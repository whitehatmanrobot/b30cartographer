));

            //
            // store the object in the file 
            //
            
            pIrpSp->FileObject->FsContext = pControlObject;
            pIrpSp->FileObject->FsContext2 = SR_CONTROL_OBJECT_CONTEXT;

            //
            // and keep a global copy
            //
            
            _globals.pControlObject = pControlObject;
            
        } finally {

            SrReleaseGlobalLock();

        }

        if (!NT_SUCCESS( Status )) {
            goto CompleteTheIrp;
        }
        
        break;

    //
    // IRP_MJ_CLOSE is called when all references are gone.
    //      Note:  this operation can not be failed.  It must succeed.
    //
        
    case IRP_MJ_CLOSE:

        pControlObject = pIrpSp->FileObject->FsContext;
        ASSERT(_globals.pControlObject == pControlObject);
        ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));
        ASSERT(pIrpSp->FileObject->FsContext2 == SR_CONTROL_OBJECT_CONTEXT);

        try {
            
            SrAcquireGlobalLockExclusive();

            //
            // delete the control object
            //
            
            Status = SrDeleteControlObject(pControlObject);
            if (!NT_SUCCESS(Status))
            {
                leave;
            }
            
            pIrpSp->FileObject->FsContext2 = NULL;
            pIrpSp->FileObject->FsContext = NULL;

            //
            // clear out the global
            //
            
            _globals.pControlObject = NULL;
            
        } finally {

            SrReleaseGlobalLock();
        }

        break;

    //
    // IRP_MJ_DEVICE_CONTROL is how most user-mode api's drop into here
    //
    
    case IRP_MJ_DEVICE_CONTROL:

        //
        // Extract the IOCTL control code and process the request.
        //

        Code = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
        FunctionCode = IoGetFunctionCodeFromCtlCode(Code);

        if (FunctionCode < SR_NUM_IOCTLS &&
            SrIoctlTable[FunctionCode].IoControlCode == Code)
        {
#if DBG
            KIRQL oldIrql = KeGetCurrentIrql();
#endif  // DBG

            Status = (SrIoctlTable[FunctionCode].Handler)( pIrp, pIrpSp );
            ASSERT( KeGetCurrentIrql() == oldIrql );

            if (!NT_SUCCESS(Status)) {
             
                goto CompleteTheIrp;
            }

        }
        else
        {
            //
            // If we made it this far, then the ioctl is invalid.
            //

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto CompleteTheIrp;
        }

        break;

    //
    // IRP_MJ_CLEANUP is called when all handles are closed
    //      Note:  this operation can not be failed.  It must succeed.
    //
    
    case IRP_MJ_CLEANUP:

        pControlObject = pIrpSp->FileObject->FsContext;
        ASSERT(_globals.pControlObject == pControlObject);
        ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));
        ASSERT(pIrpSp->FileObject->FsContext2 == SR_CONTROL_OBJECT_CONTEXT);

        try {
            
            SrAcquireGlobalLockExclusive();

            //
            // cancel all IO on this object
            //
            
            Status = SrCancelControlIo(pControlObject);
            CHECK_STATUS(Status);
            
        } finally {

            SrReleaseGlobalLock();
        }
        
        break;
        
    default:

        //
        // unsupported!
        //
        
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }

    //
    // Complete the request if we are DONE.
    //

CompleteTheIrp:
    if (Status != STATUS_PENDING) 
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT); 
        NULLPTR(pIrp);
    }

    ASSERT(Status != SR_STATUS_VOLUME_DISABLED);

#if DBG
    if (Status == STATUS_INVALID_DEVICE_REQUEST ||
        Status == STATUS_DEVICE_ALREADY_ATTACHED ||
        Status == STATUS_REVISION_MISMATCH)
    {
        //
        // don't DbgBreak on this, test tools pass garbage in normally
        // to test this code path out.
        //

        return Status;
    }
#endif

    RETURN(Status);
}   // SrMajorFunction


/***************************************************************************++

Routine Description:

Arguments:

    Handle WRITE Irps.
    NOTE:  This routine is NOT pageable.

Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PIO_STACK_LOCATION      pIrpSp;
    PSR_STREAM_CONTEXT      pFileContext;
    NTSTATUS                eventStatus;

    //
    // This cannot be paged because it is called from 
    // the paging path.
    //

    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our control device object (vs an attachee)?
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to , grab our extension
    //
    
    ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
    pExtension = DeviceObject->DeviceExtension;

    //
    //  See if logging is enabled and we don't care about this type of IO
    //  to the file systems' control device objects.
    //

    if (!SR_LOGGING_ENABLED(pExtension) ||
        SR_IS_FS_CONTROL_DEVICE(pExtension))
    {
        goto CompleteTheIrp;
    }    

    //
    // ignore all paging i/o for now.  we catch all write's prior to 
    // the cache manager even seeing them.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if (FlagOn(pIrp->Flags, IRP_PAGING_IO))
    {
        goto CompleteTheIrp;
    }

    //
    // Ignore files with no name
    //

    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pIrpSp->FileObject ) ||
        FILE_OBJECT_DOES_NOT_HAVE_VPB( pIrpSp->FileObject ))
    {
        goto CompleteTheIrp;
    }
    
    //
    //  Get the context now so we can determine if this is a
    //  directory or not
    //

    eventStatus = SrGetContext( pExtension,
                                pIrpSp->FileObject,
                                SrEventStreamChange,
                                &pFileContext );

    if (!NT_SUCCESS( eventStatus ))
    {
        goto CompleteTheIrp;
    }

    //
    //  If this is a directory don't bother logging because the
    //  operation will fail.
    //

    if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && !FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
    {
        SrHandleEvent( pExtension,
                       SrEventStreamChange, 
                       pIrpSp->FileObject,
                       pFileContext,
                       NULL, 
                       NULL );
    }

    //
    //  Release the context
    //

    SrReleaseContext( pFileContext );

    //
    // call the AttachedTo driver
    //

CompleteTheIrp:    
    IoSkipCurrentIrpStackLocation(pIrp);
    return IoCallDriver(pExtension->pTargetDevice, pIrp);
}   // SrWrite


/***************************************************************************++

Routine Description:

    Handle Cleanup IRPs

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PIO_STACK_LOCATION      pIrpSp;

    //
    // < dispatch!
    //

    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our control device object (vs an attachee)?
    //

    if (DeviceObject == _globals.pControlDevice) 
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to, grab our extension
    //
    
    ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
    pExtension = DeviceObject->DeviceExtension;

    //
    //  See if logging is enabled and we don't care about this type of IO
    //  to the file systems' control device objects.
    //

    if (!SR_LOGGING_ENABLED(pExtension) ||
        SR_IS_FS_CONTROL_DEVICE(pExtension))
    {
        goto CompleteTheIrp;
    }    

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // does this file have a name?  skip unnamed files
    //
    
    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pIrpSp->FileObject ) ||
        FILE_OBJECT_DOES_NOT_HAVE_VPB( pIrpSp->FileObject ))
    {
        goto CompleteTheIrp;
    }

    //
    // is this file about to be deleted ?  we do this here as file's can
    // be marked for deletion throughout their lifetime via 
    // IRP_MJ_SET_INFORMATION .
    //

    //
    // for delete we only clean the FCB, not the CCB delete_on_close.
    // this was handled in SrCreate.
    //

    if (pIrpSp->FileObject->DeletePending)
    {
        NTSTATUS eventStatus;
        PSR_STREAM_CONTEXT pFileContext;

        //
        //  Get the context now so we can determine if this is a directory or not
        //

        eventStatus = SrGetContext( pExtension,
                                    pIrpSp->FileObject,
                                    SrEventFileDelete,
                                    &pFileContext );

        if (!NT_SUCCESS( eventStatus ))
        {
            goto CompleteTheIrp;
        }

        //
        //  If interesting, log it
        //

        if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting))
        {
            SrHandleEvent( pExtension,
                           FlagOn(pFileContext->Flags,CTXFL_IsDirectory) ?
                                SrEventDirectoryDelete :
                                SrEventFileDelete,
                           pIrpSp->FileObject,
                           pFileContext,
                           NULL,
                           NULL);
        }

        //
        //  Release the context
        //

        SrReleaseContext( pFileContext );
    }
    
    //
    // call on to the next filter
    //
    
CompleteTheIrp:
    IoSkipCurrentIrpStackLocation(pIrp);
    return IoCallDriver(pExtension->pTargetDevice, pIrp);
}   // SrCleanup


/***************************************************************************++

Routine Description:

    Handle Create IRPS

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                eventStatus;
    NTSTATUS                IrpStatus;
    ULONG                   CreateDisposition;
    ULONG                   CreateOptions;
    USHORT                  FileAttributes;
    SR_OVERWRITE_INFO       OverwriteInfo;
    KEVENT                  waitEvent;
    PFILE_OBJECT            pFileObject;
    PSR_STREAM_CONTEXT      pFileContext = NULL;
    BOOLEAN                 willCreateUnnamedStream = TRUE;


    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our control device object (vs an attachee)?
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to, grab our extension
    //
    
    ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
    pExtension = DeviceObject->DeviceExtension;

    //
    //  See if logging is enabled and we don't care about this type of IO
    //  to the file systems' control device objects.
    //

    if (!SR_LOGGING_ENABLED(pExtension) ||
        SR_IS_FS_CONTROL_DEVICE(pExtension))
    {
        goto CompleteTheIrpAndReturn;
    }    

    //
    // Finish Initialization
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileObject = pIrpSp->FileObject;

    //
    //  does this file have a name?  skip unnamed files.  Also skip paging
    //  files.  (NULL Vpb is normal - the file is not open yet)
    //
    
    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pFileObject ) ||
	    FlagOn(pIrpSp->Flags,SL_OPEN_PAGING_FILE))
    {
        goto CompleteTheIrpAndReturn;
    }

    //
    // Finish initialization and save some information
    //

    RtlZeroMemory( &OverwriteInfo, sizeof(OverwriteInfo) );
    OverwriteInfo.Signature = SR_OVERWRITE_INFO_TAG;

    CreateOptions = pIrpSp->Parameters.Create.Options & FILE_VALID_OPTION_FLAGS;
    CreateDisposition = pIrpSp->Parameters.Create.Options >> 24;
    FileAttributes = pIrpSp->Parameters.Create.FileAttributes;

    //
    // Handle OVERWRITE and SUPERSEEDE cases.
    //
    
    if ((CreateDisposition == FILE_OVERWRITE) || 
        (CreateDisposition == FILE_OVERWRITE_IF) ||
        (CreateDisposition == FILE_SUPERSEDE))
    {
        SR_EVENT_TYPE event;
        //
        //  The file may be changed by this open so save a copy before going
        //  down to the filesystem.  
        //
        //  First get the context to determine if this is interesting.  Since
        //  this is in the PRE-Create stage we can not tell if this file
        //  has a context or not (the FsContext field is not initialized yet).
        //  We will always create a context.  Then in the Post-Create section
        //  we will see if a context was already defined.  If not we will add
        //  this context to the system.  If so then we will free this
        //  context.
        //
        //  Note: If a user opens a directory with any of these 
        //  CreateDisposition flags set, we will go down this path, treating
        //  the directory name like a file.  If the directory name is
        //  interesting, we will try to back it up and at that point we will
        //  realize that it is a directory and bail.
        //

        event = SrEventStreamOverwrite|SrEventIsNotDirectory|SrEventInPreCreate;
        if (FlagOn( CreateOptions, FILE_OPEN_BY_FILE_ID ))
        {
            event |= SrEventOpenById;
        }
        
        eventStatus = SrCreateContext( pExtension,
                                       pFileObject,
                                       event,
                                       FileAttributes,
                                       &pFileContext );

        if (!NT_SUCCESS_NO_DBGBREAK(eventStatus))
        {
            goto CompleteTheIrpAndReturn;
        }

        SrTrace( CONTEXT_LOG, ("Sr!SrCreate:              Created     (%p) Event=%06x Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               SrEventStreamOverwrite|SrEventIsNotDirectory,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                   pFileContext->StreamNameLength)/
                                   sizeof(WCHAR),
                               pFileContext->FileName.Buffer) );

        //
        //  If the file is interesting then handle it
        //

        if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting))
        {
            OverwriteInfo.pIrp = pIrp;

            eventStatus = SrHandleEvent( pExtension,
                                         SrEventStreamOverwrite, 
                                         pFileObject,
                                         pFileContext,
                                         &OverwriteInfo,
                                         NULL );

            OverwriteInfo.pIrp = NULL;

            if (!NT_SUCCESS(eventStatus))
            {
                //
                //  This context has never been linked into a list so nobody
                //  else can be refrencing it.  Release it (which will delete
                //  it since the use count is at 1.
                //

                ASSERT(pFileContext != NULL);
                ASSERT(pFileContext->UseCount == 1);

                SrReleaseContext( pFileContext );
                pFileContext = NULL;

                goto CompleteTheIrpAndReturn;
            }
        }
    }
    
    //
    //  As long as the file is not marked delete on close, if the file is simply
    //  opened, we can do not need to set a completion routine.  Otherwise,
    //  we need a completion routine so that we can see the result of the
    //  create before we do any logging work.
    //

    if (!FlagOn( CreateOptions, FILE_DELETE_ON_CLOSE ) &&
        CreateDisposition == FILE_OPEN)
    {
        goto CompleteTheIrpAndReturn;
    }

    //
    //  If this is a CREATE operation that could result in the creation of
    //  a named data stream on a file (FILE_OPEN and FILE_OVERWRITE will never
    //  create a new file), we need to see if the non-named data
    //  stream of this file already exists.  If the file already exists,
    //  then so does the non-named data stream.
    //
    
    if (((CreateDisposition == FILE_CREATE) ||
         (CreateDisposition == FILE_OPEN_IF) ||
         (CreateDisposition == FILE_SUPERSEDE) ||
         (CreateDisposition == FILE_OVERWRITE_IF)) &&
         SrFileNameContainsStream( pExtension, pFileObject, pFileContext ))
    {
        if (SrFileAlreadyExists( pExtension, pFileObject, pFileContext ))
        {
            willCreateUnnamedStream = FALSE;
        }
    }
    
    //
    //  It is an operation we may care about, go to the completion routine
    //  to handle what happened.
    //

    KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext(pIrp);
    IoSetCompletionRoutine( pIrp,
                            SrStopProcessingCompletion,
                            &waitEvent,
                            TRUE,
                            TRUE,
                            TRUE );

    
    IrpStatus = IoCallDriver(pExtension->pTargetDevice, pIrp);

    //
    //  Wait for the completion routine to be called
    //

	if (STATUS_PENDING == IrpStatus)
	{
        NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == localStatus);
	}

    //=======================================================================
    //
    //  The create operation is completed and we have re-syncronized back
    //  to the dispatch routine from the completion routine.  Handle
    //  post-create operations.
    //
    //=======================================================================

    //
    //  Load status of the operation.  We need to remember this status in 
    //  IrpStatus so that we can return it from this dispatch routine. Status
    //  we get the status of our event handling routines as we do our post-
    //  CREATE operation work.
    //

    IrpStatus = pIrp->IoStatus.Status;

    //
    //  Handle the File Overwrite/Supersede cases
    //

    if ((CreateDisposition == FILE_OVERWRITE) || 
        (CreateDisposition == FILE_OVERWRITE_IF) ||
        (CreateDisposition == FILE_SUPERSEDE))
    {
        ASSERT(pFileContext != NULL);
        ASSERT(pFileContext->UseCount == 1);

        //
        //  See if it was successful (do not change this to NU_SUCCESS macro
        //  because STATUS_REPARSE is a success code)
        //

        if (STATUS_SUCCESS == IrpStatus)
        {
            //
            //  Now that the create is completed (and we have context state in
            //  the file object) insert this context into the context hash
            //  table.  This routine will look to see if a context structure
            //  already exists for this file.  If so, it will free this
            //  structure and return the one that already existed.  It will
            //  properly ref count the context
            //

            ASSERT(pFileContext != NULL);
            ASSERT(pFileContext->UseCount == 1);

            //
            //  Check to see if we need to be concerned that this name was
            //  tunneled.  If this context is temporary and we are not going
            //  to need to use this context to log any operations, there is
            //  not need to go through this extra work.
            //

            if (!FlagOn( pFileContext->Flags, CTXFL_Temporary ) ||
                (FILE_CREATED == pIrp->IoStatus.Information))
            {
                //
                //  We are in a case where name tunneling could affect the 
                //  correctness of the name we log.
                //
                
                eventStatus = SrCheckForNameTunneling( pExtension, 
                                                       &pFileContext );

                if (!NT_SUCCESS( eventStatus ))
                {
                    goto AfterCompletionCleanup;
                }
            }
            
            SrLinkContext( pExtension,
                           pFileObject,
                           &pFileContext );

            SrTrace( CONTEXT_LOG, ("Sr!SrCreate:              Link        (%p) Event=%06x Fl=%03x Use=%d \"%.*S\"\n",
                                   pFileContext,
                                   SrEventStreamOverwrite|SrEventIsNotDirectory,
                                   pFileContext->Flags,
                                   pFileContext->UseCount,
                                   (pFileContext->FileName.Length+
                                       pFileContext->StreamNameLength)/
                                       sizeof(WCHAR),
                                   pFileContext->FileName.Buffer));
            //
            //  Handle if the file was actually created
            //

            if (FILE_CREATED == pIrp->IoStatus.Information)
            {
                //
                //  If the file is interesting, log it
                //

                if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting))
                {
                    SrHandleEvent( pExtension,
                                   ((willCreateUnnamedStream) ? 
                                        SrEventFileCreate :
                                        SrEventStreamCreate), 
                                   pFileObject,
                                   pFileContext,
                                   NULL,
                                   NULL);
                }
            }

            //
            // make sure it didn't succeed when we thought it would fail
            //

            else if (!OverwriteInfo.RenamedFile && 
                     !OverwriteInfo.CopiedFile &&
                     OverwriteInfo.IgnoredFile )
            {
                //
                // ouch, the caller's create worked, but we didn't think
                // it would.  this is a bad bug.  nothing we can do now, as
                // the file is gone.
                //

                ASSERT(!"sr!SrCreate(post complete): overwrite succeeded with NO BACKUP");

                //
                // trigger the failure notification to the service
                //

                SrNotifyVolumeError( pExtension,
                                     &pFileContext->FileName,
                                     STATUS_FILE_INVALID,
                                     SrEventStreamOverwrite );
            }
        }
        else
        {
            //
            // handle it failing when we thought it would succeed
            //

            if (OverwriteInfo.RenamedFile)
            {
                //
                // the call failed (or returned some weird info code)
                // but we renamed the file!  we need to fix it.
                //

                eventStatus = SrHandleOverwriteFailure( pExtension,
                                                        &pFileContext->FileName,
                                                        OverwriteInfo.CreateFileAttributes,
                                                        OverwriteInfo.pRenameInformation );
                                               
                ASSERTMSG("sr!SrCreate(post complete): failed to correct a failed overwrite!\n", NT_SUCCESS(eventStatus));
            }

            //
            //  The create failed, the releaseContext below will free
            //  the structure since we didn't link it into any lists
            //
        }
    }

    //
    // If it did not work, return now.  Don't bother getting a context
    //

    else if ((STATUS_REPARSE == IrpStatus) ||
             !NT_SUCCESS_NO_DBGBREAK(IrpStatus))
    {
        ASSERT(pFileContext == NULL);
    }

    //
    // is this open for DELETE_ON_CLOSE?  if so, handle the delete now,
    // we won't have any other chance until MJ_CLEANUP, and it's hard
    // to manipulate the object during cleanup.  we do not perform any
    // optimization on deletes in this manner.  kernel32!deletefile does
    // not use FILE_DELETE_ON_CLOSE so this should be rare if ever seen.
    //

    else if (FlagOn(CreateOptions, FILE_DELETE_ON_CLOSE))
    {
        //
        //  Get the context so we can see if this is a directory or not
        //

        ASSERT(pFileContext == NULL);

        eventStatus = SrGetContext( pExtension,
                                    pFileObject,
                                    SrEventFileDelete,
                                    &pFileContext );

        if (!NT_SUCCESS(eventStatus))
        {
            goto AfterCompletionCleanup;
        }

        //
        //  Log the operation.  If this is a file, we want to make sure that
        //  we don't try to rename the file into the store since it will be
        //  deleted when it is closed.  On a directory delete, we don't have
        //  this problem since we only log an entry for a directory delete
        //  and don't need to actually backup anything.
        //
        
        SrHandleEvent( pExtension,
                       (FlagOn(pFileContext->Flags,CTXFL_IsDirectory) ? 
                            SrEventDirectoryDelete :
                            (SrEventFileDelete | SrEventNoOptimization)) ,
                       pFileObject,
                       pFileContext,
                       NULL,
                       NULL );
    }

    //
    // was a brand new file just created?
    //
    
    else if ((CreateDisposition == FILE_CREATE) ||
             (pIrp->IoStatus.Information == FILE_CREATED))
    {
        ASSERT(pFileContext == NULL);

        //
        // LOG the create
        //

        SrHandleEvent( pExtension,
                       (FlagOn( CreateOptions, FILE_DIRECTORY_FILE ) ?
                            SrEventDirectoryCreate|SrEventIsDirectory :
                            (willCreateUnnamedStream ?
                                SrEventFileCreate|SrEventIsNotDirectory :
                                SrEventStreamCreate|SrEventIsNotDirectory)), 
                       pFileObject,
                       NULL,
                       NULL,
                       NULL );
    }

//
//  This is for doing any cleanup that occured after we synced with
//  the completion routine
//

AfterCompletionCleanup:

    if (OverwriteInfo.pRenameInformation != NULL)
    {
        SR_FREE_POOL( OverwriteInfo.pRenameInformation, 
                      SR_RENAME_BUFFER_TAG );
                      
        NULLPTR(OverwriteInfo.pRenameInformation);
    }

    if (NULL != pFileContext)
    {
        SrReleaseContext( pFileContext );
        NULLPTR(pFileContext);
    }

    //
    //  Complete the request and return status
    //

    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return IrpStatus;

//
//  We come here if we got an error before the completion routine.  This
//  means we don't need to wait for the completion routine.
//

CompleteTheIrpAndReturn:
    IoSkipCurrentIrpStackLocation(pIrp);
    return IoCallDriver(pExtension->pTargetDevice, pIrp);
}   // SrCreate


/***************************************************************************++

Routine Description:

    Handle SetSecurit IRPS

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrSetSecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PIO_STACK_LOCATION      pIrpSp;

    //
    // < dispatch!
    //

    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our device (vs an attachee) .
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to, grab our extension
    //
    
    ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
    pExtension = DeviceObject->DeviceExtension;

    //
    //  See if logging is enabled and we don't care about this type of IO
    //  to the file systems' control device objects.
    //

    if (!SR_LOGGING_ENABLED(pExtension)||
        SR_IS_FS_CONTROL_DEVICE(pExtension))
    {
        goto CompleteTheIrp;
    }    

    //
    // does this file have a name?  skip unnamed files
    //
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pIrpSp->FileObject ) ||
        FILE_OBJECT_DOES_NOT_HAVE_VPB( pIrpSp->FileObject ))
    {
        goto CompleteTheIrp;
    }

    //
    // log the change
    //

    SrHandleEvent( pExtension, 
                   SrEventAclChange, 
                   pIrpSp->FileObject,
                   NULL,
                   NULL,
                   NULL);

    //
    // call the AttachedTo driver
    //
    
CompleteTheIrp:
    IoSkipCurrentIrpStackLocation(pIrp);
    return IoCallDriver(pExtension->pTargetDevice, pIrp);
}   // SrSetSecurity


/***************************************************************************++

Routine Description:

    handles IRP_MJ_FILE_SYSTEM_CONTROL.  the main thing we watch for here
    are set reparse points to monitor volume mounts.

Arguments:

    DeviceObject - the device object being processed

    pIrp - the irp

Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrFsControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION    pExtension = NULL;
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   FsControlCode;
    PIO_COMPLETION_ROUTINE  pCompletionRoutine = NULL;

    PAGED_CODE();

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);
    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our control device object (vs an attachee)?
    //

    if (pDeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(pDeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to , grab our extension
    //

    ASSERT(IS_SR_DEVICE_OBJECT(pDeviceObject));
    pExtension = pDeviceObject->DeviceExtension;

    //
    //  Begin by determining the minor function code for this file 
    //  system control function.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if ( pIrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME ) 
    {

        if (SR_IS_SUPPORTED_REAL_DEVICE(pIrpSp->Parameters.MountVolume.Vpb->RealDevice)) {

            //
            //  We mount devices even if we are disabled right now so that the
            //  filter can be enabled later and already be attached to each
            //  device at the appropriate location in the stack.
            //
            
            return SrFsControlMount( pDeviceObject, pExtension, pIrp );
            
        } else {

            //
            //  We don't care about this type of device so jump down to where
            //  we take SR out of the stack and pass the IO through.
            //

            goto SrFsControl_Skip;
        }
    } 
    else if (pIrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST)
    {
        //
        //  See if logging is enabled and we don't care about this type of IO
        //  to the file systems' control device objects.
        //

        if (!SR_LOGGING_ENABLED(pExtension) ||
            SR_IS_FS_CONTROL_DEVICE(pExtension))
        {
            goto SrFsControl_Skip;
        }    

        FsControlCode = pIrpSp->Parameters.FileSystemControl.FsControlCode;

        switch (FsControlCode) {
            case FSCTL_SET_REPARSE_POINT:
            case FSCTL_DELETE_REPARSE_POINT:

                //
                //  In this case, we need to do work after the IO has completed
                //  and we have synchronized back to this thread, so 
                //  SrFsControlReparsePoint contains the call to IoCallDriver and
                //  we just want to return the status of this routine.
                //

                return SrFsControlReparsePoint(pExtension, pIrp);

            case FSCTL_LOCK_VOLUME:

                SrTrace( NOTIFY, ("sr!SrFsControl:FSCTL_LOCK_VOLUME(%wZ)\n", 
                         pExtension->pNtVolumeName ));

                SrFsControlLockOrDismount(pExtension, pIrp);
            
                //
                //  Jump down to where take SR out of the stack and pass this
                //  IO through.
                //

                goto SrFsControl_Skip;

            case FSCTL_DISMOUNT_VOLUME:
        
                SrTrace( NOTIFY, ("sr!SrFsControl:FSCTL_DISMOUNT_VOLUME(%wZ)\n", 
                         pExtension->pNtVolumeName ));

                //
                //  First, disable the log while we shutdown the log context
                //  and wait for the filesystem to handle the dismount.  If
                //  the dismount fails, we will reenable the volume.
                //

                pExtension->Disabled = TRUE;

                //
                //  Stop the logging on the volume.
                //
                
                SrFsControlLockOrDismount(pExtension, pIrp);

                //
                //  We need to see the completion of this operation so we
                //  can see the final status.  If we see that the dismount has 
                //  failed, we need to reenable the volume.
                //

                pCompletionRoutine = SrDismountCompletion;

                goto SrFsControl_SetCompletion;

            case FSCTL_WRITE_RAW_ENCRYPTED:

                SrFsControlWriteRawEncrypted(pExtension, pIrp);

                //
                //  Jump down to where take SR out of the stack and pass this
                //  IO through.
                //

                goto SrFsControl_Skip;

            case FSCTL_SET_SPARSE:

                SrFsControlSetSparse( pExtension, pIrp );
                
                //
                //  Jump down to where take SR out of the stack and pass this
                //  IO through.
                //

                goto SrFsControl_Skip;
                
            default:

                //
                //  For all other FSCTL just skip the current IRP stack location.
                //

                //
                //  Jump down to where take SR out of the stack and pass this
                //  IO through.
                //

                goto SrFsControl_Skip;

        }   // switch (FsControlCode)
        
    }   // else if (pIrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST)
    else
    {
        //
        //  We don't care about any other operations so simply get out of
        //  the stack.
        //

        goto SrFsControl_Skip;
    }

SrFsControl_SetCompletion:

    ASSERT( pCompletionRoutine != NULL );

    IoCopyCurrentIrpStackLocationToNext(pIrp);
    
    IoSetCompletionRoutine( pIrp,
                            pCompletionRoutine,
                            NULL,   // CompletionContext
                            TRUE,
                            TRUE,
                            TRUE );

    return IoCallDriver( pExtension->pTargetDevice, pIrp );

SrFsControl_Skip:

    ASSERT( pCompletionRoutine == NULL );

    IoSkipCurrentIrpStackLocation( pIrp );
    return IoCallDriver( pExtension->pTargetDevice, pIrp );
}   // SrFsControl


/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrFsControlReparsePoint (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    PREPARSE_DATA_BUFFER pReparseHeader;
    PUNICODE_STRING pMountVolume = NULL;
    PFILE_OBJECT pFileObject = NULL;
    ULONG TotalLength;
    PIO_STACK_LOCATION pIrpSp;
    KEVENT EventToWaitOn;
    NTSTATUS IrpStatus;
    NTSTATUS eventStatus;
    ULONG FsControlCode;
    PSR_STREAM_CONTEXT pFileContext = NULL;
    BOOLEAN isFile = FALSE;
#if DBG

    //
    //  This is to verify that the original request gets the same error
    //  we got when querying the reparse point.
    //
    
    BOOLEAN ExpectError = FALSE;
    NTSTATUS ExpectedErrorCode = STATUS_SUCCESS;
#endif

    PAGED_CODE();

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    FsControlCode = pIrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  See if it has a name
    //

    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pIrpSp->FileObject ) ||
        FILE_OBJECT_DOES_NOT_HAVE_VPB( pIrpSp->FileObject ))
    {
        goto SrFsControlReparsePoint_SkipFilter;
    }
        
    //
    //  Get the context now so we can determine if this is a directory or not
    //

    eventStatus = SrGetContext( pExtension,
                                pIrpSp->FileObject,
                                SrEventInvalid,
                                &pFileContext );

    if (!NT_SUCCESS( eventStatus ))
    {
        goto SrFsControlReparsePoint_SkipFilter;
    }

    //
    //  If it is not a directory, return
    //

    if (!FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
    {
        isFile = TRUE;
        goto SrFsControlReparsePoint_SkipFilter;
    }

    //
    // is there enough space for the header?
    //

    pReparseHeader = pIrp->AssociatedIrp.SystemBuffer;

    if (pReparseHeader == NULL ||
        pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            REPARSE_DATA_BUFFER_HEADER_SIZE)
    {
        goto SrFsControlReparsePoint_SkipFilter;
    }

    //
    // is this a mount point?
    //

    if (pReparseHeader->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT)
    {
        goto SrFsControlReparsePoint_SkipFilter;
    }

    //
    // keep a copy for post processing
    //

    pFileObject = pIrpSp->FileObject;
    ObReferenceObject(pFileObject);

    //
    // now let's see what we have to do
    //

    if (FsControlCode == FSCTL_SET_REPARSE_POINT)
    {

        //
        //  If there is no data this is invalid
        //

        if (pReparseHeader->ReparseDataLength <= 0)
        {
            goto SrFsControlReparsePoint_SkipFilter;
        }

        //
        // is there enough space for the header + data?
        // (according to him - not trusted)
        //
        //
        
        if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            pReparseHeader->ReparseDataLength + ((ULONG)REPARSE_DATA_BUFFER_HEADER_SIZE))
        {
            goto SrFsControlReparsePoint_SkipFilter;
        }

        //
        // did he lie about the length of the string?
        //
        
        TotalLength = DIFF( (((PUCHAR)pReparseHeader->MountPointReparseBuffer.PathBuffer) 
                                + pReparseHeader->MountPointReparseBuffer.SubstituteNameLength)
                             - ((PUCHAR)pReparseHeader) );

        if (TotalLength > 
            pIrpSp->Parameters.DeviceIoControl.InputBufferLength)
        {
            goto SrFsControlReparsePoint_SkipFilter;
        }

        //
        // grab the volume name
        //

        eventStatus = SrAllocateFileNameBuffer( pReparseHeader->MountPointReparseBuffer.SubstituteNameLength,
                                                &pMountVolume );

        if (!NT_SUCCESS(eventStatus))
        {
            goto SrFsControlReparsePoint_VolumeError;
        }

        RtlCopyMemory( pMountVolume->Buffer,
                       pReparseHeader->MountPointReparseBuffer.PathBuffer,
                       pReparseHeader->MountPointReparseBuffer.SubstituteNameLength );
                       
        pMountVolume->Length = pReparseHeader->MountPointReparseBuffer.SubstituteNameLength;
    }
    else 
    {
        ASSERT(FsControlCode == FSCTL_DELETE_REPARSE_POINT);

        //
        // it's a delete, get the old mount location for logging
        //
        
        eventStatus = SrGetMountVolume( pFileObject,
                                        &pMountVolume );

        if (eventStatus == STATUS_INSUFFICIENT_RESOURCES)
        {
            //
            //  Must notify service of volume error and shut down
            //  before passing the IO through.
            //

            goto SrFsControlReparsePoint_VolumeError;
        }

#if DBG 
        if (!NT_SUCCESS_NO_DBGBREAK( eventStatus ))
        {
            ExpectError = TRUE;
            ExpectedErrorCode = eventStatus;
            goto SrFsControlReparsePoint_SkipFilter;
        }
#else            
        if (!NT_SUCCESS( eventStatus ))
        {
            goto SrFsControlReparsePoint_SkipFilter;
        }
#endif            
    }

    //
    //  If we get to this point, this is a reparse point we care about
    //  so set a completion routine so that we can see the result of this
    //  operation.
    //
    
    KeInitializeEvent( &EventToWaitOn, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext( pIrp );
    IoSetCompletionRoutine( pIrp,
                            SrStopProcessingCompletion,
                            &EventToWaitOn,
                            TRUE,
                            TRUE,
                            TRUE );

    IrpStatus = IoCallDriver( pExtension->pTargetDevice, pIrp );

    if (STATUS_PENDING == IrpStatus )
    {
        NTSTATUS localStatus = KeWaitForSingleObject( &EventToWaitOn,
                                                      Executive,
                                                      KernelMode,
                                                      FALSE,
                                                      NULL );
        ASSERT(STATUS_SUCCESS == localStatus);
    }

    //
    //  The Irp is still good since we have returned
    //  STATUS_MORE_PROCESSING_REQUIRED from the completion
    //  routine.
    //

    //
    //  If the status in the IRP was STATUS_PENDING,
    //  we want to change the status to STATUS_SUCCESS
    //  since we have just performed the necessary synchronization
    //  with the orginating thread.
    //

    if (pIrp->IoStatus.Status == STATUS_PENDING)
    {
        ASSERT(!"I want to see if this ever happens");
        pIrp->IoStatus.Status = STATUS_SUCCESS;
    }
    
    IrpStatus = pIrp->IoStatus.Status;

    //
    //  We are done with the Irp, so complete the Irp.
    //

    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    //
    //  Now these pointers are no longer valid.
    //
    
    NULLPTR(pIrp);
    NULLPTR(pIrpSp);

    //
    //  Check to make sure the operation successfully
    //  completed.
    //
    
    if (!NT_SUCCESS_NO_DBGBREAK(IrpStatus))
    {
        goto SrFsControlReparsePoint_Exit;
    }
    
    //
    // The reparse point change occurred successfully, so
    // log the reparse point change.
    //

    ASSERT(pFileObject != NULL);
    ASSERT(pFileContext != NULL);
    ASSERT(FlagOn(pFileContext->Flags,CTXFL_IsDirectory));
    ASSERT(FsControlCode == FSCTL_DELETE_REPARSE_POINT ||
           FsControlCode == FSCTL_SET_REPARSE_POINT);
    
    SrHandleEvent( pExtension,
                   ((FSCTL_SET_REPARSE_POINT == FsControlCode) ?
                        SrEventMountCreate :
                        SrEventMountDelete),
                   pFileObject,
                   pFileContext,
                   NULL,
                   pMountVolume );

    goto SrFsControlReparsePoint_Exit;

SrFsControlReparsePoint_VolumeError:

    //
    //  We've gotten a volume error sometime before we passed the IRP
    //  along to the base file system.  Do the right thing to shut down
    //  the volume logging.
    //

    SrNotifyVolumeError( pExtension,
                         NULL,
                         eventStatus,
                         SrNotificationVolumeError );
    //
    //  We will now fall through to skip our filter as we pass the IO
    //  down to the remaining filters and file system.
    //
    
SrFsControlReparsePoint_SkipFilter:

    //
    //  If this was a file, we need to clear out our context on this file
    //  since we don't want to monitor files with Reparse Points.  On the
    //  next access to this file, we will requery this information.
    //

    if (isFile)
    {
        ASSERT( pFileContext != NULL );
        SrDeleteContext( pExtension, pFileContext );
    }
        
    //
    //  We don't need a completion routine, call to next driver
    //

    IoSkipCurrentIrpStackLocation( pIrp );
    IrpStatus = IoCallDriver( pExtension->pTargetDevice, pIrp );

    NULLPTR(pIrp);
    NULLPTR(pIrpSp);

    ASSERT(!ExpectError || ((ExpectedErrorCode == IrpStatus) || 
                            (STATUS_PENDING == IrpStatus )));
    
//
//  Cleanup state
//

SrFsControlReparsePoint_Exit:

    if (NULL != pMountVolume)
    {
        SrFreeFileNameBuffer( pMountVolume );
        NULLPTR(pMountVolume);
    }

    if (NULL != pFileObject)
    {
        ObDereferenceObject( pFileObject );
        NULLPTR(pFileObject);
    }

    if (NULL != pFileContext)
    {
        SrReleaseContext( pFileContext );
        NULLPTR(pFileContext);
    }

    return IrpStatus;
}

/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrFsControlMount (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    PIO_STACK_LOCATION pIrpSp;
    PDEVICE_OBJECT pNewDeviceObject = NULL;
    KEVENT EventToWaitOn;
    PVPB pVpb = NULL;
    PDEVICE_OBJECT pRealDevice;
    NTSTATUS Status;
    
    PAGED_CODE();

    ASSERT( SR_IS_FS_CONTROL_DEVICE(pExtension) );
    
    //
    // create our device we are going to attach to this new volume
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    pRealDevice = pIrpSp->Parameters.MountVolume.Vpb->RealDevice;
    
    Status = SrCreateAttachmentDevice( pRealDevice, 
                                       pDeviceObject,
                                       &pNewDeviceObject );

    if (!NT_SUCCESS( Status ))
    {
        IoSkipCurrentIrpStackLocation( pIrp );
        return IoCallDriver( pExtension->pTargetDevice, pIrp );
    }

    //
    //  If we get here, we need to set our completion routine then
    //  wait for it to signal us before we continue with the post processing
    //  of the mount.
    //

    KeInitializeEvent( &EventToWaitOn, NotificationEvent, FALSE );
    
    IoCopyCurrentIrpStackLocationToNext(pIrp);

    IoSetCompletionRoutine( pIrp,
                            SrStopProcessingCompletion,
                            &EventToWaitOn,   // CompletionContext
                            TRUE,
                            TRUE,
                            TRUE );

    pIrpSp->Parameters.MountVolume.DeviceObject = 
                    pIrpSp->Parameters.MountVolume.Vpb->RealDevice;
    

    Status = IoCallDriver( pExtension->pTargetDevice, pIrp );

    if (STATUS_PENDING == Status)
    {
        NTSTATUS localStatus = KeWaitForSingleObject( &EventToWaitOn,
                                                      Executive,
                                                      KernelMode,
                                                      FALSE,
                                                      NULL );
        ASSERT( NT_SUCCESS( localStatus ) );
    }

    //
    // skip out if the mount failed
    //
    
    if (!NT_SUCCESS_NO_DBGBREAK(pIrp->IoStatus.Status))
    {
        goto SrFsControlMount_Error;
    }

    //
    //  Note that the VPB must be picked up from the real device object
    //  so that we can see the DeviceObject that the file system created
    //  to represent this newly mounted volume.
    //

    pVpb = pRealDevice->Vpb;
    ASSERT(pVpb != NULL);

    //
    // SrFsControl made sure that we support this volume type
    //
    
    ASSERT(SR_IS_SUPPORTED_VOLUME(pVpb));

    //
    // are we already attached to this device?
    //
    
    if (NT_SUCCESS( pIrp->IoStatus.Status ) && 
        (SrGetFilterDevice(pVpb->DeviceObject) == NULL))
    {
        //
        // now attach to the new volume
        //
    
        Status = SrAttachToDevice( pVpb->RealDevice, 
                                   pVpb->DeviceObject, 
                                   pNewDeviceObject,
                                   NULL );
                                   
        if (NT_SUCCESS(Status))
        {
            goto SrFsControlMount_Exit;
        }
    }

SrFsControlMount_Error:

    ASSERT( pNewDeviceObject != NULL );
    SrDeleteAttachmentDevice( pNewDeviceObject );
    
SrFsControlMount_Exit:

    Status = pIrp->IoStatus.Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrFsControlLockOrDismount (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    UNREFERENCED_PARAMETER( pIrp );
    PAGED_CODE();

    try {
        //
        // close our log file handle on this volume , it's being
        // locked.  it's ok if the lock attempt fails, we will open
        // our handle again automatically since DriveChecked is also
        // being cleared.
        //

        SrAcquireActivityLockExclusive( pExtension);

        if (pExtension->pLogContext != NULL)
        {
            Status = SrLogStop( pExtension, TRUE, FALSE );
            CHECK_STATUS( Status );
        }
        
    } finally {

        SrReleaseActivityLock(pExtension);
    }

    return Status;
}


/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
VOID
SrFsControlWriteRawEncrypted (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    PIO_STACK_LOCATION pIrpSp;
    NTSTATUS Status;
    PSR_STREAM_CONTEXT pFileContext = NULL;

    PAGED_CODE();

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pIrpSp->FileObject ) ||
        FILE_OBJECT_DOES_NOT_HAVE_VPB( pIrpSp->FileObject )) {

        return;
    }
    
    //
    //  Look up the context for this file object so that we can figure out
    //  if this is a file or a directory.  If this is a directory, the 
    //  file system will fail the operation, so there is no need to try to
    //  back it up.
    //

    Status = SrGetContext( pExtension,
                           pIrpSp->FileObject,
                           SrEventStreamChange,
                           &pFileContext );

    if (!NT_SUCCESS( Status )) 
    {

        //
        //  We hit some error trying to get the context.  If this should
        //  generate a volume error, it has already been taken care of inside
        //  SrGetContext.  Otherwise, this just means that the actual operation
        //  will fail, so there is no work for us to do here.
        //

        return;
    }

    ASSERT( NULL != pFileContext );

    //
    //  Make sure that we have an interesting file.  This operation
    //  is invalid on directories.
    //

    if (FlagOn( pFileContext->Flags, CTXFL_IsInteresting )&&
        !FlagOn( pFileContext->Flags, CTXFL_IsDirectory )) 
    {
        SrHandleEvent( pExtension, 
                       SrEventStreamChange,
                       pIrpSp->FileObject,
                       pFileContext,
                       NULL,
                       NULL );
    }

    //
    //  We are all done with this context, so now release it.
    //
    
    ASSERT( NULL != pFileContext );
    
    SrReleaseContext( pFileContext );
    NULLPTR(pFileContext);

    return;
}

/***************************************************************************++

Routine Description:

    When a file is set to sparse, we need to clear out our context for this
    file.  On the next interesting operation for this file, we will regenerate
    a correct context.

    This work is done since SR doesn't want to monitor files that are SPARSE.

Arguments:


Return Value:

    None.

--***************************************************************************/
VOID
SrFsControlSetSparse (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT pFileObject;
    PSR_STREAM_CONTEXT pFileContext = NULL;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( pIrp );
    pFileObject = irpSp->FileObject;

    pFileContext = SrFindExistingContext( pExtension, pFileObject );

    if (pFileContext != NULL)
    {
        SrDeleteContext( pExtension, pFileContext );
        SrReleaseContext( pFileContext );
    }

    return;
}

/***************************************************************************++

Routine Description:

    handles IRP_MJ_PNP.  SR needs to close its handle to the log when it sees 
    that the volume is going away and reopen it when the drive reappears.

Arguments:

    DeviceObject - the device object being processed

    pIrp - the irp

Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSR_DEVICE_EXTENSION pExtension;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();
    
    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(Irp));

    //
    // Get this driver out of the driver stack and get to the next driver as
    // quickly as possible.
    //

    //
    // Is this a function for our device (vs an attachee) .
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, Irp);
    }

    //
    // else it is a device we've attached to, grab our extension
    //
    
    ASSERT( IS_SR_DEVICE_OBJECT( DeviceObject ) );
    pExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:

        SrTrace( PNP, ( "SR!SrPnp: QUERY_REMOVE_DEVICE [%wZ]\n",
                        pExtension->pNtVolumeName ) );

        //
        //  If this is a SURPRISE_REMOVAL, the device has already gone away 
        //  and we are not going to see any more operations to this volume, but
        //  the OS won't call us to detach and delete our device object until
        //  all the handles that are outstanding on this volume are closed.  Do
        //  our part by closing down the handle to our log.
        //
        
        try {
        
            SrAcquireActivityLockExclusive( pExtension );

            pExtension->Disabled = TRUE;

            if (pExtension->pLogContext != NULL)
            {
                SrLogStop( pExtension, TRUE, FALSE );
            }
            
        } finally {

            SrReleaseActivityLock( pExtension );
        }
        
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        
        SrTrace( PNP, ( "SR!SrPnp: SURPRISE_REMOVAL [%wZ]\n",
                        pExtension->pNtVolumeName ) );
        
        //
        //  If this is a SURPRISE_REMOVAL, the device has already gone away 
        //  and we are not going to see any more operations to this volume, but
        //  the OS won't call us to detach and delete our device object until
        //  all the handles that are outstanding on this volume are closed.  Do
        //  our part by closing down the handle to our log.
        //

        try {
        
            SrAcquireActivityLockExclusive( pExtension );

            pExtension->Disabled = TRUE;

            if (pExtension->pLogContext != NULL)
            {
                SrLogStop( pExtension, TRUE, FALSE );
            }
            
        } finally {

            SrReleaseActivityLock( pExtension );
        }
        
        break;
        
    case IRP_MN_CANCEL_REMOVE_DEVICE:

        SrTrace( PNP, ( "SR!SrPnp: CANCEL_REMOVE_DEVICE [%wZ]\n",
                        pExtension->pNtVolumeName ) );
        //
        //  The removal is not going to happen, so reenable the device and
        //  the log will be restarted on the next interesting operation.
        //

        if (pExtension->Disabled) {

            try {

                SrAcquireActivityLockExclusive( pExtension );
                pExtension->Disabled = FALSE;
                
            } finally {
            
                SrReleaseActivityLock( pExtension );
            }
        }
            
        break;
        
    default:

        //
        //  All PNP minor codes we don't care about, so just pass
        //  the IO through.
        //
        
        break;
    }    

    //
    //  If we have gotten here, we don't need to wait to see the result of this
    //  operation, so just call the appropriate file system driver with 
    //  the request.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( pExtension->pTargetDevice, Irp );
}

/***************************************************************************++

Routine Description:

    this does the actual work for creating a new restore point.
    
    this is called by the user mode SrCreateRestorePoint .

    this IOCTL is METHOD_BUFFERED !

Arguments:

    pIrp - the irp
    
    pIrpSp - the irp stack

Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrCreateRestorePointIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS        Status;
    PUNICODE_STRING pVolumeName = NULL;
    PLIST_ENTRY     pListEntry;
    PSR_DEVICE_EXTENSION pExtension;
    BOOLEAN releaseActivityLocks = TRUE;
    PSR_DEVICE_EXTENSION pSystemVolumeExtension = NULL;

    PAGED_CODE();

    ASSERT(IS_VALID_IRP(pIrp));

    SrTrace( IOCTL, ("SR!SrCreateRestorePointIoctl -- ENTER\n") );
    
    try {

        //
        //  Grab the device extension list lock since we are 
        //  going to have to pause all the volume activity.
        //

        SrAcquireDeviceExtensionListLockShared();
        
        //
        //  We've got the device extension lock, so now try to pause
        //  activity on all the volumes.
        //

        Status = SrPauseVolumeActivity();

        if (!NT_SUCCESS( Status )) {

            releaseActivityLocks = FALSE;
            leave;
        }

        try {

            SrAcquireGlobalLockExclusive();
            
            //
            // make sure we've loaded the config file
            //
            
            if (!_globals.FileConfigLoaded)
            {

                Status = SrReadConfigFile();
                if (!NT_SUCCESS(Status))
                    leave;

                _globals.FileConfigLoaded = TRUE;
            }
        } finally {

            SrReleaseGlobalLock();
        }

        if (!NT_SUCCESS( Status )) {
            leave;
        }

        //
        // Clear the volumes' DriveChecked flag so that we check the volumes 
        // again. this will create the restore point directories.
        //
        // also stop logging on all volumes. new log files will be created in 
        // the restore locations.
        //
        //  We need to do this before we increment the current restore point
        //  counter.
        //
        
        for (pListEntry = _globals.DeviceExtensionListHead.Flink;
             pListEntry != &_globals.DeviceExtensionListHead;
             pListEntry = pListEntry->Flink)
        {
            pExtension = CONTAINING_RECORD( pListEntry,
                                            SR_DEVICE_EXTENSION,
                                            ListEntry );
            
            ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

            //
            //  We only have to do work if this is a volume device object,
            //  not if this is a device object that is attached to a file
            //  system's control device object.
            //
            
            if (FlagOn( pExtension->FsType, SrFsControlDeviceObject ))
            {
                continue;
            }

            //
            // stop logging for this volume
            //
            
            if (pExtension->pLogContext != NULL)
            {
                Status = SrLogStop( pExtension, FALSE, TRUE );
                CHECK_STATUS( Status );
            }
            else
            {
                ASSERT(!pExtension->DriveChecked);
                Status = SrLogNormalize( pExtension );
                CHECK_STATUS( Status );
            }

            //
            // make sure to enable all of the volumes again.  If the user
            // has disabled the volume, this is tracked in the blob info.
            //

            pExtension->Disabled = FALSE;
            
            //
            // make sure the drive is checked again for the new restore point
            //
            
            pExtension->DriveChecked = FALSE;

            //
            // reset the byte count, it's a new restore point
            //

            pExtension->BytesWritten = 0;

            //
            // clear out the backup history so that we start backing 
            // up files again
            //

            Status = SrResetBackupHistory(pExtension, NULL, 0, SrEventInvalid);
            
            if (!NT_SUCCESS(Status))
                leave;
        }

        try {

            SrAcquireGlobalLockExclusive();
            
            //
            // bump up the restore point number
            //

            _globals.FileConfig.CurrentRestoreNumber += 1;

            SrTrace( INIT, ("sr!SrCreateRestorePointIoctl: RestorePoint=%d\n", 
                     _globals.FileConfig.CurrentRestoreNumber ));

            //
            // save out the config file
            //

            Status = SrWriteConfigFile();
            if (!NT_SUCCESS(Status))
                leave;
        } finally {

            SrReleaseGlobalLock();
        }

        if (!NT_SUCCESS( Status )) {
            leave;
        }

        //
        // allocate space for a filename
        //

        Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pVolumeName);
        if (!NT_SUCCESS(Status))
            leave;

        //
        // get the location of the system volume
        //

        Status = SrGetSystemVolume( pVolumeName,
                                    &pSystemVolumeExtension,
                                    SR_FILENAME_BUFFER_LENGTH );
                                        
        //
        //  This should only happen if there was some problem with SR attaching
        //  in the mount path.  This check was added to make SR more robust to
        //  busted filters above us.  If other filters cause us to get mounted,
        //  we won't have an extension to return here.  While those filters are
        //  broken, we don't want to AV.
        //

        if (pSystemVolumeExtension == NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
            leave;
        }
                                        
        if (!NT_SUCCESS(Status))
            leave;

        ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pSystemVolumeExtension ) );
        
        //
        // create the restore point dir on the system volume
        //

        Status = SrCreateRestoreLocation( pSystemVolumeExtension );
        if (!NT_SUCCESS(Status))
            leave;

        //
        // return the restore point number
        //

        if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >= 
                sizeof(ULONG))
        {

            RtlCopyMemory( pIrp->AssociatedIrp.SystemBuffer, 
                           &_globals.FileConfig.CurrentRestoreNumber,
                           sizeof(ULONG) );

            pIrp->IoStatus.Information = sizeof(ULONG);                       
        }
        
        //
        // all done
        //
        
    } finally {

        Status = FinallyUnwind(SrCreateRestorePointIoctl, Status);

        if (releaseActivityLocks) {

            SrResumeVolumeActivity ();
        }
        
        SrReleaseDeviceExtensionListLock();

        if (pVolumeName != NULL)
        {
            SrFreeFileNameBuffer(pVolumeName);
            pVolumeName = NULL;
        }
    }

    SrTrace( IOCTL, ("SR!SrCreateRestorePointIoctl -- EXIT -- status 0x%08lx\n",
                     Status));

    //
    // At this point if Status != PENDING, the ioctl wrapper will
    // complete pIrp
    //

    RETURN(Status);
    
}   // SrCreateRestorePointIoctl

/***************************************************************************++

Routine Description:

    this does the actual work for getting the next seq number from the filter
    
    this is called by the user mode SrGetNextSequenceNum .

    this IOCTL is METHOD_BUFFERED !

Arguments:

    pIrp - the irp
    
    pIrpSp - the irp stack

Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrGetNextSeqNumIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(IS_VALID_IRP(pIrp));

    SrTrace( IOCTL, ("SR!SrGetNextSeqNumIoctl -- ENTER\n") );
    
    try
    {
        INT64 SeqNum = 0;
    
        //
        // grab the global lock
        //
    
        SrAcquireGlobalLockExclusive();
    
        //
        // make sure we've loaded the config file
        //
        
        if (!_globals.FileConfigLoaded)
        {
    
            Status = SrReadConfigFile();
            if (!NT_SUCCESS(Status))
                leave;
    
            _globals.FileConfigLoaded = TRUE;
        }
    
        //
        // Get the next sequence number
        //
    
        Status = SrGetNextSeqNumber(&SeqNum);
    
        if (NT_SUCCESS(Status))
        {
            //
            // return the restore point number
            //
        
            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >= 
                    sizeof(INT64))
            {
        
                RtlCopyMemory( pIrp->AssociatedIrp.SystemBuffer, 
                               &SeqNum,
                               sizeof(INT64) );
        
                pIrp->IoStatus.Information = sizeof(INT64);                       
            }
        }
    }
    finally
    {
        Status = FinallyUnwind(SrGetNextSeqNumIoctl, Status);

        SrReleaseGlobalLock();
    }

    SrTrace( IOCTL, ("SR!SrGetNextSeqNumIoctl -- EXIT -- status 0x%08lx\n",
                     Status) );

    //
    // At this point if Status != PENDING, the ioctl wrapper will
    // complete pIrp
    //

    RETURN(Status);
    
}   // SrGetNextSeqNumIoctl

NTSTATUS
SrReloadConfigurationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS        Status    = STATUS_UNSUCCESSFUL;
    PUNICODE_STRING pFileName = NULL;
    ULONG           CharCount;
    PLIST_ENTRY     pListEntry;
    PSR_DEVICE_EXTENSION pExtension;
    BOOLEAN releaseDeviceExtensionListLock = FALSE;
    PSR_DEVICE_EXTENSION pSystemVolumeExtension = NULL;

    UNREFERENCED_PARAMETER( pIrp );
    UNREFERENCED_PARAMETER( IrpSp );

    PAGED_CODE();

    SrTrace( IOCTL, ("SR!SrReloadConfigurationIoctl -- ENTER\n") );

    try {

        //
        // allocate space for a filename
        //

        Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pFileName);
        if (!NT_SUCCESS(Status))
            leave;

        //
        // get the location of the system volume
        //

        Status = SrGetSystemVolume( pFileName,
                                    &pSystemVolumeExtension,
                                    SR_FILENAME_BUFFER_LENGTH );
                                        
        //
        //  This should only happen if there was some problem with SR attaching
        //  in the mount path.  This check was added to make SR more robust to
        //  busted filters above us.  If other filters cause us to get mounted,
        //  we won't have an extension to return here.  While those filters are
        //  broken, we don't want to AV.
        //
        
        if (pSystemVolumeExtension == NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
            leave;
        }
                                    
        if (!NT_SUCCESS(Status))
            leave;

        ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pSystemVolumeExtension ) );
        
        //
        // load the file list config data 
        //

        CharCount = swprintf( &pFileName->Buffer[pFileName->Length/sizeof(WCHAR)],
                              RESTORE_FILELIST_LOCATION,
                              _globals.MachineGuid );

        pFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

        Status = SrReloadLookupBlob( pFileName, 
                                     pSystemVolumeExtension->pTargetDevice,
                                     &_globals.BlobInfo ); 
        if (!NT_SUCCESS(Status))
        {
            leave;
        }

        //
        // flush our volume configuration, it needs to be reconfigured as to
        // which drives are enabled or not
        //

        //
        // loop over all volumes reseting their disabled config
        //

        SrAcquireDeviceExtensionListLockShared();
        releaseDeviceExtensionListLock = TRUE;

        for (pListEntry = _globals.DeviceExtensionListHead.Flink;
             pListEntry != &_globals.DeviceExtensionListHead;
             pListEntry = pListEntry->Flink)
        {
            pExtension = CONTAINING_RECORD( pListEntry,
                                            SR_DEVICE_EXTENSION,
                                            ListEntry );
            
            ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

            try {

                SrAcquireActivityLockExclusive( pExtension );
                pExtension->Disabled = FALSE;
                
            } finally {
            
                SrReleaseActivityLock( pExtension );
            }
        }
            

    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrReloadConfigurationIoctl, Status);

        if (releaseDeviceExtensionListLock) {
            SrReleaseDeviceExtensionListLock();
        }

        if (pFileName != NULL)
        {
            SrFreeFileNameBuffer(pFileName);
            pFileName = NULL;
        }
    }

    SrTrace( IOCTL, ("SR!SrReloadConfigurationIoctl -- EXIT -- status 0x%08lx\n",
                     Status));
    RETURN(Status);
    
}   // SrReloadConfigurationIoctl

NTSTATUS
SrSwitchAllLogsIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS Status;
    PAGED_CODE();

    UNREFERENCED_PARAMETER( pIrp );
    UNREFERENCED_PARAMETER( IrpSp );

    SrTrace( IOCTL, ("SR!SrSwitchAllLogsIoctl -- ENTER\n") );
    
    Status = SrLoggerSwitchLogs(_globals.pLogger);

    SrTrace( IOCTL, ("SR!SrSwitchAllLogsIoctl -- EXIT -- status 0x%08lx\n",
                     Status));
    
    RETURN(Status);
    
}   // SrSwitchAllLogsIoctl

NTSTATUS
SrDisableVolumeIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PSR_DEVICE_EXTENSION    pExtension;
    UNICODE_STRING          VolumeName;
    
    PAGED_CODE();

    ASSERT(IS_VALID_IRP(pIrp));

    SrTrace( IOCTL, ("SR!SrDisableVolumeIoctl -- ENTER\n") );

    if (pIrp->AssociatedIrp.SystemBuffer == NULL ||
        pIrpSp->Parameters.DeviceIoControl.InputBufferLength <= sizeof(WCHAR) ||
        pIrpSp->Parameters.DeviceIoControl.InputBufferLength > SR_MAX_FILENAME_LENGTH)
    {
        RETURN ( STATUS_INVALID_DEVICE_REQUEST );
    }

    //
    // get the volume name out 
    //

    VolumeName.Buffer = pIrp->AssociatedIrp.SystemBuffer;
    VolumeName.Length = (USHORT)(pIrpSp->Parameters.DeviceIoControl.InputBufferLength - sizeof(WCHAR));
    VolumeName.MaximumLength = VolumeName.Length;

    //
    // attach to it. it will check for a previous attachement and do the 
    // right thing .
    //
    
    Status = SrAttachToVolumeByName(&VolumeName, &pExtension);
    if (!NT_SUCCESS(Status)) {
        
        RETURN( Status );
    }

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    
    try {

        SrAcquireActivityLockExclusive( pExtension );
            
        //
        // now turn it off
        //

        pExtension->Disabled = TRUE;

        //
        // stop logging on the volume
        //

        if (pExtension->pLogContext != NULL)
        {
            SrLogStop( pExtension, TRUE, TRUE );
        }
        else
        {
            ASSERT(!pExtension->DriveChecked);
        }

        //
        //  Reset the backup history since the information stored there
        //  is no longer valid.
        //

        Status = SrResetBackupHistory(pExtension, NULL, 0, SrEventInvalid);

    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrDisableVolumeIoctl, Status);

        SrReleaseActivityLock( pExtension );

        //
        // At this point if Status != PENDING, the ioctl wrapper will
        // complete pIrp
        //
    }

    SrTrace( IOCTL, ("SR!SrDisableVolumeIoctl -- EXIT -- status 0x%08lx\n",
                     Status));

    RETURN(Status);
}   // SrDisableVolumeIoctl



NTSTATUS
SrStartMonitoringIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    UNREFERENCED_PARAMETER( pIrp );
    UNREFERENCED_PARAMETER( IrpSp );

    PAGED_CODE();

    SrTrace( IOCTL, ("SR!SrStartMonitoringIoctl -- ENTER\n") );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // no locks better be held, the registry hits the disk with it's own
    // locks held so we deadlock .
    //
    
    ASSERT(!IS_GLOBAL_LOCK_ACQUIRED());

    //
    // reload the registry information, on firstrun, we would have
    // no valid machine guid until we are started manually by the service
    //

    Status = SrReadRegistry(_globals.pRegistryLocation, FALSE);
    if (!NT_SUCCESS(Status))
    {
        goto SrStartMonitoringIoctl_Exit;
    }
    
    //
    //  Before we enable, we should clear our all old notifications. 
    //

    SrClearOutstandingNotifications();
    
    //
    // now turn us on
    //
    
    _globals.Disabled = FALSE;

SrStartMonitoringIoctl_Exit:
    
    SrTrace( IOCTL, ("SR!SrStartMonitoringIoctl -- EXIT -- status 0x%08lx\n",
                     Status));
    
    RETURN(Status);

}   // SrStartMonitoringIoctl

NTSTATUS
SrStopMonitoringIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                Status;
    PLIST_ENTRY             pListEntry;
    PSR_DEVICE_EXTENSION    pExtension;

    UNREFERENCED_PARAMETER( pIrp );
    UNREFERENCED_PARAMETER( IrpSp );

    PAGED_CODE();

    SrTrace( IOCTL, ("SR!SrStopMonitoringIoctl -- ENTER\n") );

    ASSERT(IS_VALID_IRP(pIrp));

    try {

        //
        // Disable the driver before we start shutting down each volume
        // so that a volume isn't reenabled while we are shutting down
        // other volumes.
        //
        
        _globals.Disabled = TRUE;

        //
        // Stop logging on all volumes
        //

        SrAcquireDeviceExtensionListLockShared();
        
        for (pListEntry = _globals.DeviceExtensionListHead.Flink;
             pListEntry != &_globals.DeviceExtensionListHead;
             pListEntry = pListEntry->Flink)
        {
            pExtension = CONTAINING_RECORD( pListEntry,
                                            SR_DEVICE_EXTENSION,
                                            ListEntry );
            
            ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

            //
            //  We only have to do work if this is a volume device object,
            //  not if this is a device object that is attached to a file
            //  system's control device object.
            //
            
            if (FlagOn( pExtension->FsType, SrFsControlDeviceObject ))
            {
                continue;
            }

            try {

                //
                //  Take a reference on the DeviceObject associated with this
                //  extension to ensure that the DeviceObject won't get detached
                //  until we return from SrLogStop.  SrLogStop could have the 
                //  last open handle on this volume, so during shutdown, closing
                //  this handle could cause the base file system to initiate
                //  the tearing down of the filter stack.  If this happens, 
                //  without this extra reference, we will call SrFastIoDetach
                //  before we return from SrLogStop.  This will cause the
                //  machine to deadlock on the device extension list lock (we 
                //  currently have the device extension list lock shared and 
                //  SrFastIoDetach needs to acquire it exclusive).
                //  

                ObReferenceObject( pExtension->pDeviceObject );

                SrAcquireActivityLockExclusive( pExtension );
            
                pExtension->Disabled = FALSE;

                if (pExtension->pLogContext != NULL)
                {
                    Status = SrLogStop( pExtension, TRUE, TRUE );
                    CHECK_STATUS( Status );
                }
                else
                {
                    ASSERT(!pExtension->DriveChecked);
                    Status = SrLogNormalize( pExtension );
                    CHECK_STATUS( Status );
                }
            } finally {

                SrReleaseActivityLock( pExtension );
                ObDereferenceObject( pExtension->pDeviceObject );
            }
        }

        //
        // check logger status
        //

        ASSERT( _globals.pLogger->ActiveContexts == 0 );

        //
        // Unload the blob config -- SrFreeLookupBlock acquires the appropriate
        // locks.
        //

        Status = SrFreeLookupBlob(&_globals.BlobInfo);
        if (!NT_SUCCESS(Status))
            leave;

        ASSERT(!_globals.BlobInfoLoaded);

        Status = STATUS_SUCCESS;

    } finally {

        Status = FinallyUnwind(SrStopMonitoringIoctl, Status);

        SrReleaseDeviceExtensionListLock();
    }
    
    SrTrace( IOCTL, ("SR!SrStopMonitoringIoctl -- EXIT -- status 0x%08lx\n",
                     Status));
    
    RETURN(Status);

}   // SrStopMonitoringIoctl

/***************************************************************************++

Routine Description:

    This is a generic completion routine that signals the event passed in
    then returns STATUS_MORE_PROCESSING_REQUIRED so that the dispatch routine
    that it is synchronizing with can still access the Irp.  The dispatch
    routine is responsible for restarting the completion processing.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the IRP that was just completed.

    EventToSignal - Pointer to the event to signal.

Return Value:

    The return value is always STATUS_MORE_PROCESSING_REQUIRED.

--***************************************************************************/
NTSTATUS
SrDismountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PSR_DEVICE_EXTENSION pExtension;
    
    UNREFERENCED_PARAMETER( Context );

    ASSERT(IS_SR_DEVICE_OBJECT( DeviceObject ));
    pExtension = DeviceObject->DeviceExtension;

    if (!NT_SUCCESS_NO_DBGBREAK(Irp->IoStatus.Status)) {

        //
        //  The volume failed to dismount, so we want to enable this
        //  extension so that the log will get reinitialized on the 
        //  first interesting operation.
        //

        pExtension->Disabled = FALSE;
    }

    //
    //  Propogate the pending flag as needed.
    //

    if (Irp->PendingReturned) {
        
        IoMarkIrpPending( Irp );
    }
    
    return STATUS_SUCCESS;
} // SrStopProcessingCompletion

/***************************************************************************++

Routine Description:

    This is a generic completion routine that signals the event passed in
    then returns STATUS_MORE_PROCESSING_REQUIRED so that the dispatch routine
    that it is synchronizing with can still access the Irp.  The dispatch
    routine is responsible for restarting the completion processing.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the IRP that was just completed.

    EventToSignal - Pointer to the event to signal.

Return Value:

    The return value is always STATUS_MORE_PROCESSING_REQUIRED.

--***************************************************************************/
NTSTATUS
SrStopProcessingCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT EventToSignal
    )
{
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( DeviceObject );

    ASSERT( IS_SR_DEVICE_OBJECT( DeviceObject ) );
    ASSERT(NULL != EventToSignal);

    KeSetEvent( EventToSignal, IO_NO_INCREMENT, FALSE );

    //
    //  We don't propagate the pending flag here since
    //  we are doing the synchronization with the originating
    //  thread.
    //

    //
    //  By return STATUS_MORE_PROCESSING_REQUIRED, we stop all further
    //  processing of the IRP by the IO Manager.  This means that the IRP
    //  will still be good when the thread waiting on the above event.
    //  The waiting thread needs the IRP to check and update the 
    //  Irp->IoStatus.Status as appropriate.
    //
    
    return STATUS_MORE_PROCESSING_REQUIRED;
} // SrStopProcessingCompletion
/***************************************************************************++

Routine Description:

    shutdown is happening.  flushes our config file to the disk.

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION pExtension = NULL;

    //
    // < dispatch!
    //

    PAGED_CODE();

    ASSERT( IS_VALID_DEVICE_OBJECT( DeviceObject ) );
    ASSERT( IS_VALID_IRP( pIrp ) );

    ASSERT( IS_SR_DEVICE_OBJECT( DeviceObject ) );
    pExtension = DeviceObject->DeviceExtension;
    
    SrTrace(INIT, ( "SR!SrShutdown:%p,%wZ [%wZ]\n", 
                    DeviceObject,
                    &pExtension->pTargetDevice->DriverObject->DriverName,
                    pExtension->pNtVolumeName ));
   
    //
    // Get this driver out of the driver stack and get to the next driver as
    // quickly as possible.
    //

    //
    // Is this a function for our device (vs an attachee) .
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    //  We get SHUTDOWN irp directed at each file system control device
    //  object that we are attached to when the system is shutting down.
    //
    //  At this time, we need to loop through the SR device objects and
    //  find all the SR device objects associated with volumes that are running
    //  this file system.  We use the FsType field in the device extension
    //  to figure this out.
    //
    //  We need to shutdown the log for all volumes that use this file system
    //  because after this operation gets to the file system, all volumes 
    //  using this file system will no longer be able to satify write operations 
    //  from us.
    //

    ASSERT(SR_IS_FS_CONTROL_DEVICE(pExtension));

    //
    //  SR's extensions that are attached to control device objects should
    //  never get disabled.
    //

    ASSERT( !pExtension->Disabled );

    try {

        PLIST_ENTRY pListEntry;
        SR_FILESYSTEM_TYPE interestingFsType;
        PSR_DEVICE_EXTENSION pCurrentExtension;

        interestingFsType = pExtension->FsType;
        ClearFlag( interestingFsType, SrFsControlDeviceObject );
    
        SrAcquireDeviceExtensionListLockShared();

        for (pListEntry = _globals.DeviceExtensionListHead.Flink;
             pListEntry != &(_globals.DeviceExtensionListHead);
             pListEntry = pListEntry->Flink ) {

            pCurrentExtension = CONTAINING_RECORD( pListEntry, 
                                                   SR_DEVICE_EXTENSION,
                                                   ListEntry );

            if (pCurrentExtension->FsType == interestingFsType) {

                try {

                    SrAcquireActivityLockExclusive( pCurrentExtension );
               
                    //
                    //  Disable this drive so that we do not log any more
                    //  activity on it.
                    //
                    
                    pCurrentExtension->Disabled = TRUE;

                    //
                    //  Now cleanup the log on this volume so that the log
                    //  we get flushed to the disk before the file system
                    //  shuts down.
                    //
                    
                    if (pCurrentExtension->pLogContext != NULL)
                    {
                        SrLogStop( pCurrentExtension, TRUE, FALSE );
                    }
                } finally {

                    SrReleaseActivityLock( pCurrentExtension );
                }
            }
        }
        
    } finally {

        SrReleaseDeviceExtensionListLock();
    }
        
    //
    // time to update our configuration file ?
    //

    try {

        SrAcquireGlobalLockExclusive();
        
        if (_globals.FileConfigLoaded)
        {
            //
            // write our the real next file number (not the +1000)
            //
            
            _globals.FileConfig.FileSeqNumber  = _globals.LastSeqNumber;
            _globals.FileConfig.FileNameNumber = _globals.LastFileNameNumber;

            SrWriteConfigFile();

            //
            // only need to do this once
            //
            
            _globals.FileConfigLoaded = FALSE;
        }
    } finally {

        SrReleaseGlobalLock();
    }

    //
    //  Now pass this operation to the next device in the stack.  We don't
    //  need a completion routine, so just skip our current stack location.
    //

    IoSkipCurrentIrpStackLocation(pIrp);
	return IoCallDriver(pExtension->pTargetDevice, pIrp);
}   // SrShutdown
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\fastio.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    fastio.c

Abstract:

    This module performs the hooks for the fast i/o path.

Author:

    Paul McDaniel (paulmcd)     01-Mar-2000

Revision History:

--*/


#include "precomp.h"

//
// Private constants.
//

//
// Private types.
//

//
// Private prototypes.
//

//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrFastIoCheckIfPossible )
#pragma alloc_text( PAGE, SrFastIoRead )
#pragma alloc_text( PAGE, SrFastIoWrite )
#pragma alloc_text( PAGE, SrFastIoQueryBasicInfo )
#pragma alloc_text( PAGE, SrFastIoQueryStandardInfo )
#pragma alloc_text( PAGE, SrFastIoLock )
#pragma alloc_text( PAGE, SrFastIoUnlockSingle )
#pragma alloc_text( PAGE, SrFastIoUnlockAll )
#pragma alloc_text( PAGE, SrFastIoUnlockAllByKey )
#pragma alloc_text( PAGE, SrFastIoDeviceControl )
#pragma alloc_text( PAGE, SrPreAcquireForSectionSynchronization )
#pragma alloc_text( PAGE, SrFastIoDetachDevice )
#pragma alloc_text( PAGE, SrFastIoQueryNetworkOpenInfo )
#pragma alloc_text( PAGE, SrFastIoMdlRead )
#pragma alloc_text( PAGE, SrFastIoMdlReadComplete )
#pragma alloc_text( PAGE, SrFastIoPrepareMdlWrite )
#pragma alloc_text( PAGE, SrFastIoMdlWriteComplete )
#pragma alloc_text( PAGE, SrFastIoReadCompressed )
#pragma alloc_text( PAGE, SrFastIoWriteCompressed )
#pragma alloc_text( PAGE, SrFastIoMdlReadCompleteCompressed )
#pragma alloc_text( PAGE, SrFastIoMdlWriteCompleteCompressed )
#pragma alloc_text( PAGE, SrFastIoQueryOpen )

#endif  // ALLOC_PRAGMA


//
// Private globals.
//

//
// Public globals.
//

//
// Public functions.
//






//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

BOOLEAN
SrFastIoCheckIfPossible (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    //
    //  Handle calls to Control Device Object
    //

    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;
    
        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoCheckIfPossible))
        {
            return pFastIoDispatch->FastIoCheckIfPossible(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}



BOOLEAN
SrFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoRead))
        {
            return pFastIoDispatch->FastIoRead(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}

    

BOOLEAN
SrFastIoWrite (
    IN struct _FILE_OBJECT *pFileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    NTSTATUS                eventStatus;
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();

    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        //  See if logging is enabled
        //

        if (!SR_LOGGING_ENABLED(pExtension) ||
            SR_IS_FS_CONTROL_DEVICE(pExtension))
        {
            goto CallNextDevice;
        }    

        //
        // does this file have a name?  skip unnamed files
        //

        if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pFileObject ))
        {
            goto CallNextDevice;
        }

        ASSERT(pFileObject->Vpb != NULL);

        //
        // is this file already closed?  it can be the cache manager calling
        // us to do work.  we ignore the cache managers work as we monitored
        // everything that happned prior to him seeing it.
        //

        if (FlagOn(pFileObject->Flags, FO_CLEANUP_COMPLETE))
        {
            goto CallNextDevice;
        }

        //
        // Fire a notification , SrNotify will check for eligibility
        //

        eventStatus = SrHandleEvent( pExtension, 
                                     SrEventStreamChange, 
                                     pFileObject,
                                     NULL,
                                     NULL, 
                                     NULL );

        CHECK_STATUS(eventStatus);

        //
        // call the next device
        //

CallNextDevice:

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoWrite))
        {
            return pFastIoDispatch->FastIoWrite( pFileObject,
                                                 FileOffset,
                                                 Length,
                                                 Wait,
                                                 LockKey,
                                                 Buffer,
                                                 IoStatus,
                                                 pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


//
// Fast I/O query basic and standard information procedures.
//

BOOLEAN
SrFastIoQueryBasicInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;


        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoQueryBasicInfo))
        {
            return pFastIoDispatch->FastIoQueryBasicInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoQueryStandardInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoQueryStandardInfo))
        {
            return pFastIoDispatch->FastIoQueryStandardInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


//
// Fast I/O lock and unlock procedures.
//

BOOLEAN
SrFastIoLock (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoLock))
        {
            return pFastIoDispatch->FastIoLock(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoUnlockSingle (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoUnlockSingle))
        {
            return pFastIoDispatch->FastIoUnlockSingle(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoUnlockAll (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoUnlockAll))
        {
            return pFastIoDispatch->FastIoUnlockAll(
                        FileObject,
                        ProcessId,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoUnlockAllByKey (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoUnlockAllByKey))
        {
            return pFastIoDispatch->FastIoUnlockAllByKey(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


//
// Fast I/O device control procedure.
//

BOOLEAN
SrFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();

    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoDeviceControl))
        {
            return pFastIoDispatch->FastIoDeviceControl(
                        FileObject,
                        Wait,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        IoControlCode,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


//
// Define callbacks for NtCreateSection to copy the file if a write section 
// is being created on this file.
//

NTSTATUS
SrPreAcquireForSectionSynchronization(
	IN PFS_FILTER_CALLBACK_DATA Data,
	OUT PVOID *CompletionContext
	)
{
    NTSTATUS        eventStatus;
    PFILE_OBJECT    pFileObject;
    PSR_DEVICE_EXTENSION pExtension;
    
    UNREFERENCED_PARAMETER( CompletionContext );
    ASSERT(Data->Operation == FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION);
    ASSERT(CompletionContext == NULL);
    ASSERT(IS_SR_DEVICE_OBJECT(Data->DeviceObject));

    PAGED_CODE();

    //
    // get the file object and device object
    //
    
    pExtension = Data->DeviceObject->DeviceExtension;
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

    //
    //  See if logging is enabled
    //

    if (!SR_LOGGING_ENABLED(pExtension) ||
        SR_IS_FS_CONTROL_DEVICE(pExtension))
    {
        return STATUS_SUCCESS;
    }    

    pFileObject = Data->FileObject;
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));

    //
    //  If they don't have write access to the section or the file don't worry
    //  about it.
    //
    //  Is this file already closed?  it can be the cache manager calling
    //  us to do work.  we ignore the cache managers work as we monitored
    //  everything that happned prior to him seeing it.
    //

    if (!FlagOn(Data->Parameters.AcquireForSectionSynchronization.PageProtection,
               (PAGE_READWRITE|PAGE_WRITECOPY|PAGE_EXECUTE_READWRITE|PAGE_EXECUTE_WRITECOPY)) ||
        !pFileObject->WriteAccess ||
        FlagOn(pFileObject->Flags, FO_CLEANUP_COMPLETE))
    {
        return STATUS_SUCCESS;
    }

    //
    // does this file have a name?  skip unnamed files
    //
    
    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pFileObject ))
    {
        return STATUS_SUCCESS;
    }
    ASSERT(pFileObject->Vpb != NULL);

    //
    // yep, fire a notification as if a write just happened.
    // otherwise he can write to the section and we don't see the write
    //

    eventStatus = SrHandleEvent( pExtension, 
                                 SrEventStreamChange, 
                                 pFileObject,
                                 NULL, 
                                 NULL,
                                 NULL );

    CHECK_STATUS(eventStatus);

    //
    // we never want to fail the acquire, we are just a silent monitor.
    //
    
    return STATUS_SUCCESS;
    
}   // SrPreAcquireForCreateSection

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

VOID
SrFastIoDetachDevice (
    IN struct _DEVICE_OBJECT *AttachedDevice,
    IN struct _DEVICE_OBJECT *DeviceDeleted
    )
{
    PSR_DEVICE_EXTENSION    pExtension;

    UNREFERENCED_PARAMETER( DeviceDeleted );

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    ASSERT(IS_SR_DEVICE_OBJECT(AttachedDevice));
    pExtension = AttachedDevice->DeviceExtension;

    SrTrace(NOTIFY, ("SR!SrFastIoDetachDevice: detaching from %p(%wZ)\n",
                     DeviceDeleted, 
                     pExtension->pNtVolumeName ));

    //
    // Detach ourselves from the device.
    //

    ASSERT(pExtension->pTargetDevice == DeviceDeleted);

    SrDetachDevice(AttachedDevice, TRUE);
    SrDeleteAttachmentDevice(AttachedDevice);
    
    NULLPTR(AttachedDevice);
}   // SrFastIoDetachDevice


//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

BOOLEAN
SrFastIoQueryNetworkOpenInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoQueryNetworkOpenInfo))
        {
            return pFastIoDispatch->FastIoQueryNetworkOpenInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


//
//  Define Mdl-based routines for the server to call
//

BOOLEAN
SrFastIoMdlRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, MdlRead))
        {
            return pFastIoDispatch->MdlRead(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoMdlReadComplete (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, MdlReadComplete))
        {
            return pFastIoDispatch->MdlReadComplete(
                        FileObject,
                        MdlChain,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoPrepareMdlWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, PrepareMdlWrite))
        {
            return pFastIoDispatch->PrepareMdlWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        pExtension->pTargetDevice);
        }
    }
    return FALSE;
}

BOOLEAN
SrFastIoMdlWriteComplete (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, MdlWriteComplete))
        {
            return pFastIoDispatch->MdlWriteComplete(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoReadCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoReadCompressed))
        {
            return pFastIoDispatch->FastIoReadCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoWriteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoWriteCompressed))
        {
            return pFastIoDispatch->FastIoWriteCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoMdlReadCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, MdlReadCompleteCompressed))
        {
            return pFastIoDispatch->MdlReadCompleteCompressed(
                        FileObject,
                        MdlChain,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoMdlWriteCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, MdlWriteCompleteCompressed))
        {
            return pFastIoDispatch->MdlWriteCompleteCompressed (
                        FileObject,
                        FileOffset,
                        MdlChain,
                        pExtension->pTargetDevice );
        }
    }
    return FALSE;
}


BOOLEAN
SrFastIoQueryOpen (
    IN struct _IRP *pIrp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    PFAST_IO_DISPATCH       pFastIoDispatch;
    PIO_STACK_LOCATION      pIrpSp;
    BOOLEAN                 Result;

    //
    // < dispatch!
    //

    PAGED_CODE();
       
    if (DeviceObject->DeviceExtension)
    {
        ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
        pExtension = DeviceObject->DeviceExtension;

        //
        // call the next device
        //

        pFastIoDispatch = pExtension->pTargetDevice->
                                DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER(pFastIoDispatch, FastIoQueryOpen))
        {
            //
            // normally IoCallDriver would update this field, we should manually
            //

            pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
            pIrpSp->DeviceObject = pExtension->pTargetDevice;

            Result = pFastIoDispatch->FastIoQueryOpen ( pIrp,
                                                        NetworkInformation,
                                                        pExtension->pTargetDevice );
                                                
            if (!Result) 
            {
                //
                //  This is ok, fastioquery does not complete the irp ever, and
                //  false means we are about to come down with an MJ_CREATE so
                //  we need the proper device object put back in the stack.
                //
        
                pIrpSp->DeviceObject = DeviceObject;
	        } 
	
            return Result;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\event.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    event.h

Abstract:

    contains prototypes for functions in event.c

Author:

    Paul McDaniel (paulmcd)     01-March-2000

Revision History:

--*/


#ifndef _EVENT_H_
#define _EVENT_H_

#define IS_VALID_OVERWRITE_INFO(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == SR_OVERWRITE_INFO_TAG))

typedef struct _SR_OVERWRITE_INFO
{

    //
    // = SR_OVERWRITE_INFO_TAG
    //
    

    ULONG Signature;

    //
    // IN the irp on input
    //
    
    PIRP pIrp;

    //
    // OUT did we rename the file?
    //
    
    BOOLEAN RenamedFile;

    //
    // OUT did we copied the file instead of renaming it?
    //
    
    BOOLEAN CopiedFile;

    //
    // OUT did we ignore the file because we thought the overwrite would fail?
    //
    
    BOOLEAN IgnoredFile;

    //
    // OUT the file attributes use in the create. these have to be returned
    // as they must match for CreateFile to success for H/S files.
    //

    ULONG CreateFileAttributes;

    //
    // OUT OPTIONAL the name we renamed it to IF we ended up renaming
    //
    
    PFILE_RENAME_INFORMATION pRenameInformation;

} SR_OVERWRITE_INFO, *PSR_OVERWRITE_INFO;

NTSTATUS
SrHandleEvent (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext OPTIONAL,
    IN OUT PSR_OVERWRITE_INFO pOverwriteInfo OPTIONAL,
    IN PUNICODE_STRING pFileName2 OPTIONAL
    );

NTSTATUS
SrLogEvent(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject OPTIONAL,
    IN PUNICODE_STRING pFileName,
    IN USHORT FileNameStreamLength,
    IN PUNICODE_STRING pTempName OPTIONAL,
    IN PUNICODE_STRING pFileName2 OPTIONAL,
    IN USHORT FileName2StreamLength OPTIONAL,
    IN PUNICODE_STRING pShortName OPTIONAL
    );

NTSTATUS
SrCreateRestoreLocation (
    IN PSR_DEVICE_EXTENSION pExtension
    );

NTSTATUS
SrHandleDirectoryRename (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pDirectoryName,
    IN BOOLEAN EventDelete
    );

NTSTATUS
SrHandleFileRenameOutOfMonitoredSpace(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext,
    OUT PBOOLEAN pOptimizeDelete,
    OUT PUNICODE_STRING *ppDestFileName
    );

NTSTATUS
SrHandleOverwriteFailure (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pOriginalFileName,
    IN ULONG CreateFileAttributes,
    IN PFILE_RENAME_INFORMATION pRenameInformation
    );


#endif // _EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\fastio.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    fastio.h

Abstract:

    contains prototypes for functions in fastio.c

Author:

    Paul McDaniel (paulmcd)     01-March-2000

Revision History:

--*/


#ifndef _FASTIO_H_
#define _FASTIO_H_


BOOLEAN
SrFastIoCheckIfPossible (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

    

BOOLEAN
SrFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoQueryBasicInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoQueryStandardInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoLock (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoUnlockSingle (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoUnlockAll (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoUnlockAllByKey (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

VOID
SrFastIoDetachDevice (
    IN struct _DEVICE_OBJECT *AttachedDevice,
    IN struct _DEVICE_OBJECT *DeviceDeleted
    );

BOOLEAN
SrFastIoQueryNetworkOpenInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoMdlRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoMdlReadComplete (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoPrepareMdlWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoMdlWriteComplete (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoReadCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoWriteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoMdlReadCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoMdlWriteCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
SrFastIoQueryOpen (
    IN struct _IRP *Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN struct _DEVICE_OBJECT *DeviceObject
    );


NTSTATUS
SrPreAcquireForSectionSynchronization (
	IN PFS_FILTER_CALLBACK_DATA Data,
	OUT PVOID *CompletionContext
	);



#endif // _FASTIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\filelist.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    filelist.c

Abstract:

    this is the code that handles the file lists (exclusion/inclusion).

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000

Revision History:

--*/



#include "precomp.h"

//
// Private prototypes.
//

//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrGetObjectName )
#pragma alloc_text( PAGE, SrpFindFilePartW)
#pragma alloc_text( PAGE, SrpFindFilePart )
#pragma alloc_text( PAGE, SrFindCharReverse )
#pragma alloc_text( PAGE, SrGetDestFileName )
#pragma alloc_text( PAGE, SrGetNextFileNumber )
#pragma alloc_text( PAGE, SrGetNextSeqNumber )
#pragma alloc_text( PAGE, SrGetSystemVolume )
#pragma alloc_text( PAGE, SrMarkFileBackedUp )
#pragma alloc_text( PAGE, SrHasFileBeenBackedUp )
#pragma alloc_text( PAGE, SrResetBackupHistory )
#pragma alloc_text( PAGE, SrResetHistory )
#pragma alloc_text( PAGE, SrGetVolumeDevice )
#pragma alloc_text( PAGE, SrSetFileSecurity )
#pragma alloc_text( PAGE, SrGetVolumeGuid )
#pragma alloc_text( PAGE, SrAllocateFileNameBuffer )
#pragma alloc_text( PAGE, SrFreeFileNameBuffer )
#pragma alloc_text( PAGE, SrGetNumberOfLinks )
#pragma alloc_text( PAGE, SrCheckVolume )
#pragma alloc_text( PAGE, SrCheckForRestoreLocation )
#pragma alloc_text( PAGE, SrGetMountVolume )
#pragma alloc_text( PAGE, SrCheckFreeDiskSpace )
#pragma alloc_text( PAGE, SrSetSecurityObjectAsSystem )
#pragma alloc_text( PAGE, SrCheckForMountsInPath )
#pragma alloc_text( PAGE, SrGetShortFileName )

#endif  // ALLOC_PRAGMA


//
// Private globals.
//

//
// Public globals.
//

//
// Public functions.
//

NTSTATUS
SrGetObjectName(
    IN  PSR_DEVICE_EXTENSION pExtension OPTIONAL, 
    IN  PVOID pObject, 
    OUT PUNICODE_STRING pName, 
    IN  ULONG NameLength // size of the buffer in pName
    )
{
    NTSTATUS Status;
    ULONG ReturnLength = 0;
    PVOID Buffer = NULL;
    ULONG BufferLength;
    PFILE_NAME_INFORMATION NameInfo;

    if (pExtension != NULL) {

        ASSERT( IS_VALID_FILE_OBJECT( (PFILE_OBJECT)pObject ) &&
                ((PFILE_OBJECT)pObject)->Vpb != NULL );
            
        //
        //  We are getting the name of a file object, so
        //  call SrQueryInformationFile to query the name.
        //

        BufferLength = NameLength + sizeof( ULONG );
        Buffer = ExAllocatePoolWithTag( PagedPool, 
                                        BufferLength, 
                                        SR_FILENAME_BUFFER_TAG);
        if (Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        NameInfo = Buffer;

        Status = SrQueryInformationFile( pExtension->pTargetDevice,
                                         pObject,
                                         NameInfo,
                                         BufferLength,
                                         FileNameInformation,
                                         &ReturnLength );

        if (NT_SUCCESS( Status )) {

            //
            //  We successfully got the name, so now build up the device name
            //  and file name into the pName buffer passed in.
            //

            ASSERT( pExtension->pNtVolumeName );

            Status = RtlAppendUnicodeStringToString( pName,
                                                     pExtension->pNtVolumeName );

            if (!NT_SUCCESS( Status )) {

                goto SrGetObjectName_Cleanup;
            }

            if ((pName->Length + NameInfo->FileNameLength + sizeof( WCHAR )) <= 
                 pName->MaximumLength ) {

                //
                // We have enough room in the buffer for the file name and
                // a NULL terminator.
                //

                RtlCopyMemory( &pName->Buffer[pName->Length/sizeof(WCHAR)],
                               NameInfo->FileName,
                               NameInfo->FileNameLength );
                pName->Length += (USHORT)NameInfo->FileNameLength;

                pName->Buffer[pName->Length/sizeof( WCHAR )] = UNICODE_NULL;
                
            } else {

                Status = STATUS_BUFFER_OVERFLOW;
            }
        }
        
    } else {

        ULONG NameBufferLength = NameLength - sizeof( UNICODE_STRING );

        ASSERT( IS_VALID_DEVICE_OBJECT( (PDEVICE_OBJECT)pObject ) );

        //
        //  Use ObQueryNameString to get the name of the DeviceObject passed
        //  in, but save space to NULL-terminate the name.
        //
        
        Status = ObQueryNameString( pObject,
                                    (POBJECT_NAME_INFORMATION) pName, 
                                    NameBufferLength - sizeof( UNICODE_NULL ), 
                                    &ReturnLength);

        if (NT_SUCCESS( Status )) {
            
            //
            //  ObQueryNameString sets the MaximumLength of pName to something
            //  it calculates, which is smaller than what we allocated.  Fix this
            //  up here and NULL terminate the string (we've already reserved
            //  the space).
            //

            pName->MaximumLength = (USHORT)NameBufferLength;
            pName->Buffer[pName->Length/sizeof( WCHAR )] = UNICODE_NULL;
        }
    }               

SrGetObjectName_Cleanup:

    if (Buffer != NULL) {

        ExFreePoolWithTag( Buffer, SR_FILENAME_BUFFER_TAG );
    }
    
    RETURN( Status );
}

/***************************************************************************++

Routine Description:

    Locates the file part of a fully qualified path.

Arguments:

    pPath - Supplies the path to scan.

Return Value:

    PSTR - The file part.

--***************************************************************************/
PWSTR
SrpFindFilePartW(
    IN PWSTR pPath
    )
{
    PWSTR pFilePart;

    PAGED_CODE();

    SrTrace(FUNC_ENTRY, ("SR!SrpFindFilePartW\n"));

    //
    // Strip off the path from the path.
    //

    pFilePart = wcsrchr( pPath, L'\\' );

    if (pFilePart == NULL)
    {
        pFilePart = pPath;
    }
    else
    {
        pFilePart++;
    }

    return pFilePart;

}   // SrpDbgFindFilePart


/***************************************************************************++

Routine Description:

    Locates the file part of a fully qualified path.

Arguments:

    pPath - Supplies the path to scan.

Return Value:

    PSTR - The file part.

--***************************************************************************/
PSTR
SrpFindFilePart(
    IN PSTR pPath
    )
{
    PSTR pFilePart;

    PAGED_CODE();

    SrTrace(FUNC_ENTRY, ("SR!SrpFindFilePart\n"));

    //
    // Strip off the path from the path.
    //

    pFilePart = strrchr( pPath, '\\' );

    if (pFilePart == NULL)
    {
        pFilePart = pPath;
    }
    else
    {
        pFilePart++;
    }

    return pFilePart;

}   // SrpFindFilePart


NTSTATUS
SrFindCharReverse(
    IN PWSTR pToken,
    IN ULONG TokenLength, 
    IN WCHAR FindChar, 
    OUT PWSTR * ppToken,
    OUT PULONG pTokenLength
    )
{
    NTSTATUS Status;
    int i;
    ULONG TokenCount;

    PAGED_CODE();

    //
    // assume we didn't find it
    //
    
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // turn this into a count
    //
    
    TokenCount = TokenLength / sizeof(WCHAR);

    if (TokenCount == 0 || pToken == NULL || pToken[0] == UNICODE_NULL)
        goto end;

    //
    // start looking from the end
    //

    for (i = TokenCount - 1; i >= 0; i--)
    {

        if (pToken[i] == FindChar)
            break;

    }

    if (i >= 0)
    {

        //
        // found it!
        //

        *ppToken = pToken + i;
        *pTokenLength = (TokenCount - i) * sizeof(WCHAR);

        Status = STATUS_SUCCESS;
    }

end:
    return Status;
    
}   // SrFindCharReverse

    
/***************************************************************************++

Routine Description:

    This routine generates the destination file name for a file that is being
    created in the restore location.  This name had the extension of the file
    that is being backed up with a unique file name that is generated here.

Arguments:

    pExtension - The SR_DEVICE_EXTENSION for the volume on which this file
        resides.
    pFileName - The name of the original file that is being backed up into
        the restore location.  This file is in the SR's normalized form
        (e.g., \\Device\HarddiskVolume1\mydir\myfile.ext)
    pDestFileName - This unicode string gets filled in with the full path
        and file name for the destination file in the restore location.

Return Value:

    NTSTATUS - Completion status. 
    
--***************************************************************************/
NTSTATUS 
SrGetDestFileName(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    OUT PUNICODE_STRING pDestFileName
    )
{
    NTSTATUS    Status;
    PWSTR       pFilePart;
    ULONG       FilePartLength;
    ULONG       NextFileNumber;
    ULONG       CharCount;

    PAGED_CODE();

    ASSERT( (pFileName != NULL) && (pFileName->Length > 0));
    ASSERT( pDestFileName != NULL );
    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) ||
            IS_ACTIVITY_LOCK_ACQUIRED_SHARED( pExtension ) );

    //
    // Copy the volume name out of the device extension.
    //

    ASSERT( pExtension->pNtVolumeName != NULL );

    Status = RtlAppendUnicodeStringToString( pDestFileName, 
                                             pExtension->pNtVolumeName );

    if (!NT_SUCCESS( Status ))
    {
        goto SrGetDestFileName_Exit;
    }
    
    //
    // and append our restore point location
    //

    CharCount = swprintf( &pDestFileName->Buffer[pDestFileName->Length/sizeof(WCHAR)],
                          RESTORE_LOCATION,
                          global->MachineGuid );

    pDestFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

    //
    // and the actual restore directory; we don't need to acquire a lock
    //  to read this because we already have the ActivityLock and this
    //  will prevent the value from changing.
    //

    CharCount = swprintf( &pDestFileName->Buffer[pDestFileName->Length/sizeof(WCHAR)],
                          L"\\" RESTORE_POINT_PREFIX L"%d\\",
                          global->FileConfig.CurrentRestoreNumber );

    pDestFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

    //
    // now get a number to use
    //

    Status = SrGetNextFileNumber(&NextFileNumber);
    if (!NT_SUCCESS(Status))
    {
        goto SrGetDestFileName_Exit;
    }

    //
    // use the "A" prefix (e.g. "A0000001.dll" )
    //

    swprintf( &pDestFileName->Buffer[pDestFileName->Length/sizeof(WCHAR)],
              RESTORE_FILE_PREFIX L"%07d",
              NextFileNumber );

    pDestFileName->Length += 8 * sizeof(WCHAR);

    //
    //  We know that the pFileName contains a fully-normalized name, so
    //  we just need to search for the '.' from the end of the name
    //  to find the proper extension.
    //

    pFilePart = pFileName->Buffer;
    FilePartLength = pFileName->Length;

    Status = SrFindCharReverse( pFilePart,
                                FilePartLength,
                                L'.',
                                &pFilePart,
                                &FilePartLength );

    //
    //  No extension is not supported!
    //
        
    if (!NT_SUCCESS(Status))
    {
        goto SrGetDestFileName_Exit;
    }

    //
    // now put the proper extension on
    //
    
    RtlCopyMemory( &pDestFileName->Buffer[pDestFileName->Length/sizeof(WCHAR)],
                   pFilePart,
                   FilePartLength );

    pDestFileName->Length += (USHORT)FilePartLength;

    //
    // NULL terminate it
    //

    ASSERT(pDestFileName->Length < pDestFileName->MaximumLength);
    
    pDestFileName->Buffer[pDestFileName->Length/sizeof(WCHAR)] = UNICODE_NULL;

SrGetDestFileName_Exit:
    
    RETURN (Status);
}   // SrGetDestFileName

NTSTATUS
SrGetNextFileNumber(
    OUT PULONG pNextFileNumber
    )
{
    NTSTATUS Status;
            
    PAGED_CODE();

    ASSERT(pNextFileNumber != NULL);

    *pNextFileNumber = InterlockedIncrement(&global->LastFileNameNumber);

    if (*pNextFileNumber >= global->FileConfig.FileNameNumber)
    {
        //
        // save out the number again
        //

        try {
            SrAcquireGlobalLockExclusive();

            //
            // double check with the lock held
            //
            
            if (*pNextFileNumber >= global->FileConfig.FileNameNumber)
            {
                global->FileConfig.FileNameNumber += SR_FILE_NUMBER_INCREMENT;

                //
                // save it out
                //
                
                Status = SrWriteConfigFile();
                CHECK_STATUS(Status);
            }
        } finally {

            SrReleaseGlobalLock();
        }
    }

    RETURN(STATUS_SUCCESS);

}   // SrGetNextFileNumber 


NTSTATUS
SrGetNextSeqNumber(
    OUT PINT64 pNextSeqNumber
    )
{
    NTSTATUS Status;
            
    PAGED_CODE();

    ASSERT(pNextSeqNumber != NULL);

    //
    // bummer , there is no interlocked increment for 64bits
    //

    try {

        SrAcquireGlobalLockExclusive();

        *pNextSeqNumber = ++(global->LastSeqNumber);

        if (*pNextSeqNumber >= global->FileConfig.FileSeqNumber)
        {
            //
            // save out the number again
            //

            global->FileConfig.FileSeqNumber += SR_SEQ_NUMBER_INCREMENT;

            //
            // save it out
            //
            
            Status = SrWriteConfigFile();
            CHECK_STATUS(Status);

        }
    } finally {
    
        SrReleaseGlobalLock();
    }

    RETURN(STATUS_SUCCESS);

}   // SrGetNextFileNumber 



/***************************************************************************++

Routine Description:

    Returns the string location of the system volume.  Get this by using the
    global cache'd system volume extension.  If it can't be found (hasn't
    been attached yet), it queries the os to get the match for \\SystemRoot.

Arguments:

    pFileName - holds the volume path on return (has to be a contigous block)

    pSystemVolumeExtension - SR's extension for the device that is attached
        to the system volume.

    pFileNameLength - holds the size of the buffer on in, and the size copied
        on out.  both in bytes.

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrGetSystemVolume(
    OUT PUNICODE_STRING pFileName,
    OUT PSR_DEVICE_EXTENSION *ppSystemVolumeExtension,
    IN ULONG FileNameLength
    )
{
    NTSTATUS            Status;
    HANDLE              FileHandle = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PFILE_OBJECT        pFileObject = NULL;
    UNICODE_STRING      FileName;
    PDEVICE_OBJECT      pFilterDevice;
    PDEVICE_OBJECT      pRelatedDevice;

    PAGED_CODE();

    ASSERT( pFileName != NULL);
    ASSERT( ppSystemVolumeExtension != NULL );

    *ppSystemVolumeExtension = NULL;

    if (global->pSystemVolumeExtension == NULL) {

        //
        // don't have it cache'd, attempt to open the SystemRoot
        //

        RtlInitUnicodeString(&FileName, L"\\SystemRoot");

        InitializeObjectAttributes( &ObjectAttributes,
                                    &FileName,
                                    OBJ_KERNEL_HANDLE, 
                                    NULL,
                                    NULL );

        Status = ZwCreateFile( &FileHandle,
                               FILE_GENERIC_READ,                  // DesiredAccess
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,                               // AllocationSize
                               FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,                               // EaBuffer
                               0 );                                // EaLength

        if (!NT_SUCCESS(Status))
            goto end;
        
        //
        // now get the file object
        //

        Status = ObReferenceObjectByHandle( FileHandle,
                                            0,          // DesiredAccess
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pFileObject,
                                            NULL );

        if (!NT_SUCCESS(Status))
            goto end;

        //
        // and get our device's extension
        //

        pRelatedDevice = IoGetRelatedDeviceObject( pFileObject );

        if (pRelatedDevice == NULL )
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        pFilterDevice = SrGetFilterDevice(pRelatedDevice);
        
        if (pFilterDevice == NULL) {
        
            //
            // we are not attached to the system volume, just get the name
            // This happens during unload, when writing out the config file
            //

            Status = SrGetObjectName( NULL,
                                      pFileObject->Vpb->RealDevice,
                                      pFileName,
                                      FileNameLength );

            if (!NT_SUCCESS(Status))
                goto end;

            //
            // all done
            //
            
            goto end;
        }    

        //
        // and store it
        //
        
        global->pSystemVolumeExtension = pFilterDevice->DeviceExtension;

        SrTrace( INIT, (
                 "sr!SrGetSystemVolume: cached system volume [%wZ]\n", 
                 global->pSystemVolumeExtension->pNtVolumeName ));
    }

    ASSERT(global->pSystemVolumeExtension != NULL);
    ASSERT(global->pSystemVolumeExtension->pNtVolumeName != NULL);

    //
    // now use the cache'd value
    //

    if (FileNameLength < 
        global->pSystemVolumeExtension->pNtVolumeName->Length) {
    
        Status = STATUS_BUFFER_OVERFLOW;
        
    } else {

        RtlCopyUnicodeString( pFileName, 
                              global->pSystemVolumeExtension->pNtVolumeName );
        *ppSystemVolumeExtension = global->pSystemVolumeExtension;
                              
        Status = STATUS_SUCCESS;
    }

end:

    if (pFileObject != NULL)
    {
        ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }

    if (FileHandle != NULL)
    {
        ZwClose(FileHandle);
        FileHandle = NULL;
    }


    RETURN(Status);

}   // SrGetSystemVolume


/***************************************************************************++

Routine Description:

    This routine updates the backup history for the given file.  Based on the
    current event and the full file name, this routine decides whether to log 
    this change against the file's unnamed data stream or the data stream
    currently being operation on.

Arguments:

    pExtension - the SR device extension for the current volume.
    pFileName - holds the path name of the file that's been backed up.
    StreamNameLength - the length of the stream component of the file name
        if there is one.
    CurrentEvent - the event that is causing us to update the backup history
    FutureEventsToIgnore - the events that should be ignored in the future.

Return Value:

    Returns STATUS_SUCCESS if we are able to successfully update the backup
    history, or the appropriate error code otherwise.

--***************************************************************************/
NTSTATUS
SrMarkFileBackedUp(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    IN USHORT StreamNameLength,
    IN SR_EVENT_TYPE CurrentEvent,
    IN SR_EVENT_TYPE FutureEventsToIgnore
    )
{
    NTSTATUS    Status;
    ULONG_PTR   Context = (ULONG_PTR) SrEventInvalid;
    HASH_KEY    Key;
    
    PAGED_CODE();

    ASSERT( pFileName != NULL );

    //
    //  Make sure our pFileName is correctly constructed.
    //
    
    ASSERT( IS_VALID_SR_STREAM_STRING( pFileName, StreamNameLength ) );

    //
    //  Set up the hash key we need to lookup.
    //

    Key.FileName.Length = pFileName->Length;
    Key.FileName.MaximumLength = pFileName->MaximumLength;
    Key.FileName.Buffer = pFileName->Buffer;
    Key.StreamNameLength = RECORD_AGAINST_STREAM( CurrentEvent, 
                                                  StreamNameLength );
    
    try {

        SrAcquireBackupHistoryLockExclusive( pExtension );

        //
        // try and find a matching entry in the hash list
        //

        Status = HashFindEntry( pExtension->pBackupHistory, 
                                &Key,
                                (PVOID*)&Context );

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // not found... add one
            //

            Status = HashAddEntry( pExtension->pBackupHistory, 
                                   &Key, 
                                   (PVOID)FutureEventsToIgnore );
                                   
            if (!NT_SUCCESS(Status))
                leave;
        }
        else if (NT_SUCCESS(Status))
        {
            //
            // add this to the mask
            //
            
            Context |= FutureEventsToIgnore;

            //
            // and update the entry
            //
            
            Status = HashAddEntry( pExtension->pBackupHistory, 
                                   &Key, 
                                   (PVOID)Context );

            if (Status == STATUS_DUPLICATE_OBJECTID)
            {
                Status = STATUS_SUCCESS;
            }
            else if (!NT_SUCCESS(Status))
            {
                leave;
            }
            
        }
    }finally {

        SrReleaseBackupHistoryLock( pExtension );
    }

    RETURN(Status);
}   // SrMarkFileBackedUp

/***************************************************************************++

Routine Description:

    This routine looks up in the backup history based on the name passed in
    whether or not this EventType has already been backed up for this file.

    With stream names, this is a little more complicated than it first appears.
    If this name contains a stream, we may have to look up to see if we have
    a history on the file name with and without the stream component of the
    name.

Arguments:

    pExtension - SR's device extension for this volume.  This contains
        our backup history structures.
    pFileName - The file name to lookup.  If the name has a stream component,
        that stream component is in the buffer of this unicode string, but
        the length only designates the file-only name portion.
    StreamNameLength - Designates the extra bytes in addition to 
        pFileName->Length that specify the stream component of the name.
    EventType - The current event that we are seeing on this file.

Return Value:

    Returns TRUE if this file has already been backed up for this EventType,
    and FALSE otherwise.

--***************************************************************************/
BOOLEAN
SrHasFileBeenBackedUp(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    IN USHORT StreamNameLength,
    IN SR_EVENT_TYPE EventType
    )
{
    NTSTATUS Status;
    ULONG_PTR Context;
    HASH_KEY Key;
    SR_EVENT_TYPE EventsToIgnore = SrEventInvalid;
    BOOLEAN HasBeenBackedUp = FALSE;
    
    PAGED_CODE();

    ASSERT( pFileName != NULL );

    //
    //  Make sure our pFileName is correctly constructed.
    //
    
    ASSERT( IS_VALID_SR_STREAM_STRING( pFileName, StreamNameLength ) );

    //
    //  Setup our hash key.  We will first do a lookup on the exact match
    //  of the name passed in since this will be what hits the majority of the
    //  time.
    //

    Key.FileName.Length = pFileName->Length;
    Key.FileName.MaximumLength = pFileName->MaximumLength;
    Key.FileName.Buffer = pFileName->Buffer;
    Key.StreamNameLength = StreamNameLength;
    
    try {

        SrAcquireBackupHistoryLockShared( pExtension );

        //
        // try and find a matching entry in the hash list
        //

        Status = HashFindEntry( pExtension->pBackupHistory, 
                                &Key, 
                                (PVOID*)&Context );

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND || !NT_SUCCESS(Status))
        {
            //
            //  We don't have a backup history entry for this name, so we
            //  don't have any recorded events to igore for this name.
            //

            EventsToIgnore = SrEventInvalid;
        }
        else
        {
            //
            //  Context contains the set of events that should be ignored
            //  for this name.
            //
            
            EventsToIgnore = (SR_EVENT_TYPE)Context;
        }

        //
        //  Now see if we have enough information to say with certainty whether
        //  or not we should ignore this operation.
        //
        //  We have two cases here:
        //    1. The name passed in has NO stream name component
        //          In this case, the current value of EventsToIgnore is all
        //          we have to make our decision.  So figure out if our
        //          EventType is in this list and return the appropriate
        //          HasBeenBackedUp value.
        //
        //    2. The name passed in DOES have a stream name component
        //          In this case, if our EventType is already in the
        //          EventsToIgnore set, we are done.  Otherwise, if this
        //          EventType is relevant to the file-only name, check to
        //          see if we have a backup history entry for that name.
        //

        if (StreamNameLength == 0)
        {
            HasBeenBackedUp = BooleanFlagOn( EventsToIgnore, EventType );
            leave;
        }
        else
        {
            if (FlagOn( EventsToIgnore, EventType ))
            {
                HasBeenBackedUp = TRUE;
                leave;
            }
            else
            {
                //
                //  We need to see if we have a context on the file-only portion
                //  of the name.
                //

                Key.FileName.Length = pFileName->Length;
                Key.FileName.MaximumLength = pFileName->MaximumLength;
                Key.FileName.Buffer = pFileName->Buffer;
                Key.StreamNameLength = 0;
                
                Status = HashFindEntry( pExtension->pBackupHistory, 
                                        &Key, 
                                        (PVOID*)&Context );

                if (Status == STATUS_OBJECT_NAME_NOT_FOUND || !NT_SUCCESS(Status))
                {
                    //
                    //  We don't have a backup history entry for this name, so we
                    //  don't have any recorded events to igore for this name.
                    //

                    EventsToIgnore = SrEventInvalid;
                }
                else
                {
                    //
                    //  Context contains the set of events that should be ignored
                    //  for this name.
                    //
                    
                    EventsToIgnore = (SR_EVENT_TYPE)Context;
                }

                //
                //  This is all we've got, so make our decision based on the
                //  current value of EventsToIgnore.
                //

                HasBeenBackedUp = BooleanFlagOn( EventsToIgnore, EventType );
            }
        }
    } 
    finally 
    {
        SrReleaseBackupHistoryLock( pExtension );
    }

    return HasBeenBackedUp;
}   //  SrHasFileBeenBackedUp

/***************************************************************************++

Routine Description:

    this will clear the backup history completely.  this is done when a new 
    restore point is created .

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrResetBackupHistory(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName OPTIONAL,
    IN USHORT StreamNameLength OPTIONAL,
    IN SR_EVENT_TYPE EventType
    )
{
    NTSTATUS Status;
    ULONG_PTR Context;
    HASH_KEY Key;
    
    PAGED_CODE();

    try 
    {
        SrAcquireBackupHistoryLockExclusive( pExtension );

        if (pFileName == NULL)
        {
            //
            // clear them all
            //
            
            HashClearEntries(pExtension->pBackupHistory);
            Status = STATUS_SUCCESS;
        }
        else if (StreamNameLength > 0)
        {
            //
            // clear just this one
            //

            //
            //  Make sure our pFileName is correctly constructed.
            //
            ASSERT( IS_VALID_SR_STREAM_STRING( pFileName, StreamNameLength ) );
            
            Key.FileName.Length = pFileName->Length;
            Key.FileName.MaximumLength = pFileName->MaximumLength;
            Key.FileName.Buffer = pFileName->Buffer;
            Key.StreamNameLength = StreamNameLength;

            Status = HashFindEntry( pExtension->pBackupHistory,
                                    &Key,
                                    (PVOID*)&Context );

            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            {
                //
                // no entry, nothing to clear
                //
                
                Status = STATUS_SUCCESS;
                leave;
            }
            else if (!NT_SUCCESS(Status))
            {
                leave;
            }

            //
            // update/clear the existing entry
            //

            Context = EventType;

            Status = HashAddEntry( pExtension->pBackupHistory, 
                                   &Key, 
                                   (PVOID)Context );

            ASSERT(Status == STATUS_DUPLICATE_OBJECTID);
            
            if (Status == STATUS_DUPLICATE_OBJECTID)
            {
                Status = STATUS_SUCCESS;
            }
            else if (!NT_SUCCESS(Status))
            {
                leave;
            }
        }
        else
        {
            //
            //  We've got to clear all entries associated with this file name.
            //

            Status = HashClearAllFileEntries( pExtension->pBackupHistory,
                                              pFileName );
        }
    } 
    finally
    {
    
        SrReleaseBackupHistoryLock( pExtension );
    }

    RETURN(Status);
    
}   // SrResetBackupHistory


/***************************************************************************++

Routine Description:

    this is a callback function for HashprocessEntries that is used to reset 
    the history on all files that match the directory prefix.  this is called
    when a directory is renamed, invaliding all hash entries with the 
    directory's new name, as they are no longer the same file.

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
PVOID
SrResetHistory(
    IN PHASH_KEY pKey, 
    IN PVOID pEntryContext,
    PUNICODE_STRING pDirectoryName
    )
{
    PAGED_CODE();

    //
    // does this directory prefix match the key?
    //

    if (RtlPrefixUnicodeString(pDirectoryName, &pKey->FileName, TRUE))
    {
        //
        // return a new context of invalid event.
        //

        SrTrace(HASH, ("sr!SrResetHistory: clearing %wZ\n", &pKey->FileName));
        
        return (PVOID)(ULONG_PTR)SrEventInvalid;
    }
    else
    {
        //
        // do nothing, keep the old context
        //

        return pEntryContext;
    }
}   // SrResetHistory


/***************************************************************************++

Routine Description:

    returns the proper volume device object for this file object.  handles
    if the file is open or not.

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
PDEVICE_OBJECT
SrGetVolumeDevice(
    PFILE_OBJECT pFileObject
    )
{

    PAGED_CODE();

    //
    // is this file open?
    //

    if (pFileObject->Vpb != NULL)
        return pFileObject->Vpb->RealDevice;

    //
    // otherwise is there a related file object?
    //

    if (pFileObject->RelatedFileObject != NULL)
    {
        ASSERT(pFileObject->RelatedFileObject->Vpb != NULL);
        if (pFileObject->RelatedFileObject->Vpb != NULL)
            return pFileObject->RelatedFileObject->Vpb->RealDevice;
    }
    
    //
    // otherwise it's unopened and not a relative open
    //
    
    return pFileObject->DeviceObject;

}   // SrGetVolumeDevice

/***************************************************************************++

Routine Description:

    This routine will set the proper security descriptor based on the
    SR_ACL_TYPE passed in.

    Here is a break down of the ACL built for each SR_ACL_TYPE:

    SrAclTypeSystemVolumeInformationDirectory:
        Local System                   --  Full Control, Container and objects inherit
        Admins owner
        
    SrAclTypeRestoreDirectoryAndFiles:
        Local System and Admins group  --  Full Control, Container and objects inherit
        World                          --  Add file | Synchronize, Only containers inherit
        Admins owner

    // ISSUE-mollybro-2002-04-08 Remove World access from _restore directory
    //
    //  We need give World AddFile and Synchronize access that containers will
    //  inherit so in case someone restores to a point before the SP installation 
    //  (i.e., running with old sr binaries), the directories will be ACLed such 
    //  that SR can still rename files into RP directories.  For Longhorn, 
    //  this ACE can be removed.
    //

        
    SrAclTypeRPDirectory:
        Local System and Admins group  --  Full Control, Containers and objects inherit
        World                          -- Add file | Synchronize, Not inherit
        Admins owner

    SrAclTypeRPFiles:
        Local System and Admins group  --  Full Control, Containers and objects inherit
        Admins owner
    
Arguments:

    FileHandle - The handle to the file/directory for which we are to
        set the ACL.

    AclType - The type of file/directory represented by FileHandle.  This
        specifies the type of ACL to put on the file/directory.

Return Value:

    STATUS_SUCCESS if the Acl was set successfully, or the appropriate error
    otherwise.
    
--***************************************************************************/
NTSTATUS
SrSetFileSecurity(
    IN HANDLE FileHandle,
    IN SR_ACL_TYPE AclType
    )
{
    NTSTATUS status;
    SECURITY_DESCRIPTOR securityDescriptor;
    ULONG securityInformation = 0;
    PACL acl = NULL;
    ULONG aclLength;
    PSID adminsSid;
    PSID systemSid;
    PSID worldSid;

    //
    //  Initialize the security descriptor.
    //
    
    status = RtlCreateSecurityDescriptor( &securityDescriptor, 
                                          SECURITY_DESCRIPTOR_REVISION );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Build up the ACL requested.
    //

    adminsSid = SeExports->SeAliasAdminsSid;
    systemSid = SeExports->SeLocalSystemSid;
    worldSid = SeExports->SeWorldSid;

    switch (AclType) {

    case SrAclTypeSystemVolumeInformationDirectory:

        aclLength = sizeof( ACL )                      +
                    (1 * sizeof( ACCESS_ALLOWED_ACE )) +
                    RtlLengthSid( systemSid )          -
                    (1 * sizeof( ULONG ));
        break;

    case SrAclTypeRPFiles:

        aclLength = sizeof( ACL )                      +
                    (2 * sizeof( ACCESS_ALLOWED_ACE )) +
                    RtlLengthSid( adminsSid )          +
                    RtlLengthSid( systemSid )          -
                    (2 * sizeof( ULONG ));
        break;

    case SrAclTypeRestoreDirectoryAndFiles:
    case SrAclTypeRPDirectory:
        aclLength = sizeof( ACL )                      +
                    (3 * sizeof( ACCESS_ALLOWED_ACE )) +
                    RtlLengthSid( adminsSid )          +
                    RtlLengthSid( systemSid )          +
                    RtlLengthSid( worldSid )           -
                    (3 * sizeof( ULONG ));
        break;
    
    default:

        return STATUS_INVALID_PARAMETER;
    }

    acl = SR_ALLOCATE_POOL( PagedPool, aclLength, SR_SECURITY_DATA_TAG );

    if (NULL == acl) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl( acl, aclLength, ACL_REVISION );

    if (!NT_SUCCESS( status )) {

        goto SrSetFileSecurity_Exit;
    }

    switch (AclType) {

    case SrAclTypeSystemVolumeInformationDirectory:

        //
        //  Add (SYSTEM, Full control, Folder and File Inherit) ACE
        //
        //  This is an exact match of the ACE added by 
        //  RtlCreateSystemVolumeInformationFolder.
        //

        status = SrAddAccessAllowedAce( acl,
                                        systemSid,
                                        STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                                        0,
                                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE );
        
        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        break;
        
    case SrAclTypeRestoreDirectoryAndFiles:

        //
        //  Add (WORLD, Add File|Synchronize, Inherit) ACE
        // 
        //  NOTE: Must include SYNCHRONIZE so that when we rename files into
        //  this directory, the open of the directory that 
        //  IopOpenLinkOrRenameTarget does as part of a rename operation will
        //  succeed.
        //
        //  NOTE 2: Must allow this ACE to be inherited for the _restore
        //  directory so that if SR binaries are revert to 2600 version, SR
        //  will continue to work.  Only directories will inherit this so that
        //  a user cannot append to files.
        //

        status = SrAddAccessAllowedAce( acl,
                                        worldSid,
                                        FILE_ADD_FILE | SYNCHRONIZE,
                                        0,
                                        CONTAINER_INHERIT_ACE );
        
        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        //
        //  Add (ADMINS, Full control, Inherit) ACE
        //

        status = SrAddAccessAllowedAce( acl,
                                        adminsSid,
                                        STANDARD_RIGHTS_ALL | GENERIC_ALL,
                                        1,
                                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE );
                                 
        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        //
        //  Add (SYSTEM, Full control, Inherit) ACE
        //

        status = SrAddAccessAllowedAce( acl,
                                        systemSid,
                                        STANDARD_RIGHTS_ALL | GENERIC_ALL,
                                        2,
                                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE );
        
        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        break;
        
    case SrAclTypeRPDirectory:

        //
        //  Add (WORLD, Add File|Synchronize, No inherit) ACE
        // 
        //  NOTE: Must include SYNCHRONIZE so that when we rename files into
        //  this directory, the open of the directory that 
        //  IopOpenLinkOrRenameTarget does as part of a rename operation will
        //  succeed.
        //

        status = SrAddAccessAllowedAce( acl,
                                        worldSid,
                                        FILE_ADD_FILE | SYNCHRONIZE,
                                        0,
                                        0 );
        
        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        //
        //  Add (ADMINS, Full control, Inherit) ACE
        //

        status = SrAddAccessAllowedAce( acl,
                                        adminsSid,
                                        STANDARD_RIGHTS_ALL | GENERIC_ALL,
                                        1,
                                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE );

        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        //
        //  Add (SYSTEM, Full control, Inherit) ACE
        //

        status = SrAddAccessAllowedAce( acl,
                                        systemSid,
                                        STANDARD_RIGHTS_ALL | GENERIC_ALL,
                                        2,
                                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE );
        
        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        break;

    case SrAclTypeRPFiles:

        //
        //  Add (ADMINS, Full control, No inheritance) ACE
        //

        status = SrAddAccessAllowedAce( acl,
                                        adminsSid,
                                        STANDARD_RIGHTS_ALL | GENERIC_ALL,
                                        0,
                                        0 );

        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        //
        //  Add (SYSTEM, Full control, No inheritance) ACE
        //

        status = SrAddAccessAllowedAce( acl,
                                        systemSid,
                                        STANDARD_RIGHTS_ALL | GENERIC_ALL,
                                        1,
                                        0 );

        if (!NT_SUCCESS( status )) {

            goto SrSetFileSecurity_Exit;
        }

        break;
  
    default:

        ASSERT( FALSE );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We've now built up the proper ACL, so set it as the DACL in our
    //  security descriptor.
    //
    
    status = RtlSetDaclSecurityDescriptor( &securityDescriptor,
                                           TRUE,
                                           acl,
                                           FALSE );

    if (!NT_SUCCESS( status )) {

        goto SrSetFileSecurity_Exit;
    }

    //
    //  Mark it as protected so that no parent DACL changes what we've set
    //
   
    securityDescriptor.Control |= SE_DACL_PROTECTED;
    
    securityInformation |= DACL_SECURITY_INFORMATION;

    //
    //  Set the owner in our security descriptor to the Admins group.
    //

    status = RtlSetOwnerSecurityDescriptor( &securityDescriptor, 
                                            adminsSid, 
                                            FALSE );
                                                
    if (!NT_SUCCESS( status )) {

        goto SrSetFileSecurity_Exit;
    }

    securityInformation |= OWNER_SECURITY_INFORMATION;


    //
    //  Now that the security descriptor is completely set up, set it
    //  on the file/directory passed in.
    //

    status = SrSetSecurityObjectAsSystem( FileHandle,
                                          securityInformation,
                                          &securityDescriptor );

    CHECK_STATUS( status );

SrSetFileSecurity_Exit:

    if (NULL != acl) {

        SR_FREE_POOL( acl, SR_SECURITY_DATA_TAG );
    }

    RETURN( status );
}

/***************************************************************************++

Routine Description:

    this will lookup the volume guid and return it to the caller.

Arguments:

    pVolumeName - the nt name of the volume (\Device\HardDiskVolume1)

    pVolumeGuid - holds the guid on retunr ( {xxx-x-x-x} )

Return Value:

    NTSTATUS - Completion status. 
    
--***************************************************************************/
NTSTATUS
SrGetVolumeGuid(
    IN PUNICODE_STRING pVolumeName,
    OUT PWCHAR pVolumeGuid
    )
{
    NTSTATUS                Status;
    PMOUNTMGR_MOUNT_POINT   pMountPoint = NULL;
    PMOUNTMGR_MOUNT_POINTS  pMountPoints = NULL;
    PMOUNTMGR_MOUNT_POINT   pVolumePoint;
    UNICODE_STRING          DeviceName;
    UNICODE_STRING          VolumePoint;
    IO_STATUS_BLOCK         IoStatusBlock;
    PKEVENT                 pEvent = NULL;
    PIRP                    pIrp;
    PDEVICE_OBJECT          pDeviceObject;
    PFILE_OBJECT            pFileObject = NULL;
    ULONG                   MountPointsLength;
    ULONG                   Index;
    
    PAGED_CODE();

    ASSERT(pVolumeName != NULL);
    ASSERT(pVolumeGuid != NULL);

try {


    //
    // bind to the volume mount point manager's device
    //
    
    RtlInitUnicodeString(&DeviceName, MOUNTMGR_DEVICE_NAME);

    Status = IoGetDeviceObjectPointer( &DeviceName, 
                                       FILE_READ_ATTRIBUTES,
                                       &pFileObject,
                                       &pDeviceObject );
                                       
    if (!NT_SUCCESS(Status))
        leave;

    //
    // allocate some space for the input mount point (the volume name)
    //

    pMountPoint = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool, 
                                                 MOUNTMGR_MOUNT_POINT, 
                                                 pVolumeName->Length, 
                                                 SR_MOUNT_POINTS_TAG );
                                                 
    if (pMountPoint == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        leave;
    }
    


    RtlZeroMemory(pMountPoint, sizeof(MOUNTMGR_MOUNT_POINT));

    pMountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    pMountPoint->DeviceNameLength = pVolumeName->Length;
    
    RtlCopyMemory( pMountPoint + 1,
                   pVolumeName->Buffer, 
                   pVolumeName->Length );

    //
    // allocate some space for the mount points we are going to query for
    //

    MountPointsLength = 1024 * 2;

    //
    // init an event for use
    //

    pEvent = SR_ALLOCATE_STRUCT(NonPagedPool, KEVENT, SR_KEVENT_TAG);
    if (pEvent == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        leave;
    }

    KeInitializeEvent(pEvent, SynchronizationEvent, FALSE);
    
retry:

    ASSERT(pMountPoints == NULL);
    
    pMountPoints = (PMOUNTMGR_MOUNT_POINTS)SR_ALLOCATE_ARRAY( PagedPool, 
                                                              UCHAR, 
                                                              MountPointsLength,
                                                              SR_MOUNT_POINTS_TAG );

    if (pMountPoints == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        leave;
    }

    //
    // call into the mount manager to get all of the mount points
    //
    
    pIrp = IoBuildDeviceIoControlRequest( IOCTL_MOUNTMGR_QUERY_POINTS,
                                          pDeviceObject, 
                                          pMountPoint,      // InputBuffer
                                          sizeof(MOUNTMGR_MOUNT_POINT) 
                                            + pMountPoint->DeviceNameLength, 
                                          pMountPoints,     // OutputBuffer
                                          MountPointsLength, 
                                          FALSE,            // InternalIoctl
                                          pEvent,
                                          &IoStatusBlock );

    if (pIrp == NULL) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        leave;
    }

    //
    // call the driver
    //
    
    Status = IoCallDriver(pDeviceObject, pIrp);
    if (Status == STATUS_PENDING) 
    {
        Status = KeWaitForSingleObject( pEvent, 
                                        Executive, 
                                        KernelMode, 
                                        FALSE, 
                                        NULL );
                                        
        ASSERT(NT_SUCCESS(Status));
        
        Status = IoStatusBlock.Status;
    }

    //
    // do we need a larger buffer?
    //

    if (Status == STATUS_BUFFER_OVERFLOW)
    {
        //
        // how much should we allocate? (odd IoStatusBlock isn't used - this 
        // was copied straight from volmount.c ).
        //
        
        MountPointsLength = pMountPoints->Size;
    
        SR_FREE_POOL(pMountPoints, SR_MOUNT_POINTS_TAG);
        pMountPoints = NULL;

        //
        // call the driver again!
        //
        
        goto retry;
    }
    else if (!NT_SUCCESS(Status))
    {
        leave;
    }

    //
    // walk through all of the mount points return and find the 
    // volume guid name
    //

    for (Index = 0; Index < pMountPoints->NumberOfMountPoints; ++Index)
    {
        pVolumePoint = &pMountPoints->MountPoints[Index];

        VolumePoint.Length = pVolumePoint->SymbolicLinkNameLength;
        VolumePoint.Buffer = (PWSTR)( ((PUCHAR)pMountPoints) 
                                      + pVolumePoint->SymbolicLinkNameOffset);
        
        if (MOUNTMGR_IS_VOLUME_NAME(&VolumePoint))
        {
            //
            // found it!
            //
            
            break;
        }
        
    }   // for (Index = 0; pMountPoints->NumberOfMountPoints; ++Index)

    //
    // did we find it?
    //
    
    if (Index == pMountPoints->NumberOfMountPoints) 
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        leave;
    }

    //
    // return it!
    //

    ASSERT(VolumePoint.Buffer[10] == L'{');
    
    RtlCopyMemory( pVolumeGuid,
                   &VolumePoint.Buffer[10],
                   SR_GUID_BUFFER_LENGTH );

    pVolumeGuid[SR_GUID_BUFFER_LENGTH/sizeof(WCHAR)] = UNICODE_NULL;

    SrTrace(NOTIFY, ("SR!SrGetVolumeGuid(%wZ, %ws)\n", 
            pVolumeName, pVolumeGuid ));

} finally {

    //
    // check for unhandled exceptions
    //

    Status = FinallyUnwind(SrGetVolumeGuid, Status);
    

    if (pEvent != NULL)
    {
        SR_FREE_POOL(pEvent, SR_KEVENT_TAG);
        pEvent = NULL;
    }

    if (pMountPoint != NULL)
    {
        SR_FREE_POOL(pMountPoint, SR_MOUNT_POINTS_TAG);
        pMountPoint = NULL;
    }

    if (pMountPoints != NULL)
    {
        SR_FREE_POOL(pMountPoints, SR_MOUNT_POINTS_TAG);
        pMountPoints = NULL;
    }

    if (pFileObject != NULL)
    {
        ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }

} 
    RETURN(Status);    

}   // SrGetVolumeGuid


//
// paulmcd: 7/2000: remove the lookaside code so that the verifier can 
// catch any invalid memory accesses
// 

NTSTATUS
SrAllocateFileNameBuffer (
    IN ULONG TokenLength,
    OUT PUNICODE_STRING * ppBuffer 
    )
{    
    PAGED_CODE();

    ASSERT(ppBuffer != NULL);

    //
    // is the file name too big ?
    //
    
    if (TokenLength > SR_MAX_FILENAME_LENGTH)
    {
        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

#ifdef USE_LOOKASIDE

    *ppBuffer = ExAllocateFromPagedLookasideList(
                    &global->FileNameBufferLookaside
                    );

#else

    *ppBuffer = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool,
                                               UNICODE_STRING,
                                               SR_MAX_FILENAME_LENGTH+sizeof(WCHAR),
                                               SR_FILENAME_BUFFER_TAG );

#endif

    if (*ppBuffer == NULL)
    {
        RETURN(STATUS_INSUFFICIENT_RESOURCES);
    }
    
    (*ppBuffer)->Buffer = (PWCHAR)((*ppBuffer) + 1);
    (*ppBuffer)->Length = 0;
    (*ppBuffer)->MaximumLength = SR_MAX_FILENAME_LENGTH;

    RETURN(STATUS_SUCCESS);
    
}   // SrAllocateFileNameBuffer



VOID
SrFreeFileNameBuffer (
    IN PUNICODE_STRING pBuffer 
    )
{

    PAGED_CODE();
    
    ASSERT(pBuffer != NULL);

#ifdef USE_LOOKASIDE

    ExFreeToPagedLookasideList(
        &global->FileNameBufferLookaside,
        pBuffer );

#else

   SR_FREE_POOL( pBuffer,
                 SR_FILENAME_BUFFER_TAG );

#endif


}   // SrFreeFileNameBuffer



/***************************************************************************++

Routine Description:

    this routine will return the number of hardlinks outstanding on this file
    
Arguments:

    NextDeviceObject - the device object where this query will begin.
    
    FileObject - the object to query

    pNumberOfLinks - returns the number of links

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrGetNumberOfLinks(
    IN PDEVICE_OBJECT NextDeviceObject,
    IN PFILE_OBJECT FileObject,
    OUT ULONG * pNumberOfLinks
    )
{
    FILE_STANDARD_INFORMATION   StandardInformation;
    NTSTATUS                    Status = STATUS_SUCCESS;

    ASSERT(NextDeviceObject != NULL );
    ASSERT(FileObject != NULL);
    ASSERT(pNumberOfLinks != NULL);
    
    PAGED_CODE();

    Status = SrQueryInformationFile( NextDeviceObject,
                                     FileObject,
                                     &StandardInformation,
                                     sizeof(StandardInformation),
                                     FileStandardInformation,
                                     NULL );

    if (!NT_SUCCESS( Status )) {

        RETURN( Status );
    }
    
    *pNumberOfLinks = StandardInformation.NumberOfLinks;

    RETURN( Status );
}   // SrGetNumberOfLinks


/***************************************************************************++

Routine Description:

    this checks the volume provided if necessary.  a hash table is used
    to prevent redundant checks.  if it is necessary to check this volume,
    this function will do so and create any needed directory structures.

    this includes the volume restore location + current restore point 
    location.

    it will fire the first write notification to any listening usermode 
    process.

Arguments:

    pVolumeName - the name of the volume to check on 

    ForceCheck - force a check.  this is passed as TRUE if an SrBackupFile
        failed due to path not found.

Return Value:

    NTSTATUS - Completion status. 

--***************************************************************************/
NTSTATUS
SrCheckVolume(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN BOOLEAN ForceCheck
    )
{
    NTSTATUS        Status;
    PUNICODE_STRING pLogFileName = NULL;
    BOOLEAN         ReleaseLock = FALSE;

    ASSERT(ExIsResourceAcquiredShared(&pExtension->ActivityLock));
    
    PAGED_CODE();

    //
    // has the drive already been checked?
    //

    if (!ForceCheck && pExtension->DriveChecked)
    {
        //
        // all done then
        //
        
        return STATUS_SUCCESS;
    }
            
    try {

        Status = STATUS_SUCCESS;

        //
        // grab the lock EXCLUSIVE
        //

        SrAcquireGlobalLockExclusive();
        ReleaseLock = TRUE;

        //
        // delay load our file config (we have to wait for the file systems
        // to become active) 
        //
        
        if (!global->FileConfigLoaded)
        {

            Status = SrReadConfigFile();
            if (!NT_SUCCESS(Status))
                leave;

            global->FileConfigLoaded = TRUE;
        }
    } finally {

        SrReleaseGlobalLock();
    }

    if (!NT_SUCCESS_NO_DBGBREAK( Status )) {

        goto SrCheckVolume_Cleanup;
    }

    try {

        SrAcquireLogLockExclusive( pExtension );
        
        //
        // check it again with the lock held.
        //

        if (!ForceCheck && pExtension->DriveChecked)
        {
            //
            // all done then
            //
            
            leave;
        }

        //
        //  Check to make sure that the volume is enabled.
        //

        if (!SR_LOGGING_ENABLED(pExtension))
        {
            leave;
        }
            
        //
        // first time we've seen this volume, need to check it
        //

        SrTrace( NOTIFY, ("SR!SrCheckVolume(%wZ, %d)\n", 
                 pExtension->pNtVolumeName, 
                 (ULONG)ForceCheck ));

        //
        // get the volume guid. this can't be done in SrAttachToVolume as it
        // won't work at boot time as the mount mgr is not happy about being 
        // called that early
        //

        pExtension->VolumeGuid.Length = SR_GUID_BUFFER_LENGTH;
        pExtension->VolumeGuid.MaximumLength = SR_GUID_BUFFER_LENGTH;
        pExtension->VolumeGuid.Buffer = &pExtension->VolumeGuidBuffer[0];
        
        Status = SrGetVolumeGuid( pExtension->pNtVolumeName, 
                                  &pExtension->VolumeGuidBuffer[0] );
                                  
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        // look for an existing restore location
        //
        Status = SrCheckForRestoreLocation( pExtension );
        
        //
        // if it failed we might need to create a new restore store .
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND || 
            Status == STATUS_OBJECT_PATH_NOT_FOUND)
        {
            //
            // fire a notification for the first write on this volume
            //

            Status = SrFireNotification( SrNotificationVolumeFirstWrite, 
                                         pExtension,
                                         0 );
                                         
            if (!NT_SUCCESS(Status))
                leave;

            //
            // and create a new restore location
            //

            Status = SrCreateRestoreLocation( pExtension );
            if (!NT_SUCCESS(Status))
                leave;
        } else if (!NT_SUCCESS(Status)) {
            
            leave;
        }

        //
        // and start logging
        //

        if (pExtension->pLogContext == NULL)
        {
            Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pLogFileName);
            if (!NT_SUCCESS(Status))
                leave;
            
            Status = SrGetLogFileName( pExtension->pNtVolumeName, 
                                       SR_FILENAME_BUFFER_LENGTH,
                                       pLogFileName );
                                     
            if (!NT_SUCCESS(Status))
                leave;

            //
            // start logging!
            //
            
            Status = SrLogStart( pLogFileName, 
                                 pExtension,
                                 &pExtension->pLogContext );

            if (!NT_SUCCESS(Status))
            {
                leave;
            }
        }

        //
        // the drive is now checked
        //

        pExtension->DriveChecked = TRUE;

        //
        // we are all done
        //
        
    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrCheckVolume, Status);

        SrReleaseLogLock( pExtension );
    }

SrCheckVolume_Cleanup:

    if (pLogFileName != NULL)
    {
        SrFreeFileNameBuffer( pLogFileName );
        pLogFileName = NULL;
    }

    RETURN(Status);
    
}   // SrCheckVolume




/***************************************************************************++

Routine Description:

    this will check for a restore location on the volume provided.

    this consists of checking both the location + the restore point location.

    it will return failure for no restore location, but will alwasy create 
    the restore point location as long as a good restore location is found.

Arguments:

    pVolumeName - the nt name of the volume to check on 

Return Value:

    NTSTATUS - Completion status. 

--***************************************************************************/
NTSTATUS
SrCheckForRestoreLocation(
    IN PSR_DEVICE_EXTENSION pExtension
    )
{
    NTSTATUS                    Status;
    HANDLE                      Handle = NULL;
    ULONG                       CharCount;
    PUNICODE_STRING             pDirectoryName = NULL;
    IO_STATUS_BLOCK             IoStatusBlock;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PFILE_RENAME_INFORMATION    pRenameInformation = NULL;
    PUNICODE_STRING             pVolumeName;

    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ));
    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) );

    PAGED_CODE();

    try {

        pVolumeName = pExtension->pNtVolumeName;
        ASSERT( pVolumeName != NULL );

        //
        // need to check for an existing _restore directory?
        //


        RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));
        
        //
        // grab a filename buffer
        //

        Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pDirectoryName);
        if (!NT_SUCCESS(Status))
            leave;

        //
        // create our restore point location string
        //

        CharCount = swprintf( pDirectoryName->Buffer,
                              VOLUME_FORMAT RESTORE_LOCATION,
                              pVolumeName,
                              global->MachineGuid );

        pDirectoryName->Length = (USHORT)CharCount * sizeof(WCHAR);

        InitializeObjectAttributes( &ObjectAttributes,
                                    pDirectoryName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = SrIoCreateFile( &Handle,
                                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,                       // OPEN_EXISTING
                                 FILE_DIRECTORY_FILE 
                                  | FILE_SYNCHRONOUS_IO_NONALERT 
                                  | FILE_OPEN_FOR_BACKUP_INTENT,
                                 NULL,
                                 0,                                  // EaLength
                                 IO_IGNORE_SHARE_ACCESS_CHECK,
                                 pExtension->pTargetDevice );

        if (!NT_SUCCESS_NO_DBGBREAK(Status))
            leave;
            
        //
        // the correct location existed .  
        // this is a good restore point to use
        //

        ZwClose(Handle);
        Handle = NULL;

        //
        // is there a restore point directory
        //

        //
        // check our current restore points sub directory; don't need to protect
        // access to CurrentRestoreNumber because we are protected by the
        // ActivityLock.
        //

        CharCount = swprintf( &pDirectoryName->Buffer[pDirectoryName->Length/sizeof(WCHAR)],
                              L"\\" RESTORE_POINT_PREFIX L"%d",
                              global->FileConfig.CurrentRestoreNumber );

        pDirectoryName->Length += (USHORT)CharCount * sizeof(WCHAR);

        InitializeObjectAttributes( &ObjectAttributes,
                                    pDirectoryName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = SrIoCreateFile( &Handle,
                                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,                       // OPEN_EXISTING
                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                                 NULL,
                                 0,                               // EaLength
                                 IO_IGNORE_SHARE_ACCESS_CHECK,
                                 pExtension->pTargetDevice );

        if (!NT_SUCCESS_NO_DBGBREAK(Status))
            leave;

        //
        // all done, it was there
        //
        
        ZwClose(Handle);
        Handle = NULL;

    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrCheckForRestoreLocation, Status);

        if (Handle != NULL)
        {
            ZwClose(Handle);
            Handle = NULL;
        }

        if (pDirectoryName != NULL)
        {
            SrFreeFileNameBuffer(pDirectoryName);
            pDirectoryName = NULL;
        }

    }

    //
    // don't use RETURN.. it's normal to return NOT_FOUND
    //
    
    return Status;

}   // SrCheckForRestoreLocation


NTSTATUS
SrGetMountVolume(
    IN PFILE_OBJECT pFileObject,
    OUT PUNICODE_STRING * ppMountVolume
    )
{    
    NTSTATUS        Status;
    HANDLE          FileHandle = NULL;
    HANDLE          EventHandle = NULL;
    BOOLEAN         RestoreFileObjectFlag = FALSE;
    IO_STATUS_BLOCK IoStatusBlock;
    
    PREPARSE_DATA_BUFFER    pReparseHeader = NULL;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    
    PAGED_CODE();

    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT(ppMountVolume != NULL);

    try {

        *ppMountVolume = NULL;
    
        //
        // get the current mount point information
        //

        pReparseHeader = SR_ALLOCATE_POOL( PagedPool, 
                                           MAXIMUM_REPARSE_DATA_BUFFER_SIZE, 
                                           SR_REPARSE_HEADER_TAG );

        if (pReparseHeader == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        RtlZeroMemory(pReparseHeader, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);

        //
        // first turn off any synchro bit that is set.  we want 
        // async for our calls.  this does :
        //
        // 1) avoids the iomgr from grabbing the FileObjectLock.  this
        // will deadlock if it attempts to grab it.
        //

        if (FlagOn(pFileObject->Flags, FO_SYNCHRONOUS_IO))
        {
            RestoreFileObjectFlag = TRUE;
            pFileObject->Flags = pFileObject->Flags ^ FO_SYNCHRONOUS_IO;
        }

        //
        // get a handle
        //

        Status = ObOpenObjectByPointer( pFileObject,
                                        OBJ_KERNEL_HANDLE,
                                        NULL,      // PassedAccessState
                                        FILE_READ_ATTRIBUTES,
                                        *IoFileObjectType,
                                        KernelMode,
                                        &FileHandle );

        if (!NT_SUCCESS(Status)) {
            leave;
        }

        InitializeObjectAttributes( &ObjectAttributes,
                                    NULL,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = ZwCreateEvent( &EventHandle,
                                EVENT_ALL_ACCESS,
                                &ObjectAttributes,
                                SynchronizationEvent,
                                FALSE);

        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        // get the old mount volume name
        //

        Status = ZwFsControlFile( FileHandle,
                                  EventHandle,
                                  NULL,         // ApcRoutine OPTIONAL,
                                  NULL,         // ApcContext OPTIONAL,
                                  &IoStatusBlock,
                                  FSCTL_GET_REPARSE_POINT,
                                  NULL,         // InputBuffer OPTIONAL,
                                  0,            // InputBufferLength,
                                  pReparseHeader,
                                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE );

        if (Status == STATUS_PENDING)
        {
            Status = ZwWaitForSingleObject( EventHandle, FALSE, NULL );
            if (!NT_SUCCESS(Status)) {
                leave;
            }
                
            Status = IoStatusBlock.Status;
        }

        if ((STATUS_NOT_A_REPARSE_POINT == Status) ||
            !NT_SUCCESS(Status)) {
            leave;
        }

        if (pReparseHeader->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ||
            pReparseHeader->ReparseDataLength == 0)
        {
            Status = STATUS_NOT_A_REPARSE_POINT;
            leave;
        }

        //
        // grab the volume name
        //

        Status = SrAllocateFileNameBuffer( pReparseHeader->MountPointReparseBuffer.SubstituteNameLength,
                                           ppMountVolume );

        if (!NT_SUCCESS(Status)) {
            leave;
        }

        RtlCopyMemory( (*ppMountVolume)->Buffer,
                       pReparseHeader->MountPointReparseBuffer.PathBuffer,
                       pReparseHeader->MountPointReparseBuffer.SubstituteNameLength );

        (*ppMountVolume)->Length = pReparseHeader->MountPointReparseBuffer.SubstituteNameLength;

    } finally {

        Status = FinallyUnwind(SrGetMountVolume, Status);

        if (pReparseHeader != NULL)
        {
            SR_FREE_POOL(pReparseHeader, SR_REPARSE_HEADER_TAG);
            pReparseHeader = NULL;
        }

        if (FileHandle != NULL)
        {
            ZwClose(FileHandle);
            FileHandle = NULL;
        }

        if (EventHandle != NULL)
        {
            ZwClose(EventHandle);
            EventHandle = NULL;
        }

        if (RestoreFileObjectFlag)
        {
            pFileObject->Flags = pFileObject->Flags | FO_SYNCHRONOUS_IO;
        }

        if (!NT_SUCCESS_NO_DBGBREAK(Status) && *ppMountVolume != NULL)
        {
            SrFreeFileNameBuffer(*ppMountVolume);
            *ppMountVolume = NULL;
        }

    }

#if DBG 

    //
    //  We don't want to break if we see STATUS_NOT_A_REPARSE_POINT.
    //

    if (STATUS_NOT_A_REPARSE_POINT == Status) {

        return Status;
    }
    
#endif

    RETURN(Status);

}   // SrGetMountVolume

NTSTATUS
SrCheckFreeDiskSpace(
    IN HANDLE FileHandle,
    IN PUNICODE_STRING pVolumeName OPTIONAL
    )
{    
    NTSTATUS Status;
    FILE_FS_FULL_SIZE_INFORMATION FsFullSizeInformation;
    IO_STATUS_BLOCK IoStatus;

    UNREFERENCED_PARAMETER( pVolumeName );

    PAGED_CODE();
    
    Status = ZwQueryVolumeInformationFile( FileHandle,
                                           &IoStatus,
                                           &FsFullSizeInformation,
                                           sizeof(FsFullSizeInformation),
                                           FileFsFullSizeInformation );
                                           
    if (!NT_SUCCESS(Status)) 
        RETURN(Status);

    //
    // make sure there is 50mb free
    //

    if ((FsFullSizeInformation.ActualAvailableAllocationUnits.QuadPart * 
         FsFullSizeInformation.SectorsPerAllocationUnit *
         FsFullSizeInformation.BytesPerSector) < SR_MIN_DISK_FREE_SPACE)
    {
        //
        // this disk is too full for us
        //

        SrTrace( NOTIFY, ("sr!SrCheckFreeDiskSpace: skipping %wZ due to < 50mb free\n",
                 pVolumeName ));
        
        RETURN(STATUS_DISK_FULL);
    }
    
    RETURN(STATUS_SUCCESS);
}   // SrCheckFreeDiskSpace

/***************************************************************************++

Routine Description:

    this is a private version of ZwSetSecurityObject.  This works around
    a bug in ntfs that does not allow you to change the OWNER to admin, 
    even though PreviousMode is KernelMode.

Arguments:


Return Value:

    NTSTATUS - Completion status. 

--***************************************************************************/
NTSTATUS
SrSetSecurityObjectAsSystem(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    NTSTATUS        Status;
    SR_WORK_ITEM    WorkItem;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    RtlZeroMemory( &WorkItem, sizeof( SR_WORK_ITEM ) );

    WorkItem.Signature = SR_WORK_ITEM_TAG;
    KeInitializeEvent(&WorkItem.Event, NotificationEvent, FALSE);
    WorkItem.Parameter1 = (PVOID) Handle;
    WorkItem.Parameter2 = (PVOID) SecurityInformation;
    WorkItem.Parameter3 = (PVOID) SecurityDescriptor;

    ExInitializeWorkItem( &WorkItem.WorkItem,
                          &SrSetSecurityObjectAsSystemWorker,
                          &WorkItem );

    ExQueueWorkItem( &WorkItem.WorkItem,
                     DelayedWorkQueue );

    //
    //  Wait for work to finish
    //

    Status = KeWaitForSingleObject( &WorkItem.Event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );
    
    ASSERT(NT_SUCCESS(Status));

    RETURN(WorkItem.Status);
}

VOID
SrSetSecurityObjectAsSystemWorker (
    IN PSR_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    SECURITY_INFORMATION SecurityInformation;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    Handle = (HANDLE) pWorkItem->Parameter1;
    SecurityInformation = (SECURITY_INFORMATION) pWorkItem->Parameter2;
    SecurityDescriptor = (PSECURITY_DESCRIPTOR) pWorkItem->Parameter3;

    //
    // change the OWNER now 
    //
    
    Status = ZwSetSecurityObject( Handle,
                                  SecurityInformation,
                                  SecurityDescriptor );

    CHECK_STATUS( Status );

    pWorkItem->Status = Status;
    KeSetEvent(&pWorkItem->Event, 0, FALSE);
}

/***************************************************************************++

Routine Description:

    this is will check if the fileobject passed in really is on the volume
    represented by pExtension .

    if it is not (due to mount points in the path) then it returns the real
    file name and the real volume it's on.

Arguments:


Return Value:

    NTSTATUS - Completion status. 

--***************************************************************************/
NTSTATUS
SrCheckForMountsInPath(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    OUT BOOLEAN * pMountInPath
    )
{
    PDEVICE_OBJECT pFilterDevice;

    PAGED_CODE();
    
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT(pFileObject->Vpb != NULL && pFileObject->Vpb->DeviceObject != NULL);

    *pMountInPath = FALSE;

    //
    // get our device extension that we have attached to this VPB
    //

    pFilterDevice = SrGetFilterDevice(pFileObject->Vpb->DeviceObject);
    if (pFilterDevice == NULL)
    {
        RETURN(STATUS_INVALID_DEVICE_STATE);
    }

    //
    // check it against the passed in extension for a match
    //

    if (pFilterDevice->DeviceExtension == pExtension)
    {
        //
        // it's normal, leave early
        //
        
        RETURN(STATUS_SUCCESS);
    }

    //
    // we went through a mount point
    //

    *pMountInPath = TRUE;
    
    RETURN(STATUS_SUCCESS);

}    // SrCheckForMountsInPath


/***************************************************************************++

Routine Description:

    Return the short file name for the given file object

Arguments:

    pExtension - The SR device extension for the volume on which this file
        resides.
    pFileObject - The file for which we are querying the short name.
    pShortName - The unicode string that will get set to the short name.
    
Return Value:

    Returns STATUS_SUCCESS if the shortname is retrieved successfully.
    Returns STATUS_OBJECT_NAME_NOT_FOUND if this file does not have a 
    short name (e.g., hardlinks).
    Returns STATUS_BUFFER_OVERFLOW if pShortName is not large enough to hold
    the shortname returned.

--***************************************************************************/
NTSTATUS
SrGetShortFileName(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    OUT PUNICODE_STRING pShortName
    )
{
    NTSTATUS                Status;
    PFILE_NAME_INFORMATION  pNameInfo;
    CHAR                    buffer[sizeof(FILE_NAME_INFORMATION)+(SR_SHORT_NAME_CHARS+1)*sizeof(WCHAR)];
    
    PAGED_CODE();

    //
    // make the query
    //
    
    Status = SrQueryInformationFile( pExtension->pTargetDevice,
                                     pFileObject,
                                     buffer,
                                     sizeof(buffer),
                                     FileAlternateNameInformation, 
                                     NULL );

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status ||
        !NT_SUCCESS( Status ))
    {
        //
        //  STATUS_OBJECT_NAME_NOT_FOUND is a valid error that the caller 
        //  should be able to deal with.  Some files do not have shortname
        //  (e.g., hardlinks).  If we hit some other error, just return that
        //  also and let the caller deal.
        //

        return Status;
    }

    pNameInfo = (PFILE_NAME_INFORMATION) buffer;

    //
    // return the short name
    //

    if (pShortName->MaximumLength < pNameInfo->FileNameLength /*+ sizeof(WCHAR)*/)
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // copy the name over
    //
    
    RtlCopyMemory( pShortName->Buffer, 
                   pNameInfo->FileName, 
                   pNameInfo->FileNameLength );

    //
    // update the length and NULL terminate
    //
    
    pShortName->Length = (USHORT)pNameInfo->FileNameLength;
    //pShortName->Buffer[pShortName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\filelist.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    filelist.h

Abstract:

    This is a local header file for filelist.c

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000
    
Revision History:

--*/


#ifndef _FILELIST_H_    
#define _FILELIST_H_

//
//  Enumerated type to describe the different classes of ACLs SR can set
//  on files and directories it controls.
//

typedef enum _SR_ACL_TYPE {

    //
    //  For the \System Volume Information directory and the files contain
    //  in this directory.
    //

    SrAclTypeSystemVolumeInformationDirectory,

    //
    //  For the _restore{MachineGuid} directory and the files contained
    //  in this directory.
    //
    
    SrAclTypeRestoreDirectoryAndFiles,

    //
    //  For the _restore{MachineGuid}\RPx directories
    //
    
    SrAclTypeRPDirectory,

    //
    //  For the files contained in the _restore{MachineGuid}\RPx directories
    //
    
    SrAclTypeRPFiles

} SR_ACL_TYPE, *PSR_ACL_TYPE;

NTSTATUS
SrGetObjectName (
    IN  PSR_DEVICE_EXTENSION pExtension OPTIONAL,
    IN  PVOID pObject, 
    OUT PUNICODE_STRING pName, 
    IN  ULONG NameLength
    );

PWSTR
SrpFindFilePartW (
    IN PWSTR pPath
    );

PSTR
SrpFindFilePart (
    IN PSTR pPath
    );

NTSTATUS
SrFindCharReverse(
    IN PWSTR pToken,
    IN ULONG TokenLength, 
    IN WCHAR FindChar, 
    OUT PWSTR * ppToken,
    OUT PULONG pTokenLength
    );


NTSTATUS 
SrGetDestFileName(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    OUT PUNICODE_STRING pDestFileName
    );


NTSTATUS
SrGetNextFileNumber (
    OUT PULONG pNextFileNumber
    );

NTSTATUS
SrGetNextSeqNumber (
    OUT PINT64 pNextSeqNumber
    );

NTSTATUS
SrGetSystemVolume (
    OUT PUNICODE_STRING pFileName,
    OUT PSR_DEVICE_EXTENSION *ppSystemVolumeExtension,
    IN ULONG FileNameLength
    );


//
// a backup history, for only performing one backup per session
//

#define BACKUP_BUCKET_COUNT     2003 // a prime number
#define BACKUP_BUCKET_LENGTH    (5 * 1024 * 1024) // 5mb

NTSTATUS
SrMarkFileBackedUp(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    IN USHORT StreamNameLength,
    IN SR_EVENT_TYPE CurrentEvent,
    IN SR_EVENT_TYPE FutureEventsToIgnore
    );

BOOLEAN
SrHasFileBeenBackedUp(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    IN USHORT StreamNameLength,
    IN SR_EVENT_TYPE EventType
    );

NTSTATUS
SrResetBackupHistory (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName OPTIONAL,
    IN USHORT StreamNameLength OPTIONAL,
    IN SR_EVENT_TYPE EventType
    );


//
// the size of the full buffer
//

#define SR_RENAME_BUFFER_LENGTH         ( sizeof(FILE_RENAME_INFORMATION) \
                                            +SR_MAX_FILENAME_LENGTH     \
                                            +sizeof(WCHAR) )


#define SR_FILENAME_BUFFER_LENGTH       ( sizeof(UNICODE_STRING)        \
                                            +SR_MAX_FILENAME_LENGTH     \
                                            +sizeof(WCHAR) )


#define SR_FILENAME_BUFFER_DEPTH     50


NTSTATUS
FORCEINLINE
SrAddAccessAllowedAce (
    PACL Acl,
    PSID Sid,
    ACCESS_MASK Access,
    ULONG AceIndex,
    UCHAR AceFlags
    )
/*++

Routine Description:

    This routine calls the appropriate Rtl routines to add an access ACE
    to an ACL and set the inheritance as specified by the AceFlags.
    
Arguments:

    Acl - The Acl to which this ACE should be added.
    
    Sid - The id of the user/group to which this ACE applies.
    
    Access - The access to allow this Sid.
    
    AceIndex - The index for this ACE in the ACL.

    AceFlags - The flags to set on for this ACE.
    
Return Value:

    STATUS_SUCCESS if the ACE was set successfully, or the appropriate error
    otherwise.
    
--*/
{
    NTSTATUS status;
    PACE_HEADER aceHeader;
    
    status = RtlAddAccessAllowedAce( Acl,
                                     ACL_REVISION,
                                     Access,
                                     Sid );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    if (AceFlags != 0) {
        
        status = RtlGetAce( Acl, AceIndex, &aceHeader );

        if (!NT_SUCCESS( status )) {

            return status;
        }

        aceHeader->AceFlags = AceFlags;
    }

    return status;
}

PVOID
SrResetHistory(
    IN PHASH_KEY pKey, 
    IN PVOID pEntryContext,
    PUNICODE_STRING pDirectoryName
    );

PDEVICE_OBJECT
SrGetVolumeDevice (
    PFILE_OBJECT pFileObject
    );

NTSTATUS
SrSetFileSecurity (
    IN HANDLE FileHandle,
    IN SR_ACL_TYPE AclType
    );

NTSTATUS
SrGetVolumeGuid (
    IN PUNICODE_STRING pVolumeName,
    OUT PWCHAR pVolumeGuid
    );

NTSTATUS
SrAllocateFileNameBuffer (
    IN ULONG TokenLength,
    OUT PUNICODE_STRING * ppBuffer 
    );
    
VOID
SrFreeFileNameBuffer (
    IN PUNICODE_STRING pBuffer 
    );


NTSTATUS
SrGetNumberOfLinks (
    IN PDEVICE_OBJECT NextDeviceObject,
    IN PFILE_OBJECT FileObject,
    OUT ULONG * pNumberOfLinks
    );

NTSTATUS
SrCheckVolume (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN BOOLEAN ForceCheck
    );

NTSTATUS
SrCheckForRestoreLocation (
    IN PSR_DEVICE_EXTENSION pExtension
    );

NTSTATUS
SrGetMountVolume (
    IN PFILE_OBJECT pFileObject,
    OUT PUNICODE_STRING * ppMountVolume
    );

NTSTATUS
SrCheckFreeDiskSpace (
    IN HANDLE FileHandle,
    IN PUNICODE_STRING pVolumeName OPTIONAL
    );

NTSTATUS
SrSetSecurityObjectAsSystem (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
SrSetSecurityObjectAsSystemWorker (
    IN PSR_WORK_ITEM pWorkItem
    );

NTSTATUS
SrCheckForMountsInPath(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    OUT BOOLEAN * pMountInPath
    );

NTSTATUS
SrGetShortFileName (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    OUT PUNICODE_STRING pShortName
    );

#endif // _FILELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\filenames.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    event.h

Abstract:

    contains prototypes for functions in event.c

Author:

    Paul McDaniel (paulmcd)     01-March-2000

Revision History:

--*/


#ifndef _FILENAMES_H_
#define _FILENAMES_H_


#if DBG

VOID
VALIDATE_FILENAME(
    IN PUNICODE_STRING pName
    );

#else

#define VALIDATE_FILENAME(_fileName) ((VOID)0)

#endif

NTSTATUS
SrpGetFileName(
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN PFILE_OBJECT pFileObject,
    IN OUT PSRP_NAME_CONTROL pNameCtrl
    );

NTSTATUS
SrpGetFileNameFromFileObject (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN PFILE_OBJECT pFileObject,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    );

NTSTATUS
SrpGetFileNameOpenById (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN PFILE_OBJECT pFileObject,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    );

VOID
SrpRemoveStreamName(
    IN OUT PSRP_NAME_CONTROL pNameCtrl
    );

NTSTATUS
SrpExpandDestPath (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN HANDLE RootDirectory,
    IN ULONG FileNameLength,
    IN PWSTR pFileName,
    IN PSR_STREAM_CONTEXT pOriginalFileContext,
    IN PFILE_OBJECT pOriginalFileObject,
    OUT PUNICODE_STRING *ppNewName,
    OUT PUSHORT pNewNameStreamLength,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    );

VOID
SrpInitNameControl(
    IN PSRP_NAME_CONTROL pNameCtrl
    );

VOID
SrpCleanupNameControl(
    IN PSRP_NAME_CONTROL pNameCtrl
    );

NTSTATUS
SrpReallocNameControl(
    IN PSRP_NAME_CONTROL pNameCtrl,
    ULONG newSize,
    PWCHAR *retOriginalBuffer OPTIONAL
    );

NTSTATUS
SrpExpandFileName (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN SR_EVENT_TYPE EventFlags,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    );

NTSTATUS
SrIsFileEligible (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN IsDirectory,
    IN SR_EVENT_TYPE EventFlags,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pIsInteresting,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    );

BOOLEAN
SrFileNameContainsStream (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext OPTIONAL
    );

BOOLEAN
SrFileAlreadyExists (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext OPTIONAL
    );

NTSTATUS
SrIsFileStream (
    PSR_DEVICE_EXTENSION pExtension,
    PSRP_NAME_CONTROL pNameCtrl,
    PBOOLEAN pIsFileStream,
    PBOOLEAN pReasonableErrorForUnOpenedName
    );

NTSTATUS
SrCheckForNameTunneling (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN OUT PSR_STREAM_CONTEXT *ppFileContext
    );

//
//  If it is determined that we need to allocate a buffer anyway we might as
//  well make it big enough to hold most expanded short names.  Allocate this
//  much extra to handle this.
//

#define SHORT_NAME_EXPANSION_SPACE 512


//
//  This macro will check to see if we need to grow the name control buffer
//

#define SrpNameCtrlBufferCheck( nctrl, len ) \
    (((len) > ((nctrl)->BufferSize - sizeof(WCHAR))) ? \
        SrpReallocNameControl( (nctrl), \
                               (len) + \
                                 SHORT_NAME_EXPANSION_SPACE + \
                                 sizeof(WCHAR), \
                               NULL ) : \
        STATUS_SUCCESS)
        
//
//  This macro will check to see if we need to grow the name control buffer.
//  This will also return the old allocated buffer if there was one.
//

#define SrpNameCtrlBufferCheckKeepOldBuffer( nctrl, len, retBuf ) \
    (((len) > ((nctrl)->BufferSize - sizeof(WCHAR))) ? \
        SrpReallocNameControl( (nctrl), \
                               (len) + \
                                 SHORT_NAME_EXPANSION_SPACE + \
                                 sizeof(WCHAR), \
                               (retBuf) ) : \
        (*(retBuf) = NULL, STATUS_SUCCESS))  /*make sure buffer is NULLED*/  


#endif // _FILENAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\hash.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    this homes kernel mode hash routines
    
Author:

    Paul McDaniel (paulmcd)     28-Apr-2000

Revision History:

--*/


#include "precomp.h"

//
// Private constants.
//

//
// Private types.
//

//
// Private prototypes.
//

NTSTATUS
HashpFindEntry ( 
    IN PHASH_HEADER pHeader,
    IN PHASH_BUCKET pBucket OPTIONAL,
    IN ULONG HashValue,
    IN PHASH_KEY pKey,
    OUT PVOID * ppContext,
    OUT PULONG pIndex
    );

LONG
HashpCompare (
    IN PHASH_HEADER pHeader,
    IN ULONG HashValue,
    IN PHASH_KEY pKey,
    IN PHASH_ENTRY pEntry
    );

LONG
HashpCompareStreams (
    PHASH_KEY pKey,
    PHASH_ENTRY pEntry
    );

VOID
HashTrimList (
    IN PHASH_HEADER pHeader
    );

//
// linker commands
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, HashCreateList )
#pragma alloc_text( PAGE, HashAddEntry )
#pragma alloc_text( PAGE, HashFindEntry )
#pragma alloc_text( PAGE, HashpFindEntry )
#pragma alloc_text( PAGE, HashpCompare )
#pragma alloc_text( PAGE, HashpCompareStreams )
#pragma alloc_text( PAGE, HashClearEntries )
#pragma alloc_text( PAGE, HashClearAllFileEntries )
#pragma alloc_text( PAGE, HashProcessEntries )
#pragma alloc_text( PAGE, HashDestroyList )
#pragma alloc_text( PAGE, HashTrimList )
#endif  // ALLOC_PRAGMA


//
// Private globals.
//

#define CONTINUE -1
#define FOUND     0
#define NOT_FOUND 1

//
//  We track how much memory we have used for the names we have in the hash.
//  We need to track the memory for both the file and stream components of the
//  name.
//

#define HASH_KEY_LENGTH( pHashKey ) \
    ((pHashKey)->FileName.Length + (pHashKey)->StreamNameLength)
    
//
// Public globals.
//

//
// Public functions.
//


NTSTATUS
HashCreateList( 
    IN ULONG BucketCount,
    IN ULONG AllowedLength,
    IN ULONG PrefixLength OPTIONAL,
    IN PHASH_ENTRY_DESTRUCTOR pDestructor OPTIONAL,
    OUT PHASH_HEADER * ppHeader
    )
{
    NTSTATUS        Status;
    PHASH_HEADER    pHeader;

    PAGED_CODE();

    ASSERT(ppHeader != NULL);
    
    pHeader = SR_ALLOCATE_STRUCT_WITH_SPACE( NonPagedPool, 
                                             HASH_HEADER, 
                                             sizeof(PHASH_BUCKET) * BucketCount,
                                             HASH_HEADER_TAG );
    if (pHeader == NULL)
    {   
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    RtlZeroMemory( pHeader, 
                   sizeof(HASH_HEADER) 
                        + (sizeof(PHASH_BUCKET) * BucketCount) );

    pHeader->Signature = HASH_HEADER_TAG;
    pHeader->BucketCount = BucketCount;
    pHeader->AllowedLength = AllowedLength;
    pHeader->PrefixLength = PrefixLength;
    pHeader->pDestructor = pDestructor;
    ExInitializeResourceLite(&pHeader->Lock);

    *ppHeader = pHeader;

    SrTrace(HASH, ("SR!HashCreateList(%p)\n", pHeader));

    Status = STATUS_SUCCESS;

end:
    RETURN(Status);
    
}   // HashCreateList

NTSTATUS   
HashAddEntry( 
    IN PHASH_HEADER pHeader,
    IN PHASH_KEY pKey,
    IN PVOID pContext 
   )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PHASH_BUCKET    pNewBucket = NULL;
    PHASH_BUCKET    pOldBucket = NULL;
    PHASH_BUCKET    pBucket = NULL;
    PHASH_ENTRY     pEntry = NULL;
    ULONG           HashValue = 0;
    ULONG           HashBucket = 0;
    ULONG           Index = 0;
    PVOID           pTemp = NULL;
    PWCHAR          pKeyBuffer = NULL;
    BOOLEAN         lookedUpHashValue = FALSE; // Use this to track if the
                                               // HashValue is valid.

    PAGED_CODE();
    
    ASSERT(IS_VALID_HASH_HEADER(pHeader));
    ASSERT(pKey != NULL);

    try {

        //
        // the caller is responsible for synchronizing access to this list
        // paulmcd: 1/01
        //

        ASSERT(ExIsResourceAcquiredExclusive(&pHeader->Lock));

        //
        // do we need to trim space ?
        //

        if (pHeader->UsedLength > pHeader->AllowedLength)
        {
            (VOID)HashTrimList(pHeader);
        }

        Status = RtlHashUnicodeString( &(pKey->FileName), 
                                       TRUE, 
                                       HASH_STRING_ALGORITHM_DEFAULT, 
                                       &HashValue );
                                       
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        lookedUpHashValue = TRUE;
        
        HashBucket = HashValue % pHeader->BucketCount;

        pBucket = pHeader->Buckets[HashBucket];

        ASSERT(pBucket == NULL || IS_VALID_HASH_BUCKET(pBucket));
        
        //
        // find this entry in the bucket list
        //

        Status = HashpFindEntry( pHeader, 
                                 pBucket, 
                                 HashValue, 
                                 pKey, 
                                 &pTemp, 
                                 &Index );

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // did it fail ?
            //
            
            if (!NT_SUCCESS(Status)) {
                
                leave;
            }

            //
            // we found it... update the context
            //

            if (pBucket == NULL)
            {
                ASSERTMSG("sr.sys[hash.c] Hash Bucket is NULL!", FALSE);
                Status = STATUS_INVALID_DEVICE_REQUEST;
                leave;
            }

            ASSERT(IS_VALID_HASH_BUCKET(pBucket));
            ASSERT(Index < pBucket->UsedCount);

            pBucket->Entries[Index].pContext = pContext;

            //
            // all done, give an error just to make sure they were expecting
            // duplicates !
            //

            Status = STATUS_DUPLICATE_OBJECTID;
            
            leave;
        }

        //
        // didn't find it... let's insert it
        //

        //
        // any existing entries?
        //

        if (pBucket == NULL)
        {
            //
            // allocate a sibling array
            //

            pBucket = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool,
                                                     HASH_BUCKET,
                                                     sizeof(HASH_ENTRY) 
                                                        * HASH_ENTRY_DEFAULT_WIDTH,
                                                     HASH_BUCKET_TAG );

            if (pBucket == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }

            RtlZeroMemory( pBucket,
                           sizeof(HASH_BUCKET) +
                                sizeof(HASH_ENTRY) * HASH_ENTRY_DEFAULT_WIDTH );

            pBucket->Signature = HASH_BUCKET_TAG;
            pBucket->AllocCount = HASH_ENTRY_DEFAULT_WIDTH;

        }
        else if ((pBucket->UsedCount + 1) > pBucket->AllocCount)
        {
            //
            // Grow a bigger array
            //

            pNewBucket = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool,
                                                        HASH_BUCKET,
                                                        sizeof(HASH_ENTRY) 
                                                            * (pBucket->AllocCount * 2),
                                                        HASH_BUCKET_TAG );

            if (pNewBucket == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }

            RtlCopyMemory( pNewBucket,
                           pBucket,
                           sizeof(HASH_BUCKET) +
                                sizeof(HASH_ENTRY) * pBucket->AllocCount );

            RtlZeroMemory( ((PUCHAR)pNewBucket) + sizeof(HASH_BUCKET) +
                                        sizeof(HASH_ENTRY) * pBucket->AllocCount,
                            sizeof(HASH_ENTRY) * pBucket->AllocCount );

            pNewBucket->AllocCount *= 2;

            pOldBucket = pBucket;
            pBucket = pNewBucket;
        }

        //
        // Allocate an key buffer
        //

        pKeyBuffer = SR_ALLOCATE_ARRAY( PagedPool,
                                        WCHAR,
                                        (HASH_KEY_LENGTH( pKey )/sizeof(WCHAR))+1,
                                        HASH_KEY_TAG );

        if (pKeyBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        //
        // need to shuffle things around?
        //

        if (Index < pBucket->UsedCount)
        {
            //
            // shift right the chunk at Index
            //

            RtlMoveMemory( &(pBucket->Entries[Index+1]),
                           &(pBucket->Entries[Index]),
                           (pBucket->UsedCount - Index) * sizeof(HASH_ENTRY) );

        }

        //
        // now fill in the entry
        //
        
        pEntry = &pBucket->Entries[Index];

        pEntry->Key.FileName.Buffer = pKeyBuffer;

        //
        // copy over the key string
        //
        
        RtlCopyMemory( pEntry->Key.FileName.Buffer,
                       pKey->FileName.Buffer,
                       pKey->FileName.Length + pKey->StreamNameLength);

        pEntry->Key.FileName.Length = pKey->FileName.Length;
        pEntry->Key.FileName.MaximumLength = pKey->FileName.MaximumLength;
        pEntry->Key.StreamNameLength = pKey->StreamNameLength;

        //
        // NULL terminate it
        //
        
        pEntry->Key.FileName.Buffer[(pEntry->Key.FileName.Length + pEntry->Key.StreamNameLength)/sizeof(WCHAR)] = UNICODE_NULL;

        //
        // and the hash value and context
        //
        
        pEntry->HashValue = HashValue;
        pEntry->pContext = pContext;
        
        //
        // update we've used an extra block
        //

        pBucket->UsedCount += 1;

        //
        // update the hash header with this new bucket
        //
        
        pHeader->Buckets[HashBucket] = pBucket;

        //
        // update our used count
        //
        
        pHeader->UsedLength += HASH_KEY_LENGTH( &(pEntry->Key) );

        //
        // all done
        //
        
        Status = STATUS_SUCCESS;

    }finally {

        Status = FinallyUnwind( HashAddEntry, Status );

        if (lookedUpHashValue) {

            if ((Status != STATUS_DUPLICATE_OBJECTID) && !NT_SUCCESS(Status))
            {
                //
                // free any new bucket we allocated but didn't use
                //
                
                if (pHeader->Buckets[HashBucket] != pBucket && pBucket != NULL)
                {
                    SR_FREE_POOL_WITH_SIG(pBucket, HASH_BUCKET_TAG);
                }

                //
                // same for the key buffer
                //
                
                if (pKeyBuffer != NULL)
                {
                    SR_FREE_POOL(pKeyBuffer, HASH_KEY_TAG);
                    pKeyBuffer = NULL;
                }
            }
            else
            {
                SrTraceSafe( HASH, ("sr!HashAddEntry(%p[%d][%d], ['%wZ', %p]) %ws%ws\n",
                             pHeader,
                             HashBucket,
                             Index,
                             &(pKey->FileName),
                             pContext,
                             (Index < (pBucket->UsedCount-1)) ? L"[shifted]" : L"",
                             (pOldBucket) ? L"[realloc]" : L"" ) );
            
                //
                // supposed to free the old bucket buffer?
                //

                if (pOldBucket != NULL)
                {
                    SR_FREE_POOL_WITH_SIG(pOldBucket, HASH_BUCKET_TAG);
                }
            }
        }

    }

#if DBG

    if (Status == STATUS_DUPLICATE_OBJECTID)
    {
        //
        // don't want to break when we return this
        //
        
        return Status;
    }
    
#endif

    RETURN(Status);

}   // HashAddEntry


NTSTATUS
HashFindEntry( 
    IN PHASH_HEADER pHeader,
    IN PHASH_KEY pKey,
    OUT PVOID * ppContext
    )
{
    NTSTATUS Status;
    ULONG Index;
    ULONG HashValue;
    ULONG HashBucket;

    PAGED_CODE();

    ASSERT(IS_VALID_HASH_HEADER(pHeader));
    ASSERT(pKey != NULL);
    ASSERT(ppContext != NULL);

    //
    // this has to be held as we are returning a context who's refcount
    // is owned by the hash, and can be free'd on the lock is released
    //

    //
    // the caller is responsible for synchronizing access to this list
    // paulmcd: 1/01
    //
    
    ASSERT(ExIsResourceAcquiredShared(&pHeader->Lock));

    Status = RtlHashUnicodeString( &(pKey->FileName), 
                                   TRUE, 
                                   HASH_STRING_ALGORITHM_DEFAULT, 
                                   &HashValue );
                                   
    if (!NT_SUCCESS(Status))
        return Status;
    
    HashBucket = HashValue % pHeader->BucketCount;

    Status = HashpFindEntry( pHeader,
                             pHeader->Buckets[HashBucket],
                             HashValue, 
                             pKey, 
                             ppContext, 
                             &Index );

    return Status;
}   // HashFindEntry


NTSTATUS
HashpFindEntry( 
    IN PHASH_HEADER pHeader,
    IN PHASH_BUCKET pBucket OPTIONAL,
    IN ULONG HashValue,
    IN PHASH_KEY pKey,
    OUT PVOID * ppContext,
    OUT PULONG pIndex
    )
{
    NTSTATUS        Status;
    PHASH_ENTRY     pEntry;
    ULONG           Index = 0;

    PAGED_CODE();

    ASSERT(IS_VALID_HASH_HEADER(pHeader));
    ASSERT(pBucket == NULL || IS_VALID_HASH_BUCKET(pBucket));
    ASSERT(HashValue != 0);
    ASSERT(pKey != NULL);
    ASSERT(ppContext != NULL);
    ASSERT(pIndex != NULL);

    //
    // assume we didn't find it
    //
    
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // are there any entries in this bucket?
    //
    
    if (pBucket != NULL)
    {

        //
        // Walk the sorted array looking for a match (linear)
        //

        //
        // CODEWORK:  make this a binary search!
        //

        for (Index = 0; Index < pBucket->UsedCount; Index++)
        {
            LONG result;
            
            pEntry = &pBucket->Entries[Index];

            result = HashpCompare( pHeader,
                                   HashValue,
                                   pKey,
                                   pEntry );

            if (result == NOT_FOUND)
            {
                //
                //  We passed this name in the sorted list, so stop.
                //
                break;
            }
            else if (result == FOUND)
            {
                //
                //  We got a match, so return the context.
                //

                Status = STATUS_SUCCESS;
                *ppContext = pEntry->pContext;
                break;
            }

            // 
            //  else if (result == CONTINUE)
            //
            //  Otherwise, keep scanning.
            //
        
        }   // for (Index = 0; Index < pBucket->UsedCount; Index++)
        
    }   // if (pBucket != NULL)

    *pIndex = Index;

    return Status;

}   // HashpFindEntry

/***************************************************************************++

Routine Description:

    This routine will compare two HASH_KEYs (one explicitly passed in and the
    other in the pEntry).  This comparison function assumes sorting in the 
    following way:
        * Increasing hash values
        * File names (not including stream components) in increasing lengths.
        * File names in lexically increasing order.
        * Stream components in increasing lengths.
        * Stream components in lexically increasing order.

    Because this routine routine assumes the above sort, it will return
    one of three values indicating that pKey is not in the list, we've
    matched pKey or we need to keep looking.

    Examples of lexically sorted order:
        "cat" < "cats"
        "stream1" < "stream2"
        "file1" < "file1:stream1"
    
Arguments:

    pHeader - The header for this hash table.
    HashValue - The hash value for pKey
    pKey - The hash key we are looking up.  Note: the name buffer is NOT
        NULL terminated.
    pEntry - The entry with the hash key we are comparing against.  Note:
        the name buffer for this hash key IS NULL terminated.
        
Return Value:

    NOT_FOUND - pKey does not match pEntry->Key and we know that it is not in 
        the list because pKey is LESS than pEntry->Key (by our sort definition).
    FOUND - pKey matches pEntry->Key
    CONTINUE - pKey does not match pEntry->Key, but it is GREATER 
        than pEntry->Key (by our sort definition), so keep looking.

--***************************************************************************/
LONG
HashpCompare (
    IN PHASH_HEADER pHeader,
    IN ULONG HashValue,
    IN PHASH_KEY pKey,
    IN PHASH_ENTRY pEntry
    )
{
    int temp;

    PAGED_CODE();
    
    //
    // How does the hash compare?
    //

    if (HashValue > pEntry->HashValue)
    {
        //
        // larger, time to stop
        //
        return CONTINUE;
    }
    else if (HashValue == pEntry->HashValue)
    {
        //
        // and the length?
        //

        if (pKey->FileName.Length < pEntry->Key.FileName.Length)
        {
            return NOT_FOUND;
        }
        else if (pKey->FileName.Length == pEntry->Key.FileName.Length)
        {
            ULONG offsetToFileName;
            
            ASSERT(pHeader->PrefixLength < pKey->FileName.Length);

            offsetToFileName = pHeader->PrefixLength/sizeof(WCHAR);

            //
            //  Use pKey's length to control how long to search since it is
            //  not necessarily NULL terminated and pEntry is.
            //
            
            temp = _wcsnicmp( pKey->FileName.Buffer + offsetToFileName,
                              pEntry->Key.FileName.Buffer + offsetToFileName,
                              pKey->FileName.Length/sizeof(WCHAR) - offsetToFileName );

            if (temp > 0)
            {
                //
                //  pKey > pEntry->Key, so we need to keep looking.
                //
                return CONTINUE;
            }
            else if (temp == 0)
            {
                //
                //  Found a file name match.  Now we look at the stream
                //  components of the name for the match.
                //

                return HashpCompareStreams( pKey, pEntry );
            }
            else
            {
                return NOT_FOUND;
            }
        }
        else 
        {
            //
            // pKey->FileName.Length > pEntry->Key.FileName.Length
            //
            return CONTINUE;
        }        
    }
    else
    {
        return NOT_FOUND;
    }
 }

LONG
HashpCompareStreams (
    PHASH_KEY pKey,
    PHASH_ENTRY pEntry
    )
{
    int temp;

    PAGED_CODE();

    //
    //  This is the most common case, so make the check quick.
    //

    if (pKey->StreamNameLength == 0 &&
        pEntry->Key.StreamNameLength == 0)
    {
        return FOUND;
    }
    
    if (pKey->StreamNameLength < pEntry->Key.StreamNameLength)
    {
        return NOT_FOUND;
    }
    else if (pKey->StreamNameLength == pEntry->Key.StreamNameLength)
    {
        ULONG offsetToStream;

        ASSERT( pKey->StreamNameLength > 0 );
        
        offsetToStream = pKey->FileName.Length/sizeof(WCHAR);
        
        //
        //  See if stream name matches
        //

        temp = _wcsnicmp( pKey->FileName.Buffer + offsetToStream,
                          pEntry->Key.FileName.Buffer + offsetToStream,
                          pKey->StreamNameLength/sizeof(WCHAR) );

        if (temp > 0)
        {
            //
            //  pKey > pEntry->Key, so we need to keep looking.
            //
            return CONTINUE;
        }
        else if (temp == 0)
        {
            //
            // Found the exact match
            //

            return FOUND;
        }
        else
        {
            //
            // pKey < pEntry->Key
            //
            
            return NOT_FOUND;
        }
    }
    else
    {
        //
        // pKey->FileName.Length > pEntry->Key.FileName.Length
        //
        
        return CONTINUE;
    }
}

VOID
HashClearEntries(
    IN PHASH_HEADER pHeader
    )
{
    ULONG           Index;
    ULONG           Index2;
    PHASH_BUCKET    pBucket;
    PHASH_ENTRY     pEntry;
    
    PAGED_CODE();

    ASSERT(IS_VALID_HASH_HEADER(pHeader));

    SrTrace(HASH, ("SR!HashClearEntries(%p)\n", pHeader));

    //
    // the caller is responsible for synchronizing access to this list
    // paulmcd: 1/01
    //

    ASSERT(ExIsResourceAcquiredExclusive(&pHeader->Lock));

    //
    // walk all of our entries and delete them
    //

    for (Index = 0; Index < pHeader->BucketCount; ++Index)
    {
        pBucket = pHeader->Buckets[Index];

        if (pBucket != NULL)
        {
            ASSERT(IS_VALID_HASH_BUCKET(pBucket));

            for (Index2 = 0 ; Index2 < pBucket->UsedCount; ++Index2)
            {
                pEntry = &pBucket->Entries[Index2];

                //
                // invoke the callback?
                //

                if (pHeader->pDestructor != NULL)
                {
                    pHeader->pDestructor(&pEntry->Key, pEntry->pContext);
                }

                //
                // update our header usage
                //

                pHeader->UsedLength -= HASH_KEY_LENGTH( &(pEntry->Key) );

                SR_FREE_POOL(pEntry->Key.FileName.Buffer, HASH_KEY_TAG);
                pEntry->Key.FileName.Buffer = NULL;
                pEntry->Key.FileName.Length = 0;
                pEntry->Key.FileName.MaximumLength = 0;
                pEntry->Key.StreamNameLength = 0;

                pEntry->HashValue = 0;
                pEntry->pContext = NULL;
            }

            //
            // reset it
            //
            
            pBucket->UsedCount = 0;
        }
    }

    //
    // everything should be gone
    //
    
    ASSERT(pHeader->UsedLength == 0);

    //
    // reset the trim time counter
    //
    
    pHeader->LastTrimTime.QuadPart = 0;
}   // HashClearEntries


VOID
HashProcessEntries(
    IN PHASH_HEADER pHeader,
    IN PHASH_ENTRY_CALLBACK pfnCallback,
    IN PVOID pCallbackContext
    )
{
    ULONG           Index;
    ULONG           Index2;
    PHASH_BUCKET    pBucket;
    PHASH_ENTRY     pEntry;
    
    PAGED_CODE();

    ASSERT(pfnCallback != NULL );
    ASSERT(IS_VALID_HASH_HEADER(pHeader));

    SrTrace(HASH, ("SR!HashProcessEntries(%p)\n", pHeader));

    //
    // grab the lock exclusive
    //

    SrAcquireResourceExclusive(&pHeader->Lock, TRUE);

    //
    // walk all of our entries and "process" them
    //

    for (Index = 0; Index < pHeader->BucketCount; ++Index)
    {
        pBucket = pHeader->Buckets[Index];

        if (pBucket != NULL)
        {
            ASSERT(IS_VALID_HASH_BUCKET(pBucket));

            for (Index2 = 0 ; Index2 < pBucket->UsedCount; ++Index2)
            {
                pEntry = &pBucket->Entries[Index2];

                //
                // invoke the callback
                //

                pEntry->pContext = pfnCallback( &pEntry->Key, 
                                                pEntry->pContext,
                                                pCallbackContext );

            }
        }
    }

    SrReleaseResource(&pHeader->Lock);
}   

NTSTATUS
HashClearAllFileEntries (
    IN PHASH_HEADER pHeader,
    IN PUNICODE_STRING pFileName
    )
{
    NTSTATUS Status;
    ULONG HashValue, HashBucket;
    ULONG Index;
    PHASH_BUCKET pHashBucket;
    PHASH_ENTRY pEntry;

    PAGED_CODE();

    ASSERT( ExIsResourceAcquiredExclusive( &pHeader->Lock ) );
    
    Status = RtlHashUnicodeString( pFileName, 
                                   TRUE, 
                                   HASH_STRING_ALGORITHM_DEFAULT, 
                                   &HashValue );
                                   
    if (!NT_SUCCESS(Status))
    {
        goto HashClearAllFileEntries_Exit;
    }

    HashBucket = HashValue % pHeader->BucketCount;

    pHashBucket = pHeader->Buckets[HashBucket];

    if (pHashBucket == NULL)
    {
        Status = STATUS_SUCCESS;
        goto HashClearAllFileEntries_Exit;
    }
    
    for (Index = 0; Index < pHashBucket->UsedCount; Index++)
    {
        pEntry = &pHashBucket->Entries[Index];

        if (RtlEqualUnicodeString( pFileName, &(pEntry->Key.FileName), TRUE ))
        {
            pEntry->pContext = (PVOID)SrEventInvalid;
        }
    }

HashClearAllFileEntries_Exit:
    
    RETURN( Status );
}

VOID
HashDestroyList( 
    IN PHASH_HEADER pHeader
    )
{
    ULONG           Index;
    PHASH_BUCKET    pBucket;

    PAGED_CODE();

    ASSERT(IS_VALID_HASH_HEADER(pHeader));

    SrTrace(HASH, ("SR!HashDestroyList(%p)\n", pHeader));
        
    //
    // let go of all of the entries
    //
    
    SrAcquireResourceExclusive( &pHeader->Lock, TRUE );    
    HashClearEntries(pHeader);
    SrReleaseResource( &pHeader->Lock );

    //
    // now free the memory blocks
    //

    for (Index = 0; Index < pHeader->BucketCount; ++Index)
    {
        pBucket = pHeader->Buckets[Index];
        if (pBucket != NULL)
        {
            ASSERT(IS_VALID_HASH_BUCKET(pBucket));
            SR_FREE_POOL_WITH_SIG(pBucket, HASH_BUCKET_TAG);
        }
    }

    ExDeleteResourceLite(&pHeader->Lock);
    SR_FREE_POOL_WITH_SIG(pHeader, HASH_HEADER_TAG);
}   // HashDestroyList 


VOID
HashTrimList(
    IN PHASH_HEADER pHeader
    )
{
    LARGE_INTEGER   EndTime;
    LARGE_INTEGER   CurrentTime;
    ULONG           EndLength;
    ULONG           MinutesSinceTrim;
    ULONG           MaxPercentDivisor;
    ULONG           MaxTime;
    ULONG           Index;
    ULONG           Index2;
    PHASH_BUCKET    pBucket;
    PHASH_ENTRY     pEntry;


    PAGED_CODE();

    ASSERT(IS_VALID_HASH_HEADER(pHeader));

    //
    // the caller is responsible for synchronizing access to this list
    // paulmcd: 1/01
    //
    
    ASSERT(ExIsResourceAcquiredExclusive(&pHeader->Lock));


    //
    // decide how much to trim
    //

    //
    // we don't want to trim all of the time, trim based on when we trimmed
    // last
    //

    KeQuerySystemTime( &CurrentTime );

    if (pHeader->LastTrimTime.QuadPart == 0)
    {
        MinutesSinceTrim = 0xffffffff;
    }
    else
    {
        MinutesSinceTrim = (ULONG)(CurrentTime.QuadPart - 
                                    pHeader->LastTrimTime.QuadPart) 
                                        / NANO_FULL_SECOND;
    }

    //
    // < 10 mins = 30% or 8s
    // < 30 mins = 20% or 4s
    // > 1 hour = 10% or 2s
    //
    
    if (MinutesSinceTrim < 10)
    {
        MaxPercentDivisor = 3;  // 30%
        MaxTime = 8;
    }
    else if (MinutesSinceTrim < 60)
    {
        MaxPercentDivisor = 5;  // 20%
        MaxTime = 4;
    }
    else
    {
        MaxPercentDivisor = 10; // 10%
        MaxTime = 2;
    }
    

    SrTrace(HASH, ("sr!HashTrimList, trimming. MinutesSinceTrim=%d,MaxTime=%d, MaxPercentDivisor=%d\n", 
            MinutesSinceTrim,
            MaxTime, 
            MaxPercentDivisor ));

    EndTime.QuadPart = CurrentTime.QuadPart + (MaxTime * NANO_FULL_SECOND);
    
    ASSERT(MaxPercentDivisor != 0);
    EndLength = pHeader->UsedLength - (pHeader->UsedLength / MaxPercentDivisor);


    //
    // update that we've trimmed
    //

    KeQuerySystemTime( &pHeader->LastTrimTime );


    //
    // loop through the hash list
    //

    for (Index = 0; Index < pHeader->BucketCount; ++Index)
    {
        pBucket = pHeader->Buckets[Index];

        if (pBucket != NULL)
        {
            ASSERT(IS_VALID_HASH_BUCKET(pBucket));

            //
            // loop through this bucket
            //

            for (Index2 = 0 ; Index2 < pBucket->UsedCount; ++Index2)
            {

                //
                // throw this away
                //
            
                pEntry = &pBucket->Entries[Index2];

                //
                // invoke the callback?
                //

                if (pHeader->pDestructor != NULL)
                {
                    pHeader->pDestructor(&pEntry->Key, pEntry->pContext);
                }

                //
                // update the length of the hash
                //

                pHeader->UsedLength -= HASH_KEY_LENGTH( &(pEntry->Key) );

                //
                // and free the memory
                //

                SR_FREE_POOL(pEntry->Key.FileName.Buffer, HASH_KEY_TAG);
                pEntry->Key.FileName.Buffer = NULL;
                pEntry->Key.FileName.Length = 0;
                pEntry->Key.FileName.MaximumLength = 0;
                pEntry->Key.StreamNameLength = 0;

                pEntry->HashValue = 0;
                pEntry->pContext = NULL;
            }

            //
            // reset it
            //
            
            pBucket->UsedCount = 0;
            
        }   // if (pBucket != NULL)

        //
        // are we ready to quit
        //

        KeQuerySystemTime( &CurrentTime );

        if (EndTime.QuadPart <= CurrentTime.QuadPart)
        {
            SrTrace(HASH, ("sr!HashTrimList, leaving due to time\n"));
            break;
        }

        if (pHeader->UsedLength <= EndLength)
        {
            SrTrace(HASH, ("sr!HashTrimList, leaving due to space\n"));
            break;
        }
        
    }   // for (Index = 0; Index < pHeader->BucketCount; ++Index)
    

}   // HashTrimList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\lock.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    lock.c

Abstract:

    this file contains the routines that help with managing the 
    volume locks.

Author:

    Molly Brown (mollybro)     04-Jan-2001

Revision History:

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrPauseVolumeActivity )
#pragma alloc_text( PAGE, SrResumeVolumeActivity )

#endif  // ALLOC_PRAGMA

/***************************************************************************++

Routine Description:

    This routine will exclusively acquire the ActivityLock for each volume 
    in the system.  Once the lock is acquired, we set the flag in the device
    extension saying that we know it is acquired so that we know what we need
    to release in case of an error.

    Note:  This routine assumes that the DeviceExtensionListLock is already
    held, either shared or exclusive.
    
Arguments:

    None
    
Return Value:

    Returns STATUS_SUCCESS if all the locks were acquired successfully and
    returns STATUS_LOCK_NOT_GRANTED otherwise.

--***************************************************************************/
NTSTATUS
SrPauseVolumeActivity (
    )
{
    NTSTATUS status = STATUS_LOCK_NOT_GRANTED;
    PLIST_ENTRY pCurrentEntry;
    PSR_DEVICE_EXTENSION pExtension;

    ASSERT( IS_DEVICE_EXTENSION_LIST_LOCK_ACQUIRED() );

    try {
        
        for (pCurrentEntry = global->DeviceExtensionListHead.Flink;
             pCurrentEntry != &global->DeviceExtensionListHead;
             pCurrentEntry = pCurrentEntry->Flink) {

            pExtension = CONTAINING_RECORD( pCurrentEntry,
                                            SR_DEVICE_EXTENSION,
                                            ListEntry );

            ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );

            SrAcquireActivityLockExclusive( pExtension );
            pExtension->ActivityLockHeldExclusive = TRUE;
        }

        //
        //  We successfully acquired all the volume activity locks exclusively.
        //

        status = STATUS_SUCCESS;
        
    } finally {

        status = FinallyUnwind( SrPauseVolumeActivity, status );

        if (!NT_SUCCESS( status )) {

            SrResumeVolumeActivity();
        }
    }

    RETURN( status );
}

/***************************************************************************++

Routine Description:

    This routine will iterate through this list of device extensions and 
    release any activity locks that are held.

    Note:  This routine assumes that the DeviceExtensionListLock is already
    held, either shared or exclusive.
    
Arguments:

    None
    
Return Value:

    None.
    
--***************************************************************************/
VOID
SrResumeVolumeActivity (
    )
{
    PLIST_ENTRY pCurrentEntry;
    PSR_DEVICE_EXTENSION pExtension;

    ASSERT( IS_DEVICE_EXTENSION_LIST_LOCK_ACQUIRED() );
    
    for (pCurrentEntry = global->DeviceExtensionListHead.Flink;
         pCurrentEntry != &global->DeviceExtensionListHead;
         pCurrentEntry = pCurrentEntry->Flink) {

        pExtension = CONTAINING_RECORD( pCurrentEntry,
                                        SR_DEVICE_EXTENSION,
                                        ListEntry );

        ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );

        if (pExtension->ActivityLockHeldExclusive) {
            pExtension->ActivityLockHeldExclusive = FALSE;
            SrReleaseActivityLock( pExtension );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\hash.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    contains prototypes for functions in hash.c

Author:

    Paul McDaniel (paulmcd)     28-Apr-2000

Revision History:

--*/


#ifndef _HASH_H_
#define _HASH_H_

//
//  The hash key is the file name, but we need to track both the file
//  component of the name in addition to the stream component of the name (if
//  there is one).  The buffer in the FileName UNICODE_STRING contains the 
//  full name with stream information, but the length is set to just designate
//  the file portion of the name.
//
//  Note: The keys will be hashed based on the FileName only, not the stream 
//  portion of the name.  This is done so that we can easily find all the
//  entries related to a given file if that file has multiple data streams.
//

typedef struct _HASH_KEY
{

    UNICODE_STRING FileName;

    USHORT StreamNameLength;
    USHORT Reserved;

} HASH_KEY, *PHASH_KEY;

//
// a hash list entry .
//

typedef struct _HASH_ENTRY
{
    //
    // the hash value
    //

    ULONG HashValue;
    
    //
    // the key
    //

    HASH_KEY Key;
    
    //
    // a context stored with this hash entry
    //
    
    PVOID pContext;
    
} HASH_ENTRY, *PHASH_ENTRY;

//
// a hash bucket, which is basically an array of hash entries
// sorted by (HashValue, Key.Length, Key.Buffer) .
//

#define IS_VALID_HASH_BUCKET(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == HASH_BUCKET_TAG))

typedef struct _HASH_BUCKET
{
    //
    // = HASH_BUCKET_TAG
    //
    
    ULONG Signature;
    
    ULONG AllocCount;
    ULONG UsedCount;
    
    HASH_ENTRY Entries[0];

} HASH_BUCKET, *PHASH_BUCKET;


#define HASH_ENTRY_DEFAULT_WIDTH    10

//
// a destructor for hash entries
//

typedef
VOID
(*PHASH_ENTRY_DESTRUCTOR) (
    IN PHASH_KEY pKey, 
    IN PVOID pContext
    );

typedef
PVOID
(*PHASH_ENTRY_CALLBACK) (
    IN PHASH_KEY pKey, 
    IN PVOID pEntryContext,
    IN PVOID pCallbackContext
    );

//
// and a hash header, an array of buckets which is hashed into.
//

#define IS_VALID_HASH_HEADER(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == HASH_HEADER_TAG))

typedef struct _HASH_HEADER
{

    //
    // NonPagedPool
    //

    //
    // = HASH_HEADER_TAG
    //
    
    ULONG Signature;

    //
    // the count of buckets the hash table has
    //
    
    ULONG BucketCount;

    //
    // the memory this hash table is taking
    //

    ULONG UsedLength;

    //
    // the memory this hash table is allowed to use
    //

    ULONG AllowedLength;

    //
    // how many times we've trimmed due to memory
    //

    ULONG TrimCount;
    
    //
    // the last time we trim'd
    //
    
    LARGE_INTEGER LastTrimTime;

    //
    // OPTIONAL the length in bytes of the duplicate prefix (if any) 
    // all keys share in this lists.  This will be skipped for all manual
    // comparisons as an optimization.  this can be 0
    //

    ULONG PrefixLength;

    //
    // the lock for this list
    //

    ERESOURCE Lock;
    
    //
    // OPTIONAL destructor
    //
    
    PHASH_ENTRY_DESTRUCTOR pDestructor;

    //
    // and the actual buckets
    //
    
    PHASH_BUCKET Buckets[0];
    
} HASH_HEADER, *PHASH_HEADER;

// 
// Function Prototypes.
//

NTSTATUS
HashCreateList ( 
    IN ULONG BucketCount,
    IN ULONG AllowedLength,
    IN ULONG PrefixLength OPTIONAL,
    IN PHASH_ENTRY_DESTRUCTOR pDestructor OPTIONAL,
    OUT PHASH_HEADER * ppHashList
    );

VOID
HashDestroyList ( 
    IN PHASH_HEADER pHashList
    );

NTSTATUS
HashAddEntry ( 
    IN PHASH_HEADER pHashList,
    IN PHASH_KEY pKey,
    IN PVOID pContext 
   ); 

NTSTATUS
HashFindEntry ( 
    IN PHASH_HEADER pHashList,
    IN PHASH_KEY pKey,
    OUT PVOID * ppContext
    );

VOID
HashClearEntries (
    IN PHASH_HEADER pHashList
    );

NTSTATUS
HashClearAllFileEntries (
    IN PHASH_HEADER pHeader,
    IN PUNICODE_STRING pFileName
    );

VOID
HashProcessEntries (
    IN PHASH_HEADER pHeader,
    IN PHASH_ENTRY_CALLBACK pfnCallback,
    IN PVOID pCallbackContext
    );

#if 0

#define HashCompute(Key) HashScramble(HashUnicodeString((Key)))


__inline ULONG
HashUnicodeString(
    PUNICODE_STRING pKey
    )
{
    ULONG Hash = 0;
    ULONG Index;
    ULONG CharCount;

    CharCount = pKey->Length/sizeof(WCHAR);
    
    for (Index = 0 ; Index < CharCount;  ++Index)
    {
        Hash = 37 * Hash +  (pKey->Buffer[Index] & 0xFFDF);
    }
    
    return Hash;
}

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKHash applies this internally
// to all hash signatures for exactly this reason.

__inline ULONG
HashScramble(ULONG dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const ULONG RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const ULONG RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}

#endif // 0

#endif // _HASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\hlist.c ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    hashlist.c
 *
 *  Abstract:
 *    This file contains the implementation for hashed list required for
 *    file / extension lookups
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#include "precomp.h"
#include "hashlist.h"

#ifndef RING3

//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, MatchExtension    )
#pragma alloc_text( PAGE, MatchEntry        )

#endif  // ALLOC_PRAGMA

#endif

//
// MatchEntry : Matched the given extension as PathElement and returns the
//    entry type if it is found in the hash table.
//

BOOL 
__inline
MatchEntry(
    IN  PBYTE  pList,       // Pointer to hash list
    IN  LPWSTR pStr,        // Pointer to unicode path string
    IN  INT    NumBytes,    // Number  of unichars in path string
    OUT PINT   pType )      // Pointer to variable returning ext type
{
    INT iHash;
    INT iNode;
    ListEntry *pEntry;
    BOOL fRet = FALSE;

    iHash = HASHSTR(pList, pStr, (USHORT)NumBytes);

    if( (iNode = HASH_BUCKET(pList, iHash)) != 0 )
    {
        pEntry = LIST_NODEPTR(pList, iNode);
    
        while( pEntry  )
        {
            if ( NumBytes == STR_BYTES(pEntry) &&
                 memcmp(pList + pEntry->m_dwData + sizeof(USHORT), 
                        pStr, 
                        NumBytes ) == 0
               ) 
            {
                *pType = pEntry->m_dwType;

                fRet = TRUE;
                break;
            }
    
            if (pEntry->m_iNext == 0)
            {
                break;
            }

            pEntry = LIST_NODEPTR(pList, pEntry->m_iNext);
        }
    }

    return fRet;
}



//
// MatchExtension: Extracts the extension and matches it against the 
//    hashed list
//

BOOL   
__inline
MatchExtension( 
    IN  PBYTE           pList,     // Pointer to hash list
    IN  PUNICODE_STRING pPath ,    // Pointer to unicode path
    OUT PINT            pType,     // Pointer to node type
    OUT PBOOL           pbHasExt ) // Pointer to BOOL var returning ext result
{
    BOOL fRet = FALSE;
    INT i;
    INT ExtLen = 0;
    PWCHAR pExt = NULL;
    UNICODE_STRING ext;
    WCHAR pBuffer[ SR_MAX_EXTENSION_LENGTH+sizeof(WCHAR) ];

    ASSERT(pList    != NULL);
    ASSERT(pPath    != NULL);
    ASSERT(pType    != NULL);
    ASSERT(pbHasExt != NULL);
    ASSERT(pPath->Length >= sizeof(WCHAR));

    *pbHasExt = FALSE;

    //
    //  Find the start of an extension.  We make sure that we don't find
    //  an extension that was on a data stream name.
    //

    for( i=(pPath->Length/sizeof(WCHAR))-1; i>=0; i--)
    {
        if (pPath->Buffer[i] == L'.')
        { 
            if (pExt == NULL)
            {
                pExt = &pPath->Buffer[i+1];
            }
        }
        else if (pPath->Buffer[i] == L':')
        {
            ExtLen = 0;
            pExt = NULL;
        }
        else if (pPath->Buffer[i] == L'\\')
        {
            break;
        }
        else if (pExt == NULL)
        {
            ExtLen++;
        }

        if (ExtLen > SR_MAX_EXTENSION_CHARS)
        {
            break;
        }
    }

    if( pExt && ExtLen > 0 )
    {

        *pbHasExt = TRUE;

        //
        // Create a unicode string for extension
        //

		ext.Buffer = pBuffer;
        ext.Length = (USHORT)(ExtLen *  sizeof(WCHAR));
        ext.MaximumLength = sizeof(pBuffer);
        memcpy( ext.Buffer, 
                pExt, 
                ext.Length );
        ext.Buffer[ ExtLen ] = UNICODE_NULL;

        //
        // Convert to uppercase : Hope this works
        //

        RtlUpcaseUnicodeString( &ext, &ext, FALSE );

        //
        // Check extension list.
        //

        fRet = MatchEntry( pList, 
                           ext.Buffer, 
                           ext.Length,
                           pType);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\filenames.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    filenames.c

Abstract:

    this is the code that handles the file lists (exclusion/inclusion).

Author:

    Neal Christiansen (nealch)     03-Jan-2001

Revision History:

--*/

#include "precomp.h"


//
//  Local prototypes
//

NTSTATUS
SrpExpandShortNames(
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    IN BOOLEAN expandFileNameComponenet
    );

NTSTATUS
SrpExpandPathOfFileName(
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrpGetFileName )
#pragma alloc_text( PAGE, SrpGetFileNameFromFileObject )
#pragma alloc_text( PAGE, SrpGetFileNameOpenById )
#pragma alloc_text( PAGE, SrpExpandShortNames )
#pragma alloc_text( PAGE, SrpExpandPathOfFileName )
#pragma alloc_text( PAGE, SrpRemoveStreamName )
#pragma alloc_text( PAGE, SrpExpandDestPath )
#pragma alloc_text( PAGE, SrpInitNameControl )
#pragma alloc_text( PAGE, SrpCleanupNameControl )
#pragma alloc_text( PAGE, SrpReallocNameControl )
#pragma alloc_text( PAGE, SrpExpandFileName )
#pragma alloc_text( PAGE, SrIsFileEligible )
#pragma alloc_text( PAGE, SrFileNameContainsStream )
#pragma alloc_text( PAGE, SrFileAlreadyExists )
#pragma alloc_text( PAGE, SrIsFileStream )

#endif  // ALLOC_PRAGMA


#if DBG
/***************************************************************************++

Routine Description:

    This presently scans the filename looking for two backslashes in a row.
    If so

Arguments:

Return Value:

--***************************************************************************/
VOID
VALIDATE_FILENAME(
    IN PUNICODE_STRING pName
    )
{
    ULONG i;
    ULONG len;

    if (pName && (pName->Length > 0))
    {
        len = (pName->Length/sizeof(WCHAR))-1;

        //
        //  Setup to scan the name
        //

        for (i=0;
             i < len;
             i++ )
        {
            //
            //  See if there are adjacent backslashes
            //

            if (pName->Buffer[i] == L'\\' &&
                pName->Buffer[i+1] == L'\\')
            {
                if (FlagOn(global->DebugControl, 
                    SR_DEBUG_VERBOSE_ERRORS|SR_DEBUG_BREAK_ON_ERROR))
                {
                    KdPrint(("sr!VALIDATE_FILENAME: Detected adjacent backslashes in \"%wZ\"\n",
                            pName));
                }

                if (FlagOn(global->DebugControl,SR_DEBUG_BREAK_ON_ERROR))
                {
                    DbgBreakPoint();
                }
            }
        }
    }
}

#endif


/***************************************************************************++

Routine Description:

    This routine will try and get the name of the given file object.  This
    will allocate a buffer if it needs to.  Because of deadlock issues we
    do not call ObQueryNameString.  Instead we ask the file system for the
    name by generating our own IRPs.

Arguments:

    pExtension  - the extension for the device this file is on
    pFileObject - the fileObject for the file we want the name of.
    pNameControl - a structure used to manage the name of the file

Return Value:

    status of the operation

--***************************************************************************/
NTSTATUS
SrpGetFileName (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN PFILE_OBJECT pFileObject,
    IN OUT PSRP_NAME_CONTROL pNameCtrl
    )
{
    PFILE_NAME_INFORMATION nameInfo;
    NTSTATUS status;
    ULONG volNameLength = (ULONG)pExtension->pNtVolumeName->Length;
    ULONG returnLength;
    ULONG fullNameLength;

    PAGED_CODE();

    ASSERT(IS_VALID_FILE_OBJECT( pFileObject ) && (pFileObject->Vpb != NULL));
    ASSERT(pNameCtrl->AllocatedBuffer == NULL);

    //
    //  Use the small buffer in the structure (that will handle most cases)
    //  for the name.  Then get the name
    //

    nameInfo = (PFILE_NAME_INFORMATION)pNameCtrl->SmallBuffer;

    status = SrQueryInformationFile( pExtension->pTargetDevice,
                                     pFileObject,
                                     nameInfo,
                                     pNameCtrl->BufferSize - sizeof(WCHAR),
                                     FileNameInformation,
                                     &returnLength );

    //
    //  If the buffer was too small, get a bigger one.
    //

    if (status == STATUS_BUFFER_OVERFLOW)
    {
        //
        //  The buffer was too small, allocate one big enough (including volume
        //  name and terminating NULL)
        //

        status = SrpReallocNameControl( pNameCtrl, 
                                        nameInfo->FileNameLength + 
                                          volNameLength + 
                                          SHORT_NAME_EXPANSION_SPACE +
                                          sizeof(WCHAR),
                                        NULL );

        if (!NT_SUCCESS( status ))
        {
            return status;
        }

        //
        //  Set the allocated buffer and get the name again
        //

        nameInfo = (PFILE_NAME_INFORMATION)pNameCtrl->AllocatedBuffer;

        status = SrQueryInformationFile( pExtension->pTargetDevice,
                                         pFileObject,
                                         nameInfo,
                                         pNameCtrl->BufferSize - sizeof(WCHAR),
                                         FileNameInformation,
                                         &returnLength );
    }

    //
    //  Handle QueryInformation errors
    //

    if (!NT_SUCCESS( status ))
    {
        return status;
    }

    //
    //  We now have the filename.  Calucalte how much space the full name
    //  (including device name) will be.  Include space for a terminating
    //  NULL.  See if there is room in the current buffer.
    //

    fullNameLength = nameInfo->FileNameLength + volNameLength;

    status = SrpNameCtrlBufferCheck( pNameCtrl, fullNameLength);

    if (!NT_SUCCESS( status )) 
    {
        return status;
    }

    //
    //  Slide the file name down to make room for the device name.  Account
    //  for the header in the FILE_NAME_INFORMATION structure
    //

    RtlMoveMemory( &pNameCtrl->Name.Buffer[volNameLength/sizeof(WCHAR) ],
                   nameInfo->FileName,
                   nameInfo->FileNameLength );
            
    RtlCopyMemory( pNameCtrl->Name.Buffer,
                   pExtension->pNtVolumeName->Buffer,
                   volNameLength );

    pNameCtrl->Name.Length = (USHORT)fullNameLength;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Gets the file name and volume name for a file that is not yet opened.
    This is necessary in the MJ_CREATE where work is done prior to the file
    being opened by the fsd.  

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrpGetFileNameFromFileObject (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN PFILE_OBJECT pFileObject,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    NTSTATUS status;
    ULONG fullNameLength;

    PAGED_CODE();

    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT(pExtension->pNtVolumeName != NULL);
    ASSERT(pExtension->pNtVolumeName->Length > 0);
    ASSERT(pNameCtrl->AllocatedBuffer == NULL);

    //
    //  first see if this is a relative open
    //

    if (pFileObject->RelatedFileObject != NULL)
    {
        //
        //  get the full name of the related file object
        //

        status = SrpGetFileName( pExtension,
                                pFileObject->RelatedFileObject,
                                pNameCtrl );

        if (!NT_SUCCESS_NO_DBGBREAK(status))
        {
            goto Cleanup;
        }

        ASSERT(pNameCtrl->Name.Length > 0);

        //
        //  make sure the buffer is still large enough.  Note that we account
        //  for a trailing null to be added as well as the poosible addition
        //  of a separator character.
        //
        
        fullNameLength = pNameCtrl->Name.Length + 
                         sizeof(WCHAR) +            // could be a seperator
                         pFileObject->FileName.Length;

        status = SrpNameCtrlBufferCheck( pNameCtrl, fullNameLength );

        if (!NT_SUCCESS( status ))
        {
            return status;
        }

        //
        // put on the slash seperator if it is missing
        //

        if ((pFileObject->FileName.Length > 0) &&
            (pFileObject->FileName.Buffer[0] != L'\\') &&
            (pFileObject->FileName.Buffer[0] != L':') &&
            (pNameCtrl->Name.Buffer[(pNameCtrl->Name.Length/sizeof(WCHAR))-1] != L'\\'))
        {
            pNameCtrl->Name.Buffer[pNameCtrl->Name.Length/sizeof(WCHAR)] = L'\\';
            pNameCtrl->Name.Length += sizeof(WCHAR);
        }

        //
        // now append the file's name part
        //
        
        status = RtlAppendUnicodeStringToString( &pNameCtrl->Name,
                                                 &pFileObject->FileName );
        ASSERT(STATUS_SUCCESS == status);
    }
    else
    {
        //
        // this is a full path open off of the volume
        //

        //
        //  Make sure the buffer is large enough.  Note that we account
        //  for a trailing null to be added.
        //
        
        fullNameLength = pExtension->pNtVolumeName->Length + pFileObject->FileName.Length;

        status = SrpNameCtrlBufferCheck( pNameCtrl, fullNameLength );

        if (!NT_SUCCESS( status ))
        {
            return status;
        }

        //
        //  set the volume name
        //

        RtlCopyUnicodeString( &pNameCtrl->Name, 
                              pExtension->pNtVolumeName );

        //
        // now append the file's name part (it already has the prefix '\\')
        //

        status = RtlAppendUnicodeStringToString( &pNameCtrl->Name,
                                                 &pFileObject->FileName );
        ASSERT(STATUS_SUCCESS == status);
    }

    //
    //  The main reson we come through this path is because we are in pre-
    //  create and we got the name from the file object.  We need to expand
    //  the path to remove any mount points from it.
    //

    status = SrpExpandPathOfFileName( pExtension, 
                                      pNameCtrl,
                                      pReasonableErrorForUnOpenedName );

Cleanup:
#if DBG
    if ((STATUS_MOUNT_POINT_NOT_RESOLVED == status) ||
        (STATUS_OBJECT_PATH_NOT_FOUND == status) ||
        (STATUS_OBJECT_NAME_NOT_FOUND == status) ||
        (STATUS_OBJECT_NAME_INVALID == status) ||
        (STATUS_REPARSE_POINT_NOT_RESOLVED == status) ||
        (STATUS_NOT_SAME_DEVICE == status))
    {
        return status;
    }
#endif

    RETURN(status);
}

/***************************************************************************++

Routine Description:

    Gets the file name if we have a file object that has not be fully 
    opened yet and it has been opened by ID.  In this case, the file must
    already exist.  We will try to open the file by id to get a fully 
    initialized file object, then use that file object to query the file name.

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrpGetFileNameOpenById (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN PFILE_OBJECT pFileObject,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE FileHandle = NULL;
    PFILE_OBJECT pReopenedFileObject = NULL;
    SRP_NAME_CONTROL FileNameCtrl;
    ULONG FileNameLength;
    
    PAGED_CODE();

    *pReasonableErrorForUnOpenedName = FALSE;

    SrpInitNameControl( &FileNameCtrl );

    //
    //  Make sure that we have a valid file name in the file object.
    //

    if (pFileObject->FileName.Length == 0)
    {
        Status = STATUS_OBJECT_NAME_INVALID;
        *pReasonableErrorForUnOpenedName = TRUE;
        goto SrpGetFileNameOpenById_Exit;
    }

    //
    //  Build up our name so that it is in the format of:
    //    \Device\HarddiskVolume1\[id in binary format]
    //  We have the device name in our device extension and we have
    //  the binary format of the file id in pFileObject->FileName.
    //

    FileNameLength = pExtension->pNtVolumeName->Length + 
                     sizeof( L'\\' ) +
                     pFileObject->FileName.Length;
    
    Status = SrpNameCtrlBufferCheck( &FileNameCtrl,
                                     FileNameLength );

    if (!NT_SUCCESS( Status ))
    {
        goto SrpGetFileNameOpenById_Exit;
    }

    RtlCopyUnicodeString( &(FileNameCtrl.Name), pExtension->pNtVolumeName );

    //
    //  Check to see if we need to add a '\' separator.
    //

    if (pFileObject->FileName.Buffer[0] != L'\\')
    {
        RtlAppendUnicodeToString( &(FileNameCtrl.Name), L"\\" );
    }

    RtlAppendUnicodeStringToString( &(FileNameCtrl.Name), &(pFileObject->FileName) );
    
    InitializeObjectAttributes( &ObjectAttributes,
                                &(FileNameCtrl.Name),
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );
    
    Status = SrIoCreateFile( &FileHandle,
                             GENERIC_READ,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             NULL,
                             0,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN,
                             FILE_OPEN_BY_FILE_ID,
                             NULL,
                             0,
                             IO_IGNORE_SHARE_ACCESS_CHECK,
                             pExtension->pTargetDevice );

    if (!NT_SUCCESS_NO_DBGBREAK( Status ))
    {
        *pReasonableErrorForUnOpenedName = TRUE;
        goto SrpGetFileNameOpenById_Exit;
    }

    Status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &pReopenedFileObject,
                                        NULL );

    if (!NT_SUCCESS( Status ))
    {
        goto SrpGetFileNameOpenById_Exit;
    }

    Status = SrpGetFileName( pExtension,
                             pReopenedFileObject,
                             pNameCtrl );

    CHECK_STATUS( Status );

SrpGetFileNameOpenById_Exit:

    SrpCleanupNameControl( &FileNameCtrl );
    
    if (pReopenedFileObject != NULL)
    {
        ObDereferenceObject( pReopenedFileObject );
    }
    
    if (FileHandle != NULL)
    {
        ZwClose( FileHandle );
    }

    RETURN ( Status );
}


/***************************************************************************++

Routine Description:

    This will scan for short file names in the filename buffer and expand
    them inplace.  if we need to we will reallocate the name buffer to
    grow it.

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrpExpandShortNames (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    IN BOOLEAN expandFileNameComponent
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG idx;
    ULONG start;
    ULONG end;
    ULONG nameLen;
    LONG shortNameLen;
    LONG copyLen;
    LONG delta;
    HANDLE directoryHandle = NULL;
    PFILE_NAMES_INFORMATION pFileEntry = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING shortFileName;
    UNICODE_STRING expandedFileName;
    USHORT newFileNameLength;
    USHORT savedFileNameLength;

    PAGED_CODE();

    ASSERT( IS_VALID_SR_STREAM_STRING( &pNameCtrl->Name, pNameCtrl->StreamNameLength) );
    VALIDATE_FILENAME( &pNameCtrl->Name );

    nameLen = pNameCtrl->Name.Length / sizeof(WCHAR);

    // 
    // scan the entire string
    //

    for (idx = 0; idx < nameLen; idx++)
    {
        //
        //
        // in this example the pointers are like this:
        //
        //  \Device\HarddiskDmVolumes\PhysicalDmVolumes\
        //          BlockVolume3\Progra~1\office.exe
        //                      ^        ^
        //                      |        |
        //                    start     end
        //
        // pStart always points to the last seen '\\' .
        //
    
        //
        //  is this a potential start of a path part?
        //
        
        if (pNameCtrl->Name.Buffer[idx] == L'\\')
        {
            //
            //  yes, save current position
            //
            
            start = idx;
        }

        //
        //  does this current path part contain a short version (~)
        //

        else if (pNameCtrl->Name.Buffer[idx] == L'~')
        {
            //
            //  we need to expand this part.
            //

            //
            //  find the end (a ending slash or end of string)
            //

            while ((idx < nameLen) && (pNameCtrl->Name.Buffer[idx] != L'\\'))
            {
                idx++;
            }

            //
            //  If we are looking at the filename component (we hit the end
            //  of the string) and we are not to expand this component, quit
            //  now
            //

            if ((idx >= nameLen) && !expandFileNameComponent)
            {
                break;
            }

            //
            //  at this point idx points either to the NULL or to the 
            //  subsequent '\\', so we will use this as our 
            //
            
            end = idx;

            ASSERT(pNameCtrl->Name.Buffer[start] == L'\\');
            ASSERT((end >= nameLen) || (pNameCtrl->Name.Buffer[end] == L'\\'));

            //
            //  Get the length of the file component that we think might be a
            //  short name.  Only try and get the expanded name if the
            //  component length is <= an 8.3 name length.
            //

            shortNameLen = end - start - 1;

            //
            //  shortNameLen counts the number of characters, not bytes, in the
            //  name, therefore we compare this against SR_SHORT_NAME_CHARS, not
            //  SR_SHORT_NAME_CHARS * sizeof(WCHAR)
            //

            if (shortNameLen > SR_SHORT_NAME_CHARS)
            {
                //
                //  This name is too long to be a short name.  Make end the 
                //  next start and keep looping to look at the next path
                //  component.
                //

                start = end;
            }
            else
            {
                //
                //  We have a potential shortname here.
                //
                //  Change the file name length to only include the parent 
                //  directory of the current name component (including
                //  the trailing slash).
                //

                savedFileNameLength = pNameCtrl->Name.Length;
                pNameCtrl->Name.Length = (USHORT)(start+1)*sizeof(WCHAR);

                //
                // now open the parent directory
                //

                ASSERT(directoryHandle == NULL);
            
                InitializeObjectAttributes( &objectAttributes,
                                            &pNameCtrl->Name,
                                            OBJ_KERNEL_HANDLE, 
                                            NULL,
                                            NULL );

                status = SrIoCreateFile( 
                                &directoryHandle,
                                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                &objectAttributes,
                                &ioStatusBlock,
                                NULL,                               // AllocationSize
                                FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,  // ShareAccess
                                FILE_OPEN,                          // OPEN_EXISTING
                                FILE_DIRECTORY_FILE
                                    | FILE_OPEN_FOR_BACKUP_INTENT
                                    | FILE_SYNCHRONOUS_IO_NONALERT, //create options
                                NULL,
                                0,                                  // EaLength
                                IO_IGNORE_SHARE_ACCESS_CHECK,
                                pExtension->pTargetDevice );

                //
                //  Now that we have the directory open, restore the original
                //  saved file name length.
                //

                pNameCtrl->Name.Length = savedFileNameLength;

                //
                //  Handle an open error
                //

#if DBG
                if (STATUS_MOUNT_POINT_NOT_RESOLVED == status)
                {

                    //
                    //  This is directory is through a mount point, so we don't
                    //  care about it here.  We will wait and take care of it
                    //  when the name has been resolved to the correct volume.
                    //

                    goto Cleanup;
                } 
                else 
#endif
                if (!NT_SUCCESS(status))
                {
                    goto Cleanup;
                }

                //
                //  Allocate a buffer to receive the filename if we don't
                //  already have one.
                //
            
                if (pFileEntry == NULL)
                {
                    pFileEntry = ExAllocatePoolWithTag( 
                                        PagedPool,
                                        SR_FILE_ENTRY_LENGTH,
                                        SR_FILE_ENTRY_TAG );

                    if (pFileEntry == NULL)
                    {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Cleanup;
                    }
                }

                //
                // now set just the file part for the query
                //

                shortFileName.Buffer = &pNameCtrl->Name.Buffer[start+1];
                shortFileName.Length = (USHORT)shortNameLen * sizeof(WCHAR);
                shortFileName.MaximumLength = shortFileName.Length;

                //
                // query the file entry to get the long name
                //

                pFileEntry->FileNameLength = 0;
            
                status = ZwQueryDirectoryFile( directoryHandle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ioStatusBlock,
                                               pFileEntry,
                                               SR_FILE_ENTRY_LENGTH,
                                               FileNamesInformation,
                                               TRUE,            // ReturnSingleEntry
                                               &shortFileName,
                                               TRUE );          // RestartScan

                //
                // it's possible that this file doesn't exist yet.  new 
                // creates with a literal '~' in the name. or creates
                // with non-existant directories in the path with ~'s in 
                // them
                //

                if (status == STATUS_NO_SUCH_FILE)
                {
                    status = STATUS_SUCCESS;
                
                    //
                    // exit the 'for' loop
                    //
                
                    break;
                }
                else if (status == STATUS_UNMAPPABLE_CHARACTER)
                {
                    //
                    // this appears to be ok.  fat returns this if there
                    // are funny characters in the name, but still gives us 
                    // the full name back.
                    //
                
                    status = STATUS_SUCCESS;
                }
                else if (!NT_SUCCESS(status))
                {
                    goto Cleanup;
                }

                ASSERT(pFileEntry->FileNameLength > 0);

                //
                // did it expand?
                //

                expandedFileName.Buffer = pFileEntry->FileName;
                expandedFileName.Length = (USHORT)pFileEntry->FileNameLength;
                expandedFileName.MaximumLength = (USHORT)pFileEntry->FileNameLength;

                if (RtlCompareUnicodeString(&expandedFileName,&shortFileName,TRUE) != 0)
                {
                    SrTrace(EXPAND_SHORT_NAMES, ("sr!SrpExpandShortNames:    expanded    \"%wZ\" to \"%wZ\"\n", &shortFileName, &expandedFileName));

                    //
                    //  Is there room in the current filename buffer for the
                    //  expanded file name
                    //

                    newFileNameLength = ((pNameCtrl->Name.Length - shortFileName.Length) +
                                         expandedFileName.Length);

                    status = SrpNameCtrlBufferCheck( pNameCtrl, 
                                                     (ULONG)(newFileNameLength +
                                                      pNameCtrl->StreamNameLength));

                    if (!NT_SUCCESS( status )) {

                        goto Cleanup;
                    }

                    //
                    // shuffle things around to make room for the expanded name
                    //

                    delta = ((LONG)expandedFileName.Length - (LONG)shortFileName.Length)/
                                (LONG)sizeof(WCHAR);

                    //
                    //  Open a hole for the name
                    //

                    if (delta != 0)
                    {
                        copyLen = (pNameCtrl->Name.Length + 
                                        pNameCtrl->StreamNameLength) - 
                                  (end * sizeof(WCHAR));
                        ASSERT(copyLen >= 0);
                        
                        if (copyLen > 0)
                        {
                            RtlMoveMemory( &pNameCtrl->Name.Buffer[end + delta],
                                           &pNameCtrl->Name.Buffer[end],
                                           copyLen );
                        }
                    }

                    //
                    // now copy over the expanded name
                    //

                    RtlCopyMemory(&pNameCtrl->Name.Buffer[start + 1],
                                  pFileEntry->FileName,
                                  pFileEntry->FileNameLength );

                    //
                    // and update our current index and lengths.
                    //

                    idx += delta;
                    pNameCtrl->Name.Length = (USHORT)newFileNameLength;
                    nameLen = newFileNameLength / sizeof(WCHAR);

                    //
                    // always NULL terminate
                    //

                    //pNameCtrl->Name.Buffer[pNameCtrl->Name.Length/sizeof(WCHAR)] = UNICODE_NULL;
                }

                //
                // close the directory handle.
                // 
            
                ZwClose( directoryHandle );
                directoryHandle = NULL;

                //
                //  We may have just expanded a name component.  Make sure
                //  that we still have valid name and stream name components.
                //
                
                ASSERT( IS_VALID_SR_STREAM_STRING( &pNameCtrl->Name, pNameCtrl->StreamNameLength) );

                //
                // skip start ahead to the next spot (the next slash or NULL)
                //
            
                start = idx;
                end = -1;
            }
        }
    }

    //
    //  Cleanup state and return
    //
Cleanup:

    if (NULL != pFileEntry)
    {
        ExFreePool(pFileEntry);
        NULLPTR(pFileEntry);
    }

    if (NULL != directoryHandle)
    {
        ZwClose(directoryHandle);
        NULLPTR(directoryHandle);
    }

#if DBG

    if (STATUS_MOUNT_POINT_NOT_RESOLVED == status) {

        return status;
    }
#endif

    VALIDATE_FILENAME( &pNameCtrl->Name );
    RETURN(status);
}



/***************************************************************************++

Routine Description:

    This routine will take the given full path filename, extract the PATH
    portion, get its value and substitue it back into the original name
    if it is different.  We do this to handle volume mount points as well
    as normallizing the name to a common format.  NOTE: this does NOT
    expand short names, but it will normalize the volume name to the
    \Device\HarddiskVolume1 format.

    We do this by:
        open the parent to get the real path to the parent.  we can't just
        open the target as it might not exist yet. we are sure the parent
        of the target always exists. if it doesn't, the rename will fail,
        and we are ok.

Arguments:

    pExtension - the SR device extension for the volume we are working on
    pNameCtrl - the name control structure that contains the name we are to
        expand.
    pReasonableErrorForUnOpenedName - this will be set to TRUE if we hit
        a reasonable error (e.g., something that leads us to believe the 
        original operation will also fail) during our work to expand the
        path.
        
Return Value:

    NTSTATUS - STATUS_SUCCESS if we were able to expand the path without
        error, or the appropriate error code otherwise.  If we did hit a
        reasonable error during this process, we will return that error
        here.

--***************************************************************************/
NTSTATUS
SrpExpandPathOfFileName (
    IN PSR_DEVICE_EXTENSION pExtension, 
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SRP_NAME_CONTROL localNameCtrl;
    ULONG TokenLength = 0;
    PWSTR pToken;
    PWCHAR pOrigBuffer;
    HANDLE FileHandle = NULL;
    PFILE_OBJECT pFileObject = NULL;
    
    PAGED_CODE();

    //
    //  Initialize state
    //

    SrpInitNameControl( &localNameCtrl );

    //
    //  Throughout this function, if this name contains a stream component,
    //  we want to manipulate the name as if the stream was part of the
    //  file name.  So add this amount to the pNameCtrl->Name.Length for
    //  now.  At the end of this routine, we will decrement
    //  pNameCtrl->Name.Length appropriately.
    //

    ASSERT( IS_VALID_SR_STREAM_STRING( &pNameCtrl->Name, pNameCtrl->StreamNameLength) );
    
    pNameCtrl->Name.Length += pNameCtrl->StreamNameLength;
    ASSERT( pNameCtrl->Name.Length <= pNameCtrl->Name.MaximumLength );
    
    //
    // find the filename part in the full path
    //
    
    status = SrFindCharReverse( pNameCtrl->Name.Buffer, 
                                pNameCtrl->Name.Length, 
                                L'\\',
                                &pToken,
                                &TokenLength );
                                
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    //
    //  The token pointer points to the last '\' on the original file and the
    //  length includes that '\'.  Adjust the token pointer and length to not
    //  include it.  Note that it is possible for a directory name to get
    //  down this path if the user tries to open a directory for overwrite or
    //  supercede.  This open will fail, but we will try to lookup the name
    //  anyway.
    //

    ASSERT(*pToken == L'\\');
    ASSERT(TokenLength >= sizeof(WCHAR));
    pToken++;
    TokenLength -= sizeof(WCHAR);

    //
    //  Take the filename part out of the original name.
    //  NOTE:  This does not take the '\' out of the name.  If we do and this
    //         is the root directory of the volume, the ZwCreateFile will
    //         result in a volume open instead of an open on the root directory
    //         of the volume.
    //  NOTE:  We specifically are sending this command to the TOP
    //         of the filter stack chain because we want to resolve
    //         the mount points.  We need the name with all mount points
    //         resolved so that we log the correct name in the change.log.
    //

    ASSERT(pNameCtrl->Name.Length > TokenLength);

    pNameCtrl->Name.Length -= (USHORT)TokenLength;

    InitializeObjectAttributes( &ObjectAttributes,
                                &pNameCtrl->Name,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = SrIoCreateFile( &FileHandle,
                             SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,                       // OPEN_EXISTING
                             FILE_SYNCHRONOUS_IO_NONALERT 
                              | FILE_OPEN_FOR_BACKUP_INTENT,
                             NULL,
                             0,                                // EaLength
                             IO_IGNORE_SHARE_ACCESS_CHECK,
                             NULL );    // go to TOP of filter stack

    //
    // not there?  that's ok, the rename will fail then.
    //
    
    if (!NT_SUCCESS_NO_DBGBREAK(status))
    {
        //
        //  It is resonable for pre-create to get an error here
        //

        *pReasonableErrorForUnOpenedName = TRUE;
        goto Cleanup;
    }

    //
    // reference the file object
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &pFileObject,
                                        NULL );

    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    //
    //  Now we need to make sure that we are still on the same volume.  The
    //  above open will have resolved any mount points and that could have
    //  taken us to another volume in the system.
    //

    if (IoGetRelatedDeviceObject( pFileObject ) !=
        IoGetAttachedDevice( pExtension->pDeviceObject )) {

        status = STATUS_NOT_SAME_DEVICE;
        *pReasonableErrorForUnOpenedName = TRUE;
        goto Cleanup;
    }

    //
    //  Get the name of the parent directory, this will handle
    //  resolving mount locations
    //

    status = SrpGetFileName( pExtension,
                             pFileObject,
                             &localNameCtrl );

    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    //
    //  Make sure there is a slash on the end of the new string (since our
    //  source string always has a slash) before we see if they are the same
    //

    ASSERT(localNameCtrl.Name.Length > 0);

    if (localNameCtrl.Name.Buffer[(localNameCtrl.Name.Length/sizeof(WCHAR))-1] != L'\\')
    {
        status = SrpNameCtrlBufferCheck( &localNameCtrl, 
                                         localNameCtrl.Name.Length+sizeof(WCHAR) );

        if (!NT_SUCCESS( status ))
        {
            goto Cleanup;
        }

        localNameCtrl.Name.Buffer[(localNameCtrl.Name.Length/sizeof(WCHAR))] = L'\\';
        localNameCtrl.Name.Length += sizeof(WCHAR);
    }

    //
    //  See if the directory name is different.  If not just return now
    //

    if (RtlCompareUnicodeString( &pNameCtrl->Name,
                                 &localNameCtrl.Name,
                                 TRUE ) == 0)
    {
        goto Cleanup;
    }

    //  
    //  Worst case the new name is longer so make sure our buffer is big
    //  enough.  If the new buffer is smaller then we know we won't need
    //  to allocate more name.
    //

    status = SrpNameCtrlBufferCheckKeepOldBuffer( pNameCtrl, 
                                                  localNameCtrl.Name.Length + TokenLength, 
                                                  &pOrigBuffer );

    if (!NT_SUCCESS( status ))
    {
        goto Cleanup;
    }

    //
    //  The name did change.  Shuffle the file name left or right based on
    //  the new estimated length of the path.  Note that we need to do the
    //  move first because pToken is a pointer into this string where the
    //  filename used to be.
    //

    RtlMoveMemory( &pNameCtrl->Name.Buffer[localNameCtrl.Name.Length/sizeof(WCHAR)],
                   pToken,
                   TokenLength );

    //
    //  We may have had to allocate a new buffer for this new name.  If there
    //  happened to be an old allocated buffer (the system is deisgned so this
    //  should never happen) then we had the SrNameCtrlBufferCheckKeepOldBuffer
    //  macro return us the old buffer because pToken still pointed into it.
    //  We now need to free that buffer.
    //

    if (pOrigBuffer)
    {
        ExFreePool(pOrigBuffer);
        NULLPTR(pToken);
    }

    //
    //  Copy the path portion of the name and set the length
    //

    RtlCopyMemory( pNameCtrl->Name.Buffer,
                   localNameCtrl.Name.Buffer,
                   localNameCtrl.Name.Length );

    pNameCtrl->Name.Length = localNameCtrl.Name.Length /*+
                             (USHORT)TokenLength*/;     // token length is now added in cleanup

    //
    //  Handle cleanup
    //

Cleanup:

    //
    //  Always restore the name length back to its original size -- adjust
    //  for TokenLength and StreamNameLength;
    //

    pNameCtrl->Name.Length += (USHORT)TokenLength;
    pNameCtrl->Name.Length -= pNameCtrl->StreamNameLength;

    if (pFileObject != NULL)
    {
        ObDereferenceObject(pFileObject);
        NULLPTR(pFileObject);
    }

    if (FileHandle != NULL)
    {
        ZwClose(FileHandle);
        NULLPTR(FileHandle);
    }

    SrpCleanupNameControl( &localNameCtrl );

#if DBG
    if ((STATUS_MOUNT_POINT_NOT_RESOLVED == status) ||
        (STATUS_OBJECT_PATH_NOT_FOUND == status) ||
        (STATUS_OBJECT_NAME_NOT_FOUND == status) ||
        (STATUS_OBJECT_NAME_INVALID == status) ||
        (STATUS_REPARSE_POINT_NOT_RESOLVED == status) ||
        (STATUS_NOT_SAME_DEVICE == status))
    {
        return status;
    }
#endif

    RETURN(status);
}

VOID
SrpRemoveExtraDataFromStream (
    PUNICODE_STRING pStreamComponent,
    PUSHORT AmountToRemove
    )
{
    UNICODE_STRING dataName;
    UNICODE_STRING endOfName;

    ASSERT( pStreamComponent != NULL );
    ASSERT( AmountToRemove != NULL );

    *AmountToRemove = 0;
    
    //
    //  Determine if we have an extra ":$DATA" to remove from the stream name.
    //

    RtlInitUnicodeString( &dataName, L":$DATA" );

    if (pStreamComponent->Length >= dataName.Length)
    {
        endOfName.Buffer = &(pStreamComponent->Buffer[
                                (pStreamComponent->Length - dataName.Length) / 
                                    sizeof(WCHAR) ]);
        endOfName.Length = dataName.Length;
        endOfName.MaximumLength = dataName.Length;

        //
        //  If the end of the stream name matches ":$DATA" strip it off
        //

        if (RtlEqualUnicodeString( &dataName, &endOfName, TRUE))
        {
            USHORT endOfStream;
                
            *AmountToRemove += dataName.Length;

            //
            //  We may still have one trailing ':' since 
            //  filename.txt::$DATA is a valid way to open the default
            //  stream of a file.
            //

            if ((pStreamComponent->Length + dataName.Length) > 0)
            {
                endOfStream = ((pStreamComponent->Length - dataName.Length)/sizeof(WCHAR))-1;
                
                if (pStreamComponent->Buffer[endOfStream] == L':')
                {
                    *AmountToRemove += sizeof(L':');
                }
            }
        }
    }
}

/***************************************************************************++

Routine Description:

    This will look to see if the given file name has a stream name on it.
    If so it will remove it from the string.

Arguments:

    pNameControl - a structure used to manage the name of the file

Return Value:

    None

--***************************************************************************/
VOID
SrpRemoveStreamName (
    IN OUT PSRP_NAME_CONTROL pNameCtrl
    )
{
    INT i;
    INT countOfColons = 0;

    PAGED_CODE();

    //
    // search for a potential stream name to strip.
    //

    ASSERT(pNameCtrl->Name.Length > 0);
    for ( i = (pNameCtrl->Name.Length / sizeof(WCHAR)) - 1;
          i >= 0;
          i -= 1 )
    {
        if (pNameCtrl->Name.Buffer[i] == L'\\')
        {
            //
            // hit the end of the file part. stop looking
            //
            
            break;
        }   
        else if (pNameCtrl->Name.Buffer[i] == L':')
        {
            USHORT delta;

            //
            //  Track the number of colons we see so that we know
            //  what we need to try to strip at the end.
            //
            
            countOfColons ++;

            //
            // strip the stream name (save how much we stripped)
            //
            
            delta = pNameCtrl->Name.Length - (USHORT)(i * sizeof(WCHAR));

            pNameCtrl->StreamNameLength += delta;
            pNameCtrl->Name.Length -= delta;
        }
    }

    if (countOfColons == 2)
    {
        UNICODE_STRING streamName;
        USHORT amountToRemove = 0;
        
        //
        //  We have an extra ":$DATA" to remove from the stream name.
        //

        streamName.Length = streamName.MaximumLength = pNameCtrl->StreamNameLength;
        streamName.Buffer = pNameCtrl->Name.Buffer + (pNameCtrl->Name.Length/sizeof(WCHAR));

        SrpRemoveExtraDataFromStream( &streamName, 
                                      &amountToRemove );

        pNameCtrl->StreamNameLength -= amountToRemove;
    }
}


/***************************************************************************++

Routine Description:

    This routine will construct a full nt path name for the target of a 
    rename or link operation.  The name will be completely normalized for SR's
    lookup and logging purposes.
    
Arguments:

    pExtension - SR's device extension for the volume on which this file resides.
    RootDirectory - Handle to the root directory for which this rename/link is 
        relative
    pFileName - If this is rename\link that is relative to the original file, 
        this is the target name.
    FileNameLength - The length in bytes of pFileName.
    pOriginalFileContext - The file context for the file that is being renamed
        or linked to.
    pOriginalFileObject - The file object that is being renamed or linked to.
    ppNewName - The normalized name that this function generates.  The caller
        is responsible for freeing the memory allocated.
    pReasonableErrorForUnOpenedName - Set to TRUE if we hit an error during 
        the name normalization path that is reasonable since this operation
        has not yet been validated by the file system.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpExpandDestPath (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN HANDLE RootDirectory,
    IN ULONG FileNameLength,
    IN PWSTR pFileName,
    IN PSR_STREAM_CONTEXT pOriginalFileContext,
    IN PFILE_OBJECT pOriginalFileObject,
    OUT PUNICODE_STRING *ppNewName,
    OUT PUSHORT pNewNameStreamLength,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    NTSTATUS status;
    UNICODE_STRING NewName;
    ULONG TokenLength;
    PWSTR pToken;
    PFILE_OBJECT pDirectory = NULL;
    SRP_NAME_CONTROL newNameCtrl;
    ULONG fullNameLength;
    UNICODE_STRING OrigName;
    SRP_NAME_CONTROL originalNameCtrl;
    BOOLEAN freeOriginalNameCtrl = FALSE;

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(pFileName != NULL);
    ASSERT(pOriginalFileContext != NULL);
    ASSERT(ppNewName != NULL);
    ASSERT(pNewNameStreamLength != NULL);

    //
    //  Initialize state
    //

    *ppNewName = NULL;
    *pNewNameStreamLength = 0;
    SrpInitNameControl( &newNameCtrl );

    //
    // fill in the new name to a UNICODE_STRING 
    //

    NewName.Length = (USHORT)FileNameLength;
    NewName.MaximumLength = (USHORT)FileNameLength;
    NewName.Buffer = pFileName;

    //
    // construct a fully qualified name we can use to open the parent
    // dir
    //

    //
    // is this a directory relative op?
    //
    
    if (RootDirectory != NULL)
    {
        //
        // reference the directory file object
        //

        status = ObReferenceObjectByHandle( RootDirectory,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pDirectory,
                                            NULL );

        if (!NT_SUCCESS(status))
        {
            goto Cleanup;
        }

        //
        // get path name for the directory
        //
        
        status = SrpGetFileName( pExtension,
                                 pDirectory, 
                                 &newNameCtrl );
        
        if (!NT_SUCCESS(status))
        {
            goto Cleanup;
        }

        fullNameLength = newNameCtrl.Name.Length + 
                         NewName.Length + 
                         sizeof(WCHAR);     //space for seperator

        status = SrpNameCtrlBufferCheck( &newNameCtrl, fullNameLength );

        if (!NT_SUCCESS( status )) {

            goto Cleanup;
        }

        //
        //  Slap on the relative part now
        //
        //  We may need to add a slash separator if it is missing.
        //

        if ((NewName.Buffer[0] != L'\\') &&
            (NewName.Buffer[0] != L':') &&
            (newNameCtrl.Name.Buffer[(newNameCtrl.Name.Length/sizeof(WCHAR))-1] != L'\\'))
        {
            newNameCtrl.Name.Buffer[newNameCtrl.Name.Length/sizeof(WCHAR)] = L'\\';
            newNameCtrl.Name.Length += sizeof(WCHAR);
        }

        RtlAppendUnicodeStringToString( &newNameCtrl.Name,
                                        &NewName );

        //
        // done with the object now
        //
        
        ObDereferenceObject(pDirectory);
        pDirectory = NULL;
    }
    
    //
    // is this a same directory rename\link creation ?
    //
    
    else if (NewName.Buffer[0] != L'\\')
    {
        PUNICODE_STRING pOriginalName;

        ASSERT(RootDirectory == NULL);

        if (!FlagOn( pOriginalFileContext->Flags, CTXFL_IsInteresting ))
        {
            //
            //  We don't have a name for this file, so generate the fully
            //  qualified name.
            //

            SrpInitNameControl( &originalNameCtrl );
            freeOriginalNameCtrl = TRUE;
            
            status = SrpGetFileName( pExtension, 
                                     pOriginalFileObject,
                                     &originalNameCtrl );

            if (!NT_SUCCESS( status )) {

                goto Cleanup;
            }

            pOriginalName = &(originalNameCtrl.Name);
        }
        else
        {
            //
            //  This file is interesting, so we have a name in the context.
            //
            
            pOriginalName = &(pOriginalFileContext->FileName);
        }

        //
        //  We are doing either a same directory rename/link or renaming a 
        //  stream of this file.  We can figure out which by looking for a ':'
        //  as the first character in the NewName.  In either case,
        //  NewName should have no '\'s in it.

        
        status = SrFindCharReverse( NewName.Buffer, 
                                    NewName.Length, 
                                    L'\\',
                                    &pToken,
                                    &TokenLength );

        if (status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            *pReasonableErrorForUnOpenedName = TRUE;
            status = STATUS_OBJECT_NAME_INVALID;
            goto Cleanup;
        }

        if (NewName.Buffer[0] == ':')
        {
            USHORT CurrentFileNameLength;
            USHORT AmountToRemove = 0;
            
            //
            //  We are renaming a stream on this file.  This is the easy
            //  case because we can build up the new name without any more
            //  parsing of the original name.
            //

            //
            //  NewName currently contains the new stream name component.  It
            //  may have the extra $DATA at the end of the stream name
            //  and we want to strip that part off.
            //

            SrpRemoveExtraDataFromStream( &NewName, 
                                          &AmountToRemove );

            NewName.Length -= AmountToRemove;
            
            //
            //  Calculate the full length of the name with stream and upgrade 
            //  our buffer if we need to.
            //

            fullNameLength = pOriginalName->Length + NewName.Length;

            status = SrpNameCtrlBufferCheck( &newNameCtrl, fullNameLength );

            if (!NT_SUCCESS( status )) 
            {
                goto Cleanup;
            }

            //
            // insert the orignal file name into the string
            //

            RtlCopyUnicodeString( &newNameCtrl.Name,
                                  pOriginalName );

            //
            //  Append the stream name component on, but remember the current
            //  length of the file name, since will will restore that after
            //  the append operation to maintain our file name format.
            //

            CurrentFileNameLength = newNameCtrl.Name.Length;
            
            RtlAppendUnicodeStringToString( &newNameCtrl.Name,
                                            &NewName );
            
            newNameCtrl.Name.Length = CurrentFileNameLength;
            newNameCtrl.StreamNameLength = NewName.Length;
        }
        else 
        {
            //
            //  get the length of the filename portion of the source
            //  path
            //
            
            status = SrFindCharReverse( pOriginalName->Buffer, 
                                        pOriginalName->Length, 
                                        L'\\',
                                        &pToken,
                                        &TokenLength );
                                        
            if (!NT_SUCCESS(status))
            {
                goto Cleanup;
            }

            //
            // Leave the prefix character ('\') on the path
            //

            TokenLength -= sizeof(WCHAR);

            ASSERT(pOriginalName->Length > TokenLength);
            OrigName.Length = (USHORT) (pOriginalName->Length - TokenLength);
            OrigName.MaximumLength = OrigName.Length;
            OrigName.Buffer = pOriginalName->Buffer;

            //
            //  Calculate the full length of the name and upgrade our
            //  buffer if we need to.
            //

            fullNameLength = OrigName.Length + NewName.Length;

            status = SrpNameCtrlBufferCheck( &newNameCtrl, fullNameLength );

            if (!NT_SUCCESS( status )) 
            {
                goto Cleanup;
            }

            //
            // insert the orignal file name into the string
            //

            RtlCopyUnicodeString( &newNameCtrl.Name,
                                  &OrigName );

            //
            //  Append the new name on
            //

            RtlAppendUnicodeStringToString( &newNameCtrl.Name,
                                            &NewName );
        }
    }
    else
    {
        ASSERT(NewName.Buffer[0] == L'\\');
        
        //
        // it's already fully quailifed, simply allocate a buffer and 
        // copy it in so we can post process expand mount points and 
        // shortnames
        //

        status = SrpNameCtrlBufferCheck( &newNameCtrl, NewName.Length );

        if (!NT_SUCCESS( status ))
        {
            goto Cleanup;
        }

        //
        //  Copy the name into the buffer
        //

        RtlCopyUnicodeString( &newNameCtrl.Name,
                              &NewName );
    }

    //
    // NULL terminate the name
    //

    ASSERT(newNameCtrl.Name.Length > 0);

    //
    //  Since this may be a raw path name from the user, try and expand
    //  the path so that we will eliminate the mount points.  After this
    //  call, the name will be normalized to 
    //  \Device\HarddiskVolume1\[fullpath]
    //

    status = SrpExpandPathOfFileName( pExtension,
                                      &newNameCtrl,
                                      pReasonableErrorForUnOpenedName );

    if (!NT_SUCCESS_NO_DBGBREAK(status))
    {
        goto Cleanup;
    }

    //
    //  Now expand any shortnames in the path
    //
        
    status = SrpExpandShortNames( pExtension,
                                  &newNameCtrl,
                                  FALSE );

    if (!NT_SUCCESS_NO_DBGBREAK(status))
    {
        goto Cleanup;
    }

    //
    //  Allocate a string buffer to return and copy the name to it
    //

    *ppNewName = ExAllocatePoolWithTag( PagedPool,
                                        sizeof( UNICODE_STRING ) + 
                                            newNameCtrl.Name.Length + 
                                            newNameCtrl.StreamNameLength,
                                        SR_FILENAME_BUFFER_TAG );
                                    
    if (NULL == *ppNewName)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    (*ppNewName)->MaximumLength = newNameCtrl.Name.Length + newNameCtrl.StreamNameLength;
    (*ppNewName)->Buffer = (PWCHAR)((PWCHAR)((*ppNewName) + 1));

    //
    //  Since we need to copy the steam information also, do the copy
    //  ourselves here instead of relying on the Unicode function.
    //

    RtlCopyMemory( (*ppNewName)->Buffer, 
                    newNameCtrl.Name.Buffer,
                    (*ppNewName)->MaximumLength );
    
    (*ppNewName)->Length = newNameCtrl.Name.Length;
    *pNewNameStreamLength = newNameCtrl.StreamNameLength;
    
    //
    //  Handle cleanup of state
    //

Cleanup:
    if (pDirectory != NULL)
    {
        ObDereferenceObject(pDirectory);
        NULLPTR(pDirectory);
    }

    SrpCleanupNameControl( &newNameCtrl );

    if (freeOriginalNameCtrl)
    {
        SrpCleanupNameControl( &originalNameCtrl );
    }

#if DBG
    if ((STATUS_MOUNT_POINT_NOT_RESOLVED == status) ||
        (STATUS_OBJECT_PATH_NOT_FOUND == status) ||
        (STATUS_OBJECT_NAME_NOT_FOUND == status) ||
        (STATUS_OBJECT_NAME_INVALID == status) ||
        (STATUS_REPARSE_POINT_NOT_RESOLVED == status) ||
        (STATUS_NOT_SAME_DEVICE == status))
    {
        return status;
    }
#endif

    RETURN(status);
}



/***************************************************************************++

Routine Description:

    This will initialize the name control structure

Arguments:

Return Value:

    None

--***************************************************************************/
VOID
SrpInitNameControl (
    IN PSRP_NAME_CONTROL pNameCtrl
    )
{
    PAGED_CODE();

    pNameCtrl->AllocatedBuffer = NULL;
    pNameCtrl->StreamNameLength = 0;
    pNameCtrl->BufferSize = sizeof(pNameCtrl->SmallBuffer);
    RtlInitEmptyUnicodeString( &pNameCtrl->Name,
                               (PWCHAR)pNameCtrl->SmallBuffer,
                               pNameCtrl->BufferSize );
    //pNameCtrl->Name.Buffer[0] = UNICODE_NULL;
}


/***************************************************************************++

Routine Description:

    This will cleanup the name control structure

Arguments:

Return Value:

    None

--***************************************************************************/
VOID
SrpCleanupNameControl (
    IN PSRP_NAME_CONTROL pNameCtrl
    )
{
    PAGED_CODE();

    if (NULL != pNameCtrl->AllocatedBuffer)
    {
        ExFreePool( pNameCtrl->AllocatedBuffer );
        pNameCtrl->AllocatedBuffer = NULL;
    }
}

/***************************************************************************++

Routine Description:

    This routine will allocate a new larger name buffer and put it into the
    NameControl structure.  If there is already an allocated buffer it will
    be freed.  It will also copy any name information from the old buffer
    into the new buffer.

Arguments:

    pNameCtrl           - the name control we need a bigger buffer for
    newSize             - size of the new buffer
    retOrignalBuffer    - if defined, receives the buffer that we were
                          going to free.  if NULL was returned no buffer
                          needed to be freed.
                          WARNING:  if this parameter is defined and a 
                                    non-null value is returned then the
                                    call MUST free this memory else the
                                    memory will be lost.

Return Value:

    None

--***************************************************************************/
NTSTATUS
SrpReallocNameControl (
    IN PSRP_NAME_CONTROL pNameCtrl,
    ULONG newSize,
    PWCHAR *retOriginalBuffer OPTIONAL
    )
{
    PCHAR newBuffer;    

    PAGED_CODE();

    ASSERT(newSize > pNameCtrl->BufferSize);

    //
    //  Flag no buffer to return yet
    //

    if (retOriginalBuffer)
    {
        *retOriginalBuffer = NULL;
    }

    //
    //  Allocate the new buffer
    //

    newBuffer = ExAllocatePoolWithTag( PagedPool,
                                       newSize,
                                       SR_FILENAME_BUFFER_TAG );

    if (NULL == newBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SrTrace( CONTEXT_LOG, ("Sr!SrpReallocNameControl: Realloc:    (%p) oldSz=%05x newSz=%05x  \"%.*S\"\n",
                           pNameCtrl,
                           pNameCtrl->BufferSize,
                           newSize,
                           (pNameCtrl->Name.Length+
                               pNameCtrl->StreamNameLength)/sizeof(WCHAR),
                           pNameCtrl->Name.Buffer));
    //
    //  Copy data from old buffer if there is any, including any stream
    //  name component.
    //

    if ((pNameCtrl->Name.Length + pNameCtrl->StreamNameLength) > 0)
    {
        ASSERT(newSize > (USHORT)(pNameCtrl->Name.Length + pNameCtrl->StreamNameLength));
        RtlCopyMemory( newBuffer,
                       pNameCtrl->Name.Buffer,
                       (pNameCtrl->Name.Length + pNameCtrl->StreamNameLength) );
    }

    //
    //  If we had an old buffer free it if the caller doesn't want
    //  it passed back to him.  This is done because there are
    //  cases where the caller has a pointer into the old buffer so
    //  it can't be freed yet.  The caller must free this memory.
    //
    
    if (NULL != pNameCtrl->AllocatedBuffer)
    {
        if (retOriginalBuffer)
        {
            *retOriginalBuffer = (PWCHAR)pNameCtrl->AllocatedBuffer;
        }
        else
        {
            ExFreePool(pNameCtrl->AllocatedBuffer);
        }
    }

    //
    //  Set the new buffer into the name control
    //

    pNameCtrl->AllocatedBuffer = newBuffer;
    pNameCtrl->BufferSize = newSize;

    pNameCtrl->Name.Buffer = (PWCHAR)newBuffer;
    pNameCtrl->Name.MaximumLength = (USHORT)newSize;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:
    This routine does the following things:
    - Get the FULL path name of the given file object
    - Will expand any short names in the path to long names
    - Will remove any stream names.

Arguments:
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpExpandFileName (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN ULONG EventFlags,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    //  If we are in pre-create, use the name in the FILE_OBJECT.  Also if 
    //  there is no related file object and the name starts with a slash, 
    //  just use the name in the FILE_OBJECT.
    //

    if (FlagOn( EventFlags, SrEventOpenById ))
    {
        status = SrpGetFileNameOpenById( pExtension, 
                                         pFileObject,
                                         pNameCtrl, 
                                         pReasonableErrorForUnOpenedName);

    }
    else if (FlagOn( EventFlags, SrEventInPreCreate ))
    {
        status = SrpGetFileNameFromFileObject( pExtension,
                                               pFileObject, 
                                               pNameCtrl,
                                               pReasonableErrorForUnOpenedName );
    }
    else
    {

        //
        // Ask the file system for the name
        //

        status = SrpGetFileName( pExtension,
                                 pFileObject,
                                 pNameCtrl );
    }
    
    if (!NT_SUCCESS_NO_DBGBREAK( status ))
    {
        return status;
    }
    //
    //  Remove the stream name from the file name (if defined)
    //

    SrpRemoveStreamName( pNameCtrl );

    //
    // Expand any short names in the filename
    //

    status = SrpExpandShortNames( pExtension,
                                  pNameCtrl,
                                  TRUE );

    RETURN(status);
}


/***************************************************************************++

Routine Description:

    This will see if we care about this file.  During this process it looks
    up the full file name and returns it.
    
Arguments:

    pExtension  - the extension for the device this file is on
    pFileObject - the fileobject being handled
    IsDirectory - TRUE if this is a directory, else FALSE
    EventFlags - The flags portion of the current event.  This is used to
        determine if we are in the pre-create path or if this file is being
        opened by file id.
    pNameControl - a structure used to manage the name of the file
    pIsInteresting - returns if this file should be monitored
    pReasonableErrorForUnOpenedName - 
    
Return Value:

    NTSTATUS - Completion status

--***************************************************************************/
NTSTATUS
SrIsFileEligible (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN IsDirectory,
    IN SR_EVENT_TYPE EventFlags,
    IN OUT PSRP_NAME_CONTROL pNameCtrl,
    OUT PBOOLEAN pIsInteresting,
    OUT PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    NTSTATUS status;
    
    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));

    //
    //  Assume the file is NOT interesting
    //

    *pIsInteresting = FALSE;

    //
    // is anyone monitoring this system at all?
    //

    if (!SR_LOGGING_ENABLED(pExtension))
    {
        return SR_STATUS_VOLUME_DISABLED;
    }

    //
    // have we loaded the file config information
    //

    if (!_globals.BlobInfoLoaded)
    {
        status = SrReadBlobInfo();
        if (!NT_SUCCESS_NO_DBGBREAK( status ))
        {
            ASSERT(!_globals.BlobInfoLoaded);

            //
            //  We couldn't load the lookup blob for some reason, but
            //  we have already handled the error so mark that this is a 
            //  resonable error, so just let the error propogate out.
            //

            *pReasonableErrorForUnOpenedName = TRUE;
            
            return status;
        }

        ASSERT(_globals.BlobInfoLoaded);
    }

    //
    //  Always query the name
    //

    status = SrpExpandFileName( pExtension,
                                pFileObject,
                                EventFlags,
                                pNameCtrl,
                                pReasonableErrorForUnOpenedName );

    if (!NT_SUCCESS_NO_DBGBREAK( status ))
    {
        return status;
    }

    //
    //  Check to see if this file name is longer than SR_MAX_PATH.  If so,
    //  this file is not interesting.
    //

    if (!IS_FILENAME_VALID_LENGTH( pExtension, 
                                   &(pNameCtrl->Name), 
                                   pNameCtrl->StreamNameLength ))
    {
        *pIsInteresting = FALSE;
        return STATUS_SUCCESS;
    }
    
    //
    // is this is a file, check the extension for a match
    //
    
    if (!IsDirectory)
    {
        //
        // does this extension match?  do this first as we can do this
        // pretty quick like
        //

        status = SrIsExtInteresting( &pNameCtrl->Name,
                                     pIsInteresting );

        if (!NT_SUCCESS( status ))
        {
            return status;
        }

        //
        //  Is this not interesting
        //
        
        if (!*pIsInteresting)
        {
            return status;
        }

        //
        //  Check to see if this file has a stream component.  If so,
        //  we need to check to see if this is a named stream on a
        //  file or directory.  We are only interested in streams on
        //  files.
        //

        if (pNameCtrl->StreamNameLength > 0)
        {
            status = SrIsFileStream( pExtension, 
                                     pNameCtrl, 
                                     pIsInteresting,
                                     pReasonableErrorForUnOpenedName );

            if (!NT_SUCCESS_NO_DBGBREAK( status ) || !*pIsInteresting)
            {
                return status;
            }
        }
    }
    
    //
    // see if this is a file that we should monitor?
    //

    status = SrIsPathInteresting( &pNameCtrl->Name, 
                                  pExtension->pNtVolumeName,
                                  IsDirectory,
                                  pIsInteresting );
                    
    RETURN(status);
}

/***************************************************************************++

Routine Description:

    This routine does a quick scan of the file object's name to see if it
    contains the stream name delimiter ':'.

    Note:  This routine assumes that the name in the file object is valid, 
        therefore this routine should only be called from SrCreate.

    Note2:  We only need to rely on the name components in the 
        pFileObject->FileName field because for our purposes this is sufficient.
        If this filed doesn't contain the ':' delimiter, we are either not
        opening a stream or we are doing a self-relative open of a stream
    
Arguments:

    pExtension  - the SR extension the current volume
    pFileObject - the current fileobject to be opened
    pFileContext - if provided, we will get the name from the context
    
Return Value:

    Returns TRUE if the file name contains a steam delimiter or FALSE otherwise.

--***************************************************************************/
BOOLEAN
SrFileNameContainsStream (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext OPTIONAL
    )
{
    PUNICODE_STRING pFileName;
    NTSTATUS status;
    PWCHAR pToken;
    ULONG tokenLength;
    
    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );
    ASSERT( IS_VALID_FILE_OBJECT( pFileObject ) );
    
    //
    //  If we've already cached the attributes of this volume, do a quick
    //  check to see if this FS supports named streams.  If not, we don't need
    //  to do any more work here.
    //
    
    if (pExtension->CachedFsAttributes &&
        !FlagOn( pExtension->FsAttributes, FILE_NAMED_STREAMS ))
    {
        return FALSE;
    }

    if (pFileContext != NULL)
    {
        //
        //  If we've got a pFileContext, it has all the stream information
        //  in it already, so just use that.
        //
        
        if (pFileContext->StreamNameLength == 0)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }

    pFileName = &(pFileObject->FileName);

    status = SrFindCharReverse( pFileName->Buffer, 
                                pFileName->Length,
                                L':',
                                &pToken,
                                &tokenLength );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        //  We didn't find a ':', therefore this doen't have a stream component
        //  in the name.
        //

        return FALSE;
    }
    else if (status == STATUS_SUCCESS)
    {
        //
        //  We found a ':', so there is a stream component in this name.
        //

        return TRUE;
    }
    else
    {
        //
        //  We should never reach this path.
        //
        
        ASSERT( FALSE );
    }
    
    return FALSE;
}

/***************************************************************************++

Routine Description:

    This routine opens the file-only component of the file name (ignoring
    any stream component) to see if the unnamed data stream for this file
    already exists.

    Note:  This routine assumes that the name in the file object is valid, 
        therefore this routine should only be called from SrCreate.

Arguments:

    pExtension  - the SR extension the current volume
    pFileObject - the current fileobject to be opened
    pFileContext - if provided, we will get the name from the context
    
Return Value:

    Returns TRUE if the file name contains a steam delimiter or FALSE otherwise.

--***************************************************************************/
BOOLEAN
SrFileAlreadyExists (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext OPTIONAL
    )
{
    SRP_NAME_CONTROL nameCtrl;
    BOOLEAN cleanupNameCtrl = FALSE;
    BOOLEAN reasonableError;
    NTSTATUS status;
    BOOLEAN unnamedStreamExists = FALSE;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle = NULL;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING pFileName;

    if (pFileContext == NULL)
    {
        SrpInitNameControl( &nameCtrl );
        cleanupNameCtrl = TRUE;

        status = SrpGetFileNameFromFileObject( pExtension,
                                               pFileObject, 
                                               &nameCtrl,
                                               &reasonableError );
                                         
        if (!NT_SUCCESS_NO_DBGBREAK( status ))
        {
            goto SrFileAlreadyHasUnnamedStream_Exit;
        }

        //
        //  Remove the stream name from the file name (if defined)
        //

        SrpRemoveStreamName( &nameCtrl );
        pFileName = &(nameCtrl.Name);

        //
        //  The stream component just resolved down to the default data stream,
        //  go exit now without doing the open.
        //

        if (nameCtrl.StreamNameLength == 0)
        {
            goto SrFileAlreadyHasUnnamedStream_Exit;
        }
    }
    else
    {
        pFileName = &(pFileContext->FileName);

        //
        //  This name should have a stream component, that's the reason we are
        //  in this path.
        //
        
        ASSERT( pFileContext->StreamNameLength > 0 );
    }

    
    InitializeObjectAttributes( &objectAttributes,
                                pFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = SrIoCreateFile( &fileHandle,
                             FILE_READ_ATTRIBUTES,
                             &objectAttributes,
                             &ioStatus,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0,
                             IO_IGNORE_SHARE_ACCESS_CHECK,
                             pExtension->pTargetDevice );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        //  The unnamed data stream doesn't exist, so the creation of this
        //  stream is also going to created the unnamed data stream on this
        //  file.
        //

        unnamedStreamExists = FALSE;
    }
    else if (status == STATUS_SUCCESS)
    {
        //
        //  The unnamed data stream does exist, so the creation of this
        //  stream is just going to create a new stream on this file.
        //

        unnamedStreamExists = TRUE;
    }
    else if (status == STATUS_DELETE_PENDING)
    {
        //
        //  This file already exists but is about to be deleted.
        //

        unnamedStreamExists = TRUE;
    }
    else
    {
        CHECK_STATUS( status );
    }

SrFileAlreadyHasUnnamedStream_Exit:
    
    if (fileHandle != NULL)
    {
        ZwClose( fileHandle );
    }

    if (cleanupNameCtrl)
    {
        SrpCleanupNameControl( &nameCtrl );
    }

    return unnamedStreamExists;
}

/***************************************************************************++

Routine Description:

    This routine determines if a name containing a stream component is a
    named stream on a directory or on a file.  To this this, this routine opens 
    the current file name ignoring any stream component in the name.

Arguments:

    pExtension  - the SR extension the current volume
    pNameCtrl - the SRP_NAME_CTRL structure that has the complete name.
    pIsFileStream - set to TRUE if this is a stream on a file, or FALSE if
        this is a stream on a directory.
    pReasonableErrorForUnOpenedName - set to TRUE if we hit an error trying
        to do this open.
        
Return Value:

    Returns STATUS_SUCCESS if we were able to determine if the parent to the
    stream is a file or directory, or the error we hit in the open path
    otherwise.

--***************************************************************************/
NTSTATUS
SrIsFileStream (
    PSR_DEVICE_EXTENSION pExtension,
    PSRP_NAME_CONTROL pNameCtrl,
    PBOOLEAN pIsFileStream,
    PBOOLEAN pReasonableErrorForUnOpenedName
    )
{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle = NULL;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    ASSERT( pIsFileStream != NULL );
    ASSERT( pReasonableErrorForUnOpenedName != NULL );

    *pReasonableErrorForUnOpenedName = FALSE;
    
    InitializeObjectAttributes( &objectAttributes,
                                &(pNameCtrl->Name),
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = SrIoCreateFile( &fileHandle,
                             FILE_READ_ATTRIBUTES,
                             &objectAttributes,
                             &ioStatus,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                             FILE_OPEN,
                             FILE_NON_DIRECTORY_FILE,
                             NULL,
                             0,
                             IO_IGNORE_SHARE_ACCESS_CHECK,
                             pExtension->pTargetDevice );

    if (status == STATUS_FILE_IS_A_DIRECTORY)
    {
        status = STATUS_SUCCESS;
        *pIsFileStream = FALSE;
    }
    else if (status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        //  We must be creating a new file with this stream operation,
        //  therefore the parent of this stream must be a file and not
        //  a directory.
        //
        
        status = STATUS_SUCCESS;
        *pIsFileStream = TRUE;
    }
    else if (!NT_SUCCESS_NO_DBGBREAK( status ))
    {
        *pReasonableErrorForUnOpenedName = TRUE;
    }
    else
    {
        *pIsFileStream = TRUE;
    }

    if (fileHandle)
    {
        ZwClose( fileHandle );
    }

    RETURN( status );
}

/***************************************************************************++

Routine Description:

    This routine checks to see if the long name for this file was tunneled.  If
    so, the user could have opened the file by its short name, but it will have
    a long name associated with it.  For correctness, we need to log operations
    on this file via the long name.
    
Arguments:

    pExtension  - The SR extension the current volume
    ppFileContext - This reference parameter passes in the current file context
        for this file and may get replaced with a new file context if we need
        to replace the name in this context.  If this is the case, this 
        routine will properly cleanup the context passed in and the caller is
        responsible for cleaning up the context passed out.
        
Return Value:

    Returns STATUS_SUCCESS if the check for tunneling was successful and the
    ppFileContext was updated as needed.  If there was some error, the 
    appropriate error status is returned.  Just like when we create our 
    original contexts, if an error occurs while doing this work, we must
    generate a volume error and go into pass through mode.  This routine will 
    generation the volume error and the caller should just get out of this 
    IO path.

--***************************************************************************/
NTSTATUS
SrCheckForNameTunneling (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN OUT PSR_STREAM_CONTEXT *ppFileContext
    )
{
    NTSTATUS status;
    PWCHAR pFileNameComponentBuffer = NULL;
    ULONG FileNameComponentLength = 0;
    PWCHAR pTildaPosition = NULL;
    ULONG TildaPositionLength;
    HANDLE parentDirectory = NULL;
    PSR_STREAM_CONTEXT pOrigCtx;

    ASSERT( ppFileContext != NULL );
    
    pOrigCtx = *ppFileContext;
    ASSERT( pOrigCtx != NULL);

    //
    //  First, see if this file is interesting and if this pFileObject
    //  represents a file.  Name tunneling is not done on directory names.
    //

    if (FlagOn( pOrigCtx->Flags, CTXFL_IsDirectory ) ||
        !FlagOn( pOrigCtx->Flags, CTXFL_IsInteresting ))
    {
        status = STATUS_SUCCESS;
        goto SrCheckForNameTunneling_Exit;
    }

    //
    //  Find the file name component of name we have in pOrigCtx.
    //

    status = SrFindCharReverse( pOrigCtx->FileName.Buffer,
                                pOrigCtx->FileName.Length,
                                L'\\',
                                &pFileNameComponentBuffer,
                                &FileNameComponentLength );

    if (!NT_SUCCESS( status ))
    {
        goto SrCheckForNameTunneling_Exit;
    }

    ASSERT( FileNameComponentLength > sizeof( L'\\' ) );
    ASSERT( pFileNameComponentBuffer[0] == L'\\' );

    //
    //  Move past the leading '\' of the file name since we want to keep that
    //  with the parent directory name.
    //

    pFileNameComponentBuffer ++;
    FileNameComponentLength -= sizeof( WCHAR );

    //
    //  We've got the file name component.  Now see if it is a candidate for
    //  tunneling of the long name.  It will be a candidate if:
    //      * The name is (SR_SHORT_NAME_CHARS) or less.
    //      * The name contains a '~'.
    //

    if (FileNameComponentLength > ((SR_SHORT_NAME_CHARS) * sizeof (WCHAR)))
    {
        //
        //  This name is too long to be a short name.  We're done.
        //

        goto SrCheckForNameTunneling_Exit;
    }

    status = SrFindCharReverse( pFileNameComponentBuffer,
                                FileNameComponentLength,
                                L'~',
                                &pTildaPosition,
                                &TildaPositionLength );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        //  This name doesn't have a '~' therefore, it cannot be a short
        //  name.
        //

        status = STATUS_SUCCESS;
        goto SrCheckForNameTunneling_Exit;
    }
    else
    {
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING fileNameComponent;
        UNICODE_STRING parentDirectoryName;
        UNICODE_STRING fsFileName;
        IO_STATUS_BLOCK ioStatus;
        PFILE_BOTH_DIR_INFORMATION pFileBothDirInfo;
#       define FILE_BOTH_DIR_SIZE (sizeof( FILE_BOTH_DIR_INFORMATION ) + (256 * sizeof( WCHAR )))
        PCHAR pFileBothDirBuffer [FILE_BOTH_DIR_SIZE];

        pFileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION) pFileBothDirBuffer;
        
        //
        //  This name contains a '~', therefore we need to open the parent directory
        //  and query for FileBothNamesInformation for this file to get the
        //  possibly tunneled long name.
        //

        parentDirectoryName.Length = 
            parentDirectoryName.MaximumLength =
                        (pOrigCtx->FileName.Length - (USHORT)FileNameComponentLength);
        parentDirectoryName.Buffer = pOrigCtx->FileName.Buffer;

        InitializeObjectAttributes( &objectAttributes,
                                    &parentDirectoryName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        status = SrIoCreateFile( 
                        &parentDirectory,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &objectAttributes,
                        &ioStatus,
                        NULL,                               // AllocationSize
                        FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,  // ShareAccess
                        FILE_OPEN,                          // OPEN_EXISTING
                        FILE_DIRECTORY_FILE
                            | FILE_OPEN_FOR_BACKUP_INTENT
                            | FILE_SYNCHRONOUS_IO_NONALERT, //create options
                        NULL,
                        0,                                  // EaLength
                        IO_IGNORE_SHARE_ACCESS_CHECK,
                        pExtension->pTargetDevice );

        if (!NT_SUCCESS( status ))
        {
            goto SrCheckForNameTunneling_Exit;
        }

        //
        //  Build a unicode string with for the file name component.
        //

        fileNameComponent.Buffer = pFileNameComponentBuffer;
        fileNameComponent.Length = 
            fileNameComponent.MaximumLength = (USHORT)FileNameComponentLength;
        
        status = ZwQueryDirectoryFile( parentDirectory,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatus,
                                       pFileBothDirInfo,
                                       FILE_BOTH_DIR_SIZE,
                                       FileBothDirectoryInformation,
                                       TRUE,
                                       &fileNameComponent,
                                       TRUE );

        if (!NT_SUCCESS( status ))
        {
            goto SrCheckForNameTunneling_Exit;
        }

        fsFileName.Buffer = &(pFileBothDirInfo->FileName[0]);
        fsFileName.Length = 
            fsFileName.MaximumLength =
                (USHORT)pFileBothDirInfo->FileNameLength;

        if (RtlCompareUnicodeString( &fsFileName, &fileNameComponent, TRUE ) != 0)
        {
            PSR_STREAM_CONTEXT ctx;
            ULONG contextSize;
            ULONG fileNameLength;
            
            //
            //  Name tunneling did occur.  Now we need to create a new context
            //  with the updated name for this file.
            //

            fileNameLength = parentDirectoryName.Length + sizeof( L'\\' ) +
                          fsFileName.Length + pOrigCtx->StreamNameLength;
            contextSize = fileNameLength + sizeof( SR_STREAM_CONTEXT );

            ctx = ExAllocatePoolWithTag( PagedPool, 
                                         contextSize,
                                         SR_STREAM_CONTEXT_TAG );

            if (!ctx)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto SrCheckForNameTunneling_Exit;
            }

#if DBG
            INC_STATS(TotalContextCreated);
            INC_STATS(TotalContextIsEligible);
#endif

            //
            //  Initialize the context structure from the components we've
            //  got.  We can copy over most everything but the full name from
            //  the pOrigCtx.  We also need to initialize the filename
            //  correctly when this copy is through.
            //

            RtlCopyMemory( ctx, 
                           pOrigCtx, 
                           (sizeof(SR_STREAM_CONTEXT) + parentDirectoryName.Length) );

            RtlInitEmptyUnicodeString( &ctx->FileName, 
                                       (PWCHAR)(ctx + 1), 
                                       fileNameLength );
            ctx->FileName.MaximumLength = (USHORT)fileNameLength;
            ctx->FileName.Length = parentDirectoryName.Length;

            //
            //  Append trailing slash if one is not already there
            //  NOTE:  About fix for bug 374479
            //         I believe the append below is unnecessary because the
            //         code above this guarentees that the path always has
            //         a trailing slash.  But because this fix is occuring so
            //         late in the release I decided to simply add a check to
            //         see if we should add the slash. If so we will add it.
            //         I believe the following 6 lines of code can be deleted
            //         in a future version of SR.
            //

            ASSERT(ctx->FileName.Length > 0);

            if (ctx->FileName.Buffer[(ctx->FileName.Length/sizeof(WCHAR))-1] != L'\\')
            {
                RtlAppendUnicodeToString( &ctx->FileName, L"\\" );
            }

            //
            //  Append file name
            //

            RtlAppendUnicodeStringToString( &ctx->FileName, &fsFileName );

            if (pOrigCtx->StreamNameLength > 0)
            {
                //
                //  This file has a stream name component so copy that over now.
                //  The ctx->StreamNameLength should already be correctly set.
                //

                ASSERT( ctx->StreamNameLength == pOrigCtx->StreamNameLength );
                RtlCopyMemory( &(ctx->FileName.Buffer[ctx->FileName.Length/sizeof( WCHAR )]),
                               &(pOrigCtx->FileName.Buffer[pOrigCtx->FileName.Length/sizeof( WCHAR )]),
                               pOrigCtx->StreamNameLength );
            }

            //
            //  Now we are done with the original file context and we want
            //  to return our new one.
            //

            status = STATUS_SUCCESS;
            SrReleaseContext( pOrigCtx );
            *ppFileContext = ctx;

            VALIDATE_FILENAME( &ctx->FileName );
        }
    }

SrCheckForNameTunneling_Exit:

    //
    //  If we have an error, we need to generate a volume error here.
    //

    if (CHECK_FOR_VOLUME_ERROR( status ))
    {
        //
        //  Trigger the failure notification to the service
        //

        NTSTATUS tempStatus = SrNotifyVolumeError( pExtension,
                                                   &(pOrigCtx->FileName),
                                                   status,
                                                   SrEventFileCreate );
        CHECK_STATUS(tempStatus);
    }

    if ( parentDirectory != NULL )
    {
        ZwClose( parentDirectory );
    }

    RETURN( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\lock.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    lock.h

Abstract:

    this file contains the prototypes that help with managing the 
    volume locks.

Author:

    Molly Brown (mollybro)     04-Jan-2001

Revision History:

--*/

#ifndef __LOCK_H__
#define __LOCK_H__

NTSTATUS
SrPauseVolumeActivity (
    );

VOID
SrResumeVolumeActivity (
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\init.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the SR device driver.

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000

Revision History:

--*/


#include "precomp.h"

#ifndef DPFLTR_SR_ID
#define DPFLTR_SR_ID 0x00000077
#endif


//
// Private constants.
//

//
// Private types.
//

//
// Private prototypes.
//

EXTERN_C
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SrUnload (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
SrFsNotification (
    IN PDEVICE_OBJECT pNewDeviceObject,
    IN BOOLEAN FsActive
    );

NTSTATUS
SrEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT pDeviceObject
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, SrUnload )
#if DBG
#pragma alloc_text( PAGE, SrDbgStatus )
#endif
#pragma alloc_text( PAGE, SrFsNotification )
#pragma alloc_text( PAGE, SrAttachToDevice )
#pragma alloc_text( PAGE, SrDetachDevice )
#pragma alloc_text( PAGE, SrGetFilterDevice )
#pragma alloc_text( PAGE, SrAttachToVolumeByName )
#pragma alloc_text( PAGE, SrCreateAttachmentDevice )
#pragma alloc_text( PAGE, SrDeleteAttachmentDevice )
#pragma alloc_text( PAGE, SrEnumerateFileSystemVolumes )

#endif  // ALLOC_PRAGMA


//
// Private globals.
//

//
// Public globals.
//

SR_GLOBALS _globals;
PSR_GLOBALS global = &_globals;

#if DBG
SR_STATS SrStats;
#endif

//
// Public functions.
//


/***************************************************************************++

Routine Description:

    This is the initialization routine for the UL device driver.

Arguments:

    DriverObject - Supplies a pointer to driver object created by the
        system.

    RegistryPath - Supplies the name of the driver's configuration
        registry tree.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS            Status;
    UNICODE_STRING      NameString;
    ULONG               i;
    BOOLEAN             bReleaseLock = FALSE;
    FS_FILTER_CALLBACKS fsFilterCallbacks;


    //
    // < dispatch!
    //

    PAGED_CODE();

    ASSERT(DriverObject != NULL);
    ASSERT(RegistryPath != NULL);

    try {

        //
        // allocate and clear out our global memory
        //
        
        RtlZeroMemory(global, sizeof(SR_GLOBALS));
#if DBG
        RtlZeroMemory(&SrStats, sizeof(SR_STATS));
#endif

        global->Signature = SR_GLOBALS_TAG;
        global->pDriverObject = DriverObject;

        InitializeListHead(&global->DeviceExtensionListHead);

        //
        // Read in our configuration from the registry
        //

        global->pRegistryLocation = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool, 
                                                                   UNICODE_STRING, 
                                                                   RegistryPath->Length + sizeof(WCHAR), 
                                                                   SR_REGISTRY_TAG );

        if (global->pRegistryLocation == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        global->pRegistryLocation->Length = RegistryPath->Length;
        global->pRegistryLocation->MaximumLength = RegistryPath->MaximumLength;
        global->pRegistryLocation->Buffer = (PWCHAR)(global->pRegistryLocation + 1);

        RtlCopyMemory(global->pRegistryLocation->Buffer,
                      RegistryPath->Buffer, 
                      RegistryPath->Length );

        global->pRegistryLocation->Buffer[global->pRegistryLocation->Length/sizeof(WCHAR)] = UNICODE_NULL;
        
        Status = SrReadRegistry(global->pRegistryLocation, TRUE);
        if (!NT_SUCCESS(Status))
            leave;

        //
        // give someone a chance to debug startup
        //
        
        if (FlagOn(global->DebugControl, SR_DEBUG_BREAK_ON_LOAD))
        {
            DbgBreakPoint();
        }

        //
        // Init the ERESOURCE (s)
        //

        Status = ExInitializeResourceLite(&global->GlobalLock);
        if (!NT_SUCCESS(Status))
            leave;

        Status = ExInitializeResourceLite(&global->DeviceExtensionListLock);
        if (!NT_SUCCESS(Status))
            leave;

        Status = ExInitializeResourceLite(&global->BlobLock);
        if (!NT_SUCCESS(Status))
            leave;

        //
        // Create our main named device so user-mode can connect
        //

        RtlInitUnicodeString( &NameString, SR_CONTROL_DEVICE_NAME );

        Status = IoCreateDevice( DriverObject,              // DriverObject
                                 0,                         // DeviceExtension
                                 &NameString,               // DeviceName
                                 FILE_DEVICE_UNKNOWN,       // DeviceType
                                 FILE_DEVICE_SECURE_OPEN,   // DeviceCharacteristics
                                 FALSE,                     // Exclusive
                                 &global->pControlDevice ); // DeviceObject

        if (!NT_SUCCESS(Status))
            leave;

        //
        // loop through all of the possible major functions
        //
        
        for (i = 0 ; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
        {
            DriverObject->MajorFunction[i] = SrPassThrough;
        }

        //
        // and now hook the ones we care about
        //
        
        DriverObject->MajorFunction[IRP_MJ_WRITE] = SrWrite;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SrCleanup;
        DriverObject->MajorFunction[IRP_MJ_CREATE] = SrCreate;
        DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = SrSetInformation;
        DriverObject->MajorFunction[IRP_MJ_SET_SECURITY] = SrSetSecurity;
        DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SrFsControl;
        DriverObject->MajorFunction[IRP_MJ_PNP] = SrPnp;
        DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = SrShutdown;

        //
        // and the fast io path
        //
        
        RtlZeroMemory(&global->FastIoDispatch, sizeof(FAST_IO_DISPATCH));

        DriverObject->FastIoDispatch = &global->FastIoDispatch;

        //
        // fill in the fast i/o dispatch pointers
        //

        DriverObject->FastIoDispatch->SizeOfFastIoDispatch = 
                                                        sizeof(FAST_IO_DISPATCH);
                                                        
        DriverObject->FastIoDispatch->FastIoCheckIfPossible = SrFastIoCheckIfPossible;
        DriverObject->FastIoDispatch->FastIoRead = SrFastIoRead;
        DriverObject->FastIoDispatch->FastIoWrite = SrFastIoWrite;
        DriverObject->FastIoDispatch->FastIoQueryBasicInfo = SrFastIoQueryBasicInfo;
        DriverObject->FastIoDispatch->FastIoQueryStandardInfo = SrFastIoQueryStandardInfo;
        DriverObject->FastIoDispatch->FastIoLock = SrFastIoLock;
        DriverObject->FastIoDispatch->FastIoUnlockSingle = SrFastIoUnlockSingle;
        DriverObject->FastIoDispatch->FastIoUnlockAll = SrFastIoUnlockAll;
        DriverObject->FastIoDispatch->FastIoUnlockAllByKey = SrFastIoUnlockAllByKey;
        DriverObject->FastIoDispatch->FastIoDeviceControl = SrFastIoDeviceControl;
        DriverObject->FastIoDispatch->FastIoDetachDevice = SrFastIoDetachDevice;
        DriverObject->FastIoDispatch->FastIoQueryNetworkOpenInfo = SrFastIoQueryNetworkOpenInfo;
        DriverObject->FastIoDispatch->MdlRead = SrFastIoMdlRead;
        DriverObject->FastIoDispatch->MdlReadComplete = SrFastIoMdlReadComplete;
        DriverObject->FastIoDispatch->PrepareMdlWrite = SrFastIoPrepareMdlWrite;
        DriverObject->FastIoDispatch->MdlWriteComplete = SrFastIoMdlWriteComplete;
        DriverObject->FastIoDispatch->FastIoReadCompressed = SrFastIoReadCompressed;
        DriverObject->FastIoDispatch->FastIoWriteCompressed = SrFastIoWriteCompressed;
        DriverObject->FastIoDispatch->MdlReadCompleteCompressed = SrFastIoMdlReadCompleteCompressed;
        DriverObject->FastIoDispatch->MdlWriteCompleteCompressed = SrFastIoMdlWriteCompleteCompressed;
        DriverObject->FastIoDispatch->FastIoQueryOpen = SrFastIoQueryOpen;
        

        //
        // these are hooked differently.  the fsrtl system does not go via 
        // attached devices when calling these.  so we need to directly hook
        // the driver via FsRtlRegisterFileSystemFilterCallbacks
        //
        
        DriverObject->FastIoDispatch->AcquireFileForNtCreateSection = NULL;
        DriverObject->FastIoDispatch->ReleaseFileForNtCreateSection = NULL;
        DriverObject->FastIoDispatch->AcquireForModWrite = NULL;
        DriverObject->FastIoDispatch->ReleaseForModWrite = NULL;
        DriverObject->FastIoDispatch->AcquireForCcFlush = NULL;
        DriverObject->FastIoDispatch->ReleaseForCcFlush = NULL;
        

        //
        // Set our unload function
        //

        if (FlagOn(global->DebugControl, SR_DEBUG_ENABLE_UNLOAD))
        {
            SrTrace(INIT, ("sr!DriverEntry enabling UNLOAD\n"));
            DriverObject->DriverUnload = &SrUnload;
        }

#ifdef USE_LOOKASIDE

        //
        // initialized our lookaside lists
        //

        ExInitializePagedLookasideList( &global->FileNameBufferLookaside,// Lookaside
                                        NULL,                           // Allocate
                                        NULL,                           // Free
                                        0,                              // Flags
                                        SR_FILENAME_BUFFER_LENGTH,      // Size
                                        SR_FILENAME_BUFFER_TAG,         // Tag
                                        SR_FILENAME_BUFFER_DEPTH );     // Depth



#endif

        //
        //  Setup the callbacks for the operations we receive through
        //  the FsFilter interface.
        //

        RtlZeroMemory(&fsFilterCallbacks, sizeof(FS_FILTER_CALLBACKS));

        fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof(FS_FILTER_CALLBACKS);
        fsFilterCallbacks.PreAcquireForSectionSynchronization = SrPreAcquireForSectionSynchronization;

        Status = FsRtlRegisterFileSystemFilterCallbacks( DriverObject, 
                                                         &fsFilterCallbacks );

        if (!NT_SUCCESS(Status))
            leave;

        //
        // register for fs registrations, the io manager will also notify us
        // of already loaded file systems... so we catch anything regardless of 
        // when we load.  this also catches any already mounted volumes.
        //
        
        Status = IoRegisterFsRegistrationChange(DriverObject, SrFsNotification);
        if (!NT_SUCCESS(Status)) 
            leave;

        //
        // start the global logger subsystem
        //

        Status = SrLoggerStart( DriverObject->DeviceObject,
                                &global->pLogger );

        if (!NT_SUCCESS(Status)) 
            leave;

    } finally {

        if (!NT_SUCCESS(Status))
        {
            //
            // force an unload which will cleanup all of the created and attached 
            // devices
            //
            
            SrUnload(DriverObject);
        }
    }
    
    SrTrace( LOAD_UNLOAD, ("SR!DriverEntry complete\n") );

    RETURN(Status);
}   // DriverEntry


//
// Private functions.
//


/***************************************************************************++

Routine Description:

    Unload routine called by the IO subsystem when SR is getting
    unloaded.

--***************************************************************************/
VOID
SrUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PSR_DEVICE_EXTENSION pExtension = NULL;
    NTSTATUS Status;
    LARGE_INTEGER Interval;
    PLIST_ENTRY pListEntry = NULL;
    
    //
    // Sanity check.
    //

    PAGED_CODE();

    SrTrace( LOAD_UNLOAD, ("SR!SrUnload\n") );

    if (global == NULL) {

        return;
    }

    //
    // unregister our interest in any new file systems
    //
    
    IoUnregisterFsRegistrationChange(DriverObject, SrFsNotification);

    //
    // disable the driver to prevent anyone from coming in and 
    // causing logging to start again.
    //

    global->Disabled = TRUE;
    
    //
    // To clean up we need to do the following:
    //
    //  1) Detach all volumes.
    //  2) Wait for all outstanding IOs to complete and all the logs to flush
    //     to disk.
    //  3) Delete all our device objects.
    //  4) Cleanup our global structures.
    //


    //
    //  Detach all volumes
    //

    if (IS_RESOURCE_INITIALIZED( &(global->DeviceExtensionListLock) ))
    {
        try {
            SrAcquireDeviceExtensionListLockShared();
            
            for (pListEntry = global->DeviceExtensionListHead.Flink;
                 pListEntry != &global->DeviceExtensionListHead;
                 pListEntry = pListEntry->Flink)
            {
                pExtension = CONTAINING_RECORD( pListEntry,
                                                SR_DEVICE_EXTENSION,
                                                ListEntry );
                
                SrDetachDevice( pExtension->pDeviceObject, FALSE );
            }   // while (pListEntry != &global->DeviceExtensionListHead)
        } finally {

            SrReleaseDeviceExtensionListLock();
        }
    }

    //
    //  Stop the logger and wait for all outstanding IOs to complete 
    //  and all the logs to flush to disk.
    //

    if (NULL != global->pLogger)
    {
        Status = SrLoggerStop( global->pLogger );
        CHECK_STATUS(Status);
        global->pLogger = NULL;
    }
    
    //
    // wait 5 seconds to make sure the logger is done flushing and the
    // outstanding IRPs to complete.
    // normally we would never unload.. so this is for debugging 
    // convenience only.
    //

    Interval.QuadPart = -1 * (5 * NANO_FULL_SECOND);
    KeDelayExecutionThread(KernelMode, TRUE, &Interval);

    //
    //  Delete all our device objects.
    //

    if (IS_RESOURCE_INITIALIZED( &(global->DeviceExtensionListLock) ))
    {
        try {
            SrAcquireDeviceExtensionListLockExclusive();
            
            pListEntry = global->DeviceExtensionListHead.Flink;
            while (pListEntry != &global->DeviceExtensionListHead) 
            {

                pExtension = CONTAINING_RECORD( pListEntry,
                                                SR_DEVICE_EXTENSION,
                                                ListEntry );

                //
                //  Remember this for later since we are about to delete this entry
                //
                
                pListEntry = pListEntry->Flink;

                //
                //  Detach from the list.
                //
                
                RemoveEntryList( &(pExtension->ListEntry) );

                //
                //  Delete the device
                //

                SrDeleteAttachmentDevice( pExtension->pDeviceObject );
                NULLPTR( pExtension );
            }
        } finally {
            
            SrReleaseDeviceExtensionListLock();
        }
    }
    
    //
    // Delete our global structures 
    //

    if (NULL != global->pControlDevice)
    {
        SrTrace(INIT, ( "SR!SrUnload IoDeleteDevice(%p) [control]\n", 
                        global->pControlDevice ));
        IoDeleteDevice( global->pControlDevice );
        global->pControlDevice = NULL;
    }

    //
    // we better not have anything else lying around.
    //
    
    ASSERT(IsListEmpty(&global->DeviceExtensionListHead));

    //
    // should we update our configuration file ?
    //

    if (IS_RESOURCE_INITIALIZED( &(global->GlobalLock) ))
    {
        try {

            SrAcquireGlobalLockExclusive();
            
            if (global->FileConfigLoaded)
            {
                //
                // write our the real next file / Seq number (not the +1000)
                //
                
                global->FileConfig.FileSeqNumber  = global->LastSeqNumber;
                global->FileConfig.FileNameNumber = global->LastFileNameNumber;

                Status = SrWriteConfigFile();
                CHECK_STATUS(Status);
            }
            
        } finally {

            SrReleaseGlobalLock();
        }
    }

    //
    // free the blob info structure
    //
        
    if (global->BlobInfoLoaded)
    {
        Status = SrFreeLookupBlob(&global->BlobInfo);
        CHECK_STATUS(Status);
    }

    if (global->pRegistryLocation != NULL)
    {
        SR_FREE_POOL(global->pRegistryLocation, SR_REGISTRY_TAG);
        global->pRegistryLocation = NULL;
    }

    //
    // cleanup our resources
    //

    if (IS_RESOURCE_INITIALIZED(&global->GlobalLock))
    {
        Status = ExDeleteResourceLite(&global->GlobalLock);
        ASSERT(NT_SUCCESS(Status));
    }

    if (IS_RESOURCE_INITIALIZED(&global->BlobLock))
    {
        Status = ExDeleteResourceLite(&global->BlobLock);
        ASSERT(NT_SUCCESS(Status));
    }

    if (IS_RESOURCE_INITIALIZED(&global->DeviceExtensionListLock))
    {
        Status = ExDeleteResourceLite(&global->DeviceExtensionListLock);
        ASSERT(NT_SUCCESS(Status));
    }

#ifdef USE_LOOKASIDE

    //
    // delete our lookaside list(s)
    //

    if (IS_LOOKASIDE_INITIALIZED(&global->FileNameBufferLookaside))
    {
        ExDeletePagedLookasideList(&global->FileNameBufferLookaside);
    }

#endif

}   // SrUnload

#if DBG
/***************************************************************************++

Routine Description:

    Hook for catching failed operations. This routine is called within each
    routine with the completion status.

Arguments:

    Status - Supplies the completion status.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrDbgStatus(
    IN NTSTATUS Status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{

    if (!NT_SUCCESS_NO_DBGBREAK(Status))
    {
        if ((global == NULL) || 
                (FlagOn(global->DebugControl, 
                    SR_DEBUG_VERBOSE_ERRORS|SR_DEBUG_BREAK_ON_ERROR) &&
                 (STATUS_BUFFER_OVERFLOW != Status) &&
                 (SR_STATUS_CONTEXT_NOT_SUPPORTED != Status) &&
                 (SR_STATUS_VOLUME_DISABLED != Status) &&
                 (SR_STATUS_IGNORE_FILE != Status)))
        {
            KdPrintEx((DPFLTR_SR_ID, DPFLTR_ERROR_LEVEL,
                       "SrDbgStatus: %s:%lu returning %08lx\n",
                       SrpFindFilePart( pFileName ),
                       LineNumber,
                       Status));
        }

        if ((global != NULL) && 
            FlagOn(global->DebugControl, SR_DEBUG_BREAK_ON_ERROR) && 
                // ignore STATUS_INSUFFICIENT_RESOURCES as the verifier injects
                // these normally under stress
            (STATUS_INSUFFICIENT_RESOURCES != Status) &&
                // ignore DISK_FULL, this happens under stress normally
            (STATUS_DISK_FULL != Status) &&
                // this happens under stress a lot
            (STATUS_BUFFER_OVERFLOW != Status) &&
                // This also happens under IOStress because there is a test
                // that will just dismount and mount volumes as activity is
                // happening.
            (STATUS_VOLUME_DISMOUNTED != Status) &&
                // This also happens when cleaning up from IOStress.  We
                // don't disable when we hit this error, so don't break
                // here either.
            (STATUS_FILE_CORRUPT_ERROR != Status) &&
                // Ignore our internal disabled error
            (SR_STATUS_VOLUME_DISABLED != Status) &&
                // Ignore our internal context not supported error
            (SR_STATUS_CONTEXT_NOT_SUPPORTED != Status) &&
                // Ignore when we decide to ignore a file
            (SR_STATUS_IGNORE_FILE != Status)
            )
        {
            KdBreakPoint();
        }
    }

    return Status;

}   // SrDbgStatus
#endif



/***************************************************************************++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--***************************************************************************/
VOID
SrFsNotification(
    IN PDEVICE_OBJECT pDeviceObject,
    IN BOOLEAN FsActive
    )
{
    NTSTATUS                Status;

    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));

    SrTrace( NOTIFY, ( "SR!SrFsNotification: %wZ(%p)\n", 
             &pDeviceObject->DriverObject->DriverName,
             pDeviceObject ));

    //
    // Begin by determining whether this file system is registering or
    // unregistering as an active file system.
    //

    if (FsActive) 
    {
        //
        // The file system has registered as an active file system.  attach 
        // to it.
        //

        //
        // attach to the main driver's control device (like \ntfs) 
        //

        if (SR_IS_SUPPORTED_DEVICE( pDeviceObject ) &&
            SrGetFilterDevice( pDeviceObject ) == NULL)
        {
            PSR_DEVICE_EXTENSION pNewDeviceExtension = NULL;
            
            Status = SrAttachToDevice( NULL, pDeviceObject, NULL, &pNewDeviceExtension );

            if (Status != STATUS_BAD_DEVICE_TYPE &&
                NT_SUCCESS( Status ))
            {
                //
                //  This is a control device object, so set that flag in the
                //  FsType of the deviceExtension.
                //

                SetFlag( pNewDeviceExtension->FsType, SrFsControlDeviceObject );
                //
                // now attach to all the volumes already mounted by this 
                // file system
                //

                Status = SrEnumerateFileSystemVolumes( pDeviceObject );
                CHECK_STATUS(Status);
            }

        }

    } 
    else    // if (FsActive) 
    {
        PDEVICE_OBJECT pSrDevice;
        
        //
        // Call SrGetFilterDevice to safely walk this device object chain
        // and find SR's device object.
        //

        pSrDevice = SrGetFilterDevice( pDeviceObject );

        if (pSrDevice != NULL) {

            //
            // We've found SR's device object, so now detach the device.
            //
            
            (VOID)SrDetachDevice(pSrDevice, TRUE);
            SrDeleteAttachmentDevice(pSrDevice);

        }   // while (pNextDevice != NULL) 

    }   // if (FsActive) 

}   // SrFsNotification

/***************************************************************************++

Routine Description:

    This will attach to a DeviceObject that represents a file system or 
    a mounted volume.  

Arguments:

    pRealDevice - OPTIONAL if this is a mounted volume this is the disk 
        device that can be used to fetch the name of the volume out .
        
    pDeviceObject - The file system device to attach to .

    pNewDeviceObject - OPTIONAL if this is passed in it is used as the device
        to attach to pDeviceObject.  if this is NULL a fresh device is 
        created. this allows callers to preallocate the device object if they
        wish.  SrMountCompletion uses this.

    ppExtension - OPTIONAL will hold the extension of the new device on return.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrAttachToDevice(
    IN PDEVICE_OBJECT pRealDevice OPTIONAL,
    IN PDEVICE_OBJECT pDeviceObject,
    IN PDEVICE_OBJECT pNewDeviceObject OPTIONAL,
    OUT PSR_DEVICE_EXTENSION *ppExtension OPTIONAL
    )
{
    NTSTATUS                Status;
    PDEVICE_OBJECT          pBaseFsDeviceObject = NULL;
    PDEVICE_OBJECT          pAllocatedDeviceObject = NULL;
    PSR_DEVICE_EXTENSION    pExtension;
    SR_FILESYSTEM_TYPE      fsType;

    PAGED_CODE();

    ASSERT(pRealDevice == NULL || IS_VALID_DEVICE_OBJECT(pRealDevice));
    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));
    ASSERT(pNewDeviceObject == NULL || IS_VALID_DEVICE_OBJECT(pNewDeviceObject));

    ASSERT(SrGetFilterDevice(pDeviceObject) == NULL);

    Status = STATUS_SUCCESS;

    //
    // only hook fat + ntfs;  Check this by looking at the name of the
    // base file system device object.
    //

    pBaseFsDeviceObject = IoGetDeviceAttachmentBaseRef ( pDeviceObject );
    ASSERT( pBaseFsDeviceObject != NULL );
    
    if (_wcsnicmp( pBaseFsDeviceObject->DriverObject->DriverName.Buffer, 
                   L"\\FileSystem\\Fastfat",
                   pBaseFsDeviceObject->DriverObject->DriverName.Length/sizeof(WCHAR) ) == 0) {

        fsType = SrFat;

    } else if (_wcsnicmp( pBaseFsDeviceObject->DriverObject->DriverName.Buffer, 
                         L"\\FileSystem\\Ntfs",
                         pBaseFsDeviceObject->DriverObject->DriverName.Length/sizeof(WCHAR) ) == 0 ) {

        fsType = SrNtfs;
        
    } else {

        Status = STATUS_BAD_DEVICE_TYPE;
        goto SrAttachToDevice_Exit;
    }

    //
    // we should only be connecting to fat + ntfs now, these are supported
    // device types
    //
    
    ASSERT( SR_IS_SUPPORTED_DEVICE( pDeviceObject ) );
    ASSERT( pRealDevice == NULL || SR_IS_SUPPORTED_REAL_DEVICE( pRealDevice ));

    if (pNewDeviceObject == NULL)
    {
        //
        // create a device now
        //
        
        Status = SrCreateAttachmentDevice( pRealDevice, 
                                           pDeviceObject, 
                                           &pAllocatedDeviceObject );

        if (!NT_SUCCESS( Status )) 
            goto SrAttachToDevice_Exit;

        pNewDeviceObject = pAllocatedDeviceObject;
    }

    pExtension = pNewDeviceObject->DeviceExtension;
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

    //
    // initialize the rest of the device extension
    //

    pExtension->FsType = fsType;

    //
    // and create our hash list
    //

    Status = HashCreateList( BACKUP_BUCKET_COUNT, 
                             BACKUP_BUCKET_LENGTH,
                             (pExtension->pNtVolumeName != NULL) ? 
                                pExtension->pNtVolumeName->Length : 0,
                             NULL,                          // pDestructor
                             &pExtension->pBackupHistory );
    
    if (!NT_SUCCESS(Status)) {
        goto SrAttachToDevice_Exit;
    }

    try {

        //
        //  Propogate flags
        //

        if (FlagOn( pDeviceObject->Flags, DO_BUFFERED_IO )) 
        {
            SetFlag( pNewDeviceObject->Flags, DO_BUFFERED_IO);
        }

        if (FlagOn( pDeviceObject->Flags, DO_DIRECT_IO )) 
        {
            SetFlag( pNewDeviceObject->Flags, DO_DIRECT_IO );
        }

        //
        //  Hold the device extension list lock while we attach and insert
        //  this device extension into our list to ensure that this is done
        //  atomically.
        //
        
        SrAcquireDeviceExtensionListLockExclusive();

        Status = IoAttachDeviceToDeviceStackSafe( pNewDeviceObject,
                                                  pDeviceObject,
                                                  &pExtension->pTargetDevice );

        if (!NT_SUCCESS(Status)) 
        {
            leave;
        } 

        //
        // all done with this, it's attached now.  Must NULL this here
        // so that it won't get freed when we cleanup.
        //
        
        pAllocatedDeviceObject = NULL;

        //
        // insert it into our global list now that it is attached
        //

        InsertTailList(&global->DeviceExtensionListHead, &pExtension->ListEntry);
        
    } finally {

        SrReleaseDeviceExtensionListLock();
    }

    if (!NT_SUCCESS( Status )) {
        goto SrAttachToDevice_Exit;
    }

    //
    // we are now done initializing our new device
    //
    
    ClearFlag( pNewDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    SrTrace( INIT, ("SR!SrAttachToDevice:f=%p,t=%p,%wZ [%wZ]\n",
             pNewDeviceObject,
             pExtension->pTargetDevice,
             &(pExtension->pTargetDevice->DriverObject->DriverName),
             pExtension->pNtVolumeName ));

    //
    // return the extension
    //
    
    if (ppExtension != NULL)
    {
        *ppExtension = pExtension;
    }

SrAttachToDevice_Exit:

    //
    //  Clear the reference added by calling IoGetDeviceAttachmentBaseRef.
    //
    
    if (pBaseFsDeviceObject != NULL) {

        ObDereferenceObject (pBaseFsDeviceObject);
    }
    
    if (pAllocatedDeviceObject != NULL)
    {
        SrDeleteAttachmentDevice(pAllocatedDeviceObject);
        pAllocatedDeviceObject = NULL;
    }

#if DBG
    if (Status == STATUS_BAD_DEVICE_TYPE)
    {
        return Status;
    }
#endif

    RETURN(Status);
    
}   // SrAttachToDevice 

/***************************************************************************++

Routine Description:

    this will detach pDeviceObject from it's target device.

Arguments:

    pDeviceObject - The unnamed sr device that attached to the file 
                    system device

--***************************************************************************/
VOID
SrDetachDevice(
    IN PDEVICE_OBJECT pDeviceObject,
    IN BOOLEAN RemoveFromDeviceList
    )
{
    PSR_DEVICE_EXTENSION    pExtension;
    NTSTATUS                Status;

    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));

    //
    // grab the extension
    //
    
    pExtension = pDeviceObject->DeviceExtension;

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    
    if (!IS_VALID_SR_DEVICE_EXTENSION(pExtension))
        return;

    SrTrace(INIT, ( "SR!SrDetachDevice:%p,%wZ [%wZ]\n", 
            pDeviceObject,
            &pExtension->pTargetDevice->DriverObject->DriverName,
            pExtension->pNtVolumeName ));


    //
    // detach the device
    //
    
    ASSERT(IS_VALID_DEVICE_OBJECT(pExtension->pTargetDevice));
    
    ASSERT(pExtension->pTargetDevice->AttachedDevice == pDeviceObject);

    //
    // detach from the device
    //
    
    IoDetachDevice(pExtension->pTargetDevice);

    try {
        SrAcquireActivityLockExclusive( pExtension );

        pExtension->Disabled = TRUE;

        //
        // stop logging ?
        //

        if (pExtension->pLogContext != NULL)
        {
            Status = SrLogStop( pExtension, TRUE, FALSE );
            CHECK_STATUS(Status);
        }

    } finally {

        SrReleaseActivityLock( pExtension );
    }

    //
    // is it the system volume?
    //
    
    if (global->pSystemVolumeExtension == pExtension) {
        SrTrace(INIT, ("sr!SrDetachDevice: detaching from the system volume\n"));
        global->pSystemVolumeExtension = NULL;
    }

    //
    // remove ourselves from the global list
    //

    if (RemoveFromDeviceList) {
        
        try {
            SrAcquireDeviceExtensionListLockExclusive();

            //
            // remove ourselves from the global list
            //

            RemoveEntryList(&pExtension->ListEntry);
            
        } finally {

            SrReleaseDeviceExtensionListLock();
        }
    }    
}   // SrDetachDevice


/***************************************************************************++

Routine Description:

    This routine will see if we are already attached to the given device.
    if we are, it returns the device that we used to attach.

Arguments:

    DeviceObject - The device chain we want to look through

Return Value:

    PDEVICE_OBJECT - NULL if not attached, otherwise the device attached.

--***************************************************************************/
PDEVICE_OBJECT
SrGetFilterDevice(
    PDEVICE_OBJECT pDeviceObject
    )
{
    PDEVICE_OBJECT pNextDevice;

    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));

    //
    // we might be in the middle of an attachment chain, get the top device
    //

    pDeviceObject = IoGetAttachedDeviceReference(pDeviceObject);

    //
    // now walk down the attachment chain, looking for sr.sys 
    //

    do 
    {
        //
        //  See if this is OUR device object
        //

        if (IS_SR_DEVICE_OBJECT(pDeviceObject))
        {
            ObDereferenceObject(pDeviceObject);
            return pDeviceObject;
        }

        pNextDevice = IoGetLowerDeviceObject(pDeviceObject);
        
        ObDereferenceObject(pDeviceObject);
        
        pDeviceObject = pNextDevice;

    } while (NULL != pDeviceObject);

    ASSERT(pDeviceObject == NULL);

    return NULL;
}

NTSTATUS
SrAttachToVolumeByName(
    IN PUNICODE_STRING pVolumeName,
    OUT PSR_DEVICE_EXTENSION * ppExtension OPTIONAL
    )
{
    NTSTATUS                Status;
    HANDLE                  VolumeHandle = NULL;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    PVPB                    pVpb;
    PFILE_OBJECT            pVolumeFileObject = NULL;
    PDEVICE_OBJECT          pDeviceObject;

    ASSERT(pVolumeName != NULL);

    PAGED_CODE();

    try {

        //
        // open this volume up, to see it's REAL name (no symbolic links) 
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    pVolumeName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = ZwCreateFile( &VolumeHandle,
                               SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,                    //  OPEN_EXISTING
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0 );                                // EaLength

        if (!NT_SUCCESS(Status))
            leave;

        //
        // reference the file object
        //

        Status = ObReferenceObjectByHandle( VolumeHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pVolumeFileObject,
                                            NULL );

        if (!NT_SUCCESS(Status))
            leave;

        ASSERT(IS_VALID_FILE_OBJECT(pVolumeFileObject));

        pVpb = pVolumeFileObject->DeviceObject->Vpb;

        //
        // does it have a real device object
        //
        // only attach to mounted volumes.  we've already attached to 
        // all of the file systems, any new volume mounts we will
        // catch in SrFsControl.
        //
            
        if (pVpb != NULL && pVpb->DeviceObject != NULL)
        {
            //
            // attach! are we already attached to it?
            //
            
            if (SR_IS_SUPPORTED_VOLUME(pVpb))
            {
                //
                // are we already attached?
                //
                
                pDeviceObject = SrGetFilterDevice(pVpb->DeviceObject);
                if (pDeviceObject == NULL)
                {
                    //
                    // nope, attach to the volume
                    //

                    Status = SrAttachToDevice( pVpb->RealDevice, 
                                               pVpb->DeviceObject,
                                               NULL,
                                               ppExtension );
                                               
                    if (!NT_SUCCESS(Status))
                        leave;
                }
                
                //
                // we're already attached, did the caller want a copy of 
                // the extension ?
                //
                
                else if (ppExtension != NULL)
                {
                    ASSERT(IS_SR_DEVICE_OBJECT( pDeviceObject ));
                    *ppExtension = pDeviceObject->DeviceExtension;
                }
            }
            else
            {
                Status = STATUS_BAD_DEVICE_TYPE;
                leave;
            }
        }
        else
        {
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }


    } finally {    

        Status = FinallyUnwind(SrAttachToVolumeByName, Status);

        if (pVolumeFileObject != NULL)
        {
            ObDereferenceObject(pVolumeFileObject);
            pVolumeFileObject = NULL;
        }

        if (VolumeHandle != NULL)
        {
            ZwClose(VolumeHandle);
            VolumeHandle = NULL;
        }

        
    }

#if DBG

    if (Status == STATUS_BAD_DEVICE_TYPE)
    {
        return Status;
    }

#endif


    RETURN(Status);
    
}   // SrAttachToVolumeByName


/***************************************************************************++

Routine Description:

Arguments:

Return Value:

--***************************************************************************/
NTSTATUS
SrCreateAttachmentDevice(
    IN PDEVICE_OBJECT pRealDevice OPTIONAL,
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PDEVICE_OBJECT *ppNewDeviceObject
    )
{
    NTSTATUS                Status;
    BOOLEAN                 Exclusive;
    PDEVICE_OBJECT          pNewDeviceObject = NULL;
    PSR_DEVICE_EXTENSION    pExtension = NULL;

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));
    
    PAGED_CODE();
    
    try {

        Exclusive = FlagOn(pDeviceObject->Flags, DO_EXCLUSIVE) ? TRUE : FALSE;

        Status = IoCreateDevice( global->pDriverObject,
                                 sizeof( SR_DEVICE_EXTENSION ),
                                 NULL,  // DeviceName
                                 pDeviceObject->DeviceType,
                                 pDeviceObject->Characteristics,
                                 Exclusive,
                                 &pNewDeviceObject );

        if (!NT_SUCCESS( Status )) 
            leave;

        //
        // initialize our device extension
        //
        
        pExtension = pNewDeviceObject->DeviceExtension;

        RtlZeroMemory(pExtension, sizeof(SR_DEVICE_EXTENSION));

        pExtension->Signature = SR_DEVICE_EXTENSION_TAG;
        pExtension->pDeviceObject = pNewDeviceObject;
        SrInitContextCtrl( pExtension );

        //
        // we only care about volume names.
        //
        
        if (pRealDevice != NULL)
        {
            ASSERT(SR_IS_SUPPORTED_REAL_DEVICE(pRealDevice));
            
            //
            // get the nt volume name and stuff it in the extension
            //
            
            Status = SrAllocateFileNameBuffer( SR_MAX_FILENAME_LENGTH, 
                                               &pExtension->pNtVolumeName );
                                               
            if (!NT_SUCCESS(Status))
                leave;
            
            Status = SrGetObjectName( NULL,
                                      pRealDevice,
                                      pExtension->pNtVolumeName,
                                      SR_FILENAME_BUFFER_LENGTH );

            if (!NT_SUCCESS(Status))
                leave;
        }

        //
        //  Initialize the volume activity lock
        //

        ExInitializeResourceLite( &(pExtension->ActivityLock) );

        //
        //  The ActivityLockHeldExclusive boolean is initialize to false
        //  by zeroing the device extension above.
        //
        //  pExtension->ActivityLockHeldExclusive = FALSE;

        //
        //  Initialize the volume log lock
        //

        ExInitializeResourceLite( &(pExtension->LogLock) );

        *ppNewDeviceObject = pNewDeviceObject;
        pNewDeviceObject = NULL;

    } finally {

        Status = FinallyUnwind(SrCreateAttachmentDevice, Status);
        
        if (pNewDeviceObject != NULL)
        {
            SrDeleteAttachmentDevice(pNewDeviceObject);
            pNewDeviceObject = NULL;
        }
    }

    RETURN(Status);

}   // SrCreateAttachmentDevice


/***************************************************************************++

Routine Description:

Arguments:

Return Value:

--***************************************************************************/
VOID
SrDeleteAttachmentDevice(
    IN PDEVICE_OBJECT pDeviceObject
    )
{
    PSR_DEVICE_EXTENSION pExtension;

    PAGED_CODE();
    
    pExtension = pDeviceObject->DeviceExtension;
    
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    
    if (IS_VALID_SR_DEVICE_EXTENSION(pExtension))
    {
        if (pExtension->pNtVolumeName != NULL)
        {
            SrFreeFileNameBuffer(pExtension->pNtVolumeName);
            pExtension->pNtVolumeName = NULL;
        }

        //
        // clear our hash list
        //
        
        if (pExtension->pBackupHistory != NULL) 
        {
            HashDestroyList(pExtension->pBackupHistory);
            pExtension->pBackupHistory = NULL;
        }

        //
        //  Remove all existing contexts then cleanup the structure
        //

        SrCleanupContextCtrl( pExtension );

        pExtension->Signature = MAKE_FREE_TAG(pExtension->Signature);
   }

   if (IS_RESOURCE_INITIALIZED( &(pExtension->ActivityLock) ))
   {
       ExDeleteResourceLite( &(pExtension->ActivityLock) );
   }

   if (IS_RESOURCE_INITIALIZED( &(pExtension->LogLock) ))
   {
       ExDeleteResourceLite( &(pExtension->LogLock) );
   }

   IoDeleteDevice(pDeviceObject);

}   // SrDeleteAttachmentDevice



/***************************************************************************++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    pDeviceObject - The device object for the file system we want to enumerate

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrEnumerateFileSystemVolumes(
    IN PDEVICE_OBJECT pDeviceObject
    ) 
{
    PDEVICE_OBJECT *ppDeviceList = NULL;
    PDEVICE_OBJECT  pRealDevice;
    NTSTATUS        Status;
    ULONG           DeviceCount;
    ULONG           i;

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));
    
    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    Status = IoEnumerateDeviceObjectList( pDeviceObject->DriverObject,
                                          NULL,
                                          0,
                                          &DeviceCount);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        return Status;
    }

    //
    //  Allocate memory for the list of known devices
    //

    DeviceCount += 2;        //grab a few extra slots

    ppDeviceList = SR_ALLOCATE_POOL( NonPagedPool, 
                                     (DeviceCount * sizeof(PDEVICE_OBJECT)), 
                                     SR_DEVICE_LIST_TAG );
    if (NULL == ppDeviceList) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SrEnumerateFileSystemVolumes_Exit;
    }

    //
    //  Now get the list of devices.  If we get an error again
    //  something is wrong, so just fail.
    //

    Status = IoEnumerateDeviceObjectList( pDeviceObject->DriverObject,
                                          ppDeviceList,
                                          (DeviceCount * sizeof(PDEVICE_OBJECT)),
                                          &DeviceCount );

    if (!NT_SUCCESS( Status )) {
        
        goto SrEnumerateFileSystemVolumes_Exit;
    }

    //
    //  Walk the given list of devices and attach to them if we should.
    //

    for (i = 0; i < DeviceCount; i++) 
    {

        //
        //  Do not attach if:
        //      - This is the control device object (the one passed in)
        //      - We are already attached to it
        //

        if (ppDeviceList[i] != pDeviceObject &&
            SrGetFilterDevice(ppDeviceList[i]) == NULL)
        {
            //
            //  Get the disk device object associated with this
            //  file  system device object.  Only try to attach if we
            //  have a storage device object.  If the device does not
            //  have 
            //

            Status = IoGetDiskDeviceObject( ppDeviceList[i], &pRealDevice);

            //
            // don't dbgbreak, as it might not be a properly mounted 
            // volume, we can ignore these
            //
            
            if (NT_SUCCESS_NO_DBGBREAK( Status ) && 
                SR_IS_SUPPORTED_REAL_DEVICE(pRealDevice) ) 
            {
                Status = SrAttachToDevice( pRealDevice,
                                           ppDeviceList[i],
                                           NULL,
                                           NULL );

                CHECK_STATUS(Status);
                    
                //
                //  Remove reference added by IoGetDiskDeviceObject.
                //  We only need to hold this reference until we are
                //  successfully attached to the current volume.  Once
                //  we are successfully attached to ppDeviceList[i], the
                //  IO Manager will make sure that the underlying
                //  diskDeviceObject will not go away until the file
                //  system stack is torn down.
                //

                ObDereferenceObject(pRealDevice);
                pRealDevice = NULL;
            }
        }

        //
        //  Dereference the object (reference added by 
        //  IoEnumerateDeviceObjectList)
        //

        ObDereferenceObject( ppDeviceList[i] );
        ppDeviceList[i] = NULL;
    }

    //
    //  We are going to ignore any errors received while mounting.  We
    //  simply won't be attached to those volumes if we get an error
    //

    Status = STATUS_SUCCESS;

SrEnumerateFileSystemVolumes_Exit:
    
    //
    //  Free the memory we allocated for the list
    //

    if (ppDeviceList != NULL)
    {
        SR_FREE_POOL(ppDeviceList, SR_DEVICE_LIST_TAG);
    }

    RETURN(Status);
    
}   // SrEnumerateFileSystemVolumes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\lookup.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    lookup.h

Abstract:

    contains prototypes for functions in lookup.c

Author:

    Kanwaljit Marok (kmarok)     01-March-2000

Revision History:

--*/


#ifndef _LOOKUP_H_
#define _LOOKUP_H_

//
// this structure contains all the relevant pointers after
// the lookup blob is loaded in memory
//

typedef struct _BLOB_INFO
{
    //
    // Pointer to Start of blob in memory
    //

    PBYTE LookupBlob;

    //
    // Pointer to Start of path tree in memory
    //

    PBYTE LookupTree;

    //
    // Pointer to Start of hash list in memory
    //

    PBYTE LookupList;

    //
    // Default type of the node.
    //

    DWORD DefaultType;

} BLOB_INFO, * PBLOB_INFO;

//
// lookup function prototypes
//

NTSTATUS
SrLoadLookupBlob(
    IN  PUNICODE_STRING pFileName,
    IN  PDEVICE_OBJECT pTargetDevice,
    OUT PBLOB_INFO pBlobInfo
    );

NTSTATUS
SrReloadLookupBlob(
    IN  PUNICODE_STRING pFileName,
    IN  PDEVICE_OBJECT pTargetDevice,
    IN  PBLOB_INFO pBlobInfo
    );

NTSTATUS
SrFreeLookupBlob(
    IN  PBLOB_INFO pBlobInfo
    );

NTSTATUS
SrIsExtInteresting(
    IN  PUNICODE_STRING pszPath,
    OUT PBOOLEAN        pInteresting
    );

NTSTATUS
SrIsPathInteresting(
    IN  PUNICODE_STRING pszFullPath,
    IN  PUNICODE_STRING pszVolPrefix,
    IN  BOOLEAN         IsDirectory,
    OUT PBOOLEAN        pInteresting
    );

#endif // _LOOKUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\lookup.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    lookup.c

Abstract:

    this is the sr lookup functionlity implementation

Author:

    Kanwaljit Marok (kmarok)     01-May-2000

Revision History:

--*/

#include "precomp.h"

//
// Include hlist.c to use the inline funtions
//

#include "hlist.c"
#include "ptree.c"

//
// Internal helper APIs
//

static
NTSTATUS
SrOpenLookupBlob(
    IN  PUNICODE_STRING pFileName,
    IN  PDEVICE_OBJECT  pTargetDevice,
    OUT PBLOB_INFO pBlobInfo
    );

//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrOpenLookupBlob    )
#pragma alloc_text( PAGE, SrLoadLookupBlob    )
#pragma alloc_text( PAGE, SrReloadLookupBlob  )
#pragma alloc_text( PAGE, SrFreeLookupBlob    )
#pragma alloc_text( PAGE, SrIsExtInteresting  )
#pragma alloc_text( PAGE, SrIsPathInteresting )

#endif  // ALLOC_PRAGMA

//++
// Function:
//		SrOpenLookupBlob
//
// Description:
//		This function loads the lookup blob in memory and 
//		sets the appropriate pointers for lookup.
//
// Arguments:
//
// Return Value:
//		This function returns STATUS_XXX
//--

static
NTSTATUS
SrOpenLookupBlob(
    IN  PUNICODE_STRING pFileName,
    IN  PDEVICE_OBJECT  pTargetDevice,
    OUT PBLOB_INFO      pBlobInfo
    )
{
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES  oa;
    IO_STATUS_BLOCK    IoStatusBlock;
    HANDLE             Handle   = NULL;
    PLIST_ENTRY        pListEntry;
    PSR_DEVICE_EXTENSION pExtension;
    static char blobFailureMessage[] = "sr!System Restore's BLOB file \"%wZ\" is invalid.\n";

    PAGED_CODE();
    
    ASSERT(pFileName);
    ASSERT(pBlobInfo);

    ASSERT( IS_BLOB_LOCK_ACQUIRED() );

    try    
    {
        //
        // Zero out the pointers that get initialized when the 
        // blob is successfully read into the memory from disk
        //
    
        pBlobInfo->LookupBlob = NULL;
        pBlobInfo->LookupTree = NULL;
        pBlobInfo->LookupList = NULL;
        pBlobInfo->DefaultType= NODE_TYPE_UNKNOWN;
    
        //
        // open and read the file
        //
    
        InitializeObjectAttributes( &oa,
                                    pFileName,
                                    OBJ_KERNEL_HANDLE, 
                                    NULL,
                                    NULL );
    
        Status = SrIoCreateFile(
                     &Handle,
                     GENERIC_READ | SYNCHRONIZE,
                     &oa,
                     &IoStatusBlock,
                     0,
                     FILE_ATTRIBUTE_NORMAL,
                     FILE_SHARE_READ,
                     FILE_OPEN,
                     FILE_SYNCHRONOUS_IO_NONALERT,
                     NULL,
                     0,
                     0,
                     pTargetDevice );
    
        if (NT_SUCCESS(Status))
        {
            DWORD dwBytesRead = 0, dwBytes = 0;
            LARGE_INTEGER nOffset;
            BlobHeader blobHeader;
    
            //
            // Read the blob header
            //
    
            nOffset.QuadPart = 0;
            dwBytes          = sizeof(blobHeader);
    
            Status =  ZwReadFile(
                          Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          &blobHeader,
                          dwBytes,
                          &nOffset,
                          NULL
                      );
    
            if (NT_SUCCESS(Status))
            {
                //
                // need to do some sanity check on the header
                //
    
                if ( !VERIFY_BLOB_VERSION(&blobHeader) ||
                     !VERIFY_BLOB_MAGIC  (&blobHeader) )
                {
                    SrTrace( BLOB_VERIFICATION, (blobFailureMessage, pFileName) );

                    Status = STATUS_FILE_CORRUPT_ERROR;
                    leave;
                }
    
                pBlobInfo->LookupBlob = SR_ALLOCATE_POOL( 
                                            NonPagedPool,
                                            blobHeader.m_dwMaxSize,
                                            SR_LOOKUP_TABLE_TAG );
    
                if( pBlobInfo->LookupBlob )
                {
                    //
                    // Read the entire file now
                    //
    
                    nOffset.QuadPart = 0;
                    dwBytes = blobHeader.m_dwMaxSize;
     
                    Status =  ZwReadFile(
                                  Handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  pBlobInfo->LookupBlob,
                                  dwBytes,
                                  &nOffset,
                                  NULL
                                  );
    
                    if (NT_SUCCESS(Status))
                    {
                        //
                        // TODO: verify that size of the file matched the
                        // size from the header
                        //
    
                        //
                        // Setup the lookup pointers properly in blobinfo
                        //
    
                        pBlobInfo->LookupTree = pBlobInfo->LookupBlob + 
                                                sizeof(blobHeader);
    
                        pBlobInfo->LookupList = pBlobInfo->LookupTree + 
                                                BLOB_MAXSIZE((pBlobInfo->LookupTree));
    
                        pBlobInfo->DefaultType = TREE_HEADER((pBlobInfo->LookupTree))->m_dwDefault;
    
                        //
                        // Verify the individual blobs
                        //
    
                        if (!SrVerifyBlob(pBlobInfo->LookupBlob)) {

                            SrTrace( BLOB_VERIFICATION, 
                                     (blobFailureMessage,pFileName) );
                            Status = STATUS_FILE_CORRUPT_ERROR;
                            leave;
                        }
                    }
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else
        {
            SrTrace( VERBOSE_ERRORS, 
                     ("sr!SrOpenLookupBlob:  Cannot Open Blob file \"%wZ\"\n",
                      pFileName) );
        }

        //
        //  The new blob was loaded successfully, perge all contexts on all
        //  volumes since what is interesting and what is not interesting
        //  may have changed.
        //

        ASSERT(!IS_DEVICE_EXTENSION_LIST_LOCK_ACQUIRED());

        try
        {
            SrAcquireDeviceExtensionListLockShared();

            for (pListEntry = _globals.DeviceExtensionListHead.Flink;
                 pListEntry != &_globals.DeviceExtensionListHead;
                 pListEntry = pListEntry->Flink)
            {
                pExtension = CONTAINING_RECORD( pListEntry,
                                                SR_DEVICE_EXTENSION,
                                                ListEntry );
            
                ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

                //
                //  Skip Control Device Objects.
                //

                if (!FlagOn(pExtension->FsType,SrFsControlDeviceObject))
                {
                    SrDeleteAllContexts( pExtension );
                }
            }
        }
        finally
        {
            SrReleaseDeviceExtensionListLock();
        }
    }
    finally
    {
        Status = FinallyUnwind(SrOpenLookupBlob, Status);

        //
        // close the blob file handle
        //
    
        if (Handle)
        {
            ZwClose( Handle );
        }
    
        //
        // incase of a failure free up the resources
        //
    
        if (!NT_SUCCESS(Status))
        {
            if( pBlobInfo->LookupBlob )
            {
                SR_FREE_POOL( pBlobInfo->LookupBlob, SR_LOOKUP_TABLE_TAG );
            }
    
            pBlobInfo->LookupBlob = NULL;
            pBlobInfo->LookupTree = NULL;
            pBlobInfo->LookupList = NULL;
            pBlobInfo->DefaultType= NODE_TYPE_UNKNOWN;
        }
    }

    RETURN(Status);
}

//
// Public APIs called by the filer
//

//++
// Function:
//		SrLoadLookupBlob
//
// Description:
//		This function loads the lookup blob in memory and 
//		sets the appropriate pointers for lookup.
//
// Arguments:
//
// Return Value:
//		This function returns STATUS_XXX
//--

NTSTATUS
SrLoadLookupBlob(
    IN  PUNICODE_STRING pFileName,
    IN  PDEVICE_OBJECT pTargetDevice,
    OUT PBLOB_INFO pBlobInfo
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    
    ASSERT( pFileName );
    ASSERT( pBlobInfo );

    try
    {
        SrAcquireBlobLockExclusive();
     
        //
        // if somebody else did it, bail out
        //
    
        if (global->BlobInfoLoaded)
        {
            Status = STATUS_SUCCESS;
            leave;
        }
    
        //
        // initialize return information
        //
    
        RtlZeroMemory( pBlobInfo, sizeof( BLOB_INFO ) );
    
        //
        // Try and open the lookup blob
        //
    
        Status = SrOpenLookupBlob( pFileName, 
                                   pTargetDevice,
                                   pBlobInfo );
    
        //
        // If we failed to read the file for some reason,
        // reinitlialize the return info
        //
    
        if ( NT_SUCCESS( Status ) )
        {
            SrTrace(LOOKUP, ("Loaded lookup blob :%wZ\n", pFileName) );
            global->BlobInfoLoaded = TRUE;
        }
        else
        {
            SrFreeLookupBlob( pBlobInfo );
        }
    }
    finally
    {
        SrReleaseBlobLock();
    }

    RETURN(Status);
}

//++
// Function:
//		SrReloadLookupBlob
//
// Description:
//		This function loads the lookup blob in memory and 
//		sets the appropriate pointers for lookup.
//
// Arguments:
//		Pointer to LookupBlob 
//		Pointer to BlobInfo structure 
//
// Return Value:
//		This function returns STATUS_XXX
//--

NTSTATUS
SrReloadLookupBlob(
    IN  PUNICODE_STRING pFileName,
    IN  PDEVICE_OBJECT pTargetDevice,
    OUT PBLOB_INFO pBlobInfo
    )
{
    NTSTATUS   Status = STATUS_UNSUCCESSFUL;
    BLOB_INFO  OldBlobInfo;

    PAGED_CODE();

    ASSERT( pFileName != NULL );
    ASSERT( pBlobInfo != NULL );

    ASSERT( !IS_BLOB_LOCK_ACQUIRED() );
    
    try
    {
        SrAcquireBlobLockExclusive();
    
        if (global->BlobInfoLoaded == 0)
        {
            Status = SrLoadLookupBlob( pFileName, 
                                       pTargetDevice,
                                       pBlobInfo );
            leave;
        }
    
        //
        // Save the current blob info
        //
    
        RtlCopyMemory( &OldBlobInfo, pBlobInfo, sizeof( BLOB_INFO ) );
    
        //
        // Open the new blob file
        //
    
        Status = SrOpenLookupBlob( pFileName, 
                                   pTargetDevice,
                                   pBlobInfo );
    
        if(NT_SUCCESS(Status))
        {
            //
            // Free up the memory taken up by the old blob
            //
    
            if (OldBlobInfo.LookupBlob)
            {
                SR_FREE_POOL( OldBlobInfo.LookupBlob, SR_LOOKUP_TABLE_TAG );
            }
    
            SrTrace(LOOKUP, ("Reloaded lookup blob :%wZ\n", pFileName) );
        }
        else
        {
            //
            // Copy the old information back in the original context
            //
    
            RtlCopyMemory( pBlobInfo, &OldBlobInfo, sizeof( BLOB_INFO ) );
    
            SrTrace(LOOKUP, (" Cannot reload blob :%wZ\n", pFileName) );
        }
    }
    finally
    {
        if (NT_SUCCESS_NO_DBGBREAK( Status ))
        {
            //
            //  The blob has been reload successfully, so make sure that the
            //  global BlobError flag is cleared.
            //
            //  We do this here because we are still holding the blob lock.
            //

            _globals.HitErrorLoadingBlob = FALSE;
        }

        SrReleaseBlobLock();
    }

    RETURN(Status);
}


//++
// Function:
//		SrFreeLookupBlob
//
// Description:
//		This function Frees the lookup blob in memory
//
// Arguments:
//		Pointer to BlobInfo structure 
//
// Return Value:
//		This function returns STATUS_XXX
//--

NTSTATUS
SrFreeLookupBlob(
    IN  PBLOB_INFO pBlobInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT( pBlobInfo );

    try
    {    
        SrAcquireBlobLockExclusive();
    
        if (_globals.BlobInfoLoaded == 0)
        {
            //
            //  Reset our error flag here.
            //
            
            _globals.HitErrorLoadingBlob = FALSE;
            leave;
        }
    
        if( pBlobInfo->LookupBlob )
        {
            SR_FREE_POOL( pBlobInfo->LookupBlob, SR_LOOKUP_TABLE_TAG );
            pBlobInfo->LookupBlob = NULL;
        }
    
        RtlZeroMemory( pBlobInfo, sizeof(BLOB_INFO) );
        pBlobInfo->DefaultType = NODE_TYPE_UNKNOWN;
    
        SrTrace(LOOKUP, ("Freed lookup blob\n") );
    
        global->BlobInfoLoaded = 0;
    }
    finally
    {
        SrReleaseBlobLock();
    }
 
    RETURN(Status);
}


//++
// Function:
//		SrIsExtInteresting
//
// Description:
//		This function checks the file extension in the blob to
//      see if we care about it
//
// Arguments:
//		Pointer to BlobInfo structure  
//		Pointer to Path 
//		Pointer to boolean return value
//
// Return Value:
//		This function returns TRUE/FALSE
//--

NTSTATUS
SrIsExtInteresting(
    IN  PUNICODE_STRING pFileName,
    OUT PBOOLEAN        pInteresting
    )
{
    BOOL     fRet   = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    INT      iType  = 0;
    BOOL     fPathHasExt = FALSE;
    BOOL     fMatch = FALSE;

    PAGED_CODE();

    //
    // check parameters and lookup info
    //

    ASSERT(pFileName);
    ASSERT(pInteresting);

    //
    // Lookup code is enclosed in an exception handler to protect against
    // bad memroy accesses generated by corrupt lookup data
    //

    try
    {

        *pInteresting = FALSE;
    
        //
        // CODEWORK : put some blob verification code, 
        // magicnum, type etc
        //
    
        //
        // Take the blob lock so that other threads won't change 
        // the blob while we are looking up.  Note that the blob
        // can be gone after we get the lock.
        //
    
        SrAcquireBlobLockShared();

        if ( !global->BlobInfoLoaded ||
             !global->BlobInfo.LookupList )
        {
            Status = SR_STATUS_VOLUME_DISABLED;
            leave;
        }
    
        //
        // parse the filename for lookup in the mem blob
        //
        
        fMatch = MatchExtension(
                     global->BlobInfo.LookupList, 
                     pFileName,
                     &iType, 
                     &fPathHasExt );

        if ( !fMatch )
        {
            //
            // Extension didn't match, so setting to default type
            //

            iType = global->BlobInfo.DefaultType;
        }

        if ( !fPathHasExt )
        {
            //
            // If the path didn't contain an extension then we should
            // treat it as an exclude 
            //

            iType = NODE_TYPE_EXCLUDE;
        }

        //
        // If type is still unknown then set the type to the default.
        //

        if ( NODE_TYPE_UNKNOWN == iType )
        {
            iType = global->BlobInfo.DefaultType;
        }

        *pInteresting = (iType != NODE_TYPE_EXCLUDE);
    
        // SrTrace(LOOKUP, ("Extention Interest:%d\n", *pInteresting) );
    }
    finally
    {
        Status = FinallyUnwind(SrIsExtInteresting, Status);
        
        SrReleaseBlobLock();

        if (!NT_SUCCESS(Status))
        {
            *pInteresting = FALSE;
        }
            
    }

    RETURN(Status);
}


//++
// Function:
//		SrIsPathInteresting
//
// Description:
//		This function checks the file name in the blob to
//      see if we care about it
//
// Arguments:
//		Pointer to BlobInfo structure  
//		Pointer to Full Path 
//		Pointer to Volume Prefix 
//		Boolean to indicate if this path is a directory 
//		Pointer to boolean return value
//
// Return Value:
//		This function returns TRUE/FALSE
//--

NTSTATUS
SrIsPathInteresting(
    IN  PUNICODE_STRING pFullPath,
    IN  PUNICODE_STRING pVolPrefix,
    IN  BOOLEAN         IsDirectory,
    OUT PBOOLEAN        pInteresting
    )
{
    BOOL        fRet    = FALSE;
    NTSTATUS    Status  = STATUS_UNSUCCESSFUL;
    PBYTE       pFileName = NULL;
    WORD        FileNameSize = 0;
    UNICODE_STRING localName;

    PAGED_CODE();
    
    //
    // check parameters and lookup info
    //

    ASSERT(pFullPath);
    ASSERT(pVolPrefix);
    ASSERT(pFullPath->Length >= pVolPrefix->Length);
    ASSERT(pInteresting);
 
    try
    {
        *pInteresting = FALSE;
    
        //
        // Take the blob lock so that other threads won't change 
        //
    
        SrAcquireBlobLockShared();

        if ( !global->BlobInfoLoaded ||
             !global->BlobInfo.LookupList ||
             !global->BlobInfo.LookupTree )
        {
            Status = SR_STATUS_VOLUME_DISABLED;
            leave;
        }
    
        ASSERT(global->BlobInfo.DefaultType != NODE_TYPE_UNKNOWN );
        
        //
        // allocate space for a parsed path
        //

        FileNameSize = CALC_PPATH_SIZE( pFullPath->Length/sizeof(WCHAR) );
        pFileName = ExAllocatePoolWithTag( PagedPool,
                                           FileNameSize,
                                           SR_FILENAME_BUFFER_TAG );
                                           
        if (NULL == pFileName)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
    
        //
        // parse the filename for lookup in the mem blob
        //
    
        fRet = ConvertToParsedPath(
                   pFullPath->Buffer,
                   pFullPath->Length/sizeof(WCHAR),
                   pFileName,
                   FileNameSize );
    
        if(fRet)
        {
            INT    iNode  = -1;
            INT    iType  = 0;
            INT    iLevel = 0;
            BOOL   fExactMatch = FALSE;
            BOOL   fMatch      = FALSE;
    
            //
            // Lookup the parsed path in the tree blob
            //
    
            fMatch = MatchPrefix( 
                         global->BlobInfo.LookupTree, 
                         TREE_ROOT_NODE, 
                         ((path_t)pFileName)->pp_elements, 
                         &iNode, 
                         &iLevel, 
                         &iType, 
                         NULL, 
                         &fExactMatch); 
            
            if (fMatch)
            {
                SrTrace(LOOKUP, 
                        ("Found match in pathtree N: %d L:%d T:%d\n",
                          iNode, iLevel, iType));
            }
    
            //
            // Lookup in __ALLVOLUMES__ to see is there is a match
            //
    
            if ( NODE_TYPE_UNKNOWN == iType ||   
                 (!fExactMatch && NODE_TYPE_EXCLUDE != iType )       
               )                                      
            {
                PBYTE  pRelFileName   = NULL;
                INT    RelFileNameLen = 0;
    
                //
                // Lookup only volume relative filename
                //

                RelFileNameLen = sizeof(L'\\' ) +
                                 sizeof(ALLVOLUMES_PATH_W) +
                                 (pFullPath->Length - pVolPrefix->Length);

                pRelFileName = ExAllocatePoolWithTag( PagedPool,
                                                      RelFileNameLen,
                                                      SR_FILENAME_BUFFER_TAG );
                                                   
                if (NULL == pRelFileName)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }
    
                localName.Buffer = &pFullPath->Buffer[pVolPrefix->Length/sizeof(WCHAR)];
                localName.Length = pFullPath->Length - pVolPrefix->Length;
                localName.MaximumLength = localName.Length;

                RelFileNameLen = swprintf( 
                                    (LPWSTR)pRelFileName, 
                                    L"\\%s%wZ",
                                    ALLVOLUMES_PATH_W,
                                    &localName );

                fRet = ConvertToParsedPath(
                           (LPWSTR)pRelFileName,
                           (USHORT)RelFileNameLen,
                           pFileName,
                           FileNameSize );
    
                if(fRet)
                {
                    //
                    // Lookup the parsed path in the appropriate protion of 
                    // the tree blob NTROOT\\__ALLVOLUMES__
                    //
    
                    fMatch = MatchPrefix( 
                         global->BlobInfo.LookupTree, 
                         TREE_ROOT_NODE, 
                         ((path_t)pFileName)->pp_elements, 
                         &iNode, 
                         &iLevel, 
                         &iType, 
                         NULL, 
                         &fExactMatch); 
            
                    if (fMatch)
                    {
                        SrTrace(LOOKUP,
                                ("Found match in pathtree N: %d L:%d T:%d\n",
                                iNode, iLevel, iType));
                    }
                }
                else
                {
                    CHECK_STATUS( Status );
                }
    
                ExFreePoolWithTag( pRelFileName, SR_FILENAME_BUFFER_TAG );
                NULLPTR( pRelFileName );
            }
    
    
            if ( !IsDirectory )
            {
                //
                // If path didn't match or matched partially, we need to
                // lookup the extension list also
                //
        
                if ( NODE_TYPE_UNKNOWN == iType ||   
                     (!fExactMatch && NODE_TYPE_EXCLUDE != iType )       
                   )                                      
                {
                    BOOL fPathHasExt = FALSE;
        
                    fMatch = MatchExtension(
                                 global->BlobInfo.LookupList, 
                                 pFullPath, 
                                 &iType, 
                                 &fPathHasExt );
        
                    if ( !fMatch )
                    {
                        //
                        // Extension didn't match, setting to default type
                        //
        
                        iType = global->BlobInfo.DefaultType;
                    }
        
                    if ( !fPathHasExt )
                    {
                        //
                        // If path didn't contain an extension then 
                        // treat it as an exclude 
                        //
        
                        iType = NODE_TYPE_EXCLUDE;
                    }
                }
        
                //
                // If still type is unknown then set type to the default.
                //
        
                if ( NODE_TYPE_UNKNOWN == iType )
                {
                    iType = global->BlobInfo.DefaultType;
                }
            }
            else
            {
    
                //
                // If this is directory operation and no match found in 
                // tree then treat is as include.
                //
        
                if ( NODE_TYPE_UNKNOWN == iType )
                {
                    iType = NODE_TYPE_INCLUDE;
        
                }
            }
    
            *pInteresting = (iType != NODE_TYPE_EXCLUDE);
            Status = STATUS_SUCCESS;
        }
        else
        {
            SrTrace( LOOKUP,
                     ( "ConvertToParsedPath Failed : %wZ\n", pFullPath )
                   );
            CHECK_STATUS( Status );
        }
    
        // SrTrace(LOOKUP, ("Path Interest:%d\n", *pInteresting) );
    }
    finally
    {
        Status = FinallyUnwind(SrIsPathInteresting, Status);
        
        SrReleaseBlobLock();

        if (pFileName != NULL)
        {
            ExFreePoolWithTag( pFileName, SR_FILENAME_BUFFER_TAG );
            NULLPTR( pFileName );;
        }

        if (!NT_SUCCESS(Status))
        {
            *pInteresting = FALSE;
        }
    }

    RETURN(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for SR. It includes all other
    necessary header files for SR.

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000
    
Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

//
// System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

//
// include ntos.h instead of ntifs.h as the public headers don't
// let you include multiple headers (like ntifs + ntobapi) .
// we need to use public structures from both headers so need a global header
// that actually works
//

//#define _NTIFS_     //needed to tell NTOS we are not in the OS.

//#include <ntos.h>
//#include <zwapi.h>
         
#include <ntifs.h>
#include <stdio.h>
#include <mountmgr.h>   // MountManager (for getting volume guids)
//#include <ntrtl.h>

//
// BUGBUG: stolen from io.h until nt6 adds proper fastio hooking for 
// createsection.  paulmcd (5/2000)
//

#ifdef _NTOS_
// from ntifs.h (her manually because i have to include ntos.h for now)
typedef struct _FSRTL_COMMON_FCB_HEADER {
    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;
    UCHAR Flags;
    UCHAR IsFastIoPossible; // really type FAST_IO_POSSIBLE
    UCHAR Flags2;
    UCHAR Reserved;
    PERESOURCE Resource;
    PERESOURCE PagingIoResource;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER ValidDataLength;
} FSRTL_COMMON_FCB_HEADER, *PFSRTL_COMMON_FCB_HEADER;
#endif  //_NTOS_

//
// needed for srapi.h (but never used by the driver)
//

typedef PVOID LPOVERLAPPED;
#define WINAPI __stdcall

//
// need this macro to disappear in order to use FileDispositionInformation
//

#undef DeleteFile

#ifdef __cplusplus
}
#endif

//
// Force the memxxx() functions to be intrinsics so we can build
// the driver even if MSC_OPTIMIZATION=/Od is specified. This is
// necessary because the memxxx() functions are not exported by
// NTOSKRNL.
//

#pragma intrinsic( memcmp, memcpy, memset, strcmp )


//
// Project include files.
//

#include "srapi.h"
#include "hash.h"

#include "windef.h"
#include "common.h"
#include "blob.h"
#include "pathtree.h"
#include "hashlist.h"
#include "lookup.h"

#include "srpriv.h"
#include "srlog.h"
#include "srio.h"
#include "control.h"
#include "fastio.h"
#include "dispatch.h"
#include "event.h"
#include "notify.h"
#include "filelist.h"
#include "copyfile.h"
#include "config.h"
#include "lock.h"
#include "context.h"
#include "filenames.h"
#include "stats.h"

#include <srmsg.h>

BOOL SrVerifyBlob(PBYTE Blob);

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\ptree.c ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    pathtree.c
 *
 *  Abstract:
 *    This file contains the implementation for pathtree.
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#include "precomp.h"
#include "pathtree.h"
#include "hashlist.h"

#ifndef RING3

//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, ConvertToParsedPath )
#pragma alloc_text( PAGE, MatchPrefix         )

#endif  // ALLOC_PRAGMA

#endif

static WCHAR g_bWildCardNode[2] = { 4, L'*' };

//
// Converts a Wide Char String to Parsed Path
//
//  This routine expects the path to be in the format:
//      \[full path]
//     Note: There should be no trailing '\' on directory names.
//

BOOL
ConvertToParsedPath(
    LPWSTR  lpszPath,   
    WORD    nPathLen,
    PBYTE   pPathBuf,
    WORD    nBufSize
)
{
    BOOL    fRet      = FALSE;
    WORD    nLen      = 0;
    WORD    nChars    = 0;
    WORD    nPrefix   = 0;
    WCHAR   *pWStr    = NULL;
    WCHAR   *pWBuf    = NULL;
    WCHAR   *peLength = NULL;
    BYTE    *pElem    = NULL;

    if(NULL == lpszPath)
    {
#ifndef RING3
        SrTrace( LOOKUP, ("lpszPath is null\n")) ;
#endif
        goto done;
    }

    if(NULL == pPathBuf)
    {
#ifndef RING3
        SrTrace( LOOKUP, ("pPathBuf is null\n")) ;
#endif
        goto done;
    }

    nLen  = nPathLen;
    pWStr = lpszPath;

    if( nLen &&  nBufSize < CALC_PPATH_SIZE(nLen) )
    {
#ifndef RING3
        SrTrace( LOOKUP, ("Passed in buffer is too small\n")) ;
#endif
        goto done;
    }

    memset( pPathBuf, 0, nBufSize );

    pWStr = lpszPath;

    //
    // Skip the leading '\'
    //

    while( *pWStr == L'\\' ) 
    {
        pWStr++;
        nLen--;
    }

    //
    // Parse and convert to PPATH
    //

    pWBuf    = (PWCHAR)(pPathBuf + 2*sizeof(WCHAR));
    nChars   = 0;
    nPrefix  = 2 * sizeof(WCHAR); 
    peLength = pWBuf;

    *peLength = 0;
    pWBuf++;

    while( nLen )
    {
        if ( *pWStr == L'\\' )
        {
            //
            // Set pe_length
            //

            *peLength = (nChars+1)*sizeof(WCHAR);

            //
            // update PrefixLength
            //

            nPrefix += (*peLength);

            peLength = pWBuf;
            nChars = 0;

            if (nPrefix >= nBufSize)
            {
#ifndef RING3
                SrTrace( LOOKUP, ("Passed in buffer is too small - 2\n")) ;
#endif
                fRet = FALSE;
                goto done;
            }
        }
        else
        {
            nChars++;

#ifdef RING3
            *pWBuf = (WCHAR)CharUpperW((PWCHAR)(*pWStr));
#else
            *pWBuf = RtlUpcaseUnicodeChar(*pWStr);
#endif
        }

        pWStr++;
        pWBuf++;
        nLen--;
    }

    //
    //  When we terminate the above loop, the peLength for the final portion of 
    //  the name will not have been set, but peLength will be pointing to the
    //  correct location for this sections length.  Go ahead and set it now.
    //

    *peLength = (nChars+1)*sizeof(WCHAR);

    //
    // Set PrefixLength
    //

    ( (ParsedPath *)pPathBuf )->pp_prefixLength = nPrefix;

    //
    // Set TotalLength
    //

    ( (ParsedPath *)pPathBuf )->pp_totalLength = nPrefix + (*peLength);

    //
    // Set the last WORD to 0x00
    //

    *( (PWCHAR)((PBYTE)pPathBuf + nPrefix + (*peLength)) ) = 0;

    fRet = TRUE;

done:

    return fRet;
}

//
// MatchPrefix : Matches Parsed Path Elements with the given tree.
//

BOOL 
MatchPrefix(
    BYTE * pTree,                  // Pointer to the tree blob
    INT    iFather,                // Parent/Starting Node
    struct PathElement * ppElem ,  // PathElement to match
    INT  * pNode,                  // Matched node return
    INT  * pLevel,                 // Level of matching
    INT  * pType,                  // Node type : Incl/Excl/Sfp
    BOOL * pfProtected,            // Protection flag
    BOOL * pfExactMatch            // TRUE : if the path matched exactly
    )
{
    TreeNode * node;
    BOOL fRet = FALSE;

    if( pLevel )
        (*pLevel)++;

    if( ppElem->pe_length )
    {
        INT  iNode = 0;
        INT  iWildCardNode = 0;

        iNode = TREE_NODEPTR(pTree, iFather)->m_iSon;

        //
        // Start by looking at the children of the passed in father
        //

        while( iNode )  
        {
            node = TREE_NODEPTR(pTree,iNode);

            //
            // if we encounter a wildcar node, make a note of it
            //

            if (RtlCompareMemory(g_bWildCardNode, 
                       pTree + node->m_dwData, 
                       ((PathElement *)g_bWildCardNode)->pe_length) == 
                ((PathElement *)g_bWildCardNode)->pe_length)
            {
                iWildCardNode = iNode;
            }

            //
            // compare the node contents
            //

            if (RtlCompareMemory(ppElem, 
                                 pTree + node->m_dwData, 
                                 ppElem->pe_length) == 
                ppElem->pe_length )
            {
                break;
            }

            iNode = node->m_iSibling;
        }

        //
        // Note: Wildcard processing
        // incase we don't have a complete node match, use   the 
        // wildcard node if one was found above unless we are at
        // last element in  the path, in which case we   need to 
        // lookup hashlist first before doing the wildcard match 
        //

        if ( iNode == 0 &&
             iWildCardNode != 0 && 
             IFSNextElement(ppElem)->pe_length != 0 )
        {
             iNode = iWildCardNode;
        }

        //
        // Check for lower levels or file children
        //

        if( iNode != 0 )
        {   
            //
            // Since we have found a matching node with non default type
            // we need to set the pType to this node type. This is required
            // to enforce the parent's type on the children nodes, except 
            // in the case of SFP type. SFP type is marked on a directory
            // to specify there are SFP files in that directory
            // 

            if ( ( NODE_TYPE_UNKNOWN != node->m_dwType ) )
            {
                *pType = node->m_dwType;
            }

            //
            // if the node is disabled then abort any furthur seach and
            // return NODE_TYPE_EXCLUDE from here
            //

            if ( node->m_dwFlags & TREEFLAGS_DISABLE_SUBTREE ) 
            {
                *pType = NODE_TYPE_EXCLUDE;
                *pNode = iNode;
                fRet   = TRUE;
                goto Exit;
            }

            //
            // Return from here to preserve the level
            //

            fRet = MatchPrefix(
                      pTree, 
                      iNode, 
                      IFSNextElement(ppElem), 
                      pNode, 
                      pLevel, 
                      pType,
                      pfProtected,
                      pfExactMatch);

            if (fRet)
            {
                goto Exit;
            }
        }
        else
        {
            TreeNode * pFatherNode;

            //
            // if this the last node check in the Hashlist of parent
            //

            if ( IFSNextElement(ppElem)->pe_length == 0 )
            {
                pFatherNode = TREE_NODEPTR(pTree,iFather);

                if ( pFatherNode->m_dwFileList &&  
                     MatchEntry( 
                         pTree + pFatherNode->m_dwFileList,
                         (LPWSTR)(ppElem->pe_unichars),       
                         (INT)(ppElem->pe_length - sizeof(USHORT)),
                         pType) 
                   )
                {
                    //
                    // Current Father node needs to be returned
                    //

                    *pfExactMatch = TRUE;
                    *pNode        = iFather;

                    fRet = TRUE;
                }
                else
                {
                    //
                    // So we have failed to match the hashlist, but
                    // we have encountered a wildcard node then  we 
                    // need to  return that node's  type as it will
                    // be the match in this case
                    //

                    if ( iWildCardNode != 0 )
                    {
                        node   = TREE_NODEPTR(pTree,iWildCardNode);
                        *pNode = iWildCardNode;
                        *pType = node->m_dwType;
                        fRet   = TRUE;
                    }
                    else
                    {
                        fRet = FALSE;
                    }
                }
            }
        }
    }
    else
    {
        *pfExactMatch = TRUE;
        *pNode        = iFather;
        fRet          = TRUE;
    }
    
    (*pLevel)--;

Exit:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\notify.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    notify.h

Abstract:

    contains prototypes for functions in notify.c

Author:

    Paul McDaniel (paulmcd)     01-March-2000

Revision History:

--*/


#ifndef _NOTIFY_H_
#define _NOTIFY_H_


NTSTATUS
SrWaitForNotificationIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrUpdateBytesWritten (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN ULONGLONG BytesWritten
    );

NTSTATUS
SrFireNotification (
    IN SR_NOTIFICATION_TYPE NotificationType,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN ULONG Context OPTIONAL
    );

NTSTATUS
SrNotifyVolumeError (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName OPTIONAL,
    IN NTSTATUS ErrorStatus,
    IN SR_EVENT_TYPE EventType OPTIONAL
    );

VOID
SrClearOutstandingNotifications (
    );

#endif // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\setinformation.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    setInformation.c

Abstract:

    this is the major function code dispatch filter layer.

Author:

    Neal Christiansen (nealch)     5-Feb-2001

Revision History:

--*/

#include "precomp.h"

//
//  Local prototypes
//

NTSTATUS
SrpSetRenameInfo(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

NTSTATUS
SrpSetLinkInfo(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

NTSTATUS
SrpReplacingDestinationFile (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pDestFileObject,
    IN PSR_STREAM_CONTEXT pDestFileContext
    );

VOID
SrpSetRenamingState(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_STREAM_CONTEXT pFileContext
    );

BOOLEAN
SrpCheckForSameFile (
    IN PFILE_OBJECT pFileObject1,
    IN PFILE_OBJECT pFileObject2
    );


//
//  Linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrSetInformation )
#pragma alloc_text( PAGE, SrpSetRenameInfo )
#pragma alloc_text( PAGE, SrpSetLinkInfo )
#pragma alloc_text( PAGE, SrpReplacingDestinationFile )
#pragma alloc_text( PAGE, SrpSetRenamingState )
#pragma alloc_text( PAGE, SrpCheckForSameFile )

#endif  // ALLOC_PRAGMA


/***************************************************************************++

Routine Description:

    Handle SetInformation IRPS

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION pExtension;
    PIO_STACK_LOCATION pIrpSp;
    NTSTATUS eventStatus;
    FILE_INFORMATION_CLASS FileInformationClass;

    PUNICODE_STRING pRenameNewDirectoryName = NULL;
    PSR_STREAM_CONTEXT pOrigFileContext = NULL;

    //
    // < dispatch!
    //

    PAGED_CODE();

    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our device (vs an attachee).
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to, grab our extension
    //
    
    ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
    pExtension = DeviceObject->DeviceExtension;

    //
    //  See if logging is enabled and we don't care about this type of IO
    //  to the file systems' control device objects.
    //

    if (!SR_LOGGING_ENABLED(pExtension) ||
        SR_IS_FS_CONTROL_DEVICE(pExtension))
    {
        goto SrSetInformation_Skip;
    }    

    //
    // Just pass through all paging IO.  We catch all write's prior to 
    // the cache manager even seeing them.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if (FlagOn(pIrp->Flags, IRP_PAGING_IO))
    {
        goto SrSetInformation_Skip;
    }

    //
    // Ignore files with no name
    //
    
    if (FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING( pIrpSp->FileObject ) ||
        FILE_OBJECT_DOES_NOT_HAVE_VPB( pIrpSp->FileObject ))
    {
        goto SrSetInformation_Skip;
    }

    //
    //  Handle the necessary event based on the FileInformationClass.
    //  Note that the FileLinkInformation and FileRenameInformation (when
    //  renaming a directory in some cases) require synchronization
    //  with a completion routine so that we can see the final status.
    //
    
    FileInformationClass = pIrpSp->Parameters.SetFile.FileInformationClass;

    switch (FileInformationClass)
    {
        case FileEndOfFileInformation: // SetEndOfFile
        case FileAllocationInformation:
        {
            PSR_STREAM_CONTEXT pFileContext;

            //
            //  Get the context now so we can determine if this is a
            //  directory or not
            //

            eventStatus = SrGetContext( pExtension,
                                        pIrpSp->FileObject,
                                        SrEventStreamChange,
                                        &pFileContext );

            if (!NT_SUCCESS( eventStatus ))
            {
                goto SrSetInformation_Skip;
            }

            //
            //  If this is a directory don't bother logging because the
            //  operation will fail.
            //

            if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && 
                !FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
            {
                SrHandleEvent( pExtension,
                               SrEventStreamChange, 
                               pIrpSp->FileObject,
                               pFileContext,
                               NULL, 
                               NULL );
            }

            //
            //  Release the context
            //

            SrReleaseContext( pFileContext );

            break;
        }

        case FileDispositionInformation: // DeleteFile - handled in MJ_CLEANUP
        case FilePositionInformation:   // SetFilePosition
    
            //
            // we can skip these
            //
        
            break;
        
        case FileBasicInformation:  // SetFileAttributes
        {
            PFILE_BASIC_INFORMATION pBasicInformation;
        
            //
            // ignore time changes.  for sure we need to ignore changes
            // to LastAccessTime updates.
            //
            // for now we only care about attrib changes (like adding hidden)
            //

            pBasicInformation = pIrp->AssociatedIrp.SystemBuffer;
        
            if ((pBasicInformation != NULL) &&
                (pIrpSp->Parameters.SetFile.Length >= 
                        sizeof(FILE_BASIC_INFORMATION)) &&
                (pBasicInformation->FileAttributes != 0))
            {
                //
                // Handle this event
                //

                SrHandleEvent( pExtension,
                               SrEventAttribChange, 
                               pIrpSp->FileObject,
                               NULL,
                               NULL,
                               NULL );
            }
            break;        
        }

        case FileRenameInformation: // Rename
        {
            PFILE_RENAME_INFORMATION pRenameInfo;

            //
            // Handle this event, SrHandleRename will check for eligibility
            //

            pRenameInfo = (PFILE_RENAME_INFORMATION)pIrp->AssociatedIrp.SystemBuffer;

            if ((pRenameInfo == NULL) ||
                (pIrpSp->Parameters.SetFile.Length < sizeof(FILE_RENAME_INFORMATION)) ||
                (pIrpSp->Parameters.SetFile.Length < 
                        (FIELD_OFFSET(FILE_RENAME_INFORMATION, FileName) + 
                        pRenameInfo->FileNameLength)) )
            {
                //
                //  We don't have valid rename information, so just skip this
                //  operation.
                //
            
                goto SrSetInformation_Skip;
            }

            return SrpSetRenameInfo( pExtension, pIrp );
        }

        case FileLinkInformation:   //Create HardLink
        {
            PFILE_LINK_INFORMATION pLinkInfo;

            //
            // Handle this event, SrHandleRename will check for eligibility
            //

            pLinkInfo = (PFILE_LINK_INFORMATION)pIrp->AssociatedIrp.SystemBuffer;

            if ((pLinkInfo == NULL) ||
                (pIrpSp->Parameters.SetFile.Length < sizeof(FILE_LINK_INFORMATION)) ||
                (pIrpSp->Parameters.SetFile.Length < 
                        FIELD_OFFSET(FILE_LINK_INFORMATION, FileName) + pLinkInfo->FileNameLength) )
            {
                //
                //  We don't have valid Link information, so just skip this
                //  operation.
                //
            
                goto SrSetInformation_Skip;
            }

            return SrpSetLinkInfo( pExtension, pIrp );
        }

        default:

            //
            //  Handle all other setInformation calls
            //

            SrHandleEvent( pExtension,
                           SrEventAttribChange, 
                           pIrpSp->FileObject,
                           NULL,
                           NULL,
                           NULL );
            break;        
    }

SrSetInformation_Skip:
    //
    //  We don't need to wait for this operation to complete, so just
    //  skip our stack location and pass this IO on to the next driver.
    //

    IoSkipCurrentIrpStackLocation( pIrp );
    return IoCallDriver( pExtension->pTargetDevice, pIrp );
}



/***************************************************************************++

Routine Description:

    This handles renames and is called from SrSetInformation.

    This bypasses the normal path of SrHandleEvent as work needs to be done
    even if the file is not interesting.  It's possible that the new name
    is an interesting name, which needs to be logged as a new create.  Plus
    it might be clobbering an interesting file, in which case we need to 
    backup that interesting file.

Arguments:

    pExtension - SR extension for this volume

    pIrp - the Irp for this operation

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpSetRenameInfo(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    NTSTATUS            eventStatus = STATUS_SUCCESS;
    NTSTATUS            IrpStatus;
    PFILE_OBJECT        pFileObject;
    PFILE_RENAME_INFORMATION pRenameInfo;
    PIO_STACK_LOCATION  pIrpSp;
    PUNICODE_STRING     pNewName = NULL;
    USHORT              NewNameStreamLength = 0;
    UNICODE_STRING      NameToOpen;
    PUNICODE_STRING     pDestFileName = NULL;
    PSR_STREAM_CONTEXT  pFileContext = NULL;
    PSR_STREAM_CONTEXT  pNewFileContext = NULL;
    HANDLE              newFileHandle = NULL;
    PFILE_OBJECT        pNewFileObject = NULL;
    ULONG               CreateOptions;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOLEAN             NewNameInteresting = FALSE;
    BOOLEAN             newNameIsDirectory;
    BOOLEAN             releaseLock = FALSE;
    BOOLEAN             setRenamingStateInFileContext = FALSE;
    BOOLEAN             doPostProcessing = FALSE;
    BOOLEAN             renamingSelf = FALSE;
    KEVENT              eventToWaitOn;
    PUNICODE_STRING     pShortName = NULL;
    UNICODE_STRING      shortName;
    WCHAR               shortNameBuffer[SR_SHORT_NAME_CHARS+1];
    BOOLEAN             optimizeDelete = FALSE;
    BOOLEAN             streamRename = FALSE;
    BOOLEAN             fileBackedUp = FALSE;
    BOOLEAN             exceedMaxPath = FALSE;
    //
    //  The following macro must be at the end of local declarations
    //  since it declares a variable only in DBG builds.
    //
    DECLARE_EXPECT_ERROR_FLAG(expectError);

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT( IS_VALID_IRP( pIrp ) );

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    pFileObject = pIrpSp->FileObject;
    pRenameInfo = pIrp->AssociatedIrp.SystemBuffer;

    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));

    //
    //  Initalize return values
    //
    
    try
    {
        //
        // does the caller have DELETE access (it's required).
        //

        if (pFileObject->DeleteAccess == 0)
            leave;

        //
        // should we short circuit out of here for testing mode?
        //

        if (global->DontBackup)
            leave;

        //
        //  Get the context for the current file
        //

        eventStatus = SrGetContext( pExtension,
                                    pFileObject,
                                    SrEventFileRename,
                                    &pFileContext );

        if (!NT_SUCCESS( eventStatus ))
            leave;

        // 
        //  If this is not a directory then see if the extension is
        //  interesting.
        //

        if (!FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
        {
            UNICODE_STRING destName;

            destName.Buffer = pRenameInfo->FileName;
            destName.Length = (USHORT)pRenameInfo->FileNameLength;
            destName.MaximumLength = (USHORT)pRenameInfo->FileNameLength;

            //
            //  First check to see if this is a stream name change.  If so,
            //  we determine the "interesting-ness" of the new name from 
            //  the "interesting-ness" of the current name.
            //

            if ((destName.Length > 0) &&
                (destName.Buffer[0] == L':'))
            {
                //
                //  This is a stream rename, so the "interesting-ness" of the
                //  new name is the same as the "interesting-ness" of the old
                //  name, since "interesting-ness" is determined by the file
                //  name with out the stream component.
                //

                NewNameInteresting = BooleanFlagOn( pFileContext->Flags,
                                                    CTXFL_IsInteresting );
                streamRename = TRUE;
            }
            else
            {
                //
                //  This is not a stream name change, so see if this new name
                //  has an interesting extension.
                //
                
                eventStatus = SrIsExtInteresting( &destName, 
                                                  &NewNameInteresting );

                if (!NT_SUCCESS( eventStatus ))
                    leave;
            }
        }
        else
        {
            //
            //  all directories are interesting unless explicitly excluded.
            //

            NewNameInteresting = TRUE;
        }

        //
        //  If both are not interesting, ignore it.  we make this check
        //  twice in this routine.  Once here to weed out any non-interesting
        //  events, and another after checking path exclusions, because some
        //  that was potentially interesting could have just become non 
        //  interesting.  This let's us get out quicker for non interesting
        //  renames.
        //

        if (!FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && !NewNameInteresting)
        {
            //
            //  Neither the file we are renaming or the new name are
            //  interesting.  But we still need to cleanup the context
            //  because it may be renamed to something interesting in
            //  the future.
            //

            SrpSetRenamingState( pExtension, 
                                 pFileContext );
            setRenamingStateInFileContext = TRUE;
            leave;
        }

        //
        // check the path exclusions
        //
    
        //
        //  Get the full path for the target.  Note that we will translate
        //  reasonable errors to status success and return.  This way we
        //  will not log the event because we know the real operation should
        //  fail.
        //
    
        {
            BOOLEAN reasonableErrorInDestPath = FALSE;

            eventStatus = SrpExpandDestPath( pExtension,
                                             pRenameInfo->RootDirectory,
                                             pRenameInfo->FileNameLength,
                                             pRenameInfo->FileName,
                                             pFileContext, 
                                             pFileObject,
                                             &pNewName,
                                             &NewNameStreamLength,
                                             &reasonableErrorInDestPath );
                                           
            if (!NT_SUCCESS_NO_DBGBREAK( eventStatus ))
            {
                if (reasonableErrorInDestPath)
                {
                    SET_EXPECT_ERROR_FLAG( expectError );
                    eventStatus = STATUS_SUCCESS;
                }
                leave;
            }
        }

        ASSERT(pNewName != NULL);

        //
        //  We now have the full destination name (whew!)
        //

        //
        //  Check to see if the target for the rename is longer than
        //  SR_MAX_FILENAME_LENGTH.  If it is, we will treat the target name as 
        //  uninteresting.
        //

        if (!IS_FILENAME_VALID_LENGTH( pExtension, 
                                       pNewName, 
                                       NewNameStreamLength ))
        {
            NewNameInteresting = FALSE;
            exceedMaxPath = TRUE;
            
            if (!FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && !NewNameInteresting)
            {
                //
                //  Neither the file we are renaming or the new name are
                //  interesting.  But we still need to cleanup the context
                //  because it may be renamed to something interesting in
                //  the future.
                //

                SrpSetRenamingState( pExtension, 
                                     pFileContext );
                setRenamingStateInFileContext = TRUE;
                leave;
            }
        }
        
        //
        //  We only need to do the following sets of checks if this is not
        //  a stream rename.
        //

        if (!streamRename && !exceedMaxPath)
        {
            //
            //  See if we are still on the same volume
            //

            if (!RtlPrefixUnicodeString( pExtension->pNtVolumeName,
                                         pNewName,
                                         TRUE ))
            {
                //
                //  We are not on the same volume.  This is possible if they used
                //  some sort of symbolic link that was not understood.  For the
                //  most part these can be ignored, this is not a win32 client.
                //  CODEWORK:paulmcd: we could expand the sym links ourselves
                //

                ASSERT(!"SR: Figure out how rename switched volumes unexpectedly!");
                SrTrace( NOTIFY, ("sr!SrHandleRename: ignoring rename to %wZ, used symlink\n", 
                         pNewName ));
                SET_EXPECT_ERROR_FLAG( expectError );
                leave;
            }
        
            //
            //  Now see if the new path is interesting.
            // 

            eventStatus = SrIsPathInteresting( pNewName, 
                                               pExtension->pNtVolumeName,
                                               BooleanFlagOn(pFileContext->Flags,CTXFL_IsDirectory),
                                               &NewNameInteresting );

            if (!NT_SUCCESS( eventStatus ))
                leave;

            //
            // if both are not interesting, ignore it
            //

            if (!FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && !NewNameInteresting)
            {
                //
                //  Neither the file we are renaming or the new name are
                //  interesting.  But we still need to cleanup the context
                //  because it may be renamed to something interesting in
                //  the future.
                //

                SrpSetRenamingState( pExtension, 
                                     pFileContext );
                setRenamingStateInFileContext = TRUE;
                leave;
            }
        }

        /////////////////////////////////////////////////////////////////////
        //
        //  See if destination file exists
        //
        /////////////////////////////////////////////////////////////////////

        //
        //  Always open the destination file to see if it is there, even if
        //  it is not interesting.  We do this because we need a resonable
        //  guess if the operation is going to fail or succeed so we don't
        //  log the wrong information.
        //
        //  If we've got a stream open, we need to play some tricks to get the
        //  stream component exposed in the file name.
        //

        if (streamRename)
        {
            NameToOpen.Length = pNewName->Length + NewNameStreamLength;
        }
        else
        {
            NameToOpen.Length = pNewName->Length;
        }
        NameToOpen.MaximumLength = pNewName->MaximumLength;
        NameToOpen.Buffer = pNewName->Buffer;
        
        InitializeObjectAttributes( &ObjectAttributes,
                                    &NameToOpen,
                                    (OBJ_KERNEL_HANDLE |            // don't let usermode trash myhandle
                                        OBJ_FORCE_ACCESS_CHECK),    // force ACL checking
                                    NULL,
                                    NULL );

        //
        // start out assuming the dest file is a directory if the source 
        // file is one then set the desired create options
        //

        newNameIsDirectory = BooleanFlagOn(pFileContext->Flags,CTXFL_IsDirectory);
        CreateOptions = (newNameIsDirectory ? FILE_DIRECTORY_FILE : 0);

RetryOpenExisting:

        eventStatus = SrIoCreateFile( &newFileHandle,
                                      DELETE,
                                      &ObjectAttributes,
                                      &IoStatusBlock,
                                      NULL,                             // AllocationSize
                                      FILE_ATTRIBUTE_NORMAL,
                                      FILE_SHARE_READ|
                                            FILE_SHARE_WRITE|
                                            FILE_SHARE_DELETE,          // ShareAccess
                                      FILE_OPEN,                        // OPEN_EXISTING
                                      FILE_SYNCHRONOUS_IO_NONALERT |
                                            CreateOptions,
                                      NULL,
                                      0,                                // EaLength
                                      IO_IGNORE_SHARE_ACCESS_CHECK,
                                      pExtension->pTargetDevice );

        if (eventStatus == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // looks like there is no new file
            //

            eventStatus = STATUS_SUCCESS;
        }
        else if (eventStatus == STATUS_ACCESS_DENIED)
        {
            //
            //  We don't have permission to open this file with the
            //  permission necessary to replace the target file, so the
            //  caller's request should also fail.  We can stop our
            //  processing now and exit, but we don't need to disable the
            //  volume.
            //

            eventStatus = STATUS_SUCCESS;
            SET_EXPECT_ERROR_FLAG( expectError );
            leave;
        }
        else if (eventStatus == STATUS_NOT_A_DIRECTORY)
        {   
            //
            // are we renaming a directory to a file?  this is ok, but we need
            // to open the target as a file, not a directory
            //

            if (CreateOptions == 0)
            {
                //
                // we already tried the reopen, it didn't work, bad.
                //

                ASSERT(!"SR: This is an unexpected error, figure out how we got it!");
                leave;
            }
        
            CreateOptions = 0;
            newNameIsDirectory = FALSE;
            goto RetryOpenExisting;

            //
            // was there some other error ?
            //
    
        }
        else if (eventStatus == STATUS_SHARING_VIOLATION ||
                 !NT_SUCCESS( eventStatus ))
        {
            leave;
        }
        else
        {
            ASSERT(NT_SUCCESS(eventStatus));

            //
            // SUCCESS! the dest file already exists.. are we allowed to 
            // clobber it?
            //

            //
            // reference the file object
            //

            eventStatus = ObReferenceObjectByHandle( newFileHandle,
                                                     0,
                                                     *IoFileObjectType,
                                                     KernelMode,
                                                     &pNewFileObject,
                                                     NULL );

            if (!NT_SUCCESS( eventStatus ))
                leave;

            //
            //  See if we are renaming to our self. If so then don't log the 
            //  destination but do log the rename.
            //

            renamingSelf = SrpCheckForSameFile( pFileObject, 
                                                pNewFileObject );

            //
            //  We know the destination exists, see if we are allowed to clobber
            //  it.  If not and we are not renaming to our self then the operation
            //  will fail, don't bother handling it.
            //

            if (!pRenameInfo->ReplaceIfExists && !renamingSelf)
            {
                SET_EXPECT_ERROR_FLAG( expectError );
                leave;
            }

            //
            //  Note:  Directories cannot be renamed over other directories, 
            //  the file system doesn't allow it (unless they are being renamed
            //  over themselves). However, directories can 
            //  be renamed over other files.
            //
            //  Quit if renaming a directory over a different directory because
            //  we know that will fail.
            //

            if (FlagOn(pFileContext->Flags,CTXFL_IsDirectory) && 
                (newNameIsDirectory))
            {
#if DBG
                if (!renamingSelf)
                {
                    SET_EXPECT_ERROR_FLAG( expectError );
                }
#endif                
                
                leave;
            }

            //
            //  If the destination file is not our own file then handle
            //  creating a deletion event.
            //

            if (!renamingSelf)
            {
                //
                //  Get the context for the destination file.  We do this now
                //  so that we can mark that we are renaming this file.  This
                //  will cause anyone else who tries to access this file while
                //  the rename in progress to create a temporary context.
                //  We do this so there won't be any windows when someone
                //  tries to access the wrong file and gets the wrong state.
                //  NOTE: We do want to do this even for files which are NOT
                //        interesting so the context is updated correctly.
                //

                eventStatus = SrGetContext( pExtension,
                                            pNewFileObject,
                                            SrEventFileDelete|
                                                 SrEventNoOptimization|
                                                 SrEventSimulatedDelete,
                                            &pNewFileContext );

                if (!NT_SUCCESS( eventStatus ))
                    leave;

                //
                //  If we are renaming to a directory just leave because this
                //  will fail.  Release the context.
                //

                if (FlagOn(pNewFileContext->Flags,CTXFL_IsDirectory))
                {
                    ASSERT(!FlagOn(pFileContext->Flags,CTXFL_IsDirectory));
                    newNameIsDirectory = TRUE;

                    SrReleaseContext( pNewFileContext );
                    pNewFileContext = NULL;     //so we don't free it later
                    leave;
                }

                //
                //  The destination file exists and is interesting, log that we
                //  are delting it.
                //

                if (NewNameInteresting)
                {
                    //
                    //  Log that we are changing the destination file
                    //

                    eventStatus = SrpReplacingDestinationFile( 
                                            pExtension,
                                            pNewFileObject,
                                            pNewFileContext );

                    if (!NT_SUCCESS( eventStatus ))
                        leave;

                    fileBackedUp = TRUE;
                    
                    //
                    //  These names can be different because one could be a
                    //  short name and one could be a long name for the same
                    //  file.
                    //

//                  ASSERT((NULL == pNewFileContext) || 
//                           RtlEqualUnicodeString(pNewName,
//                                                 &pNewFileContext->FileName,
//                                                 TRUE));
                }
            }
        }

        //
        //  Whether the file existed or not, handle purging our logging state
        //

        if (NewNameInteresting)
        {
            //
            //  clear the backup history for this new file
            //

            if (newNameIsDirectory)
            {
                //
                // we need to clear all entries that prefix match this 
                // dest directory, so that they now have new histories as 
                // they are potentially new files.
                //

                HashProcessEntries( pExtension->pBackupHistory, 
                                    SrResetHistory,
                                    pNewName );
            }
            else
            {
                //
                // its a simple file, clear the single entry
                //
    
                eventStatus = SrResetBackupHistory( pExtension, 
                                                    pNewName,
                                                    NewNameStreamLength,
                                                    SrEventInvalid );
                if (!NT_SUCCESS( eventStatus ))
                    leave;
            }
        }

        //
        //  When we get here we think the operation will succeed.  Mark
        //  the contexts so we won't try to use them while we are in
        //  the middle of the rename
        //

        SrpSetRenamingState( pExtension, pFileContext );
        setRenamingStateInFileContext = TRUE;

        //
        //  At this point we think the rename will succeed and we care
        //  about it.

        //
        //  If this is a stream rename, see if we have already backed
        //  up the file.  If not, we need to do that backup now.
        //
        //  We don't just log renames of stream renames because Win32 doesn't
        //  support renaming streams.  Therefore, it is difficult for Restore
        //  do undo this rename.  Since stream rename occur infrequently, we
        //  just do a full backup here.  This also means that we don't need
        //  to do any work after the rename operation has completed.
        //

        if (streamRename && !fileBackedUp)
        {
            eventStatus = SrpReplacingDestinationFile( pExtension,
                                                       pFileObject, 
                                                       pFileContext );
            leave;
        }
        
        //
        //  Get the sort name of the source file so we can
        //  log it.
        //

        RtlInitEmptyUnicodeString( &shortName,
                                   shortNameBuffer,
                                   sizeof(shortNameBuffer) );

        eventStatus = SrGetShortFileName( pExtension,
                                          pFileObject,
                                          &shortName );

        if (STATUS_OBJECT_NAME_NOT_FOUND == eventStatus)
        {
            //
            //  This file doesn't have a short name, so just leave 
            //  pShortName equal to NULL.
            //

            eventStatus = STATUS_SUCCESS;
        } 
        else if (!NT_SUCCESS(eventStatus))
        {
            //
            //  We hit an unexpected error, so leave.
            //
            
            leave;
        }
        else
        {
            pShortName = &shortName;
        }

        //
        //  See if this a file or directory moving OUT of monitored space.
        //  If so we need to do some work before the file is moved.
        //  

        if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && !NewNameInteresting)
        {
            if (FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
            {
                //
                //  This is a directory, create delete events for all
                //  interesting files in the tree before it goes away because
                //  of the rename.
                //

                eventStatus = SrHandleDirectoryRename( pExtension, 
                                                       &pFileContext->FileName, 
                                                       TRUE );
                if (!NT_SUCCESS( eventStatus ))
                    leave;
            }
            else
            {
                UNICODE_STRING volRestoreLoc;
                UNICODE_STRING destName;

                //
                //  It's a file moving out of monitored space, back it up
                //  before the rename.
                //
                //  Make sure we aren't renaming it into our special store, we
                //  want to ignore those operations.  Get the store name.
                //

                RtlInitUnicodeString( &volRestoreLoc, GENERAL_RESTORE_LOCATION);

                //
                //  Get the destination name with the volume name stripped off
                //  the front (Since we know we are on the same volume).
                //

                ASSERT(pNewName->Length >= pExtension->pNtVolumeName->Length);
                destName.Buffer = &pNewName->Buffer[
                                        pExtension->pNtVolumeName->Length / 
                                        sizeof(WCHAR) ];
                destName.Length = pNewName->Length - 
                                  pExtension->pNtVolumeName->Length;
                destName.MaximumLength = destName.Length;

                if (RtlPrefixUnicodeString( &volRestoreLoc,
                                            &destName,
                                            TRUE ))
                {
                    //
                    // it is going to our store. skip it
                    //
                
                    leave;
                }

                eventStatus = SrHandleFileRenameOutOfMonitoredSpace( 
                                        pExtension,
                                        pFileObject,
                                        pFileContext,
                                        &optimizeDelete,
                                        &pDestFileName );

                if (!NT_SUCCESS( eventStatus ))
                {
                    leave;
                }

#if DBG
                if (optimizeDelete)
                {
                    ASSERT( pDestFileName == NULL );
                }
                else
                {
                    ASSERT( pDestFileName != NULL );
                }
#endif
            }
        }

        //
        //  Mark that we want to do post-operation processing
        //

        doPostProcessing = TRUE;
    }
    finally
    {
        //
        //  If the destination file is open, close it now (so we can do the rename)
        //

        if (pNewFileObject != NULL)
        {
            ObDereferenceObject(pNewFileObject);
            NULLPTR(pNewFileObject);
        }

        if (newFileHandle != NULL)
        {
            ZwClose(newFileHandle);
            NULLPTR(newFileHandle);
        }
    }

    /////////////////////////////////////////////////////////////////////
    //
    //  Send the operation to the file system 
    //
    /////////////////////////////////////////////////////////////////////

    //
    //  Setup to wait for the operation to complete
    //

    KeInitializeEvent( &eventToWaitOn, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext( pIrp );
    IoSetCompletionRoutine( pIrp, 
                            SrStopProcessingCompletion, 
                            &eventToWaitOn, 
                            TRUE, 
                            TRUE, 
                            TRUE );

	IrpStatus = IoCallDriver(pExtension->pTargetDevice, pIrp);

    if (STATUS_PENDING == IrpStatus)
    {
        NTSTATUS localStatus;
        localStatus = KeWaitForSingleObject( &eventToWaitOn, 
                                             Executive,
                                             KernelMode,
                                             FALSE,
                                             NULL );
        ASSERT(STATUS_SUCCESS == localStatus);
    }

    //
    //  The operation has completed, get the final status from the Irp.
    //

    IrpStatus = pIrp->IoStatus.Status;

    //
    //  We are done with the Irp, so complete it now.
    //
    
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    try
    {
        //
        //  In DBG builds, this will verify that the operation failed with the
        //  file system when we expected it to.  Otherwise, it will assert so
        //  we can debug why we missed this case.
        //
        
        CHECK_FOR_EXPECTED_ERROR( expectError, IrpStatus );
        
        //
        //  leave if:
        //  - the rename failed
        //  - we got an error eariler in setting up for the rename
        //  - they tolds us to not continue processing
        //

        if (!NT_SUCCESS_NO_DBGBREAK( IrpStatus ) ||
            !NT_SUCCESS_NO_DBGBREAK( eventStatus ) ||
            !doPostProcessing)
        {
            leave;
        }

        ASSERT(pFileContext != NULL);

        /////////////////////////////////////////////////////////////////////
        //
        //  LOG EVENTS FOR ORIGINAL FILE
        //
        /////////////////////////////////////////////////////////////////////

        //
        //  We are now going to log the rename, grab the activity lock
        //

        SrAcquireActivityLockShared( pExtension );
        releaseLock = TRUE;

        //
        // Now that we have the shared activity lock, check that the volume
        // hasn't been disable before we do unnecessary work.
        //

        if (!SR_LOGGING_ENABLED(pExtension))
            leave;

        //
        // is this the first interesting event on this volume?
        //

        eventStatus = SrCheckVolume( pExtension, FALSE );

        if (!NT_SUCCESS( eventStatus ))
            leave;

        //
        //  Log the correct state
        //

        if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && NewNameInteresting)
        {
            //
            //  Both files are interesting, log the rename
            //

#if DBG
            if (pShortName != NULL )
            {
                ASSERT(shortName.Length > 0 && shortName.Length <= (12*sizeof(WCHAR)));
            }
#endif            

            SrLogEvent( pExtension,
                        ((FlagOn(pFileContext->Flags,CTXFL_IsDirectory)) ?
                            SrEventDirectoryRename :
                            SrEventFileRename),
                        pFileObject,
                        &pFileContext->FileName,
                        pFileContext->StreamNameLength,
                        NULL,
                        pNewName,
                        NewNameStreamLength,
                        pShortName );
        }
        else if (FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
        {
            if (!FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && 
                NewNameInteresting)
            {
                //
                //  The rename on the directory succeeded and the directory was
                //  renamed INTO monitored space.  We need to log creates for all
                //  the children of this directory.
                //

                eventStatus = SrHandleDirectoryRename( pExtension, 
                                                       pNewName, 
                                                       FALSE );
                if (!NT_SUCCESS( eventStatus ))
                    leave;
            }
            //
            //  We logged all of the directory operations before it occured
            //  for the case of moving a directory OUT of monitored space
            //
        }
        else if (FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && !NewNameInteresting)
        {
            ASSERT(!FlagOn(pFileContext->Flags,CTXFL_IsDirectory));

            //
            //  Since the "interesting-ness" of a file is determined at the 
            //  file level, a stream rename should never get down this path.
            //
            
            ASSERT( pFileContext->StreamNameLength == 0);

            //
            //  Log this as a delete (we backed up the file before the 
            //  rename occured).
            //

            if (optimizeDelete)
            {
                //
                //  This file was either created during this restore point or
                //  has already been backed up, therefore, we want to log the
                //  a delete that has been optimized out.
                //
                
                eventStatus = SrLogEvent( pExtension,
                                          SrEventFileDelete,
                                          NULL,
                                          &pFileContext->FileName,
                                          0,
                                          NULL,
                                          NULL,
                                          0,
                                          NULL );
            }
            else
            {
                eventStatus = SrLogEvent( pExtension,
                                          SrEventFileDelete,
                                          pFileObject,
                                          &pFileContext->FileName,
                                          0,
                                          pDestFileName,
                                          NULL,
                                          0,
                                          &shortName );
            }

            if (!NT_SUCCESS( eventStatus ))
                leave;
        }
        else if (!FlagOn(pFileContext->Flags,CTXFL_IsInteresting) && NewNameInteresting)
        {
            ASSERT(!FlagOn(pFileContext->Flags,CTXFL_IsDirectory));

            //
            //  Since the "interesting-ness" of a file is determined at the 
            //  file level, a stream rename should never get down this path.
            //
            
            ASSERT( NewNameStreamLength == 0);

            //
            //  it's a file being brought into monitored space, log it
            //
            
            eventStatus = SrLogEvent( pExtension,
                                      SrEventFileCreate,
                                      NULL,      // pFileObject
                                      pNewName,
                                      0,
                                      NULL,
                                      NULL,
                                      0,
                                      NULL );

            if (!NT_SUCCESS( eventStatus ))
                leave;

            //
            // ignore later mods
            //

            eventStatus = SrMarkFileBackedUp( pExtension,
                                              pNewName,
                                              0,
                                              SrEventFileCreate,
                                              SR_IGNORABLE_EVENT_TYPES );
                                         
            if (!NT_SUCCESS( eventStatus ))
                leave;
        }
    }
    finally
    {
        //
        // Check for any bad errors if this operation succeeded;
        // If the pFileContext is NULL, this error was encountered in 
        // SrGetContext which already generated the volume error.
        //

        if (NT_SUCCESS_NO_DBGBREAK( IrpStatus ) &&
            CHECK_FOR_VOLUME_ERROR(eventStatus) && 
            (pFileContext != NULL))
        {
            //
            // trigger the failure notification to the service
            //

            SrNotifyVolumeError( pExtension,
                                 &pFileContext->FileName,
                                 eventStatus,
                                 FlagOn(pFileContext->Flags,CTXFL_IsDirectory) ? 
                                    SrEventDirectoryRename:
                                    SrEventFileRename );
        }

        if (releaseLock)
        {
            SrReleaseActivityLock( pExtension );
        }

        if (NULL != pNewName)
        {
            SrFreeFileNameBuffer(pNewName);
            NULLPTR(pNewName);
        }

        if (NULL != pDestFileName)
        {
            SrFreeFileNameBuffer(pDestFileName);
            NULLPTR(pDestFileName);
        }

        //
        //  Cleanup contexts from rename state
        //

        if (pFileContext != NULL)
        {
            if (setRenamingStateInFileContext)
            {
                if (FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
                {
                    ASSERT(pExtension->ContextCtrl.AllContextsTemporary > 0);
                    InterlockedDecrement( &pExtension->ContextCtrl.AllContextsTemporary );
                    ASSERT(!FlagOn(pFileContext->Flags,CTXFL_DoNotUse));
                } 
                else
                {
                    ASSERT(FlagOn(pFileContext->Flags,CTXFL_DoNotUse));
                }
                SrDeleteContext( pExtension, pFileContext );
            }
            else
            {
                ASSERT(!FlagOn(pFileContext->Flags,CTXFL_DoNotUse));
            }

            SrReleaseContext( pFileContext );
            NULLPTR(pFileContext);
        }

        if (pNewFileContext != NULL)
        {
            ASSERT(!FlagOn(pNewFileContext->Flags,CTXFL_IsDirectory));
            SrReleaseContext( pNewFileContext );
            NULLPTR(pNewFileContext);
        }
    }

    return IrpStatus;
}

/***************************************************************************++

Routine Description:

    This handles the creation of hardlinks and is called from SrSetInformation.

    This bypasses the normal path of SrHandleEvent to handle the following
    cases:
     - If an interesting file is going to be overwritten as the result of this
     hardlink being created, we must backup the original file.
     - If a hardlink with an interesting name is being created, we need to log
     this file creation.

Arguments:

    pExtension - the SR device extension for this volume.

    pIrp - the Irp representing this SetLinkInformation operation.
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpSetLinkInfo(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    )
{
    NTSTATUS EventStatus = STATUS_SUCCESS;
    NTSTATUS IrpStatus;
    PFILE_OBJECT pFileObject;
    PFILE_LINK_INFORMATION pLinkInfo;
    PIO_STACK_LOCATION pIrpSp;
    PUNICODE_STRING pLinkName = NULL;
    USHORT LinkNameStreamLength = 0;
    PSR_STREAM_CONTEXT pFileContext = NULL;
    PSR_STREAM_CONTEXT pLinkFileContext = NULL;
    HANDLE LinkFileHandle = NULL;
    PFILE_OBJECT pLinkFileObject = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN LinkNameInteresting = FALSE;
    BOOLEAN ReleaseLock = FALSE;
    BOOLEAN DoPostProcessing = FALSE;
    KEVENT EventToWaitOn;
    //
    //  The following macro must be at the end of local declarations
    //  since it declares a variable only in DBG builds.
    //
    DECLARE_EXPECT_ERROR_FLAG( ExpectError );

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT( IS_VALID_IRP( pIrp ) );

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    pFileObject = pIrpSp->FileObject;
    pLinkInfo = pIrp->AssociatedIrp.SystemBuffer;

    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));


    try
    {
        //
        // should we short circuit out of here for testing mode?
        //

        if (global->DontBackup)
            leave;

        //
        //  Get the context for the current file
        //

        EventStatus = SrGetContext( pExtension,
                                    pFileObject,
                                    SrEventFileCreate,
                                    &pFileContext );

        if (!NT_SUCCESS( EventStatus ))
            leave;

        // 
        //  If this is a directory, then we don't care about this operation
        //  since it is not possible to create hardlinks on directories.
        //

        if (FlagOn( pFileContext->Flags, CTXFL_IsDirectory ))
            leave;

        //
        //  We are creating a hardlink on this file.  While we do the processing
        //  mark this context as CTXFL_DoNotUse so that other users of this
        //  stream will be guaranteed to get correct information.
        //

        RtlInterlockedSetBitsDiscardReturn(&pFileContext->Flags,CTXFL_DoNotUse);

        /////////////////////////////////////////////////////////////////////
        //
        //  Check to see if the hardlink name is interesting
        //
        /////////////////////////////////////////////////////////////////////

        {
            UNICODE_STRING destName;

            destName.Buffer = pLinkInfo->FileName;
            destName.Length = (USHORT)pLinkInfo->FileNameLength;
            destName.MaximumLength = (USHORT)pLinkInfo->FileNameLength;

            EventStatus = SrIsExtInteresting( &destName, 
                                              &LinkNameInteresting );

            if (!NT_SUCCESS( EventStatus ))
            {
                leave;
            }
        }

        //
        //  Get the full path for the hardlink name.  Note that we will 
        //  translate reasonable errors to status success and return.  This way 
        //  we will not log the event because we know the real operation should
        //  fail.
        //
    
        {
            BOOLEAN reasonableErrorInDestPath = FALSE;

            EventStatus = SrpExpandDestPath( pExtension,
                                             pLinkInfo->RootDirectory,
                                             pLinkInfo->FileNameLength,
                                             pLinkInfo->FileName,
                                             pFileContext, 
                                             pFileObject,
                                             &pLinkName,
                                             &LinkNameStreamLength,
                                             &reasonableErrorInDestPath );
                                           
            if (!NT_SUCCESS_NO_DBGBREAK( EventStatus ))
            {
                if (reasonableErrorInDestPath)
                {
                    SET_EXPECT_ERROR_FLAG( ExpectError );
                    EventStatus = STATUS_SUCCESS;
                }
                leave;
            }

            //
            //  We can't have a stream component in this name, so if we do have
            //  one, this is also a malformed link name.
            //

            if (LinkNameStreamLength > 0)
            {
                SET_EXPECT_ERROR_FLAG( ExpectError );
                EventStatus = STATUS_SUCCESS;
                leave;
            }
        }

        ASSERT(pLinkName != NULL);

        //
        //  We now have the full destination name (whew!)
        //  See if we are still on the same volume
        //

        if (!RtlPrefixUnicodeString( pExtension->pNtVolumeName,
                                     pLinkName,
                                     TRUE ))
        {
            //
            //  Hardlinks must be on the same volume so this operation will
            //  fail.
            //

            SET_EXPECT_ERROR_FLAG( ExpectError );
            leave;
        }

        //
        //  Make sure that the link name is not too long for us to monitor.
        //

        if (!IS_FILENAME_VALID_LENGTH( pExtension, pLinkName, 0 ))
        {
            //
            //  Link name is too long for us, so just leave now.
            //
            
            LinkNameInteresting = FALSE;
            leave;
        }
    
        //
        // Now see if the new path is interesting.
        // 

        EventStatus = SrIsPathInteresting( pLinkName, 
                                           pExtension->pNtVolumeName,
                                           FALSE,
                                           &LinkNameInteresting );

        if (!NT_SUCCESS( EventStatus ))
        {
            leave;
        }

        if (!LinkNameInteresting)
        {
            //
            //  The link name is not interesting so just cut out now.
            //
            
            leave;  
        }

        /////////////////////////////////////////////////////////////////////
        //
        //  See if hardlink file exists
        //
        /////////////////////////////////////////////////////////////////////

        //
        //  If the hardlink name exists, we may need to back it up before this
        //  operation gets down to the file system.
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    pLinkName,
                                    (OBJ_KERNEL_HANDLE |
                                     OBJ_FORCE_ACCESS_CHECK),    // force ACL checking
                                    NULL,
                                    NULL );

        EventStatus = SrIoCreateFile( &LinkFileHandle,
                                      SYNCHRONIZE,
                                      &ObjectAttributes,
                                      &IoStatusBlock,
                                      NULL,                             // AllocationSize
                                      FILE_ATTRIBUTE_NORMAL,
                                      FILE_SHARE_READ|
                                            FILE_SHARE_WRITE|
                                            FILE_SHARE_DELETE,          // ShareAccess
                                      FILE_OPEN,                        // OPEN_EXISTING
                                      FILE_SYNCHRONOUS_IO_NONALERT |
                                            FILE_NON_DIRECTORY_FILE,
                                      NULL,
                                      0,                                // EaLength
                                      IO_IGNORE_SHARE_ACCESS_CHECK,
                                      pExtension->pTargetDevice );

        if (EventStatus == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // looks like there is no new file
            //

            EventStatus = STATUS_SUCCESS;
        }
        else if (EventStatus == STATUS_ACCESS_DENIED)
        {
            //
            //  We don't have permission to open this file with the
            //  permission necessary to replace the target file, so the
            //  caller's request should also fail.  We can stop our
            //  processing now and exit, but we don't need to disable the
            //  volume.
            //

            SET_EXPECT_ERROR_FLAG( ExpectError );
            EventStatus = STATUS_SUCCESS;
            leave;
        }
        else if (EventStatus == STATUS_FILE_IS_A_DIRECTORY)
        {   
            //
            //  Does the hardlink name currently name a directory?  This is not
            //  allowed, so just ignore the operation since it will fail.
            //

            SET_EXPECT_ERROR_FLAG( ExpectError );
            EventStatus = STATUS_SUCCESS;
            leave;
        }
        else if (!NT_SUCCESS( EventStatus ))
        {
            //
            //  We hit an unexpected error and we will handle this error
            //  below.
            //
            
            leave;
        }
        else
        {
            BOOLEAN linkingToSelf;
            
            ASSERT(NT_SUCCESS(EventStatus));

            //
            // SUCCESS! the dest file already exists.. are we allowed to 
            // clobber it?
            //

            if (!pLinkInfo->ReplaceIfExists)
                leave;

            //
            //  We are allowed to overwrite the existing file, so now check
            //  to make sure that we aren't just recreating a hardlink that
            //  already exists.
            //
            
            EventStatus = ObReferenceObjectByHandle( LinkFileHandle,
                                                     0,
                                                     *IoFileObjectType,
                                                     KernelMode,
                                                     &pLinkFileObject,
                                                     NULL );

            if (!NT_SUCCESS( EventStatus ))
                leave;

            linkingToSelf = SrpCheckForSameFile( pFileObject, 
                                                 pLinkFileObject );

            //
            //  We only need to backup the hardlink file if we are not
            //  recreating a link to ourself.
            //

            if (!linkingToSelf)
            {
                //
                //  Get the context for the destination file.
                //

                EventStatus = SrGetContext( pExtension,
                                            pLinkFileObject,
                                            SrEventFileDelete|
                                                 SrEventNoOptimization|
                                                 SrEventSimulatedDelete,
                                            &pLinkFileContext );

                if (!NT_SUCCESS( EventStatus ))
                    leave;

                ASSERT(!FlagOn(pLinkFileContext->Flags,CTXFL_IsDirectory));
                ASSERT(FlagOn(pLinkFileContext->Flags,CTXFL_IsInteresting));
                
                //
                //  Log that we are changing the destination file
                //

                EventStatus = SrpReplacingDestinationFile( pExtension,
                                                           pLinkFileObject,
                                                           pLinkFileContext );

                if (!NT_SUCCESS( EventStatus ))
                    leave;
            }
            else
            {
                //
                //  We are just recreating an existing link to ourself.  There
                //  is no need to log this.
                //

                leave;
            }
        }

        //
        //  We have successfully gotten to this point, so we want to do 
        //  post-operation processing to log the link creation.
        //

        DoPostProcessing = TRUE;
    }
    finally
    {
        //
        //  If the destination file is open, close it now (so we can do the rename)
        //

        if (NULL != pLinkFileObject)
        {
            ObDereferenceObject(pLinkFileObject);
            NULLPTR(pLinkFileObject);
        }

        if (NULL != LinkFileHandle)
        {
            ZwClose(LinkFileHandle);
            NULLPTR(LinkFileHandle);
        }

        if (NULL != pLinkFileContext)
        {
            SrReleaseContext( pLinkFileContext );
            NULLPTR(pLinkFileContext);
        }
    }

    /////////////////////////////////////////////////////////////////////
    //
    //  Send the operation to the file system
    //
    /////////////////////////////////////////////////////////////////////


    //
    //  Setup to wait for the operation to complete.
    //

    KeInitializeEvent( &EventToWaitOn, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext( pIrp );
    IoSetCompletionRoutine( pIrp, 
                            SrStopProcessingCompletion, 
                            &EventToWaitOn, 
                            TRUE, 
                            TRUE, 
                            TRUE );

	IrpStatus = IoCallDriver(pExtension->pTargetDevice, pIrp);

    if (STATUS_PENDING == IrpStatus)
    {
        NTSTATUS localStatus;
        localStatus = KeWaitForSingleObject( &EventToWaitOn, 
                                             Executive,
                                             KernelMode,
                                             FALSE,
                                             NULL );
        ASSERT(STATUS_SUCCESS == localStatus);
    }

    //
    //  The operation has completed, get the final status from the Irp.
    //

    IrpStatus = pIrp->IoStatus.Status;

    //
    //  We are done with the Irp, so complete it now.
    //
    
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    try
    {
        //
        //  In DBG builds, this will verify that the operation failed with the
        //  file system when we expected it to.  Otherwise, it will assert so
        //  we can debug why we missed this case.
        //
        
        CHECK_FOR_EXPECTED_ERROR( ExpectError, IrpStatus );
        
        
        //
        //  leave if:
        //  - the link failed
        //  - we got an error eariler in setting up for the link
        //  - they tolds us to not continue processing
        //

        if (!NT_SUCCESS_NO_DBGBREAK( IrpStatus ) ||
            !NT_SUCCESS_NO_DBGBREAK( EventStatus ) ||
            !DoPostProcessing)
        {
            leave;
        }
        
        ASSERT(pLinkName != NULL);

        /////////////////////////////////////////////////////////////////////
        //
        //  Log the file creation for the hardlink file.
        //
        /////////////////////////////////////////////////////////////////////

        //
        //  Before we do the logging work, we need to grab the activity lock
        //

        SrAcquireActivityLockShared( pExtension );
        ReleaseLock = TRUE;

        //
        // Now that we have the shared activity lock, check that the volume
        // hasn't been disable before we do unnecessary work.
        //

        if (!SR_LOGGING_ENABLED(pExtension))
            leave;

        //
        // Is this the first interesting event on this volume?
        //

        EventStatus = SrCheckVolume( pExtension, FALSE );

        if (!NT_SUCCESS( EventStatus ))
            leave;

        //
        //  Log the file creation
        //

        EventStatus = SrLogEvent( pExtension,
                                  SrEventFileCreate,
                                  NULL,      // pFileObject
                                  pLinkName,
                                  0,
                                  NULL,
                                  NULL,
                                  0,
                                  NULL );

        if (!NT_SUCCESS( EventStatus ))
            leave;

        //
        // ignore later modifications
        //

        EventStatus = SrMarkFileBackedUp( pExtension,
                                          pLinkName,
                                          0,
                                          SrEventFileCreate,
                                          SR_IGNORABLE_EVENT_TYPES );
    }
    finally
    {
        //
        // Check for any bad errors if this operation was successful.
        //

        if (NT_SUCCESS_NO_DBGBREAK( IrpStatus ) &&
            CHECK_FOR_VOLUME_ERROR( EventStatus ))
        {
            //
            // trigger the failure notification to the service
            //

            SrNotifyVolumeError( pExtension,
                                 pLinkName,
                                 EventStatus,
                                 SrEventFileCreate );
        }

        if (ReleaseLock)
        {
            SrReleaseActivityLock( pExtension );
        }

        if (NULL != pLinkName)
        {
            SrFreeFileNameBuffer(pLinkName);
            NULLPTR(pLinkName);
        }

        if (NULL != pFileContext)
        {
            if (FlagOn(pFileContext->Flags,CTXFL_DoNotUse))
            {
                //
                //  We marked this context as DoNotUse, so we need to delete it from
                //  the lists now that we are done with it.
                //
                
                SrDeleteContext( pExtension, pFileContext );
            }
            SrReleaseContext( pFileContext );
            NULLPTR(pFileContext);
        }
    }

    return IrpStatus;
}

/***************************************************************************++

Routine Description:

    The destination file exists, log that it is being replaced.

Arguments:

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpReplacingDestinationFile (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pDestFileObject,
    IN PSR_STREAM_CONTEXT pDestFileContext
    )
{
    NTSTATUS status;

    try
    {
        //
        //  We are now going to log the destination file getting clobbered,
        //  grab the volume's activity lock now.
        //

        SrAcquireActivityLockShared( pExtension );

        //
        // Now that we have the shared activity lock, check that the volume
        // hasn't been disable before we do unnecessary work.
        //

        if (!SR_LOGGING_ENABLED(pExtension))
        {
            status = SR_STATUS_VOLUME_DISABLED;
            leave;
        }

        //
        // setup volume if we need to
        //

        status = SrCheckVolume( pExtension, FALSE );
        if (!NT_SUCCESS( status ))
            leave;

        //
        // now simulate a delete on the destination file
        //

        ASSERT(!FlagOn(pDestFileContext->Flags,CTXFL_IsDirectory));

        status = SrHandleEvent( pExtension,
                                SrEventFileDelete|
                                    SrEventNoOptimization|
                                    SrEventSimulatedDelete,
                                pDestFileObject,
                                pDestFileContext,
                                NULL,
                                NULL );

        if (!NT_SUCCESS( status ))
            leave;
    }
    finally
    {
        //
        //  Release the activity lock
        //

        SrReleaseActivityLock( pExtension );
    }

    return status;
}


/***************************************************************************++

Routine Description:

    Set correct state if we are renaming.  This would be:
    - If renaming a directory mark that ALL contexts become temporary.
      We do this because we don't track all the names for all of the
      contexts 

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
VOID
SrpSetRenamingState (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_STREAM_CONTEXT pFileContext
    )
{
    //
    //  Neither the file we are renaming or the new name are
    //  interesting.  But we still need to cleanup the context
    //  because it may be renamed to something interesting in
    //  the future.
    //

    if (FlagOn(pFileContext->Flags,CTXFL_IsDirectory))
    {
        //
        //  Since we don't save names for contexts that are not
        //  interesting, on directory renames we mark the device
        //  extension so that all contexts will become temporary
        //  and then we flush all existing contexts.  We clear this
        //  state during the post-setInformation to guarentee there
        //  is no window when we will get the wrong state.
        //

        InterlockedIncrement( &pExtension->ContextCtrl.AllContextsTemporary );

        SrDeleteAllContexts( pExtension );
    }
    else
    {
        //
        //  Mark that this context should not be used (because we are
        //  renaming it).  We will delete this context in the post-
        //  rename handling.
        //

        RtlInterlockedSetBitsDiscardReturn(&pFileContext->Flags,CTXFL_DoNotUse);
    }
}


/***************************************************************************++

Routine Description:

    This will determine if the two files represent the same stream of a file
    by comparing the FsContext of the file objects.

Arguments:

    pExtension - SR's device extension for this volume.
    pFileObject1 - The first file in the comparison
    pFileObject2 - The second file in the comparison
    retAreSame - Is set to TRUE if the two files are the same,
        FALSE otherwise.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
BOOLEAN
SrpCheckForSameFile (
    IN PFILE_OBJECT pFileObject1,
    IN PFILE_OBJECT pFileObject2
    )
{
    if (pFileObject1->FsContext == pFileObject2->FsContext)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\notify.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module contians the notification logic for sr

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000

Revision History:

--*/

#include "precomp.h"


//
// Private constants.
//

//
// Private types.
//

//
// Private prototypes.
//

PIRP
SrDequeueIrp (
    IN PSR_CONTROL_OBJECT pControlObject
    );

PSR_NOTIFICATION_RECORD
SrDequeueNotifyRecord (
    IN PSR_CONTROL_OBJECT pControlObject
    );

VOID
SrCopyRecordToIrp (
    IN PIRP pIrp,
    IN SR_NOTIFICATION_TYPE NotificationType,
    IN PUNICODE_STRING pVolumeName,
    IN ULONG Context
    );

VOID
SrCancelWaitForNotification (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
SrCancelWaitForNotificationWorker (
    IN PVOID pContext
    );

NTSTATUS
SrLogError (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    IN NTSTATUS ErrorStatus,
    IN SR_EVENT_TYPE EventType
    );

UCHAR
SrIrpCodeFromEventType (
    IN SR_EVENT_TYPE EventType
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrWaitForNotificationIoctl )
#pragma alloc_text( PAGE, SrCancelWaitForNotificationWorker )
#pragma alloc_text( PAGE, SrCopyRecordToIrp )
#pragma alloc_text( PAGE, SrDequeueIrp )
#pragma alloc_text( PAGE, SrDequeueNotifyRecord )
#pragma alloc_text( PAGE, SrFireNotification )
#pragma alloc_text( PAGE, SrUpdateBytesWritten )
#pragma alloc_text( PAGE, SrNotifyVolumeError )
#pragma alloc_text( PAGE, SrLogError )
#pragma alloc_text( PAGE, SrIrpCodeFromEventType )

#endif  // ALLOW_UNLOAD

#if 0
NOT PAGEABLE -- SrCancelWaitForNotification
#endif // 0


//
// Private globals.
//

//
// Public globals.
//

//
// Public functions.
//



/***************************************************************************++

Routine Description:

    This routine enables sending notifications to user mode

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrWaitForNotificationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PSR_CONTROL_OBJECT      pControlObject;
    PSR_NOTIFICATION_RECORD pRecord;

    //
    // Sanity check.
    //

    PAGED_CODE();

    SrTrace(FUNC_ENTRY, ("SR!SrWaitForNotificationIoctl\n"));

    //
    // grab the control object
    //

    pControlObject = (PSR_CONTROL_OBJECT)pIrpSp->FileObject->FsContext;

    //
    // make sure we really have one 
    //

    if (pIrpSp->FileObject->FsContext2 != SR_CONTROL_OBJECT_CONTEXT ||
        IS_VALID_CONTROL_OBJECT(pControlObject) == FALSE ||
        pIrp->MdlAddress == NULL)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // make sure the buffer is at least minimum size.  
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < 
            sizeof(SR_NOTIFICATION_RECORD))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Grab the lock
    //

    SrAcquireGlobalLockExclusive();

    //
    // Do we have a queue'd record ?
    //
    
    pRecord = SrDequeueNotifyRecord(pControlObject);
    if (pRecord == NULL)
    {
        SrTrace(NOTIFY, ("SR!SrWaitForNotificationIoctl - queue'ing IRP(%p)\n", pIrp));

        //
        // Nope, queue the irp up.
        //

        IoMarkIrpPending(pIrp);

        //
        // give the irp a pointer to the control object (add a refcount
        // as the cancel routine runs queued, and needs to access the 
        // control object - even if it's later deleted).
        //

        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pControlObject;
        SrReferenceControlObject(pControlObject);

        //
        // set to these to null just in case the cancel routine runs
        //

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        IoSetCancelRoutine(pIrp, &SrCancelWaitForNotification);

        //
        // cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // darn it, need to make sure the irp get's completed
            //

            if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
            {
                //
                // we are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  ioctl wrapper
                // will complete it
                //

                SrReleaseGlobalLock();

                pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                SrDereferenceControlObject(pControlObject);

                pIrp->IoStatus.Information = 0;

                SrUnmarkIrpPending( pIrp );
                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // our cancel routine will run and complete the irp,
            // don't touch it
            //

            SrReleaseGlobalLock();

            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the irp
            //

            Status = STATUS_PENDING;
            goto end;
        }

        //
        // now we are safe to queue it
        //

        InsertTailList(
            &pControlObject->IrpListHead,
            &pIrp->Tail.Overlay.ListEntry
            );

        SrReleaseGlobalLock();

        Status = STATUS_PENDING;
        goto end;
    }
    else // if (pRecord == NULL)
    {
        //
        // Have a queue'd record, serve it up!
        //

        //
        // all done with the control object
        //

        SrReleaseGlobalLock();

        SrTrace( NOTIFY, ( "SR!SrWaitForNotificationIoctl - completing IRP(%p) NotifyRecord(%d, %wZ)\n", 
                 pIrp,
                 pRecord->NotificationType,
                 &pRecord->VolumeName ));

        //
        // Copy it to the irp, the routine will take ownership
        // of pRecord if it is not able to copy it to the irp.
        //
        // it will also complete the irp so don't touch it later.
        //

        IoMarkIrpPending(pIrp);

        //
        // Copy the data and complete the irp
        //

        (VOID) SrCopyRecordToIrp( pIrp, 
                                  pRecord->NotificationType,
                                  &pRecord->VolumeName,
                                  pRecord->Context );

        //
        // don't touch pIrp, SrCopyRecordToIrp ALWAYS completes it.
        //
      
        pIrp = NULL;

        //
        // and free the record
        //

        SR_FREE_POOL_WITH_SIG(pRecord, SR_NOTIFICATION_RECORD_TAG);

        Status = STATUS_PENDING;
        goto end;
    }


end:

    //
    // At this point if Status != PENDING, the ioctl wrapper will
    // complete pIrp
    //

    RETURN(Status);

}   // SrWaitForNotificationIoctl



/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to receive the http request.
    this routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
SrCancelWaitForNotification(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    C_ASSERT(sizeof(WORK_QUEUE_ITEM) <= sizeof(pIrp->Tail.Overlay.DriverContext));

    UNREFERENCED_PARAMETER( pDeviceObject );

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    ExInitializeWorkItem( (PWORK_QUEUE_ITEM)&pIrp->Tail.Overlay.DriverContext[0],
                          &SrCancelWaitForNotificationWorker,
                          pIrp );

    ExQueueWorkItem( (PWORK_QUEUE_ITEM)&pIrp->Tail.Overlay.DriverContext[0],
                     DelayedWorkQueue  );


}   // SrCancelWaitForNotification

/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
SrCancelWaitForNotificationWorker(
    IN PVOID pContext
    )
{
    PSR_CONTROL_OBJECT  pControlObject;
    PIRP                pIrp;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pContext != NULL);

    //
    // grab the irp off the context
    //

    pIrp = (PIRP)pContext;
    ASSERT(IS_VALID_IRP(pIrp));

    SrTrace(CANCEL, ("SR!SrCancelWaitForNotificationWorker irp=%p\n", pIrp));

    //
    // grab the control object off the irp
    //

    pControlObject = (PSR_CONTROL_OBJECT)(
                    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));

    //
    // grab the lock protecting the queue
    //

    SrAcquireGlobalLockExclusive();

    //
    // does it need to be de-queue'd ?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // remove it
        //

        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // let the lock go
    //

    SrReleaseGlobalLock();

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    SrDereferenceControlObject(pControlObject);

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

}   // SrCancelWaitForNotificationWorker



/******************************************************************************

Routine Description:

    this copies a record into a free irp.  this routine completes the IRP!

Arguments:

    pRecord - the record to copy

    pIrp - the irp to copy pRecord to.  this routine completes this IRP !

Return Value:

    VOID - it always works.

******************************************************************************/
VOID
SrCopyRecordToIrp(
    IN PIRP pIrp,
    IN SR_NOTIFICATION_TYPE NotificationType,
    IN PUNICODE_STRING pVolumeName,
    IN ULONG Context
    )
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpSp;
    PVOID                   pBuffer;
    PSR_NOTIFICATION_RECORD pUserNotifyRecord;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(NotificationType < SrNotificationMaximum);
    ASSERT(NotificationType > SrNotificationInvalid);
    ASSERT(pVolumeName != NULL);

    SrTrace(FUNC_ENTRY, ("SR!SrCopyRecordToIrp\n"));

    ASSERT(global->pControlObject != NULL);

    //
    // assume SUCCESS!
    //
    
    Status = STATUS_SUCCESS;

    //
    // Make sure this is big enough to handle the request, and
    // if so copy it in.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // do we have enough space?
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < 
            sizeof(SR_NOTIFICATION_RECORD) + pVolumeName->Length 
                    + sizeof(WCHAR) )
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto complete;
    }
    
    //
    // get the system address for the buffer
    //

    pBuffer = MmGetSystemAddressForMdlSafe( pIrp->MdlAddress,
                                            NormalPagePriority );

    if (pBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    //
    // wipe it clean
    //

    RtlZeroMemory( pBuffer, 
                   pIrpSp->Parameters.DeviceIoControl.OutputBufferLength );

    //
    // Fill in the user space
    //

    pUserNotifyRecord = (PSR_NOTIFICATION_RECORD) pBuffer;

    pUserNotifyRecord->Signature = SR_NOTIFICATION_RECORD_TAG;
    pUserNotifyRecord->NotificationType = NotificationType;
    pUserNotifyRecord->VolumeName.Length = pVolumeName->Length;
    pUserNotifyRecord->VolumeName.MaximumLength = pVolumeName->Length;

    //
    // put the virtual pointer in for the use by the user mode service
    //
    
    pUserNotifyRecord->VolumeName.Buffer = 
        (PWSTR)((PUCHAR)(MmGetMdlVirtualAddress(pIrp->MdlAddress))
                                         + sizeof(SR_NOTIFICATION_RECORD));

    pUserNotifyRecord->Context = Context;

    //
    // and copy the string using the system address
    //
    
    RtlCopyMemory( pUserNotifyRecord+1, 
                   pVolumeName->Buffer, 
                   pVolumeName->Length );

    //
    // null terminate it
    //
    
    ((PWSTR)(pUserNotifyRecord+1))[pVolumeName->Length/sizeof(WCHAR)] 
                                                            = UNICODE_NULL;
    
    //
    // Tell everyone how much we copied
    //
    
    pIrp->IoStatus.Information = sizeof(SR_NOTIFICATION_RECORD) 
                                        + pVolumeName->Length + sizeof(WCHAR);

    //
    // complete the irp
    //

complete:

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    //
    // success.  we completed the irp
    //


}   // SrCopyRecordToIrp


/******************************************************************************

Routine Description:

    this will grab a free queue'd irp off the list and return it.

Arguments:

    pControlObject - the control object to grab irp's from

Return Value:

    PIRP - the free irp found (can be NULL)

******************************************************************************/
PIRP
SrDequeueIrp(
    IN PSR_CONTROL_OBJECT pControlObject
    )
{
    PIRP                pIrp = NULL;
    PSR_CONTROL_OBJECT  pIrpControlObject;

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));

    //
    // we are modifying the lists, better own the lock
    //

    ASSERT(IS_GLOBAL_LOCK_ACQUIRED());

    SrTrace(FUNC_ENTRY, ("SR!SrDequeueIrp\n"));

    //
    // check our list
    //

    while (!IsListEmpty(&(pControlObject->IrpListHead)))
    {
        PLIST_ENTRY pEntry;

        //
        // Found a free irp !
        //

        pEntry = RemoveHeadList(&pControlObject->IrpListHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //

            pIrpControlObject = (PSR_CONTROL_OBJECT)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pIrpControlObject == pControlObject);

            SrDereferenceControlObject(pControlObject);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);

            pIrp = NULL;
        }
        else
        {

            //
            // we are free to use this irp !
            //

            pIrpControlObject = (PSR_CONTROL_OBJECT)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pIrpControlObject == pControlObject);

            SrDereferenceControlObject(pControlObject);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            break;
        }
    }

    return pIrp;

}   // SrDequeueIrp


/******************************************************************************

Routine Description:

    this will grab a notify record if one has been queue'd for completion.

Arguments:

    pControlObject - the control object to grab records from

Return Value:

    PSR_NOTIFICATION_RECORD - the record found (can be NULL)

******************************************************************************/
PSR_NOTIFICATION_RECORD
SrDequeueNotifyRecord(
    IN PSR_CONTROL_OBJECT pControlObject
    )
{
    PSR_NOTIFICATION_RECORD pRecord = NULL;

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));

    //
    // we are modifying the lists, better own the lock
    //

    ASSERT(IS_GLOBAL_LOCK_ACQUIRED());


    SrTrace(FUNC_ENTRY, ("SR!SrDequeueNotifyRecord\n"));

    //
    // check our list
    //

    if (IsListEmpty(&pControlObject->NotifyRecordListHead) == FALSE)
    {
        PLIST_ENTRY pEntry;

        //
        // Found a free record !
        //

        pEntry = RemoveHeadList(&pControlObject->NotifyRecordListHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pRecord = CONTAINING_RECORD( pEntry, 
                                     SR_NOTIFICATION_RECORD, 
                                     ListEntry );

        ASSERT(IS_VALID_NOTIFICATION_RECORD(pRecord));

        //
        // give the record to the caller
        //
        
    }

    return pRecord;

}   // SrDequeueNotifyRecord



/******************************************************************************

Routine Description:

    this will fire a notify up to a listening usermode process.

    it does nothing if nobody is listening.

    it will queue the record if there are no free irp's.

Arguments:

    NotificationType - the type of notification 
    
    pExtension - the volume being notified about

Return Value:

    NTSTATUS - completion code

******************************************************************************/
NTSTATUS
SrFireNotification(
    IN SR_NOTIFICATION_TYPE NotificationType,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN ULONG Context OPTIONAL
    )
{
    NTSTATUS    Status;
    PIRP        pIrp;
    BOOLEAN     bReleaseLock = FALSE;

    PAGED_CODE();

    ASSERT(NotificationType < SrNotificationMaximum);
    ASSERT(NotificationType > SrNotificationInvalid);
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

    SrTrace(FUNC_ENTRY, ("SR!SrFireNotification\n"));

    Status = STATUS_SUCCESS;

    try {

        //
        // grab the lock EXCLUSIVE
        //

        SrAcquireGlobalLockExclusive();
        bReleaseLock = TRUE;

        //
        // do we still have a control object ?  the agent could have just
        // crashed or he was never there... that's ok .
        //

        if (global->pControlObject == NULL)
        {
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        // find a free irp to use 
        //

        pIrp = SrDequeueIrp(global->pControlObject);

        if (pIrp != NULL)
        {

            //
            // Found one, release the lock
            //

            SrReleaseGlobalLock();
            bReleaseLock = FALSE;

            SrTrace( NOTIFY, ("SR!SrFireNotification(%d, %wZ, %X) - completing IRP(%p)\n", 
                     NotificationType,
                     &pExtension->VolumeGuid,
                     Context,
                     pIrp ));

            //
            // Copy the data and complete the irp
            //

            (VOID) SrCopyRecordToIrp( pIrp, 
                                      NotificationType, 
                                      &pExtension->VolumeGuid,
                                      Context );

            //
            // don't touch pIrp, SrCopyRecordToIrp ALWAYS completes it.
            //
          
            NULLPTR( pIrp );

        }
        else 
        {
            PSR_NOTIFICATION_RECORD pRecord = NULL;

            SrTrace(NOTIFY, ("SR!SrFireNotification(%d, %wZ) - no IRPs; queue'ing a NOTIFY_RECORD\n", 
                    NotificationType,
                    &pExtension->VolumeGuid ));

            //
            // need to queue a NOTIFY_RECORD and wait for a free IRP to come down
            //

            //
            // allocate a notify record
            //

            pRecord = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool, 
                                                     SR_NOTIFICATION_RECORD, 
                                                     pExtension->VolumeGuid.Length + sizeof(WCHAR),
                                                     SR_NOTIFICATION_RECORD_TAG );

            if (NULL == pRecord)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }

            RtlZeroMemory(pRecord, sizeof(SR_NOTIFICATION_RECORD));

            pRecord->Signature = SR_NOTIFICATION_RECORD_TAG;
            pRecord->NotificationType = NotificationType;
            pRecord->VolumeName.Length = pExtension->VolumeGuid.Length;
            pRecord->VolumeName.MaximumLength = pExtension->VolumeGuid.Length;

            pRecord->VolumeName.Buffer = (PWSTR)(pRecord + 1);

            RtlCopyMemory( pRecord->VolumeName.Buffer,
                           pExtension->VolumeGuid.Buffer,
                           pExtension->VolumeGuid.Length );
                           
            pRecord->VolumeName.Buffer
                    [pRecord->VolumeName.Length/sizeof(WCHAR)] = UNICODE_NULL;

            pRecord->Context = Context;

            //
            // insert it into the list
            //
            
            InsertTailList( &global->pControlObject->NotifyRecordListHead, 
                            &pRecord->ListEntry );

            NULLPTR( pRecord );
        }
    } finally {
    
        //
        // release any locks we held during an error
        //
        
        if (bReleaseLock)
        {
            SrReleaseGlobalLock();
        }
    }

    RETURN(Status);
    
}   // SrFireNotification



/******************************************************************************

Routine Description:

    this update the bytes written count for the volume, and potentially
    fire a notification to user mode (for every 25mb).

Arguments:

    pExtension - the volume being updated

    BytesWritten - how much was just written

Return Value:

    NTSTATUS - completion code

******************************************************************************/
NTSTATUS
SrUpdateBytesWritten(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN ULONGLONG BytesWritten
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    try {

        SrAcquireLogLockExclusive( pExtension );

        //
        // update the count
        //

        pExtension->BytesWritten += BytesWritten;

        SrTrace( BYTES_WRITTEN, ( "SR!SrUpdateBytesWritten: (%wZ) Wrote 0x%016I64x bytes; total bytes written 0x%016I64x\n",
    							  pExtension->pNtVolumeName,
        						  BytesWritten,
        						  pExtension->BytesWritten ) );
        
        while (pExtension->BytesWritten >= SR_NOTIFY_BYTE_COUNT)
        {

    	    SrTrace( BYTES_WRITTEN, ( "SR!SrUpdateBytesWritten: (%wZ) Reached threshold -- notifying service; Total bytes written 0x%016I64x\n",
    								  pExtension->pNtVolumeName,
    	    						  pExtension->BytesWritten ) );

            Status = SrFireNotification( SrNotificationVolume25MbWritten, 
                                         pExtension,
                                         global->FileConfig.CurrentRestoreNumber );

            if (NT_SUCCESS(Status) == FALSE)
                leave;

            pExtension->BytesWritten -= SR_NOTIFY_BYTE_COUNT;
        }

        //
        // all done
        //
        
        Status = STATUS_SUCCESS;

    } finally {

        Status = FinallyUnwind(SrUpdateBytesWritten, Status);

        SrReleaseLogLock( pExtension );
    }

    RETURN(Status);
    
}   // SrUpdateBytesWritten


NTSTATUS
SrNotifyVolumeError(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName OPTIONAL,
    IN NTSTATUS ErrorStatus,
    IN SR_EVENT_TYPE EventType OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    
    if (!pExtension->Disabled)
    {
        //
        // trigger the failure notification to the service
        //

        Status = SrFireNotification( SrNotificationVolumeError, 
                                     pExtension,
                                     RtlNtStatusToDosErrorNoTeb(ErrorStatus));
                                         
        CHECK_STATUS(Status);

        //
        // log the failure in our change log
        //

        if (pFileName != NULL && 
            pExtension->pNtVolumeName != NULL &&
            (pFileName->Length > pExtension->pNtVolumeName->Length))
        {
            Status = SrLogEvent( pExtension,
                                 SrEventVolumeError,
                                 NULL,
                                 pFileName,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL );

            CHECK_STATUS(Status);

        }

        //
        // log the failure with nt
        //

        Status = SrLogError( pExtension, 
                             pFileName ? pFileName : pExtension->pNtVolumeName, 
                             ErrorStatus, 
                             EventType );
                             
        CHECK_STATUS(Status);

        //
        // and temporarily disable the volume
        //

        SrTrace( VERBOSE_ERRORS,
                ("sr!SrNotifyVolumeError(%X): disabling \"%wZ\", error %X!\n",
                 EventType,
                 pExtension->pNtVolumeName,
                 ErrorStatus) );
            
        pExtension->Disabled = TRUE;
    }

    RETURN(Status);

}

/******************************************************************************

Routine Description:

    This routine clears out all the outstanding notification record in the
    queue.

Arguments:

Return Value:

******************************************************************************/
VOID
SrClearOutstandingNotifications (
    )
{
    PSR_NOTIFICATION_RECORD pRecord;

    ASSERT( !IS_GLOBAL_LOCK_ACQUIRED() );
    
    try {

        SrAcquireGlobalLockExclusive();

        while (pRecord = SrDequeueNotifyRecord( _globals.pControlObject ))
        {
            //
            //  We don't care about this notification, so just free the memory.
            //
            
            SR_FREE_POOL_WITH_SIG(pRecord, SR_NOTIFICATION_RECORD_TAG);
        }
        
    } finally {

        SrReleaseGlobalLock();
    }
}

/******************************************************************************

Routine Description:

    This routine writes an eventlog entry to the eventlog.  It is way more
    complicated then you would hope, as it needs to squeeze everything into
    less than 104 bytes (52 characters).

Arguments:

Return Value:

    NTSTATUS - completion code

******************************************************************************/
NTSTATUS
SrLogError(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pFileName,
    IN NTSTATUS ErrorStatus,
    IN SR_EVENT_TYPE EventType
    )
{
C_ASSERT(sizeof(NTSTATUS) == sizeof(ULONG));

    UCHAR ErrorPacketLength;
    UCHAR BasePacketLength;
    ULONG StringLength, ReservedLength;
    PIO_ERROR_LOG_PACKET ErrorLogEntry = NULL;
    PWCHAR String;
    PWCHAR pToken, pFileToken, pVolumeToken;
    ULONG TokenLength, FileTokenLength, VolumeTokenLength;
    ULONG Count;
    WCHAR ErrorString[10+1];

    NTSTATUS Status;

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(pExtension->pNtVolumeName != NULL);
    ASSERT(pFileName != NULL);

    PAGED_CODE();

    //
    // get the name of just the file part
    //
    
    Status = SrFindCharReverse( pFileName->Buffer, 
                                pFileName->Length, 
                                L'\\',
                                &pFileToken,
                                &FileTokenLength );

    if (!NT_SUCCESS_NO_DBGBREAK(Status)) {
        FileTokenLength = 0;
        pFileToken = NULL;
    } else {
        //
        // skip the prefix slash
        //
        
        pFileToken += 1;
        FileTokenLength -= sizeof(WCHAR);
    }        

    //
    // get the name of just the volume
    //
    
    Status = SrFindCharReverse( pExtension->pNtVolumeName->Buffer, 
                                pExtension->pNtVolumeName->Length, 
                                L'\\',
                                &pVolumeToken,
                                &VolumeTokenLength );

    if (!NT_SUCCESS_NO_DBGBREAK(Status))
    {
        VolumeTokenLength = 0;
        pVolumeToken = NULL;
    }
    else
    {
        //
        // skip the prefix slash
        //
        
        pVolumeToken += 1;
        VolumeTokenLength -= sizeof(WCHAR);
    }        

    //
    //  Get our error packet, holding the string and status code.
    //

    BasePacketLength = sizeof(IO_ERROR_LOG_PACKET) ;
    
    if ((BasePacketLength + sizeof(ErrorString) + VolumeTokenLength + sizeof(WCHAR) + FileTokenLength + sizeof(WCHAR)) <= ERROR_LOG_MAXIMUM_SIZE) {
        ErrorPacketLength = (UCHAR)(BasePacketLength 
                                        + sizeof(ErrorString) 
                                        + VolumeTokenLength + sizeof(WCHAR) 
                                        + FileTokenLength + sizeof(WCHAR) );
    } else {
        ErrorPacketLength = ERROR_LOG_MAXIMUM_SIZE;
    }

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( pExtension->pDeviceObject,
                                                                    ErrorPacketLength );
                                                                    
    if (ErrorLogEntry == NULL) 
    {
        RETURN(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    //  Fill in the nonzero members of the packet.
    //

    ErrorLogEntry->MajorFunctionCode = SrIrpCodeFromEventType(EventType);
    ErrorLogEntry->ErrorCode = EVMSG_DISABLEDVOLUME;

    //
    // init the insertion strings
    //
    
    ErrorLogEntry->NumberOfStrings = 3;
    ErrorLogEntry->StringOffset = BasePacketLength;

    StringLength = ErrorPacketLength - BasePacketLength;

    ASSERT(!(StringLength % sizeof(WCHAR)));

    String = (PWCHAR) ((PUCHAR)ErrorLogEntry + BasePacketLength);
    
    RtlZeroMemory(String, StringLength);

    ASSERT(StringLength > 3 * sizeof(WCHAR));

    //
    // put the error code string in first
    //
    
    if (StringLength >= ((10+1)*sizeof(WCHAR)) ) {
        Count = swprintf(String, L"0x%08X", ErrorStatus);
        ASSERT(Count == 10);

        String += (10+1);
        StringLength -= (10+1) * sizeof(WCHAR);
    } else {
        String[0] = UNICODE_NULL;
        String += 1;
        StringLength -= sizeof(WCHAR);
    }

    //
    // now put the filename token in there
    //
    
    TokenLength = FileTokenLength;
    pToken = pFileToken;

    //
    // reserve space for the volume token
    //

    if (ErrorPacketLength == ERROR_LOG_MAXIMUM_SIZE) {
        if (StringLength > (VolumeTokenLength + 10)) {
            StringLength -= VolumeTokenLength;
            ReservedLength = VolumeTokenLength;
        } else {
            StringLength /= 2;
            ReservedLength = StringLength;
            if (StringLength % 2) {
                StringLength -=1;
                ReservedLength += 1;
            }
        }
    } else {
        ReservedLength = 0;
    }
    
    if (TokenLength > 0)
    {
        //
        //  The filename string is appended to the end of the error log entry. We 
        //  may have to smash the middle to fit it in the limited space.
        //

        //
        //  If the name does not fit in the packet, divide the name equally to the
        //  prefix and suffix, with an ellipsis " .. " (4 wide characters) to indicate
        //  the loss.
        //

        if (StringLength <= TokenLength) {

            ULONG BytesToCopy, ChunkLength;
            
            //
            // take the ending NULL off the top
            //
            
            StringLength -= sizeof(WCHAR);

            //
            // use half the chunk, minus the 4 " .. " characters
            // for the first and last half
            //
            
            ChunkLength = StringLength - 4*sizeof(WCHAR);
            ChunkLength /= 2;

            //
            // make sure it stays even
            //
            
            if (ChunkLength % 2) 
                ChunkLength -= 1;

            BytesToCopy = ChunkLength;
            
            RtlCopyMemory( String,
                           pToken,
                           BytesToCopy );
                           
            String += BytesToCopy/sizeof(WCHAR);
            StringLength -= BytesToCopy;
            
            BytesToCopy = 4*sizeof(WCHAR);
                           
            RtlCopyMemory( String,
                           L" .. ",
                           BytesToCopy );
                           
            String += BytesToCopy/sizeof(WCHAR);
            StringLength -= BytesToCopy;
            
            BytesToCopy = ChunkLength;
            
            RtlCopyMemory( String,
                           ((PUCHAR)pToken)
                                + TokenLength 
                                - BytesToCopy,
                           BytesToCopy );

            String += BytesToCopy/sizeof(WCHAR);
            StringLength -= BytesToCopy;
            
            String[0] = UNICODE_NULL;
            String += 1;

            //
            // already subtracted the NULL from the top (see above)
            //
                           
        } else {
            RtlCopyMemory( String,
                           pToken,
                           TokenLength );
                           
            String += TokenLength/sizeof(WCHAR);
            StringLength -= TokenLength;

            
            String[0] = UNICODE_NULL;
            String += 1;
            StringLength -= sizeof(WCHAR);
        }
    }
    else
    {
        String[0] = UNICODE_NULL;
        String += 1;
        StringLength -= sizeof(WCHAR);
    }

    //
    // put back any reserved length we kept
    //
    
    StringLength += ReservedLength;

    //
    // and put the volume name in there
    //
    
    TokenLength = VolumeTokenLength;
    pToken = pVolumeToken;

    if (TokenLength > 0)
    {
        //
        //  The filename string is appended to the end of the error log entry. We 
        //  may have to smash the middle to fit it in the limited space.
        //

        //
        //  If the name does not fit in the packet, divide the name equally to the
        //  prefix and suffix, with an ellipsis " .. " (4 wide characters) to indicate
        //  the loss.
        //

        if (StringLength <= TokenLength) {

            ULONG BytesToCopy, ChunkLength;
            
            //
            // take the ending NULL off the top
            //
            
            StringLength -= sizeof(WCHAR);

            //
            // use half the chunk, minus the 4 " .. " characters
            // for the first and last half
            //
            
            ChunkLength = StringLength - 4*sizeof(WCHAR);
            ChunkLength /= 2;

            //
            // make sure it stays even
            //
            
            if (ChunkLength % 2) 
                ChunkLength -= 1;

            BytesToCopy = ChunkLength;
            
            RtlCopyMemory( String,
                           pToken,
                           BytesToCopy );
                           
            String += BytesToCopy/sizeof(WCHAR);
            StringLength -= BytesToCopy;
            
            BytesToCopy = 4*sizeof(WCHAR);
                           
            RtlCopyMemory( String,
                           L" .. ",
                           BytesToCopy );
                           
            String += BytesToCopy/sizeof(WCHAR);
            StringLength -= BytesToCopy;
            
            BytesToCopy = ChunkLength;
            
            RtlCopyMemory( String,
                           ((PUCHAR)pToken)
                                + TokenLength 
                                - BytesToCopy,
                           BytesToCopy );

            String += BytesToCopy/sizeof(WCHAR);
            StringLength -= BytesToCopy;
            
            String[0] = UNICODE_NULL;
            String += 1;

            //
            // already subtracted the NULL from the top (see above)
            //
                           
        } else {
            RtlCopyMemory( String,
                           pToken,
                           TokenLength );
                           
            String += TokenLength/sizeof(WCHAR);
            StringLength -= TokenLength;

            
            String[0] = UNICODE_NULL;
            String += 1;
            StringLength -= sizeof(WCHAR);
        }
    }
    else
    {
        String[0] = UNICODE_NULL;
        String += 1;
        StringLength -= sizeof(WCHAR);
    }

    IoWriteErrorLogEntry( ErrorLogEntry );

    RETURN(STATUS_SUCCESS);
    
}   // SrLogError


UCHAR
SrIrpCodeFromEventType(
    IN SR_EVENT_TYPE EventType
    )
{    
    UCHAR Irp;

    PAGED_CODE();
    
    switch (EventType)
    {
    case SrEventStreamChange:   Irp = IRP_MJ_WRITE;                 break;
    case SrEventAclChange:      Irp = IRP_MJ_SET_SECURITY;          break;
    case SrEventDirectoryCreate:
    case SrEventFileCreate:
    case SrEventStreamOverwrite:Irp = IRP_MJ_CREATE;                break;
    case SrEventFileRename:
    case SrEventDirectoryDelete:
    case SrEventDirectoryRename:
    case SrEventFileDelete:     
    case SrEventAttribChange:   Irp = IRP_MJ_SET_INFORMATION;       break;
    case SrEventMountCreate:    
    case SrEventMountDelete:    Irp = IRP_MJ_FILE_SYSTEM_CONTROL;   break;
    default:                    Irp = IRP_MJ_DEVICE_CONTROL;        break;
    }   // switch (EventType)
    
    return Irp;
    
}   // SrIrpCodeFromEventType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\srlog.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    srlog.h

Abstract:

    contains prototypes/macros for functions SR logging functionality

Author:

    Kanwaljit Marok (kmarok)     01-March-2000

Revision History:

--*/


#ifndef _SR_LOG_H_
#define _SR_LOG_H_

#include "logfmt.h"


//
// This structure contains all the relevant context information
// regarding the current SRlog
//

#define IS_VALID_LOG_CONTEXT(pObject)                \
    (((pObject) != NULL) &&                          \
     ((pObject)->Signature == SR_LOG_CONTEXT_TAG) && \
     ((pObject)->pExtension != NULL)  &&             \
     ((pObject)->pExtension->pLogContext == (pObject)))

typedef struct _SR_LOG_CONTEXT
{
    //
    // PagedPool
    //

    //
    // = SR_LOG_CONTEXT_TAG
    //

    ULONG Signature;

    //
    // Log file handle
    //

    HANDLE LogHandle;

    //
    // File object represented by LogHandle.
    //

    PFILE_OBJECT pLogFileObject;

    //
    // Pointer to log buffer (NonPagedPool)
    //

    PBYTE pLogBuffer;

    //
    //  Current log file allocation size.
    //

    ULONG AllocationSize;
    //
    // Offset for next buffer write in the file
    //

    ULONG FileOffset;

    //
    // Offset for next to log entry write in the buffer
    //

    ULONG BufferOffset;

    //
    // indicates the offset of a previous entry
    //

    ULONG LastBufferOffset;

    //
    // Log file path - required for suspend / resume
    //

    PUNICODE_STRING pLogFilePath;

    //
    // Logging flags , enabled, dirty, etc.
    //

    ULONG  LoggingFlags;

    //
    // Keep a backpointer to the DeviceExtension associated with this
    // log context.
    //
    
    PSR_DEVICE_EXTENSION pExtension;

} SR_LOG_CONTEXT, *PSR_LOG_CONTEXT;



//
// This stucture contains context information for the logger
//

#define IS_VALID_LOGGER_CONTEXT(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == SR_LOGGER_CONTEXT_TAG))

typedef struct _SR_LOGGER_CONTEXT
{

    //
    // NonPagedPool
    //

    //
    // = SR_LOGGER_CONTEXT_TAG
    //

    ULONG Signature;

    //
    // Number of active log contexts
    //

    LONG ActiveContexts;

    //
    // Timer object for flushing logs evry 5 Secs
    //

    KTIMER           Timer;

    //
    // Dpc routine used along with the timer object
    //

    KDPC             Dpc;

#ifdef USE_LOOKASIDE

    //
    // lookaside lists for speedy allocations
    //

    PAGED_LOOKASIDE_LIST LogEntryLookaside;

    //
    // lookaside lists for speedy log allocations
    //

    NPAGED_LOOKASIDE_LIST LogBufferLookaside;

#endif

} SR_LOGGER_CONTEXT, * PSR_LOGGER_CONTEXT;


#define SR_MAX_INLINE_ACL_SIZE               8192

#define SR_LOG_DEBUG_INFO_SIZE               sizeof( SR_LOG_DEBUG_INFO )

#ifdef USE_LOOKASIDE

#define SrAllocateLogBuffer()                                          \
        ExAllocateFromNPagedLookasideList(&global->pLogger->LogBufferLookaside)

#define SrFreeLogBuffer( pBuffer )                                     \
        ExFreeToNPagedLookasideList(                                   \
            &global->pLogger->LogBufferLookaside,                      \
            (pBuffer) )

#else

#define SrAllocateLogBuffer( _bufferSize )                              \
        SR_ALLOCATE_POOL(NonPagedPool, (_bufferSize) , SR_LOG_BUFFER_TAG)

#define SrFreeLogBuffer( pBuffer )                                     \
        SR_FREE_POOL(pBuffer, SR_LOG_BUFFER_TAG)

#endif

#define SrAllocateLogEntry( EntrySize )                                \
        SR_ALLOCATE_POOL(PagedPool, (EntrySize), SR_LOG_ENTRY_TAG)

#define SrFreeLogEntry( pBuffer )                                      \
        SR_FREE_POOL(pBuffer, SR_LOG_ENTRY_TAG)

NTSTATUS
SrLogStart ( 
    IN  PUNICODE_STRING   pLogPath,
    IN  PSR_DEVICE_EXTENSION pExtension,
    OUT PSR_LOG_CONTEXT  * ppLogContext
    );

NTSTATUS
SrLogStop(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN BOOLEAN PurgeContexts,
    IN BOOLEAN CheckLog
    );

NTSTATUS
SrLogWrite ( 
    IN PSR_DEVICE_EXTENSION pExtension OPTIONAL,
    IN PSR_LOG_CONTEXT pOptionalLogContext OPTIONAL,
    IN PSR_LOG_ENTRY pLogEntry
    );

NTSTATUS
SrLogNormalize (
    IN PSR_DEVICE_EXTENSION pExtension
    );

NTSTATUS
SrGetAclInformation (
    IN PFILE_OBJECT pFileObject,
    IN PSR_DEVICE_EXTENSION pExtension,
    OUT PSECURITY_DESCRIPTOR * pSecurityDescriptorPtr,
    OUT PULONG pSizeNeeded
    );

NTSTATUS
SrLoggerStart (
    IN  PDEVICE_OBJECT    pDeviceObject,
    OUT PSR_LOGGER_CONTEXT * pLoggerInfo
    );

NTSTATUS
SrLoggerStop ( 
    IN PSR_LOGGER_CONTEXT pLoggerInfo
    );

NTSTATUS
SrLoggerSwitchLogs ( 
    IN PSR_LOGGER_CONTEXT pLogger
    );

NTSTATUS 
SrGetLogFileName (
    IN  PUNICODE_STRING pVolumeName,
    IN  USHORT          LogFileNameLength,
    OUT PUNICODE_STRING pLogFileName
    );

NTSTATUS
SrPackDebugInfo ( 
    IN PBYTE pBuffer,
    IN ULONG BufferSize
    );

NTSTATUS
SrPackLogEntry( 
    OUT PSR_LOG_ENTRY *ppLogEntry,
    IN ULONG EntryType,
    IN ULONG Attributes,
    IN INT64 SequenceNum,
    IN PSECURITY_DESCRIPTOR pAclInfo OPTIONAL,
    IN ULONG AclInfoSize OPTIONAL,
    IN PVOID pDebugBlob OPTIONAL,
    IN PUNICODE_STRING pPath1,
    IN USHORT Path1StreamLength,
    IN PUNICODE_STRING pTempPath OPTIONAL,
    IN PUNICODE_STRING pPath2 OPTIONAL,
    IN USHORT Path2StreamLength OPTIONAL,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pShortName OPTIONAL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\srio.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    srio.h

Abstract:

    Contains the prototypes for the routines in srio.c.

Author:

    Molly Brown (MollyBro)     07-Nov-2000
    
Revision History:

--*/

#ifndef __SRIO_H__
#define __SRIO_H__

NTSTATUS
SrSyncIoCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
    );

NTSTATUS
SrQueryInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	OUT PULONG LengthReturned OPTIONAL
	);

NTSTATUS
SrSetInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	);

NTSTATUS
SrQueryVolumeInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FsInformation,
	IN  ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass,
	OUT PULONG LengthReturned OPTIONAL
	);

NTSTATUS
SrQueryEaFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID Buffer,
	IN ULONG Length,
	OUT PULONG LengthReturned OPTIONAL
	);

NTSTATUS
SrQuerySecurityObject (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	IN SECURITY_INFORMATION SecurityInformation,
	OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN ULONG Length,
	OUT PULONG LengthNeeded
	);

NTSTATUS
SrFlushBuffers (
    PDEVICE_OBJECT NextDeviceObject,
    PFILE_OBJECT FileObject
    );

#endif /* __SRIO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\srio.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    srio.c

Abstract:

    This files contains the routines that generate IO
    for the SR filter driver.

Author:

    Molly Brown (MollyBro)     07-Nov-2000
    
Revision History:

    Added routines to post & wait for ops - ravisp 12/6/2000

--*/

#include "precomp.h"


#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrQueryInformationFile )
#pragma alloc_text( PAGE, SrSetInformationFile )
#pragma alloc_text( PAGE, SrQueryVolumeInformationFile )
#pragma alloc_text( PAGE, SrQueryEaFile )
#pragma alloc_text( PAGE, SrQuerySecurityObject )
#pragma alloc_text( PAGE, SrFlushBuffers )
#pragma alloc_text( PAGE, SrSyncOpWorker )
#pragma alloc_text( PAGE, SrPostSyncOperation )

#endif  // ALLOC_PRAGMA

NTSTATUS
SrSyncIoCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine does the cleanup necessary once the IO request
    is completed by the file system.
    
Arguments:

    DeviceObject - This will be NULL since we originated this
        Irp.

    Irp - The io request structure containing the information
        about the current state of our file name query.

    Event - The event to signal to notify the 
        originator of this request that the operation is
        complete.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED so that IO Manager
    will not try to free the Irp again.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Make sure that the Irp status is copied over to the user's
    //  IO_STATUS_BLOCK so that the originator of this irp will know
    //  the final status of this operation.
    //

    ASSERT( NULL != Irp->UserIosb );
    *Irp->UserIosb = Irp->IoStatus;

    //
    //  Signal SynchronizingEvent so that the originator of this
    //  Irp know that the operation is completed.
    //

    KeSetEvent( Event, IO_NO_INCREMENT, FALSE );

    //
    //  We are now done, so clean up the irp that we allocated.
    //

    IoFreeIrp( Irp );

    //
    //  If we return STATUS_SUCCESS here, the IO Manager will
    //  perform the cleanup work that it thinks needs to be done
    //  for this IO operation.  This cleanup work includes:
    //  * Copying data from the system buffer to the user's buffer 
    //    if this was a buffered IO operation.
    //  * Freeing any MDLs that are in the Irp.
    //  * Copying the Irp->IoStatus to Irp->UserIosb so that the
    //    originator of this irp can see the final status of the
    //    operation.
    //  * If this was an asynchronous request or this was a 
    //    synchronous request that got pending somewhere along the
    //    way, the IO Manager will signal the Irp->UserEvent, if one 
    //    exists, otherwise it will signal the FileObject->Event.
    //    (This can have REALLY bad implications if the irp originator
    //     did not an Irp->UserEvent and the irp originator is not
    //     waiting on the FileObject->Event.  It would not be that
    //     farfetched to believe that someone else in the system is
    //     waiting on FileObject->Event and who knows who will be
    //     awoken as a result of the IO Manager signaling this event.
    //
    //  Since some of these operations require the originating thread's
    //  context (e.g., the IO Manager need the UserBuffer address to 
    //  be valid when copy is done), the IO Manager queues this work
    //  to an APC on the Irp's orginating thread.
    //
    //  Since SR allocated and initialized this irp, we know
    //  what cleanup work needs to be done.  We can do this cleanup
    //  work more efficiently than the IO Manager since we are handling
    //  a very specific case.  Therefore, it is better for us to
    //  perform the cleanup work here then free the irp than passing
    //  control back to the IO Manager to do this work.
    //
    //  By returning STATUS_MORE_PROCESS_REQUIRED, we tell the IO Manager 
    //  to stop processing this irp until it is told to restart processing
    //  with a call to IoCompleteRequest.  Since the IO Manager has
    //  already performed all the work we want it to do on this
    //  irp, we do the cleanup work, return STATUS_MORE_PROCESSING_REQUIRED,
    //  and ask the IO Manager to resume processing by calling 
    //  IoCompleteRequest.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SrQueryInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	OUT PULONG LengthReturned OPTIONAL
	)

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

    This routine only supports the following FileInformationClasses:
        FileBasicInformation
        FileStandardInformation
        FileStreamInformation
        FileAlternateNameInformation
        FileNameInformation

Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies the file object about which the requested
        information should be returned.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This must be a buffer allocated from kernel
        space.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    LengthReturned - the number of bytes returned if the operation was 
        successful.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  In DBG builds, make sure that we have valid parameters before we do 
    //  any work here.
    //

    ASSERT( NULL != NextDeviceObject );
    ASSERT( NULL != FileObject );
    ASSERT( NULL != FileInformation );
    
    ASSERT( (FileInformationClass == FileBasicInformation) ||
            (FileInformationClass == FileStandardInformation) ||
            (FileInformationClass == FileStreamInformation) ||
            (FileInformationClass == FileAlternateNameInformation) ||
            (FileInformationClass == FileNameInformation) ||
            (FileInformationClass == FileInternalInformation) );

    //
    //  The parameters look ok, so setup the Irp.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SrSyncIoCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );

    if (LengthReturned != NULL) {

        *LengthReturned = (ULONG) ioStatusBlock.Information;
    }

#if DBG
    if (STATUS_OBJECT_NAME_NOT_FOUND == ioStatusBlock.Status ||
        STATUS_INVALID_PARAMETER == ioStatusBlock.Status)
    {
        return ioStatusBlock.Status;
    }
#endif    
    
    RETURN( ioStatusBlock.Status );
}

NTSTATUS
SrSetInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	)

/*++

Routine Description:

    This routine changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies the file object about which the requested
        information should be changed.

    FileInformation - Supplies a buffer containing the information which should
        be changed on the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        changed about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  In DBG builds, make sure the parameters are valid.
    //

    ASSERT( NULL != NextDeviceObject );
    ASSERT( NULL != FileObject );
    ASSERT( NULL != FileInformation );

    //
    //  The parameters look ok, so setup the Irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;
    irpSp->Parameters.SetFile.FileObject = NULL;
    irpSp->Parameters.SetFile.DeleteHandle = NULL;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SrSyncIoCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );
#if DBG
    if (ioStatusBlock.Status == STATUS_CANNOT_DELETE ||
        ioStatusBlock.Status == STATUS_DIRECTORY_NOT_EMPTY)
    {
        //
        // bug#186511: STATUS_CANNOT_DELETE can be returned for some crazy 
        // reason by the fsd if the file is already deleted.  it should return 
        // already deleted or simple return success, but it returns this 
        // instead.  callers of this function know to test for this.  
        // don't DbgBreak.
        //
    
        return ioStatusBlock.Status;
    }
#endif

    RETURN( ioStatusBlock.Status );
}

NTSTATUS
SrQueryVolumeInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass,
	OUT PULONG LengthReturned OPTIONAL
	)

/*++

Routine Description:

    This routine returns information about the volume associated with the
    FileObject parameter.  The information returned in the buffer is defined
    by the FsInformationClass parameter.  The legal values for this parameter
    are as follows:

        o  FileFsVolumeInformation
        o  FileFsSizeInformation
        o  FileFsDeviceInformation
        o  FileFsAttributeInformation

    Note:  Currently this routine only supports the following 
    FsInformationClasses:

        FileFsVolumeInformation
        FileFsSizeInformation
  
Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies a fileobject to an open volume, directory, or file
        for which information about the volume is returned.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the volume.  This must be a buffer allocated from
        kernel space.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

    LengthReturned - The number of bytes returned if the operation was 
        successful.
        
Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  In DBG builds, make sure that we have valid parameters before 
    //  we do any work here.
    //

    ASSERT( NextDeviceObject != NULL );
    ASSERT( FileObject != NULL );
    ASSERT( FsInformation != NULL );

    ASSERT( (FsInformationClass == FileFsVolumeInformation) ||
            (FsInformationClass == FileFsSizeInformation) ||
            (FsInformationClass == FileFsAttributeInformation) );

    //
    //  The parameters look ok, so setup the Irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_VOLUME_INFORMATION.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FsInformation;

    irpSp->Parameters.QueryVolume.Length = Length;
    irpSp->Parameters.QueryVolume.FsInformationClass = FsInformationClass;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SrSyncIoCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );
    if (LengthReturned != NULL) {

        *LengthReturned = (ULONG) ioStatusBlock.Information;
    }
    
    RETURN( ioStatusBlock.Status );
}

NTSTATUS
SrQueryEaFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID Buffer,
	IN ULONG Length,
	OUT PULONG LengthReturned OPTIONAL
	)
	
/*++

Routine Description:

    This routine returns the Extended Attributes (EAs) associated with the
    file specified by the FileObject parameter.  The amount of information
    returned is based on the size of the EAs, and the size of the buffer.
    That is, either all of the EAs are written to the buffer, or the buffer
    is filled with complete EAs if the buffer is not large enough to contain
    all of the EAs.  Only complete EAs are ever written to the buffer; no
    partial EAs will ever be returned.

    NOTE: This routine will always return EAs starting at the being of the 
    file's EA List.  It will also always return as many EAs as possible in the
    buffer.  THIS BEHAVIOR IS A LIMITED VERSION OF ZwQueryEaFile.

Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies a fileobject to the file for which the EAs are returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the EAs for the file.

    Length - Supplies the length, in bytes, of the buffer.

    LengthReturned - The number of bytes returned if the operation is 
        successful.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  In DBG builds, make sure that we have valid parameters before we do 
    //  any work here.
    //

    ASSERT( NULL != NextDeviceObject );
    ASSERT( NULL != FileObject );
    ASSERT( NULL != Buffer );
    
    //
    //  The parameters look ok, so setup the Irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (NULL == irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_EA;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_EA.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the user buffer.
    //

    irp->UserBuffer = Buffer;

    irpSp->Parameters.QueryEa.Length = Length;
    irpSp->Parameters.QueryEa.EaList = NULL;
    irpSp->Parameters.QueryEa.EaListLength = 0;
    irpSp->Parameters.QueryEa.EaIndex = 0;
    irpSp->Flags = SL_RESTART_SCAN;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SrSyncIoCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );

    if (LengthReturned != NULL) {

        *LengthReturned = (ULONG) ioStatusBlock.Information;
    }
    
    RETURN( ioStatusBlock.Status );
}

NTSTATUS
SrQuerySecurityObject (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	IN SECURITY_INFORMATION SecurityInformation,
	OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN ULONG Length,
	OUT PULONG LengthNeeded
	)

/*++

Routine Description:

    This routine is used to invoke an object's security routine.  It
    is used to set the object's security state.

Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies the file object for the object being modified

    SecurityInformation - Indicates the type of information we are
        interested in getting. e.g., owner, group, dacl, or sacl.

    SecurityDescriptor - Supplies a pointer to where the information
        should be returned.  This must be a buffer allocated from kernel
        space.

    Length - Supplies the size, in bytes, of the output buffer

    LengthNeeded - Receives the length, in bytes, needed to store
        the output security descriptor

Return Value:

    An appropriate NTSTATUS value

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  Make sure that we have valid parameters before we do any work here.
    //
    
    ASSERT( NextDeviceObject != NULL );
    ASSERT( FileObject != NULL );
    ASSERT( SecurityDescriptor != NULL );
    ASSERT( LengthNeeded != NULL );

    //
    //  The parameters look ok, so setup the Irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_SECURITY;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_SECURITY_INFORMATION.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the User buffer.
    //

    irp->UserBuffer = SecurityDescriptor;

    irpSp->Parameters.QuerySecurity.SecurityInformation = SecurityInformation;
    irpSp->Parameters.QuerySecurity.Length = Length;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SrSyncIoCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );

    status = ioStatusBlock.Status;

    if (status == STATUS_BUFFER_OVERFLOW) {
        status = STATUS_BUFFER_TOO_SMALL;

        //
        //  The buffer was too small, so return the size needed for the
        //  security descriptor.
        //
        
        *LengthNeeded = (ULONG) ioStatusBlock.Information;
    }

#if DBG
    if (status == STATUS_BUFFER_TOO_SMALL) {

        return status;
    }
#endif

    RETURN( status );
}

NTSTATUS
SrFlushBuffers (
    PDEVICE_OBJECT NextDeviceObject,
    PFILE_OBJECT FileObject
    )
{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  Make sure that we have valid parameters before we do any work here.
    //

    ASSERT( NextDeviceObject != NULL );
    ASSERT( FileObject != NULL );

    //
    //  The parameters look ok, so setup the Irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoBuildAsynchronousFsdRequest( IRP_MJ_FLUSH_BUFFERS, 
                                         NextDeviceObject, 
                                         NULL, 
                                         0,
                                         NULL, 
                                         &ioStatusBlock );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SrSyncIoCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    if (status == STATUS_PENDING)
    {
        (VOID) KeWaitForSingleObject( &event, 
                                      Executive, 
                                      KernelMode,
                                      FALSE,
                                      NULL );
    }

    RETURN( ioStatusBlock.Status );

}

//
//++
// Function:
//        SrSyncOpWorker
//
// Description:
//        This function is the generic worker routine
//        that calls the real caller-passed work routine,
//        and sets the event for synchronization with the main
//        thread
//
// Arguments:
//
//        Context
//
// Return Value:
//
//        None
//--
//
VOID
SrSyncOpWorker(
    IN PSR_WORK_CONTEXT WorkContext
    )
{
    PAGED_CODE();

    ASSERT(WorkContext != NULL);
    ASSERT(WorkContext->SyncOpRoutine != NULL);
    
    //
    // Call the 'real' posted routine
    //
    WorkContext->Status = (*WorkContext->SyncOpRoutine)(WorkContext->Parameter);
    //
    // Signal the main-thread about completion
    //
    KeSetEvent(&WorkContext->SyncEvent,
               EVENT_INCREMENT,
               FALSE);
}

//++
// Function:
//        SrPostSyncOperation
//
// Description:
//        This function posts work to a worker thread
//        and waits for completion
//
//        WARNING: Be VERY careful about acquiring locks in the 
//        operation that is being posted. This may lead to deadlocks.
//        
//
// Arguments:
//
//        Pointer to worker routine that handles the work
//        Context to be passed to worker routine
//
// Return Value:
//        This function returns status of the work routine
//--
NTSTATUS
SrPostSyncOperation(
    IN PSR_SYNCOP_ROUTINE SyncOpRoutine,
    IN PVOID              Parameter
    )
{
    SR_WORK_CONTEXT workContext;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the workContext
    //
    workContext.SyncOpRoutine = SyncOpRoutine;
    workContext.Parameter     = Parameter;
    KeInitializeEvent(&workContext.SyncEvent,
                      NotificationEvent,
                      FALSE);

    //
    // Initialize and queue off the SyncOp Worker
    //
    ExInitializeWorkItem(&workContext.WorkItem, 
                         SrSyncOpWorker,
                         &workContext);

    ExQueueWorkItem(&workContext.WorkItem,
                    CriticalWorkQueue );
    //
    // Now just wait for the worker to fire and complete
    //
    status = KeWaitForSingleObject(&workContext.SyncEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);

    ASSERT(status == STATUS_SUCCESS);

    //
    // We're done free the work context and return the status of the 
    // operation. 
    //
    return workContext.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\srlog.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    srlog.c

Abstract:

    this file implements the sr logging functionality

Author:

    Kanwaljit Marok (kmarok)     01-May-2000

Revision History:

--*/

#include "precomp.h"
#include "srdefs.h"

//
// Some SR_LOG related macros
//

#define MAX_RENAME_TRIES                    1000


#define SR_LOG_FLAGS_ENABLE                  0x00000001
#define SR_LOG_FLAGS_DIRTY                   0x00000010

#define SR_MAX_LOG_FILE_SIZE                 (1024*1024)

//
// system volume information\_restore{machineguid} 
//

#define SR_DATASTORE_PREFIX_LENGTH          79 * sizeof(WCHAR)

//
// Length of \_restore.{machineguid}\RPXX\S0000000.ACL
//

#define SR_ACL_FILENAME_LENGTH             (SR_DATASTORE_PREFIX_LENGTH + \
                                            32* sizeof(WCHAR))

#define SR_INLINE_ACL_SIZE(AclInfoSize)    (sizeof(RECORD_HEADER)+ AclInfoSize)

#define SR_FILE_ACL_SIZE(pVolumeName)      (sizeof(RECORD_HEADER)    +    \
                                            pVolumeName->Length      +    \
                                            SR_ACL_FILENAME_LENGTH)

#define UPDATE_LOG_OFFSET( pLogContext, BytesWritten )                 \
    ((pLogContext)->FileOffset += BytesWritten)
    
#define RESET_LOG_BUFFER( pLogContext )                                \
        ((pLogContext)->BufferOffset     = 0,                          \
         (pLogContext)->LastBufferOffset = 0)                          

#define RESET_LOG_CONTEXT( pLogContext )                               \
        ((pLogContext)->FileOffset = 0,                                \
         RESET_LOG_BUFFER( pLogContext ),                              \
         (pLogContext)->LoggingFlags = 0,                              \
         (pLogContext)->AllocationSize = 0)

#define SET_ENABLE_FLAG( pLogContext )                                 \
        SetFlag( pLogContext->LoggingFlags, SR_LOG_FLAGS_ENABLE )

#define CLEAR_ENABLE_FLAG( pLogContext )                               \
        ClearFlag( pLogContext->LoggingFlags, SR_LOG_FLAGS_ENABLE )

#define SET_DIRTY_FLAG( pLogContext )                                  \
        SetFlag( pLogContext->LoggingFlags, SR_LOG_FLAGS_DIRTY)

#define CLEAR_DIRTY_FLAG( pLogContext )                                \
        ClearFlag( pLogContext->LoggingFlags, SR_LOG_FLAGS_DIRTY )
        

//
// Context passed to SrCreateFile
//
typedef struct _SR_OPEN_CONTEXT {
    //
    // Path to file
    //
    PUNICODE_STRING pPath;
    //
    // Handle will be returned here
    //
    HANDLE Handle;
    //
    // Open options
    //
    ACCESS_MASK DesiredAccess;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;

    PSR_DEVICE_EXTENSION pExtension;

} SR_OPEN_CONTEXT, *PSR_OPEN_CONTEXT;

//
// Note : These api can be called only when the FileSystem
// is online and it is safe to read/write data.
//


VOID
SrPackString(
    IN PBYTE pBuffer,
    IN DWORD BufferSize,
    IN DWORD RecordType,
    IN PUNICODE_STRING pString
    );

NTSTATUS
SrPackLogHeader( 
    IN PSR_LOG_HEADER *ppLogHeader,
    IN PUNICODE_STRING pVolumePath
    );

NTSTATUS
SrPackAclInformation( 
    IN PBYTE                pBuffer,
    IN PSECURITY_DESCRIPTOR pSecInfo,
    IN ULONG                SecInfoSize,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN BOOLEAN              bInline
    );

VOID
SrLoggerFlushDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SrLoggerFlushWorkItem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
SrLoggerAddLogContext( 
    IN PSR_LOGGER_CONTEXT pLoggerInfo,
    IN PSR_LOG_CONTEXT pLogContext
    );

NTSTATUS
SrLoggerRemoveLogContext( 
    IN PSR_LOGGER_CONTEXT pLoggerInfo,
    IN PSR_LOG_CONTEXT pLogContext
    );

NTSTATUS
SrLogOpen( 
    IN PSR_LOG_CONTEXT pLogContext
    );

NTSTATUS
SrLogClose(
    IN PSR_LOG_CONTEXT pLogContext
    );

NTSTATUS
SrLogCheckAndRename(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pLogPath
    );

NTSTATUS
SrpLogWriteSynchronous( 
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_LOG_CONTEXT pLogContext,
    IN PSR_LOG_ENTRY pLogEntry
    );

#ifndef SYNC_LOG_WRITE
NTSTATUS
SrpLogWriteAsynchronous( 
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_LOG_CONTEXT pLogContext,
    IN PSR_LOG_ENTRY pLogEntry
    );
#endif

NTSTATUS
SrLogFlush ( 
    IN PSR_LOG_CONTEXT pLogContext
    );

NTSTATUS
SrLogSwitch( 
    IN PSR_LOG_CONTEXT  pLogContext
    );

NTSTATUS 
SrGetRestorePointPath(
    IN  PUNICODE_STRING pVolumeName,
    IN  USHORT          RestPtPathLength,
    OUT PUNICODE_STRING pRestPtPath
    );

NTSTATUS 
SrGetAclFileName(
    IN  PUNICODE_STRING pVolumeName,
    IN  USHORT          AclFileNameLength,
    OUT PUNICODE_STRING pAclFileName
    );

NTSTATUS
SrCreateFile( 
    IN PSR_OPEN_CONTEXT pOpenContext
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrPackString              )
#pragma alloc_text( PAGE, SrPackLogEntry            )
#pragma alloc_text( PAGE, SrPackLogHeader           )
#pragma alloc_text( PAGE, SrPackDebugInfo           )
#pragma alloc_text( PAGE, SrPackAclInformation      )
#pragma alloc_text( PAGE, SrLoggerStart             )
#pragma alloc_text( PAGE, SrLoggerStop              )
#pragma alloc_text( PAGE, SrLoggerFlushWorkItem     )
#pragma alloc_text( PAGE, SrLoggerAddLogContext     )
#pragma alloc_text( PAGE, SrLoggerRemoveLogContext  )
#pragma alloc_text( PAGE, SrLoggerSwitchLogs        )
#pragma alloc_text( PAGE, SrCreateFile              )
#pragma alloc_text( PAGE, SrLogOpen                 )
#pragma alloc_text( PAGE, SrLogClose                )
#pragma alloc_text( PAGE, SrLogCheckAndRename       )
#pragma alloc_text( PAGE, SrLogStart                ) 
#pragma alloc_text( PAGE, SrLogStop                 ) 
#pragma alloc_text( PAGE, SrLogFlush                )

#ifdef SYNC_LOG_WRITE
#pragma alloc_text( PAGE, SrpLogWriteSynchronous    )
#else
#pragma alloc_text( PAGE, SrpLogWriteAsynchronous   )
#endif

#pragma alloc_text( PAGE, SrLogFlush                )
#pragma alloc_text( PAGE, SrLogWrite                )
#pragma alloc_text( PAGE, SrLogSwitch               )
#pragma alloc_text( PAGE, SrGetRestorePointPath     )
#pragma alloc_text( PAGE, SrGetLogFileName          )
#pragma alloc_text( PAGE, SrGetAclFileName          )
#pragma alloc_text( PAGE, SrGetAclInformation       )

#endif  // ALLOC_PRAGMA

/////////////////////////////////////////////////////////////////////
//
// Packing/Marshaling Routines : Marshals information into records
//
/////////////////////////////////////////////////////////////////////

//++
// Function:
//        SrPackString
//
// Description:
//        This function packs a string into a record.
//
// Arguments:
//        Pointer to memory to create the entry
//        Size of memory
//        Entry type
//        Pointer to unicode string
//
// Return Value:
//        None
//--

static
VOID
SrPackString(
    IN PBYTE pBuffer,
    IN DWORD BufferSize,
    IN DWORD RecordType,
    IN PUNICODE_STRING pString
    )
{
    PRECORD_HEADER pHeader = (PRECORD_HEADER)pBuffer;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( BufferSize );

    ASSERT( pBuffer );
    ASSERT( pString );

    pHeader->RecordSize = STRING_RECORD_SIZE( pString );

    ASSERT( pHeader->RecordSize <= BufferSize );

    pHeader->RecordType = RecordType;

    //
    // Copy string contents
    //

    RtlCopyMemory( pBuffer + sizeof(RECORD_HEADER),
                   pString->Buffer,
                   pString->Length );

    //
    // Add null terminator
    //

    *(PWCHAR)( pBuffer + sizeof(RECORD_HEADER) + pString->Length ) = UNICODE_NULL;
}   // SrPackString

//++
// Function:
//        SrPackLogEntry
//
// Description:
//  This function allocates and fills a SR_LOG_ENTRY structure.  The
//  caller is responsible for freeing the memory returned in ppLogEntry.
//
// Arguments:
//      ppLogEntry - Pointer to a SR_LOG_ENTRY pointer.  This gets set to the
//          the log entry structure that is allocated and initialized by this
//          routine.
//      EntryType - The type of log entry this is.
//      Attributes - The attributes for this file.
//      SequenceNum - The sequence number for this log entry.
//      pAclInfo - The ACL information for the file being modified, if needed.
//      AclInfoSize - The size in bytes of pAclInfo, if needed.
//      pDebugBlob - The debug blob to log, if needed.
//      pPath1 - The first full path for the file or dir that this log entry
//          pertains to, if needed.
//      Path1StreamLength - The length of the stream component of the name
//          in pPath1, if needed.
//      pTempPath - The path to the temporary file in the restore location,
//          if needed.
//      pPath2 - The second full path for the file or dir that this log entry
//          pertains to, if needed.
//      Path2StreamLength - The length of the stream component of the name
//          in pPath2, if needed.
//      pExtension - The SR device extension for this volume.
//      pShortName - The short name for the file or dir that this log entry
//          pertains to, if needed.
//
// Return Value:
//      This function returns STATUS_INSUFFICIENT_RESOURCES if it cannot
//      allocate a log entry record large enough to store this entry.
//
//      If there is a problem getting the ACL info, that error status is
//      returned.
//
//      If one of the parameters is ill-formed, STATUS_INVALID_PARAMETER
//      is returned.
//
//      Otherwise, STATUS_SUCCESS is returned.
//--

NTSTATUS
SrPackLogEntry( 
    OUT PSR_LOG_ENTRY *ppLogEntry,
    IN ULONG EntryType,
    IN ULONG Attributes,
    IN INT64 SequenceNum,
    IN PSECURITY_DESCRIPTOR pAclInfo OPTIONAL,
    IN ULONG AclInfoSize OPTIONAL,
    IN PVOID pDebugBlob OPTIONAL,
    IN PUNICODE_STRING pPath1,
    IN USHORT Path1StreamLength,
    IN PUNICODE_STRING pTempPath OPTIONAL,
    IN PUNICODE_STRING pPath2 OPTIONAL,
    IN USHORT Path2StreamLength OPTIONAL,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pShortName OPTIONAL
    )
{
    NTSTATUS    Status     = STATUS_UNSUCCESSFUL;
    DWORD       Size       = 0;
    DWORD       RequiredSize = 0;
    DWORD       RecordSize = 0;
    PBYTE       pLoc       = NULL;
    DWORD       EntryFlags = 0;
    BOOLEAN     bAclInline = TRUE;
    PUCHAR      pBuffer = NULL;
    PUNICODE_STRING pVolumeName;
    PSR_LOG_DEBUG_INFO pDebugInfo = (PSR_LOG_DEBUG_INFO) pDebugBlob;

    //
    //  Unicode strings used for string manipulation.
    //
    
    UNICODE_STRING Path1Fix;
    UNICODE_STRING TempPathFix;
    UNICODE_STRING Path2Fix;

    PAGED_CODE();

    ASSERT( pPath1 != NULL );
    ASSERT( pExtension != NULL );
    ASSERT( ppLogEntry != NULL );
    
    pVolumeName = pExtension->pNtVolumeName;
    ASSERT( pVolumeName != NULL );

    // ====================================================================
    //
    //  Prepare the necessary fields for the log entry.
    //
    // ====================================================================

    //
    //  Remove the volume prefix from pPath1 and add the stream name to the
    //  visible portion of the name, if there is one.
    //

    ASSERT( RtlPrefixUnicodeString( pVolumeName, pPath1, FALSE ) );
    ASSERT( IS_VALID_SR_STREAM_STRING( pPath1, Path1StreamLength ) );
    
    Path1Fix.Length = Path1Fix.MaximumLength = (pPath1->Length + Path1StreamLength) - pVolumeName->Length;
    Path1Fix.Buffer = (PWSTR)((PBYTE)pPath1->Buffer + pVolumeName->Length);

    //
    //  Find the file name component of the pTempPath if that was passed in.
    //
    
    if (pTempPath != NULL)
    {
        PWSTR pFileName = NULL;
        ULONG FileNameLength;

        Status = SrFindCharReverse( pTempPath->Buffer,
                                    pTempPath->Length,
                                    L'\\',
                                    &pFileName,
                                    &FileNameLength );

        if (!NT_SUCCESS( Status ))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto SrPackLogEntry_Exit;
        }

        ASSERT( pFileName != NULL );

        //
        //  Move past the leading '\\'
        //

        pFileName++;
        FileNameLength -= sizeof( WCHAR );
        
        TempPathFix.Length = TempPathFix.MaximumLength = (USHORT) FileNameLength;
        TempPathFix.Buffer = pFileName;
    }

    //
    //  Remove the volume prefix from pPath2 if that was provided.  Also, add
    //  the stream component to the visible portion of the name, if there
    //  is a stream component.
    //

    if (pPath2 != NULL)
    {
        ASSERT( IS_VALID_SR_STREAM_STRING( pPath2, Path2StreamLength ) );

        if (RtlPrefixUnicodeString( pVolumeName,
                                    pPath2,
                                    FALSE ))
        {
            Path2Fix.Length = Path2Fix.MaximumLength = (pPath2->Length + Path2StreamLength) - pVolumeName->Length;
            Path2Fix.Buffer = (PWSTR)((PBYTE)pPath2->Buffer + pVolumeName->Length);
        }
        else
        {
            Path2Fix.Length = Path2Fix.MaximumLength = (pPath2->Length + Path2StreamLength);
            Path2Fix.Buffer = pPath2->Buffer;
        }
    }

    // ====================================================================
    //
    //  Calculate the total size needed for the log entry based on the 
    //  components that we must log.
    //
    // ====================================================================

    //  First, account for the SR_LOG_ENTRY header.
    
    RequiredSize = FIELD_OFFSET(SR_LOG_ENTRY, SubRecords);

    //  Count pPath1
    RequiredSize += ( STRING_RECORD_SIZE(&Path1Fix) );

    //  Count pTempPath, if we've got one
    if (pTempPath)
    {
        RequiredSize += ( STRING_RECORD_SIZE(&TempPathFix) );
    }
    
    //  Count pPath2, if we've got one
    if (pPath2)
    {
        RequiredSize += ( STRING_RECORD_SIZE(&Path2Fix) );
    }
    
    //  Count pAclInfo, if we've got one.  At this point, we assume that the
    //  Acl will be stored inline.
    if( pAclInfo )
    {
        RequiredSize += SR_INLINE_ACL_SIZE( AclInfoSize );
    }

    //  Count pDebugInfo, if we've got any
    if (pDebugInfo)
    {
        RequiredSize += pDebugInfo->Header.RecordSize;
    }

    //  Count pShortName, if we've got one
    if (pShortName != NULL && pShortName->Length > 0)
    {
        RequiredSize += ( STRING_RECORD_SIZE(pShortName) );
    }

    //
    // increment the size to accomodate the entry size at the end
    //

    RequiredSize += sizeof(DWORD);

    // ====================================================================
    //
    //  Check if we meet the buffer size requirements and initialize the 
    //  record if we do.
    //
    // ====================================================================

    //
    //  First, determine if we should keep the AclInfo inline or not.
    //

    if (SR_INLINE_ACL_SIZE( AclInfoSize ) > SR_MAX_INLINE_ACL_SIZE)
    {
        SrTrace( LOG, ("SR!Changing Acl to Non-resident form\n"));
        bAclInline = FALSE;
        RequiredSize -= SR_INLINE_ACL_SIZE( AclInfoSize );
        RequiredSize += SR_FILE_ACL_SIZE( pVolumeName );
    }

    //
    //  Now allocate the buffer that will hold the log entry.
    //

    pBuffer = SrAllocateLogEntry( RequiredSize );

    if (pBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SrPackLogEntry_Exit;
    }
    
    // ====================================================================
    //
    //  We've got a big enough LogEntry, so now properly fill the LogEntry.
    //
    // ====================================================================

    //
    // Initialize the static part of SR_LOG_ENTRY
    //

    RtlZeroMemory( pBuffer, RequiredSize );

    //
    // StreamOverwrite should be StreamChange
    //

    if (EntryType == SrEventStreamOverwrite)
    {
        EntryType = SrEventStreamChange;
    }

    ((PSR_LOG_ENTRY) pBuffer)->MagicNum    = SR_LOG_MAGIC_NUMBER;  
    ((PSR_LOG_ENTRY) pBuffer)->EntryType   = EntryType;  
    ((PSR_LOG_ENTRY) pBuffer)->EntryFlags  = EntryFlags;  
    ((PSR_LOG_ENTRY) pBuffer)->Attributes  = Attributes;  
    ((PSR_LOG_ENTRY) pBuffer)->SequenceNum = SequenceNum;  

    Size = FIELD_OFFSET( SR_LOG_ENTRY, SubRecords );
    
    //
    // add first filename string
    //

    pLoc = pBuffer + Size; 
    RecordSize = STRING_RECORD_SIZE( &Path1Fix );

    SrPackString( pLoc,
                  RecordSize,
                  RecordTypeFirstPath,
                  &Path1Fix );

    Size += RecordSize;

    //
    // add temp filename if passed
    //

    if( pTempPath )
    {
        pLoc = pBuffer + Size; 
        RecordSize = STRING_RECORD_SIZE( &TempPathFix );

        SrPackString( pLoc,
                      RecordSize,
                      RecordTypeTempPath,
                      &TempPathFix );
        ((PSR_LOG_ENTRY) pBuffer)->EntryFlags |= ENTRYFLAGS_TEMPPATH;   
        
        Size += RecordSize;
    }

    //
    // add second filename string if passed in
    //

    if( pPath2 )
    {
        pLoc = pBuffer + Size;
        RecordSize = STRING_RECORD_SIZE( &Path2Fix );

        SrPackString( pLoc,
                      RecordSize,
                      RecordTypeSecondPath,
                      &Path2Fix );
        ((PSR_LOG_ENTRY) pBuffer)->EntryFlags |= ENTRYFLAGS_SECONDPATH;   

        Size += RecordSize;
    }


    //
    // Pack and add the Acl information appropriately
    //

    if( pAclInfo )
    {
        pLoc = pBuffer + Size; 

        Status = SrPackAclInformation( pLoc,
                                       pAclInfo,
                                       AclInfoSize,
                                       pExtension,
                                       bAclInline );

        if (!NT_SUCCESS( Status ))
            goto SrPackLogEntry_Exit;

        ((PSR_LOG_ENTRY) pBuffer)->EntryFlags |= ENTRYFLAGS_ACLINFO;   

        if (bAclInline)
        {
            Size += SR_INLINE_ACL_SIZE( AclInfoSize );
        }
        else
        {
            Size += SR_FILE_ACL_SIZE( pVolumeName );
        }
    }

    //
    // Pack debug info if passed in
    //

    if (pDebugBlob)
    {
        pLoc = pBuffer + Size; 

        RtlCopyMemory( pLoc,
                       pDebugInfo,
                       pDebugInfo->Header.RecordSize );
        ((PSR_LOG_ENTRY) pBuffer)->EntryFlags |= ENTRYFLAGS_DEBUGINFO;  

        Size += pDebugInfo->Header.RecordSize;
    }

    //
    // pack and add the short name, if supplied
    //

    if (pShortName != NULL && pShortName->Length > 0)
    {
        pLoc = pBuffer + Size; 
        RecordSize = STRING_RECORD_SIZE( pShortName );

        SrPackString( pLoc,
                      RecordSize,
                      RecordTypeShortName,
                      pShortName );
        ((PSR_LOG_ENTRY) pBuffer)->EntryFlags |= ENTRYFLAGS_SHORTNAME;

        Size += RecordSize;
    }

    //
    // increment the size to accomodate the entry size at the end
    //

    Size += sizeof(DWORD);

    //
    // fill in the header fields : record size, record type and
    // update the size at the end
    //

    ((PSR_LOG_ENTRY) pBuffer)->Header.RecordSize = Size;  
    ((PSR_LOG_ENTRY) pBuffer)->Header.RecordType = RecordTypeLogEntry;  

    UPDATE_END_SIZE( pBuffer, Size );

    *ppLogEntry = (PSR_LOG_ENTRY) pBuffer;
    Status = STATUS_SUCCESS;

SrPackLogEntry_Exit:
    
    RETURN(Status);
}   // SrPackLogEntry

//++
// Function:
//        SrPackLogHeader
//
// Description:
//      This function creates a proper SR_LOG_HEADER entry.  It allocates
//      the LogEntry structure so that it is big enough to store this header.
//
//      Note: The caller is responsible for freeing the SR_LOG_ENTRY allocated.
//
// Arguments:
//      ppLogHeader - Pointer to the PSR_LOG_HEADER that get set to the
//          allocated log header address.
//      pVolumePath - The volume path for this volume.
//
// Return Value:
//        Returns STATUS_INSUFFICIENT_RESOURCES if the SR_LOG_ENTRY cannot
//        be allocated.  Otherwise, it returns STATUS_SUCCESS.
//--

NTSTATUS
SrPackLogHeader( 
    IN PSR_LOG_HEADER *ppLogHeader,
    IN PUNICODE_STRING pVolumePath
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    DWORD    RequiredSize = 0;
    DWORD    SubRecordSize = 0;
    DWORD    Size   = 0;
    PBYTE    pLoc   = NULL;
    PBYTE    pBuffer = NULL;

    PAGED_CODE();

    ASSERT( ppLogHeader != NULL );
    ASSERT( pVolumePath != NULL );

    // ====================================================================
    //
    //  First, figure out how much of the buffer we need to use.
    //
    // ====================================================================

    RequiredSize = FIELD_OFFSET(SR_LOG_HEADER, SubRecords);

    //  Count the volume path.
    RequiredSize += ( STRING_RECORD_SIZE(pVolumePath) );

    //  Increment the size to accomodate the LogHeader size at the end
    RequiredSize += sizeof(DWORD);

    // ====================================================================
    //
    //  Second, make sure that the buffer passed in is large enough for
    //  the LogHeader.
    //
    // ====================================================================

    Size = FIELD_OFFSET(SR_LOG_HEADER, SubRecords);

    pBuffer = SrAllocateLogEntry( RequiredSize );

    if (pBuffer == NULL)
    {
        //
        // Not enough memory to pack the entry
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SrPackLogHeader_Exit;
    }

    //
    // Initialize the static part of SR_LOG_HEADER
    //

    RtlZeroMemory( pBuffer, RequiredSize );

    ((PSR_LOG_HEADER) pBuffer)->MagicNum    = SR_LOG_MAGIC_NUMBER ;        
    ((PSR_LOG_HEADER) pBuffer)->LogVersion  = SR_LOG_VERSION      ;

    // ====================================================================
    //
    //  Finally, the buffer is large enough for the LogHeader, so fill
    //  the buffer with the header.
    //
    // ====================================================================
    
    Size = FIELD_OFFSET(SR_LOG_HEADER, SubRecords);

    //
    //  Add the volume prefix
    //

    pLoc = (PBYTE)(&((PSR_LOG_HEADER)pBuffer)->SubRecords);
    SubRecordSize = STRING_RECORD_SIZE( pVolumePath );

    SrPackString( pLoc,
                  SubRecordSize,
                  RecordTypeVolumePath,
                  pVolumePath );
    Size += SubRecordSize;

    //
    //  Increment the size to accomodate the LogHeader size at the end
    //

    Size += sizeof(DWORD);

    //
    // Fill in the header fields : record size, record type and
    // update the size at the end
    //

    ASSERT( RequiredSize == Size );
    
    ((PSR_LOG_HEADER) pBuffer)->Header.RecordSize = Size;  
    ((PSR_LOG_HEADER) pBuffer)->Header.RecordType = RecordTypeLogHeader;  

    UPDATE_END_SIZE( pBuffer, Size );

    *ppLogHeader = (PSR_LOG_HEADER) pBuffer;
    Status = STATUS_SUCCESS;

SrPackLogHeader_Exit:
    
    RETURN( Status );
}   // SrPackLogHeader

//++
// Function:
//        SrPackDebugInfo
//
// Description:
//        This function creates a properly formatted debug info from
//        the supplied data. if NULL is passed instead of the buffer
//        then the API returns the size required to pack the entry.
//
// Arguments:
//        Pointer to log entry buffer
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrPackDebugInfo( 
    IN PBYTE  pBuffer,
    IN DWORD  BufferSize
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    DWORD    Size   = 0;
    PCHAR pStr;
    PEPROCESS peProcess;

    PAGED_CODE();

    ASSERT( pBuffer != NULL );

    Size = sizeof(SR_LOG_DEBUG_INFO);

    if (BufferSize < Size)
    {
        //
        // Not enough memory to pack the entry
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SrPackDebugInfo_Exit;
    }

    //
    // fill in the header fields : record size, record type
    //

    ((PSR_LOG_DEBUG_INFO)pBuffer)->Header.RecordSize = Size;
    ((PSR_LOG_DEBUG_INFO)pBuffer)->Header.RecordType = 
                                          RecordTypeDebugInfo;

    ((PSR_LOG_DEBUG_INFO)pBuffer)->ThreadId  = PsGetCurrentThreadId() ;
    ((PSR_LOG_DEBUG_INFO)pBuffer)->ProcessId = PsGetCurrentProcessId();

    pStr = ((PSR_LOG_DEBUG_INFO)pBuffer)->ProcessName;
    
    *pStr = 0;

    peProcess = PsGetCurrentProcess();
    
    RtlCopyMemory( pStr, 
                   ((PBYTE)peProcess) + global->ProcNameOffset, 
                   PROCESS_NAME_MAX );

    pStr[ PROCESS_NAME_MAX ] = 0;

    Status = STATUS_SUCCESS;

SrPackDebugInfo_Exit:
    
    RETURN(Status);
}   // SrPackDebugInfo

//++
// Function:
//        SrPackAclInformation
//
// Description:
//        This function creates a properly formatted Acl record from
//        the supplied data. 
//
// Arguments:
//        Pointer to log entry buffer
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrPackAclInformation( 
    IN PBYTE                pBuffer,
    IN PSECURITY_DESCRIPTOR pSecInfo,
    IN ULONG                SecInfoSize,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN BOOLEAN              bInline
    )
{
    NTSTATUS Status              = STATUS_UNSUCCESSFUL;
    PRECORD_HEADER pHeader       = (PRECORD_HEADER)pBuffer;
    PUNICODE_STRING pAclFileName = NULL;
    HANDLE AclFileHandle         = NULL;
    PUNICODE_STRING pVolumeName;

    PAGED_CODE();

    ASSERT( pExtension != NULL );
    
    pVolumeName = pExtension->pNtVolumeName;
    ASSERT( pVolumeName != NULL );

    try
    {
        ASSERT( pBuffer     != NULL );
        ASSERT( pSecInfo    != NULL );
        ASSERT( SecInfoSize != 0    );
    
        //
        // CODEWORK: Convert ACL to Self contained form ??
        //
    
        if (bInline)
        {
            //
            // Just format and put the contents into the buffer
            //
    
            pHeader->RecordSize = sizeof( RECORD_HEADER ) + 
                                  SecInfoSize;  
    
            pHeader->RecordType = RecordTypeAclInline;
    
            RtlCopyMemory( pBuffer + sizeof(RECORD_HEADER),
                           pSecInfo,
                           SecInfoSize );
    
            Status = STATUS_SUCCESS;
        }
        else
        {
            SR_OPEN_CONTEXT     OpenContext;
            IO_STATUS_BLOCK     IoStatusBlock;
    
            //
            // Write the contents out to a temp file and create a 
            // AclFile record.
            //
    
            Status = SrAllocateFileNameBuffer( SR_MAX_FILENAME_LENGTH, 
                                               &pAclFileName );
                                               
            if (!NT_SUCCESS( Status ))
                leave;
    
            Status = SrGetAclFileName( pVolumeName, 
                                       SR_FILENAME_BUFFER_LENGTH,
                                       pAclFileName );
    
            if (!NT_SUCCESS( Status ))
                leave;
    
            //
            // Open Acl file and write the security info in that file
            //
            OpenContext.pPath  = pAclFileName;
            OpenContext.Handle = NULL;
            OpenContext.DesiredAccess = FILE_GENERIC_WRITE | SYNCHRONIZE;
            OpenContext.FileAttributes = FILE_ATTRIBUTE_NORMAL;
            OpenContext.ShareAccess = 0;
            OpenContext.CreateDisposition = FILE_OVERWRITE_IF;                  // OPEN always
            OpenContext.CreateOptions = /*FILE_NO_INTERMEDIATE_BUFFERING |*/ 
                                          FILE_WRITE_THROUGH |
                                          FILE_SYNCHRONOUS_IO_NONALERT;
            OpenContext.pExtension = pExtension;
    
            Status =  SrPostSyncOperation(SrCreateFile,
                                          &OpenContext);
    
            if (NT_SUCCESS(Status))
            {
                LARGE_INTEGER Offset;
    
                ASSERT(OpenContext.Handle != NULL);
                
                AclFileHandle = OpenContext.Handle;

                Offset.QuadPart = 0;
    
                Status = ZwWriteFile( AclFileHandle,
                                      NULL,                      // Event
                                      NULL,                      // ApcRoutine 
                                      NULL,                      // ApcContext 
                                      &IoStatusBlock,
                                      pSecInfo,
                                      SecInfoSize,
                                      &Offset,                   // ByteOffset
                                      NULL );                    // Key
    
                if (NT_SUCCESS(Status))
                {
                    //
                    // Create AclFile type entry
                    //
                                        
                    SrPackString( pBuffer,
                                  STRING_RECORD_SIZE( pAclFileName ),
                                  RecordTypeAclFile,
                                  pAclFileName );
                }
            } else {
                ASSERT(OpenContext.Handle == NULL);
            }
        }
    }
    finally
    {
        if (pAclFileName != NULL) 
        {
            SrFreeFileNameBuffer( pAclFileName );
            pAclFileName = NULL;
        }
    
        if (AclFileHandle != NULL)
        {
            ZwClose(AclFileHandle);
            AclFileHandle = NULL;
        }
    }

    RETURN(Status);
    
}   // SrPackAclInformation




/////////////////////////////////////////////////////////////////////
//
// Logger Routines : Manipulate Logger object
//
/////////////////////////////////////////////////////////////////////

//++
// Function:
//        SrLoggerStart
//
// Description:
//        This function initializes the logger and enables the flushing
//      routines.
//
// Arguments:
//      PDEVICE_OBJECT    pDeviceObject
//      PSR_LOGGER_CONTEXT * pLogger
//
// Return Value:
//        STATUS_XXX
//--

NTSTATUS
SrLoggerStart(
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PSR_LOGGER_CONTEXT * ppLogger
    )
{
    NTSTATUS            Status;
    PSR_LOGGER_CONTEXT  pInitInfo = NULL;
    PIO_WORKITEM        pWorkItem = NULL;
    
    UNREFERENCED_PARAMETER( pDeviceObject );

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));
    ASSERT(ppLogger != NULL);

    PAGED_CODE();

    try 
    {

        Status = STATUS_SUCCESS;
    
        *ppLogger = NULL;
    
        //
        //  Allocate Logging Init info from NonPagedPool
        //
    
        pInitInfo = SR_ALLOCATE_STRUCT( NonPagedPool, 
                                        SR_LOGGER_CONTEXT,
                                        SR_LOGGER_CONTEXT_TAG );
    
        if (pInitInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
    
        RtlZeroMemory( pInitInfo, sizeof( SR_LOGGER_CONTEXT ) );

        pInitInfo->Signature = SR_LOGGER_CONTEXT_TAG;
        pInitInfo->ActiveContexts = 0;
        
#ifdef USE_LOOKASIDE

        //
        // Initialize Lookaside list used in logging module
        //
    
        ExInitializeNPagedLookasideList( &pInitInfo->LogBufferLookaside,
                                         NULL,                          
                                         NULL,                          
                                         0,                             
                                         _globals.LogBufferSize,           
                                         SR_LOG_BUFFER_TAG,         
                                         0 );                       

#endif

    
#ifndef SYNC_LOG_WRITE

        //
        // Allocate work item for the DPC
        //
        pWorkItem = IoAllocateWorkItem(global->pControlDevice);
        if (pWorkItem == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
        
        //
        // Initialize Dpc and timer object
        //
    
        KeInitializeTimer( &pInitInfo->Timer );
   
        KeInitializeDpc  ( &pInitInfo->Dpc,
                           SrLoggerFlushDpc,
                           pWorkItem );
    
        //
        // Start the timer for log flushing 
        //
    
        KeSetTimer( &pInitInfo->Timer,
                    global->LogFlushDueTime,
                    &pInitInfo->Dpc );

#endif
    
        *ppLogger = pInitInfo;

    } finally {

        Status = FinallyUnwind(SrLoggerStart, Status);
    
        if (!NT_SUCCESS( Status ))
        {
            if (pInitInfo != NULL) {
                SrLoggerStop( pInitInfo );
            }
            *ppLogger = pInitInfo = NULL;
            if (pWorkItem != NULL) {
                IoFreeWorkItem(pWorkItem);
            }
            pWorkItem = NULL;
        }
    }

    RETURN(Status);
    
}   // SrLoggerStart

//++
// Function:
//        SrLoggerStop
//
// Description:
//        This function stops the logger and frees the related resources
//
// Arguments:
//      LoggerInfo pointer
//
// Return Value:
//        STATUS_XXX
//--
//++

NTSTATUS
SrLoggerStop( 
    IN PSR_LOGGER_CONTEXT pLogger
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    ASSERT(IS_VALID_LOGGER_CONTEXT(pLogger));

    try {
    
        //
        // Stop the timer routines
        //

        KeCancelTimer( &pLogger->Timer );

        //
        // Active log contexts must be zero other wise we are leaking
        //

        ASSERT( pLogger->ActiveContexts == 0 );

#ifdef USE_LOOKASIDE

        //
        // Free the lookaside lists
        //

        if (IS_LOOKASIDE_INITIALIZED(&pLogger->LogEntryLookaside))
        {
            ExDeletePagedLookasideList(
                &pLogger->LogEntryLookaside);
        }

        if (IS_LOOKASIDE_INITIALIZED(&pLogger->LogBufferLookaside))
        {
            ExDeleteNPagedLookasideList(
                &pLogger->LogBufferLookaside);
        }
        
#endif

        SR_FREE_POOL_WITH_SIG( pLogger, SR_LOGGER_CONTEXT_TAG );

        Status = STATUS_SUCCESS;
    } finally {
    
        Status = FinallyUnwind(SrLoggerStop, Status);
        
    }

    RETURN(Status);
    
}   // SrLoggerStop

#ifndef SYNC_LOG_WRITE

//++
// Function:
//        SrLoggerFlushDpc
//
// Description:
//        This function is a DPC called to flush the log buffers. This will
//      queue a workitem to flush the buffers. This should not be paged.
//
// Arguments:
//      IN PKDPC Dpc 
//      IN PVOID DeferredContext 
//      IN PVOID SystemArgument1 
//      IN PVOID SystemArgument2
//
// Return Value:
//        None
//--

VOID
SrLoggerFlushDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PIO_WORKITEM  pSrWorkItem;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    SrTrace( LOG, ("SR!SrLoggerFlushDpc Called...\n"));

    pSrWorkItem = (PIO_WORKITEM) DeferredContext;

    ASSERT(pSrWorkItem != NULL);

    IoQueueWorkItem( pSrWorkItem,
                     SrLoggerFlushWorkItem,
                     DelayedWorkQueue,
                     pSrWorkItem );

}   // SrLoggerFlushDpc

//++
// Function:
//        SrLoggerFlushWorkItem
//
// Description:
//        This Workitem queued by DPC will actually flush the log buffers.
//
// Arguments:
//      IN PDEVICE_OBJECT DeviceObject 
//      IN PVOID Context
//
// Return Value:
//        None
//--

VOID
SrLoggerFlushWorkItem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    NTSTATUS        Status;
    PLIST_ENTRY     pListEntry;
    
    PSR_DEVICE_EXTENSION pExtension;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Context);

    SrTrace(LOG, ("sr!SrLoggerFlushWorkItem: enter\n"));

    try {

        //
        // Grab the DeviceExtensionListLock as we are about to 
        // iterate through this list.  Since we are only going to be
        // reading this list, we can get this lock shared.
        //

        SrAcquireDeviceExtensionListLockShared();
        
        Status = STATUS_SUCCESS;

#if DBG
        //
        // sleep for twice the DPC interval to prove that 2 DPC's
        // are not coming in at the same time
        //
        
        if (global->DebugControl & SR_DEBUG_DELAY_DPC)
        {
            LARGE_INTEGER Interval;
            
            Interval.QuadPart = -1 * (10 * NANO_FULL_SECOND);
            KeDelayExecutionThread(KernelMode, TRUE, &Interval);
        }
#endif

        ASSERT( global->pLogger != NULL );

        //
        // loop over all volumes flushing data to the disk.
        //

        
        for (pListEntry = global->DeviceExtensionListHead.Flink;
             pListEntry != &global->DeviceExtensionListHead;
             pListEntry = pListEntry->Flink)
        {
            pExtension = CONTAINING_RECORD( pListEntry,
                                            SR_DEVICE_EXTENSION,
                                            ListEntry );
            
            ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

            //
            //  Do a quick unsafe check to see if we have started logging this 
            //  volume yet.  If it appears we haven't, just continue onto the 
            //  next entry in the list.  If logging is just about to begin,
            //  we catch it on the next firing of this timer.
            //

            if (pExtension->pLogContext == NULL) {

                continue;
            }

            //
            //  It looks like we have started to log, so get the necessary
            //  locks and do our work to flush the volume.
            //

            try {

                SrAcquireActivityLockExclusive( pExtension );
                
                if (pExtension->pLogContext != NULL)
                {
                    //
                    // yes, flush for this volume
                    //
                    
                    Status = SrLogFlush( pExtension->pLogContext );

                    if (!NT_SUCCESS( Status ))
                    {
                        //
                        // Disable volume
                        //

                        Status = SrNotifyVolumeError( pExtension,
                                                      pExtension->pLogContext->pLogFilePath,
                                                      Status,
                                                      SrEventVolumeError );
                        //
                        // Stop Logging
                        //

                        SrLogStop( pExtension, TRUE, TRUE );
                    }
                }
            } finally {

                SrReleaseActivityLock( pExtension );
            }
        }
        
    } finally {

        Status = FinallyUnwind(SrLoggerFlushWorkItem, Status);

        //
        // fire the timer again, do this with the global lock 
        // held so that it can be cancelled in SrLoggerStop.
        //

        //
        // The DPC is going to reuse the work item
        //
        KeSetTimer( &global->pLogger->Timer,
                    global->LogFlushDueTime,
                    &global->pLogger->Dpc );
        
        SrReleaseDeviceExtensionListLock();
    }
        
    SrTrace(LOG, ("sr!SrLoggerFlushWorkItem: exit\n"));

}   // SrLoggerFlushWorkItem

#endif

//++
// Function:
//        SrLoggerAddLogContext
//
// Description:
//        This function adds a given Log Context to the logger
//
// Arguments:
//      pointer to LoggerInfo
//      pointer to LogContext
//
// Return Value:
//        STATUS_XXX    
//--

VOID
SrLoggerAddLogContext( 
    IN PSR_LOGGER_CONTEXT pLogger,
    IN PSR_LOG_CONTEXT pLogContext
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( pLogContext );
    ASSERT(IS_VALID_LOGGER_CONTEXT(pLogger));
    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));


    InterlockedIncrement(&pLogger->ActiveContexts);

}   // SrLoggerAddLogContext
    
//++
// Function:
//        SrLoggerRemoveLogContext
//
// Description:
//        This Workitem queued by DPC will actually flush the log buffers.
//
// Arguments:
//      pointer to LoggerInfo
//      pointer to LogContext
//
// Return Value:
//        STATUS_XXX    
//--

NTSTATUS
SrLoggerRemoveLogContext( 
    IN PSR_LOGGER_CONTEXT pLogger,
    IN PSR_LOG_CONTEXT pLogContext
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( pLogContext );
    ASSERT(IS_VALID_LOGGER_CONTEXT(pLogger));
    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));
   
    InterlockedDecrement(&pLogger->ActiveContexts);

    Status = STATUS_SUCCESS;
        

    RETURN(Status);
    
}   // SrLoggerRemoveLogContext


//++
// Function:
//        SrLoggerSwitchLogs
//
// Description:
//        This function loops thru the log contexts and switches all the
//      log contexts
//
// Arguments:
//      pointer to LoggerInfo
//
// Return Value:
//        STATUS_XXX    
//--

NTSTATUS
SrLoggerSwitchLogs( 
    IN PSR_LOGGER_CONTEXT pLogger
    )
{
    NTSTATUS        Status;
    PLIST_ENTRY     pListEntry;
    PSR_DEVICE_EXTENSION pExtension;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( pLogger );
    ASSERT(IS_VALID_LOGGER_CONTEXT(pLogger));

    Status = STATUS_SUCCESS;

    try {

        SrAcquireDeviceExtensionListLockShared();

        //
        // loop over all volumes switching their logs
        //

        for (pListEntry = _globals.DeviceExtensionListHead.Flink;
             pListEntry != &_globals.DeviceExtensionListHead;
             pListEntry = pListEntry->Flink)
        {
            pExtension = CONTAINING_RECORD( pListEntry,
                                            SR_DEVICE_EXTENSION,
                                            ListEntry );
            
            ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

            //
            //  We only have to do work if this is a volume device object,
            //  not if this is a device object that is attached to a file
            //  system's control device object.
            //
            
            if (FlagOn( pExtension->FsType, SrFsControlDeviceObject ))
            {
                continue;
            }
            
            try {

                SrAcquireActivityLockExclusive( pExtension );

                //
                // have we started logging on this volume? 
                //

                if (pExtension->pLogContext != NULL)
                {
                    //
                    // yes, switch for this volume
                    //
                    
                    Status = SrLogSwitch(pExtension->pLogContext);

                }
                else
                {
                    Status = SrLogNormalize( pExtension );
                }
                
                if (!NT_SUCCESS( Status ))
                {
                    //
                    // Disable volume
                    //

                    Status = SrNotifyVolumeError( pExtension,
                                                  NULL,
                                                  Status,
                                                  SrEventVolumeError );

                    if (pExtension->pLogContext != NULL)
                    {
                        //
                        // Stop Logging
                        //

                        SrLogStop( pExtension, TRUE, TRUE );
                    }
                }
            } finally {
            
                Status = FinallyUnwind(SrLoggerSwitchLogs, Status);
                SrReleaseActivityLock( pExtension );
            }
            
        }
        
    } finally {

        Status = FinallyUnwind(SrLoggerSwitchLogs, Status);
        SrReleaseDeviceExtensionListLock();
    }
    
    RETURN(Status);
    
}   // SrLoggerSwitchLogs


/////////////////////////////////////////////////////////////////////
//
// Log Routines : Manipulate individual Logs
//
/////////////////////////////////////////////////////////////////////


//++
// Function:
//        SrCreateFile
//
// Description:
//        This function just does a create on  file, no sync needed 
//        written so that it can be called in a separate thread to avoid
//        stack overflows via SrIoCreateFile
//
// Arguments:
// 
//        pOpenContext - pointer to the open context
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrCreateFile( 
    IN PSR_OPEN_CONTEXT pOpenContext
    )
{

    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            Status;

    PAGED_CODE();

    ASSERT(pOpenContext != NULL);
    ASSERT(pOpenContext->pPath != NULL);

    SrTrace(LOG, ("Opening file %wZ", pOpenContext->pPath));
  
    InitializeObjectAttributes( &ObjectAttributes,
                                pOpenContext->pPath,
                                OBJ_KERNEL_HANDLE, 
                                NULL,
                                NULL );

    ASSERT( pOpenContext->pExtension != NULL );

    Status = SrIoCreateFile( 
                 &pOpenContext->Handle,
                 pOpenContext->DesiredAccess,  
                 &ObjectAttributes,
                 &IoStatusBlock,
                 NULL,                               // AllocationSize
                 pOpenContext->FileAttributes,    
                 pOpenContext->ShareAccess,      
                 pOpenContext->CreateDisposition, 
                 pOpenContext->CreateOptions,     
                 NULL,                               // EaBuffer
                 0,                                  // EaLength
                 0,
                 pOpenContext->pExtension->pTargetDevice );
    
    return Status;
}

//++
// Function:
//        SrLogOpen
//
// Description:
//        This function creates a log file, no sync needed as it is always
//      called internally 
//
// Arguments:
//        Pointer to open context
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogOpen( 
    IN PSR_LOG_CONTEXT pLogContext
    )
{
    NTSTATUS            Status = STATUS_UNSUCCESSFUL;
    PSR_LOG_HEADER      pLogHeader = NULL;
    SR_OPEN_CONTEXT     OpenContext;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));
    ASSERT(pLogContext->pLogFilePath    != NULL );
    ASSERT(pLogContext->LogHandle == NULL );
    ASSERT(pLogContext->pLogFileObject == NULL);

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) );

    try
    {
        SrTrace(FUNC_ENTRY, ("SR!SrLogOpen\n"));
    
        //
        // Initialize the open context with the file create parameters
        //
        OpenContext.pPath  = pLogContext->pLogFilePath;;
        OpenContext.Handle = NULL;
        OpenContext.DesiredAccess = FILE_GENERIC_WRITE | 
                                    SYNCHRONIZE | 
                                    FILE_APPEND_DATA;
        OpenContext.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        OpenContext.ShareAccess = FILE_SHARE_READ;
        OpenContext.CreateDisposition = FILE_OVERWRITE_IF;                  // OPEN always
        OpenContext.CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;
        OpenContext.pExtension = pLogContext->pExtension;

        SrTrace(LOG, ("Opening Log in another thread %wZ", pLogContext->pLogFilePath));

        Status = SrPostSyncOperation(SrCreateFile,
                                     &OpenContext);

        if (NT_SUCCESS(Status))
        {
            SrTrace(LOG, (" - Succeeded\n"));

            ASSERT(OpenContext.Handle != NULL); 

            pLogContext->LogHandle = OpenContext.Handle;

            //
            //  Also get the file object associated with this handle.
            //

            Status = ObReferenceObjectByHandle( pLogContext->LogHandle,
                                                0,
                                                *IoFileObjectType,
                                                KernelMode,
                                                (PVOID *) &(pLogContext->pLogFileObject),
                                                NULL );

            if (!NT_SUCCESS( Status ))
            {
                leave;
            }
            
            //
            // Initialize log context poperly for this log
            //

#ifndef SYNC_LOG_WRITE
            RtlZeroMemory( pLogContext->pLogBuffer, _globals.LogBufferSize );
#endif
            RESET_LOG_CONTEXT( pLogContext );
    
            //
            // Enable log context
            //
    
            SET_ENABLE_FLAG(pLogContext);
    
            //
            // CODEWORK:kmarok: need to decide if we want to preallocate
            // the log file and do it here
            // 
    
            //
            // Write the log header as the first entry into
            // the newly created log
            //
    
            Status = SrPackLogHeader( &pLogHeader, 
                                      pLogContext->pLogFilePath);

            if (!NT_SUCCESS( Status ))
                leave;

            Status = SrLogWrite( NULL, 
                                 pLogContext, 
                                 (PSR_LOG_ENTRY)pLogHeader );
                                 
            if (!NT_SUCCESS( Status ))
                leave;

            //
            // Clear dirty flag because we haven't actually written any
            // data
            // 

            CLEAR_DIRTY_FLAG(pLogContext);
        }
        else
        {
            SrTrace(LOG, (" - Failed (0x%X) \n", Status));
        }
        
    } finally {
    
        Status = FinallyUnwind(SrLogOpen, Status);

        if (!NT_SUCCESS( Status ))
        {
            //
            // Since the open failed, disable the log
            //
            CLEAR_ENABLE_FLAG(pLogContext);

            if (pLogContext->pLogFileObject != NULL)
            {
                ObDereferenceObject( pLogContext->pLogFileObject );
                pLogContext->pLogFileObject = NULL;
            }
            
            if (pLogContext->LogHandle)
            {
                ZwClose( pLogContext->LogHandle );
                pLogContext->LogHandle = NULL;
            }
        }

        if (pLogHeader != NULL)
        {
            SrFreeLogEntry( pLogHeader );
            NULLPTR( pLogHeader );
        }
    }

    RETURN(Status);
    
}   // SrLogOpen

//++
// Function:
//        SrLogClose
//
// Description:
//        This function closes the current log
//
// Arguments:
//        Pointer to Log Context
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogClose(
    IN PSR_LOG_CONTEXT pLogContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TempStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) );

    //
    // Flush & Close the log file
    //

    if ( pLogContext->LogHandle )
    {
#ifndef SYNC_LOG_WRITE
        // 
        //  We only need to force flush here if we are not doing synchronous
        //  log writes.
        //

        Status = SrLogFlush( pLogContext );
#endif

        //
        //  The close operation is only going to fail if the LogHandle
        //  is invalid.  We need to close the handle even if we hit an
        //  error trying to flush the log, but it is the value returned from
        //  flushing the log that the caller really cares about, not the 
        //  return value from closing the handle, so just store it in a 
        //  temp variable and validate in checked builds.
        //
        
        ObDereferenceObject( pLogContext->pLogFileObject );
        TempStatus = ZwClose( pLogContext->LogHandle );
        CHECK_STATUS( TempStatus );
    } 

    // 
    // modify the log context to indicate the log is closed
    // donot clear the LogBuffer member ( reused )
    //

    pLogContext->LogHandle = NULL;
    pLogContext->pLogFileObject = NULL;
    RESET_LOG_CONTEXT(pLogContext);

    RETURN( Status );
    
}   // SrLogClose

//++
// Function:
//        SrLogCheckAndRename
//
// Description:
//        This function checks and backsup a log file
//
// Arguments:
//        pExtension - The SR_DEVICE_EXTENSION for this volume.
//        pLogPath - The full path and file name to the change log.
//
// Return Value:             
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogCheckAndRename(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pLogPath
    )
{
    INT                         i                  = 1;
    NTSTATUS                    Status             = STATUS_UNSUCCESSFUL;
    HANDLE                      LogHandle          = NULL;
    PUNICODE_STRING             pRenamedFile       = NULL;
    PFILE_RENAME_INFORMATION    pRenameInformation = NULL;
    ULONG                       CharCount;
    ULONG                       RenameInformationLength;
    IO_STATUS_BLOCK             IoStatusBlock;
    SR_OPEN_CONTEXT             OpenContext;
    
    PAGED_CODE();

    ASSERT( pLogPath != NULL );

    SrTrace(FUNC_ENTRY, ("SR!SrLogCheckAndRename\n"));

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension) );

    try
    { 
        //
        // Do the create 
        //
        OpenContext.pPath = pLogPath;
        OpenContext.Handle = NULL;
        OpenContext.DesiredAccess = DELETE;
        OpenContext.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        OpenContext.ShareAccess = 0;
        OpenContext.CreateDisposition = FILE_OPEN;
        OpenContext.CreateOptions = FILE_NO_INTERMEDIATE_BUFFERING
                                     | FILE_SYNCHRONOUS_IO_NONALERT;
        OpenContext.pExtension = pExtension;
        
        Status = SrPostSyncOperation(SrCreateFile,
                                     &OpenContext);

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND || 
            !NT_SUCCESS( Status ))
        {
            ASSERT(OpenContext.Handle == NULL);
            //
            // we need to check for file not found status
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            {
                Status = STATUS_SUCCESS;
            }
    
            leave;
        }
    
        //
        // File exists so try to rename the file
        //
        LogHandle = OpenContext.Handle;
        ASSERT(LogHandle != NULL);

        RenameInformationLength = sizeof(FILE_RENAME_INFORMATION)
                                        + pLogPath->Length
                                        + sizeof(WCHAR)     // the "."
                                        + MAX_ULONG_LENGTH  // the "%d"
                                        + sizeof(WCHAR) ;   // a NULL

        pRenameInformation = SR_ALLOCATE_POOL( PagedPool, 
                                               RenameInformationLength,
                                               SR_RENAME_BUFFER_TAG );
        
        if (pRenameInformation == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
                                           
        Status = SrAllocateFileNameBuffer( pLogPath->Length 
                                            + sizeof(WCHAR)     // the "."
                                            + MAX_ULONG_LENGTH, // the "%d"
                                           &pRenamedFile );
                                           
        if (!NT_SUCCESS( Status ))
            leave;
    
        while( 1 )
        {
            RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));
    
            //
            // Construct possible backup filename
            //
        
            RtlCopyMemory( pRenamedFile->Buffer, 
                           pLogPath->Buffer,
                           pLogPath->Length );
    
            pRenamedFile->Length = pLogPath->Length;
                       
            //
            // and append backup suffix
            //
    
            CharCount = swprintf( &pRenamedFile->Buffer[
                                      pRenamedFile->Length/sizeof(WCHAR)],
                                  L".%d",
                                  i++ );

            ASSERT(CharCount <= MAX_ULONG_LENGTH);
            
            pRenamedFile->Length += (USHORT)CharCount * sizeof(WCHAR);

            ASSERT(pRenamedFile->Length <= pRenamedFile->MaximumLength);
            
            //
            // now initialize the rename info struct
            //
        
            RtlCopyMemory( (PUCHAR)&pRenameInformation->FileName[0],
                           pRenamedFile->Buffer,
                           pRenamedFile->Length + sizeof(WCHAR) );
    
            pRenameInformation->ReplaceIfExists = FALSE;
            pRenameInformation->RootDirectory   = NULL;
            pRenameInformation->FileNameLength  = pRenamedFile->Length;
    
            SrTrace( LOG, ("SR!SrLogCheckAndRename: renaming to %ws\n",
                     &pRenameInformation->FileName[0] ));
    
            Status = ZwSetInformationFile( LogHandle,
                                           &IoStatusBlock,
                                           pRenameInformation,
                                           RenameInformationLength,
                                           FileRenameInformation );
                        
            if ( NT_SUCCESS_NO_DBGBREAK( Status ) ||
                (Status != STATUS_OBJECT_NAME_COLLISION) ||
                (i > MAX_RENAME_TRIES) )
            {
                break;
            }
        }

		//
		//  To get DBG messages for unexpected errors in DEBUG builds...
		//
		
		CHECK_STATUS( Status );
		
    }
    finally
    {
        if ( LogHandle != NULL )
        {
            ZwClose(LogHandle);
            LogHandle = NULL;
        }
    
        if ( pRenamedFile != NULL )
        {
            SrFreeFileNameBuffer( pRenamedFile );
            pRenamedFile = NULL; 
        }
    
        if ( pRenameInformation != NULL )
        {
            SR_FREE_POOL(pRenameInformation, SR_RENAME_BUFFER_TAG);
            pRenameInformation = NULL; 
        }
    }

    RETURN(Status);
}   // SrLogCheckAndRename


//
// Public API implementation
//

//++
// Function:
//        SrLogStart
//
// Description:
//        This function prepares the driver for Logging
//        requests.
//
// Arguments:
//        Pointer to Log Path
//        Pointer to device extension
//        Pointer to handle
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogStart( 
    IN  PUNICODE_STRING   pLogPath,
    IN  PSR_DEVICE_EXTENSION pExtension,
    OUT PSR_LOG_CONTEXT * ppLogContext
    )
{
    NTSTATUS Status             = STATUS_UNSUCCESSFUL;
    PSR_LOG_CONTEXT pLogContext = NULL;

    PAGED_CODE();

    ASSERT(pLogPath     != NULL);
    ASSERT(ppLogContext != NULL);

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension ));

    try
    {

        *ppLogContext = NULL;
    
        //
        // should we short circuit out of here for testing mode?
        //
    
        if (!SR_LOGGING_ENABLED( pExtension ) ||
            _globals.DontBackup)
        {
            leave;
        }
    
        *ppLogContext = SR_ALLOCATE_STRUCT( PagedPool, 
                                            SR_LOG_CONTEXT,
                                            SR_LOG_CONTEXT_TAG );
    
        if ( *ppLogContext == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
    
        pLogContext = *ppLogContext;
    
        RtlZeroMemory( pLogContext, sizeof(SR_LOG_CONTEXT) );

        pLogContext->Signature = SR_LOG_CONTEXT_TAG;
        pLogContext->pExtension = pExtension;
    
        //
        // grab a buffer to store the file name
        //
    
        Status = SrAllocateFileNameBuffer( pLogPath->Length, 
                                           &(pLogContext->pLogFilePath) );
                                           
        if (!NT_SUCCESS( Status ))
            leave;

        //
        //  Store our backpointer to the device extension
        //
        
        pLogContext->pExtension = pExtension;
        
        //
        // Save the filename in the context
        //
    
        RtlCopyMemory( pLogContext->pLogFilePath->Buffer, 
                       pLogPath->Buffer,
                       pLogPath->Length );

        pLogContext->pLogFilePath->Buffer
            [pLogPath->Length/sizeof(WCHAR)] = UNICODE_NULL;

        pLogContext->pLogFilePath->Length = pLogPath->Length;

#ifndef SYNC_LOG_WRITE

        //
        //  We only need a buffer to cache the log entries if we are doing
        //  asynchronous log writes.
        //
    
        pLogContext->pLogBuffer = SrAllocateLogBuffer( _globals.LogBufferSize );
    
        if ( pLogContext->pLogBuffer == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
#endif        
    
        //
        // rename the old log file if one exists
        //
    
        Status = SrLogCheckAndRename( pExtension, pLogContext->pLogFilePath);

        if (!NT_SUCCESS(Status))
            leave;
        
        //
        // try and open the log file
        //

        Status = SrLogOpen( pLogContext );
    
        if (NT_SUCCESS(Status))
        {
            //
            // Add the context to the logger
            // 
            //
            SrLoggerAddLogContext( global->pLogger,
                                   pLogContext );
        }
        //
        // Important: We should not fail after calling SrLoggerAddContext above
        // because the finally clause assumes that if there's a failure,
        // SrLoggerAddContext was not called yet. If this changes, use a
        // BOOLEAN to appropriately indicate if SrLoggerAddContext is already
        // called and use that to condition the call in the finally clause.
        //
    }
    finally
    {
        Status = FinallyUnwind(SrLogStart, Status);
    
        //
        // if we are unsuccessful for some reason then clean up
        // the logging structs (if necessary) .
        //
    
        if ((!NT_SUCCESS( Status )) && (pLogContext != NULL))
        {
            //
            // We assume as per note above that the context count is not
            // incremented. Increment it now because SrLogStop will decrement it
            //

            SrLoggerAddLogContext(global->pLogger,
                                  pLogContext);

            //
            //  Stop the log
            //

            SrLogStop( pExtension, TRUE, TRUE );
            *ppLogContext = pLogContext = NULL;
        }
    }

    RETURN(Status);
    
}   // SrLogStart

//++
// Function:
//        SrLogStop
//
// Description:
//        This function  closes / frees any resources used 
//      SR logging
//
// Arguments:
//        pExtension - The SR device extension on this volume which contains
//             our logging information.
//        PurgeContexts - TRUE if we should purge all our contexts at this time
//        CheckLog - TRUE if we should try to check and rename the log at
//              this time.  Note that checking the log could cause the volume
//              to be remounted at this time.  Therefore, if we don't want
//              that to happen (i.e., during shutdown), CheckLog should be 
//              FALSE.
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogStop(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN BOOLEAN PurgeContexts,
    IN BOOLEAN CheckLog
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PSR_LOG_CONTEXT pLogContext = pExtension->pLogContext;


    PAGED_CODE();

    //
    // context must have been intialized by calling SrLogStart
    //

    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) );

    try
    {
    
        //
        //  If we are diabling the volume then free all of the contexts
        //

        if (PurgeContexts)
        {
            SrDeleteAllContexts( pExtension );
        }

        //
        //  Close the log handle
        //

        if ( pLogContext->LogHandle )
        {
            SrTrace( LOG,  ("Stopped logging : %wZ\n", 
                     pLogContext->pLogFilePath));
    
            Status = SrLogClose( pLogContext );
    
            //
            // Rename this log to the backup log for uniformity.
            //
    
            if (NT_SUCCESS(Status) && CheckLog)
            {
                Status = SrLogCheckAndRename( pExtension, 
                                              pLogContext->pLogFilePath );
            }
        }
    
        //
        // Remove the context from logger
        //
    
        SrLoggerRemoveLogContext( global->pLogger,
                                  pLogContext );
    
        //
        // Free buffers
        //

#ifdef SYNC_LOG_WRITE
        //
        //  If we are doing synchronous log writes, we shouldn't have a 
        //  buffer to free here.
        //
        
        ASSERT( pLogContext->pLogBuffer == NULL );
#else
        //
        //  If we are doing asynchronous log writes, we need to free the buffer
        //  used to collect log entries.
        //
        
        if ( pLogContext->pLogBuffer )
        {
            SrFreeLogBuffer( pLogContext->pLogBuffer );
            pLogContext->pLogBuffer = NULL;
        } 
#endif

        if ( pLogContext->pLogFilePath )
        {
            SrFreeFileNameBuffer( pLogContext->pLogFilePath );
            pLogContext->pLogFilePath = NULL;
        } 
    
        SR_FREE_POOL_WITH_SIG(pLogContext, SR_LOG_CONTEXT_TAG);
    
        //
        //  Set logging state in extension
        //

        pExtension->pLogContext = NULL;
        pExtension->DriveChecked = FALSE;

        Status = STATUS_SUCCESS;
    }
    finally
    {
        Status = FinallyUnwind(SrLogStop, Status);
    }

    RETURN(Status);
    
}   // SrLogStop
 
//++
// Function:
//      SrLogNormalize
//
// Description:
//      This function ensures that any closed change.log files have been 
//      renamed to change[#].log format for restore.  Since we can't always
//      ensure that the change.log got renamed when the log was stopped (we
//      can't do this on shutdown), we need to do this normalization for
//      Restore.
//
// Arguments:
//      pExtension - The SR Device Extension for this volume.
//
// Return Value:
//      This function returns STATUS_SUCCESS if we were able to do the
//      log normalization or the appropriate error code otherwise.
//--

NTSTATUS
SrLogNormalize (
    IN PSR_DEVICE_EXTENSION pExtension
    )
{
    NTSTATUS status;
    PUNICODE_STRING pLogPath = NULL;
    
    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) );

    //
    //  Check to see if we have a restore location for this volume yet.
    //  If not, we don't have to do any more work.
    //

    status = SrCheckForRestoreLocation( pExtension );

    if (!NT_SUCCESS_NO_DBGBREAK( status ))
    {
        status = STATUS_SUCCESS;
        goto SrLogNormalize_Exit;
    }

    //
    //  We do have a restore location, so build up the log path.
    //

    status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pLogPath);

    if (!NT_SUCCESS(status))
    {
        goto SrLogNormalize_Exit;
    }
    
    status = SrGetLogFileName( pExtension->pNtVolumeName, 
                               SR_FILENAME_BUFFER_LENGTH,
                               pLogPath );
                             
    if (!NT_SUCCESS(status))
    {
        goto SrLogNormalize_Exit;
    }

    status = SrLogCheckAndRename( pExtension, pLogPath );
    
SrLogNormalize_Exit:

    if (pLogPath != NULL)
    {
        SrFreeFileNameBuffer( pLogPath );
    }

    RETURN( status );
}

//++
// Function:
//        SrLogWrite
//
// Description:
//        This function writes the entry into the log cache and
//      flushes the cache in case the entry cannot fit in.
//
// Arguments:
//        Pointer to Device object
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogWrite( 
    IN PSR_DEVICE_EXTENSION pOptionalExtension OPTIONAL,
    IN PSR_LOG_CONTEXT pOptionalLogContext OPTIONAL,
    IN PSR_LOG_ENTRY pLogEntry
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PSR_LOG_CONTEXT pLogContext = NULL;
    PSR_DEVICE_EXTENSION pExtension = NULL;

    PAGED_CODE();

    ASSERT(pOptionalExtension == NULL || IS_VALID_SR_DEVICE_EXTENSION(pOptionalExtension));
    ASSERT(pOptionalExtension != NULL || pOptionalLogContext != NULL);
    ASSERT(pLogEntry != NULL);

    if (pOptionalExtension != NULL)
    {
        //
        // We need to ensure that the volume hasn't been disabled before
        // we do anything.
        //

        if (pOptionalExtension->Disabled) {
        
            Status = STATUS_SUCCESS;
            goto SrLogWrite_Exit;
        }
            
        //
        // we need to make sure our disk structures are good and logging
        // has been started. it's possible we have been called simply to 
        // log and logging was stopped due to volume lock.  we have to 
        // check with the global lock held.
        //

        Status = SrCheckVolume(pOptionalExtension, FALSE);
        if (!NT_SUCCESS( Status ))
            goto SrLogWrite_Exit;
        
        pLogContext = pOptionalExtension->pLogContext;
    }
    else
    {
        //
        // use the free form context passed in (only SrLogOpen does this)
        //
        
        pLogContext = pOptionalLogContext;
    }
    
    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));
    if (pLogContext == NULL)
    {
        //
        // this is unexpected, but need to protect against
        //
        
        Status = STATUS_INVALID_PARAMETER;
        CHECK_STATUS(Status);
        goto SrLogWrite_Exit;
    }
    
    pExtension = pLogContext->pExtension;
    ASSERT( pExtension != NULL );

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_SHARED( pExtension ) ||
            IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) );
    
    try {

        SrAcquireLogLockExclusive( pExtension );

        //
        //  Check to make sure the volume is still enabled.
        //

        if (!SR_LOGGING_ENABLED( pExtension )) 
        {
            Status = STATUS_SUCCESS;
            leave;
        }
        
        //
        // bail if logging is disabled for this context
        //
    
        if (!FlagOn(pLogContext->LoggingFlags, SR_LOG_FLAGS_ENABLE))
        {
            leave;
        }
    
        //
        // check the log file, if it is greater than 1Mb switch the log
        //
    
        if ( (pLogContext->FileOffset + 
              pLogContext->BufferOffset + 
              pLogEntry->Header.RecordSize) > SR_MAX_LOG_FILE_SIZE )
        {
            Status = SrLogSwitch( pLogContext );
    
            if (!NT_SUCCESS( Status ))
            {
                leave;
            }
        }

#ifdef SYNC_LOG_WRITE
        Status = SrpLogWriteSynchronous( pExtension, 
                                         pLogContext, 
                                         pLogEntry);
#else
        Status = SrpLogWriteAsynchronous( pExtension, 
                                          pLogContext, 
                                          pLogEntry);
#endif
    } finally {
    
        Status = FinallyUnwind(SrLogWrite, Status);

        SrReleaseLogLock(pExtension);
    }

SrLogWrite_Exit:
    
    RETURN(Status);
    
}   // SrLogWrite

//++
// Function:
//        SrLogWriteSynchronous
//
// Description:
//
//      This function writes each log entry to the current change log
//      and ensures the updated change log is flushed to disk before
//      it returns.
//
// Arguments:
//
//      pExtension - The device extension for the volume whose change
//          log is going to be updated.
//      pLogContext - The log context that contains the information
//          about which change log should updated.
//      pLogEntry - The log entry to be written.
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrpLogWriteSynchronous( 
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_LOG_CONTEXT pLogContext,
    IN PSR_LOG_ENTRY pLogEntry
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( pExtension );

    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );
    ASSERT( IS_VALID_LOG_CONTEXT( pLogContext ) );
    ASSERT( pLogEntry != NULL );

    ASSERT( IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) );
    
    //
    //  In this mode, we are not buffering the log entries, so just point
    //  the pLogContext->pLogBuffer to the current pLogEntry so save the
    //  copy into the buffer.
    //

    ASSERT( pLogContext->pLogBuffer == NULL );
    pLogContext->pLogBuffer = (PBYTE) pLogEntry;
    pLogContext->BufferOffset = pLogEntry->Header.RecordSize;
    
    SET_DIRTY_FLAG(pLogContext);

    Status = SrLogFlush( pLogContext );

    //
    //  Clear out the pLogBuffer reference to the pLogEntry whether or
    //  not the flush succeeded.
    //

    pLogContext->pLogBuffer = NULL;

    RETURN(Status);
}

#ifndef SYNC_LOG_WRITE
   
//++
// Function:
//        SrLogWriteAsynchronous
//
// Description:
//
//      This function buffers log writes then flushes the writes when the
//      buffer is full.
//
// Arguments:
//
//      pExtension - The device extension for the volume whose change
//          log is going to be updated.
//      pLogContext - The log context that contains the information
//          about which change log should updated.
//      pLogEntry - The log entry to be written.
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrpLogWriteAsynchronous( 
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_LOG_CONTEXT pLogContext,
    IN PSR_LOG_ENTRY pLogEntry
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );
    ASSERT( IS_VALID_LOG_CONTEXT( pLogContext ) );
    ASSERT( pLogEntry != NULL );

    ASSERT( IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) );
    
    //
    // Check if the entry can fit into the current buffer, if not
    // then adjust the last entry of the buffer and write it down
    // to the disk
    //

    if ( (pLogContext->BufferOffset + pLogEntry->Header.RecordSize) >
         _globals.LogBufferSize )
    {
        //
        // check to make sure we have 50mb free, we are about to 
        // grow the file
        //

        Status = SrCheckFreeDiskSpace( pLogContext->LogHandle, 
                                       pExtension->pNtVolumeName );
                                       
        if (!NT_SUCCESS( Status ))
        {
            goto SrpLogWriteAsynchronous_Exit;
        }
        
        // 
        // set the dirty flag because we have updated the buffer
        //

        SET_DIRTY_FLAG(pLogContext);

        Status = SrLogFlush( pLogContext );
        if (!NT_SUCCESS( Status ))
        {
            goto SrpLogWriteAsynchronous_Exit;
        }

        //
        //  Check to make sure that the pLogEntry itself isn't bigger
        //  than the _globals.LogBufferSize.
        //

        if (pLogEntry->Header.RecordSize > _globals.LogBufferSize)
        {
            PBYTE pLogBuffer;

            //
            //  The log was just successfully flushed, therefore there should
            //  be no data in the buffer yet.
            //
            
            ASSERT( pLogContext->BufferOffset == 0 );
            
            //
            //  For synchronous writes, we don't expect there to be a log buffer
            //  in the context so we will save this off in a local and NULL
            //  this parameter in the pLogContext while we make this call.
            //
            
            pLogBuffer = pLogContext->pLogBuffer;
            pLogContext->pLogBuffer = NULL;

            Status = SrpLogWriteSynchronous( pExtension, 
                                             pLogContext, 
                                             pLogEntry );

            //
            //  We ALWAYS need to restore this pointer in the pLogContext.
            //

            pLogContext->pLogBuffer = pLogBuffer;

            CHECK_STATUS( Status );

            //
            //  Whether we succeeded or failed, we want to skip the logic below
            //  and exit now.
            //
            
            goto SrpLogWriteAsynchronous_Exit;
        }
    }
    
    //
    //  We now have enough room in the buffer for this pLogEntry, so append the 
    //  entry to the buffer.
    //

    RtlCopyMemory( pLogContext->pLogBuffer + pLogContext->BufferOffset,
                   pLogEntry,
                   pLogEntry->Header.RecordSize );

    //
    //  Update buffer pointers to reflect the entry has been added
    //

    pLogContext->LastBufferOffset = pLogContext->BufferOffset;
    pLogContext->BufferOffset += pLogEntry->Header.RecordSize;

    SET_DIRTY_FLAG(pLogContext);

    //
    //  We were able to copy into the buffer successfully, so return
    //  STATUS_SUCCESS.
    //
    
    Status = STATUS_SUCCESS;
    
SrpLogWriteAsynchronous_Exit:
    
    RETURN(Status);
}

#endif

//++
// Function:
//        SrLogFlush
//
// Description:
//        This function flushes the buffer contents in memory
//        to the log, it doesn't increment file offset in the 
//      log context.
//
// Arguments:
//        Pointer to new Log Context
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogFlush( 
    IN PSR_LOG_CONTEXT pLogContext
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN ExtendLogFile = FALSE;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE(pLogContext->pExtension));

    SrTrace(FUNC_ENTRY, ("SR!SrLogFlush\n") );

    //
    // should we short circuit out of here for testing mode?
    //

    if (global->DontBackup)
    {
        Status = STATUS_SUCCESS;
        goto SrLogFlush_Exit;
    }

    //
    // bail if the context is disabled
    //

    if (!FlagOn( pLogContext->LoggingFlags, SR_LOG_FLAGS_ENABLE ))
    {
        goto SrLogFlush_Exit;
    }

    ASSERT( pLogContext->LogHandle != NULL );

    if (FlagOn( pLogContext->LoggingFlags, SR_LOG_FLAGS_DIRTY )) 
    {
        SrTrace( LOG, ("Flushing Log :%wZ", pLogContext->pLogFilePath));

        //
        //  Do we need to extend our log file?  We can possibly loop here if
        //  the amount of data we need to write is greater than our 
        //  allocation unit.  We want to make sure that if we do have to extend
        //  the file that we have at least extended it enough for our
        //  current write.
        //

        while ((pLogContext->BufferOffset + pLogContext->FileOffset) > 
                pLogContext->AllocationSize)
        {
            //
            //  This file will need to be extended for this write.
            //

            ExtendLogFile = TRUE;
            pLogContext->AllocationSize += _globals.LogAllocationUnit;
        }

        if (ExtendLogFile)
        {
            FILE_ALLOCATION_INFORMATION fileAllocInfo;

            fileAllocInfo.AllocationSize.QuadPart = pLogContext->AllocationSize;

            Status = SrSetInformationFile( pLogContext->pExtension->pTargetDevice,
                                           pLogContext->pLogFileObject,
                                           &fileAllocInfo,
                                           sizeof( fileAllocInfo ),
                                           FileAllocationInformation );

            if ((Status == STATUS_NO_SUCH_DEVICE) ||
                (Status == STATUS_INVALID_HANDLE) ||
                !NT_SUCCESS( Status ))
            {
                SrTrace( LOG, ("SrLogFlush: Log extension failed: 0x%x\n", Status) );
                goto SrLogFlush_Exit;
            }
        }
        
        //
        //  Write the buffer to the disk.  We have opened this file in append
        //  only mode, so the file system will maintain the current file 
        //  position for us.  This handle was open for SYNCHRONOUS access,
        //  therefore, this IO will not return until it has completed.
        //

        ASSERT( pLogContext->pLogBuffer != NULL );
        
        Status = ZwWriteFile( pLogContext->LogHandle,
                              NULL,                      // Event
                              NULL,                      // ApcRoutine 
                              NULL,                      // ApcContext 
                              &IoStatusBlock,
                              pLogContext->pLogBuffer,
                              pLogContext->BufferOffset,
                              NULL,                      // ByteOffset
                              NULL );                    // Key

        //
        // Handle STATUS_NO_SUCH_DEVICE because we expect this when
        // HotPlugable devices are removed by surprise.
        //
        // Handle STATUS_INVALID_HANDLE because we expect this when
        // a force-dismount came through on a volume.
        //
        
        if ((Status == STATUS_NO_SUCH_DEVICE) ||
            (Status == STATUS_INVALID_HANDLE) ||
            !NT_SUCCESS( Status ))
        {
            SrTrace( LOG,("SrLogFlush: Write failed: 0x%x\n", Status) );
            goto SrLogFlush_Exit;
        }

        Status = SrFlushBuffers( pLogContext->pExtension->pTargetDevice, 
                                 pLogContext->pLogFileObject );
            
        if (!NT_SUCCESS( Status ))
        {
            SrTrace( LOG,("SrLogFlush: Flush failed: 0x%x\n", Status) );
            goto SrLogFlush_Exit;
        }
        
        SrTrace( LOG,("SrLogFlush: Flush succeeded!\n"));

        //
        //  We've dumped the buffer to disk, so update our file offset with the 
        //  number of bytes we have written, reset our buffer pointer, and
        //  clear the dirty flag on this log context since it is no longer
        //  dirty.
        //

        ASSERT( pLogContext->BufferOffset == IoStatusBlock.Information );
        
        UPDATE_LOG_OFFSET( pLogContext, pLogContext->BufferOffset );
        
        RESET_LOG_BUFFER( pLogContext );
        CLEAR_DIRTY_FLAG( pLogContext );
    }

    //
    //  If we got here, the flush was successful, so return that status.
    //

    Status = STATUS_SUCCESS;

SrLogFlush_Exit:

#if DBG
    if (Status == STATUS_NO_SUCH_DEVICE ||
        Status == STATUS_INVALID_HANDLE)
    {
        return Status;
    }
#endif

    RETURN(Status);
}   // SrLogFlush

//++
// Function:
//        SrLogSwitch
//
// Description:
//        This function Switches the current log to the
//        new log.
//
// Arguments:
//        Pointer to new log context.
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrLogSwitch( 
    IN PSR_LOG_CONTEXT  pLogContext
    )
{
    NTSTATUS            Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_CONTEXT(pLogContext));

    ASSERT( IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) ||
            IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pLogContext->pExtension ) );

    //
    // bail if the context is disabled
    //

    if (!FlagOn( pLogContext->LoggingFlags, SR_LOG_FLAGS_ENABLE ))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto SrLogSwitch_Exit;
    }

    if (pLogContext->LogHandle)
    {
        //
        // flush and close current log ( close - flushes also )
        //

        Status = SrLogClose(pLogContext);

        if ( NT_SUCCESS(Status) )
        {
            //
            // rename the old log file if one exists
            //

            Status = SrLogCheckAndRename( pLogContext->pExtension,
                                          pLogContext->pLogFilePath );
  
            if (NT_SUCCESS(Status))
            {
                //
                // try and open the log file
                //

                Status = SrLogOpen( pLogContext );
            }
        }
    }

SrLogSwitch_Exit:
    
    RETURN(Status);
    
}   // SrLogSwitch

/////////////////////////////////////////////////////////////////////
//
// Misc Routines : Misc routines required by the logging module
//
/////////////////////////////////////////////////////////////////////

//++
// Function:
//        SrGetRestorePointPath
//
// Description:
//        This function creates a path for the restore point dir.
//
// Arguments:
//        Pointer to log entry buffer
//        Length of the Log filename buffer
//        Pointer to the Log filename buffer
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS 
SrGetRestorePointPath(
    IN  PUNICODE_STRING pVolumeName,
    IN  USHORT          RestPtPathLength,
    OUT PUNICODE_STRING pRestPtPath
    )
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    ULONG       CharCount;

    PAGED_CODE();

    ASSERT(pVolumeName != NULL);
    ASSERT(pRestPtPath != NULL);

    try
    {
        //
        // Copy the volume name in the log file
        //
        
        pRestPtPath->Buffer = (PWSTR)(pRestPtPath+1);
        
        //
        // TODO:(CODEWORK: grab a lock around global?)
        //
    
        //
        // construct our restore point location string
        //
    
        CharCount = swprintf( pRestPtPath->Buffer,
                              VOLUME_FORMAT RESTORE_LOCATION,
                              pVolumeName,
                              global->MachineGuid );
    
        pRestPtPath->Length = (USHORT)CharCount * sizeof(WCHAR);
        pRestPtPath->MaximumLength = RestPtPathLength;
    
        if ( pRestPtPath->Length > RestPtPathLength )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
    
        //
        // Append the restore point directory
        //
    
        CharCount = swprintf( 
                        &pRestPtPath->Buffer[pRestPtPath->Length/sizeof(WCHAR)],
                        L"\\" RESTORE_POINT_PREFIX L"%d\\",
                        global->FileConfig.CurrentRestoreNumber );
    
        pRestPtPath->Length += (USHORT)CharCount * sizeof(WCHAR);
        
        pRestPtPath->MaximumLength = RestPtPathLength;
    
        if ( pRestPtPath->Length > RestPtPathLength )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
    
        //
        // NULL terminate it
        //
    
        pRestPtPath->Buffer[pRestPtPath->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
        Status = STATUS_SUCCESS;
    }
    finally
    {
    }
   
    RETURN(Status);
    
}   // SrGetRestorePointPath

//++
// Function:
//        SrGetLogFileName
//
// Description:
//        This function creates a path for change log in restore point dir.
//
// Arguments:
//        Pointer to log entry buffer
//        Length of the Log filename buffer
//        Pointer to the Log filename buffer
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS 
SrGetLogFileName(
    IN  PUNICODE_STRING pVolumeName,
    IN  USHORT          LogFileNameLength,
    OUT PUNICODE_STRING pLogFileName
    )
{
    NTSTATUS    Status;

    PAGED_CODE();

    ASSERT(pVolumeName  != NULL);
    ASSERT(pLogFileName != NULL);

    //
    // Get restore point path
    //

    Status = SrGetRestorePointPath( pVolumeName, 
                                    LogFileNameLength, 
                                    pLogFileName );

    if (NT_SUCCESS(Status))
    {
        //
        // Append changelog file name
        //

        Status = RtlAppendUnicodeToString( pLogFileName, s_cszCurrentChangeLog );
    }

    RETURN(Status);
    
}   // SrGetLogFileName

//++
// Function:
//        SrGetAclFileName
//
// Description:
//        This function creates a path for Acl file in restore point dir.
//
// Arguments:
//        Pointer to log entry buffer
//        Length of the Log filename buffer
//        Pointer to the Log filename buffer
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS 
SrGetAclFileName(
    IN  PUNICODE_STRING pVolumeName,
    IN  USHORT          AclFileNameLength,
    OUT PUNICODE_STRING pAclFileName
    )
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    ULONG       CharCount;
    ULONG       NextFileNumber;

    PAGED_CODE();

    ASSERT(pVolumeName  != NULL);
    ASSERT(pAclFileName != NULL);

    //
    // Get restore point path
    //

    Status = SrGetRestorePointPath( pVolumeName, 
                                    AclFileNameLength, 
                                    pAclFileName );

    if (NT_SUCCESS(Status))
    {
        //
        // Generate a new file number and append it to the path above
        //

        Status = SrGetNextFileNumber(&NextFileNumber);
        if (!NT_SUCCESS( Status ))
            goto End;

        //
        // use the "S" prefix (e.g. "S0000001.Acl" )
        //

        CharCount = swprintf( &pAclFileName->Buffer[pAclFileName->Length/sizeof(WCHAR)],
              ACL_FILE_PREFIX L"%07d" ACL_FILE_SUFFIX,
              NextFileNumber );

        pAclFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

        if ( pAclFileName->Length > AclFileNameLength )
        {
            goto End;
        }

        //
        // NULL terminate it
        //

        pAclFileName->Buffer[pAclFileName->Length/sizeof(WCHAR)]=UNICODE_NULL;
    }

End:
    RETURN(Status);
    
}   // SrGetAclFileName


//++
// Function:
//        SrGetAclInformation
//
// Description:
//        This function gets the acl information from the given file
//        and packs it into a sub-record
//
// Arguments:
//        Pointer to filename
//        Pointer to variable to return the address of security info
//        Pointer to variable to return the size of security info
//
// Return Value:
//        This function returns STATUS_XXX
//--

NTSTATUS
SrGetAclInformation (
    IN PFILE_OBJECT pFileObject,
    IN PSR_DEVICE_EXTENSION pExtension,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PULONG pSizeNeeded
    )
{
    NTSTATUS             Status = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    ULONG                SizeNeeded = 256;

    struct 
    {
        FILE_FS_ATTRIBUTE_INFORMATION Info;
        WCHAR Buffer[ 50 ];
    } FileFsAttrInfoBuffer;

    PAGED_CODE();

    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT(pSizeNeeded != NULL);
    ASSERT(ppSecurityDescriptor != NULL);

    try 
    {

        *ppSecurityDescriptor = NULL;
        *pSizeNeeded = 0;

        //
        // First check if we already know if the fs supports acls
        // Do this check now so we can leave real fast if the volume
        // doesn't support ACLs
        //
        if (pExtension->CachedFsAttributes && 
            (!FlagOn(pExtension->FsAttributes, FILE_PERSISTENT_ACLS))) {
            leave;
        }
    
        //
        // Check if the file system supports acl stuff if necessary
        // 
        if (!pExtension->CachedFsAttributes) {
            //
            // We need to check now
            //
            Status = SrQueryVolumeInformationFile( pExtension->pTargetDevice,
                                                   pFileObject,
                                                   &FileFsAttrInfoBuffer.Info,
                                                   sizeof(FileFsAttrInfoBuffer),
                                                   FileFsAttributeInformation,
                                                   NULL );
                                               
            if (!NT_SUCCESS( Status )) 
                 leave;
        
            //
            // Stow away the attributes for later use
            //
            pExtension->CachedFsAttributes = TRUE;
            pExtension->FsAttributes = FileFsAttrInfoBuffer.Info.FileSystemAttributes;

            if (!FlagOn(pExtension->FsAttributes, FILE_PERSISTENT_ACLS))
             leave;
        }

        //
        // Read in the security information from the source file
        // (looping until we get a big enough buffer).
        //
    
        while (TRUE ) 
        {
            //
            // Alloc a buffer to hold the security info.
            //
    
            pSecurityDescriptor  = SR_ALLOCATE_ARRAY( PagedPool,
                                                      UCHAR,
                                                      SizeNeeded,
                                                      SR_SECURITY_DATA_TAG );
    
            if (NULL == pSecurityDescriptor) 
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }
    
            //
            // Query the security info
            //
    
            Status = SrQuerySecurityObject( pExtension->pTargetDevice,
                                            pFileObject,
                                            DACL_SECURITY_INFORMATION
                                                    |SACL_SECURITY_INFORMATION
                                                    |OWNER_SECURITY_INFORMATION 
                                                    |GROUP_SECURITY_INFORMATION,
                                            pSecurityDescriptor,
                                            SizeNeeded,
                                            &SizeNeeded );
                                            
            //
            // Not enough buffer?
            //

            if (STATUS_BUFFER_TOO_SMALL == Status ||
                STATUS_BUFFER_OVERFLOW == Status) 
            {
                //
                // Get a bigger buffer and try again.
                //

                SR_FREE_POOL( pSecurityDescriptor, 
                              SR_SECURITY_DATA_TAG );
                              
                pSecurityDescriptor = NULL;
                SizeNeeded *= 2;
                continue;
            }
    
            break;
        }  
    
        if (!NT_SUCCESS( Status )) 
            leave;
    
        //
        // Security descriptor should be self relative.
        //

        ASSERT(((PISECURITY_DESCRIPTOR_RELATIVE)pSecurityDescriptor)->Control & SE_SELF_RELATIVE);
 
        //
        // return the security information
        //
    
        *ppSecurityDescriptor = pSecurityDescriptor;
        pSecurityDescriptor = NULL;
        
        *pSizeNeeded = SizeNeeded;
    
        SrTrace( LOG, ("sr!SrGetAclInformation: returning [0x%p,%d]\n", 
                 *ppSecurityDescriptor,
                 SizeNeeded ));
        
    } finally {
    
        Status = FinallyUnwind(SrGetAclInformation, Status);

        if (pSecurityDescriptor != NULL)
        {
            SR_FREE_POOL( pSecurityDescriptor, SR_SECURITY_DATA_TAG );
            pSecurityDescriptor = NULL;
        }
    }

    RETURN(Status);
    
}   // SrGetAclInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\srpriv.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    srpriv.h

Abstract:

    This is a local header file for sr private structures and macros

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000
    
Revision History:

--*/


#ifndef _SRPRIV_H_    
#define _SRPRIV_H_

//
//  If CONFIG_LOGGING_VIA_REGISTRY is enables, SR will read the LogBufferSize,
//  LogAllocationUnit and LogFlushFrequency from the registry.  While this is
//  useful for performance tuning, we don't want this functionality in the
//  shipping filter, so this should NOT be defined for shipping code.
//

//#define CONFIG_LOGGING_VIA_REGISTRY

#ifdef CONFIG_LOGGING_VIA_REGISTRY
#define REGISTRY_LOG_BUFFER_SIZE        L"LogBufferSize"
#define REGISTRY_LOG_ALLOCATION_UNIT    L"LogAllocationUnit"
#define REGISTRY_LOG_FLUSH_FREQUENCY    L"LogFlushFrequency"
#endif

//
//  If SYNC_LOG_WRITE is defined, the filter will write all log entries
//  synchronously to the change log file.  This has a significant impact on the
//  performance of the driver, therefore we are NOT doing this.  We buffer
//  the log entries and write them to disk periodically.
//

// #define SYNC_LOG_WRITE

//
// forward definitions for srlog.h
//

typedef struct _SR_LOG_CONTEXT * PSR_LOG_CONTEXT;
typedef struct _SR_LOGGER_CONTEXT * PSR_LOGGER_CONTEXT;

//
// allocation utilities
//

#define SR_ALLOCATE_POOL( type, len, tag )          \
    ExAllocatePoolWithTag(                          \
        (type),                                     \
        (len),                                      \
        (tag)|PROTECTED_POOL )

#define SR_FREE_POOL( ptr, tag )                    \
    ExFreePoolWithTag(ptr, (tag)|PROTECTED_POOL)

#define SR_FREE_POOL_WITH_SIG(a,t)                  \
    {                                               \
        ASSERT((a)->Signature == (t));              \
        (a)->Signature = MAKE_FREE_TAG(t);          \
        SR_FREE_POOL(a,t);                          \
        (a) = NULL;                                 \
    }

#define SR_ALLOCATE_STRUCT(pt,ot,t)                 \
    (ot *)(SR_ALLOCATE_POOL(pt,sizeof(ot),t))

#define SR_ALLOCATE_ARRAY(pt,et,c,t)                \
    (et *)(SR_ALLOCATE_POOL(pt,sizeof(et)*(c),t))

// BUGBUG: ALIGN_UP(PVOID) won't work, it needs to be the type of the first entry of the
// following data (paulmcd 4/29/99)

#define SR_ALLOCATE_STRUCT_WITH_SPACE(pt,ot,cb,t)   \
    (ot *)(SR_ALLOCATE_POOL(pt,ALIGN_UP(sizeof(ot),PVOID)+(cb),t))

#define MAKE_FREE_TAG(Tag)  (((Tag) & 0xffffff00) | (ULONG)'x')
#define IS_VALID_TAG(Tag)   (((Tag) & 0x0000ffff) == 'rS' )

//
// ISSUE-2001-05-01-mollybro Restore can only handle file paths of at most 1000 characters 
//    Restore should be fixed to cope with this, but for now, the filter is just
//    going to treat operations on files with names that are longer than 1000
//    characters as uninteresting (where the 1000 characters includes the 
//    terminating NULL that will be added when the name is logged).
//    When this limit is eventually removed, we should remove these checks by 
//    the filter (search for the places that use this macro).
//
//  SR will only log filenames where the full path is 1000 characters
//  or less.  This macro tests to make sure a name is within our valid range.
//

#define IS_FILENAME_VALID_LENGTH( pExtension, pFileName, StreamLength ) \
    (((((pFileName)->Length + (StreamLength)) - (pExtension)->pNtVolumeName->Length) < \
        (SR_MAX_FILENAME_PATH * sizeof( WCHAR ))) ?                            \
        TRUE :                                                                   \
        FALSE )

//
//  This is an internal error code this is used when we detect that a
//  volume has been disabled.  Note that this status should NEVER be
//  returned from a dispatch routine.  This is designed to be an error
//  code.
//

#define SR_STATUS_VOLUME_DISABLED       ((NTSTATUS)-1)
#define SR_STATUS_CONTEXT_NOT_SUPPORTED ((NTSTATUS)-2)
#define SR_STATUS_IGNORE_FILE           ((NTSTATUS)-3)

//
//  Local event type definitions
//

//
// these are copied manually
//

#define SR_MANUAL_COPY_EVENTS   \
    (SrEventStreamChange)

//
// these are logged and only cared about once
//

#define SR_ONLY_ONCE_EVENT_TYPES \
    (SrEventAclChange|SrEventAttribChange)

//
// this we ignore after any of the SR_FULL_BACKUP_EVENT_TYPES occur
//   note: SrEventFileCreate is added to this list to prevent recording
//      of stream creates if we have recorded the unnamed stream create
//      already.
//

#define SR_IGNORABLE_EVENT_TYPES \
    (SrEventStreamChange|SrEventAclChange|SrEventAttribChange   \
        |SrEventFileDelete|SrEventStreamCreate)

//
// these cause us to start ignoring SR_IGNORABLE_EVENT_TYPES
//

#define SR_FULL_BACKUP_EVENT_TYPES \
    (SrEventStreamChange|SrEventFileCreate      \
        |SrEventFileDelete|SrEventStreamCreate)

//
// these we always need to log, even if we are ignoring them
//

#define SR_ALWAYS_LOG_EVENT_TYPES \
    (SrEventFileDelete)

//
//  Certain events are relevant to the entire file and not just
//  the current stream.  Flag these types of events so that we know
//  to put the ignorable events in the backup history keyed by the file
//  name instead of by the file and stream name.
//

#define SR_FILE_LEVEL_EVENTS \
    (SrEventStreamChange|SrEventFileDelete|SrEventAclChange|SrEventAttribChange)

/***************************************************************************++

Routine Description:

    This macro determines from the bits set in the EventType whether to
    log the current operation against the file name with the stream component
    or without the stream component.  It returns 0 if this operation should
    be logged against the file without the stream name, or the StreamNameLength
    otherwise.

Arguments:

    EventType - the event that just occured
    StreamNameLength - the length of the stream component of the name
 
Return Value:

    0 - If the filename without the stream component is to be used.
    StreamNameLength - If the filename with the stream component is to be used.

--***************************************************************************/
#define RECORD_AGAINST_STREAM( EventType, StreamNameLength )   \
    (FlagOn( (EventType), SR_FILE_LEVEL_EVENTS ) ?     \
     0 :                                   \
     (StreamNameLength) )
    
//
// pool tags (please keep this in alpha order - reading backwards)
//

#define SR_BACKUP_DIRECTORY_CONTEXT_TAG     MAKE_TAG('CBrS')
#define SR_BACKUP_FILE_CONTEXT_TAG          MAKE_TAG('FBrS')

#define SR_COPY_BUFFER_TAG                  MAKE_TAG('BCrS')
#define SR_CREATE_COMPLETION_TAG            MAKE_TAG('CCrS')
#define SR_COUNTED_EVENT_TAG                MAKE_TAG('ECrS')
#define SR_CONTROL_OBJECT_TAG               MAKE_TAG('OCrS')
#define SR_STREAM_CONTEXT_TAG               MAKE_TAG('CSrS')

#define SR_DEBUG_BLOB_TAG                   MAKE_TAG('BDrS')
#define SR_DEVICE_EXTENSION_TAG             MAKE_TAG('EDrS')
#define SR_DEVICE_LIST_TAG                  MAKE_TAG('LDrS')


#define SR_EA_DATA_TAG                      MAKE_TAG('DErS')
#define SR_EXTENSION_LIST_TAG               MAKE_TAG('LErS')
#define SR_EVENT_RECORD_TAG                 MAKE_TAG('RErS')

#define SR_FILE_ENTRY_TAG                   MAKE_TAG('EFrS')
#define SR_FILENAME_BUFFER_TAG              MAKE_TAG('NFrS')

#define SR_GLOBALS_TAG                      MAKE_TAG('LGrS')
#define SR_GET_OBJECT_NAME_CONTEXT_TAG      MAKE_TAG('OGrS')

#define HASH_BUCKET_TAG                     MAKE_TAG('BHrS')

#define SR_HOOKED_DRIVER_ENTRY_TAG          MAKE_TAG('DHrS')
#define HASH_HEADER_TAG                     MAKE_TAG('HHrS')
#define HASH_KEY_TAG                        MAKE_TAG('KHrS')

#define SR_LOG_ACLINFO_TAG                  MAKE_TAG('AIrS')

#define SR_KEVENT_TAG                       MAKE_TAG('EKrS')

#define SR_LOG_BUFFER_TAG                   MAKE_TAG('BLrS')
#define SR_LOG_CONTEXT_TAG                  MAKE_TAG('CLrS')
#define SR_LOG_ENTRY_TAG                    MAKE_TAG('ELrS')
#define SR_LOOKUP_TABLE_TAG                 MAKE_TAG('TLrS')

#define SR_MOUNT_POINTS_TAG                 MAKE_TAG('PMrS')

#define SR_OVERWRITE_INFO_TAG               MAKE_TAG('IOrS')

#define SR_PERSISTENT_CONFIG_TAG            MAKE_TAG('CPrS')

#define SR_RENAME_BUFFER_TAG                MAKE_TAG('BRrS')
#define SR_LOGGER_CONTEXT_TAG               MAKE_TAG('GRrS')
#define SR_REPARSE_HEADER_TAG               MAKE_TAG('HRrS')
#define SR_REGISTRY_TAG                     MAKE_TAG('RRrS')

#define SR_SECURITY_DATA_TAG                MAKE_TAG('DSrS')
#define SR_STREAM_DATA_TAG                  MAKE_TAG('TSrS')

#define SR_TRIGGER_ITEM_TAG                 MAKE_TAG('ITrS')

#define SR_VOLUME_INFO_TAG                  MAKE_TAG('IVrS')
#define SR_VOLUME_NAME_TAG                  MAKE_TAG('NVrS')

#define SR_WORK_ITEM_TAG                    MAKE_TAG('IWrS')
#define SR_WORK_CONTEXT_TAG                 MAKE_TAG('CWrS')

//
//  We use a "trick" of hiding the stream name in the unicode string
//  between the Length and MaximumLength of the buffer.  We then track the
//  StreamName length separately.  This macro checks to make sure that 
//  all is still in sync.
//

#define IS_VALID_SR_STREAM_STRING( pFileName, StreamLength ) \
    ((((pFileName)->Length + (StreamLength)) <= (pFileName)->MaximumLength) && \
     (((StreamLength) > 0) ?                                                   \
        (((pFileName)->Length < (pFileName)->MaximumLength) &&                 \
         ((pFileName)->Buffer[(pFileName)->Length/sizeof(WCHAR)] == ':')) :    \
        TRUE ))

#define SR_FILE_READ_ACCESS    READ_CONTROL | \
                               FILE_READ_DATA | \
                               FILE_READ_ATTRIBUTES | \
                               FILE_READ_EA

#define SR_FILE_WRITE_ACCESS   WRITE_DAC | \
                               WRITE_OWNER | \
                               FILE_WRITE_DATA | \
                               FILE_APPEND_DATA | \
                               FILE_WRITE_ATTRIBUTES | \
                               FILE_WRITE_EA

//
//  The maximum number of characters in a short name.
//

#define SR_SHORT_NAME_CHARS    (8 + 1 + 3)

//
// Error handlers.
//

#if DBG

NTSTATUS
SrDbgStatus(
    IN NTSTATUS Status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define CHECK_STATUS(status) SrDbgStatus((status),__FILE__,__LINE__)

#define RETURN(status) return CHECK_STATUS(status)

//
// in debug builds i want the chance to DbgBreak on an error encountered
// from a lower level api call.
//

#undef NT_SUCCESS

#define NT_SUCCESS(status) ((NTSTATUS)(CHECK_STATUS((status))) >= 0)
#define NT_SUCCESS_NO_DBGBREAK(status) ((NTSTATUS)(status) >= 0)


#else

#define RETURN(status) return (status)
#define CHECK_STATUS(status) ((void)0)

#define NT_SUCCESS_NO_DBGBREAK(status) NT_SUCCESS((status))

#endif // DBG

#define DebugFlagSet(a)\
    (FlagOn(_globals.DebugControl, SR_DEBUG_ ## a))
//
// Debug spew control.
//

#define SR_DEBUG_FUNC_ENTRY                 0x00000001
#define SR_DEBUG_CANCEL                     0x00000002
#define SR_DEBUG_NOTIFY                     0x00000004
#define SR_DEBUG_LOG_EVENT                  0x00000008
#define SR_DEBUG_INIT                       0x00000020
#define SR_DEBUG_HASH                       0x00000040
#define SR_DEBUG_LOOKUP                     0x00000080
#define SR_DEBUG_LOG                        0x00000100
#define SR_DEBUG_RENAME                     0x00000200
#define SR_DEBUG_LOAD_UNLOAD                0x00000400
#define SR_DEBUG_BYTES_WRITTEN				0x00000800
#define SR_DEBUG_PNP                        0x00001000
#define SR_DEBUG_EXPAND_SHORT_NAMES         0x00002000
#define SR_DEBUG_BLOB_VERIFICATION          0x00004000
#define SR_DEBUG_IOCTL                      0x00008000

#define SR_DEBUG_BREAK_ON_ERROR             0x00010000
#define SR_DEBUG_VERBOSE_ERRORS             0x00020000
#define SR_DEBUG_BREAK_ON_LOAD              0x00040000
#define SR_DEBUG_ENABLE_UNLOAD              0x00080000

#define SR_DEBUG_ADD_DEBUG_INFO             0x00100000

#define SR_DEBUG_DELAY_DPC                  0x00200000

#define SR_DEBUG_KEEP_CONTEXT_NAMES         0x10000000
#define SR_DEBUG_CONTEXT_LOG                0x20000000
#define SR_DEBUG_CONTEXT_LOG_DETAILED       0x40000000

#define SR_DEBUG_DEFAULTS                   (SR_DEBUG_VERBOSE_ERRORS)

//
// config file structures (store in \_restore\_driver.cfg)
//
// these can't go in the registry and they need to survive a restore, and 
// the registry is reverted along with the system , during a restore
//


typedef struct _SR_PERSISTENT_CONFIG
{
    //
    // = SR_PERSISTENT_CONFIG_TAG
    //
    
    ULONG Signature;

    //
    // the number to use for the next temp file name (e.g. A0000001.exe = 1)
    //
    
    ULONG FileNameNumber;

    //
    // the number to use for the next seq number
    //
    
    INT64 FileSeqNumber;

    //
    // the number for the current restore point subdirectory (e.g. 
    // "\_restore\rp5" = 5)
    //
    
    ULONG CurrentRestoreNumber;
    
} SR_PERSISTENT_CONFIG, * PSR_PERSISTENT_CONFIG;



#define RESTORE_CONFIG_LOCATION     RESTORE_LOCATION L"\\_driver.cfg"


//
// Tracing.
//

#if DBG

#define SrTrace(a, _b_)                                                 \
{                                                                       \
    if (DebugFlagSet(##a))                                              \
    {                                                                   \
        try {                                                           \
            KdPrint( _b_ );                                             \
        } except (EXCEPTION_EXECUTE_HANDLER) {                          \
            /* do nothing, just catch it and ignore.  bug#177569 */     \
            /* long strings with non-english characters can trigger */  \
            /* an exception with KdPrint. */                            \
        }                                                               \
    }                                                                   \
}


//
// a version of SrTrace that does not wrap KdPrint with try, so should
// only be used in cases where it is certain there is no risk of exception.
// this is needed in termination handlers which cannot nest exception 
// handling
//
#define SrTraceSafe(a, _b_)                                                 \
    (DebugFlagSet(##a) ? KdPrint( _b_ ) : TRUE)
/*    {                                                                       \
        IF_DEBUG(##a)                                                       \
        {                                                                   \
            KdPrint( _b_ );                                                 \
        }                                                                   \
    }
*/    
#else //DBG

#define SrTrace(a, _b_)
#define SrTraceSafe(a, _b_)

#endif //DBG

//
// Object types exported by the kernel but not in any header file.
//

extern POBJECT_TYPE *IoDeviceObjectType;

//
//  Macro to clear pointers only in the DEBUG version
//

#if DBG
#   define NULLPTR(_p) ((_p) = NULL)
#else
#   define NULLPTR(_p)
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Public globals.
//
/////////////////////////////////////////////////////////////////////////////

//
// e.g. "{64bdb2bb-d3b0-41d6-a28e-275057d7740d}" = 38 characters
//

#define SR_GUID_BUFFER_LENGTH        (38 * sizeof(WCHAR))
#define SR_GUID_BUFFER_COUNT         40


#define IS_VALID_GLOBALS(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == SR_GLOBALS_TAG))


typedef struct _SR_GLOBALS
{
    //
    // NonPagedPool
    //

    //
    // = SR_GLOBALS_TAG
    //

    ULONG Signature;

    //
    // Offset of process name in PEPROCESS struct, set to default
    // in logfmt.h but can be overridden using registry
    //
    
    ULONG ProcNameOffset;

    //
    // For controlling debug functions (like SrTrace) at runtime
    //
    
    ULONG DebugControl;

    //
    // the global DRIVER_OBJECT
    //

    PDRIVER_OBJECT pDriverObject;

    //
    // the sr device that people can open to get a control object
    //

    PDEVICE_OBJECT pControlDevice;

    //
    // OPTIONAL: a control object if it is open on this system
    //
    
    struct _SR_CONTROL_OBJECT * pControlObject;

    //
    // Are we currently monitoring the system?  This is TRUE when the registry
    // says to disable, or the filter has received the STOP_MONITORING_IOCTL.
    // It only gets cleared when the filter receives the START_MONITORING_IOCTL.
    //
    // NOTE: This is NOT used for errors that require the filter to shut off.
    //   The following flag provides that.
    //

    BOOLEAN Disabled;

    //
    //  If we hit an error reading the blob and generated a volume error
    //  on the system volume.  Set this flag to true so that we don't
    //  continue to try to load the blob until all the volumes have
    //  been disabled by the service.
    //

    BOOLEAN HitErrorLoadingBlob;

    //
    // have we loaded our disk based config values yet?  we delay load these
    // as we load pretty early in the boot sequence so our DriverEntry could
    // not do this
    //

    BOOLEAN FileConfigLoaded;

    //
    // have we loaded the blob info (lookup.c)
    //
    
    BOOLEAN BlobInfoLoaded;

    //
    // a debug flag for doing all of the normal work except for backups.
    //
    
    BOOLEAN DontBackup;
    
    //
    // our persistent config values
    //

    SR_PERSISTENT_CONFIG FileConfig;

    //
    // this is the number we used for the last backup file
    //
    
    ULONG LastFileNameNumber;

    //
    // this is the seq number
    //
    
    INT64 LastSeqNumber;

    //
    // the location to read our registry our of (from DriverEntry)
    //

    PUNICODE_STRING pRegistryLocation;

    //
    // in-memory blob information
    //

    BLOB_INFO BlobInfo;

    //
    // these resources are always acquired in order if nested acquired.
    // the activity lock is outermost.
    //

    //
    // Blob synchronization stuff (acquired sometimes with the global lock held)
    //

    ERESOURCE BlobLock;

    //
    // This resource locks pControlObject + this global structure + hash lists
    //
    
    ERESOURCE GlobalLock;

    //
    // the registry configured machine guid as a string
    // (e.g. "{03e692d7-b392-4a01-babf-1efd2c11d449}" )
    //
    
    WCHAR MachineGuid[SR_GUID_BUFFER_COUNT];

#ifdef USE_LOOKASIDE
    //
    // lookaside lists for speedy allocations
    //

    PAGED_LOOKASIDE_LIST FileNameBufferLookaside;
#endif

    //
    // Logger Context
    //

    PSR_LOGGER_CONTEXT pLogger;

    //
    //  FsRtl fast I/O call backs
    //

    FAST_IO_DISPATCH FastIoDispatch;

    //
    // anchors the list of all device extensions (attached volumes)
    //

    ERESOURCE DeviceExtensionListLock;
    LIST_ENTRY DeviceExtensionListHead;

    //
    // keeps track of whether or not we have already attached to the system
    // volume.
    //

    struct _SR_DEVICE_EXTENSION * pSystemVolumeExtension;

#ifndef SYNC_LOG_WRITE

    //
    //  SR log buffer size
    //

    ULONG LogBufferSize;

    //
    //  The time interval at which the logs are flushed, in seconds.
    //
    
    ULONG LogFlushFrequency;

    //
    //  This is the calculated value that translate the LogFlushFrequency
    //  to the form of the time that the KeTimer apis need (100-nanosecond 
    //  intervals).
    //
    
    LARGE_INTEGER LogFlushDueTime;
#endif

    //
    //  The unit used to extend the log files.
    //
    
    ULONG LogAllocationUnit;
    
} SR_GLOBALS, *PSR_GLOBALS;

extern PSR_GLOBALS global;
extern SR_GLOBALS _globals;

//
// used as a window for persisting our file numbers to the disk.
// a large enough number is used so that we don't have a problem during 
// power failures even if there is a lot of activity.  otherwise the 
// number chosen is random.
//

#define SR_SEQ_NUMBER_INCREMENT 1000
#define SR_FILE_NUMBER_INCREMENT 1000

/////////////////////////////////////////////////////////////////////////////
//  
//  File Context related information
//
/////////////////////////////////////////////////////////////////////////////

//
//  Structure for tracking an individual stream context.  Note that the buffer
//  for the FileName is allocated as part of this structure and follows 
//  immediatly after it.
//

typedef struct _SR_STREAM_CONTEXT
{
    //
    //  OS Structure used to track contexts per stream.  Note how we use
    //  the following fields:
    //      OwnerID     -> Holds pointer to our DeviceExtension
    //      InstanceId  -> Holds Pointer to FsContext associated
    //                     with this structure
    //  We use these values to get back to these structures
    //

    FSRTL_PER_STREAM_CONTEXT ContextCtrl;

    //
    //  Linked list used to track contexts per device (in our device
    //  extension).
    //

    LIST_ENTRY ExtensionLink;

    //
    //  This is a counter of how many threads are currently using this
    //  context.  The count is used in this way:
    //  - It is set to 1 when it is created.
    //  - It is incremented every time it is returned to a thread
    //  - It is decremented when the thread is done with it.
    //  - It is decremented when the underlying stream that is using it is freed
    //  - The context is deleted when this count goes to zero
    //

    LONG UseCount;

    //
    //  Maintain the link count -- currently for debugging purposes only.
    //

    ULONG LinkCount;

    //
    //  Holds the name of the file
    //

    UNICODE_STRING FileName;

    //
    //  This holds the length of the stream name portion of the
    //  FileName.  Note that this length is not included in the 
    //  length inside the FileName string but the characters
    //  are there during debug.
    //

    USHORT StreamNameLength;

    //
    //  Flags for this context.  All flags are set or cleared via
    //  the interlocked bit routines except when the entry is being
    //  created, at this time we know nobody is using this entry.
    //

    ULONG Flags;

} SR_STREAM_CONTEXT, *PSR_STREAM_CONTEXT;

//
//  If set, this entry is interesting to SR
//

#define CTXFL_IsInteresting     0x00000001

//
//  If set, this entry is for a directory
//

#define CTXFL_IsDirectory       0x00000002

//
//  If set, this entry is for a volume open.  We will not have a name
//  and this object will not be interesting.
//

#define CTXFL_IsVolumeOpen      0x00000004

//
//  If set, this is a temporary context and should not be linked into
//  any of the context lists.  It will be freed as soom as the user is
//  done with this operation.  
//

#define CTXFL_Temporary         0x00000010

//
//  If set, we are performing a significant operation that affects the state
//  of this context so we should not use it.  If someone tries to get this
//  context then create a temporary context and return it.  Cases where this
//  occurs:
//  - Source file of a rename.
//  - Source file for the creation of a hardlink
//

#define CTXFL_DoNotUse          0x00000020

//
//  If set, we need to query the link count before linking this context into
//  the filter contexts.
//

#define CTXFL_QueryLinkCount  0x00000040

//
//  If set, then we are currently linked into the device extension linked
//  list.  
//

#define CTXFL_InExtensionList   0x00000100

//
//  If set, then we are linked into the stream list.  Note that there is
//  a small period of time when we might be unlinked with this flag still
//  set (when the file system is calling SrpDeleteContextCallback).  This is
//  fine because we still handle not being found in the list when we do
//  the search.  This flag handles the case when the file has been completly
//  closed (and the memory freed) on us.
//

#define CTXFL_InStreamList      0x00000200

//
//  Macro used to set the Renaming flag in an individual context.  We use the
//  list lock in the extension to protect this.  We can get away with this
//  because rename operations are rare.
//

//#define SrSetRenamingFlag(ext,ctx) \
//{ \
//    SrAcquireContextLockExclusive((ext)); \
//    SetFlag((ctx)->Flags,CTXFL_Renaming); \
//    SrReleaseContextLock((ext)); \
//}



//
//  We use this structure to keep track of all contexts associated with this
//  device.  This way one we unload or disable monitoring we can walk
//  through and free all contexts.
//

typedef struct _SR_CONTEXT_CTRL
{
    //
    //  Lock used for accessing the linked list.  We also acquire this lock
    //  shared as we look up contexts.  This way they can't disappear until
    //  we get the use count updated.
    //

    ERESOURCE Lock;

    //
    //  The linked list of contexts.  
    //

    LIST_ENTRY List;

    //
    //  If this count is non-zero then all contexts become temporary.
    //  This count is presently used to track how many pending directory
    //  renames are in progress in the system.  While this count is non-zero
    //  any contexts that are created become temporary and are freed
    //  when the current operation is completed.
    //

    ULONG AllContextsTemporary;

} SR_CONTEXT_CTRL, *PSR_CONTEXT_CTRL;


//
//  Macros for locking the context lock
//

#define SrAcquireContextLockShared(pExt) \
            SrAcquireResourceShared( &(pExt)->ContextCtrl.Lock, TRUE )

#define SrAcquireContextLockExclusive(pExt) \
            SrAcquireResourceExclusive( &(pExt)->ContextCtrl.Lock, TRUE )

#define SrReleaseContextLock(pExt) \
            SrReleaseResource( &(pExt)->ContextCtrl.Lock )


/////////////////////////////////////////////////////////////////////////////
//
//      Name Control Structure related fields
//
/////////////////////////////////////////////////////////////////////////////

//
//  This structure is used to retrieve the name of a file object.  To prevent
//  allocating memory every time we get a name this structure contains a small
//  buffer (which should handle 90+% of all names).  If we do overflow this
//  buffer we will allocate a buffer big enough for the name.
//

typedef struct _SRP_NAME_CONTROL
{
    UNICODE_STRING Name;
    ULONG BufferSize;
    PUCHAR AllocatedBuffer;
    USHORT StreamNameLength;
    CHAR SmallBuffer[254];
} SRP_NAME_CONTROL, *PSRP_NAME_CONTROL;


/////////////////////////////////////////////////////////////////////////////
//
//      Device Extension related definitions
//
/////////////////////////////////////////////////////////////////////////////

#define IS_VALID_SR_DEVICE_EXTENSION( _ext )                 \
    (((_ext) != NULL) &&                                     \
     ((_ext)->Signature == SR_DEVICE_EXTENSION_TAG))   

#define IS_SR_DEVICE_OBJECT( _devObj )                           \
    (((_devObj) != NULL) &&                                      \
     ((_devObj)->DriverObject == _globals.pDriverObject) &&       \
     (IS_VALID_SR_DEVICE_EXTENSION(((PSR_DEVICE_EXTENSION)(_devObj)->DeviceExtension))))


#define DEVICE_NAME_SZ  64

typedef enum _SR_FILESYSTEM_TYPE {

    SrNtfs = 0x01,
    SrFat = 0x02,

    // Flag to determine whether or not this is attached to the filesystem's
    // control device object.

    SrFsControlDeviceObject = 0x80000000

} SR_FILESYSTEM_TYPE, *PSR_FILESYSTEM_TYPE;

typedef struct _SR_DEVICE_EXTENSION {

    //
    // NonPagedPool
    //

    //
    // SR_DEVICE_EXTENSION_TAG
    //

    ULONG Signature;

    //
    // links all extensions to global->DeviceExtensionListHead
    //

    LIST_ENTRY ListEntry;

    //
    //  Activity lock for this volume.
    //

    ERESOURCE ActivityLock;
    BOOLEAN ActivityLockHeldExclusive;

    //
    // the dyanamic unnamed device created by sr.sys used to attach
    // to the target device
    //
    
    PDEVICE_OBJECT pDeviceObject;

    //
    // the target device.. that device that we attached to in the attachment
    // chain, when we hooked into the file system driver.  might not be the
    // actual file system device, but another filter in the chain.
    //
    
    PDEVICE_OBJECT pTargetDevice;

    //
    // NT volume name (needs to be free'd if non-null)
    //

    PUNICODE_STRING pNtVolumeName;

    //
    //  This lock is to synchronize volumes the work needed to do
    //  to setup a volume (get the volume GUID, create the restore
    //  location, etc) for logging or actually log an operation.
    //
    //  NOTE: When this lock is acquired, the volume's ActivityLock
    //  **MUST** be acquired either shared or exclusive (the SrAcquireLogLock
    //  macro tests for this in DBG builds).  For this reason, there are times 
    //  when we access the logging structures when we just have the 
    //  ActivityLock exclusive since this will be sufficient to get exclusive 
    //  access to the logging structures.  The main reason for doing this is
    //  performance -- we can save a few instructions by not making the call to
    //  acquire the LogLock.  Since we have exclusive access to the volume, 
    //  there should be no wait to get the log lock at these times.
    //
    
    ERESOURCE LogLock;

    //
    // the string version of the nt volume guid (e.g.  "{xxx}" ).
    //

    UNICODE_STRING VolumeGuid;
    WCHAR VolumeGuidBuffer[SR_GUID_BUFFER_COUNT];

    //
    // the amount of bytes written to this volume since the last 
    // notification.  this is reset after each notification or volume
    // dismount
    //
    
    ULONGLONG BytesWritten;

    //
    // this struct contains the logging context for this volume
    //
    
    PSR_LOG_CONTEXT pLogContext;
    
    //
    //  Volume information
    //

    SR_FILESYSTEM_TYPE FsType;

    //
    //  Used to manage Contexts for a given volume.
    //

    SR_CONTEXT_CTRL ContextCtrl;

    //
    // Cached Volume attributes: valid only if CachedFsAttributes ==  TRUE
    //
    
    ULONG FsAttributes;
    BOOLEAN CachedFsAttributes;

    //
    // this drive will be temporarily disabled by the filter if it runs
    // out of space.  this is reset by SrReloadConfiguration.
    //
    
    BOOLEAN Disabled;

    //
    // do we need to check the restore store on this drive, this is reset
    // on a SrCreateRestorePoint
    //
    
    BOOLEAN DriveChecked;

    //
    // this is used by filelist.c to provide a backup histore to prevent
    // duplicate backups to a file that changes multiple times within the same
    // restore point. This list is flushed on restore point creation, and 
    // can be trimmed due to resource constraints
    //

    PHASH_HEADER pBackupHistory;

} SR_DEVICE_EXTENSION, *PSR_DEVICE_EXTENSION;

//
//  Macro used to see if we should LOG on this device object
//

#define SR_LOGGING_ENABLED(_devExt) \
            (!global->Disabled && !(_devExt)->Disabled)

//
//  We don't need to log IO that is directed at the control device object
//  of a file system in most cases.  This macro does the quick check of the
//  flags in our device extension to see if this is the control device object
//  for a file system.
//

#define SR_IS_FS_CONTROL_DEVICE(_devExt) \
    (FlagOn((_devExt)->FsType, SrFsControlDeviceObject))

//
// Definitions for posting operations
//
typedef
NTSTATUS
(*PSR_SYNCOP_ROUTINE) (
    IN PVOID Parameter
    );

typedef struct _SR_WORK_CONTEXT {
    //
    // Work item used to queue
    //
    WORK_QUEUE_ITEM WorkItem;
    //
    // Actual caller supplied work routine
    //
    PSR_SYNCOP_ROUTINE SyncOpRoutine;
    //
    // Parameter to the routine
    //
    PVOID Parameter;
    //
    // Return status of routine
    //
    NTSTATUS Status;
    //
    // Event to sync with main-line thread
    //
    KEVENT SyncEvent;
} SR_WORK_CONTEXT, *PSR_WORK_CONTEXT;
                        

//
// Op. posting routines
//
VOID
SrSyncOpWorker(
    IN PSR_WORK_CONTEXT WorkContext
    );

NTSTATUS
SrPostSyncOperation(
    IN PSR_SYNCOP_ROUTINE SyncOpRoutine,
    IN PVOID              Parameter
    );

//
// Other stuff
//
PDEVICE_OBJECT
SrGetFilterDevice (
    PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
SrCreateAttachmentDevice (
    IN PDEVICE_OBJECT pRealDevice OPTIONAL,
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PDEVICE_OBJECT *ppNewDeviceObject
    );

VOID
SrDeleteAttachmentDevice (
    IN PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
SrAttachToDevice (
    IN PDEVICE_OBJECT pRealDevice OPTIONAL,
    IN PDEVICE_OBJECT pDeviceObject,
    IN PDEVICE_OBJECT pNewDeviceObject OPTIONAL,
    OUT PSR_DEVICE_EXTENSION * ppExtension OPTIONAL
    );

NTSTATUS
SrAttachToVolumeByName (
    IN PUNICODE_STRING pVolumeName,
    OUT PSR_DEVICE_EXTENSION * ppExtension OPTIONAL
    );

VOID
SrDetachDevice(
    IN PDEVICE_OBJECT pDeviceObject,
    IN BOOLEAN RemoveFromDeviceList
    );

#if DBG

//
//  In DBG mode, define a SR_MUTEX as a RESOURCE so that we get the 
//  benefit of the thread information stored in ERESOURCES for debugging
//  purposes.
//

#define SR_MUTEX ERESOURCE

#define SrInitializeMutex( mutex )                                      \
    ExInitializeResourceLite( (mutex) );

#define SrAcquireMutex( mutex )                                         \
{                                                                       \
    ASSERT( !ExIsResourceAcquiredExclusive( (mutex) ) &&                \
            !ExIsResourceAcquiredShared( (mutex) ) );                   \
    KeEnterCriticalRegion();                                            \
    ExAcquireResourceExclusive( (mutex), TRUE );                        \
}
    
#define SrReleaseMutex( mutex )                                         \
{                                                                       \
    ASSERT( ExIsResourceAcquiredExclusive( (mutex) ) );                 \
    ExReleaseResourceEx( (mutex) );                                     \
    KeLeaveCriticalRegion();                                            \
}

#else

//
//  In non-DBG mode, define a SR_MUTEX as a FAST_MUTEX so that it is more
//  efficient for what we use this synchronization for than ERESOURCES.
//

#define SR_MUTEX FAST_MUTEX

#define SrInitializeMutex( mutex )                                      \
    ExInitializeFastMutex( (mutex) );

#define SrAcquireMutex( mutex )                                         \
    ExAcquireFastMutex( (mutex) );

#define SrReleaseMutex( mutex )                                         \
    ExReleaseFastMutex( (mutex) );

#endif /* DBG */

#define SR_RESOURCE ERESOURCE;

#define SrAcquireResourceExclusive( resource, wait )                        \
    {                                                                       \
        ASSERT( ExIsResourceAcquiredExclusiveLite((resource)) ||            \
                !ExIsResourceAcquiredSharedLite((resource)) );              \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceExclusiveLite( (resource), (wait) );               \
    } 

#define SrAcquireResourceShared( resource, wait )                           \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceSharedLite( (resource), (wait) );                  \
    }

#define SrReleaseResource( resource )                                       \
    {                                                                       \
        ASSERT( ExIsResourceAcquiredSharedLite((resource)) ||               \
                ExIsResourceAcquiredExclusiveLite((resource)) );            \
        ExReleaseResourceLite( (resource) );                                \
        KeLeaveCriticalRegion();                                            \
    }

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->SystemResourcesList.Flink != NULL)

#define IS_LOOKASIDE_INITIALIZED( lookaside )                               \
    ((lookaside)->L.ListEntry.Flink != NULL)


//
// macro that should probably be in ntos\inc\io.h.
//

#define SrUnmarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control &= ~SL_PENDING_RETURNED )


//
// Miscellaneous validators.
//

#define IS_VALID_DEVICE_OBJECT( pDeviceObject )                             \
    ( ((pDeviceObject) != NULL) &&                                          \
      ((pDeviceObject)->Type == IO_TYPE_DEVICE) )
//      ((pDeviceObject)->Size == sizeof(DEVICE_OBJECT)) )

#define IS_VALID_FILE_OBJECT( pFileObject )                                 \
    ( ((pFileObject) != NULL) &&                                            \
      ((pFileObject)->Type == IO_TYPE_FILE) )
//      ((pFileObject)->Size == sizeof(FILE_OBJECT)) )

#define IS_VALID_IRP( pIrp )                                                \
    ( ((pIrp) != NULL) &&                                                   \
      ((pIrp)->Type == IO_TYPE_IRP) &&                                      \
      ((pIrp)->Size >= IoSizeOfIrp((pIrp)->StackCount)) )


//
// Calculate the dimension of an array.
//

#define DIMENSION(x) ( sizeof(x) / sizeof(x[0]) )

//
// The DIFF macro should be used around an expression involving pointer
// subtraction. The expression passed to DIFF is cast to a size_t type,
// allowing the result to be easily assigned to any 32-bit variable or
// passed to a function expecting a 32-bit argument.
//

#define DIFF(x)     ((size_t)(x))

//
// the wait is in 100 nanosecond units to 10,000,000 = 1 second
//

#define NANO_FULL_SECOND (10000000)

//
//  The default buffer size we use to buffer the log entries.
//

#define SR_DEFAULT_LOG_BUFFER_SIZE (2 * 1024)

//
//  The frequency with which we should fire the log flush timer, in seconds.
//

#define SR_DEFAULT_LOG_FLUSH_FREQUENCY 1

//
//  By default, we will extend the log file 16K at a time.
//

#define SR_DEFAULT_LOG_ALLOCATION_UNIT (16 * 1024)

//
//  Returns TRUE if the given device type matches one of the device types
//  we support.  If not, it returns FALSE.
//

#define SR_IS_SUPPORTED_DEVICE(_do)                             \
    ((_do)->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM)

#define SR_IS_SUPPORTED_REAL_DEVICE(_rd)                            \
    (((_rd)->Characteristics & FILE_REMOVABLE_MEDIA) == 0)

#define SR_IS_SUPPORTED_VOLUME(_vpb)                            \
    (((_vpb)->DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) &&     \
     ((_vpb)->RealDevice->Characteristics & FILE_REMOVABLE_MEDIA) == 0)


#define IS_VALID_WORK_ITEM(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == SR_WORK_ITEM_TAG))

typedef struct _SR_WORK_ITEM
{
    //
    // NonPagedPool
    //

    //
    // = SR_WORK_ITEM_TAG
    //

    ULONG Signature;
    
    WORK_QUEUE_ITEM WorkItem;

    PVOID Parameter1;
    PVOID Parameter2;
    PVOID Parameter3;

    //
    //  The event to signal when the work item has been completed.
    //
    
    KEVENT Event;

    //
    //  For return a status code
    //
    
    NTSTATUS Status;

} SR_WORK_ITEM, * PSR_WORK_ITEM;


#define SR_COPY_BUFFER_LENGTH                           (64 * 1024)    

//
// used for file entries for ZwQueryDirectory

#define SR_FILE_ENTRY_LENGTH (1024*4)

//
// used just in case we switch to dos volume names
//

#define VOLUME_FORMAT   L"%wZ"

//
//  used for exception detection in finally
//

#if DBG

#define FinallyUnwind(FuncName, StatusCode)                                 \
    (AbnormalTermination()) ?                                               \
        ( SrTraceSafe( VERBOSE_ERRORS,                                          \
                       ("sr!%s failed due to an unhandled exception!\n", #FuncName)),\
          ( ( (global == NULL || FlagOn(global->DebugControl, SR_DEBUG_BREAK_ON_ERROR)) ? \
                    RtlAssert("AbnormalTermination() == FALSE", __FILE__, __LINE__, NULL) : \
                    0 ),                                                    \
            STATUS_UNHANDLED_EXCEPTION ) )                                  \
        : (StatusCode)

#else

#define FinallyUnwind(FuncName, StatusCode)                                 \
    (AbnormalTermination()) ?                                               \
        STATUS_UNHANDLED_EXCEPTION                                          \
        : (StatusCode)

#endif  // DBG

//
// stolen from sertlp.h
//

#define LongAlignPtr(Ptr) ((PVOID)(((ULONG_PTR)(Ptr) + 3) & -4))
#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
// the number of characters the largest ULONG takes in base 10 .
// 4294967295 = 10 chars
//

#define MAX_ULONG_CHARS     (10)
#define MAX_ULONG_LENGTH    (MAX_ULONG_CHARS*sizeof(WCHAR))

//
// flags to check if we are in the middle of text mode setup
//

#define UPGRADE_SETUPDD_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Setupdd"
#define UPGRADE_SETUPDD_VALUE_NAME L"Start"

//
// flags to check if we are in the middle of gui mode setup
//

#define UPGRADE_CHECK_SETUP_KEY_NAME L"\\Registry\\Machine\\System\\Setup"
#define UPGRADE_CHECK_SETUP_VALUE_NAME L"SystemSetupInProgress"

//
// this is a filter as to what sort of errors cause volume error's to be 
// triggered.  If we get the error STATUS_VOLUME_DISMOUNTED, we have already
// shutdown everything correctly and we don't want to treat this as an error.
// Also, if we get STATUS_FILE_CORRUPT_ERROR, the user's operation is also
// going to fail, so don't treat this as a volume error.
//

#define CHECK_FOR_VOLUME_ERROR(Status) \
    ((STATUS_VOLUME_DISMOUNTED != Status) && \
     (STATUS_FILE_CORRUPT_ERROR != Status) && \
     (SR_STATUS_VOLUME_DISABLED != Status) && \
     (SR_STATUS_CONTEXT_NOT_SUPPORTED != Status) && \
     (SR_STATUS_IGNORE_FILE != Status) && \
     !NT_SUCCESS((Status)))

//
// Macro that defines what a "volume name" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are "volume name" mount points.
//
// stolen + modified from mountmgr.h
//

#define MOUNTMGR_VOLUME_NAME_PREFIX_COUNT  (49)
#define MOUNTMGR_VOLUME_NAME_PREFIX_LENGTH (49*sizeof(WCHAR))

#define MOUNTMGR_IS_VOLUME_NAME_PREFIX(s) (                                 \
     (s)->Length >= MOUNTMGR_VOLUME_NAME_PREFIX_LENGTH &&                   \
     (s)->Buffer[0] == '\\' &&                                              \
     (s)->Buffer[1] == '?' &&                                               \
     (s)->Buffer[2] == '?' &&                                               \
     (s)->Buffer[3] == '\\' &&                                              \
     (s)->Buffer[4] == 'V' &&                                               \
     (s)->Buffer[5] == 'o' &&                                               \
     (s)->Buffer[6] == 'l' &&                                               \
     (s)->Buffer[7] == 'u' &&                                               \
     (s)->Buffer[8] == 'm' &&                                               \
     (s)->Buffer[9] == 'e' &&                                               \
     (s)->Buffer[10] == '{' &&                                              \
     (s)->Buffer[19] == '-' &&                                              \
     (s)->Buffer[24] == '-' &&                                              \
     (s)->Buffer[29] == '-' &&                                              \
     (s)->Buffer[34] == '-' &&                                              \
     (s)->Buffer[47] == '}' &&                                              \
     (s)->Buffer[48] == '\\' )


#if DBG

#define SrAcquireActivityLockShared(pExtension)                             \
{                                                                           \
    if (ExIsResourceAcquiredShared(&(pExtension)->ActivityLock) == FALSE)   \
    {                                                                       \
        /* no other locks better be held.  the activity lock is the */      \
        /* outermost lock                                           */      \
        ASSERT(!ExIsResourceAcquiredShared(&global->GlobalLock));           \
        ASSERT(!ExIsResourceAcquiredExclusive( &global->GlobalLock));       \
        ASSERT(!ExIsResourceAcquiredShared(&global->BlobLock));             \
        ASSERT(!ExIsResourceAcquiredExclusive( &global->BlobLock));         \
        ASSERT(!ExIsResourceAcquiredShared(&(pExtension)->LogLock));        \
        ASSERT(!ExIsResourceAcquiredExclusive( &(pExtension)->LogLock));    \
    }                                                                       \
    KeEnterCriticalRegion();                                                \
    ExAcquireSharedStarveExclusive(&(pExtension)->ActivityLock, TRUE);      \
}

#define SrAcquireActivityLockExclusive(pExtension)                          \
{                                                                           \
    if (!ExIsResourceAcquiredExclusive(&(pExtension)->ActivityLock))        \
    {                                                                       \
        /* no other locks better be held.  the activity lock is the */      \
        /* outermost lock                                           */      \
        ASSERT(!ExIsResourceAcquiredShared(&global->GlobalLock));           \
        ASSERT(!ExIsResourceAcquiredExclusive( &global->GlobalLock));       \
        ASSERT(!ExIsResourceAcquiredShared(&global->BlobLock));             \
        ASSERT(!ExIsResourceAcquiredExclusive( &global->BlobLock));         \
        ASSERT(!ExIsResourceAcquiredShared(&(pExtension)->LogLock));       \
        ASSERT(!ExIsResourceAcquiredExclusive( &(pExtension)->LogLock));   \
    }                                                                       \
    SrAcquireResourceExclusive(&(pExtension)->ActivityLock, TRUE);          \
}
    
#define SrAcquireLogLockShared(pExtension)                                  \
{                                                                           \
    ASSERT(ExIsResourceAcquiredShared(&(pExtension)->ActivityLock) ||      \
           ExIsResourceAcquiredExclusive( &(pExtension)->ActivityLock ));  \
    SrAcquireResourceShared(&(pExtension)->LogLock, TRUE);                  \
}

#define SrAcquireLogLockExclusive(pExtension)                               \
{                                                                           \
    ASSERT(ExIsResourceAcquiredShared(&(pExtension)->ActivityLock) ||       \
           ExIsResourceAcquiredExclusive( &(pExtension)->ActivityLock ));   \
    SrAcquireResourceExclusive(&(pExtension)->LogLock, TRUE);               \
}

#else

#define SrAcquireActivityLockShared(pExtension)   \
{                                                                           \
    KeEnterCriticalRegion();                                                \
    ExAcquireSharedStarveExclusive(&(pExtension)->ActivityLock, TRUE);      \
}
    
#define SrAcquireActivityLockExclusive(pExtension)                  \
    SrAcquireResourceExclusive(&(pExtension)->ActivityLock, TRUE)
    
#define SrAcquireLogLockShared(pExtension)   \
    SrAcquireResourceShared(&((pExtension)->LogLock), TRUE)

#define SrAcquireLogLockExclusive(pExtension)   \
    SrAcquireResourceExclusive(&((pExtension)->LogLock), TRUE)
    
#endif // DBG

#define IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension )                   \
    ExIsResourceAcquiredExclusiveLite( &(pExtension)->ActivityLock )
    
#define IS_ACTIVITY_LOCK_ACQUIRED_SHARED( pExtension )                      \
    ExIsResourceAcquiredSharedLite( &(pExtension)->ActivityLock )
    
#define IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension )                   \
    ExIsResourceAcquiredExclusiveLite( &(pExtension)->LogLock )
    
#define IS_LOG_LOCK_ACQUIRED_SHARED( pExtension )                      \
    ExIsResourceAcquiredSharedLite( &(pExtension)->LogLock )

#define SrReleaseActivityLock(pExtension) \
   SrReleaseResource(&(pExtension)->ActivityLock)

#define SrReleaseLogLock(pExtension) \
   SrReleaseResource(&(pExtension)->LogLock)


#define IS_GLOBAL_LOCK_ACQUIRED()                                   \
    (ExIsResourceAcquiredExclusiveLite(&(global->GlobalLock)) ||    \
     ExIsResourceAcquiredSharedLite( &(global->GlobalLock) ))

#define SrAcquireGlobalLockExclusive()                                  \
    SrAcquireResourceExclusive( &(global->GlobalLock), TRUE )
    
#define SrReleaseGlobalLock()                                 \
    SrReleaseResource( &(global->GlobalLock) )


#define IS_BLOB_LOCK_ACQUIRED_EXCLUSIVE()                         \
    (ExIsResourceAcquiredExclusiveLite(&(global->BlobLock)))

#define IS_BLOB_LOCK_ACQUIRED()                                   \
    (ExIsResourceAcquiredExclusiveLite(&(global->BlobLock)) ||    \
     ExIsResourceAcquiredSharedLite( &(global->BlobLock) ))

#define SrAcquireBlobLockExclusive()                                  \
    SrAcquireResourceExclusive( &(global->BlobLock), TRUE )

#define SrAcquireBlobLockShared()                        \
    SrAcquireResourceShared( &(global->BlobLock), TRUE )

#define SrReleaseBlobLock()                                 \
    SrReleaseResource( &(global->BlobLock) )

#define IS_DEVICE_EXTENSION_LIST_LOCK_ACQUIRED()                              \
    (ExIsResourceAcquiredExclusiveLite(&(global->DeviceExtensionListLock)) || \
     ExIsResourceAcquiredSharedLite( &(global->DeviceExtensionListLock) ))

#define SrAcquireDeviceExtensionListLockExclusive()                        \
    SrAcquireResourceExclusive( &(global->DeviceExtensionListLock), TRUE )

#define SrAcquireDeviceExtensionListLockShared()                        \
    SrAcquireResourceShared( &(global->DeviceExtensionListLock), TRUE )

#define SrReleaseDeviceExtensionListLock()                                 \
    SrReleaseResource( &(global->DeviceExtensionListLock) )

#define SrAcquireBackupHistoryLockShared( pExtension ) \
    SrAcquireResourceShared( &((pExtension)->pBackupHistory->Lock), TRUE )

#define SrAcquireBackupHistoryLockExclusive( pExtension ) \
    SrAcquireResourceExclusive( &((pExtension)->pBackupHistory->Lock), TRUE )

#define SrReleaseBackupHistoryLock( pExtension ) \
    SrReleaseResource( &((pExtension)->pBackupHistory->Lock) )

//
// we require 50mb free to function
//

#define SR_MIN_DISK_FREE_SPACE  (50 * 1024 * 1024)

//
// the temp unique filename used in SrHandleFileOverwrite
//

#define SR_UNIQUE_TEMP_FILE         L"\\4bf03598-d7dd-4fbe-98b3-9b70a23ee8d4"
#define SR_UNIQUE_TEMP_FILE_LENGTH  (37 * sizeof(WCHAR))


#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))

#define FILE_OBJECT_IS_NOT_POTENTIALLY_INTERESTING(FileObject) \
    ((FileObject) == NULL ||                               \
     FlagOn((FileObject)->Flags, FO_STREAM_FILE))

#define FILE_OBJECT_DOES_NOT_HAVE_VPB(FileObject)       \
     (FileObject)->Vpb == NULL

#define USE_DO_HINT
#ifdef USE_DO_HINT

#define SrIoCreateFile( F, D, O, I, A, FA, SA, CD, CO, EB, EL, FL, DO ) \
    IoCreateFileSpecifyDeviceObjectHint((F),                        \
                                        (D),                        \
                                        (O),                        \
                                        (I),                        \
                                        (A),                        \
                                        (FA),                       \
                                        (SA),                       \
                                        (CD),                       \
                                        (CO),                       \
                                        (EB),                       \
                                        (EL),                       \
                                        CreateFileTypeNone,         \
                                        NULL,                       \
                                        (FL),                       \
                                        (DO) );

#else

#define SrIoCreateFile( F, D, O, I, A, FA, SA, CD, CO, EB, EL, FL, DO ) \
    ZwCreateFile((F),                                               \
                 (D),                                               \
                 (O),                                               \
                 (I),                                               \
                 (A),                                               \
                 (FA),                                              \
                 (SA),                                              \
                 (CD),                                              \
                 (CO),                                              \
                 (EB),                                              \
                 (EL) );
#endif /* USE_DO_HINT */

//
//  Macros so that we can check for expected errors in debug code.
//

#if DBG
#define DECLARE_EXPECT_ERROR_FLAG( _ErrorFlag ) \
    BOOLEAN _ErrorFlag = FALSE
    
#define SET_EXPECT_ERROR_FLAG( _ErrorFlag ) \
    ((_ErrorFlag) = TRUE)

#define CLEAR_EXPECT_ERROR_FLAG( _ErrorFlag ) \
    ((_ErrorFlag) = FALSE)
    
#define CHECK_FOR_EXPECTED_ERROR( _ErrorFlag, _Status ) \
{                                                       \
    if ((_ErrorFlag))                                   \
    {                                                   \
        ASSERT( !NT_SUCCESS_NO_DBGBREAK( (_Status) ) );\
    }                                                   \
}

#else

#define DECLARE_EXPECT_ERROR_FLAG( _ErrorFlag ) 
    
#define SET_EXPECT_ERROR_FLAG( _ErrorFlag )

#define CLEAR_EXPECT_ERROR_FLAG( _ErrorFlag )
    
#define CHECK_FOR_EXPECTED_ERROR( _ErrorFlag, _Status )

#endif
#endif // _SRPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\stats.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    event.h

Abstract:

    contains prototypes for functions in event.c

Author:

    Paul McDaniel (paulmcd)     01-March-2000

Revision History:

--*/


#ifndef _STATS_H_
#define _STATS_H_


#if DBG
//
//  Structure used to track SR statistics
//

typedef struct _SR_STATS
{
    ULONG   TotalContextSearches;
    ULONG   TotalContextFound;
    ULONG   TotalContextCreated;
    ULONG   TotalContextTemporary;
    ULONG   TotalContextIsEligible;
    ULONG   TotalContextDirectories;
    ULONG   TotalContextDirectoryQuerries;
    ULONG   TotalContextDuplicateFrees;
    ULONG   TotalContextCtxCallbackFrees;
    ULONG   TotalContextNonDeferredFrees;
    ULONG   TotalContextDeferredFrees;
    ULONG   TotalContextDeleteAlls;
    ULONG   TotalContextsNotSupported;
    ULONG   TotalContextsNotFoundInStreamList;
    ULONG   TotalHardLinkCreates;
} SR_STATS, *PSR_STATS;

extern SR_STATS SrStats;

//
//  Atomically increment the value
//

#define INC_STATS(field)    InterlockedIncrement( &SrStats.field );
#define INC_LOCAL_STATS(var) ((var)++)

#else

//
//  NON-DEBUG version of macros
//

#define INC_STATS(field)        ((void)0)
#define INC_LOCAL_STATS(var)     ((void)0)

#endif


#endif // _STATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\verifyblob.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    verifyBlob.c

Abstract:

    This file contains blob verification code

Author:

    Neal Christiansen  (nealch)  12/18/2000

Revision History:

--*/

#include "precomp.h"

//
//  If DEBUG is enabled we want to display all of the errors.
//  if NOT DEBUG then return on first error
//

#if DBG
#define HANDLE_FAILURE(_good) ((_good) = FALSE)
#else
#define HANDLE_FAILURE(_good) return FALSE
#endif

//
//  Private prototypes.
//

BOOL
SrVerifyBlobHeader(
    BlobHeader *BlobHead,
    PCHAR Name,
    DWORD BlobType
    );

BOOL
SrVerifyHashHeader(
    ListHeader *HashHead,
    PCHAR Name,
    DWORD Offset
    );

BOOL
SrVerifyHash(
    ListHeader *HashHead,
    PCHAR Name,
    DWORD Offset
    );

BOOL
SrVerifyTreeHeader(
    TreeHeader *TreeHead,
    PCHAR Name
    );

BOOL
SrVerifyTree(
    TreeHeader *TreeHead,
    PCHAR Name,
    DWORD Offset
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrVerifyBlobHeader  )
#pragma alloc_text( PAGE, SrVerifyHashHeader  )
#pragma alloc_text( PAGE, SrVerifyHash        )
#pragma alloc_text( PAGE, SrVerifyTreeHeader  )
#pragma alloc_text( PAGE, SrVerifyTree        )
#pragma alloc_text( PAGE, SrVerifyBlob        )

#endif  // ALLOC_PRAGMA


BOOL
SrVerifyBlobHeader(
    BlobHeader *BlobHead,
    PCHAR Name,
    DWORD BlobType
    )
/*++

Routine Description:

    Verify that the given BLOB Header is valid

Arguments:


Return Value:

    TRUE if OK else FALSE

--*/
{
    BOOL good = TRUE;

    UNREFERENCED_PARAMETER( Name );

    if (BlobHead->m_dwVersion != BLOB_VERSION_NUM)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyBlobHeader: Invalid VERSION in %s blob header, was %08x, should be %08x\n",
                  Name,
                  BlobHead->m_dwVersion,
                  BLOB_VERSION_NUM) );
        HANDLE_FAILURE(good);
    }

    if (BlobHead->m_dwBlbType != BlobType)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyBlobHeader: Invalid TYPE in %s blob header, was %08x, should be %08x\n",
                  Name,
                  BlobHead->m_dwBlbType,
                  BlobType) );
        HANDLE_FAILURE(good);
    }

    if (BlobHead->m_dwMagicNum != BLOB_MAGIC_NUM)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyBlobHeader: Invalid MAGIC NUMBER in %s blob header, was %08x, should be %08x\n",
                  Name,
                  BlobHead->m_dwMagicNum,
                  BLOB_MAGIC_NUM) );
        HANDLE_FAILURE(good);
    }

    if ((BlobHead->m_dwEntries <= 0) || (BlobHead->m_dwEntries >= 10000))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyBlobHeader: Invalid ENTRIES in %s blob header, was %08x, should be > 0 and < 10,000\n",
                  Name,
                  BlobHead->m_dwEntries) );
        HANDLE_FAILURE(good);
    }

    return good;
}



BOOL
SrVerifyHashHeader(
    ListHeader *HashHead,
    PCHAR Name,
    DWORD Offset
    )
/*++

Routine Description:

    Verify that the given TREE Header is valid

Arguments:


Return Value:

    TRUE if OK else FALSE

--*/
{
    BOOL good = TRUE;
    DWORD calculatedSize;
    DWORD numNodes;

    UNREFERENCED_PARAMETER( Offset );

    //
    //  Verify BLOB header
    //

    if (!SrVerifyBlobHeader(&HashHead->m_BlobHeader,Name,BLOB_TYPE_HASHLIST))
    {
        return FALSE;
    }

    //
    // paulmcd: jan/2001
    // m_iHashBuckets will not be exact with m_dwEntries as it is the next
    // highest prime number.  but it will always be larger than or equalto.
    //
    
    if (HashHead->m_iHashBuckets < HashHead->m_BlobHeader.m_dwEntries)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyHashHeader: Invalid HASH BUCKET COUNT in %s header, is %08x, should be %08x or %08x\n",
                  Name,
                  HashHead->m_iHashBuckets,
                  HashHead->m_BlobHeader.m_dwEntries,
                  HashHead->m_BlobHeader.m_dwEntries+1) );
        HANDLE_FAILURE(good);
    }

    if ((HashHead->m_dwDataOff != HashHead->m_BlobHeader.m_dwMaxSize))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyHashHeader: Invalid DATA OFFSET in %s header, is %08x, should be %08x\n",
                  Name,
                  HashHead->m_dwDataOff,
                  HashHead->m_BlobHeader.m_dwMaxSize) );
        HANDLE_FAILURE(good);
    }

    if ((HashHead->m_iFreeNode != 0))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyHashHeader: Invalid FREE NODE in %s header, is %08x, should be 0\n",
                  Name,
                  HashHead->m_iFreeNode) );
        HANDLE_FAILURE(good);
    }

    //
    //  Make sure the calucalted size is accurate
    //

    numNodes = HashHead->m_BlobHeader.m_dwEntries + 1;

    calculatedSize = sizeof(ListHeader) + 
                     (HashHead->m_iHashBuckets * sizeof(DWORD)) +
                     (numNodes * sizeof(ListEntry));

    if (calculatedSize >= HashHead->m_BlobHeader.m_dwMaxSize)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyHashHeader: Invalid CALCULATED SIZE in %s header, is %08x, should be < %08x\n",
                  Name,
                  calculatedSize,
                  HashHead->m_BlobHeader.m_dwMaxSize) );
        HANDLE_FAILURE(good);
    }

    return good;
}


BOOL
SrVerifyHash(
    ListHeader *HashHead,
    PCHAR Name,
    DWORD Offset
    )
/*++

Routine Description:

    Verify that the given TREE entries are valid

Arguments:


Return Value:

    TRUE if OK else FALSE

--*/
{
    BOOL good = TRUE;
    UINT i;
    DWORD dataStart;
    DWORD numNodes;
    DWORD numBuckets;
    DWORD *hTable;
    ListEntry *hNode;

    //
    //  Validate the HEADER
    //

    if (!SrVerifyHashHeader(HashHead,Name,Offset))
    {
        return FALSE;
    }

    //
    // paulmcd: we have hash bucket and actual nodes.  there is one extra
    // actual node than reported due to offset zero being null.  the bucket
    // count is the next largest prime from numNodes 
    //

    numBuckets = HashHead->m_iHashBuckets;
    numNodes = HashHead->m_BlobHeader.m_dwEntries + 1;

    //
    //  Validate Hash table entries
    //

    hTable = (DWORD *)(HashHead + 1);

    for (i=0;i < HashHead->m_iHashBuckets;i++,hTable++) {

        if (*hTable >= numNodes)
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyHash: Invalid HASH TABLE ENTRY[%d] in %s, is %08x, should be < %08x\n",
                      i,
                      Name,
                      *hTable,
                      numNodes) );
            HANDLE_FAILURE(good);
        }
    }

    //
    //  Validate the start of the Hash LIST entries
    //

    {
        ULONG_PTR actualOffset;
        ULONG_PTR calculatedOffset;

        actualOffset = (ULONG_PTR)hTable - (ULONG_PTR)HashHead;
        calculatedOffset = sizeof(ListHeader) + 
                            (HashHead->m_iHashBuckets * sizeof(DWORD));

        if (calculatedOffset != actualOffset)
        {
            SrTrace( BLOB_VERIFICATION,
                    ("sr!SrVerifyHash: Invalid HASH LIST START in %s, offset is %08x, should be %08x\n",
                     Name,
                     actualOffset,
                     calculatedOffset) );
            HANDLE_FAILURE(good);
        }
    }

    //
    //  Validate the Hash DATA entries
    //

    hNode = (ListEntry *)hTable;
    dataStart = sizeof(ListHeader) + 
                    (HashHead->m_iHashBuckets * sizeof(DWORD)) +
                    (numNodes * sizeof(ListEntry));

    for (i=0;i < numNodes;i++,hNode++) {

        if ((hNode->m_iNext < 0) ||
             (hNode->m_iNext >= (INT)HashHead->m_iHashBuckets))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyHash: Invalid HASH NODE[%d] NEXT INDEX in %s, is %08x, should be < %08x\n",
                      i,
                      Name,
                      hNode->m_iNext,
                      HashHead->m_iHashBuckets) );
            HANDLE_FAILURE(good);
        }

        if ((hNode->m_dwData != 0) && 
            ((hNode->m_dwData < dataStart) || 
             (hNode->m_dwData >= HashHead->m_BlobHeader.m_dwMaxSize)))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyHash: Invalid HASH NODE[%d] DATA INDEX in %s, is %08x, should be >= %08x and < %08x\n",
                      i,
                      Name,
                      hNode->m_dwData,
                      dataStart,
                      HashHead->m_BlobHeader.m_dwMaxSize) );
            HANDLE_FAILURE(good);
        }
        else if ((hNode->m_dwData != 0) &&
                 ((WCHAR)hNode->m_dwDataLen != *(PWCHAR)((DWORD_PTR)HashHead + hNode->m_dwData)))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyHash: Invalid HASH NODE[%d] DATA LENGTH in %s, is %08x, should be %08x\n",
                      i,
                      Name,
                      hNode->m_dwDataLen,
                      *(PWCHAR)((DWORD_PTR)HashHead + hNode->m_dwData)) );
            HANDLE_FAILURE(good);
        }

        if ((hNode->m_dwType != NODE_TYPE_UNKNOWN) &&
            (hNode->m_dwType != NODE_TYPE_INCLUDE) && 
            (hNode->m_dwType != NODE_TYPE_EXCLUDE))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyHash: Invalid HASH NODE[%d] TYPE in %s, is %08x, should be %08x, %08x or %08x\n",
                      i,
                      Name,
                      hNode->m_dwType,
                      NODE_TYPE_UNKNOWN,
                      NODE_TYPE_INCLUDE,
                      NODE_TYPE_EXCLUDE) );
            HANDLE_FAILURE(good);
        }
    }

    return good;
}


BOOL
SrVerifyTreeHeader(
    TreeHeader *TreeHead,
    PCHAR Name
    )
/*++

Routine Description:

    Verify that the given TREE Header is valid

Arguments:


Return Value:

    TRUE if OK else FALSE

--*/
{
    BOOL good = TRUE;
    DWORD calculatedSize;

    //
    //  Verify BLOB header
    //

    if (!SrVerifyBlobHeader(&TreeHead->m_BlobHeader,Name,BLOB_TYPE_PATHTREE))
    {
        return FALSE;
    }

    if ((TreeHead->m_dwMaxNodes != TreeHead->m_BlobHeader.m_dwEntries))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyTreeHeader: Invalid MAX NODES in %s header, is %08x, should be %08x\n",
                  Name,
                  TreeHead->m_dwMaxNodes,
                  TreeHead->m_BlobHeader.m_dwEntries) );
        HANDLE_FAILURE(good);
    }

    if ((TreeHead->m_dwDataSize >= TreeHead->m_BlobHeader.m_dwMaxSize))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyTreeHeader: Invalid DATA SIZE in %s header, is %08x, should be < %08x\n",
                  Name,
                  TreeHead->m_dwDataSize,
                  TreeHead->m_BlobHeader.m_dwMaxSize) );
        HANDLE_FAILURE(good);
    }

    if ((TreeHead->m_dwDataOff != TreeHead->m_BlobHeader.m_dwMaxSize))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyTreeHeader: Invalid DATA OFFSET in %s header, is %08x, should be %08x\n",
                  Name,
                  TreeHead->m_dwDataOff,
                  TreeHead->m_BlobHeader.m_dwMaxSize) );
        HANDLE_FAILURE(good);
    }

    if ((TreeHead->m_iFreeNode != 0))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyTreeHeader: Invalid FREE NODE in %s header, is %08x, should be 0\n",
                  Name,
                  TreeHead->m_iFreeNode) );
        HANDLE_FAILURE(good);
    }

    if ((TreeHead->m_dwDefault != NODE_TYPE_EXCLUDE))
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyTreeHeader: Invalid DEFAULT in %s header, is %08x, should be %08x\n",
                  Name,
                  TreeHead->m_dwDefault,
                  NODE_TYPE_EXCLUDE) );
        HANDLE_FAILURE(good);
    }

    //
    //  Make sure the calucalted size is accurate
    //

    calculatedSize = sizeof(TreeHeader) + 
                     (TreeHead->m_dwMaxNodes * sizeof(TreeNode)) +
                     TreeHead->m_dwDataSize;

    if (calculatedSize != TreeHead->m_BlobHeader.m_dwMaxSize)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyTreeHeader: Invalid CALCULATED SIZE in %s header, is %08x, should be %08x\n",
                  Name,
                  calculatedSize,
                  TreeHead->m_BlobHeader.m_dwMaxSize) );
        HANDLE_FAILURE(good);
    }

    return good;
}


BOOL
SrVerifyTree(
    TreeHeader *TreeHead,
    PCHAR Name,
    DWORD Offset
    )
/*++

Routine Description:

    Verify that the given TREE entries are valid

Arguments:


Return Value:

    TRUE if OK else FALSE

--*/
{
    BOOL good = TRUE;
    UINT i;
    DWORD dataStart;
    TreeNode *tn;
    ListHeader *localHashHead;
    char localName[128];

    //
    //  Validate the HEADER
    //

    if (!SrVerifyTreeHeader(TreeHead,Name)) {

        return FALSE;
    }

    //
    //  Validate the DATA entries
    //

    tn = (TreeNode *)(TreeHead + 1);
    dataStart = sizeof(TreeHeader) + 
                (TreeHead->m_dwMaxNodes * sizeof(TreeNode));


    for (i=0;i < TreeHead->m_dwMaxNodes;i++,tn++)
    {
        if ((tn->m_iFather < 0) ||
            (tn->m_iFather >= (INT)TreeHead->m_dwMaxNodes))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyTree: Invalid TREE NODE[%d] FATHER index in %s, is %08x, should be < %08x\n",
                      i,
                      Name,
                      tn->m_iFather,
                      TreeHead->m_dwMaxNodes) );
            HANDLE_FAILURE(good);
        }

        if ((tn->m_iSon < 0) || 
            (tn->m_iSon >= (INT)TreeHead->m_dwMaxNodes))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyTree: Invalid TREE NODE[%d] SON index in %s, is %08x, should be < %08x\n",
                      i,
                      Name,
                      tn->m_iSon,
                      TreeHead->m_dwMaxNodes) );
            HANDLE_FAILURE(good);
        }

        if ((tn->m_iSibling < 0) || 
            (tn->m_iSibling >= (INT)TreeHead->m_dwMaxNodes))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyTree: Invalid TREE NODE[%d] SIBLING index in %s, is %08x, should be < %08x\n",
                      i,
                      Name,
                      tn->m_iSibling,
                      TreeHead->m_dwMaxNodes) );
            HANDLE_FAILURE(good);
        }

        if ((tn->m_dwData < dataStart) || 
            (tn->m_dwData >= TreeHead->m_BlobHeader.m_dwMaxSize))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyTree: Invalid TREE NODE[%d] DATA index in %s, is %08x, should be >= %08x and < %08x\n",
                      i,
                      Name,
                      tn->m_dwData,
                      dataStart,
                      TreeHead->m_BlobHeader.m_dwMaxSize) );
            HANDLE_FAILURE(good);
        }

        if (tn->m_dwFileList != 0)
        {
            if ((tn->m_dwFileList < dataStart) || 
                (tn->m_dwFileList >= TreeHead->m_BlobHeader.m_dwMaxSize))
            {
                SrTrace( BLOB_VERIFICATION,
                         ("sr!SrVerifyTree: Invalid TREE NODE[%d] FILELIST index in %s, is %08x, should be >= %08x and < %08x\n",
                          i,
                          Name,
                          tn->m_dwData,
                          dataStart,
                          TreeHead->m_BlobHeader.m_dwMaxSize) );
                HANDLE_FAILURE(good);
            }
            else
            {
                localHashHead = (ListHeader *)((DWORD_PTR)TreeHead + tn->m_dwFileList);
                sprintf(localName,"TreeNode[%d]",i);

                if (!SrVerifyHash(localHashHead,localName,(Offset+tn->m_dwFileList)))
                {
                    HANDLE_FAILURE(good);
                }
            }
        }

        if ((tn->m_dwType != NODE_TYPE_UNKNOWN) && 
            (tn->m_dwType != NODE_TYPE_INCLUDE) && 
            (tn->m_dwType != NODE_TYPE_EXCLUDE))
        {
            SrTrace( BLOB_VERIFICATION,
                     ("sr!SrVerifyTree: Invalid TREE NODE[%d] TYPE in %s, is %08x, should be %08x, %08x or %08x\n",
                      i,
                      Name,
                      tn->m_dwType,
                      NODE_TYPE_UNKNOWN,
                      NODE_TYPE_INCLUDE,
                      NODE_TYPE_EXCLUDE) );
            HANDLE_FAILURE(good);
        }
    }

    return good;
}



BOOL
SrVerifyBlob(
    PBYTE Blob
    )
/*++

Routine Description:

    Verify that the given BLOB is valid

Arguments:


Return Value:

    TRUE if OK else FALSE

--*/
{
    BlobHeader *blobHead;    
    TreeHeader *treeHead;
    ListHeader *hashHead;
    DWORD calculatedSize = 0;

    //
    //  Verify header to entire blob
    //

    blobHead = (BlobHeader *)Blob;

    if (!SrVerifyBlobHeader(blobHead,"PRIMARY",BLOB_TYPE_CONTAINER))
    {
        return FALSE;
    }

    calculatedSize += sizeof(BlobHeader);
    
    //
    //  Verify TreeHeader and Data
    //

    treeHead = (TreeHeader *)(Blob + calculatedSize);

    if (!SrVerifyTree(treeHead,"PRIMARY TREE",calculatedSize))
    {
        return FALSE;
    }

    calculatedSize += treeHead->m_BlobHeader.m_dwMaxSize;

    //
    //  Verify HashHeader and DATA
    //

    hashHead = (ListHeader *)(Blob + calculatedSize);

    if (!SrVerifyHash(hashHead,"PRIMARY HASH",calculatedSize))
    {
        return FALSE;
    }

    calculatedSize += hashHead->m_BlobHeader.m_dwMaxSize;
    
    //
    //  Validate total SIZE
    //

    if (calculatedSize != blobHead->m_dwMaxSize)
    {
        SrTrace( BLOB_VERIFICATION,
                 ("sr!SrVerifyBlob: Invalid PRIMARY BLOB size, is %08x, calculated to be %08x\n",
                  blobHead->m_dwMaxSize,
                  calculatedSize) );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\tests\fileids\oidtst.h ===
// oidtst.h


#ifndef _OIDTST_H_
#define _OIDTST_H_

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>


int
FsTestDecipherStatus(
	IN NTSTATUS Status
	);

void
FsTestHexDump (
    IN UCHAR *Buffer,
    IN ULONG Size
    );
    
void
FsTestHexDumpLongs (
    IN ULONG *Buffer,
    IN ULONG SizeInBytes
    );
    
int
FsTestSetOid( 
	IN HANDLE hFile, 
	IN FILE_OBJECTID_BUFFER ObjectIdBuffer 
	);

int
FsTestGetOid( 
	IN HANDLE hFile, 
	IN FILE_OBJECTID_BUFFER *ObjectIdBuffer 
	);

int
FsTestOpenByOid ( 
    IN UCHAR *ObjectId,
    IN ULONG ArgLength,
    IN PWCHAR DriveLetter
    );

int
FsTestDeleteOid( 
	IN HANDLE hFile
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\tests\fileids\genoid.c ===
//  genoid.c

#include "oidtst.h"

#define VOLUME_PATH  L"\\\\.\\H:"
#define VOLUME_DRIVE_LETTER_INDEX 4
#define FULL_PATH    L"\\??\\H:\\1234567890123456"
#define FULL_DRIVE_LETTER_INDEX 4
#define DEVICE_PREFIX_LEN 14

#define RELATIVE_OPEN


int
FsTestGenOid( 
    IN HANDLE hFile, 
    IN FILE_OBJECTID_BUFFER *ObjectIdBuffer 
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                           // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_CREATE_OR_GET_OBJECT_ID,   // FsControlCode
                              &hFile,                          // input buffer
                              sizeof(HANDLE),                  // input buffer length
                              ObjectIdBuffer,                  // OutputBuffer for data from the FS
                              sizeof(FILE_OBJECTID_BUFFER) );  // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nOid for this file is:" );
        
        FsTestHexDump( ObjectIdBuffer->ObjectId, 16 );
        
        printf( "\nExtended info is:" );

        FsTestHexDump( ObjectIdBuffer->ObjectId, 64 );
    }

    return FsTestDecipherStatus( Status );
}

int
FsTestGetFileId( 
    IN HANDLE hFile, 
    IN PFILE_INTERNAL_INFORMATION FileId 
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtQueryInformationFile( hFile,                           // file handle
                                     &IoStatusBlock,                  // iosb
                                     FileId,
                                     sizeof( FILE_INTERNAL_INFORMATION ),
                                     FileInternalInformation );
                                     
    if (Status == STATUS_SUCCESS) {

        printf( "\nFile id for this file is:" );
        
        FsTestHexDump( (PCHAR)FileId, 8 );
    }

    return FsTestDecipherStatus( Status );
}

int
FsTestGetName (
    HANDLE File
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAME_INFORMATION FileName;
    WCHAR buffer[100];

    FileName = (PFILE_NAME_INFORMATION) buffer;
    
    Status = NtQueryInformationFile( File,
                                     &IoStatusBlock,
                                     FileName, 
                                     sizeof( buffer ),
                                     FileNameInformation );

    if (Status == STATUS_SUCCESS)
    {
        printf( "\nFilename is: %.*lS", 
                FileName->FileNameLength/sizeof(WCHAR), 
                FileName->FileName );
    }

    return FsTestDecipherStatus( Status );
}

DWORD
FsTestOpenVolumeHandle (
    PWCHAR DriveLetter,
    HANDLE *VolumeHandle
    )
{
    WCHAR Volume[] = VOLUME_PATH;
    DWORD Status = 0;

    //
    //  Open the volume for relative opens.
    //

    RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    *VolumeHandle = CreateFileW( (PUSHORT) &Volume,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );

    if (*VolumeHandle == INVALID_HANDLE_VALUE) {

        Status = GetLastError();
        printf( "Unable to open %ws volume\n", &Volume );
        printf( "Error from CreateFile", Status );
        return Status;
    }

    return Status;
}

NTSTATUS
FsTestOpenFileById (
    IN HANDLE VolumeHandle,
    IN PUNICODE_STRING FileId,
    OUT HANDLE *File
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    
    InitializeObjectAttributes( &ObjectAttributes,
                                FileId,
                                0, 
                                VolumeHandle,
                                NULL );

    Status = NtCreateFile( File,
                           GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_OVERWRITE,
                           FILE_OPEN_BY_FILE_ID,
                           NULL,
                           0 );

    if (!NT_SUCCESS( Status )) {
        FsTestDecipherStatus( Status );
        return Status;
    }
    
    return Status;
}

VOID
FsTestGenerateFullName (
    IN PWCHAR DriveLetter,
    IN PUNICODE_STRING FileId,
    OUT PUNICODE_STRING FullName
    )
{
    WCHAR FullPath[] = FULL_PATH;
    UNICODE_STRING DeviceName;

    ASSERT( FullName->MaximumLength >= (DEVICE_PREFIX_LEN + FileId->Length) );

    RtlCopyMemory( &FullPath[FULL_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );

    DeviceName.Length = DeviceName.MaximumLength = DEVICE_PREFIX_LEN;
    DeviceName.Buffer = FullPath;

    RtlCopyUnicodeString( FullName, &DeviceName );
    RtlAppendUnicodeStringToString( FullName, FileId );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    HANDLE VolumeHandle = NULL;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    FILE_INTERNAL_INFORMATION FileId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING IdString;
    NTSTATUS Status;
    WCHAR DriveLetter;
    WCHAR FullNameBuffer [100];
    UNICODE_STRING FullName;

    //
    //  Get parameters 
    //

    if (argc < 3) {
        printf("This program finds the object id of a file and generates one if necessary (ntfs only), then prints out the file name once that file is opened by the ids.\n\n");
        printf("usage: %s drive filename\n", argv[0]);
        return;
    }

    File = CreateFile( argv[2],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( File == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[2], GetLastError() );
        return;
    }

    FsTestGetName( File );

    RtlZeroBytes( &FileId, sizeof( FileId ) );
    FsTestGetFileId( File, &FileId );

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );
    FsTestGenOid( File, &ObjectIdBuffer );

    CloseHandle( File );

    DriveLetter = *argv[1];

#ifdef RELATIVE_OPEN
    FsTestOpenVolumeHandle( &DriveLetter, &VolumeHandle );

    if (VolumeHandle == INVALID_HANDLE_VALUE) {
        goto main_exit;
    }
#endif

    RtlInitEmptyUnicodeString( &FullName, FullNameBuffer, sizeof( FullNameBuffer ) );

    printf( "\nReopening file by file id....\n" );

    IdString.Length = IdString.MaximumLength = sizeof( LARGE_INTEGER );
    IdString.Buffer = (PWSTR) &FileId;

#ifdef RELATIVE_OPEN
    Status = FsTestOpenFileById( VolumeHandle, &IdString , &File );
#else
    FsTestGenerateFullName( &DriveLetter, &IdString, &FullName );
    Status = FsTestOpenFileById( VolumeHandle, &FullName , &File );
#endif    
    
    if (!NT_SUCCESS( Status )) {
        goto main_exit;
    }
    
    FsTestGetName( File );
    
    NtClose( File );



    printf( "\nReopening file by object id....\n" );

    IdString.Length = IdString.MaximumLength = 16 * sizeof( UCHAR );
    IdString.Buffer = (PWSTR) &(ObjectIdBuffer.ObjectId);

#ifdef RELATIVE_OPEN
    Status = FsTestOpenFileById( VolumeHandle, &IdString , &File );
#else
    FsTestGenerateFullName( &DriveLetter, &IdString, &FullName );
    Status = FsTestOpenFileById( VolumeHandle, &FullName , &File );
#endif    
    
    if (!NT_SUCCESS( Status )) {
        goto main_exit;
    }
    
    FsTestGetName( File );
    
    NtClose( File );

main_exit:
    
    if (VolumeHandle != NULL) {
        CloseHandle( VolumeHandle );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\tests\fileids\oidtst.c ===
//  oidtst.c

#include "oidtst.h"


int
FsTestDecipherStatus(
	IN NTSTATUS Status
	)
{
	int Error;

    printf( "\nStatus %x -- ", Status );

	switch(Status) {

	    case STATUS_ACCESS_DENIED:
			printf( "STATUS_ACCESS_DENIED\n" );
			break;

	    case STATUS_NOT_IMPLEMENTED:
			printf( "STATUS_NOT_IMPLEMENTED\n" );
			break;			

	    case STATUS_NOT_LOCKED:
			printf( "STATUS_NOT_LOCKED\n" );
			break;			
			
		case STATUS_OBJECTID_EXISTS:
			printf( "STATUS_OBJECTID_EXISTS\n" );
			break;

		case STATUS_BUFFER_OVERFLOW:
			printf( "STATUS_BUFFER_OVERFLOW\n" );
			break;

		case STATUS_NO_MORE_FILES:
			printf( "STATUS_NO_MORE_FILES\n" );
			break;

		case STATUS_DUPLICATE_NAME:
			printf( "STATUS_DUPLICATE_NAME\n" );
			break;

		case STATUS_OBJECT_NAME_COLLISION:
			printf( "STATUS_OBJECT_NAME_COLLISION\n" );
			break;

		case STATUS_OBJECT_NAME_NOT_FOUND:
			printf( "STATUS_OBJECT_NAME_NOT_FOUND\n" );
			break;

		case STATUS_INVALID_ADDRESS:
			printf( "STATUS_INVALID_ADDRESS\n" );
			break;

		case STATUS_INVALID_PARAMETER:
			printf( "STATUS_INVALID_PARAMETER\n" );
			break;

		case STATUS_OBJECT_PATH_NOT_FOUND:
			printf( "STATUS_OBJECT_PATH_NOT_FOUND\n" );
			break;

		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			printf( "STATUS_OBJECT_PATH_SYNTAX_BAD\n" );
			break;

		case STATUS_SUCCESS:
			printf( "STATUS_SUCCESS\n" );
			break;

		default:	  
			printf( "(unknown status code)\n" );
			break;
	}

    if (Status != STATUS_SUCCESS) {

		Error = GetLastError();
        printf( "GetLastError returned (dec): %d\n", Error );

		return 1;
    }       

	return 0;
}

void
FsTestHexDump (
    IN UCHAR *Buffer,
    IN ULONG Size
    )
{
    ULONG idx;

    printf( "\n" );
    
    for (idx = 0; idx < Size; idx += 1) {
    
//        printf( "%02x %c  ", Buffer[idx], Buffer[idx] );
        printf( "%02x ", Buffer[idx] );
    }
}

void
FsTestHexDumpLongs (
    IN ULONG *Buffer,
    IN ULONG SizeInBytes
    )
{
    ULONG idx;
    ULONG Size = SizeInBytes / 4;

    printf( "\n" );
    
    for (idx = 0; idx < Size; idx += 1) {
    
        printf( "%08x ", Buffer[idx] );
    }
}
    
#if 0

void
FsTestDumpMenu(
		 void
		 )
{
    printf( "\n s -- Set object id" );	
    printf( "\n g -- Get object id" );	
    printf( "\n d -- Delete object id" );	
    printf( "\n o -- Open file by object id" );	
	printf( "\n q -- Quit" );	
}


int
FsTestDoCommand(
		   IN HANDLE hFile,
		   IN OUT OBJECTID *ObjectId
		  )

{
    char cmd[8];
	int retval = 0;
	HANDLE OpenedFile;
	
    printf( "\n -->" );

    scanf( "%s", cmd);

	switch(cmd[0]) {
	case 's':
		FsTestSetOid( hFile, *ObjectId );
		break;

	case 'g':
		FsTestGetOid( hFile, ObjectId );
		break;

	case 'd':
		FsTestDeleteOid( hFile, *ObjectId );
		break;

	case 'o':
		FsTestOpenByOid( *ObjectId, &OpenedFile );
		break;

	case 'q':
		retval = 1;
		break;

	default:
		printf( "\n Try again" );
    }

	return retval;
}


VOID
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
	OBJECTID ObjectId;

    //
    //  Get parameters 
    //

    if (argc < 3) {
        printf("This program tests object ids (ntfs only).\n\n");
        printf("usage: %s filename ObjectId\n", argv[0]);
        return;
    }

    hFile = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

	RtlZeroBytes( &ObjectId,
	 			  sizeof( ObjectId ) );

	sscanf( argv[2], "%d", &ObjectId.Lineage.Data1 );

	printf( "\nUsing file:%s, ObjectId:%d", argv[1], ObjectId.Lineage.Data1 );

	while (retval == 0) {

		FsTestDumpMenu();
		retval = FsTestDoCommand( hFile, &ObjectId );
	}

	CloseHandle( hFile );    

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\cab.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <dos.h>

#include <time.h>
#include <tchar.h>

#include <cab.h>		//Cab file headers
// #include <main.h>		//Main program header file

////////////////////////////
//Cabbing Context Variables
////////////////////////////
ERF				erf;
client_state	cs;

//Global Definations for some static setting
// Set these to override the defaults
char g_szCabFileLocation[_MAX_PATH] = {""};	//This is the fully qualified path, must have a \ at the end
char g_szCabFileName[_MAX_PATH] = {""};		//this is the file name for the cab.. Suggest that it has a .cab for telling its a cab
extern void Log(char *szString);
extern void Log2(char *szString, char *szString2);




/*
///////////////////////////////
// Cabbing API Helper Functions 
/////////////////////./////////
*/


/*
 * Memory allocation function
 */
FNFCIALLOC(mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFCIFREE(mem_free)
{
	free(memory);
}


/*
 * File i/o functions
 */
FNFCIOPEN(fci_open)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIREAD(fci_read)
{
    unsigned int result;

    result = (unsigned int) _read(hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCIWRITE(fci_write)
{
    unsigned int result;

    result = (unsigned int) _write(hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCICLOSE(fci_close)
{
    int result;

    result = _close(hf);

    if (result != 0)
        *err = errno;

    return result;
}

FNFCISEEK(fci_seek)
{
    long result;

    result = _lseek(hf, dist, seektype);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIDELETE(fci_delete)
{
    int result;

    result = remove(pszFile);

    if (result != 0)
        *err = errno;

    return result;
}


/*
 * File placed function called when a file has been committed to a cabinet
 */
FNFCIFILEPLACED(file_placed)
{
	if (fContinuation)
		Log("      (Above file is a later segment of a continued file)\n");

	return 0;
}


/*
 * Function to obtain temporary files
 */
FNFCIGETTEMPFILE(get_temp_file)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** if Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}


/*
 * Progress function
 */
FNFCISTATUS(progress)
{
	client_state	*cs;

	cs = (client_state *) pv;

	if (typeStatus == statusFile)
	{
        cs->total_compressed_size += cb1;
		cs->total_uncompressed_size += cb2;

		/*
		 * Compressing a block into a folder
		 * cb2 = uncompressed size of block
		 */
		//printf(
        //    "Compressing: %9ld -> %9ld             \r",
        //    cs->total_uncompressed_size,
        //    cs->total_compressed_size
		//);
		
		fflush(stdout);
	}
	else if (typeStatus == statusFolder)
	{
		int	percentage;

		/*
		 * Adding a folder to a cabinet
		 * cb1 = amount of folder copied to cabinet so far
		 * cb2 = total size of folder
		 */
		percentage = get_percentage(cb1, cb2);

		//printf("Copying folder to cabinet: %d%%      \r", percentage);
		fflush(stdout);
	}

	return 0;
}



FNFCIGETNEXTCABINET(get_next_cabinet)
{
	char lpBuffer[_MAX_PATH];	

	/*
	 * Cabinet counter has been incremented already by FCI
	 * Store next cabinet name
	 */
	strGenerateCabFileName(lpBuffer, MAX_COMPUTERNAME_LENGTH +1);	//BUGBUG I am just glueing this together, should check for error
	strcpy(pccab->szCab, lpBuffer);

	/*
	 * You could change the disk name here too, if you wanted
	 */

	return TRUE;
}



FNFCIGETOPENINFO(get_open_info)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME					filetime;
	HANDLE						handle;
    DWORD                       attrs;
    int                         hf;

     //*
     //* Need a Win32 type handle to get file date/time
     //* using the Win32 APIs, even though the handle we
     //* will be returning is of the type compatible with
     //* _open
     //*
	handle = CreateFileA(
		pszName,			//BUGBUG ARG What should this be???
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING, //OPEN_EXISTING
		FILE_ATTRIBUTE_NORMAL, //FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN
		NULL
	);
   
	if (INVALID_HANDLE_VALUE == handle)
	{
		printf("DEBUG: Invalid Handle for CreateFile\n");
		printf("DEBUG: %ld\n", GetLastError());
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
		printf("DEBUG: GetFileInformation Failed\n");
		CloseHandle(handle);
		return -1;
	}
   
	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime, 
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

    attrs = GetFileAttributes((const LPCTSTR)pszName);

    if (attrs == 0xFFFFFFFF)
    {
        // failure
        *pattribs = 0;
    }
    else
    {
         //*
         //* Mask out all other bits except these four, since other
         //* bits are used by the cabinet format to indicate a
         //* special meaning.
         //*
        *pattribs = (int) (attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
    }

    CloseHandle(handle);

     //*
     //* Return handle using _open
     //*
	hf = _open( pszName, _O_RDONLY | _O_BINARY );

	if (hf == -1)
		return -1; // abort on error
   
	return hf;
}



void set_cab_parameters(PCCAB cab_parms)
{	
	const char *szCabStorePath="";
	char lpBuffer[_MAX_PATH];	
	

	memset(cab_parms, 0, sizeof(CCAB));

	cab_parms->cb = MEDIA_SIZE;
	cab_parms->cbFolderThresh = FOLDER_THRESHOLD;

	/*
	 * Don't reserve space for any extensions
	 */
	cab_parms->cbReserveCFHeader = 0;
	cab_parms->cbReserveCFFolder = 0;
	cab_parms->cbReserveCFData   = 0;

	/*
	 * We use this to create the cabinet name
	 */
	cab_parms->iCab = 1;

	/*
	 * If you want to use disk names, use this to
	 * count disks
	 */
	cab_parms->iDisk = 0;

	/*
	 * Choose your own number
	 */
	cab_parms->setID = 12345;

	/*
	 * Only important if CABs are spanning multiple
	 * disks, in which case you will want to use a
	 * real disk name.
	 *
	 * Can be left as an empty string.
	 */
	strcpy(cab_parms->szDisk, "MyDisk");

	/* where to store the created CAB files */
	if( NULL != *g_szCabFileLocation)
	{
		//make sure that we have a \\ on the end of the path to the cab.
		if( '\\' != g_szCabFileLocation[strlen(g_szCabFileLocation)] )
			strcat(g_szCabFileLocation, "\\");
		strcpy(cab_parms->szCabPath, g_szCabFileLocation);
	}
	else
	{
		szCabStorePath = getenv("TEMP");
		strcpy(cab_parms->szCabPath, szCabStorePath);
		strcat(cab_parms->szCabPath, "\\");
	}

	//**
	//check if last char in path is "\"
   // len = strlen(g_szCurrDir);
//	if ('\' != g_szCurrDir[len-1])
//		strcat(cab_parms->szCabPath, "\\"); //Not the root: Append "\"at end of path

		/* store name of first CAB file */
	strGenerateCabFileName(lpBuffer, _MAX_PATH);	//BUGBUG I am just glueing this together, should check for error

	strcpy(cab_parms->szCab, lpBuffer);

	sprintf(lpBuffer, "Cab location = %s%s\n", cab_parms->szCabPath, cab_parms->szCab);
	Log(lpBuffer);
		
}

/*
************************************************************************
*
*  Function:   create_cab()
*
*  Initializes the Context to create a CAB File.
*  Returns hcfi if successful (context to a Cab file).
*
************************************************************************
*/

HFCI create_cab()
{
	// Initialize our internal state
	HFCI	hfci;
	CCAB	cab_parameters;	 

    cs.total_compressed_size = 0;
	cs.total_uncompressed_size = 0;

	set_cab_parameters(&cab_parameters);

	hfci = FCICreate(
		&erf,
		file_placed,
		mem_alloc,
		mem_free,
        fci_open,
        fci_read,
        fci_write,
        fci_close,
        fci_seek,
        fci_delete,
		get_temp_file,
        &cab_parameters,
        &cs
	);

	if (hfci == NULL)
	{
		Log2("FCICreate() failed: ",return_fci_error_string((FCIERROR)erf.erfOper));
		printf("FCICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string((FCIERROR)erf.erfOper)
		);

		return hfci;
	}
	else
		return hfci;
}

/*
********************************************************************************
*
*  Function:   flush_cab
*
*  Forces the Cabinet under construction to be completed and written to disk.
*  Returns TRUE if successful
*
********************************************************************************
*/

BOOL flush_cab(HFCI hfci)

{	

	 // This will automatically flush the folder first
	 
	if (FALSE == FCIFlushCabinet(
		hfci,
		FALSE,
		get_next_cabinet,
		progress))
	{

		Log2("FCIFlushCabinet() failed: ",return_fci_error_string((FCIERROR)erf.erfOper));
		printf("FCIFlushCabinet() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string((FCIERROR)erf.erfOper)
		);

        (void) FCIDestroy(hfci);

		return FALSE;
	}

    if (FCIDestroy(hfci) != TRUE)
	{
		Log2("FCIDestroy() failed: ",return_fci_error_string((FCIERROR)erf.erfOper));
		printf("FCIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string((FCIERROR)erf.erfOper)
		);

		return FALSE;
	}

	return TRUE;
}

/*
**************************************************************************************
*
*  Function:   test_fci
*
*  Adds Files to HFCI Context, Cabs them and flushes the folder (generates Cab file).
*  Returns TRUE if successfull
*
***************************************************************************************
*/

bool test_fci(HFCI hfci, int num_files, char *file_list[], char *currdir)
{
	int i;

	// Add files in the Array passed in file_list[]

	for (i = 0; (i < num_files)&&(strlen(file_list[i])); i++)
	{
		char	stripped_name[256];
		char	*szAux;//added ="";

		Log("--------------------------------------------------");
		Log2("Processing File = ",file_list[i]);

		szAux = (char *) malloc(strlen(file_list[i])+strlen(currdir)+1);

		if (NULL!= szAux) 
		{

			if (NULL == currdir) // if currdir is empty, then just pass element[i] in argv[]
				strcpy(szAux,file_list[i]);
			else {
				strcpy(szAux,currdir);   // else append filename to currdir
				strcat(szAux,file_list[i]);
			}

			if( -1 != (_access(szAux, 0 )) )
			{ 
				// Don't store the path name in the cabinet file!
				strip_path(szAux, stripped_name);
				
				if (FALSE == FCIAddFile(
					hfci,			//This was hfci 
					szAux,			/* file to add */
					stripped_name,  /* file name in cabinet file */
					FALSE,			/* file is not executable */
					get_next_cabinet,
					progress,
					get_open_info,
					COMPRESSION_TYPE))
				{
				
					Log2("FCIAddFile() failed: ",return_fci_error_string((FCIERROR)erf.erfOper));
					printf("FCIAddFile() failed: code %d [%s]\n",
							erf.erfOper, return_fci_error_string((FCIERROR)erf.erfOper)
					);

					// I need to continue if file can't be added....

					// (void) FCIDestroy(hfci);
					// return false;
				}
				else 
					Log("File Was Added!");
			}
			else 
				Log("File does not exist! Continuing... ");

			free (szAux);
		}
		else
			Log("Could not allocate enough memory to Cab\n");

	} // End for

	// Done Adding Files
	Log("--------------------------------------------------");
	
	//By here then everything is successful.. If not then you need to uncomment the previous failure return.
	return true;
}



int get_percentage(unsigned long a, unsigned long b)
{
	while (a > 10000000)
	{
		a >>= 3;
		b >>= 3;
	}

	if (b == 0)
		return 0;

	return ((a*100)/b);
}

/*
********************************************************************************
*
*   Function:  strip_path
*
*   Returns the file name of a full path.
*
********************************************************************************
*/

void strip_path(char *filename, char *stripped_name)
{
	char	*p;

	p = strrchr(filename, '\\');
	//printf ("Path + Filename= %s\n",filename);

	if (p == NULL)
		strcpy(stripped_name, filename);
	else
		strcpy(stripped_name, p+1);
}

char *return_fci_error_string(FCIERROR err)
{
	switch (err)
	{
		case FCIERR_NONE:
			return "No error";

		case FCIERR_OPEN_SRC:
			return "Failure opening file to be stored in cabinet";
		
		case FCIERR_READ_SRC:
			return "Failure reading file to be stored in cabinet";
		
		case FCIERR_ALLOC_FAIL:
			return "Insufficient memory in FCI";

		case FCIERR_TEMP_FILE:
			return "Could not create a temporary file";

		case FCIERR_BAD_COMPR_TYPE:
			return "Unknown compression type";

		case FCIERR_CAB_FILE:
			return "Could not create cabinet file";

		case FCIERR_USER_ABORT:
			return "Client requested abort";

		case FCIERR_MCI_FAIL:
			return "Failure compressing data";

		default:
			return "Unknown error";
	}
}


/*
**************************************************************
*
*  Function: Generate Cab File name
*
*  Output: Global String containing a filename
*  szCabFileName = ComputerName + ddmmyy + hhmmss
*
************************************************************** 
*/

DWORD strGenerateCabFileName(char *lpBuffer, DWORD dSize)
{
	time_t ltime;
	struct tm *now;
	char tmpbuf[128];

	//Check to see if we have an override for the cabname, if so use it.
	if( NULL != *g_szCabFileName) 
	{
		strcpy(lpBuffer, g_szCabFileName);
		return 0;
	}

	//
	// Copy Computer Name to CabFileName
	//
	strcpy(lpBuffer, getenv("COMPUTERNAME"));
	//GetComputerName((LPTSTR) lpBuffer, &dSize);
	
	//
	// Append Undescore character to CabFileName
	//
	strcat(lpBuffer, "_");

	//	
	// Get System Time and Date
	//
	time( &ltime );
	now = localtime( &ltime );

	//
	// Convert time/date to mmddyyhhmmss format (24hr)
	//
	if (strftime( tmpbuf, 128,"%m%d%y_%H%M%S", now))
		// Append Timestamp to CabFileName
		strcat(lpBuffer, tmpbuf);
	else {
		Log ("Could not convert system time to mmddyy_hhmmss format\n");
		return -1;
	}

	//Now append on the extension and now we are set.
	strcat(lpBuffer, ".cab");

	return 0;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\cab.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       Cab.h
//
//  Contents:   Header file for function proto types for cab.cpp.
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    9/21/00	SHeffner	Copied from Originaly Millennium code
//
//----------------------------------------------------------------------------


#include <fci.h>
#include <fcntl.h>

#ifndef _CAB_FILE_
#define _CAB_FILE_

/////////////////////////////
// CABBING API DEFINITIONS //
////////////////////////////

/*
 * When a CAB file reaches this size, a new CAB will be created
 * automatically.  This is useful for fitting CAB files onto disks.
 *
 * If you want to create just one huge CAB file with everything in
 * it, change this to a very very large number.
 */
#define MEDIA_SIZE			30000000

/*
 * When a folder has this much compressed data inside it,
 * automatically flush the folder.
 *
 * helps random access significantly.
 * Flushing the folder hurts compression a little bit, but
 */
#define FOLDER_THRESHOLD	900000

/*
 * Compression type to use
 */
#define COMPRESSION_TYPE    tcompTYPE_MSZIP

/*
 * Our internal state
 * The FCI APIs allow us to pass back a state pointer of our own
 */
typedef struct
{
    long    total_compressed_size;      /* total compressed size so far */
	long	total_uncompressed_size;	/* total uncompressed size so far */
} client_state;

//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
//	Function proto typing
//
//----------------------------------------------------------------------------
void set_cab_parameters(PCCAB cab_parms);
HFCI create_cab();
bool test_fci(HFCI hfci, int num_files, char *file_list[], char *currdir);
BOOL flush_cab(HFCI hfci);
int	 get_percentage(unsigned long a, unsigned long b);
DWORD strGenerateCabFileName(char *lpBuffer, DWORD dSize);
char *return_fci_error_string(FCIERROR err);
void strip_path(char *filename, char *stripped_name);
// void FNFCIGETOPENINFO(get_open_info);

#endif		//End of _CAB_FILE_ define
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\chglog.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    chglog.cpp
 *
 *  Abstract:
 *    Tool for enumerating the change log - forward/reverse
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/09/2000
 *        created
 *    SHeffner: Just grabbed the code, and put it into SRDiag.
 *
 *****************************************************************************/

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "srapi.h"
#include <shellapi.h>
#include "enumlogs.h"
#include "srrpcapi.h"


//+---------------------------------------------------------------------------
//
//	Function proto typing
//
//----------------------------------------------------------------------------
LPWSTR GetEventString(DWORD EventId);
void EnumLog(char *szFileName, WCHAR *szDrive);


struct _EVENT_STR_MAP
{
    DWORD   EventId;
    LPWSTR  pEventStr;
} EventMap[ 13 ] =
{
    {SrEventInvalid ,       L"INVALID" },
    {SrEventStreamChange,   L"FILE-MODIFY" },
    {SrEventAclChange,      L"ACL-CHANGE" },
    {SrEventAttribChange,   L"ATTR-CHANGE" },
    {SrEventStreamOverwrite,L"FILE-MODIFY" },
    {SrEventFileDelete,     L"FILE-DELETE" },
    {SrEventFileCreate,     L"FILE-CREATE" },
    {SrEventFileRename,     L"FILE-RENAME" },
    {SrEventDirectoryCreate,L"DIR-CREATE" },
    {SrEventDirectoryRename,L"DIR-RENAME" },
    {SrEventDirectoryDelete,L"DIR-DELETE" },
    {SrEventMountCreate,    L"MNT-CREATE" },
    {SrEventMountDelete,    L"MNT-DELETE" }
};

//+---------------------------------------------------------------------------
//
//  Function:   GetEventString
//
//  Synopsis:   Transulates the EventString from the event ID
//
//  Arguments:  [EventID]  -- DWord for the event code
//
//  Returns:    Pointer to maped string to the event coded
//
//  History:    9/21/00		SHeffner Copied from Brijesh
//
//
//----------------------------------------------------------------------------
LPWSTR GetEventString(DWORD EventId)
{
    LPWSTR pStr = L"NOT-FOUND";

    for( int i=0; i<sizeof(EventMap)/sizeof(_EVENT_STR_MAP);i++)
    {
        if ( EventMap[i].EventId == EventId )
        {
            pStr = EventMap[i].pEventStr;
        }
    }

    return pStr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetChgLog
//
//  Synopsis:   Dumps the change log into the file specified
//
//  Arguments:  [szLogfile]  -- ANSI string pointing to the name of the log file
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner created
//
//
//----------------------------------------------------------------------------
void GetChgLog(char *szLogfile)
{
	WCHAR		szString[_MAX_PATH];
	DWORD		dLength;
	HANDLE		hVolume;

	dLength = _MAX_PATH;

	//Walk through all of the volume's on the system, and then validate that
	//   this is a fixed drive. Once we have a valid drive then pass this volume to
	//   the enumeration routine for changelog.
	if( INVALID_HANDLE_VALUE != (hVolume = FindFirstVolume( szString, dLength)) ) 
	{
		do
		{
			dLength = _MAX_PATH;

			//Check to make sure that this is a fixed volume, and then get the change log, else skip.
			if ( DRIVE_FIXED == GetDriveType(szString) )
				EnumLog(szLogfile, szString);

		} while (TRUE == FindNextVolume(hVolume, szString, dLength) );
	}

	//Cleanup code
	FindVolumeClose(hVolume);
	
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumLog
//
//  Synopsis:   Enumerate the change log for the Volume
//
//  Arguments:  [szLogfile]  -- ANSI string pointing to the name of the log file
//				[szDrive]	 --	WCHAR string, that specifies the volume to gather the log from
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner grabbed from Brijesh, but tweaked to get the rest of the fields
//
//
//----------------------------------------------------------------------------
void EnumLog(char *szFileName, WCHAR *szDrive)
{
    DWORD       dwTargetRPNum = 0;
    HGLOBAL     hMem = NULL;
    DWORD       dwRc, dLength;
	FILE		*fStream;
	WCHAR		szMount[_MAX_PATH];



	//Open up our logging file
	fStream = fopen(szFileName, "a");

	//Write header for our Section so that we can see what Volume that we are enumerating
	GetVolumePathNamesForVolumeName(szDrive, szMount, _MAX_PATH, &dLength);
	fprintf(fStream, "\nChangeLog Enumeration for Drive [%S] Volume %S\n\n", szMount, szDrive);

	//Calling the ChangeLogenumeration functions, specifying the drive, Forward through log, 
	//   RP Number start 0, and switch??
    CChangeLogEntryEnum ChangeLog(szDrive, TRUE, dwTargetRPNum, TRUE);
    CChangeLogEntry     cle;

    if (ERROR_SUCCESS == ChangeLog.FindFirstChangeLogEntry(cle))
    {
		do 
		{
		fprintf(fStream,
			"RPDir=%S, Drive=%S, SeqNum=%I64ld, EventString=%S, Flags=%lu, Attr=%lu, Acl=%S, AclSize=%lu, AclInline=%lu, Process=%S, ProcName=%S, Path1=%S, Path2=%S, Temp=%S\n", 
			cle.GetRPDir(),
			szMount,
			cle.GetSequenceNum(), 
			GetEventString(cle.GetType()),
			cle.GetFlags(),
			cle.GetAttributes(),
			cle.GetAcl() ? L"Yes" : L"No",
			cle.GetAclSize(),
			cle.GetAclInline(),
			cle.GetProcess() ? cle.GetProcess() : L"NULL",
			cle.GetProcName() ? cle.GetProcName() : L"NULL",
			cle.GetPath1() ? cle.GetPath1() : L"NULL",
			cle.GetPath2() ? cle.GetPath2() : L"NULL",
			cle.GetTemp() ? cle.GetTemp() : L"NULL");


		dwRc = ChangeLog.FindNextChangeLogEntry(cle);        
            
		}   while (dwRc == ERROR_SUCCESS);

		ChangeLog.FindClose();
	}
	else
	{
        fprintf(fStream, "No change log entries\n");
	}

	//code cleanup
	fclose(fStream);
    if (hMem) GlobalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\getreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       GetReg.cpp
//
//  Contents:   Routines to get the registry, and dump the contents into
//					a text file. 
//				
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    9/21/00	SHeffner	Created
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>

//+---------------------------------------------------------------------------
//
//	Function Proto types
//
//----------------------------------------------------------------------------
void RegType(DWORD dwType, WCHAR *szString);


//+---------------------------------------------------------------------------
//
//  Function:   GetSRRegistry
//
//  Synopsis:   Routine will recursivly call this routine to enumerate the keys and values for the registry
//
//  Arguments:  [szFileName]  -- Simple ANSI string to log file
//				[szPath]	  -- Simple ANSI string to the path to start at the registry
//				[bRecurse]    -- Bool to indicate if I should recurse into sub paths
//
//  Returns:    true if successful
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
bool GetSRRegistry(char *szFileName, WCHAR *szPath, bool bRecurse)
{

	WCHAR szKeyString[_MAX_PATH +1], szValueString[_MAX_PATH +1], szString[_MAX_PATH +1];
	DWORD dwIndex=0, dwValueSize, dwDataSize, dwType;
	long lResult;
	HKEY mHkey;
	FILE *fStream;
	
	// Open the Log file for append
	fStream = fopen(szFileName, "a");

	//Initialize local variables before processing path
	dwIndex =0;
	dwDataSize = dwValueSize = _MAX_PATH +1;

	//log current path, and then open the registry hive, and start enumerating the Values.
	fprintf(fStream, "\n[%S]\n", szPath);
	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_READ, &mHkey);
	lResult = RegEnumValue(mHkey, dwIndex, szKeyString, &dwDataSize, 0, &dwType, (unsigned char *)szValueString, &dwValueSize);
	while( ERROR_SUCCESS == lResult ) {
		RegType(dwType, szString);
		//BUGBUG.. If it is type 4, then we do the special type casting, 
		// if not then we just pass it through as a string
		if (4 == dwType) 
			fprintf(fStream, "\"%S\"=%S:%lu\n", szKeyString, szString, (DWORD &) szValueString);
		else 
			fprintf(fStream, "\"%S\"=%S:%S\n", szKeyString, szString, (unsigned char *) szValueString);

		//Update local variables for next iteration.
		dwDataSize = dwValueSize = _MAX_PATH +1;
		dwIndex ++;
		lResult = RegEnumValue(mHkey, dwIndex, szKeyString, &dwDataSize, 0, &dwType, (unsigned char *)szValueString, &dwValueSize);
	}

	//Close out the file, for next recursion loop.
	fclose(fStream);

	
	//Now lets find all of the Key's under this key, and kick off a another enumeration for each one found
	if ( true == bRecurse ) {
		dwIndex = 0;
		dwDataSize = _MAX_PATH +1;
		lResult = RegEnumKey(mHkey, dwIndex, szKeyString, dwDataSize);
		while( ERROR_SUCCESS == lResult) {
			//Build the path, and then call this function again.
			wcscpy(szString, szPath);
			wcscat(szString, TEXT("\\"));
			wcscat(szString, szKeyString);
			GetSRRegistry(szFileName, szString, bRecurse);

			//Now do next run through.
			dwDataSize = _MAX_PATH +1;
			dwIndex ++;
			lResult = RegEnumKey(mHkey, dwIndex, szKeyString, dwDataSize);
		}
	}


	//Close key, and return back.
	RegCloseKey(mHkey);
	return true;

}

//+---------------------------------------------------------------------------
//
//  Function:   RegType
//
//  Synopsis:   Routine returns in the string pass in, the description of registry key it is
//
//  Arguments:  [dwType]      -- DWord Type
//				[szString]	  -- Simple ANSI string receive a string description
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//----------------------------------------------------------------------------
void RegType(DWORD dwType, WCHAR *szString)
{
	switch(dwType) {
	case REG_BINARY:
		wcscpy(szString, TEXT("REG_BINARY"));
		break;
	case REG_DWORD:
		wcscpy(szString, TEXT("REG_DWORD"));
		break;
	case REG_DWORD_BIG_ENDIAN:
		wcscpy(szString, TEXT("REG_DWORD_BIG_ENDIAN"));
		break;
	case REG_EXPAND_SZ:
		wcscpy(szString, TEXT("REG_EXPAND_SZ"));
		break;
	case REG_LINK:
		wcscpy(szString, TEXT("REG_LINK"));
		break;
	case REG_MULTI_SZ:
		wcscpy(szString, TEXT("REG_MULTI_SZ"));
		break;
	case REG_NONE:
		wcscpy(szString, TEXT("REG_NONE"));
		break;
	case REG_QWORD:
		wcscpy(szString, TEXT("REG_QWORD"));
		break;
	case REG_RESOURCE_LIST:
		wcscpy(szString, TEXT("REG_RESOURCE_LIST"));
		break;
	case REG_SZ:
		wcscpy(szString, TEXT("REG_SZ"));
		break;
	default:
		wcscpy(szString, TEXT("UnKnown"));
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\rpenum.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    rplog.cpp
 *
 *  Abstract:
 *    Tool for enumerating the restore points - forward/reverse
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/13/2000
 *        created
 *	  SHeffner, I just copied this source, and using the existing API's so that
 *      srdiag will also be in sync as changes occur to the file structure.
 *
 *****************************************************************************/

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <shellapi.h>
#include <enumlogs.h>
#include <cab.h>

//+---------------------------------------------------------------------------
//
//	Function Proto types
//
//----------------------------------------------------------------------------
void GetRPLogs(HFCI hc, char *szLogFile, WCHAR *szVolumePath);
void GetSRRPLogs(HFCI hc, WCHAR *szVolumePath, WCHAR *szRPDir, WCHAR *szFileName);
extern void GetRestoreGuid(char *szString);			//Gets the restore point GUID, code in main.cpp

//+---------------------------------------------------------------------------
//
//	Files to collect for each Restore Point, on all drives.
//
//----------------------------------------------------------------------------
WCHAR	*wszRPFileList[] = { TEXT("restorepointsize"),
							 TEXT("drivetable.txt"),
							 TEXT("rp.log"),
							 TEXT("") };
//+---------------------------------------------------------------------------
//
//	Types of restorepoints, based off of Brijesh's code
//
//----------------------------------------------------------------------------
WCHAR	*szRPDescrip[] = { TEXT("APPLICATION_INSTALL"),
						   TEXT("APPLICATION_UNINSTALL"),
						   TEXT("DESKTOP_SETTING"),
						   TEXT("ACCESSIBILITY_SETTING"),
						   TEXT("OE_SETTING"),
						   TEXT("APPLICATION_RUN"),
						   TEXT("RESTORE"),
						   TEXT("CHECKPOINT"),
						   TEXT("WINDOWS_SHUTDOWN"),
						   TEXT("WINDOWS_BOOT"),
						   TEXT("DEVICE_DRIVER_CHANGE"),
						   TEXT("FIRSTRUN"),
						   TEXT("MODIFY_SETTINGS"),
						   TEXT("CANCELLED_OPERATION") };

//+---------------------------------------------------------------------------
//
//	Simple Array's to say how to print the Month, and Day's
//
//----------------------------------------------------------------------------

WCHAR	*szMonth[] = { TEXT("January"), TEXT("Feburary"), TEXT("March"), TEXT("April"), TEXT("May"), TEXT("June"),
					   TEXT("July"), TEXT("August"), TEXT("September"), TEXT("October"), TEXT("November"), TEXT("December") };
WCHAR	*szDay[] = { TEXT("Sunday"), TEXT("Monday"), TEXT("Tuesday"), TEXT("Wednesday"), TEXT("Thursday"), TEXT("Friday"), TEXT("Saturday") };

//+---------------------------------------------------------------------------
//
//  Function:   RPEnumDrive
//
//  Synopsis:   Via the FindFirstVolume, and FindNext get all of the valid volumes on the system
//					I then transulate this volume, to the actual path and then pass that information
//					to GetRPLogs which will get the restore point logs.
//
//  Arguments:  [hc]		-- Handle to my current Cab
//				[szLogFile]	-- File name and path to where I log my restore point log information.
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void RPEnumDrive(HFCI hc, char *szLogFile)
{
	WCHAR		szString[_MAX_PATH] = {TEXT("")}, szMount[_MAX_PATH] = {TEXT("")};
	DWORD		dLength = 0, dSize = 0;
	HANDLE		hVolume = 0, hMount = 0;

	dLength = _MAX_PATH;
	if( INVALID_HANDLE_VALUE != (hVolume = FindFirstVolume( szString, dLength)) ) 
	{
		do
		{
			dLength = dSize = _MAX_PATH;

			//Check to make sure that this is a fixed volume, and then get the change log, else skip.
			if ( DRIVE_FIXED == GetDriveType(szString) )
			{
				//First get the Friendly name for the current Volume, and get log
				GetVolumePathNamesForVolumeName(szString, szMount, _MAX_PATH, &dSize);
				GetRPLogs(hc, szLogFile, szMount);
			}
		} while (TRUE == FindNextVolume(hVolume, szString, dLength) );
	}

	//Cleanup code
	FindVolumeClose(hVolume);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRPLogs
//
//  Synopsis:   This will enumerate the restore points on the volume path that is provided, writting
//					this information out the logfile specified.
//
//  Arguments:  [hc]		-- Handle to my current Cab
//				[szLogFile]	-- File name and path to where I log my restore point log information.
//				[szVolumePath] -- Path to the Volume for the restore point API to work.
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void GetRPLogs(HFCI hc, char *szLogFile, WCHAR *szVolumePath)
{
	INT64				i64Size=0;
	int					iCount=0;
	WCHAR				szString[_MAX_PATH] = {TEXT("")};
	char				szRestoreGuid[_MAX_PATH] = {""};
	RESTOREPOINTINFOW	pRpinfo;
	FILETIME			*ft;
	SYSTEMTIME			st;
	FILE				*fStream = NULL, *fStream2 = NULL;

	//Initialization of the Restore point
	CRestorePointEnum   RPEnum(szVolumePath, TRUE, FALSE);
    CRestorePoint       RP;
    DWORD               dwRc;

	//Get restore GUID, and open up log file, and write out our mount point
	GetRestoreGuid(szRestoreGuid);
	fStream = fopen(szLogFile, "a");
	fprintf(fStream, "\nProcessing Mount Point [%S]\n", szVolumePath);

	// If we have a valid restore point, enumerate through all of them and log the results.
    if (ERROR_SUCCESS == RPEnum.FindFirstRestorePoint(RP))
    {
		do 
		{
			//Get RestorePoint Size for the restore point log.
			swprintf(szString, L"%sSystem Volume Information\\_restore%S\\%s\\restorepointsize", szVolumePath, szRestoreGuid, RP.GetDir());
			if( NULL != (fStream2 = _wfopen(szString, L"r")) )
			{
				fread(&i64Size, sizeof(i64Size), 1, fStream2);
				fclose(fStream2);
			}
			else {
				i64Size=0;
			}

            
			if (RP.GetName() == NULL)  // not system-drive
			{
    			//format should be field=value, field=value, ...
    			fprintf(fStream, "DirectoryName=%S, Size=%I64ld, Number=%ul\n", 
    					RP.GetDir(), i64Size, RP.GetNum());
			}
			else
			{
    			//Get the time, and then convert it to localsystemtime, and then pump out the rest of the DataStructures
	    		ft = RP.GetTime();
			    
    			FileTimeToSystemTime( ft, &st);

    			//format should be field=value, field=value, ...
    			fprintf(fStream, "DirectoryName=%S, Size=%I64ld, Type=%ld[%S], RestorePointName=%S, RestorePointStatus=%S, Number=%ul, Date=%S %S %lu, %lu %lu:%lu:%lu\n", 
    					RP.GetDir(), i64Size, RP.GetType(), szRPDescrip[RP.GetType()], RP.GetName(), 
    					RP.IsDefunct() ? TEXT("[Cancelled]") : TEXT("[VALID]"), RP.GetNum(), szDay[st.wDayOfWeek],
    					szMonth[st.wMonth-1], st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
			}
			
			//Now Add-in the files needed per restore point
			iCount = 0;
			while ( NULL != *wszRPFileList[iCount] )
			{
				GetSRRPLogs(hc, szVolumePath, RP.GetDir(), wszRPFileList[iCount]);
				iCount++;
			}


		}   while (ERROR_SUCCESS == (dwRc = RPEnum.FindNextRestorePoint(RP)) );
		RPEnum.FindClose();
	}
	else
	{
        fprintf(fStream, "No restore points for Mount Point [%S]\n", szVolumePath);
    }    
    
	//Close up file Handle
	fclose (fStream);		//close out the file handle
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSRRPLogs
//
//  Synopsis:   Routine will figure out 1) where the file in question is, 2) copy it to the temp directory
//					with the new name, 3) add to cab, 4) nuke temp file
//
//  Arguments:  [hc]			-- Handle to my current Cab
//				[szVolumePath]	-- File name and path to where I log my restore point log information.
//				[szRPDir]		-- Name of the restore point directory
//				[szFileName]	-- Name of the file in the restore point directory to collect
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void GetSRRPLogs(HFCI hc, WCHAR *szVolumePath, WCHAR *szRPDir, WCHAR *szFileName)
{
	char	*szTest[1], *pszLoc;
	char	szRestoreGuid[_MAX_PATH];
	char	szTemp[_MAX_PATH], szSource[_MAX_PATH], szDest[_MAX_PATH];

	//Get restore GUID, and build the source path
	GetRestoreGuid(szRestoreGuid);
	sprintf(szSource, "%SSystem Volume Information\\_restore%s\\%S\\%S", szVolumePath, szRestoreGuid, szRPDir, szFileName);

	//Build Dest Path, swap out the \ and a : for a -
	sprintf(szTemp, "%S%S-%S", szVolumePath, szRPDir, szFileName);
	while(NULL != (pszLoc = strchr(szTemp, '\\')) )
		*pszLoc = '-';
	while(NULL != (pszLoc = strchr(szTemp, ':')) )
		*pszLoc = '-';
	sprintf(szDest, "%s\\%s", getenv("TEMP"), szTemp);

	//Copy to new location, overwrite if it exists.
	CopyFileA(szSource, szDest, FALSE);

	//Now Add to file to the cab file.
	szTest[0] = szDest;
	test_fci(hc, 1, szTest, "");
	DeleteFileA(szDest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\main.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       Main.h
//
//  Contents:   Header file for function proto types for main.cpp
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    9/21/00	SHeffner	Created
//
//----------------------------------------------------------------------------
#ifndef _CMSRDIAG
#define _CMSRDIAG


//+---------------------------------------------------------------------------
//
//	Function proto typing
//
//----------------------------------------------------------------------------

void Log(char *szString);
void Log2(char *szString, char *szString2);
void GetRestoreGuid(char *szString);
void SRGetFileInfo(char *szLogFile);
void InfoPerFile(char *szLogFile, WCHAR *szFileName);
void ArgParse(int argc, char *argv[], char *szArgCmd[]);
void Usage();

//+---------------------------------------------------------------------------
//
//	Structure Definations
//
//----------------------------------------------------------------------------

//Listing of the files, that we will gather in the version information, and file statics from.
//  This information will be stored in the SR-FileList.txt
WCHAR	*wszFileVersionList[] = { TEXT("\\system32\\drivers\\sr.sys"),
		 						  TEXT("\\system32\\srclient.dll"),
								  TEXT("\\system32\\srsvc.dll"),
								  TEXT("\\system32\\srrstr.dll"),
								  TEXT("\\system32\\restore\\filelist.xml"),
								  TEXT("\\system32\\restore\\rstrui.exe"),
								  TEXT("\\system32\\restore\\srframe.mmf"),
								  TEXT("\\system32\\restore\\sr.mof"),
								  TEXT("") };

//Listing of the resourece strings that we are looking for in the structure wszFileVersionList.
WCHAR	*wszVersionResource[] = { TEXT("Comments"), 
								  TEXT("CompanyName"),
								  TEXT("FileDescription"),
								  TEXT("FileVersion"), 
								  TEXT("InternalName"), 
								  TEXT("LegalCopyright"), 
								  TEXT("LegalTrademarks"), 
								  TEXT("OriginalFilename"), 
								  TEXT("ProductName"), 
								  TEXT("ProductVersion"), 
								  TEXT("PrivateBuild"), 
								  TEXT("SpecialBuild"), 
								  TEXT("") };

//Listing of the Registry keys that we are grabbing. The first param is the Path from HKLM, the Second Param
//  is either 0 for not recursing, or 1 if you want to recurse all of the sub keys.
WCHAR	*wszRegKeys[][2] = { TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"), TEXT("0"),
							 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore"), TEXT("1"),
							 TEXT("System\\CurrentControlSet\\Services\\SR"), TEXT("1"),
							 TEXT("System\\CurrentControlSet\\Services\\SRService"), TEXT("1"),
							 TEXT("Software\\Policies\\Microsoft\\Windows NT\\SystemRestore"), TEXT("1"),
							 TEXT(""), TEXT("") };


//Listing of the files that we will gather on the system into the cab, based on the relative root starting
//   from the Windir directory.
char	*szWindirFileCollection[] =	{ "\\system32\\restore\\machineguid.txt",
									  "\\system32\\restore\\filelist.xml",
									  "\\system32\\restore\\rstrlog.dat",
									  "" };

//Listing of the files, that we will collect at the root of the SystemVolumeInformation\_Restore{GUID} directory
char	*szSysVolFileCollection[] = { "_filelst.cfg",
									  "drivetable.txt",
									  "_driver.cfg",
									  "fifo.log",
									  "" };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\chglog.cxx ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    chglog.cpp
 *
 *  Abstract:
 *    Tool for enumerating the change log - forward/reverse
 *
 *  Revision History:
 *
 *    Brijesh Krishnaswami (brijeshk)  04/09/2000
 *        created
 *
 *    SHeffner
 *        Just grabbed the code, and put it into SRDiag.
 *
 *    Weiyou Cui    (weiyouc)   02-May-2001
 *        Rewritten
 *
 *****************************************************************************/

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------

#include "srheader.hxx"
#include <srapi.h>
#include <shellapi.h>
#include <enumlogs.h>
#include <srrpcapi.h>


//+---------------------------------------------------------------------------
//
//	Function proto types
//
//----------------------------------------------------------------------------

LPWSTR GetEventString(DWORD EventId);
HRESULT EnumLog(LPTSTR ptszFileName, LPTSTR ptszDrive);

//+---------------------------------------------------------------------------
//
//	Some structures
//
//----------------------------------------------------------------------------

struct _EVENT_STR_MAP
{
    DWORD   EventId;
    LPWSTR  pEventStr;
} EventMap[] =
{
    {SrEventInvalid ,       L"INVALID" },
    {SrEventStreamChange,   L"FILE-MODIFY" },
    {SrEventAclChange,      L"ACL-CHANGE" },
    {SrEventAttribChange,   L"ATTR-CHANGE" },
    {SrEventStreamOverwrite,L"FILE-MODIFY" },
    {SrEventFileDelete,     L"FILE-DELETE" },
    {SrEventFileCreate,     L"FILE-CREATE" },
    {SrEventFileRename,     L"FILE-RENAME" },
    {SrEventDirectoryCreate,L"DIR-CREATE" },
    {SrEventDirectoryRename,L"DIR-RENAME" },
    {SrEventDirectoryDelete,L"DIR-DELETE" },
    {SrEventMountCreate,    L"MNT-CREATE" },
    {SrEventMountDelete,    L"MNT-DELETE" },
    {SrEventVolumeError,    L"VOLUME-ERROR" }
};

//+---------------------------------------------------------------------------
//
//  Function:   GetChgLogOnDrives
//
//  Synopsis:   Dumps the change log into the file specified
//
//  Arguments:  [ptszLogFile]  -- log file name
//
//  Returns:    HRESULT
//
//  History:    9/21/00		SHeffner created
//
//              02-May-2001 WeiyouC  Rewritten
//
//----------------------------------------------------------------------------
HRESULT GetChgLogOnDrives(LPTSTR ptszLogFile)
{
    HRESULT hr       = S_OK;
	DWORD   dwLength = MAX_PATH;
	HANDLE  hVolume  = INVALID_HANDLE_VALUE;
	TCHAR   tszVolume[MAX_PATH];
	
    DH_VDATEPTRIN(ptszLogFile, TCHAR);

	//
	//  Walk through all of the volume's on the system, and then validate that
	//  this is a fixed drive. Once we have a valid drive then pass this volume
	//  to the enumeration routine for changelog.
	//

	hVolume = FindFirstVolume(tszVolume, dwLength);
	if (INVALID_HANDLE_VALUE != hVolume) 
	{
		do
		{
			dwLength = MAX_PATH;
			if (DRIVE_FIXED == GetDriveType(tszVolume))
		    {
				hr = EnumLog(ptszLogFile, tszVolume);
				DH_HRCHECK_ABORT(hr, TEXT("EnumLog"));
		    }
		} while (FindNextVolume(hVolume, tszVolume, dwLength) );
	}

	if (INVALID_HANDLE_VALUE != hVolume)
    {
    	FindVolumeClose(hVolume);
    }

ErrReturn:
	return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetEventString
//
//  Synopsis:   Transulates the EventString from the event ID
//
//  Arguments:  [dwEventID]  -- DWord for the event code
//
//  Returns:    Pointer to maped string to the event coded
//
//  History:    9/21/00		SHeffner Copied from Brijesh
//
//              02-May-2001 WeiyouC  Rewritten
//
//----------------------------------------------------------------------------

LPWSTR GetEventString(DWORD dwEventID)
{
    LPWSTR pwStr = L"NOT-FOUND";

    for (int i = 0; i < sizeof(EventMap)/sizeof(_EVENT_STR_MAP); i++)
    {
        if (EventMap[i].EventId == dwEventID )
        {
            pwStr = EventMap[i].pEventStr;
        }
    }

    return pwStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumLog
//
//  Synopsis:   Enumerate the change log for the Volume
//
//  Arguments:  [ptszLogFile] -- log file name
//				[ptszDrive]	  -- drive name
//
//  Returns:    HRESULT
//
//  History:    9/21/00	    SHeffner
//                      Grabbed from Brijesh. Tweaked to get the rest of
//                      the fields
//
//              02-May-2001 WeiyouC
//                      Rewritten
//
//----------------------------------------------------------------------------

HRESULT EnumLog(LPTSTR ptszLogFile, LPTSTR ptszDrive)
{
    HRESULT             hr            = S_OK;
    DWORD               dwTargetRPNum = 0;
    HGLOBAL             hMem          = NULL;
	FILE*	            fpLog         = NULL;
    DWORD               dwLength      = 0;
    BOOL                fOK           = FALSE;
    CChangeLogEntry     cle;
    CChangeLogEntryEnum ChangeLog(ptszDrive, TRUE, dwTargetRPNum, TRUE);
	TCHAR	            tszMount[MAX_PATH];

    DH_VDATEPTRIN(ptszLogFile, TCHAR);
    DH_VDATEPTRIN(ptszDrive, TCHAR);

	//
	//  Open up our logging file
	//
	
	fpLog = _tfopen(ptszLogFile, TEXT("a"));
	DH_ABORTIF(NULL == fpLog,
	           E_FAIL,
	           TEXT("_tfopen"));

	//
	//  Write header for our Section so that we can see what
	//  volume that we are enumerating
	//
	
	fOK = GetVolumePathNamesForVolumeName(ptszDrive,
	                                      tszMount,
	                                      MAX_PATH,
	                                      &dwLength);
	DH_ABORTIF(!fOK,
	           HRESULT_FROM_WIN32(GetLastError()),
	           TEXT("GetVolumePathNamesForVolumeName"));
	
	fprintf(fpLog,
	        "\nChangeLog Enumeration for Drive [%S] Volume %S\n\n",
	        tszMount,
	        ptszDrive);

	//
	//  Calling the ChangeLogenumeration functions,
	//  specifying the drive. Forward through log, 
	//  RP Number start 0, and switch??
	//
	
    if (ERROR_SUCCESS == ChangeLog.FindFirstChangeLogEntry(cle))
    {
		do 
		{
    		fprintf(fpLog,
        			"RPDir=%S, "
        			"Drive=%S, "
        			"SeqNum=%I64ld, "
        			"EventString=%S, "
        			"Flags=%lu, "
        			"Attr=%lu, "
        			"Acl=%S, "
        			"AclSize=%lu, "
        			"AclInline=%lu, "
        			"Process=%S, "
        			"ProcName=%S, "
        			"Path1=%S, "
        			"Path2=%S, "
        			"Temp=%S\n", 
        			cle.GetRPDir(),
        			tszMount,
        			cle.GetSequenceNum(), 
        			GetEventString(cle.GetType()),
        			cle.GetFlags(),
        			cle.GetAttributes(),
        			cle.GetAcl() ? L"Yes" : L"No",
        			cle.GetAclSize(),
        			cle.GetAclInline(),
        			cle.GetProcess() ? cle.GetProcess() : L"NULL",
        			cle.GetProcName() ? cle.GetProcName() : L"NULL",
        			cle.GetPath1() ? cle.GetPath1() : L"NULL",
        			cle.GetPath2() ? cle.GetPath2() : L"NULL",
        			cle.GetTemp() ? cle.GetTemp() : L"NULL");    
		}   while (ERROR_SUCCESS == ChangeLog.FindNextChangeLogEntry(cle));
		ChangeLog.FindClose();
	}
	else
	{
        fprintf(fpLog, "No change log entries\n");
	}


ErrReturn:	

	if (NULL != fpLog)
    {
    	fclose(fpLog);
    }
    if (NULL != hMem)
    {
        GlobalFree(hMem);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       Main.cpp
//
//  Contents:   Main wrapper file for SRDiag, this will call into cab.cpp,
//					chglog.cpp, getreg.cpp, rpenum.cpp for getting changlog,
//					restore points, registry information. This file also contains
//					routines for getting file information, restore Guid, and generic 
//					logging imposed by cab.cpp
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    9/21/00	SHeffner	Created
//				10/5/00	SHeffner	Moved file specific gathering to the header file.
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <cab.h>
#include <main.h>
#include <dbgtrace.h>
#include <winver.h>
#include "srrpcapi.h"


//+---------------------------------------------------------------------------
//
//	Function proto typing for rpenum.cpp, getreg.cpp, Chglog.cpp
//
//----------------------------------------------------------------------------
bool GetSRRegistry(char *szFilename, WCHAR *szPath, bool bRecurse);
void GetChgLog(char *szLogfile);
void RPEnumDrive(HFCI hc, char *szLogFile);



//+---------------------------------------------------------------------------
//
//	Global Variables used within main, and through cab.cpp
//
//----------------------------------------------------------------------------
FILE *fLogStream = NULL;						//For the Log, and Log2 routines
extern char g_szCabFileLocation[_MAX_PATH];		//This is actually defined in cab.cpp
extern char g_szCabFileName[_MAX_PATH];			//This is actually defined in cab.cpp

void __cdecl main(int argc, char *argv[])
{
	HFCI hc = NULL;
	int i=0;
	bool bResult=false;
	char szString[_MAX_PATH], szRestoreDirPath[_MAX_PATH];
	char *szTest[1], *szArgCmd[200];

	//Process any commandline arguments
	memset(szArgCmd, 0, sizeof(char)*200);		//Clean up before relying on this DS.
	ArgParse(argc, argv, szArgCmd);
	
	//Open up the log file, and start logging all activity
	strcpy(szString, getenv("TEMP"));
	strcat(szString, "\\SRDIAG.LOG");
	fLogStream = fopen(szString, "w");


	//Create a cab, if we fail then just skip, 
	// else gather all of the relevant files required.
	if (NULL != (hc = create_cab()) )
	{
		//First add in any files that were specified on the command line, but first figuring out
		//  how many were really specified
		for(i=0;i<200;i++) if(NULL == szArgCmd[i]) break;
		bResult = test_fci(hc, i, szArgCmd, "");

		
		//Get the Temp Location, ensure we have a new file, then
		// get the registry keys, and dump into our text file
		strcpy(szString, getenv("TEMP"));
		strcat(szString, "\\SR-Reg.txt");
		DeleteFileA(szString);
		i = 0;
		while (NULL != *wszRegKeys[i][0]) {
			if(0 == wcscmp(wszRegKeys[i][1], TEXT("0")))
				GetSRRegistry(szString, wszRegKeys[i][0], false);
			else
				GetSRRegistry(szString, wszRegKeys[i][0], true);
			i++;
		}
		//Add the log to the Cab, and clean up
		szTest[0] = szString;
		bResult = test_fci(hc, 1, szTest, "");
		DeleteFileA(szString);


		//Add files Bases on WinDir relative root
		i = 0;
		while (NULL != *szWindirFileCollection[i]) {
			strcpy(szString, getenv("WINDIR"));
			strcat(szString, szWindirFileCollection[i]);
			szTest[0] = szString;
			bResult = test_fci(hc, 1, szTest, "");
			i++;
		}

		//Get the restore directory on the system drive, and then Add in critial files
		GetRestoreGuid(szString);
		sprintf(szRestoreDirPath, "%s\\System Volume Information\\_Restore%s\\", getenv("SYSTEMDRIVE"), szString );

		//Add files Bases on System Volume Information relative root
		i = 0;
		while (NULL != *szSysVolFileCollection[i]) {
			strcpy(szString, szRestoreDirPath);
			strcat(szString, szSysVolFileCollection[i]);
			szTest[0] = szString;
			bResult = test_fci(hc, 1, szTest, "");
			i++;
		}

		//Get the Restore point enumeration, and then cab the file
		strcpy(szString, getenv("TEMP"));
		strcat(szString, "\\SR-RP.LOG");
		RPEnumDrive(hc, szString);
		szTest[0] = szString;
		bResult = test_fci(hc, 1, szTest, "");
		DeleteFileA(szString);

		//Get the ChangeLog enumeration, and then cab and delete the file
		//first we need to switch the log, then gather the log
		SRSwitchLog();
		strcpy(szString, getenv("TEMP"));
		strcat(szString, "\\SR-CHGLog.LOG");
		GetChgLog(szString);
		szTest[0] = szString;
		bResult = test_fci(hc, 1, szTest, "");
		DeleteFileA(szString);

		//Get the fileversion info for each of the Files
		strcpy(szString, getenv("TEMP"));
		strcat(szString, "\\SR-FileList.LOG");
		SRGetFileInfo(szString);
		szTest[0] = szString;
		bResult = test_fci(hc, 1, szTest, "");
		DeleteFileA(szString);


		//Close out logging, and add the log to the cab 
		// (THIS SHOULD BE THE LAST THING WE ARE DOING!!)
		fclose(fLogStream);
		fLogStream = NULL;
		strcpy(szString, getenv("TEMP"));
		strcat(szString, "\\SRDIAG.LOG");
		szTest[0] = szString;
		bResult = test_fci(hc, 1, szTest, "");
		DeleteFileA(szString);
	
	}

	//Completes cab file under construction
	if (flush_cab(hc))
	{	
		Log("Cabbing Process was Sucessful");
	}
	else
    {
		Log("Cabbing Process has failed");
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Log
//
//  Synopsis:   Will print a String to both our log file, and also the console
//
//  Arguments:  [szString]  -- Simple ANSI string to log
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void Log(char *szString)
{
	if( NULL != fLogStream)
		fprintf(fLogStream, "%s\n", szString);

	puts(szString);
}

//+---------------------------------------------------------------------------
//
//  Function:   Log2
//
//  Synopsis:   Takes two strings, and will print them back to back to both the
//					log file, and also to the console
//
//  Arguments:  [szString]  -- Simple ANSI string to log
//				[szString2]	--	Simple ANSI string to log
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void Log2(char *szString, char *szString2)
{
	if( NULL != fLogStream)
		fprintf(fLogStream,"%s %s\n", szString, szString2);

	printf("%s %s\n", szString, szString2);

}

//+---------------------------------------------------------------------------
//
//  Function:   GetRestoreGuid
//
//  Synopsis:   Will retrieve from the registry what the GUID is for the current
//				Restore directory, and return this in the string pointer passed 
//				to the function.
//
//  Arguments:  [szString]  -- Simple ANSI string to receive the string
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void GetRestoreGuid(char *szString)
{
	long lResult;
	HKEY mHkey;
	DWORD dwType, dwLength;

	lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\Cfg", 0, KEY_READ, &mHkey);
	dwLength = _MAX_PATH +1;
	lResult = RegQueryValueExA(mHkey, "MachineGuid", NULL, &dwType, (unsigned char *)szString, &dwLength);
}

//+---------------------------------------------------------------------------
//
//  Function:   SRGetFileInfo
//
//  Synopsis:   This is the wrapper function for InfoPerFile, where I will assemble
//				the file path for each of the relevant files that we need to get
//				file statistics. 
//
//  Arguments:  [szLogFile]  -- The path to the file that I will log this information to.
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void SRGetFileInfo(char *szLogFile)
{
	int		iCount;
	WCHAR	szString[_MAX_PATH];

	//Initialize counter, and walk through the filelist that we have
	iCount = 0;
	while(NULL != *wszFileVersionList[iCount])
	{
		//Assemble the path, since I just have the relative path from windir
		wcscpy(szString, _wgetenv(L"WINDIR"));
		wcscat(szString, wszFileVersionList[iCount]);

		//Call function to do the work since we have full path, and log file name
		InfoPerFile(szLogFile, szString);
		iCount++;
	}
}

//+---------------------------------------------------------------------------
//
//  Function:   InfoPerFile
//
//  Synopsis:   This function takes the log file path, and the filename, and then
//				will put out the relevant information from the file to be logged.
//				
//
//  Arguments:  [szLogFile]  -- The path to the file that I will log this information to.
//				[szFileName] --	The full path, and name of the file to get the information for.
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void InfoPerFile(char *szLogFile, WCHAR *szFileName)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	SYSTEMTIME					st;
	HANDLE						handle;
	FILE						*fStream;
	WCHAR						szString[_MAX_PATH];
	VOID						*pBuffer;
	VS_FIXEDFILEINFO			FixedFileInfo;
	UINT						uLen;
	DWORD						dSize, dResult, i;

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;

	WCHAR *szMonth[] = { L"January", L"Feburary", L"March", L"April", L"May", L"June", L"July", L"August", L"September", L"October", L"November", L"December" };
	WCHAR *szDay[] = {L"Sunday", L"Monday", L"Tuesday", L"Wednesday", L"Thursday", L"Friday", L"Saturday" };
	
	if ( NULL == *szFileName) return;

	//Open up our log file, and log the file we are processing
	fStream = fopen(szLogFile, "a");
	if( NULL == fStream) return;	//if we have an invalid handle just return back.
	fprintf(fStream, "\n%S\n", szFileName);

	//Open up the file so that we can get the information from the handle
	// If we are unable to do this we will just log the generic not able to find file.
	if( INVALID_HANDLE_VALUE != (handle = CreateFile(szFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)) )
	{
		if (FALSE != GetFileInformationByHandle(handle, &finfo))
		{
			//FileCreation
			FileTimeToSystemTime( &finfo.ftCreationTime, &st);
			fprintf(fStream, "\tCreation Date=%S %S %lu, %lu %lu:%lu:%lu\n",
				szDay[st.wDayOfWeek],szMonth[st.wMonth-1],st.wDay,st.wYear,st.wHour,st.wMinute,st.wSecond);
			//FileLastAccess
			FileTimeToSystemTime( &finfo.ftLastAccessTime, &st);
			fprintf(fStream, "\tLast Access Date=%S %S %lu, %lu %lu:%lu:%lu\n",
				szDay[st.wDayOfWeek],szMonth[st.wMonth-1],st.wDay,st.wYear,st.wHour,st.wMinute,st.wSecond);

			//FileLastWrite
			FileTimeToSystemTime( &finfo.ftLastWriteTime, &st);
			fprintf(fStream, "\tLast Write Date=%S %S %lu, %lu %lu:%lu:%lu\n",
				szDay[st.wDayOfWeek],szMonth[st.wMonth-1],st.wDay,st.wYear,st.wHour,st.wMinute,st.wSecond);
			//File Attributes
			wcscpy(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? L"ARCHIVE " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED ? L"COMPRESSED " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? L"DIRECTORY " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ? L"ENCRYPTED " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ? L"HIDDEN " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_NORMAL ? L"NORMAL " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE ? L"OFFLINE " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? L"READONLY " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ? L"REPARSE_POINT " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE ? L"SPARSE_FILE " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM ? L"SYSTEM " : L"");
			wcscat(szString, finfo.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY ? L"TEMPORARY " : L"");
			fprintf(fStream, "\tAttributes=%S\n", szString);
			//Get the VolumeSerialNumber, FileSize, and Number of Links
			fprintf(fStream, "\tVolumeSerialNumber=%lu\n", finfo.dwVolumeSerialNumber);
			fprintf(fStream, "\tFileSize=%lu%lu\n", finfo.nFileSizeHigh, finfo.nFileSizeLow);
			fprintf(fStream, "\tNumberOfLinks=%lu\n", finfo.nNumberOfLinks);

			if( 0 != (dSize = GetFileVersionInfoSize(szFileName, &dResult)) )
			{
				if( NULL != (pBuffer = malloc(dSize)) ) 
				{
					GetFileVersionInfo(szFileName, dResult, dSize, (LPVOID) pBuffer);

					// Read the list of languages and code pages.

					VerQueryValue(pBuffer, 
								  TEXT("\\VarFileInfo\\Translation"),
								  (LPVOID*)&lpTranslate,
								  &uLen);

					// Read the Version info for each language and code page.
					for( i=0; i < (uLen/sizeof(struct LANGANDCODEPAGE)); i++ )
					{
						char *lpBuffer;
						DWORD dwBytes, dwCount = 0;

						fprintf(fStream, "\tLanguage=%x%x\n", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
						while (NULL != *wszVersionResource[dwCount] )
						{
							//Generate the string, for getting the resource based on the language, then
							//  retrieve this, and then put it to the log file.
							wsprintf( szString, L"\\StringFileInfo\\%04x%04x\\%s",
									lpTranslate[i].wLanguage,
									lpTranslate[i].wCodePage,
									wszVersionResource[dwCount]);
							VerQueryValue(pBuffer, 
										szString, 
										(LPVOID *) &lpBuffer, 
										&uLen); 
							if( 0 != uLen )
								fprintf(fStream, "\t%S=%S\n", wszVersionResource[dwCount], lpBuffer);
							dwCount++;
						}		//While loop end, for each resource
					}	//for loop end for each language

				//Clean up the allocated memory
				free(pBuffer);
				}		//If check for getting memory
			}	//If check for getting the fileversioninfosize
		}	//if check for GetFileInformationByHandle on the file
	    CloseHandle(handle);
	}		//if check on can I open this file
   
	//Cleanup
	fclose(fStream);

}

//+---------------------------------------------------------------------------
//
//  Function:   ArgParse
//
//  Synopsis:   This function simply looks for the key word parameters, and will build
//				an array pointing to each of the files that we want to include in the cab
//				in addition to the normal files.
//				
//
//  Arguments:  [argc]  -- Count of the number of arguments
//				[argv] --	Array of the arguments.
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void ArgParse(int argc, char *argv[], char *szArgCmd[])
{
	int	iCount, iWalk;

	//If no command line specified then just do the normal cabbing, with core files
	if(1 == argc)
		return;

	//walk through each of the arguments, and check to see if its a help, file, cabname, cabloc, or a ?
	for(iCount = 1; iCount < argc; iCount++)
	{
		if( 0 == _strnicoll(&argv[iCount][1], "?", strlen("?")) )
			Usage();
		if( 0 == _strnicoll(&argv[iCount][1], "help", strlen("help")) )
			Usage();
		if( 0 == _strnicoll(&argv[iCount][1], "cabname", strlen("cabname")) )
			strcpy(g_szCabFileName, (strstr(argv[iCount], ":") + 1));
		if( 0 == _strnicoll(&argv[iCount][1], "cabloc", strlen("cabloc")) ) 
			strcpy(g_szCabFileLocation, (strstr(argv[iCount], ":") + 1));

		if( 0 == _strnicoll(&argv[iCount][1], "file", strlen("file")) )
		{
			//find the first spot where I can put the pointer to this filename
			for( iWalk=0; iWalk < 200; iWalk++) 
			{
				if( NULL == szArgCmd[iWalk] ) 
				{
					szArgCmd[iWalk] = strstr(argv[iCount], ":") + 1;
					break;
				}
			}	//end for loop, walking through DS
		}	//end of if for is this an added file
	}	//end of for loop walking through all of the arguments
}

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displaies the command line usage
//				
//
//  Arguments:  
//
//  Returns:    void
//
//  History:    9/21/00		SHeffner Created
//
//
//----------------------------------------------------------------------------
void Usage()
{
	printf("Usage: SrDiag [/Cabname:test.cab] [/Cabloc:\"c:\\temp\\\"] [/file:\"c:\\boot.ini\"]\n");
	printf("   /cabloc		is pointing to the location to store the cab, this should have a \\ on the end\n");
	printf("   /cabname		is the full name of the cab file that you wish to use. \n");
	printf("   /file		is the name and path of a file that you wish to add to the cab, this can be used many times\n");
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\fileinfo.cxx ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    FileInfo.cxx
 *
 *  Abstract:
 *    Tool for getting file information
 *
 *  Revision History:
 *
 *    Weiyou Cui    (weiyouc)   02-May-2001
 *      -   Created
 *
 *****************************************************************************/

#include "srheader.hxx"

//+---------------------------------------------------------------------------
//
//  Function prototypes
//
//----------------------------------------------------------------------------

HRESULT InfoPerFile(LPTSTR ptszLogFile, LPTSTR ptszFileName);

//+---------------------------------------------------------------------------
//
//  Some global structures and variables
//
//----------------------------------------------------------------------------

struct LANGANDCODEPAGE {
  WORD wLanguage;
  WORD wCodePage;
} *lpTranslate;

LPCTSTR g_tszFileVersionList[] =
{
    TEXT("\\system32\\drivers\\sr.sys"),
    TEXT("\\system32\\srclient.dll"),
    TEXT("\\system32\\srsvc.dll"),
    TEXT("\\system32\\srrstr.dll"),
    TEXT("\\system32\\restore\\filelist.xml"),
    TEXT("\\system32\\restore\\rstrui.exe"),
    TEXT("\\system32\\restore\\srframe.mmf"),
    TEXT("\\system32\\restore\\sr.mof"),
};

LPCTSTR g_tszVersionResource[] =
{
    TEXT("Comments"), 
    TEXT("CompanyName"),
    TEXT("FileDescription"),
    TEXT("FileVersion"), 
    TEXT("InternalName"), 
    TEXT("LegalCopyright"), 
    TEXT("LegalTrademarks"), 
    TEXT("OriginalFilename"), 
    TEXT("ProductName"), 
    TEXT("ProductVersion"), 
    TEXT("PrivateBuild"), 
    TEXT("SpecialBuild"), 
};

extern LPCTSTR g_tszMonth[];
extern LPCTSTR g_tszDay[];

//+---------------------------------------------------------------------------
//
//  Function:   SRGetFileInfo
//
//  Synopsis:   This is the wrapper function for InfoPerFile, where I will assemble
//				the file path for each of the relevant files that we need to get
//				file statistics. 
//
//  Arguments:  [ptszLogFile]  -- log file name
//
//  Returns:    HRESULT
//
//  History:    9/21/00		SHeffner Created
//
//              03-May-2001 Weiyouc  ReWritten
//
//----------------------------------------------------------------------------

HRESULT GetSRFileInfo(LPTSTR ptszLogFile)
{
    HRESULT hr = S_OK;
	int     iCount = 0;
	TCHAR   tszFileName[MAX_PATH];
	
    DH_VDATEPTRIN(ptszLogFile, TCHAR);

	for (iCount = 0; iCount < ARRAYSIZE(g_tszFileVersionList); iCount++)
	{
		//
		//  Assemble the path, since I just have the relative path from windir
		//
		
		_tcscpy(tszFileName, _tgetenv(TEXT("WINDIR")));
		_tcscat(tszFileName, g_tszFileVersionList[iCount]);

		//
		//  Call function to do the work since we have full path
		//
		
		hr = InfoPerFile(ptszLogFile, tszFileName);
		DH_HRCHECK_ABORT(hr, TEXT("InfoPerFile"));
	}

ErrReturn:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   InfoPerFile
//
//  Synopsis:   This function takes the log file path, and the filename,
//              and then will put out the relevant information from the
//              file to be logged.
//				
//
//  Arguments:  [ptszLogFile]  -- Log file name
//				[ptszFileName] -- File to be examined
//
//  Returns:    HRESULT
//
//  History:    9/21/00		SHeffner Created
//
//              03-May-2001 WeiyouC  ReWritten
//
//----------------------------------------------------------------------------
HRESULT InfoPerFile(LPTSTR ptszLogFile, LPTSTR ptszFileName)
{
    HRESULT                     hr       = S_OK;
	HANDLE						hFile    = INVALID_HANDLE_VALUE;
	FILE*                       fpLog    = NULL;
	void*						pvBuf    = NULL;
	UINT						uLen     = 0;;
	DWORD						dwSize   = 0;
	DWORD                       dwResult = 0;
	DWORD                       i        = 0;;
	TCHAR						szString[MAX_PATH];
	BY_HANDLE_FILE_INFORMATION	FileInfo;
	SYSTEMTIME					SysTime;
	VS_FIXEDFILEINFO			FixedFileInfo;

    DH_VDATEPTRIN(ptszLogFile, TCHAR);
    DH_VDATEPTRIN(ptszFileName, TCHAR);

	//
	//  Open up our log file, and log the file we are processing
	//
	
	fpLog = _tfopen(ptszLogFile, TEXT("a"));
	DH_ABORTIF(NULL == fpLog,
	           E_FAIL,
	           TEXT("a"));
	
	fprintf(fpLog, "\n%S\n", ptszFileName);

	//
	//  Open up the file so that we can get the information from the handle
	//  If we are unable to do this we will just log the generic not
	//  able to find file.
	//

	hFile = CreateFile(ptszFileName,
	                   GENERIC_READ,
	                   FILE_SHARE_READ,
	                   NULL,
	                   OPEN_EXISTING,
	                   FILE_ATTRIBUTE_NORMAL,
	                   NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (FALSE != GetFileInformationByHandle(hFile, &FileInfo))
		{
			//
			//  Get file creation time
			//
			
			FileTimeToSystemTime(&FileInfo.ftCreationTime, &SysTime);
			fprintf(fpLog,
			        "\tCreation Date=%S %S %lu, %lu %lu:%lu:%lu\n",
				    g_tszDay[SysTime.wDayOfWeek],
				    g_tszMonth[SysTime.wMonth - 1],
				    SysTime.wDay,
				    SysTime.wYear,
				    SysTime.wHour,
				    SysTime.wMinute,
				    SysTime.wSecond);

			//
			//  Get file last access time
			//
			
			FileTimeToSystemTime(&FileInfo.ftLastAccessTime, &SysTime);
			fprintf(fpLog,
			        "\tLast Access Date=%S %S %lu, %lu %lu:%lu:%lu\n",
				    g_tszDay[SysTime.wDayOfWeek],
				    g_tszMonth[SysTime.wMonth - 1],
				    SysTime.wDay,
				    SysTime.wYear,
				    SysTime.wHour,
				    SysTime.wMinute,
				    SysTime.wSecond);

			//
			//  Get file last write time
			//
			
			FileTimeToSystemTime(&FileInfo.ftLastWriteTime, &SysTime);
			fprintf(fpLog,
			        "\tLast Write Date=%S %S %lu, %lu %lu:%lu:%lu\n",
				    g_tszDay[SysTime.wDayOfWeek],
				    g_tszMonth[SysTime.wMonth - 1],
				    SysTime.wDay,
				    SysTime.wYear,
				    SysTime.wHour,
				    SysTime.wMinute,
				    SysTime.wSecond);
			
			//
			//  Get file attributes
			//
			
			_tcscpy(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? TEXT("ARCHIVE ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED ? TEXT("COMPRESSED ") :  TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? TEXT("DIRECTORY ") :  TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ? TEXT("ENCRYPTED ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ? TEXT("HIDDEN ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_NORMAL ? TEXT("NORMAL ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE ? TEXT("OFFLINE ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? TEXT("READONLY ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ? TEXT("REPARSE_POINT ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE ? TEXT("SPARSE_FILE ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM ? TEXT("SYSTEM ") : TEXT(""));
			_tcscat(szString, FileInfo.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY ? TEXT("TEMPORARY ") : TEXT(""));
			fprintf(fpLog, "\tAttributes=%S\n", szString);
			
			//
			//  Get the VolumeSerialNumber, FileSize, and Number of Links
			//
			
			fprintf(fpLog,
			        "\tVolumeSerialNumber=%lu\n",
			        FileInfo.dwVolumeSerialNumber);
			fprintf(fpLog,
			        "\tFileSize=%lu%lu\n",
			        FileInfo.nFileSizeHigh,
			        FileInfo.nFileSizeLow);
			fprintf(fpLog,
			        "\tNumberOfLinks=%lu\n",
			        FileInfo.nNumberOfLinks);

            dwSize = GetFileVersionInfoSize(ptszFileName, &dwResult);
			if (0 != dwSize)
			{
			    pvBuf = malloc(dwSize);
			    DH_ABORTIF(NULL == pvBuf,
			               E_OUTOFMEMORY,
			               TEXT("malloc"));
		    
				GetFileVersionInfo(ptszFileName,
				                   dwResult,
				                   dwSize,
				                   (LPVOID) pvBuf);

				//
				// Read the list of languages and code pages.
				//

				VerQueryValue(pvBuf, 
							  TEXT("\\VarFileInfo\\Translation"),
							  (LPVOID*)&lpTranslate,
							  &uLen);

				//
				// Read the Version info for each language and code page.
				//
				
				for (i=0; i < (uLen / sizeof(struct LANGANDCODEPAGE)); i++ )
				{
					char* lpBuffer;
					DWORD dwBytes, dwCount = 0;

					fprintf(fpLog,
					        "\tLanguage=%x%x\n",
					        lpTranslate[i].wLanguage,
					        lpTranslate[i].wCodePage);
					
					for (dwCount = 0; dwCount < ARRAYSIZE(g_tszVersionResource); dwCount++)
					{
						//
						//  Generate the string, for getting the resource
						//  based on the language, then retrieve this, and
						//  then put it to the log file.
						//
						
						_stprintf(szString,
						          TEXT("\\StringFileInfo\\%04x%04x\\%s"),
    							  lpTranslate[i].wLanguage,
    							  lpTranslate[i].wCodePage,
								  g_tszVersionResource[dwCount]);
						VerQueryValue(pvBuf, 
									  szString, 
									  (LPVOID *) &lpBuffer, 
									  &uLen); 
						if (0 != uLen)
						{
							fprintf(fpLog,
							        "\t%S=%S\n",
							        g_tszVersionResource[dwCount],
							        lpBuffer);
						}
					}		//While loop end, for each resource
				}	//for loop end for each language
			}	//If check for getting the fileversioninfosize
		}	//if check for GetFileInformationByHandle on the file
	}		//if check on can I open this file

ErrReturn:   

    if (INVALID_HANDLE_VALUE != hFile)
    {
	    CloseHandle(hFile);
	    hFile = INVALID_HANDLE_VALUE;
    }
    if (NULL != fpLog)
    {
    	fclose(fpLog);
    }
    if (NULL != pvBuf)
    {
        free(pvBuf);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\getreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       GetReg.cxx
//
//  Contents:   Routines to get the registry, and dump the contents into
//			    a text file. 
//				
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    9/21/00	    SHeffner	Created
//
//              03-May-2001 WeiyouC     Rewritten
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------
#include "SrHeader.hxx"

//+---------------------------------------------------------------------------
//
//	Function Prototypes
//
//----------------------------------------------------------------------------

BOOL GetSRRegistry(LPTSTR ptszLogFile, LPTSTR ptszRegPath, BOOL fRecurse);

//+---------------------------------------------------------------------------
//
//	Global variables
//
//----------------------------------------------------------------------------

//
//  A list of readable string names for the registery keys
//

LPTSTR tszRegStrings[] = {TEXT("REG_NONE"),
                          TEXT("REG_SZ"),
                          TEXT("REG_EXPAND_SZ"),
                          TEXT("REG_BINARY"),
                          TEXT("REG_DWORD or REG_DWORD_LITTLE_ENDIAN"),
                          TEXT("REG_DWORD_BIG_ENDIAN"),
                          TEXT("REG_LINK"),
                          TEXT("REG_MULTI_SZ"),
                          TEXT("REG_RESOURCE_LIST"),
                          TEXT("REG_FULL_RESOURCE_DESCRIPTOR"),
                          TEXT("REG_RESOURCE_REQUIREMENTS_LIST"),
                          TEXT("REG_QWORD or REG_QWORD_LITTLE_ENDIAN")
                         };

//
//  List of the Registry keys that we are grabbing.
//  The first param is the Path from HKLM, the Second Param
//  is either FALSE for not recursing, or TRUE if you want to
//  recurse all of the sub keys.
//

struct _SR_REG_STRUCTURE_
{
    LPTSTR  ptszRegPath;
    BOOL    fRecurse;
} SRRegKeys [] =
{
    {TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),                FALSE},
    {TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore"), TRUE},
    {TEXT("System\\CurrentControlSet\\Services\\SR"),                        TRUE},
    {TEXT("System\\CurrentControlSet\\Services\\SRService"),                 TRUE},
    {TEXT("Software\\Policies\\Microsoft\\Windows NT\\SystemRestore"),       TRUE},
    {TEXT(""),                                                               FALSE}
};

//+---------------------------------------------------------------------------
//
//  Function:   GetSRRegistry
//
//  Synopsis:   Routine will recursivly call this routine to enumerate the keys
//              and values for the registry
//
//  Arguments:  [ptszLogFile] -- log file name
//				[ptszRegPath] -- registery path
//				[fRecurse]    -- flag indicates if I should recurse into sub paths
//
//  Returns:    TRUE if successful
//
//  History:    9/21/00		SHeffner    Created
//
//              03-May-2001 WeiyouC     Rewitten
//
//----------------------------------------------------------------------------

BOOL GetSRRegistry(LPTSTR ptszLogFile,
                   LPTSTR ptszRegPath,
                   BOOL   fRecurse)
{
	DWORD  dwIndex     = 0;
	DWORD  dwValueSize = MAX_PATH +1;
	DWORD  dwDataSize  = MAX_PATH +1;
	DWORD  dwType      = 0;
	long   lResult     = 0;;
	FILE*  fpLog       = NULL;
	LPTSTR ptszString  = NULL;
	HKEY   hKey;
	TCHAR  tszKey[MAX_PATH +1];
	TCHAR  tszValue[MAX_PATH +1];
	TCHAR  tszNewRegPath[MAX_PATH +1];
	
	//
	//  Open the Log file for append
	//
	
	fpLog = _tfopen(ptszLogFile, TEXT("a"));
	if (NULL == fpLog)
    {
        goto ErrReturn;
    }

	//
	//  Log current path, and then open the registry hive,
	//  and start enumerating the Values.
	//
	
	fprintf(fpLog, "\n[%S]\n", ptszRegPath);
	
	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
	                       ptszRegPath,
	                       0,
	                       KEY_READ,
	                       &hKey);
	if (ERROR_SUCCESS != lResult)
    {
        goto ErrReturn;
    }

	lResult = RegEnumValue(hKey,
	                       dwIndex,
	                       tszKey,
	                       &dwDataSize,
	                       0,
	                       &dwType,
	                       (unsigned char *) tszValue,
	                       &dwValueSize);
	while (ERROR_SUCCESS == lResult )
    {
		ptszString = tszRegStrings[dwType];

		//
		//  If it is type REG_DWORD or REG_DWORD_LITTLE_ENDIAN, then we
		//  do the special type casting. If not then we just pass it through
		//  as a string
        //
		
		if ((REG_DWORD == dwType) ||
		    (REG_DWORD_LITTLE_ENDIAN == dwType))
	    {
			fprintf(fpLog,
			        "\"%S\"=%S:%lu\n",
			        tszKey,
			        ptszString,
			        (DWORD &) tszValue);
	    }
		else 
	    {
			fprintf(fpLog,
			        "\"%S\"=%S:%S\n",
			        tszKey,
			        ptszString,
			        tszValue);
	    }

		//
		//  Update local variables for next iteration.
		//
		
		dwDataSize = dwValueSize = MAX_PATH +1;
		dwIndex ++;
		lResult = RegEnumValue(hKey,
		                       dwIndex,
		                       tszKey,
		                       &dwDataSize,
		                       0,
		                       &dwType,
		                       (unsigned char *) tszValue,
		                       &dwValueSize);
	}

	//
	//  Close out the file, for next recursion loop.
	//
	
	fclose(fpLog);

	
	//
	//  Now lets find all of the Key's under this key,
	//  and start a another enumeration for each one found
	//
	
	if  (fRecurse)
    {
		dwIndex = 0;
		dwDataSize = MAX_PATH +1;
		lResult = RegEnumKey(hKey, dwIndex, tszKey, dwDataSize);
		while (ERROR_SUCCESS == lResult)
	    {
			//
			//  Build the path, and then call this function again.
			//
			
			_tcscpy(tszNewRegPath, ptszRegPath);
			_tcscat(tszNewRegPath, TEXT("\\"));
			_tcscat(tszNewRegPath, tszKey);
			GetSRRegistry(ptszLogFile, tszNewRegPath, fRecurse);

			//
			//  Now do next run through.
			//
			
			dwDataSize = MAX_PATH + 1;
			dwIndex ++;
			lResult = RegEnumKey(hKey, dwIndex, tszKey, dwDataSize);
		}
	}

ErrReturn:
    if (NULL != fpLog)
    {
        fclose(fpLog);
    }

	RegCloseKey(hKey);
	
	return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSRRegInfo
//
//  Synopsis:   Get SR registery settings and dump it to the log file
//
//  Arguments:  [ptszLogFile] -- log file name
//
//  Returns:    HRESULT
//
//  History:    9/21/00		SHeffner    Created
//
//              03-May-2001 WeiyouC     Rewitten
//
//----------------------------------------------------------------------------

HRESULT GetSRRegInfo(LPTSTR ptszLogFile)
{
    HRESULT hr  = S_OK;
	int     i   = 0;
	BOOL    fOK = FALSE;

    DH_VDATEPTRIN(ptszLogFile, TCHAR);
    
	while (NULL != *(SRRegKeys[i].ptszRegPath))
    {
	    fOK = GetSRRegistry(ptszLogFile,
                            SRRegKeys[i].ptszRegPath,
                            SRRegKeys[i].fRecurse);
	    DH_ABORTIF(!fOK,
	               E_FAIL,
	               TEXT("GetSRRegistry"));
	    i++;
	}

ErrReturn:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\getrstrlog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       GetRstrLog.cxx
//
//  Contents:   Intepreting the rstrlog.dat to a more readable format  
//				
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    03-May-2001 WeiyouC     Copied from dev code and minor rewite
//
//----------------------------------------------------------------------------

//--------------------------------------------------------------------------
// includes
//--------------------------------------------------------------------------

#include "SrHeader.hxx"
#include <srdefs.h>
#include <restmap.h>
#include <srshell.h>

#include "mfr.h"

//--------------------------------------------------------------------------
// Defines
//--------------------------------------------------------------------------

#define COUNT_RESNAME (sizeof(s_cszResName)/sizeof(LPCWSTR)-1)

//--------------------------------------------------------------------------
// Global variables
//--------------------------------------------------------------------------

static LPCWSTR  s_cszResName[] =
{
    L"",
    L"Fail",
    L"OK",
    L"Lock",
    L"Disk R/O",
    L"Exists",
    L"Ignored",
    L"Not Found",
    L"Conflict",
    L"Optimized",
    L"Lock Alt",
    NULL
};

//+---------------------------------------------------------------------------
//
//  Function:   ParseRstrLog
//
//  Synopsis:   Parse rstrlog.dat to a readable format
//
//  Arguments:  ptszRstrLog     --  restore log
//              ptszReadableLog -- the result log
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT ParseRstrLog(LPTSTR ptszRstrLog,
                     LPTSTR ptszReadableLog)
{
    HRESULT          hr      = S_OK;
    DWORD            i       = 0;
    DWORD            dwFlags = 0;
    FILE*            fpLog   = NULL;
    CMappedFileRead  cMFR;
    SRstrLogHdrBase  sHdr1;
    SRstrLogHdrV3    sHdr2;
    SRstrEntryHdr    sEntHdr;
    WCHAR            wszBuf1[SR_MAX_FILENAME_LENGTH];
    WCHAR            wszBuf2[SR_MAX_FILENAME_LENGTH];
    WCHAR            wszBuf3[SR_MAX_FILENAME_LENGTH];

    DH_VDATEPTRIN(ptszRstrLog, TCHAR);
    DH_VDATEPTRIN(ptszReadableLog, TCHAR);

    fpLog = _tfopen(ptszReadableLog, TEXT("w"));
    if (NULL == fpLog)
        goto ErrReturn;

    if (_taccess(ptszRstrLog, 0) == -1)
        goto ErrReturn;
    
    if (!cMFR.Open(ptszRstrLog))
        goto ErrReturn;

    if (!cMFR.Read(&sHdr1, sizeof(sHdr1)))
        goto ErrReturn;
    
    if ((sHdr1.dwSig1 != RSTRLOG_SIGNATURE1) ||
        (sHdr1.dwSig2 != RSTRLOG_SIGNATURE2))
    {
        fprintf(stderr, "Invalid restore log file signature...\n");
        goto ErrReturn;
    }
    if (HIWORD(sHdr1.dwVer) != RSTRLOG_VER_MAJOR)
    {
        fprintf(stderr,
                "Unknown restore log file version - %d (0x%08X)\n",
                HIWORD(sHdr1.dwVer), sHdr1.dwVer);
        goto ErrReturn;
    }

    if (!cMFR.Read(&sHdr2, sizeof(sHdr2)))
        goto ErrReturn;
    
    fprintf(fpLog, "Flags,         ");
    if (sHdr2.dwFlags == 0)
    {
        fprintf(fpLog, "<none>");
    }
    else
    {
        if (sHdr2.dwFlags & RLHF_SILENT)
            fprintf(fpLog, " Silent");
        if (sHdr2.dwFlags & RLHF_UNDO)
            fprintf(fpLog, " Undo");            
    }
    fprintf(fpLog, "\n");
    fprintf(fpLog, "Restore Point,  %d\n", sHdr2.dwRPNum);
    fprintf(fpLog, "New Restore RP, %d\n", sHdr2.dwRPNew);
    fprintf(fpLog, "# of Drives,    %d\n", sHdr2.dwDrives);
    for (i = 0;  i < sHdr2.dwDrives;  i++)
    {
        if (!cMFR.Read(&dwFlags))
            goto ErrReturn;
        if (!cMFR.ReadDynStrW(wszBuf1, MAX_PATH))
            goto ErrReturn;
        if (!cMFR.ReadDynStrW(wszBuf2, MAX_PATH))
            goto ErrReturn;
        if (!cMFR.ReadDynStrW(wszBuf3, MAX_PATH))
            goto ErrReturn;
        fprintf(fpLog,
                "%08X, %ls, %ls, %ls\n",
                dwFlags,
                wszBuf1,
                wszBuf2,
                wszBuf3);
    }

    for (i = 0;  cMFR.GetAvail() > 0;  i++)
    {
        LPCWSTR  cszOpr;
        WCHAR    szRes[16];

        if (!cMFR.Read(&sEntHdr, sizeof(sEntHdr)))
            goto ErrReturn;

        if (sEntHdr.dwID == RSTRLOGID_ENDOFMAP)
        {
            fprintf(fpLog,
                    "%4d,    ,     , END OF MAP\n",
                    i);
            continue;
        }
        else if (sEntHdr.dwID == RSTRLOGID_STARTUNDO)
        {
            fprintf(fpLog,
                    "%4d,    ,     , START UNDO\n",
                    i);
            continue;
        }
        else if (sEntHdr.dwID == RSTRLOGID_ENDOFUNDO)
        {
            fprintf(fpLog,
                    "%4d,    ,     , END OF UNDO\n",
                    i);
            continue;
        }
        else if (sEntHdr.dwID == RSTRLOGID_SNAPSHOTFAIL)
        {
            fprintf(fpLog,
                    "%4d,    ,     , SNAPSHOT RESTORE FAILED : Error=%ld\n",
                    i,
                    sEntHdr.dwErr);
            continue;
        }
        
        switch (sEntHdr.dwOpr)
        {
        case OPR_DIR_CREATE :
            cszOpr = L"DirAdd";
            break;
        case OPR_DIR_RENAME :
            cszOpr = L"DirRen";
            break;
        case OPR_DIR_DELETE :
            cszOpr = L"DirDel";
            break;
        case OPR_FILE_ADD :
            cszOpr = L"Create";
            break;
        case OPR_FILE_DELETE :
            cszOpr = L"Delete";
            break;
        case OPR_FILE_MODIFY :
            cszOpr = L"Modify";
            break;
        case OPR_FILE_RENAME :
            cszOpr = L"Rename";
            break;
        case OPR_SETACL :
            cszOpr = L"SetACL";
            break;
        case OPR_SETATTRIB :
            cszOpr = L"Attrib";
            break;
        default :
            cszOpr = L"Unknown";
            break;
        }

        if (!cMFR.ReadDynStrW(wszBuf1, SR_MAX_FILENAME_LENGTH))
            goto ErrReturn;
        
        if (!cMFR.ReadDynStrW(wszBuf2, SR_MAX_FILENAME_LENGTH))
            goto ErrReturn;
        
        if (!cMFR.ReadDynStrW(wszBuf3, SR_MAX_FILENAME_LENGTH))
            goto ErrReturn;
        
        if (sEntHdr.dwID == RSTRLOGID_COLLISION)
        {
            fprintf(fpLog,
                    "%4d,    ,     , Collision, , , %ls, %ls, %ls\n",
                    i,
                    wszBuf1,
                    wszBuf2,
                    wszBuf3);
            continue;
        }

        if (sEntHdr.dwRes < COUNT_RESNAME)
        {
            ::lstrcpy(szRes, s_cszResName[sEntHdr.dwRes]);
        }
        else
        {
            ::wsprintf(szRes, L"%X", sEntHdr.dwRes);
        }
        fprintf(fpLog,
                "%4d,%4d,%5I64d, %ls, %ls, %d, %ls, %ls, %ls\n",
                i,
                sEntHdr.dwID,
                sEntHdr.llSeq,
                cszOpr,
                szRes,
                sEntHdr.dwErr,
                wszBuf1,
                wszBuf2,
                wszBuf3);
    }

ErrReturn:

    cMFR.Close();
    if (NULL != fpLog)
    {
        fclose(fpLog);
    }
    return hr;
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\killwarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      killwarn.hxx
//
//  Contents:  Pragma's to kill specific warnings at W4
//
//  History:   28-jun-2000        jgreen   stolen from ctolestg
//--------------------------------------------------------------------------
#ifndef __KILLWARN_HXX__
#define __KILLWARN_HXX__

//
//  Quotes taken from vc user's manual
//


// Turn off: unreferenced inline function has been removed
#pragma warning(disable: 4514)

// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.
#pragma warning(disable: 4201)

// 'identifier' : inconsistent DLL linkage. dllexport assumed
//
// The specified member function was declared in a class with dllexport
// linkage, and then was imported. This warning can also be caused by
// declaring a member function in a class with dllimport linkage as neither
// imported nor static nor inline.
//
// The function was compiled as dllexport.
#pragma warning(disable: 4273)

// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.
#pragma warning(disable: 4512)

// 'function': function not expanded
//
// The given function was selected for inline expansion but the compiler did 
// not perform the inlining.
#pragma warning(disable:4710)

// trigraph not being substituted
#pragma warning (disable: 4110)

#ifdef _MAC
// alignment of a memeber was sensitive to packing
#pragma warning (disable: 4121)
#endif // _MAC

// access-declarations are deprecated; member using-declarations provide 
// a better alternative
#pragma warning (disable: 4516)

#endif  // __KILLWARN_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\mfr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       Mfr.cxx
//
//  Contents:   The implementation of the CMappedFileRead class  
//				
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    03-May-2001 WeiyouC     Copied from dev code and minor rewite
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <shellapi.h>
#include <srdefs.h>
#include <srshell.h>

#include "mfr.h"


/////////////////////////////////////////////////////////////////////////////
//
// CMappedFileRead class
//
/////////////////////////////////////////////////////////////////////////////

CMappedFileRead::CMappedFileRead()
{
    m_szPath[0] = L'\0';
    m_dwSize    = 0;
    m_hFile     = INVALID_HANDLE_VALUE;
    m_hMap      = INVALID_HANDLE_VALUE;
    m_pBuf      = NULL;
}

CMappedFileRead::~CMappedFileRead()
{
    Close();
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::Open( LPCWSTR cszPath )
{
    BOOL  fRet = FALSE;

    Close();

    m_hFile = ::CreateFile( cszPath, GENERIC_READ,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, NULL );
    if ( m_hFile == INVALID_HANDLE_VALUE )
    {
        fprintf(stderr, "CMappedFileRead::Open\n  ::CreateFile failed, err=%u\n", ::GetLastError());
        goto Exit;
    }
    m_dwSize = ::GetFileSize( m_hFile, NULL );
    if ( m_dwSize == 0xFFFFFFFF )
    {
        fprintf(stderr, "CMappedFileRead::Open\n  ::GetFileSize failed, err=%u\n", ::GetLastError());
        goto Exit;
    }

    m_hMap = ::CreateFileMapping( m_hFile, NULL, PAGE_READONLY, 0, 0, NULL );
    if ( m_hFile == INVALID_HANDLE_VALUE )
    {
        fprintf(stderr, "CMappedFileRead::Open\n  ::CreateFileMapping failed, err=%u\n", ::GetLastError());
        goto Exit;
    }

    m_pBuf = (LPBYTE)::MapViewOfFile( m_hMap, FILE_MAP_READ, 0, 0, 0 );
    if ( m_pBuf == NULL )
    {
        fprintf(stderr, "CMappedFileRead::Open\n  ::MapViewOfFile failed, err=%u\n", ::GetLastError());
        goto Exit;
    }

    ::lstrcpy( m_szPath, cszPath );
    m_pCur    = m_pBuf;
    m_dwAvail = m_dwSize;

    fRet = TRUE;
Exit:
    if ( !fRet )
        Close();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

void  CMappedFileRead::Close()
{
    if ( m_pBuf != NULL )
    {
        ::UnmapViewOfFile( m_pBuf );
        m_pBuf = NULL;
    }
    if ( m_hMap != INVALID_HANDLE_VALUE )
    {
        ::CloseHandle( m_hMap );
        m_hMap = INVALID_HANDLE_VALUE;
    }
    if ( m_hFile != INVALID_HANDLE_VALUE )
    {
        ::CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::Read( LPVOID pBuf, DWORD cbBuf )
{
    BOOL  fRet = FALSE;

    if ( cbBuf > m_dwAvail )
    {
        fprintf(stderr, "CMappedFileRead::Read(LPVOID,DWORD)\n  Insufficient data - %d bytes (need=%d bytes)\n", m_dwAvail, cbBuf);
        goto Exit;
    }

    ::CopyMemory( pBuf, m_pCur, cbBuf );

    m_pCur    += cbBuf;
    m_dwAvail -= cbBuf;

    fRet = TRUE;
Exit:
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::Read( DWORD *pdw )
{
    BOOL  fRet = FALSE;

    if ( sizeof(DWORD) > m_dwAvail )
    {
        fprintf(stderr, "CMappedFileRead::Read(DWORD)\n  Insufficient data - %d bytes (need=%d bytes)\n", m_dwAvail, sizeof(DWORD));
        goto Exit;
    }

    *pdw = *((LPDWORD)m_pCur);

    m_pCur    += sizeof(DWORD);
    m_dwAvail -= sizeof(DWORD);

    fRet = TRUE;
Exit:
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::ReadDynStrW( LPWSTR szBuf, DWORD cchMax )
{
    BOOL   fRet = FALSE;
    DWORD  dwLen;

    if ( !Read( &dwLen ) )
        goto Exit;

    if ( dwLen == 0 )
    {
        szBuf[0] = L'\0';
        goto Done;
    }

    if ( dwLen > cchMax*sizeof(WCHAR) )
    {
        fprintf(stderr, "CMappedFileRead::ReadDynStrW\n  Invalid string length - %d (max=%d)\n", dwLen, cchMax);
        goto Exit;
    }

    if ( !Read( szBuf, dwLen ) )
        goto Exit;

Done:
    fRet = TRUE;
Exit:
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_utils.h>

#include <shlobj.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\getsrevent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2001.
//
//  File:       GetSREvent.cxx
//
//  Contents:	Gets SR related system events
//
//  Classes:    n/a
//
//  Coupling:
//
//  Notes:
//
//  History:    20-04-2001   weiyouc   Created
//
//----------------------------------------------------------------------------

//--------------------------------------------------------------------------
//  Headers
//--------------------------------------------------------------------------

#include "SrHeader.hxx"

//--------------------------------------------------------------------------
//  Defines
//--------------------------------------------------------------------------

#define MAX_BUF_SIZE            1000
#define SR_SERVICE_SRC          TEXT("SrService")
#define SR_FILTER_SRC           TEXT("sr")
#define SR_SERVICE_EVENTID_BASE 0x00000067
#define SR_FILTER_EVENTID_BASE  0x00000001

//--------------------------------------------------------------------------
//  Function prototypes
//--------------------------------------------------------------------------

HRESULT DumpSREvent(LPTSTR ptszLog, EVENTLOGRECORD* pEvent);

HRESULT DumpSREventMsg(FILE* fpLog, EVENTLOGRECORD* pEvent);

LPCTSTR GetSrEventStr(WORD wEventType);

//--------------------------------------------------------------------------
//  Some global variables
//--------------------------------------------------------------------------

LPCTSTR g_tszEventType[] =
{
    TEXT("UNKNOWN_EVENT"),
    TEXT("EVENTLOG_ERROR_TYPE"),
    TEXT("EVENTLOG_WARNING_TYPE"),
    TEXT("EVENTLOG_INFORMATION_TYPE"),
    TEXT("EVENTLOG_AUDIT_SUCCESS"),
    TEXT("EVENTLOG_AUDIT_FAILURE")
};

LPCSTR g_szSrServiceEventMsg[] =
{
    "The System Restore control handler could not be installed.",
    
    "The System Restore initialization process failed.",
    
    "The System Restore service received an unsupported request.",
    
    "The System Restore service was started.",
    
    "The System Restore service has been suspended because there is not "
    "enough disk space available on the drive %S. System Restore will "
    "automatically resume service once at least %S MB of free disk space "
    "is available on the system drive.",
    
    "The System Restore service has resumed monitoring due to space freed "
    "on the system drive.",
    
    "The System Restore service was stopped.",
    
    "A restoration to \"%S\" restore point occurred successfully.",
    
    "A restoration to \"%S\" restore point failed. "
    "No changes have been made to the system.",
    
    "A restoration to \"%S\" restore point was incomplete due to an "
    "improper shutdown.",
    
    "System Restore monitoring was enabled on drive %S.",
    
    "System Restore monitoring was disabled on drive %S.",
    
    "System Restore monitoring was enabled on all drives.",
    
    "System Restore monitoring was disabled on all drives.",
};

//+---------------------------------------------------------------------------
//
//  Function:   GetSREvents
//
//  Synopsis:   Get SR related event to a log file
//
//  Arguments:  ptszLogFile --  log file name
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT GetSREvents(LPTSTR ptszLogFile)
{
    HRESULT         hr              = S_OK;
	HANDLE          hEventLog       = NULL; 
	EVENTLOGRECORD* pelrEvent       = NULL;
	FILE*           fpLog           = NULL;
	BOOL            fOK             = FALSE;
	DWORD           dwBytesRead     = 0;
	DWORD           dwBytesNeeded   = 0;
	LPTSTR          ptszSrcName     = NULL;
	BYTE            bEventBuf[MAX_BUF_SIZE];

    DH_VDATEPTRIN(ptszLogFile, TCHAR);
    
    hEventLog = OpenEventLog(NULL, TEXT("System"));
    DH_ABORTIF(NULL == hEventLog,
               HRESULT_FROM_WIN32(GetLastError()),
               TEXT("OpenEventLog"));

    ZeroMemory(&bEventBuf, MAX_BUF_SIZE);
    pelrEvent = (EVENTLOGRECORD *) &bEventBuf;
	while (ReadEventLog(hEventLog,
                        EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        pelrEvent,
                        MAX_BUF_SIZE,
                        &dwBytesRead,
                        &dwBytesNeeded))
    {
        //
        //  Since there might be multiple logs packed in the buffer,
        //  we need to unpack them.
        //
        
		while (dwBytesRead > 0)
	    {
    		//
    		//  If the source name is what we are interested,
    		//  we dump the event log
    		//
    		
    		ptszSrcName = (LPTSTR)((LPBYTE) pelrEvent + sizeof(EVENTLOGRECORD));
    		if ((0 == _tcsicmp(ptszSrcName, SR_SERVICE_SRC)) ||
    		    (0 == _tcsicmp(ptszSrcName, SR_FILTER_SRC)))
    	    {
    	        hr = DumpSREvent(ptszLogFile, pelrEvent);
    	        DH_HRCHECK_ABORT(hr, TEXT("DumpSREvent"));
    	    }

    		dwBytesRead -= pelrEvent->Length;
    		pelrEvent = (EVENTLOGRECORD*)((LPBYTE) pelrEvent + pelrEvent->Length); 
	    }
		
		ZeroMemory(&bEventBuf, MAX_BUF_SIZE);
		pelrEvent = (EVENTLOGRECORD *) &bEventBuf;
	}
	
ErrReturn:
    if (NULL != hEventLog)
    {
        CloseEventLog(hEventLog);
    }
    if (NULL != fpLog)
    {
        fclose(fpLog);
    }

	return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DumpSREvent
//
//  Synopsis:   Dump an SR-related event to the log file
//
//  Arguments:  ptszLogFile --  log file name
//              pEvent      --  pointer to a system event
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DumpSREvent(LPTSTR          ptszLog,
                    EVENTLOGRECORD* pEvent)
{
    HRESULT    hr           = S_OK;
    FILE*      fpLog        = NULL;
    WORD       wEventType   = 0;
    __int64    llTemp       = 0;
    __int64    llSecsTo1970 = 116444736000000000;
    FILETIME   FileTime;
    FILETIME   LocalFileTime;
    SYSTEMTIME SysTime;

    DH_VDATEPTRIN(ptszLog, TCHAR);
    DH_VDATEPTRIN(pEvent, EVENTLOGRECORD);

    fpLog = _tfopen(ptszLog, TEXT("a"));
    DH_ABORTIF(NULL == fpLog,
               E_FAIL,
               TEXT("_tfopen"));

    //
    //  Dump the event source
    //

    fprintf(fpLog,
            "Event Source: %S \n",
            (LPTSTR)((LPBYTE) pEvent + sizeof(EVENTLOGRECORD)));
    
    //
    //  Dump the event number
    //
    
    fprintf(fpLog, "Event Number: %u \n", pEvent->RecordNumber);

    //
    //  Dump the event ID
    //
    
    fprintf(fpLog, "Event ID: %x \n", (0xFFFF & pEvent->EventID));

    //
    //  Dump the event 
    //

    wEventType = pEvent->EventType;
    if ((wEventType >= EVENTLOG_ERROR_TYPE) &&
        (wEventType <= EVENTLOG_AUDIT_FAILURE))
    {
        fprintf(fpLog,
                "Event Type: %S \n",
                GetSrEventStr(wEventType));
    }

    //
    //  Now dump the event message
    //

    hr = DumpSREventMsg(fpLog, pEvent);
    DH_HRCHECK_ABORT(hr, TEXT("DumpSREventMsg"));
    
    //
    //  Dump the event time
    //

    llTemp = Int32x32To64(pEvent->TimeGenerated, 10000000) + llSecsTo1970;

    FileTime.dwLowDateTime = (DWORD) llTemp;
    FileTime.dwHighDateTime = (DWORD)(llTemp >> 32);

    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SysTime);

    fprintf(fpLog,
            "Time Generated: %02d/%02d/%02d   %02d:%02d:%02d\n",
            SysTime.wMonth,
            SysTime.wDay,
            SysTime.wYear,
            SysTime.wHour,
            SysTime.wMinute,
            SysTime.wSecond);

    //
    //  Finally we put an extra line break
    //
    
    fprintf(fpLog, "\n");
    
ErrReturn:
    
    if (NULL != fpLog)
    {
        fclose(fpLog);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DumpSREventMsg
//
//  Synopsis:   Dump an SR-related event message to the log file
//
//  Arguments:  fpLog  --  file pointer to the log file
//              pEvent --  pointer to a system event
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DumpSREventMsg(FILE*           fpLog,
                       EVENTLOGRECORD* pEvent)
{
    HRESULT hr        = S_OK;
    DWORD   dwEventID = 0;

    DH_VDATEPTRIN(fpLog, FILE);
    DH_VDATEPTRIN(pEvent, EVENTLOGRECORD);

    fprintf(fpLog, "Message: ");
    
    //
    //  If this is a filter type event log
    //

    dwEventID = 0xFFFF & pEvent->EventID;
    if (dwEventID == SR_FILTER_EVENTID_BASE)
    {
        fprintf(fpLog, "SR filter has encountered a volume error");
    }
    else
    {
        fprintf(fpLog,
                g_szSrServiceEventMsg[dwEventID - SR_SERVICE_EVENTID_BASE],
                (LPTSTR)(pEvent->StringOffset + (LPBYTE) pEvent));
    }

    fprintf(fpLog, "\n");
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSrEventStr
//
//  Synopsis:   Translate an event to an event string
//
//  Arguments:  wEventType  --  event type
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LPCTSTR GetSrEventStr(WORD wEventType)
{
    WORD wIndex = 0;

    switch (wEventType)
    {
        case EVENTLOG_ERROR_TYPE:
             wIndex = 1;
             break;
             
        case EVENTLOG_WARNING_TYPE:
             wIndex = 2;
             break;
             
        case EVENTLOG_INFORMATION_TYPE:
             wIndex = 3;
             break;
             
        case EVENTLOG_AUDIT_SUCCESS:
             wIndex = 4;
             break;
             
        case EVENTLOG_AUDIT_FAILURE:
             wIndex = 5;
             break;

        default:
             break;
    }

    return g_tszEventType[wIndex];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\mfr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       Mfr.h
//
//  Contents:   Class definition of CMappedFileRead class  
//				
//
//  Objects:    
//
//  Coupling:
//
//  Notes:      
//
//  History:    03-May-2001 WeiyouC     Copied from dev code and minor rewite
//
//----------------------------------------------------------------------------


#ifndef __MFR_H_INCLUDED__
#define __MFR_H_INCLUDED__
#pragma once


/////////////////////////////////////////////////////////////////////////////
//
// CMappedFileRead class
//
/////////////////////////////////////////////////////////////////////////////

class CMappedFileRead
{
public:
    CMappedFileRead();
    ~CMappedFileRead();

// Operations
public:
    BOOL  Open( LPCWSTR cszPath );
    void  Close();
    BOOL  Read( LPVOID pBuf, DWORD cbBuf );
    BOOL  Read( DWORD *pdw );
    LPCWSTR  ReadStrAnsi( DWORD cbStr );
    BOOL  ReadDynStrW( LPWSTR szBuf, DWORD cchMax );

protected:

// Attributes
public:
    DWORD  GetAvail()  {  return( m_dwAvail );  }

protected:
    WCHAR   m_szPath[MAX_PATH];
    DWORD   m_dwSize;
    HANDLE  m_hFile;
    HANDLE  m_hMap;
    LPBYTE  m_pBuf;
    LPBYTE  m_pCur;
    DWORD   m_dwAvail;
};


#endif //ndef __MFR_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\srdiag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2001.
//
//  File:       srdiag.h
//
//  Contents:	This the header file for the main module of srdiag.exe.
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    20-04-2001   weiyouc   Created
//
//----------------------------------------------------------------------------

#ifndef __SRDIAG_H__
#define __SRDIAG_H__

//--------------------------------------------------------------------------
// Headers
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Various Defines
//--------------------------------------------------------------------------
#define SR_CONFIG_REG_KEY \
	    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\Cfg")

//--------------------------------------------------------------------------
// ProtoTypes
//--------------------------------------------------------------------------

HRESULT GetSRRegInfo(LPTSTR ptszLogFile);

HRESULT ParseRstrLog(LPTSTR ptszRstrLog,
                     LPTSTR ptszReadableLog);

HRESULT GetDSOnSysVol(LPTSTR* pptszDsOnSys);

HRESULT RPEnumDrives(MPC::Cabinet* pCab,
         	         LPTSTR        ptszLogFile);

HRESULT GetChgLogOnDrives(LPTSTR ptszLogFile);

HRESULT GetSRFileInfo(LPTSTR ptszLogFile);

HRESULT GetSREvents(LPTSTR ptszLogFile);

HRESULT CleanupFiles();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2001.
//
//  File:       Main.cxx
//
//  Contents:	This the implementation for the main module of srdiag.exe.
//
//  Classes:    n/a
//
//  Functions:  DiaplayHelp
//              ParseCmdLine
//              Main
//
//  Coupling:
//
//  Notes:
//
//  History:    20-04-2001   weiyouc   Created
//
//----------------------------------------------------------------------------

//--------------------------------------------------------------------------
//  Headers
//--------------------------------------------------------------------------

#include "SrHeader.hxx"

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#include "stdafx.h"
#include "srdiag.h"

//--------------------------------------------------------------------------
// Local defines
//--------------------------------------------------------------------------

#define CAB_FILE_EXT ".cab"

//--------------------------------------------------------------------------
// Local function prototypes
//--------------------------------------------------------------------------

void DisplayHelp();

HRESULT ParseCmdLine(BOOL*   pfDisplayHelp,
                     LPTSTR* pptszCabFileName,
                     LPTSTR* pptszCabLoc);

HRESULT GenerateCabFileName(LPTSTR* pptszCabFile);

HRESULT OpenCabFile(MPC::Cabinet* pCab,
                    LPTSTR        ptszCabFileName,
                    LPTSTR        ptszCabLoc);

HRESULT AppendFilesToCabFile(MPC::Cabinet * pCab);

//--------------------------------------------------------------------------
//  Global Variables
//--------------------------------------------------------------------------

//
// List of files that we will collect at %windir% directory.
//

LPCTSTR g_tszWindirFileCollection[] =
{
    TEXT("\\system32\\restore\\machineguid.txt"),
    TEXT("\\system32\\restore\\filelist.xml"),
    TEXT("\\system32\\restore\\rstrlog.dat")
};

//
//	List of the files, that we will collect at the root of
//  %systemdrv%\System Volume Information\_Restore{GUID} directory.
//

LPCTSTR g_tszSysVolFileCollection[] =
{
    TEXT("_filelst.cfg"),
    TEXT("drivetable.txt"),
    TEXT("_driver.cfg"),
    TEXT("fifo.log"),
};

//--------------------------------------------------------------------------
//  Functions
//--------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Displays a help page for the user
//
//  Arguments:  (none)
//
//  Returns:    void
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DisplayHelp()
{
    printf("\n");
    printf("Microsoft Windows XP \n");
	printf("Usage: SrDiag [/CabName:test.cab] [/CabLoc:\"c:\\temp\\\"] \n");
	printf("  /CabName is the full name of the cab file that you wish to use. \n"
	       "           If the cab file name is not specified, the system will \n"
	       "           automatically generate one in the following format: \n"
	       "           <machine_name>_mmddyy_hhss.cab \n");
	printf("  /CabLoc  points to the location to store the cab. \n"
	       "           It must have a \\ on the end. \n"
	       "           The default location is the current directory. \n");
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseCmdLine
//
//  Synopsis:   Sets Globals based on Cmd and Enviroment settings
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT ParseCmdLine(BOOL*   pfDisplayHelp,
                     LPTSTR* pptszCabFileName,
                     LPTSTR* pptszCabLoc)
{
    HRESULT hr = S_OK;

    //
    //  Do we want to generate full string for printed test cases?
    //
    
    *pfDisplayHelp = (GETPARAM_ISPRESENT("help") ||
                      GETPARAM_ISPRESENT("?"));

    //
    //  Do we specify the cab file name or not
    //

    GETPARAM_ABORTONERROR("CabName:tstr", *pptszCabFileName);

    //
    // If cab file location is
    //

    GETPARAM_ABORTONERROR("CabLoc:tstr", *pptszCabLoc);

ErrReturn:
    return hr;
} // ParseCmdLine

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Entry point for srdiag.exe
//
//  Arguments:  [argc] --  Command Line Arg Count
//              [argv] --  Command Line Args
//
//  Returns:    VOID
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void __cdecl main (int argc, char *argv[])
{
    HRESULT      hr              = S_OK;
    BOOL         fDisplayHelp    = FALSE;
    LPTSTR       ptszCabFileName = NULL;
    LPTSTR       ptszCabLoc      = NULL;
    MPC::Cabinet Cab;

    hr = ParseCmdLine(&fDisplayHelp,
                      &ptszCabFileName,
                      &ptszCabLoc);
    DH_HRCHECK_ABORT(hr, TEXT("ParseCmdLine"));

    //
    //  Do we need to display help
    //
    
    if (fDisplayHelp)
    {
        DisplayHelp();
        goto ErrReturn;
    }

    //
    //  Make sure that we always start from a clean environment
    //

    hr = CleanupFiles();
    DH_HRCHECK_ABORT(hr, TEXT("CleanupFiles"));
    
    //
    //  Open the cab file
    //

    hr = OpenCabFile(&Cab, ptszCabFileName, ptszCabLoc);
    DH_HRCHECK_ABORT(hr, TEXT("OpenCabFile"));

    //
    //  Now append the files to the cab file
    //

    hr = AppendFilesToCabFile(&Cab);
    DH_HRCHECK_ABORT(hr, TEXT("AppendFilesToCabFile"));
    
    //
    //  Now we create the cab file for real
    //

    hr = Cab.Compress();
    DH_HRCHECK_ABORT(hr, TEXT("Cabinet::Compress"));

    //
    //  Clean up the files
    //

    hr = CleanupFiles();
    DH_HRCHECK_ABORT(hr, TEXT("CleanupFiles"));
    
ErrReturn:

    CleanupTStr(&ptszCabFileName);
    CleanupTStr(&ptszCabLoc);
    
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   GenerateCabFileName
//
//  Synopsis:   Generate a cab file name = ComputerName + ddmmyy + hhmmss
//
//  Arguments:  [pptszCabFile] --  cab file name
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT GenerateCabFileName(LPTSTR* pptszCabFile)
{
    HRESULT hr           = S_OK;
    time_t  ltime        = 0;
    tm*     ptmNow       = NULL;
    size_t  stRet        = 0;
    TCHAR   tszTmTemp[MAX_PATH];
    TCHAR   tszCabFile[MAX_PATH];

    DH_VDATEPTROUT(pptszCabFile, LPTSTR);
   
    //
    // Copy Computer Name to CabFileName
    //
    
    _tcscpy(tszCabFile, _tgetenv(TEXT("COMPUTERNAME")));
    DH_HRCHECK_ABORT(hr, TEXT("CopyString"));
    
    //
    // Append Undescore character to CabFileName
    //
    
    _tcscat(tszCabFile, TEXT("_"));

    //    
    // Get System Time and Date
    //
    
    time(&ltime);
    ptmNow = localtime(&ltime);

    //
    // Convert time/date to mmddyyhhmmss format (24hr)
    //
    
    stRet = _tcsftime(tszTmTemp,
                      MAX_PATH,
                      TEXT("%m%d%y_%H%M%S"),
                      ptmNow);
    DH_ABORTIF(0 == stRet,
               E_FAIL,
               TEXT("_tcsftime"));
    _tcscat(tszCabFile, tszTmTemp);

    //
    // Finally append on the extension and now we are set.
    //
    
    _tcscat(tszCabFile, TEXT(CAB_FILE_EXT));

    hr = CopyString(tszCabFile, pptszCabFile);
    DH_HRCHECK_ABORT(hr, TEXT("CopyString"));

ErrReturn:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenCabFile
//
//  Synopsis:   Open the cab file
//
//  Arguments:  [pCab]            --  pointer to the cab file
//              [ptszCabFileName] -- cab file name
//              [ptszCabLoc]      -- cab file location
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT OpenCabFile(MPC::Cabinet* pCab,
                    LPTSTR        ptszCabFileName,
                    LPTSTR        ptszCabLoc)
{
    HRESULT hr                  = S_OK;
    LPTSTR  ptszFullCabFileName = NULL;

    DH_VDATEPTRIN(pCab, MPC::Cabinet);

    //
    //  If the user does not specify the cab file name,
    //  we will generate one.
    //
    
    if (NULL == ptszCabFileName)
    {
        hr = GenerateCabFileName(&ptszCabFileName);
        DH_HRCHECK_ABORT(hr, TEXT("GenerateCabFileName"));
    }

    //
    //  If the use specifies a location for the cab file,
    //  we need to glue it together with the cab file name
    //
    
    if (NULL != ptszCabLoc)
    {
        hr = SrTstTStrCat(ptszCabLoc,
                          ptszCabFileName,
                          &ptszFullCabFileName);
        DH_HRCHECK_ABORT(hr, TEXT("SrTstStrCat"));
    }
    else
    {
        hr = CopyString(ptszCabFileName, &ptszFullCabFileName);
        DH_HRCHECK_ABORT(hr, TEXT("CopyString"));
    }

    //
    //  Open the cabinet file
    //

    hr = pCab->put_CabinetFile(ptszFullCabFileName);
    DH_HRCHECK_ABORT(hr, TEXT("Cabinet::put_CabinetFile"));

    //
    //  Also set a flag to ignore the missing file
    //

    hr = pCab->put_IgnoreMissingFiles(TRUE);
    DH_HRCHECK_ABORT(hr, TEXT("Cabinet::put_IgnoreMissingFiles"));

ErrReturn:
    
    CleanupTStr(&ptszFullCabFileName);
    return hr;    
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenCabFile
//
//  Synopsis:   Append files to the cab file. However it has not written
//              anyting to the cab file yet
//
//  Arguments:  [pCab] --  pointer to the cab file
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT AppendFilesToCabFile(MPC::Cabinet* pCab)
{
    HRESULT hr           = S_OK;
    int     i            = 0;
    LPTSTR  ptszFileName = NULL;
    LPTSTR  ptszDSOnSys  = NULL;

    DH_VDATEPTRIN(pCab, MPC::Cabinet);

    //
    //  Add SR related registery settings
    //

	hr = GetSRRegInfo(TEXT("SR-Reg.TXT"));
	DH_HRCHECK_ABORT(hr, TEXT("GetSRRegInfo"));

	hr = pCab->AddFile(TEXT("SR-Reg.TXT"));
	DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile()"));

	//
	//  Add files based on WinDir relative root
	//
	
	for (i = 0; i < ARRAYSIZE(g_tszWindirFileCollection); i++)
	{
		hr = SrTstTStrCat(_tgetenv(TEXT("WINDIR")),
		                  g_tszWindirFileCollection[i],
		                  &ptszFileName);
		DH_HRCHECK_ABORT(hr, TEXT("SrTstTStrCat"));

		hr = pCab->AddFile(ptszFileName);
		DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile"));

		CleanupTStr(&ptszFileName);
	}

	//
	//  Parse the restore log and add it to the cab
	//

	hr = SrTstTStrCat(_tgetenv(TEXT("WINDIR")),
	                  g_tszWindirFileCollection[2],
	                  &ptszFileName);
	DH_HRCHECK_ABORT(hr, TEXT("SrTstTStrCat"));

    hr = ParseRstrLog(ptszFileName, TEXT("SR-RstrLog.TXT"));
    DH_HRCHECK_ABORT(hr, TEXT("ParseRstrLog"));
    
	hr = pCab->AddFile(TEXT("SR-RstrLog.TXT"));
	DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile"));

	CleanupTStr(&ptszFileName);

	//
	//  Get the restore directory on the system drive,
	//  and then Add in critial files
	//
	
	hr = GetDSOnSysVol(&ptszDSOnSys);
    DH_HRCHECK_ABORT(hr, TEXT("GetDSOnSysVol"));
    
	//
	//  Add files Bases on System Volume Information relative root
	//
	
	for (i = 0; i < ARRAYSIZE(g_tszSysVolFileCollection); i++)
	{
		hr = SrTstTStrCat(ptszDSOnSys,
		                  g_tszSysVolFileCollection[i],
		                  &ptszFileName);
		DH_HRCHECK_ABORT(hr, TEXT("SrTstTStrCat"));

		hr = pCab->AddFile(ptszFileName);
		DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile()"));

		CleanupTStr(&ptszFileName);
	}

	//
	//  Get the Restore point enumeration, and then cab the file
	//
	
	hr = RPEnumDrives(pCab, TEXT("SR-RP.LOG"));
	DH_HRCHECK_ABORT(hr, TEXT("RPEnumDrives"));

	hr = pCab->AddFile(TEXT("SR-RP.LOG"));
	DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile()"));

	//
	//  Get change logs
	//

	hr = GetChgLogOnDrives(TEXT("SR-ChgLog.LOG"));
	DH_HRCHECK_ABORT(hr, TEXT("GetChgLog"));

	hr = pCab->AddFile(TEXT("SR-ChgLog.LOG"));
	DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile()"));
	
	//
	//  Get file versions
	//

	hr = GetSRFileInfo(TEXT("SR-FileList.LOG"));
	DH_HRCHECK_ABORT(hr, TEXT("GetSRFileInfo"));

	hr = pCab->AddFile(TEXT("SR-FileList.LOG"));
	DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile()"));

	//
	//  Get SR related event logs
	//

	hr = GetSREvents(TEXT("SR-EventLogs.TXT"));
	DH_HRCHECK_ABORT(hr, TEXT("GetSREvents"));

	hr = pCab->AddFile(TEXT("SR-EventLogs.TXT"));
	DH_HRCHECK_ABORT(hr, TEXT("MPC::Cabinet::AddFile()"));


ErrReturn:
    CleanupTStr(&ptszFileName);
    CleanupTStr(&ptszDSOnSys);
    return hr;    
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupFiles
//
//  Synopsis:   Remove the temporary file used by srdiag
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    20-04-2001   weiyouc   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CleanupFiles()
{
    HRESULT hr = S_OK;

    DeleteFileW(L"SR-Reg.TXT");
    DeleteFileW(L"SR-RstrLog.TXT");
    DeleteFileW(L"SR-RP.LOG");
    DeleteFileW(L"SR-ChgLog.LOG");
    DeleteFileW(L"SR-FileList.LOG");
    DeleteFileW(L"SR-EventLogs.TXT");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\rpenum.cxx ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    RPEnum.cxx
 *
 *  Abstract:
 *    Tool for enumerating the restore points - forward/reverse
 *
 *  Revision History:
 *
 *    Brijesh Krishnaswami (brijeshk)  04/13/2000
 *        created
 *
 *	  Stephen Heffner (sheffner)
 *        I just copied this source, and using the existing API's so that
 *        srdiag will also be in sync as changes occur to the file
 *        structure.
 *
 *    Weiyou Cui    (weiyouc)   02-May-2001
 *        Rewritten
 *
 *****************************************************************************/

//+---------------------------------------------------------------------------
//
//	Common Includes
//
//----------------------------------------------------------------------------
#include "SrHeader.hxx"

#include <shellapi.h>
#include <enumlogs.h>

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#include "stdafx.h"
#include "srdiag.h"

//+---------------------------------------------------------------------------
//
//	Function proto types
//
//----------------------------------------------------------------------------

HRESULT GetSRGuid(LPTSTR* pptszSRGuid);

HRESULT GetRPLogsOnVolume(MPC::Cabinet* pCab,
                          LPTSTR        ptszLogFile,
                          LPTSTR        ptszVolume);

//+---------------------------------------------------------------------------
//
//	Simple Array's to say how to print the Months, Days
//
//----------------------------------------------------------------------------

LPCTSTR g_tszMonth[] = 
{
    TEXT("January"),
    TEXT("Feburary"),
    TEXT("March"),
    TEXT("April"),
    TEXT("May"),
    TEXT("June"),
    TEXT("July"),
    TEXT("August"),
    TEXT("September"),
    TEXT("October"),
    TEXT("November"),
    TEXT("December")
};

LPCTSTR g_tszDay[] =
{
    TEXT("Sunday"),
    TEXT("Monday"),
    TEXT("Tuesday"),
    TEXT("Wednesday"),
    TEXT("Thursday"),
    TEXT("Friday"),
    TEXT("Saturday")
};


//+---------------------------------------------------------------------------
//
//	Files to collect for each Restore Point, on all drives.
//
//----------------------------------------------------------------------------

LPCTSTR g_tszRPFileList[] =
{
    TEXT("restorepointsize"),
    TEXT("drivetable.txt"),
    TEXT("rp.log"),
};

//+---------------------------------------------------------------------------
//
//	Types of restorepoints, based off of Brijesh's code
//
//----------------------------------------------------------------------------

LPCTSTR g_tszRPDescrip[] =
{
    TEXT("APPLICATION_INSTALL"),
    TEXT("APPLICATION_UNINSTALL"),
    TEXT("DESKTOP_SETTING"),
    TEXT("ACCESSIBILITY_SETTING"),
    TEXT("OE_SETTING"),
    TEXT("APPLICATION_RUN"),
    TEXT("RESTORE"),
    TEXT("CHECKPOINT"),
    TEXT("WINDOWS_SHUTDOWN"),
    TEXT("WINDOWS_BOOT"),
    TEXT("DEVICE_DRIVER_CHANGE"),
    TEXT("FIRSTRUN"),
    TEXT("MODIFY_SETTINGS"),
    TEXT("CANCELLED_OPERATION")
};

//+---------------------------------------------------------------------------
//
//  Function:   RPEnumDrives
//
//  Synopsis:   Via the FindFirstVolume, and FindNext get all of the valid
//              volumes on the system. I then transulate this volume, to the
//              actual path and then pass that information to GetRPLogs which
//              gets the restore point logs.
//
//  Arguments:  [pCab]          -- pointer to the cabinet file
//              [ptszLogFile]	-- The name of the log file
//
//  Returns:    HRESULT
//
//  History:    02-May-2001
//
//
//----------------------------------------------------------------------------

HRESULT RPEnumDrives(MPC::Cabinet* pCab,
                     LPTSTR        ptszLogFile)
{
    HRESULT hr       = S_OK;
	DWORD   dwSize   = 0;
	HANDLE	hVolume  = INVALID_HANDLE_VALUE;
	BOOL    fOK      = FALSE;
	TCHAR   tszVolume[MAX_PATH];
    TCHAR   tszMount[MAX_PATH];

    DH_VDATEPTRIN(pCab, MPC::Cabinet);
    DH_VDATEPTRIN(ptszLogFile, TCHAR);

	hVolume = FindFirstVolume(tszVolume, MAX_PATH);
	if (INVALID_HANDLE_VALUE != hVolume) 
	{
		do
		{
			dwSize   = MAX_PATH;

			//
			//  Check to make sure that this is a fixed volume, and then
			//  get the change log, else skip.
			//
			
			if (DRIVE_FIXED == GetDriveType(tszVolume))
			{
				//
				//  First get the Friendly name for the current Volume, and get log
				//
				
				fOK = GetVolumePathNamesForVolumeName(tszVolume,
        				                              tszMount,
        				                              MAX_PATH,
        				                              &dwSize);
				DH_ABORTIF(!fOK,
				           HRESULT_FROM_WIN32(GetLastError()),
				           TEXT("GetVolumePathNamesForVolumeName"));
				
				hr = GetRPLogsOnVolume(pCab,
				                       ptszLogFile,
				                       tszMount);
				DH_HRCHECK_ABORT(hr, TEXT("GetRPLogsOnVolume"));
			}
		} while (FindNextVolume(hVolume, tszVolume, MAX_PATH));
	}

ErrReturn:

	if (INVALID_HANDLE_VALUE != hVolume)
    {
    	FindVolumeClose(hVolume);
    }

	return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRPLogsOnVolume
//
//  Synopsis:   This will enumerate the restore points on the volume path
//              that is provided, writting this information out to the logfile
//              specified.
//
//  Arguments:  [pCab]        -- Pointer to the cabinet object
//              [ptszLogFile] -- Log file name
//				[ptszVolume]  -- Path to the Volume for the restore point API
//                               to work.
//
//  Returns:    HRESULT
//
//  History:    02-May-2001     weiyouc     Created
//
//----------------------------------------------------------------------------

HRESULT GetRPLogsOnVolume(MPC::Cabinet* pCab,
                          LPTSTR        ptszLogFile,
                          LPTSTR        ptszVolume)
{
    HRESULT             hr         = S_OK;
	INT64				i64Size    = 0;
	int					iCount     = 0;
	LPTSTR				ptszSRGuid = NULL;
	FILE*				fpLogFile  = NULL;
	FILE*               fpRPLog    = NULL;
	FILETIME*			pFileTime  = NULL;
	RESTOREPOINTINFOW	pRpinfo;
	SYSTEMTIME			SysTime;
	TCHAR				tszString[MAX_PATH];
	TCHAR               tszSRFileName[MAX_PATH];
	TCHAR               tszFileNameInCab[MAX_PATH];
    CRestorePoint       RP;

    DH_VDATEPTRIN(pCab, MPC::Cabinet*);
    DH_VDATEPTRIN(ptszLogFile, TCHAR);
    DH_VDATEPTRIN(ptszVolume, TCHAR);
    
	//
	//  Initialization of the RestorePointEnum obejct
	//
	
	CRestorePointEnum   RPEnum(ptszVolume, TRUE, FALSE);

	//
	//  Get restore GUID
	//
	
	hr = GetSRGuid(&ptszSRGuid);
	DH_HRCHECK_ABORT(hr, TEXT("GetSRGuid"));
	
    //
    //  Open the log file for appending
    //

	fpLogFile = _tfopen(ptszLogFile, TEXT("a"));
    DH_ABORTIF(NULL == fpLogFile,
               E_FAIL,
               TEXT("_tfopen"));
    
	fprintf(fpLogFile, "\nProcessing Mount Point [%S]\n", ptszVolume);

	//
	//  If we have a valid restore point, enumerate through all of them and
	//  log the results.
	//
	
    if (ERROR_SUCCESS == RPEnum.FindFirstRestorePoint(RP))
    {
		do 
		{
			//Get RestorePoint Size for the restore point log.
			_stprintf(tszString,
			          TEXT("%sSystem Volume Information\\_restore%S\\%s\\restorepointsize"),
			          ptszVolume,
			          ptszSRGuid,
			          RP.GetDir());

			fpRPLog = _tfopen(tszString, TEXT("r"));
			if (NULL != fpRPLog)
			{
				fread(&i64Size, sizeof(INT64), 1, fpRPLog);
				fclose(fpRPLog);
			}
			else
			{
				i64Size=0;
			}

			//
			//  Get the time, and then convert it to localsystemtime,
			//  and then pump out the rest of the DataStructures
			//
			
			pFileTime = RP.GetTime();
			FileTimeToSystemTime(pFileTime, &SysTime);

			//
			//  format should be field=value, field=value, ...
			//
			
			fprintf(fpLogFile,
			        "DirectoryName=%S, "
			        "Size=%I64ld, "
			        "Type=%ld[%S], "
			        "RestorePointName=%S, "
			        "RestorePointStatus=%S, "
			        "Number=%ul, "
			        "Date=%S %S %lu, %lu %lu:%lu:%lu\n", 
					RP.GetDir(),
					i64Size,
					RP.GetType(),
					g_tszRPDescrip[RP.GetType()],
					RP.GetName(), 
					RP.IsDefunct() ? TEXT("[Cancelled]") : TEXT("[VALID]"),
					RP.GetNum(),
					g_tszDay[SysTime.wDayOfWeek],
					g_tszMonth[SysTime.wMonth - 1],
					SysTime.wDay,
					SysTime.wYear,
					SysTime.wHour,
					SysTime.wMinute,
					SysTime.wSecond);

			//
			//  Now append the files needed per restore point
            //
			
			for (iCount = 0; iCount < ARRAYSIZE(g_tszRPFileList); iCount++)
			{
			    //
			    //  figure out which file we need to cab
			    //
			    
            	_stprintf(tszSRFileName,
                 	      TEXT("%sSystem Volume Information\\_restore%s\\%s\\%s"),
                 	      ptszVolume,
                 	      ptszSRGuid,
                 	      RP.GetDir(),
                 	      g_tszRPFileList[iCount]);
                //
                //  generate a new name for this file in the cab
                //

                //
                //  we also need to replace ":\" with "--"
                //
                
            	_stprintf(tszFileNameInCab,
                 	      TEXT("%s"),
                 	      ptszVolume);

            	_stprintf((tszFileNameInCab + 1),
                 	      TEXT("--%s-%s"),
                 	      RP.GetDir(),
                 	      g_tszRPFileList[iCount]);

            	hr = pCab->AddFile(tszSRFileName, tszFileNameInCab);
            	DH_HRCHECK_ABORT(hr, TEXT("Cabinet::AddFile"));
				
				iCount++;
			}
		}   while (ERROR_SUCCESS == RPEnum.FindNextRestorePoint(RP));
		RPEnum.FindClose();
	}
	else
	{
        fprintf(fpLogFile,
                "No restore points for Mount Point [%S]\n",
                ptszVolume);
    }    

ErrReturn:
    if (NULL != fpLogFile)
    {
        fclose(fpLogFile);
    }
    if (NULL != fpRPLog)
    {
        fclose(fpRPLog);
    }
    CleanupTStr(&ptszSRGuid);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSRGuid
//
//  Synopsis:   Get SR GUID.
//
//  Arguments:  [pptszSRGuid] -- The returned SR GUID
//
//  Returns:    HRESULT
//
//  History:    02-May-2001
//
//
//----------------------------------------------------------------------------

HRESULT GetSRGuid(LPTSTR* pptszSRGuid)
{
    HRESULT hr       = S_OK;
	long    lResult  = 0;
	DWORD   dwType   = 0;
	DWORD   dwLength = MAX_PATH +1;
	HKEY    hKey     = NULL;
	TCHAR   tszGuidStr[MAX_PATH + 1];

    DH_VDATEPTROUT(pptszSRGuid, LPTSTR);

	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
	                       SR_CONFIG_REG_KEY,
	                       0,
	                       KEY_READ,
	                       &hKey);
	DH_ABORTIF(ERROR_SUCCESS != lResult,
	           E_FAIL,
	           TEXT("RegOpenKeyEx"));
	
	lResult = RegQueryValueEx(hKey,
	                          TEXT("MachineGuid"),
	                          NULL,
	                          &dwType,
	                          (unsigned char*) tszGuidStr,
	                          &dwLength);
	DH_ABORTIF(ERROR_SUCCESS != lResult,
	           E_FAIL,
	           TEXT("RegQueryValueEx"));


    hr = CopyString(tszGuidStr, pptszSRGuid);
    DH_HRCHECK_ABORT(hr, TEXT("CopyString"));
    
ErrReturn:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return hr;	
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDSOnSysVol
//
//  Synopsis:   Get the name of the data store on the system.
//
//  Arguments:  [pptszDsOnSys]	-- data store name
//
//  Returns:    HRESULT
//
//  History:    02-May-2001
//
//
//----------------------------------------------------------------------------

HRESULT GetDSOnSysVol(LPTSTR* pptszDsOnSys)
{
    HRESULT hr         = S_OK;
    LPTSTR  ptszSRGuid = NULL;
	TCHAR   tszDS[MAX_PATH + 1];

    DH_VDATEPTROUT(pptszDsOnSys, LPTSTR);

    hr = GetSRGuid(&ptszSRGuid);
    DH_HRCHECK_ABORT(hr, TEXT("GetSRGuid"));
    
    _stprintf(tszDS,
              TEXT("%s\\System Volume Information\\_Restore%s\\"),
              _tgetenv(TEXT("SYSTEMDRIVE")),
              ptszSRGuid);
    hr = CopyString(tszDS, pptszDsOnSys);
    DH_HRCHECK_ABORT(hr, TEXT("CopyString"));
    
ErrReturn:
    CleanupTStr(&ptszSRGuid);
    return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\restmap\reslist.h ===
#ifndef _RESLIST_H_
#define _RESLIST_H_

#include "srapi.h"

#define MAX_TEMP_FNAME 10

#define HEAP_ALLOC( size ) \
    HeapAlloc( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, size )

#define HEAP_REALLOC( p, size ) \
    HeapReAlloc( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, p, size )

#define HEAP_FREE( p ) \
    if (p) { HeapFree( GetProcessHeap(), 0, p ); p = NULL; }

#define STRCOPY(a,b) \
    if (b) { HEAP_FREE(a); a = (LPWSTR) HEAP_ALLOC(STRSIZE(b)); \
             if (a) memcpy(a, b, STRSIZE(b)); }

#define STRSIZE(pa) (lstrlen(pa) + 1) * sizeof(WCHAR)
        
//
// CNode : Stores node specific data
//

struct CNode 
{
	CNode * m_pNext;              // Pointer to the sibling node.
	CNode * m_pPrev;              // Pointer to Prev node.

    DWORD   m_dwOperation;        // Restore operation.
    DWORD   m_dwAttributes;       // Restore Attributes.
    LPWSTR  m_pszTemp;            // Temp File 
    BYTE*   m_pbAcl;              // acl data
    DWORD   m_cbAcl;              // acl data size
    BOOL    m_fAclInline;         // whether acl is inline or in file
    LPWSTR  m_pPath1;             // source path
    LPWSTR  m_pPath2;             // dest path on rename 
};


CNode * 
AllocateNode( 
    LPWSTR,
    LPWSTR);


VOID
FreeNode(
    CNode *);



class CRestoreList 
{
private:
    CNode * m_pListHead;
    CNode * m_pListTail;


public:
    CRestoreList::CRestoreList();
    CRestoreList::~CRestoreList();

    BOOL 
    GenerateRestoreMap( 
        HANDLE hFile
        );

	CNode * 
    AppendNode( 
        LPWSTR        pPath1,
        LPWSTR        pPath2);

    CNode *
    RemoveNode( 
        CNode * pNode
        );

    CNode *
    GetLastNode(
        LPWSTR        pPath,
        LPWSTR        pPath2,
        BOOL          fFailOnPrefixMatch
        );

    BOOL
    CopyNode(
        CNode * pSrc,
        CNode * pDes,
        BOOL    fReplacePPath2
        );

    BOOL
    CheckIntegrity(   
        LPWSTR pszDrive,
        DWORD  dwOpr,
        DWORD  dwAttr,
        DWORD  dwFlags,
        LPWSTR pTmpFile,
        LPWSTR pPath1,
        LPWSTR pPath2,
        BYTE * pbAcl,
        DWORD  cbAcl,
        BOOL   fAclInline);
    
    BOOL
    AddMergeElement( 
        LPWSTR  pszDrive,
        DWORD   dwOpr,
        DWORD   dwAttr,
        DWORD   dwFlags,
        LPWSTR  pTmpFile,
        LPWSTR  pPath1,
        LPWSTR  pPath2,
        BYTE *  pbAcl,
        DWORD   cbAcl,
        BOOL    fAclInline);

    BOOL 
    CreateRestoreNode( 
        CNode   *pNode, 
        DWORD   dwOpr, 
        DWORD   dwAttr,
        DWORD   dwFlags,
        LPWSTR  pTmpFile,
        LPWSTR  pPath1,
        LPWSTR  pPath2,
        BYTE *  pbAcl,
        DWORD   cbAcl,
        BOOL    fAclInline);

	BOOL 
    MergeRestoreNode( 
        CNode   *pNode, 
        DWORD   dwOpr, 
        DWORD   dwAttr,
        DWORD   dwFlags,
        LPWSTR  pTmpFile,
        LPWSTR  pPath1,
        LPWSTR  pPath2,
        BYTE *  pbAcl,
        DWORD   cbAcl,
        BOOL    fAclInline);

    BOOL
    GenerateRenameEntry(
        CNode    * pNode ,
        HANDLE     hFile
    );

    BOOL
    GenerateOperation(
        CNode    * pNode ,
        HANDLE     hFile
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\tstparam.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       tstparam.cxx
//
//  Synopsys:   Test paramers container class implementation
//
//  Classes:    CTestParams, CParamNode
//
//  Notes:      The test parameter containers provide a layer of abstraction
//              above the particular ways to pass test parameters -
//              (command line, environment, registry...)
//
//  History:    10-Sep-1998  georgis  created
//
//---------------------------------------------------------------------------
#include "srheader.hxx"
#include <tstparam.hxx>

// Private macros to avoid some easy mistakes
#define RETURN(x) hr=x; goto ErrReturn;

#define ENTER_SYNC                      \
    EnterCriticalSection(&m_sync);      \
    bEnterSync=TRUE;                    \
    if (!m_bUsed)                       \
    {                                   \
        m_bUsed=TRUE;                   \
        hr=NotifyOnFirstUse();          \
        if (S_OK!=hr)                   \
        {                               \
            RETURN(hr);                 \
        }                               \
    }


#define LEAVE_SYNC                      \
    if (bEnterSync)                     \
    {                                   \
        LeaveCriticalSection(&m_sync);  \
    }



//+--------------------------------------------------------------------------
//
//  Function:   CalculateHashValue
//
//  Synopsys:   Calculates hash value for asciiz string
//              (case insensitive)
//
//  Parameters: pszName: the string
//
//  Returns:    the hash value (the first 4 characters are used)
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
DWORD CalculateHashValue(LPCWSTR pwszName)
{
    DH_ASSERT(NULL!=pwszName);
    DWORD dwLen=(DWORD)wcslen(pwszName);
    DWORD dwTemp=0;
    for (DWORD dwIndex=0; dwIndex<2; dwIndex++)
    {
        dwTemp<<=16;
        if (dwIndex<dwLen)
        {
            dwTemp|=towlower(pwszName[dwIndex]);
        }
    }
    return dwTemp;
};


//+--------------------------------------------------------------------------
//
//  Function:   Unicode2Escaped
//
//  Synopsys:   Converts Unicode string to escaped ascii string
//
//  Parameters: [in]  pwszString:   the source unicode string
//              [out] ppszString:   return the ptr to escaped ascii string here
//              [in]  dwEscapeMode: Escape mode
//
//  History:    10-Nov-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT Unicode2Escaped(
    LPCWSTR pwszString,
    char ** ppszString,
    DWORD dwEscapeMode)
{
    HRESULT hr=S_OK;
    char *  pszEscaped=NULL;
    char *  pszDest=NULL;
    LPCWSTR  pwszSrc=NULL;
    DWORD   dwSize=0;
    BOOL    bNeedEscape=FALSE;

    DH_VDATEPTROUT(ppszString,LPSTR);
    *ppszString=NULL;

    // if NULL passed, just return NULL
    if (NULL==pwszString)
    {
        return S_OK;
    }

    // Count the size needed for the escaped string
    dwSize=0;

    for (pwszSrc=pwszString; 0!=*pwszSrc; pwszSrc++)
    {
        if (ESCAPE_NOTNEEDED(*pwszSrc))
        {
            dwSize++;
        }
        else
        {
            bNeedEscape=TRUE;
            dwSize+=5; // $xxxx format
        }
    }

    // Allocate memory for the escaped string
    // Eventually put the prefix
    if ((ESCAPEMODE_PREFIX_ALWAYS==dwEscapeMode)||
        (ESCAPEMODE_PREFIX_IFCHANGED==dwEscapeMode)&&bNeedEscape)
    {
        pszEscaped=new char [dwSize+2]; // the ESCAPED_MARKER and ending 0
        DH_ABORTIF(NULL==pszEscaped,E_OUTOFMEMORY,TEXT("new"));

        pszDest=pszEscaped;
        *pszDest++=ESCAPED_MARKER;
    }
    else
    {
        pszEscaped=new char [dwSize+1]; // ending 0
        DH_ABORTIF(NULL==pszEscaped,E_OUTOFMEMORY,TEXT("new"));
        pszDest=pszEscaped;
    }

    // Translate
    for (pwszSrc=pwszString; 0!=*pwszSrc; pwszSrc++)
    {
        if (ESCAPE_NOTNEEDED(*pwszSrc))
        {
            *pszDest++=(char)*pwszSrc;
        }
        else
        {
            *pszDest++=ESCAPE_CHARACTER;
            sprintf(pszDest,"%04x",*pwszSrc);
            pszDest+=4;
        }
    }
    *pszDest=0;

ErrReturn:
    if (S_OK==hr)
    {
        *ppszString=pszEscaped;
    }
    else
    {
        delete pszEscaped;
    }
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   Unicode2Escaped     (unicode->unicode)
//
//  Synopsys:   Converts Unicode string to escaped ascii string
//
//  Parameters: [in]  pwszString:   the source unicode string
//              [out] ppwszString:   return the ptr to escaped ascii string here
//              [in]  dwEscapeMode: Escape mode
//
//  History:    10-Nov-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT Unicode2Escaped(
    LPCWSTR pwszString,
    LPWSTR* ppwszString,
    DWORD dwEscapeMode)
{
    HRESULT hr=S_OK;
    char *  pszEscaped=NULL;

    DH_VDATEPTROUT(ppwszString,LPWSTR);

    hr=Unicode2Escaped(pwszString,&pszEscaped,dwEscapeMode);

    if ((S_OK==hr)&&(NULL!=pszEscaped))
    {
        hr=CopyString(pszEscaped,ppwszString);
    }
    else
    {
        *ppwszString=NULL;
    }
    delete pszEscaped;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   Escaped2Unicode
//
//  Synopsys:   Converts Unicode string to escaped ascii string
//
//  Parameters: [in]  pszEscaped:   the source escaped ascii string
//              [out] ppwszString:  return the ptr to unescaped unicode string
//              [in]  dwEscapeMode: escape mode
//
//  History:    10-Nov-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT Escaped2Unicode(
    const char * pszEscaped,
    LPWSTR *ppwszString,
    DWORD dwEscapeMode)
{
    HRESULT hr=S_OK;
    LPWSTR  pwszDest=NULL;
    LPWSTR  pwszUnescaped=NULL;
    const   char *  pszSrc=NULL;
    DWORD   dwSize=0;
    int     iTemp=0;

    DH_VDATEPTROUT(ppwszString,LPWSTR);
    *ppwszString=NULL;

    // if NULL passed, just return NULL
    if (NULL==pszEscaped)
    {
        return S_OK;
    }

    // Check for the escaped string marker
    switch (dwEscapeMode)
    {
    case ESCAPEMODE_PREFIX_ALWAYS:
        DH_ABORTIF(ESCAPED_MARKER!=*pszEscaped,E_UNEXPECTED,
            TEXT("Bad escaped source string"));
        pszEscaped++;
        break;
    case ESCAPEMODE_PREFIX_IFCHANGED:
        if (ESCAPED_MARKER==*pszEscaped)
        {
            pszEscaped++;
        }
        break;
    case ESCAPEMODE_PREFIX_NEVER:
        break;
    default:
        hr=E_INVALIDARG;
        DH_HRCHECK_ABORT(hr,TEXT("Bad escape mode"));
    }

    // Count the size needed for the escaped string
    dwSize=0;
    for (pszSrc=pszEscaped; 0!=*pszSrc; pszSrc++)
    {
        if (ESCAPE_CHARACTER==*pszSrc)
        {
            pszSrc+=4;
        }
        else
        {
            DH_ABORTIF(!ESCAPE_NOTNEEDED(*pszSrc),E_UNEXPECTED,
                TEXT("Bad symbol in the escaped string"));
        }
        dwSize++;
    }

    // Allocate memory for the unescaped string
    pwszUnescaped=new WCHAR [dwSize+1];
    DH_ABORTIF(NULL==pwszUnescaped,E_OUTOFMEMORY,TEXT("new"));

    // Translate
    pwszDest=pwszUnescaped;

    for (pszSrc=pszEscaped; 0!=*pszSrc; pwszDest++)
    {
        if (ESCAPE_CHARACTER==*pszSrc)
        {
            pszSrc++;
            // sscanf can read hex, but the output buffer must be
            // unsigned integer of the default int size, which is more
            // then sizeof(wchar)
            sscanf(pszSrc,"%04x",&iTemp);
            *pwszDest=(WCHAR)iTemp;
            pszSrc+=4;
        }
        else
        {
            *pwszDest=(WCHAR)*pszSrc++;
        }
    }
    *pwszDest=0;

ErrReturn:
    if (S_OK==hr)
    {
        *ppwszString=pwszUnescaped;
    }
    else
    {
        delete pwszUnescaped;
    }
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   Escaped2Unicode (unicode->unicode)
//
//  Synopsys:   Converts Unicode string to escaped ascii string
//
//  Parameters: [in]  pwszEscaped:  the source escaped string (unicode)
//              [out] ppwszString:  return the ptr to unescaped unicode string
//              [in]  dwEscapeMode: escape mode
//
//  History:    10-Nov-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT Escaped2Unicode(
    LPCWSTR pwszEscaped,
    LPWSTR *ppwszString,
    DWORD dwEscapeMode)
{
    HRESULT hr=S_OK;
    char    *pszTemp=NULL;

    DH_VDATEPTROUT(ppwszString,LPWSTR);

    if (NULL!=pwszEscaped)
    {
        hr=CopyString(pwszEscaped,&pszTemp);
    }
    if (S_OK==hr)
    {
        hr=Escaped2Unicode(pszTemp,ppwszString,dwEscapeMode);
    }
    else
    {
        *ppwszString=NULL;
    }
    delete pszTemp;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Constructor: CParamNode::CParamNode
//
//  Synopsys:   Initializes the parameter node as empty
//
//  Arguments:  dwFlags: General param info : source,priority,used
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
CParamNode::CParamNode(DWORD dwFlags)
{
    m_dwFlags=dwFlags;
    m_pwszName=NULL;
    m_pwszValue=NULL;
    m_pNext=NULL;
}


//+--------------------------------------------------------------------------
//
//  Destructor: CParamNode::~CParamNode
//
//  Synopsys:   Releases the resources used by the parameter node
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
CParamNode::~CParamNode()
{
    delete m_pwszName;
    delete m_pwszValue;
}


//+--------------------------------------------------------------------------
//
//  Method:     CParamNode::Init
//
//  Synopsys:   Allocates memory for parameter Name and Value
//
//  Parameters: pszName:  the parameter name
//              pszValue: the parameter value
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CParamNode::Init(LPCWSTR pwszName, LPCWSTR pwszValue)
{
    HRESULT hr=S_OK;
    DH_ASSERT(NULL!=pwszName);
    DH_ASSERT(NULL==m_pwszName); // ensure the object is empty

    hr=CopyString(pwszName,&m_pwszName);
    if (S_OK==hr)
    {
        m_dwHashValue=CalculateHashValue(pwszName);
        if (NULL!=pwszValue)
        {
            hr=CopyString(pwszValue,&m_pwszValue);
        }
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Method:     CParamNode::ChangeValue
//
//  Synopsys:   Changes the parameter value
//
//  Parameters: pszValue: the parameter value
//              dwFlags:  parameter info (source,usage,priority)
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CParamNode::ChangeValue(LPCWSTR pwszValue, DWORD dwFlags)
{
    HRESULT hr=S_OK;

    DH_ASSERT(dwFlags>0);

    // Ensure we don't override used parameters unless asked
    if (PARAMMASK_USAGE & m_dwFlags)
    {
        if ((dwFlags & PARAMFLAG_OVERRIDEUSED)&&
            !(PARAMMASK_USAGE & (m_dwFlags & ~dwFlags)))
        {
            RETURN(E_ACCESSDENIED); // Can't override this type of usage
        }
    }

    // Ensure we don't override higher priority parameters
    if ((dwFlags & PARAMMASK_PRIORITY) < (m_dwFlags & PARAMMASK_PRIORITY))
    {
        if (dwFlags & PARAMFLAG_MUSTSET)
        {
            RETURN(E_ACCESSDENIED);
        }
        else
        {
            RETURN(S_OK);
        }
    }

    m_dwFlags=dwFlags;
    delete m_pwszValue;
    m_pwszValue=NULL;

    if (NULL!=pwszValue)
    {
        hr=CopyString(pwszValue,&m_pwszValue);
    }

ErrReturn:
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Constructor: CTestParams::CTestParams (public)
//
//  Synopsys:   Initializes the parameter container as empty
//
//  History:    10-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
CTestParams::CTestParams()
{
    m_pParamsList=NULL;
    m_dwUsageInfo=PARAMUSAGE_GENERAL;
    m_bUsed=FALSE;
    InitializeCriticalSection(&m_sync);
}


//+--------------------------------------------------------------------------
//
//  Destructor: CTestParams::~CTestParams (public)
//
//  Synopsys:   Releases the resources used by the parameter container object
//
//  History:    15-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
CTestParams::~CTestParams()
{
    EnterCriticalSection(&m_sync);

    CParamNode *pNext=NULL;
    for (CParamNode *pNode=m_pParamsList;
         NULL!=pNode;
         pNode=pNext)
    {
        pNext=pNode->m_pNext;
        delete pNode;
    }
    DeleteCriticalSection(&m_sync);
}




//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetParam (public, synchronized)
//
//  Synopsys:   Reads parameter of given name:format
//
//  Arguments:  pszName:    The parameter definition string
//              pTarget: the addres of the variable which receives the result
//
//  Returns:    S_OK on success,
//              S_FALSE if the parameter is not present,
//              E_FAIL  if the format given is incompatible with the param value
//              or HRESULT error code (E_INVALIDARG, E_OUTOFMEMORY)
//
//  Notes:      The parameter definition string must be in format name:format
//              where name is the name which identyfies the parameter and
//              format shows how to read this parameter.
//                  E.g. "my_int:%i"
//
//              Formats may be of two types:
//              1) Any standard sscanf formats starting with %
//                    E.g. %i %u %d %lx %s ...
//
//              2) Custom formats
//                    bool - read BOOL (*pTarget is BOOL)
//                    cstr - read constant string (*pTarget is const char*)
//                    astr - heap allocated ascii string (*pTarget is char*)
//                    tstr - heap allocated TCHAR string (*pTarget is LPTSTR)
//                    olestr - heap allocated OLESTR string (*pTarget is LPOLESTR)
//
//                 For the heap allocated formats the string obtained is writable,
//                 and the caller is responsible for deleting it.
//
//  History:    09-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::GetParam(const char *pszName, void* pTarget)
{
    HRESULT     hr=S_OK;
    BOOL        bEnterSync=FALSE;
    LPWSTR      pwszTemp=NULL;
    LPWSTR      pwszFormat=NULL;
    CParamNode  *pPrev=NULL; // not used
    CParamNode  *pNode=NULL;

    if ((NULL==pszName)||(NULL==pTarget))
    {
        RETURN(E_INVALIDARG);
    }

    hr=CopyString(pszName,&pwszTemp);
    if (S_OK!=hr)
    {
        RETURN(hr);
    }
    pwszFormat=wcschr(pwszTemp,L':');

    if (NULL==pwszFormat)
    {
        RETURN(E_INVALIDARG);
    }

    *pwszFormat++=0;

    ENTER_SYNC;
    pNode=FindParam(pwszTemp,&pPrev);

    // for BOOL we always succed, eventyally seting the parameter
    // to FALSE if the switch is not found or has value "FALSE"
    if (!_wcsicmp(PARAMFMT_BOOL,pwszFormat))
    {
        if ((NULL!=pNode)&&
            ((NULL==pNode->m_pwszValue)||_wcsicmp(L"FALSE",pNode->m_pwszValue)))
        {
            *(BOOL*)pTarget=TRUE;
            pNode->MarkAsUsed(m_dwUsageInfo);
        }
        else
        {
            *(BOOL*)pTarget=FALSE;
        }
        RETURN(S_OK);
    }

    if (NULL==pNode)
    {
        RETURN(S_FALSE); // Not found
    }
    else
    {
        pNode->MarkAsUsed(m_dwUsageInfo);
    }

    // Process standard sscanf formats
    if (L'%'==*pwszFormat)
    {
        if (NULL==pNode->m_pwszValue)
        {
            RETURN(E_FAIL); // Found, but has no value
        }
        if (0<swscanf(pNode->m_pwszValue,pwszFormat,pTarget))
        {
            RETURN(S_OK);
        }
        else
        {
            RETURN(E_FAIL); // sscanf failed - incompatible format
        }
    }
    else // custom format
    {
        hr=GetCustomFmtParam(pwszFormat,pNode->m_pwszValue,pTarget);
        RETURN(hr);
    }

ErrReturn:
    LEAVE_SYNC;
    delete pwszTemp;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetCustomFmtParam (private)
//
//  Synopsys:   Extracts custom format parameter
//
//  Arguments:  pszFormat: The custom format.
//              pszValue:  The value as string
//              pTarget:   the addres of the variable which receives the result
//
//  Custom formats:
//              cstr - read constant string (*pTarget is const char*)
//              astr - heap allocated ascii string (*pTarget is char*)
//              tstr - heap allocated TCHAR string (*pTarget is LPTSTR)
//              olestr - heap allocated OLESTR string (*pTarget is LPOLESTR)
//
//
//  History:    10-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::GetCustomFmtParam(LPCWSTR pwszFormat, LPCWSTR pwszValue, void* pTarget)
{
    HRESULT hr=S_OK;
    DH_ASSERT(NULL!=pwszFormat);
    DH_ASSERT(NULL!=pTarget);

    // ASCII, allocated in heap
    if (!wcscmp(PARAMFMT_ASTR,pwszFormat))
    {
        if (NULL!=pwszValue)
        {
            hr=CopyString(pwszValue,(char**)pTarget);
            RETURN(hr);
        }
        else
        {
            *(char**)pTarget=NULL;
            RETURN(E_FAIL);
        }
    }

    // TSTR allocated in heap
    if (!wcscmp(PARAMFMT_TSTR,pwszFormat))
    {
        if (NULL!=pwszValue)
        {
            hr=CopyString(pwszValue,(LPTSTR*)pTarget);
            RETURN(hr);
        }
        else
        {
            *(LPTSTR*)pTarget=NULL;
            RETURN(E_FAIL);
        }
    }

    // OLESTR allocated in heap
    if (!wcscmp(PARAMFMT_OLESTR,pwszFormat))
    {
        if (NULL!=pwszValue)
        {
            hr=CopyString(pwszValue,(LPOLESTR*)pTarget);
            RETURN(hr);
        }
        else
        {
            *(LPOLESTR*)pTarget=NULL;
            RETURN(E_FAIL);
        }
    }
    // Unknown type
    hr=E_FAIL;

ErrReturn:
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::IsPresent (public, synchronized)
//
//  Synopsys:   Retruns TRUE if the parameter is present
//              and FALSE if not or error occurs
//
//  Arguments:  pszName:    The parameter definition string
//
//  Note:       The preferred way to handle BOOL parameters is
//              using GETPARAM*("name:bool"), which enables parameters
//              to be overwriten by cmd line e.g.
//                  registry: REG_SZ myparam (existing, value do not matter)
//                  cmdline:  /myparam:false
//              The result of GETPARAM("myparam:bool") is FALSE,
//              while IsPresent("myparam") will return TRUE,
//              with or without cmdline switch /myparam:false
//
//  History:    19-Oct-1998   georgis       Created
//
//---------------------------------------------------------------------------
BOOL __cdecl CTestParams::IsPresent(const char *pszName, ...)
{
    HRESULT     hr=S_OK;
    BOOL        bEnterSync=FALSE;
    LPWSTR      pwszTemp=NULL;
    LPWSTR      pwszFormat=NULL;
    CParamNode *pPrev=NULL; // not used
    CParamNode *pNode=NULL;

    if (NULL==pszName)
    {
        return FALSE;
    }

    // if the param definition string contains format,
    // extract name only
    if (S_OK!=CopyString(pszName,&pwszTemp))
    {
        return FALSE;
    }

    pwszFormat=wcschr(pwszTemp,L':');
    if (NULL!=pwszFormat)
    {
        *pwszFormat=0;
    }

    ENTER_SYNC;
    pNode=FindParam(pwszTemp,&pPrev);

ErrReturn:
    LEAVE_SYNC;
    delete pwszTemp;
    return (NULL!=pNode);
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::SetParam (public)
//
//  Synopsys:   Sets the parameter of given name:format
//
//  Arguments:  pszName: The parameter definition string
//              pTarget: the addres of the variable containig the param value
//
//  Returns:    S_OK on success,
//              E_FAIL  if the format given is incompatible with the param value
//              or HRESULT error code (E_INVALIDARG, E_OUTOFMEMORY)
//
//  Notes:      The parameter definition string must be in format name:format
//              where name is the name which identyfies the parameter and
//              format shows how to read this parameter.
//                  E.g. "my_string:cstr"
//
//              Formats may be of two types:
//              1) Standard sscanf formats
//                 Only formats
//                      %s %d %i %x %ld %lx %u %lu %ld, and %I64* are supported
//
//              2) Custom formats
//                    bool - read BOOL (*pTarget is BOOL)
//                    cstr - read constant string (*pTarget is const char*)
//                    astr - heap allocated ascii string (*pTarget is char*)
//                    tstr - heap allocated TCHAR string (*pTarget is LPTSTR)
//                    olestr - heap allocated OLESTR string (*pTarget is LPOLESTR)
//
//                 For the heap allocated formats the string obtained is writable,
//                 and the caller is responsible for deleting it.
//
//  History:    17-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::SetParam(const char *pszName, void* pTarget, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    LPWSTR pwszTempName=NULL;
    LPWSTR pwszFormat=NULL;

    if ((NULL==pszName)||(NULL==pTarget)||
        (0==(PARAMMASK_SOURCE & dwFlags)))
    {
        RETURN(E_INVALIDARG);
    }

    hr=CopyString((char*)pszName,&pwszTempName);
    if (S_OK!=hr)
    {
        RETURN(hr);
    }
    pwszFormat=wcschr(pwszTempName,L':');

    if (NULL==pwszFormat)
    {
        RETURN(E_INVALIDARG);
    }

    *pwszFormat++=0;
    hr=SetCustomFmtParam(pwszTempName,pwszFormat,pTarget,dwFlags);

ErrReturn:
    delete pwszTempName;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::SetCustomFmtParam (private)
//
//  Synopsys:   Adds custom format parameter
//
//  Arguments:  pszName:   The parameter name
//              pszFormat: The custom format.
//              pTarget:   the addres of the variable which contains the value
//
//  Custom formats:
//              bool        - BOOL (*pTarget is BOOL)
//              cstr        - ascii string (*pTarget is char*)
//              tstr        - TCHAR string (*pTarget is LPTSTR)
//              olestr      - OLESTR string (*pTarget is LPOLESTR)
//
//
//  History:    17-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::SetCustomFmtParam(
    LPCWSTR pwszName,
    LPCWSTR pwszFormat,
    void* pTarget,
    DWORD dwFlags)
{
    HRESULT hr=S_OK;
    DH_ASSERT(NULL!=pwszName);
    DH_ASSERT(NULL!=pwszFormat);
    DH_ASSERT(NULL!=pTarget);
    DH_ASSERT((PARAMMASK_SOURCE & dwFlags)>0);
    LPWSTR pwszTempValue=NULL;
    WCHAR  wszTemp[21]; // enough to print even 64bit integers

    // BOOL
    if (!wcscmp(PARAMFMT_BOOL,pwszFormat))
    {
        if (*(BOOL*)pTarget)
        {
            hr=AddParam(pwszName,NULL,dwFlags);
            RETURN(hr);
        }
        else
        {
            hr=AddParam(pwszName,L"FALSE",dwFlags);
            RETURN(hr);
        }
    }

    // Int
    if (!_wcsicmp(L"%i",pwszFormat)||
        !_wcsicmp(L"%d",pwszFormat)||
        !_wcsicmp(L"%u",pwszFormat)||
        !_wcsicmp(L"%lu",pwszFormat)||
        !_wcsicmp(L"%lx",pwszFormat)||
        !_wcsicmp(L"%ld",pwszFormat)||
        !_wcsicmp(L"%x",pwszFormat))
    {
        if (1>swprintf(wszTemp,pwszFormat,*(long*)pTarget))
        {
            RETURN(E_FAIL);
        }
        hr=AddParam(pwszName,wszTemp,dwFlags);
        RETURN(hr);
    }

    // I64 values
    if (!_wcsnicmp(L"%I64",pwszFormat,4))
    {
        if (1>swprintf(wszTemp,pwszFormat,*(ULONGLONG*)pTarget))
        {
            RETURN(E_FAIL);
        }
        hr=AddParam(pwszName,wszTemp,dwFlags);
        RETURN(hr);
    }

    // CONST ASCII - just pass the pszValue as pointer
    if (!_wcsicmp(L"%s",pwszFormat))
    {
        hr=AddParam(pwszName,(LPCWSTR)pTarget,dwFlags);
        RETURN(hr);
    }

    // ASTR
    if (!wcscmp(PARAMFMT_ASTR,pwszFormat))
    {
        if (NULL!=*(char*)pTarget)
        {
            hr=CopyString((char*)pTarget,&pwszTempValue);
        }
        if (S_OK==hr)
        {
            hr=AddParam(pwszName,pwszTempValue,dwFlags);
        }
        RETURN(hr);
    }

    // TSTR
    if (!wcscmp(PARAMFMT_TSTR,pwszFormat))
    {
        if (NULL!=*(LPTSTR*)pTarget)
        {
            hr=CopyString((LPTSTR)pTarget,&pwszTempValue);
        }
        if (S_OK==hr)
        {
            hr=AddParam(pwszName,pwszTempValue,dwFlags);
        }
        RETURN(hr);
    }

    // OLESTR
    if (!_wcsicmp(PARAMFMT_OLESTR,pwszFormat))
    {
        if (NULL!=*(LPOLESTR*)pTarget)
        {
            hr=CopyString((LPOLESTR)pTarget,&pwszTempValue);
        }
        if (S_OK==hr)
        {
            hr=AddParam(pwszName,pwszTempValue,dwFlags);
        }
        RETURN(hr);
    }
    // Unknown type
    hr=E_INVALIDARG;

ErrReturn:
    delete pwszTempValue;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::FindParam (private)
//
//  Synopsys:   Finds given parameter in the list
//
//  Arguments:  pszName: Parameter name
//              ppPrev:  if not NULL, retrun the previous node here on success
//
//  Returns:    Pointer to the parmeter node
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
CParamNode* CTestParams::FindParam(LPCWSTR pwszName, CParamNode** ppPrev)
{
    CParamNode *pNode=NULL;
    DH_ASSERT(NULL!=pwszName);
    DH_ASSERT(NULL!=ppPrev);

    DWORD dwHashValue=CalculateHashValue(pwszName);

    for (pNode=m_pParamsList;
        NULL!=pNode;
        *ppPrev=pNode, pNode=pNode->m_pNext)
    {
        if (dwHashValue>pNode->m_dwHashValue)
        {
            continue;
        }
        else if (dwHashValue<pNode->m_dwHashValue)
        {
            return NULL;
        }
        else // Equal hash values
        {
            int i=_wcsicmp(pwszName,pNode->m_pwszName);
            if (i>0)
            {
                continue;
            }
            else if (i<0)
            {
                return NULL;
            }
            else
            {
                return pNode;
            }
        }
    }
    return NULL;
};



//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::AddParam (public, synchronized)
//
//  Synopsys:   Adds a parameter to the container
//
//  Arguments:  pszName:  The parameter name
//              pszValue: The parameter value as string
//              dwFlags:  Param info (source,priority,usage)
//
//  Returns:    S_OK on success,
//              or HRESULT error code (E_INVALIDARG, E_OUTOFMEMORY)
//
//  History:    29-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::AddParam(
    LPCWSTR pwszName,
    LPCWSTR pwszValue,
    DWORD   dwFlags,
    BOOL    bWasQuoted)
{
    HRESULT hr=S_OK;
    BOOL bEnterSync=FALSE;
    CParamNode *pPrev=NULL;
    CParamNode *pParam=NULL;
    LPWSTR     pwszTemp=NULL;

    if ((NULL==pwszName)||(0==(PARAMMASK_SOURCE & dwFlags)))
    {
        RETURN(E_INVALIDARG);
    }

    if ((NULL!=pwszValue)&&
        (ESCAPED_MARKER==*pwszValue)&&
        (!bWasQuoted))
    {
        hr=Escaped2Unicode(pwszValue,&pwszTemp,ESCAPEMODE_PREFIX_ALWAYS);
        if (S_OK!=hr)
        {
            RETURN(hr);
        }
        pwszValue=pwszTemp;
    }

    ENTER_SYNC;
    pParam=FindParam(pwszName,&pPrev);

    if (NULL!=pParam) // The parameter is known => try to change the value
    {
        hr=pParam->ChangeValue(pwszValue,dwFlags);
        RETURN(hr);
    }
    else // new parameter
    {
        // Create and initialize new parameter node
        pParam=new CParamNode(dwFlags);
        if (NULL==pParam)
        {
            RETURN(E_OUTOFMEMORY);
        }
        hr=pParam->Init(pwszName,pwszValue);
        if (S_OK!=hr)
        {
            RETURN(hr);
        }
        // Insert in the list
        if (NULL==pPrev)
        {
            // Add as first node
            pParam->m_pNext=m_pParamsList;
            m_pParamsList=pParam;
        }
        else
        {
            // Add after pPrev
            pParam->m_pNext=pPrev->m_pNext;
            pPrev->m_pNext=pParam;
        }
        RETURN(S_OK);
    }

ErrReturn:
    if (S_OK!=hr)
    {
        delete pParam;
    }
    else // Mark the repro info params as used
    {
        if (PARAMFLAG_REPROINFO & dwFlags)
        {
            pParam->MarkAsUsed(dwFlags);
        }
    }
    LEAVE_SYNC;
    delete pwszTemp;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::DeleteParam (public, synchronized)
//
//  Synopsys:   Deletes given arameter from the string table
//
//  Arguments:  pszName: Parameter name
//
//  Returns:    S_OK if the param was not found or successifully deleted
//              or E_INVALIDARG
//
//  Notes:      Deleting parmeters do not cause reallocation of
//              the string table to smaller size.
//
//  History:    10-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::DeleteParam(const char *pszName)
{
    HRESULT     hr=S_OK;
    BOOL        bEnterSync=FALSE;
    CParamNode  *pPrev=NULL;
    CParamNode  *pParam=NULL;
    LPWSTR      pwszName=NULL;

    if (NULL==pszName)
    {
        RETURN(E_INVALIDARG);
    }

    hr=CopyString(pszName,&pwszName);
    if (S_OK!=hr)
    {
        RETURN(hr);
    }

    ENTER_SYNC;
    pParam=FindParam(pwszName, &pPrev);

    if (NULL==pParam)
    {
        RETURN(S_OK); // the param is not present anyway
    }
    if (NULL==pPrev)
    {
        DH_ASSERT(m_pParamsList==pParam);
        m_pParamsList=pParam->m_pNext;
    }
    else
    {
        pPrev->m_pNext=pParam->m_pNext;
    }

ErrReturn:
    delete pParam;
    delete pwszName;
    LEAVE_SYNC;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::ReadCommandLine (public)
//
//  Synopsys:   Reads all the swithes from the command line
//              to the parameter container.
//
//  Parameters: pszCommandLine: the command line
//                              or NULL => use GetCommandLine()
//
//  Returns:    S_OK on success or E_OUTOFMEMORY
//
//  History:    10-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::ReadCommandLine(LPCTSTR ptszCommandLine, DWORD dwFlags)
{
    LPWSTR pwszCmdLine=NULL;
    LPWSTR pwszName=NULL;
    LPWSTR pwszValue=NULL;
    LPWSTR pwszEnd=NULL;
    HRESULT hr=S_OK;
    BOOL    bQuoted=FALSE;

    // If the ptszCommandLine is not given use GetCommandLine
    if (NULL!=ptszCommandLine)
    {
        hr=CopyString(ptszCommandLine,&pwszCmdLine);
        if(S_OK!=hr)
        {
            RETURN(hr);
        }
    }
    else
    {
        hr=CopyString(GetCommandLine(),&pwszCmdLine);
        if(S_OK!=hr)
        {
            RETURN(hr);
        }
    }

    // Loop for command line switches
    pwszName=pwszCmdLine;
    while ((NULL!=pwszName)&&(0!=*pwszName))
    {
        bQuoted=FALSE;

        // Find switch begining with /
        while ((0!=*pwszName)&&('/'!=*pwszName))
        {
            pwszName++;
        }
        if (0==*pwszName)
        {
            RETURN(S_OK);
        }

        // Find switch value
        pwszValue=++pwszName;
        while ((0!=*pwszValue)&&(' '!=*pwszValue)&&(':'!=*pwszValue))
        {
            pwszValue++;
        }
        switch (*pwszValue)
        {
        case 0: // we hit the end
            pwszEnd=NULL;
            pwszValue=NULL;
            break;
        case ' ': // parameter has no value
            pwszEnd=pwszValue;
            *pwszEnd++=0;
            pwszValue=NULL;
            break;
        case ':': // parameter with value
            *pwszValue++=0;
            if ('"'!=*pwszValue) //string without spaces
            {
                pwszEnd=pwszValue;
                while ((0!=*pwszEnd)&&(' '!=*pwszEnd))
                {
                    pwszEnd++;
                }
                if (0!=*pwszEnd)
                {
                    *pwszEnd++=0;
                }
                else
                {
                    pwszEnd=NULL;
                }
            }
            else // get quoted string
            {
                pwszEnd=++pwszValue;
                while ((0!=*pwszEnd)&&('"'!=*pwszEnd))
                {
                    pwszEnd++;
                }
                if ('"'==*pwszEnd)
                {
                    *pwszEnd++=0;
                    bQuoted=TRUE;
                    break;
                }
                else // the string ended before the closing quote
                {
                    RETURN(E_UNEXPECTED);
                }
            }
        } // case end
        hr=AddParam(pwszName,pwszValue,dwFlags,bQuoted);
        if (S_OK!=hr)
        {
            RETURN(hr);
        }
        pwszName=pwszEnd;
    }// parameter loop end

ErrReturn:
    delete pwszCmdLine;
    return hr;
};



//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::ReadEnvironment (public)
//
//  Synopsys:   Copies all the environment vars to the parameter container.
//
//  Returns:    S_OK on success,
//              or HRESULT error code (E_UNEXPECTED, E_OUTOFMEMORY)
//
//  Note:       The prefix should be always in upper case
//
//  History:    10-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::ReadEnvironment(LPCWSTR pwszPrefix, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    LPWSTR pwszTemp=NULL;
    LPWSTR pwszName=NULL;
    LPWSTR pwszValue=NULL;
    int     i=0;
    int     iLen=0;

    // HACK - call getenv so that the system will create environment
    // which can be accessed using the _tenviron
    _tgetenv(TEXT("COMPUTRNAME"));
    if (NULL==_tenviron)
    {
        RETURN(E_UNEXPECTED);
    }

    // Prepare the prefix length
    if (NULL!=pwszPrefix)
    {
        iLen=(int)wcslen(pwszPrefix);
    }

    for (i=0; NULL!=_tenviron[i]; i++)
    {
        hr=CopyString(_environ[i],&pwszTemp);
        if (S_OK!=hr)
        {
            RETURN(hr);
        }

        pwszValue=wcschr(pwszTemp,L'=');
        DH_ASSERT(NULL!=pwszValue)
        *pwszValue++=0;  // cut the param name, get  the value

        if ((NULL==pwszPrefix)||                 // no prefix
            (!_wcsnicmp(pwszPrefix,pwszTemp,iLen))) // prefix maches
        {
            pwszName=pwszTemp+iLen; // cut the prefix
            hr=AddParam(pwszName,pwszValue,dwFlags);
            if (S_OK!=hr)
            {
                RETURN(hr);
            }
        }
        delete pwszTemp;
        pwszTemp=NULL;
    }

ErrReturn:
    delete pwszTemp;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::ReadRegistry (public)
//
//  Synopsys:   Reads the string values in the given registry key
//              to the parameter container
//
//  Returns:    S_OK on success,
//              or HRESULT error code (E_INVALIDARG, E_OUTOFMEMORY)
//
//  Note:       All non-string values under this key are currently ignored,
//              as well as all too large string.
//
//  Returns:    S_OK on success, or HRESULT error code
//
//  History:    10-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::ReadRegistry(HKEY hBaseKey, LPCTSTR ptszKeyName, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    DWORD   dwResult=ERROR_SUCCESS;
    HKEY    hKey=0;
    TCHAR   atszTempName[MAX_REGSTRLEN];
    TCHAR   atszTempValue[MAX_REGSTRLEN];
    DWORD   dwNameSize=0;
    DWORD   dwValueSize=0;
    DWORD   dwType=REG_SZ;
    int     i=0;

    if ((0==hBaseKey)||(NULL==ptszKeyName))
    {
        RETURN(E_INVALIDARG);
    }

    dwResult=RegOpenKey(hBaseKey,ptszKeyName,&hKey);
    if ((ERROR_SUCCESS!=dwResult)||(0==hKey))
    {
        RETURN(HRESULT_FROM_WIN32(dwResult));
    }

    // Loop for all the registry values
    for (i=0; dwResult==ERROR_SUCCESS; i++)
    {
        dwNameSize = ARRAYSIZE(atszTempName);
        dwValueSize = ARRAYSIZE(atszTempValue);
        dwResult=RegEnumValue(
            hKey,
            i,
            (LPTSTR)atszTempName,
            &dwNameSize,
            NULL,
            &dwType,
            (BYTE*)atszTempValue,
            &dwValueSize);
        if (ERROR_NO_MORE_ITEMS==dwResult)
        {
            RETURN(S_OK);
        }
        else if (ERROR_SUCCESS==dwResult)
        {
            // We won't take very big strings, or not strings
            if ((dwType!=REG_SZ)||
                (dwNameSize>=ARRAYSIZE(atszTempName))||
                (dwValueSize>=ARRAYSIZE(atszTempValue)))
            {
                // BUGBUG: trace warning here
                continue;

            }
            else
            {
#ifndef UNICODE
                WCHAR awszTempName[MAX_REGSTRLEN];
                WCHAR awszTempValue[MAX_REGSTRLEN];

                hr = CopyString(atszTempName,
                    awszTempName,
                    ARRAYSIZE(atszTempName)-1,
                    ARRAYSIZE(atszTempName)-1);
                if (S_OK!=hr)
                {
                    RETURN(hr);
                }

                hr = CopyString(atszTempValue,
                    awszTempValue,
                    ARRAYSIZE(atszTempValue)-1,
                    ARRAYSIZE(atszTempValue)-1);
                if (S_OK!=hr)
                {
                    RETURN(hr);
                }

                HRESULT hr=AddParam(
                    awszTempName,
                    awszTempValue,
                    dwFlags);
#else
                HRESULT hr=AddParam(
                    atszTempName,
                    atszTempValue,
                    dwFlags);
#endif
                if (S_OK!=hr)
                {
                    RETURN(hr);
                }
            }
        }
        else if (ERROR_MORE_DATA==dwResult)
        {
            // BUGBUG:Trace warning here
            continue; // acceptable error - proceed with other params
        }
    }

ErrReturn:
    if (0!=hKey)
    {
        RegCloseKey(hKey);
    }
    return hr;
};

//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetEnum (public, synchronized)
//
//  Synopsis:   Interprets parameter string value
//              as enum DWORD.
//
//  Parameters: pszSwitchName:  the command line switch name.
//              pdwValue:       ptr to enum var which receives the result
//              ...             expected value names and values untill NULL
//
//  Example:   g_TestParams.GetParamAsEnum(
//                  "mode",
//                  &dwMode,
//                  "rw", STGM_READWRITE,
//                  "r",  STGM_READ,
//                  "w",  STGM_WRITE,
//                  NULL);
//
//  Returns:    S_OK on success HRESULT error code
//
//  Note:       If the parameter is not found the function succeeds and
//              retruns the first option value in *pdwValue
//
//  History:    15-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT __cdecl CTestParams::GetEnum(const char *pszParamName, DWORD  *pdwValue,...)
{
    HRESULT     hr=S_OK;
    char *      pszOption=NULL;
    DWORD       dwValue=0xabcdabcd;
    BOOL        bFound=FALSE;
    BOOL        bEnterSync=FALSE;
    va_list     ARGS;
    CParamNode  *pPrev=NULL; // not used
    CParamNode  *pNode=NULL;
    char *      pszTemp=NULL;
    LPWSTR      pwszName=NULL;

    if ((NULL==pszParamName)||(NULL==pdwValue))
    {
        RETURN(E_INVALIDARG);
    }

    // copy the name as unicode
    hr=CopyString(pszParamName,&pwszName);
    if (S_OK!=hr)
    {
        RETURN(hr);
    }

    // Get the switch string value
    ENTER_SYNC;
    pNode=FindParam(pwszName,&pPrev);
    if (NULL!=pNode)
    {
        pNode->MarkAsUsed(m_dwUsageInfo);
    }

    // Copy the value as ascii
    if ((NULL!=pNode)&&(NULL!=pNode->m_pwszValue))
    {
        hr=CopyString(pNode->m_pwszValue,&pszTemp);
        if (S_OK!=hr)
        {
            RETURN(hr);
        }
    }

    // Loop for all expected values
    va_start(ARGS,pdwValue);
    pszOption=va_arg(ARGS,char*);
    while(NULL!=pszOption)
    {
        dwValue=va_arg(ARGS,DWORD);
        if ((NULL==pszTemp)||
            (!_stricmp(pszTemp,pszOption)))
        {
            bFound=TRUE;
            break;
        }
        pszOption=va_arg(ARGS,char*);
    }
    va_end(ARGS);

    if (bFound)
    {
        *pdwValue=dwValue;
        hr=S_OK;
    }
    else
    {
        hr=E_FAIL;
    }

ErrReturn:
    LEAVE_SYNC;
    delete pwszName;
    delete pszTemp;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::ClearUsage (public, synchronized)
//
//  Synopsys:   Clears usage specific flags
//
//  Parameters: dwFlags: DWORD containing the usage flags to clear
//                       (all other bits are ignored)
//
//  History:    30-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
void CTestParams::ClearUsage(DWORD dwFlags)
{
    HRESULT hr=S_OK;
    BOOL bEnterSync=FALSE;
    CParamNode **pLinkPtr=&m_pParamsList;
    CParamNode *pNode=m_pParamsList;
    CParamNode *pNext=NULL;

    ENTER_SYNC;
    while (NULL!=pNode)
    {
         pNode->ClearUsage(dwFlags);
         pNext=pNode->m_pNext;

         // Clear "repro info" parameters which are out of scope
         // (all the usage flags are cleared)
         if ((PARAMFLAG_REPROINFO & pNode->m_dwFlags)&&
             !(PARAMMASK_USAGE & pNode->m_dwFlags))
         {
             *pLinkPtr=pNext;
             delete pNode;
         }
         else
         {
             pLinkPtr=&pNode->m_pNext;
         }
         pNode=pNext;
    }
ErrReturn:
    LEAVE_SYNC;
}

//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::ChangeParamFlags (public, synchronized)
//
//  Synopsys:   Change parameter flags (all except usage marks)
//
//  Parameters: dwFlags: DWORD containing the flags
//                       (usage bits are ignored)
//
//  Note:       This function may be used for changing priority
//              of the parameters from given source
//              e.g. ???.ChangeParam(
//                          PARAMFLAGS_CMDLINE,
//                          PARAMFLAGS_CMDLINE+1); // raise priority
//
//  History:    30-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::ChangeFlags(DWORD dwOldFlags, DWORD dwNewFlags)
{
    HRESULT hr=S_OK;
    BOOL bEnterSync=FALSE;
    CParamNode *pNode=NULL;

    if ((0==(PARAMMASK_SOURCE & dwOldFlags))||
        (0==(PARAMMASK_SOURCE & dwNewFlags)))
    {
        RETURN(E_INVALIDARG);
    }

    ENTER_SYNC;
    for (pNode=m_pParamsList;
         NULL!=pNode;
         pNode=pNode->m_pNext)
    {
         if (dwOldFlags==(pNode->m_dwFlags & ~PARAMMASK_SOURCE))
         {
            pNode->ChangeFlags(dwNewFlags);
         }
    }
ErrReturn:
    LEAVE_SYNC;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::SaveParams (public, synchronized)
//
//  Synopsys:   Allocates a memory block and saves all the parameter info
//
//  Arguments:  *ppcBuffer:[out] the pointer to the buffer with all params
//              *pdwSize:  [out] the size of the buffer
//              dwMask:    [in]  filter for parameters
//
//  Notes:      This method enables storing the set of parameters,
//              or sending it to different process.
//
//              The caller is responsible for deleting the table obtained.
//
//  History:    30-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::SaveParams(
    char **ppcBuffer,
    DWORD *pdwSize,
    DWORD dwMask)
{
    HRESULT     hr=S_OK;
    DWORD       dwSize=0;
    CParamNode *pNode=NULL;
    BOOL        bEnterSync=FALSE;
    char        *pcTemp=NULL;

    if ((NULL==pdwSize)||(NULL==ppcBuffer))
    {
        RETURN(E_INVALIDARG);
    }
    *ppcBuffer=NULL;
    *pdwSize=0;

    ENTER_SYNC;
    // Calculate the size needed
    for (pNode=m_pParamsList; NULL!=pNode; pNode=pNode->m_pNext)
    {
        if (pNode->m_dwFlags & dwMask)
        {
            dwSize+=sizeof(DWORD)+((DWORD)wcslen(pNode->m_pwszName)+1)*sizeof(WCHAR);
            if (NULL!=pNode->m_pwszValue)
            {
                dwSize+=((DWORD)wcslen(pNode->m_pwszValue)+1)*sizeof(WCHAR)+1; // mark 'y' + string
            }
            else
            {
                dwSize++; // mark 0
            };
        };
    }

    // Allocate a buffer
    *ppcBuffer=new char[dwSize];
    if (NULL==*ppcBuffer)
    {
        RETURN(E_OUTOFMEMORY);
    }
    memset(*ppcBuffer,0,dwSize);

    // Copy all parameters
    pcTemp=*ppcBuffer;
    for (pNode=m_pParamsList; NULL!=pNode; pNode=pNode->m_pNext)
    {
        if (pNode->m_dwFlags & dwMask)
        {
            // Flags
            *(DWORD*)(LPVOID)pcTemp=pNode->m_dwFlags;
            pcTemp+=sizeof(DWORD);

            // Name
            wcscpy((LPWSTR)pcTemp,pNode->m_pwszName);
            pcTemp+=(wcslen((LPWSTR)pcTemp)+1)*sizeof(WCHAR);

            // Value
            if (NULL!=pNode->m_pwszValue)
            {
                *pcTemp++='y'; // mark that we have a value
                wcscpy((LPWSTR)pcTemp,pNode->m_pwszValue);
                pcTemp+=(wcslen((LPWSTR)pcTemp)+1)*sizeof(WCHAR);
            }
            else
            {
                *pcTemp++=0; // mark that there is no value
            }
        }
    }
    *pdwSize=dwSize;

ErrReturn:
    LEAVE_SYNC;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::LoadParams (public, synchronized)
//
//  Synopsys:   Loads the parameters from memory buffer obtained by
//              the CTestParams::Save method
//
//  Arguments:  pcBuffer:     [in] the pointer to the buffer with all params
//              dwSize:       [in] the size of the buffer
//              dwChangeFlags:[in] if not 0, change all parameters flags
//
//  Note:       The CTestParams object will make a copy of the parameters
//              and do not need the buffer anymore.
//
//  History:    30-Sep-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::LoadParams(
    char *pcBuffer,
    DWORD dwSize,
    DWORD dwChangeFlags)
{
    HRESULT     hr=S_OK;
    BOOL        bEnterSync=FALSE;
    char        *pcTemp=pcBuffer;
    char        *pcEndPtr=pcBuffer+dwSize;

    if ((0==dwSize)||(NULL==pcBuffer))
    {
        RETURN(E_INVALIDARG);
    }

    ENTER_SYNC;
    while (pcTemp<pcEndPtr)
    {
        // extract Flags
        DWORD dwFlags=*(DWORD*)(LPVOID)(pcTemp);
        pcTemp+=sizeof(DWORD);
        if (0!=dwChangeFlags)
        {
            // Change all flags except the usage
            dwFlags=(dwFlags & PARAMMASK_USAGE) |
                (dwChangeFlags & ~PARAMMASK_USAGE);
        }

        // extract Name
        LPWSTR pwszName=(LPWSTR)pcTemp;
        pcTemp+=(wcslen((LPWSTR)pcTemp)+1)*sizeof(WCHAR);

        // extract Value
        LPWSTR pwszValue=NULL;
        if ('y'==*pcTemp)
        {
            pwszValue=(LPWSTR)++pcTemp;
            pcTemp=(char*)pwszValue+(wcslen(pwszValue)+1)*sizeof(WCHAR);
        }
        else
        {
            pwszValue=NULL;
            pcTemp++;
        }

        // Add this parameter
        HRESULT hr=AddParam(pwszName,pwszValue,dwFlags);
        if (S_OK!=hr)
        {
            RETURN(hr);
        }
    }

ErrReturn:
    LEAVE_SYNC;
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetReproLine (public, synchronized)
//
//  Synopsys:   Extracts repro line including all the parameters
//              which mach the mask
//
//  Parameters: dwFlags: the mask to filter parameters,
//                       default is PARAMMASK_USAGE.
//                       Use PARAMMASK_ALL to get all parameters
//
//              The caller is responsible for deleting the table obtained.
//
//  History:    01-Oct-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::GetReproLine(LPWSTR *ppwszReproLine, DWORD dwFlags)
{
    HRESULT     hr=S_OK;
    DWORD       dwSize=1; // the ending 0 in the string
    CParamNode  *pNode=NULL;
    BOOL        bEnterSync=FALSE;
    LPWSTR      pwszBuffer=NULL;
    LPWSTR      pwszTemp=NULL;

    if (NULL==ppwszReproLine)
    {
        RETURN(E_INVALIDARG);
    }

    ENTER_SYNC;
    // Calculate the size needed
    for (pNode=m_pParamsList; NULL!=pNode; pNode=pNode->m_pNext)
    {
        if (dwFlags & pNode->m_dwFlags)
        {
            dwSize+=(DWORD)wcslen(pNode->m_pwszName)+2; // the name, '/' and space
            if (NULL!=pNode->m_pwszValue)
            {
                dwSize+=(DWORD)wcslen(pNode->m_pwszValue)+1; // ':' and value
            }
        }
    }

    if (0==dwSize)
    {
        hr=CopyString("",&pwszBuffer);
        RETURN(hr);
    }

    // Allocate a buffer
    pwszBuffer=new WCHAR[dwSize];
    if (NULL==pwszBuffer)
    {
        RETURN(E_OUTOFMEMORY);
    }
    memset(pwszBuffer,0,dwSize*sizeof(WCHAR));

    // Copy all parameters
    pwszTemp=pwszBuffer;
    for (pNode=m_pParamsList; NULL!=pNode; pNode=pNode->m_pNext)
    {
        if (dwFlags & pNode->m_dwFlags)
        {
            // Value
            if (NULL!=pNode->m_pwszValue)
            {
                swprintf(pwszTemp,L"/%s:%s ",pNode->m_pwszName,pNode->m_pwszValue);
                pwszTemp+=wcslen(pwszTemp); // point to the ending zero
            }
            else
            {
                // The parameter has no value (boolean switch)
                swprintf(pwszTemp,L"/%s ",pNode->m_pwszName);
                pwszTemp+=wcslen(pwszTemp); // point to the ending zero
            };
        }
    }

ErrReturn:
    LEAVE_SYNC;
    if (S_OK==hr)
    {
        *ppwszReproLine=pwszBuffer;
    }
    else
    {
        delete pwszBuffer;
    }
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetReproLine (public, synchronized)
//
//  Synopsys:   Extracts repro line including all the parameters
//              which mach the mask
//
//  Parameters: dwFlags: the mask to filter parameters,
//                       default is PARAMMASK_USAGE.
//                       Use PARAMMASK_ALL to get all parameters
//
//              The caller is responsible for deleting the table obtained.
//
//  History:    01-Oct-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::GetReproLine(char **ppszReproLine, DWORD dwFlags)
{
    HRESULT     hr=S_OK;
    LPWSTR      pwszTemp=NULL;

    if (NULL==ppszReproLine)
    {
        RETURN(E_INVALIDARG);
    }

    hr=GetReproLine(&pwszTemp,dwFlags);
    if (S_OK==hr)
    {
        if (NULL==pwszTemp)
        {
            *ppszReproLine=NULL;
        }
        else
        {
            hr=CopyString(pwszTemp,ppszReproLine);
        }
    }
ErrReturn:
    delete pwszTemp;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetRange (public, synchronized)
//
//  Synopsys:   Gets the values treating the parameter as range min-max
//
//
//  Parameters: pszParamName:     [in]  the parameter name
//              pullMin,pullMin : [out] the range values
//
//  Retruns:    S_OK or HRESULT error code
//
//  Note:       The string value of the parameter should be "min-max"
//              e.g. "10-20"
//              If the parameter can't be found, or the string format is bad
//              the values won't be chenged.
//
//  History:    02-Oct-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::GetRange(
        const char *pszParamName,
        ULONGLONG *pullMin,
        ULONGLONG *pullMax)
{
    HRESULT     hr=S_OK;
    BOOL        bEnterSync=FALSE;
    CParamNode  *pPrev=NULL; // not used
    CParamNode  *pNode=NULL;
    LPWSTR      pwszMin=NULL;
    LPWSTR      pwszMax=NULL;
    ULONGLONG   ullMin=0;
    ULONGLONG   ullMax=0;
    LPWSTR      pwszName=NULL;

    if ((NULL==pszParamName)||(NULL==pullMin)||(NULL==pullMax))
    {
        RETURN(E_INVALIDARG);
    }

    hr=CopyString(pszParamName,&pwszName);
    if (S_OK!=hr)
    {
        RETURN(hr);
    }

    // Get the switch string value
    ENTER_SYNC;
    pNode=FindParam(pwszName,&pPrev);

    if ((NULL==pNode)||(NULL==pNode->m_pwszValue))
    {
        RETURN(S_FALSE);
    }
    pwszMin = pNode->m_pwszValue;
    pwszMax = pwszMin;
    // Advance the maximum pointer past the dash delimeter after
    while ((*pwszMax != 0) && (*pwszMax++ != '-'))
    {
        ;
    }

#ifdef WINNT // only here we have functions to hangle 64bit integers
    ullMin = _wtoi64(pwszMin);
    ullMax = _wtoi64(pwszMax);
#else
    // wtoi64 is not present in link libraries, ifdef this
    // to avoid build break. BUGBUG param values >DWORD will be truncated!
    ullMin = _wtol(pwszMin);
    ullMax = _wtol(pwszMax);
#endif

    if (0==*pwszMax)  // only one value is given
    {
        ullMax=ullMin;
    };

    if (ullMin <= ullMax)
    {
        hr=S_OK;
        *pullMin=ullMin;
        *pullMax=ullMax;
    }
    else
    {
        hr=E_FAIL;
    }
ErrReturn:
    LEAVE_SYNC;
    delete pwszName;
    return hr;
};

//+--------------------------------------------------------------------------
//
//  Method:     CTestParams::GetRange (public, synchronized)
//
//  Synopsys:   Gets the values treating the parameter as range min-max
//
//  Parameters: pszParamName:     [in]  the parameter name
//              pulMin,pulMin :   [out] the range values
//
//  Retruns:    S_OK or HRESULT error code
//
//  Note:       The string value of the parameter should be "min-max"
//              e.g. "10-20"
//              If the parameter can't be found, or the string format is bad
//              the values won't be chenged.
//
//  History:    02-Oct-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CTestParams::GetRange(
        const char *pszParamName,
        ULONG *pulMin,
        ULONG *pulMax)
{
    HRESULT hr=S_OK;
    ULARGE_INTEGER uliMin;
    ULARGE_INTEGER uliMax;

    if ((NULL==pszParamName)||(NULL==pulMin)||(NULL==pulMax))
    {
        RETURN(E_INVALIDARG);
    }

    uliMin.QuadPart=0;
    uliMax.QuadPart=0;

    hr=GetRange(pszParamName,&uliMin.QuadPart,&uliMax.QuadPart);

    if (S_OK==hr) // else leave the values in *pulMin and *pulMax untouched
    {
        DH_ASSERT(0==uliMin.HighPart);
        *pulMin=uliMin.LowPart;
        DH_ASSERT(0==uliMax.HighPart);
        *pulMax=uliMax.LowPart;
    }

ErrReturn:
    return hr;
};

//************** CTOLESTG specific **************************

// Define the default global parameter container
CStgParams g_TestParams;


//+--------------------------------------------------------------------------
//
//  Method:     CStgParams::NotifyOnFirstUse (public)
//
//  Synopsys:   Reads all the common parameter sources for
//              the CTOLESTG project
//
//  Note:       The cleaner way is to implement a single function,
//              but we want to start using the CTestParams in the
//              common code, without modifying each the main()
//              for each of the existing suites (about 50 now)
//
//  History:    23-Oct-1998   georgis       Created
//
//---------------------------------------------------------------------------
HRESULT CStgParams::NotifyOnFirstUse()
{
    HRESULT hr=S_OK;
    HRESULT hr1=S_OK;
    DWORD   dwDumpMask=PARAMMASK_ALL;


    // command line
    hr1=ReadCommandLine();
    if (S_OK!=hr1)
    {
        hr=hr1;
    };

    if (!GETPARAM_ISPRESENT(STG_CMDLINEONLY))
    {

        // HKEY_CURRENT_USER\Software\Microsoft\CTOLESTG
        // is the switch is not present, act as if it was empty
        hr1=ReadRegistry(
            HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\CTOLESTG"));

        // Environment
        hr1=ReadEnvironment(L"STG_");
        if (S_OK!=hr1)
        {
            hr=hr1;
        };
    } // if cmdline only

    // Eventually dump all the parameters
    if (GETPARAM_ISPRESENT(PARAMDUMP))
    {
        GETPARAM(PARAMDUMP,dwDumpMask);
    }
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\restmap\restmap.cpp ===
/******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Module Name:
 *    restmap.cpp
 *
 * Abstract:
 *    This file contains the implementation of RestoreMap apis.
 *
 * Revision History:
 *    Kanwaljit Marok  (kmarok)    06/22/1999
 *        created
 *
 *
 ******************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "restmap.h"
#include "reslist.h"
#include "enumlogs.h"
#include "utils.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#include "dbgtrace.h"

//
// CreateRestoreMap : Creates a restore map file for a given drive and restore point number
//                    Appends the restore map to file hFile
//

DWORD 
CreateRestoreMap(LPWSTR pszDrive,
                 DWORD  dwRPNum,
                 HANDLE hFile)   
{
    CRestoreList    resList;
    DWORD           dwRc;
    WCHAR           szPath[MAX_PATH];
    BOOL            fRet = FALSE;

    // enumerate backward, skipping current restore point
    CChangeLogEntryEnum cle_enum(pszDrive, FALSE, dwRPNum, TRUE);
    CChangeLogEntry     cle;
      
    dwRc = cle_enum.FindFirstChangeLogEntry(cle);

    while (dwRc == ERROR_SUCCESS)
    {
        fRet = resList.AddMergeElement(
                    pszDrive,
                    cle.GetType(),
                    cle.GetAttributes(),
                    cle.GetFlags(),
                    cle.GetTemp(),
                    cle.GetPath1(),
                    cle.GetPath2(),
                    cle.GetAcl(),
                    cle.GetAclSize(),
                    cle.GetAclInline());
        
        if (! fRet)
        {
            dwRc = ERROR_INTERNAL_ERROR;
            goto Exit;
        }

        dwRc = cle_enum.FindNextChangeLogEntry(cle);
    }

    // if there was an error, then we're done

    if (dwRc != ERROR_NO_MORE_ITEMS)
        goto Exit;        

    // if there are no entries to restore, then we're done

    if (! fRet)
        goto Exit;

    //
    // Generate the restore map in the specified file.
    //
    if (! resList.GenerateRestoreMap(hFile))
    {
        dwRc = ERROR_INTERNAL_ERROR;
        goto Exit;
    }
    
    dwRc = ERROR_SUCCESS;

Exit:
    cle_enum.FindClose();
    return dwRc;
}


//
// AppendRestoreMapEntry : writes the restore map entry to file
//

BOOL
AppendRestoreMapEntry(
    HANDLE hFile,
    DWORD  dwOperation,
    DWORD  dwAttribute,
    LPWSTR pTmpFile,
    LPWSTR pPathSrc,
    LPWSTR pPathDes,
    BYTE  *pbAcl,
    DWORD  cbAcl,
    BOOL   fAclInline)
{
    BOOL            fRet = FALSE;
    INT             cbSrc = 0, cbDes = 0, cbTemp = 0;
    RestoreMapEntry *pMapEnt = NULL;
    DWORD           dwRead, dwSize;

	if (! pPathSrc)  // something wrong
        goto done;

	cbSrc = STRSIZE(pPathSrc);

    // only one of pPathDes, pTmpFile and pbAcl will be non-NULL, if at all

	if (pTmpFile)
		cbTemp = STRSIZE(pTmpFile);

	if (pPathDes)
		cbDes = STRSIZE(pPathDes);

    dwSize = sizeof(RestoreMapEntry) - sizeof(BYTE) + cbSrc + cbTemp + cbDes + cbAcl;
	pMapEnt = (RestoreMapEntry *) HEAP_ALLOC(dwSize);
	if (! pMapEnt)
		goto done;

	pMapEnt->m_dwSize = dwSize;
    pMapEnt->m_dwOperation = dwOperation;
    pMapEnt->m_dwAttribute = dwAttribute;
    pMapEnt->m_cbAcl = cbAcl;
    pMapEnt->m_fAclInline = fAclInline;

    memcpy(pMapEnt->m_bData, pPathSrc, cbSrc);

    if (pTmpFile)
        memcpy((BYTE *) pMapEnt->m_bData + cbSrc, pTmpFile, cbTemp);

    if (pPathDes)
        memcpy((BYTE *) pMapEnt->m_bData + cbSrc + cbTemp, pPathDes, cbDes);

    if (pbAcl)
        memcpy((BYTE *) pMapEnt->m_bData + cbSrc + cbTemp + cbDes , pbAcl, cbAcl);

    fRet = WriteFile( hFile, pMapEnt, pMapEnt->m_dwSize, &dwRead, NULL );

	HEAP_FREE(pMapEnt);

done:
	return fRet;
}


// reads a restore map entry from a given file

DWORD
ReadRestoreMapEntry(
    HANDLE hFile, 
    RestoreMapEntry **pprme)
{
    DWORD dwRead, dwErr = ERROR_SUCCESS, dwSize;

	if (*pprme)
		HEAP_FREE(*pprme);

    if (! ReadFile(hFile, &dwSize, sizeof(DWORD), &dwRead, NULL))
	{
		dwErr = GetLastError();
        goto Err;
	}

	if (dwRead == 0 || dwSize == 0)
	{
		dwErr = ERROR_NO_MORE_ITEMS;
		goto Err;
	}

	*pprme = (RestoreMapEntry *) HEAP_ALLOC(dwSize);
	if (! *pprme)
	{
		dwErr = ERROR_INTERNAL_ERROR;
		goto Err;
	}

	(*pprme)->m_dwSize = dwSize;

    if (! ReadFile(hFile, 
                   (PVOID) ((BYTE *) (*pprme) + sizeof(DWORD)), 
                   (*pprme)->m_dwSize - sizeof(DWORD), 
                   &dwRead,
                   NULL) || 
        dwRead != (*pprme)->m_dwSize - sizeof(DWORD) )
	{
		dwErr = GetLastError();
        goto Err;
	}

Err:
    return dwErr;
}


PVOID
GetOptional(
    RestoreMapEntry *prme)
{
    DWORD   cbData = STRSIZE((LPWSTR) prme->m_bData);
    DWORD   dwBasicSize = sizeof(RestoreMapEntry) + cbData - sizeof(BYTE);
    
    if (prme->m_dwSize > dwBasicSize)
        return (PVOID) (prme->m_bData + cbData);
    else
        return NULL;
}


void
FreeRestoreMapEntry(
	RestoreMapEntry *prme)
{
	HEAP_FREE(prme);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\restmap\restmap.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    RestMap.h
 *
 *  Abstract:
 *    This file code for RestMap.
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef _RESTMAP_H_
#define _RESTMAP_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "srapi.h"


#define OPR_FILE_DELETE SrEventFileDelete
#define OPR_FILE_RENAME SrEventFileRename  
#define OPR_FILE_ADD    SrEventFileCreate
#define OPR_FILE_MODIFY SrEventStreamOverwrite
#define OPR_DIR_DELETE  SrEventDirectoryDelete
#define OPR_DIR_CREATE  SrEventDirectoryCreate
#define OPR_DIR_RENAME  SrEventDirectoryRename
#define OPR_SETATTRIB   SrEventAttribChange
#define OPR_UNKNOWN     SrEventInvalid
#define OPR_SETACL      SrEventAclChange

#define IsRename(a) (a == OPR_FILE_RENAME || a == OPR_DIR_RENAME)



#pragma pack(push, vxdlog_include)

#pragma pack(1)

//
// Structure of Restore Map Entry
//

typedef struct RESTORE_MAP_ENTRY
{
    DWORD m_dwSize;                    // Size of Vxd Log Entry
    DWORD m_dwOperation ;              // Operation to be performed
    DWORD m_dwAttribute ;              // Attributes
    DWORD m_cbAcl;                     // if acl op, then size of acl
    BOOL  m_fAclInline;                // whether acl is inline or in file
    BYTE  m_bData [ 1 ];               // pSrc / pTemp / pDest / pAcl
} RestoreMapEntry;

#pragma pack()

//
// Function Prototypes
//

DWORD
CreateRestoreMap(
                 LPWSTR pszDrive,
                 DWORD  dwRPNum,
                 HANDLE hFile
                 );

BOOL
AppendRestoreMapEntry(
    HANDLE hFile,
    DWORD  dwOperation,
    DWORD  dwAttribute,
    LPWSTR pTmpFile,
    LPWSTR pPathSrc,
    LPWSTR pPathDes,
    BYTE*  pbAcl,
    DWORD  cbAcl,
    BOOL   fAclInline);

DWORD
ReadRestoreMapEntry(
    HANDLE hFile,
    RestoreMapEntry **pprme);

PVOID
GetOptional(
    RestoreMapEntry *prme);

void
FreeRestoreMapEntry(
	RestoreMapEntry *prme);


#ifdef __cplusplus
}
#endif

#endif // _RESTOREMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\restmap\reslist.cpp ===
/******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Module Name:
 *    reslist.cpp
 *
 * Abstract:
 *    This file contains the implementation of Restore List.
 *
 * Revision History:
 *    Brijesh Krishnaswami  (brijeshk)    06/02/00 
 *        created
 *
 *
 ******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "restmap.h"
#include "reslist.h"
#include "shlwapi.h"
#include "utils.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


#include "dbgtrace.h"


// copy acl

void
CopyAcl(CNode *pNode, BYTE *pbAcl, DWORD cbAcl, BOOL fAclInline)
{
    if (pbAcl) 
    { 
        HEAP_FREE(pNode->m_pbAcl); 
        pNode->m_pbAcl = (BYTE *) HEAP_ALLOC(cbAcl); 
        if (pNode->m_pbAcl)
            memcpy(pNode->m_pbAcl, pbAcl, cbAcl); 
        pNode->m_cbAcl = cbAcl;
        pNode->m_fAclInline = fAclInline;
    }
}


//
// GetReverseOperation : This function will return the reverse operation of the
//      current changelog operation.
//

DWORD
GetReverseOperation( 
    DWORD dwOpr
    )
{
    DWORD dwRestoreOpr = OPR_UNKNOWN;

    switch( dwOpr )
    {
    case OPR_FILE_DELETE: 
            dwRestoreOpr = OPR_FILE_ADD; 
            break;

    case OPR_FILE_ADD   :
            dwRestoreOpr = OPR_FILE_DELETE;
            break;

    case OPR_FILE_MODIFY:
            dwRestoreOpr = OPR_FILE_MODIFY;
            break;

    case OPR_SETATTRIB:
            dwRestoreOpr = OPR_SETATTRIB;
            break;

    case OPR_FILE_RENAME:
            dwRestoreOpr = OPR_FILE_RENAME;
            break;

    case OPR_DIR_RENAME:
            dwRestoreOpr = OPR_DIR_RENAME;
            break;

    case OPR_DIR_DELETE:
            dwRestoreOpr = OPR_DIR_CREATE;
            break;

    case OPR_DIR_CREATE:
            dwRestoreOpr = OPR_DIR_DELETE;
            break;

	case OPR_SETACL:
			dwRestoreOpr = OPR_SETACL;
			break;

    default:
            dwRestoreOpr = OPR_UNKNOWN;
            break;
    }

    return dwRestoreOpr;
}


//
// AllocateNode : allocates a list node 
//  

CNode * 
AllocateNode(
    LPWSTR  pPath1,
    LPWSTR  pPath2)
{
    CNode * pNode = NULL;
    BOOL    fRet = FALSE;
    
    if (! pPath1) 
    {
        fRet = TRUE;   // BUGBUG - is this a valid case?
        goto Exit;
    }

    pNode = (CNode *) HEAP_ALLOC( sizeof(CNode) );
    if (! pNode )
        goto Exit;    

    // all pointers set to NULL

    if ( pPath1 )
        STRCOPY(pNode->m_pPath1, pPath1);

    if ( pPath2 )
        STRCOPY(pNode->m_pPath2, pPath2);
        
    pNode->m_dwOperation = OPR_UNKNOWN;
    pNode->m_dwAttributes = 0xFFFFFFFF;
    pNode->m_pPrev = NULL;
    pNode->m_pNext = NULL;

    fRet = TRUE;

Exit:
    if (! fRet)
    {
        // something failed, so cleanup

        FreeNode(pNode);
        pNode = NULL;
    }

    return pNode;
}


//
// FreeNode : This function frees a list node
//

VOID
FreeNode(
    CNode * pNode
    )
{
    if ( pNode )
    {
        HEAP_FREE(pNode->m_pPath1);
        HEAP_FREE(pNode->m_pPath2);
        HEAP_FREE(pNode->m_pszTemp);
        HEAP_FREE(pNode->m_pbAcl);
        HEAP_FREE(pNode);
    }
}
	 

//
// Looks at an existing node and the new operation coming and decides
// if they can be merged or not.
//

BOOL
CanMerge(
    DWORD dwExistingOpr,
    DWORD dwNewOpr,
    DWORD dwFlags
    )
{
    BOOL fRet = FALSE;

    //
    // Don't optimize directory renames
    //

    if ( OPR_DIR_RENAME == dwExistingOpr ||
         OPR_DIR_RENAME == dwNewOpr )
        goto Exit;

    //
    // Don't optimize for rename if the node we find is a delete node
    // and the current opr is rename. In such cases since rename is
    // dependent on deletion to succeed.
    // Example : A -> B , Create A should generate Delete A, B -> A
    //

    if ( IsRename(dwNewOpr) &&                      
         ( OPR_DIR_DELETE == dwExistingOpr || OPR_FILE_DELETE == dwExistingOpr )
       )
        goto Exit;

    //
    // Also Del A, A->B should not merge this can happen if the file is
    // getting renamed out of the directory and back.
    //

    if ( IsRename(dwExistingOpr) &&                      
         ( OPR_DIR_DELETE == dwNewOpr || 
           OPR_DIR_CREATE == dwNewOpr ||
           OPR_FILE_DELETE == dwNewOpr )
       )
        goto Exit;


    if ( IsRename(dwNewOpr) &&                      
        ( OPR_DIR_DELETE == dwExistingOpr || 
          OPR_DIR_CREATE == dwExistingOpr )
       )
        goto Exit;

    //
    // Dir + File operations don't merge
    //

    if ( ( OPR_FILE_DELETE == dwExistingOpr ||
           OPR_FILE_MODIFY == dwExistingOpr ||
           OPR_FILE_ADD    == dwExistingOpr ) &&
         ( OPR_DIR_CREATE  == dwNewOpr ||
           OPR_DIR_DELETE  == dwNewOpr )
       )
        goto Exit;

         
    if ( ( OPR_FILE_DELETE == dwNewOpr ||
           OPR_FILE_ADD    == dwNewOpr ||
           OPR_FILE_MODIFY == dwNewOpr ) &&
         ( OPR_DIR_CREATE  == dwExistingOpr ||
           OPR_DIR_DELETE  == dwExistingOpr )
       )
        goto Exit;


    // can merge

    fRet = TRUE;

Exit:
    return fRet;
}


//
// CRestoreList implementation.
//

CRestoreList::CRestoreList()
{
    m_pListHead = m_pListTail = NULL;
}


CRestoreList::~CRestoreList()
{
    //
    // Destroy the list
    //

    CNode * pNodeNext = m_pListHead;

    CNode * pNode = NULL;
    while( pNodeNext )
    {
        pNode = pNodeNext;
        pNodeNext = pNodeNext->m_pNext;
        FreeNode( pNode );
    }
}


//
// AddNode : Alocates and Adds a tree node to the restore tree.
//

CNode *
CRestoreList::AppendNode( 
    LPWSTR        pPath1,
    LPWSTR        pPath2)
{
    CNode *      pNode = NULL;

    if ( pPath1 )

    {
        pNode = AllocateNode( pPath1, pPath2 );

        if ( !pNode )
        {
            goto Exit;
        }

        if( m_pListHead )
        {
            CNode * pPrevNode  = m_pListTail;            
            pPrevNode->m_pNext = pNode;
            pNode->m_pPrev     = pPrevNode;        
            pNode->m_pNext     = NULL;        
            m_pListTail = pNode;
        }
        else
        {
            m_pListHead = pNode;
            m_pListTail = pNode;
            pNode->m_pPrev = NULL;
            pNode->m_pNext = NULL;
        }
    }
         
Exit:
    return pNode;
}

//
// RemoveNode: Removes a node from the list
//

CNode *
CRestoreList::RemoveNode(
    CNode * pNode 
    )
{
    if ( pNode )
    {
        CNode * pPrevNode = pNode->m_pPrev;
        CNode * pNextNode = pNode->m_pNext;

        if (pPrevNode)
        {
            pPrevNode->m_pNext = pNode->m_pNext;    
        }

        if (pNextNode)
        {
            pNextNode->m_pPrev = pNode->m_pPrev;    
        }

        if ( pNode == m_pListHead )
        {
            m_pListHead = pNextNode;
        }
        
        if ( pNode == m_pListTail )
        {
            m_pListTail = pPrevNode;
        }

        pNode->m_pPrev = NULL;
        pNode->m_pNext = NULL;
    }


    return pNode;
}


//
// GetLastNode : finds the most recent candidate to merge
//
CNode * 
CRestoreList::GetLastNode(
    LPWSTR pPath1,
    LPWSTR pPath2,
    BOOL   fFailOnPrefixMatch
    )
{
    CNode * pNode = NULL;

    pNode = m_pListTail;

    while( pNode )
    {
        //
        // If the node has invalid operation skip it.
        //

        if ( OPR_UNKNOWN == pNode->m_dwOperation )
        {
            pNode = pNode->m_pPrev;
            continue;
        }

        //
        // If node matches, return it
        //

        if (0 == lstrcmpi(pPath1, pNode->m_pPath1))
            goto Exit; 

        //
        // Check for a dependent rename operation, if found we should not
        // merge beyond it.
        //

        if (  pPath1 && 
              IsRename(pNode->m_dwOperation) &&
              0 == lstrcmpi(pPath1, pNode->m_pPath2) )
        {
            pNode = NULL;
            goto Exit; 
        }

        //
        // Check for swap conditions, if so don't do any optimization.
        //

        if (  pPath2 && 
              IsRename(pNode->m_dwOperation) &&
              0 == lstrcmpi(pPath2, pNode->m_pPath2) )
        {
            pNode = NULL;
            goto Exit; 
        }

        //
        // Check if the entire  path matches  as a  prefix, in such a 
        // case we should fail search because an operation under that
        // directory is found.
        //

        if ( fFailOnPrefixMatch )
        {
            //
            // Check if entire path matches a prefix that means this
            // directory has other operations so don't merge.
            //

            if (StrStrI(pNode->m_pPath1, pPath1))
            {
                pNode = NULL;
                goto Exit; 
            }

            if ( IsRename(pNode->m_dwOperation) &&
                 StrStrI(pNode->m_pPath2, pPath1))
            {
                pNode = NULL;
                goto Exit; 
            }

            //
            // Check if prefix of the path matches with the full path in
            // nodelist, means we are moving across directory's lifespan.
            // ToDo: Only check for directory life operations
            //

            if ( IsRename(pNode->m_dwOperation) || 
				 OPR_DIR_DELETE == pNode->m_dwOperation ||
                 OPR_DIR_CREATE == pNode->m_dwOperation )
            {
                if ( StrStrI(pPath1, pNode->m_pPath1) )
                {
                    pNode = NULL;
                    goto Exit;
                }
                    
                if ( IsRename(pNode->m_dwOperation) &&
                     StrStrI(pPath1, pNode->m_pPath2) )
                {
                    pNode = NULL;
                    goto Exit; 
                }
    
                if ( pPath2 )
                {
                    if ( StrStrI(pPath2, pNode->m_pPath1) )
                    {
                        pNode = NULL;
                        goto Exit;
                    }
                    
                    if ( IsRename(pNode->m_dwOperation) &&
                         StrStrI(pPath2, pNode->m_pPath2) )
                    {
                        pNode = NULL;
                        goto Exit; 
                    }
                }
            }
        }

        pNode = pNode->m_pPrev;
    }

Exit:
    
    // 
    // We have found a potential merge candidate, now check if this is
    // a rename node and dest prefix has any operations on it.
    //

    if ( pNode && IsRename(pNode->m_dwOperation))
    {
        CNode * pTmpNode = m_pListTail;

        while( pTmpNode && pTmpNode != pNode )
        {
            if ( IsRename(pTmpNode->m_dwOperation) || 
                 OPR_DIR_DELETE == pTmpNode->m_dwOperation ||
                 OPR_DIR_CREATE == pTmpNode->m_dwOperation )
            {
                if ( StrStrI(pNode->m_pPath2, pTmpNode->m_pPath1) )
                {
                    pNode = NULL;
                    break;
                }
                    
                if  ( IsRename(pTmpNode->m_dwOperation) &&
                      StrStrI(pNode->m_pPath2, pTmpNode->m_pPath2) )
                {
                    pNode = NULL;
                    break;
                }
            }
        
            pTmpNode = pTmpNode->m_pPrev;
        }
    }
   
    return pNode;
}

//
// CopyNode : Copies node information, destination opr, copy data, etc.
//

BOOL
CRestoreList::CopyNode(
    CNode  * pSrcNode,
    CNode  * pDesNode,
    BOOL   fReplacePPath2
    )
{
    BOOL fRet = FALSE;

    if (pSrcNode && pDesNode)
    {
        pSrcNode->m_dwOperation  = pDesNode->m_dwOperation ;
        pSrcNode->m_dwAttributes = pDesNode->m_dwAttributes;

        STRCOPY(pSrcNode->m_pszTemp, pDesNode->m_pszTemp);
        CopyAcl(pSrcNode, pDesNode->m_pbAcl, pDesNode->m_cbAcl, pDesNode->m_fAclInline);

        if ( IsRename(pDesNode->m_dwOperation) && fReplacePPath2 )
        {
            HEAP_FREE( pSrcNode->m_pPath2 );
            pSrcNode->m_pPath2 = pDesNode->m_pPath2;
            pDesNode->m_pPath2 = NULL;
        }
        
        fRet = TRUE;        
    }

    return fRet;
}

//
// CreateRestoreNode : Creates appropriate restore node 
//

CRestoreList::CreateRestoreNode(
    CNode       * pNode,
    DWORD         dwOpr,
    DWORD         dwAttr,
    DWORD         dwFlags,
    LPWSTR        pTmpFile,
    LPWSTR        pPath1,
    LPWSTR        pPath2,
    BYTE*         pbAcl,
    DWORD         cbAcl,
    BOOL          fAclInline)
{
    BOOL fRet = FALSE;

    if (pNode)
    {
        fRet = TRUE;
        DWORD  dwRestoreOpr = GetReverseOperation( dwOpr );

        //
        // If Source / Dest paths are same then remove this just
        // added node.
        //

        if ( IsRename(dwRestoreOpr) &&
             0 == lstrcmpi(pNode->m_pPath1, 
                         pNode->m_pPath2) )
        {
            RemoveNode( pNode );
            FreeNode( pNode );
            goto Exit;
        }

        //
        // Rename optimizations should not be done for directories.
        //

        if ( OPR_FILE_RENAME == dwRestoreOpr )  
        {
            //
            // Check if the des node already exists in the tree, if so
            // copy all the data from that node and delete it. Current
            // node effectively represents that node. 
            //

            DWORD dwCurNodeOpr  = pNode->m_dwOperation;
            CNode *pNodeDes = GetLastNode( pPath2, pPath1, TRUE ); 

            if (pNodeDes &&
                OPR_UNKNOWN != pNodeDes->m_dwOperation)
            {
                //
                // Check for Cycle if so remove the current node also
                //
              
                if ( OPR_FILE_RENAME == pNodeDes->m_dwOperation  && 
                     !lstrcmpi (pNode->m_pPath1, 
                                pNodeDes->m_pPath2) )
                {
                    //
                    // The existing node may be a hybrid one so preserve the
                    // hybrid operations cancel only rename
                    //

                    if (! pNodeDes->m_pszTemp &&
                        pNodeDes->m_dwAttributes == 0xFFFFFFFF &&
                        pNodeDes->m_pbAcl == NULL)    
                    {
                        //
                        // Not a hybrid node - remove it.
                        //

                        RemoveNode( pNodeDes );
                        FreeNode( pNodeDes );
                    }
                    else
                    {
                        //
                        // Hybrid Node so change the node to the other
                        // operations only.
                        //

                        HEAP_FREE( pNodeDes->m_pPath1 );
                        pNodeDes->m_pPath1 = pNodeDes->m_pPath2;
                        pNodeDes->m_pPath2 = NULL;                                              
                        pNodeDes->m_dwOperation = OPR_SETATTRIB;

                        if (pNodeDes->m_pbAcl)
                        {
                            pNodeDes->m_dwOperation = OPR_SETACL;
                        }

                        if (pNodeDes->m_pszTemp)
                        {
                            pNodeDes->m_dwOperation = OPR_FILE_MODIFY;
                        }
                    }
                   
                    //
                    // Remove the just add node as the operation cancels
                    // returning false will have that effect

                    fRet = FALSE;

                    goto Exit;
                }

                //
                // Remove the matching node from the list
                //

                RemoveNode( pNodeDes );

                //
                // Merge the matching node into the current rename node
                //

                CopyNode( pNode, pNodeDes, TRUE );

                //
                // Since all the information for modify/attrib/acl is
                // copied over, change the opr to rename.
                //

                if (pNodeDes->m_dwOperation == OPR_SETATTRIB ||
                    pNodeDes->m_dwOperation == OPR_SETACL ||
                    pNodeDes->m_dwOperation == OPR_FILE_MODIFY)
                {
                    pNode->m_dwOperation = dwRestoreOpr;                    
                    STRCOPY(pNode->m_pPath2, pPath2);
                }

                //
                // If current opr on the node was delete and the newly
                // copied operation is create we need to merge these and
                // and change the operation to modify
                //
                // BUGBUG - will this code ever be executed?
                // dwCurNodeOpr always seems to be OPR_UNKNOWN

                if ( OPR_FILE_ADD    == pNodeDes->m_dwOperation &&
                     OPR_FILE_DELETE == dwCurNodeOpr )
                {
                    pNode->m_dwOperation = OPR_FILE_MODIFY;
                }
                
                if ( OPR_DIR_CREATE == pNodeDes->m_dwOperation &&
                     OPR_DIR_DELETE == dwCurNodeOpr )
                {
                    pNode->m_dwOperation = OPR_SETATTRIB;
                }
                
                //
                // If the operation is changed from a rename then pPath2 should
                // not exist
                //
                
                if ( OPR_FILE_RENAME != pNode->m_dwOperation ) 
                {
                    if ( pNode->m_pPath2 )
                    {
                        HEAP_FREE(pNode->m_pPath2);
                        pNode->m_pPath2 = NULL ;
                    }
                }
                
                FreeNode( pNodeDes );
                goto Exit;
            }            
        }

        //
        // Copy the necessary information into this node.
        //

        pNode->m_dwOperation  = dwRestoreOpr;
        pNode->m_dwAttributes = dwAttr;
        STRCOPY(pNode->m_pszTemp, pTmpFile);
        CopyAcl(pNode, pbAcl, cbAcl, fAclInline);
    }

Exit:
    return fRet;
}


//
// MergeRestoreNode : Merge the new information into the current retore node
//

BOOL
CRestoreList::MergeRestoreNode(
    CNode       * pNode,
    DWORD         dwOpr,
    DWORD         dwAttr,
    DWORD         dwFlags,
    LPWSTR        pTmpFile,
    LPWSTR        pPath1,
    LPWSTR        pPath2,
    BYTE*         pbAcl,
    DWORD         cbAcl,
    BOOL          fAclInline)
{
    BOOL fRet = FALSE;

    if (pNode)
    {
        DWORD dwRestoreOpr = GetReverseOperation( dwOpr );

        // note that dwOpr cannot be a rename operation,
        // because we handle that separately in CreateRestoreNode

        ASSERT( ! IsRename(dwOpr) );

        switch( dwOpr )
        {
        case OPR_FILE_ADD :
            {
                //
                // If current opr is add and the node already encountered a
                // delete opr then remove this node because this is a no-op
                //

                if ( OPR_FILE_ADD == pNode->m_dwOperation )
                {
                    RemoveNode( pNode );
                    FreeNode  ( pNode );
                    goto Exit;
                }

                
                if ( IsRename(pNode->m_dwOperation) )
                {
                    // 
                    // Change the original node to a delete operation, to
                    // retain proper order.
                    //

                    pNode->m_dwOperation  = OPR_FILE_DELETE;

                    //
                    // Delete operation should be generated on PPath2
                    //

                    if (pNode->m_pPath1)
                    {
                         HEAP_FREE( pNode->m_pPath1);
                         pNode->m_pPath1 = NULL;
                    }

                    if (pNode->m_pPath2)
                    {
                         pNode->m_pPath1 = pNode->m_pPath2;
                         pNode->m_pPath2 = NULL;
                    }

                    goto Exit;
                }

                break;
            }
        case OPR_FILE_DELETE :
            {
                //
                // Delete followd by an add should result in modify
                //

                if (OPR_FILE_DELETE == pNode->m_dwOperation)
                {
                    pNode->m_dwOperation = OPR_FILE_MODIFY;                   
                    pNode->m_dwAttributes = dwAttr;
                    STRCOPY(pNode->m_pszTemp, pTmpFile); 
                    CopyAcl(pNode, pbAcl, cbAcl, fAclInline);
                    goto Exit;
                }

                break;
            }
        case OPR_FILE_MODIFY:
            {
                //
                // Copy the modified file copy location, don't change
                // the current restore operation.
                //

                if ( OPR_FILE_ADD == pNode->m_dwOperation ||
                     IsRename(pNode->m_dwOperation) )
                {
                    STRCOPY(pNode->m_pszTemp, pTmpFile); 
                    goto Exit;
                }
                break;
            }
        case OPR_SETATTRIB:
            {
                //
                // Don't change the current restore operation just set the attr.
                //

                if ( OPR_UNKNOWN != pNode->m_dwOperation )
                {
                    pNode->m_dwAttributes = dwAttr;
                    goto Exit;               
                }

                break;
            }
        case OPR_SETACL:
            {
                // setacl followed by any op
                // just copy the acl to the new op
            
                if (OPR_UNKNOWN != pNode->m_dwOperation)
                {
                    CopyAcl(pNode, pbAcl, cbAcl, fAclInline);
                    goto Exit;
                }

                break;
            }
        case OPR_DIR_DELETE :
            {
                //
                // if Dir delete followed by a dir create then this
                // operation should condense to set attrib + setacl

                if ( OPR_DIR_DELETE == pNode->m_dwOperation )
                {
                    //
                    // Need to change the oprn to set attrib if
                    // Attribute changed 
                    //

                    pNode->m_dwOperation  = OPR_SETATTRIB;
                    pNode->m_dwAttributes = dwAttr;
                    CopyAcl(pNode, pbAcl, cbAcl, fAclInline);
                    goto Exit;
                }
                
                break;
            }
        case OPR_DIR_CREATE :
            {
                if ( OPR_DIR_CREATE == pNode->m_dwOperation )
                {
                    RemoveNode( pNode );
                    FreeNode( pNode );
                    goto Exit;
                }
                
                if ( IsRename(pNode->m_dwOperation) )
                {
                    //
                    // Check if the existing node has some file operations
                    // afterwards then don't optimize
                    //

                    if ( GetLastNode( 
                             pNode->m_pPath1,
                             NULL,
                             TRUE) ) 
                    {
                        // 
                        // Change the last node to a delete operation, to
                        // retain proper order.
                        //

                        pNode->m_dwOperation  = OPR_DIR_DELETE;
    
                        //
                        // Delete operation should be generated on PPath2
                        //

                        if (pNode->m_pPath1)
                        {
                             HEAP_FREE( pNode->m_pPath1);
                             pNode->m_pPath1 = NULL;
                        }

                        if (pNode->m_pPath2)
                        {
                             pNode->m_pPath1 = pNode->m_pPath2;
                             pNode->m_pPath2 = NULL;
                        }
                    }
                    else
                    {
                        CNode * pNewNode = NULL;

                        //
                        // Create a new dir delete node
                        //

                        if (pNewNode = AppendNode(pPath1, pPath2) )
                        {
                             fRet = CreateRestoreNode( 
                                        pNewNode,
                                        dwOpr, 
                                        dwAttr, 
                                        dwFlags,
                                        pTmpFile, 
                                        pPath1,
                                        pPath2,
                                        pbAcl,
                                        cbAcl,
                                        fAclInline);
                        }
                    }

                    goto Exit;
                }
                break;
            }
        }

         pNode->m_dwOperation  = dwRestoreOpr;

        //
        // Change the node's attribute only if the new attrib exists
        //

        if (dwAttr != 0xFFFFFFFF) 
            pNode->m_dwAttributes = dwAttr;
    
        STRCOPY(pNode->m_pszTemp, pTmpFile);
        CopyAcl(pNode, pbAcl, cbAcl, fAclInline);
    }

Exit:

    return TRUE;
}


BOOL
CRestoreList::CheckIntegrity(    
    LPWSTR pszDrive,
    DWORD  dwOpr,
    DWORD  dwAttr,
    DWORD  dwFlags,
    LPWSTR pTmpFile,
    LPWSTR pPath1,
    LPWSTR pPath2,
    BYTE * pbAcl,
    DWORD  cbAcl,
    BOOL   fAclInline)
{
    BOOL    fRet = TRUE;
    WCHAR   szPath[MAX_PATH];
    
    // source name MUST be present
    
    if (! pPath1)
    {
        fRet = FALSE;
        goto done;
    }

    // if acl is present and it's not inline,
    // then temp file must exist

    if (pbAcl && ! fAclInline)
    {
        MakeRestorePath(szPath, pszDrive, (LPWSTR) pbAcl);    
        if (-1 == GetFileAttributes(szPath))
        {
            fRet = FALSE;
            goto done;
        }
    }
       
    
    switch (dwOpr)
    {
    case OPR_FILE_RENAME:
    case OPR_DIR_RENAME:
        // renames should have dest path and no temp file        
        if (! pPath2 || pTmpFile)
            fRet = FALSE;
        break;

    case OPR_FILE_MODIFY:
        // modify should not have dest path but must have temp file
        if (pPath2 || ! pTmpFile)
        {
            fRet = FALSE;
            break;
        }

        // and the temp file must exist inside the datastore        
        MakeRestorePath(szPath, pszDrive, pTmpFile);

        if (-1 == GetFileAttributes(szPath))
        {
            fRet = FALSE;
            break;
        }
            
        break;
        
    case OPR_SETACL:
        // acl operation should have acl (either inline or not)
        if (! pbAcl)
        {
            fRet = FALSE;
            break;
        }

    default:
        break;
   }


done:
    return fRet;   
}


    
// AddMergeElement : Adds or merge the current element as appropriate
//

BOOL
CRestoreList::AddMergeElement(
    LPWSTR pszDrive,
    DWORD  dwOpr,
    DWORD  dwAttr,
    DWORD  dwFlags,
    LPWSTR pTmpFile,
    LPWSTR pPath1,
    LPWSTR pPath2,
    BYTE * pbAcl,
    DWORD  cbAcl,
    BOOL   fAclInline)
{
    BOOL    fRet = FALSE;
    CNode * pNode = NULL;

    // check to see if the entry is consistent
    
    fRet = CheckIntegrity(pszDrive,
                          dwOpr,
                          dwAttr, 
                          dwFlags, 
                          pTmpFile, 
                          pPath1, 
                          pPath2, 
                          pbAcl, 
                          cbAcl, 
                          fAclInline);
    if (FALSE == fRet)
    {
        ASSERT(-1);
        goto Exit;
    }
        
    if ( pPath1 )
    {
         if ( 
              //
              // Merge for renames are handled inside the Create/Merge funcs
              //

              ! IsRename(dwOpr) &&

              //
              // Merge should only be allowed within directory life, check 
              // node paths to see if there are any directory life oprs.
              //

              ( pNode = GetLastNode( pPath1, pPath2, TRUE ) ) &&
              CanMerge( pNode->m_dwOperation , dwOpr, dwFlags ) 


            )
         {
              fRet = MergeRestoreNode( 
                         pNode,
                         dwOpr, 
                         dwAttr, 
                         dwFlags,
                         pTmpFile, 
                         pPath1,
                         pPath2,
                         pbAcl,
                         cbAcl,
                         fAclInline);

              if (!fRet)
                  goto Exit;

         }
         else
         {
             if (pNode = AppendNode(pPath1, pPath2) )
             {
                 fRet = CreateRestoreNode( 
                            pNode,
                            dwOpr, 
                            dwAttr, 
                            dwFlags,
                            pTmpFile, 
                            pPath1,
                            pPath2,
                            pbAcl,
                            cbAcl,
                            fAclInline);

                 if (!fRet)
                 { 
                     //
                     // We failed to create the node properly, free this node
                     //

                     RemoveNode( pNode );
                     FreeNode( pNode );

                     //
                     // We still want to continue
                     //

                     fRet = TRUE;

                     goto Exit;
                 }
            }
        }
    }

Exit:
    return fRet;
}


//
// GenerateRestoreMap : Walk the tree and generates the restore map.
//

BOOL
CRestoreList::GenerateRestoreMap (
    HANDLE hFile 
    )
{
    BOOL fRet = FALSE;

    if (hFile)
    {
        CNode * pNode = m_pListHead;

        while (pNode)
        {
            if (! GenerateOperation( pNode , hFile ))
                goto Exit;
            
            pNode = pNode->m_pNext;
        }

        fRet = TRUE;
    }

Exit:
    return fRet;
}

//
// GenerateRenameEntry : Callback to write out the renames
//

BOOL
CRestoreList::GenerateRenameEntry(
    CNode    * pNode ,
    HANDLE     hFile
    )
{
    BOOL fRet = FALSE;

    if( !pNode || ! IsRename(pNode->m_dwOperation) )
        goto Exit;

     //
     // Check if this rename is no-op , src/des are the same
     //

     if ( IsRename(pNode->m_dwOperation) &&
          lstrcmpi(pNode->m_pPath1, pNode->m_pPath2) == 0)
     {
         goto SkipMainNodeEntry;
     }

     // add rename operation

     fRet = AppendRestoreMapEntry( 
           hFile, 
           pNode->m_dwOperation,
           0xFFFFFFFF,
           NULL,
           pNode->m_pPath1,
           pNode->m_pPath2,
           NULL,
           0,
           0);

SkipMainNodeEntry:

     // add modify operation if temp file exists

     if ( pNode->m_pszTemp )
     {
         fRet = AppendRestoreMapEntry( 
                hFile, 
                OPR_FILE_MODIFY,
                0xFFFFFFFF,
                pNode->m_pszTemp,
                pNode->m_pPath1,
                NULL,
                NULL,
                0,
                0);
     }

     // add setattrib operation if attrib exists

     if ( pNode->m_dwAttributes != 0xFFFFFFFF &&
          pNode->m_dwAttributes != FILE_ATTRIBUTE_DIRECTORY )
     {
          fRet = AppendRestoreMapEntry( 
                 hFile,
                 OPR_SETATTRIB,
                 pNode->m_dwAttributes,
                 NULL,
                 pNode->m_pPath1,
                 NULL,
                 NULL,
                 0,
                 0);
     }

     // add setacl operation if acl exists

     if ( pNode->m_pbAcl != NULL && 
          pNode->m_cbAcl != 0)
     {
          fRet = AppendRestoreMapEntry( 
                 hFile,
                 OPR_SETACL,
                 0xFFFFFFFF,
                 NULL,
                 pNode->m_pPath1,
                 NULL,
                 pNode->m_pbAcl,
                 pNode->m_cbAcl,
                 pNode->m_fAclInline);
     }
         

Exit:
    return fRet;
}


BOOL
CRestoreList::GenerateOperation(
    CNode    * pNode ,
    HANDLE     hFile
    )
{
    BOOL fRet = FALSE;

    BYTE bData[4096];

    RestoreMapEntry * pResEntry = (RestoreMapEntry *)bData;

    if( !pNode || OPR_UNKNOWN == pNode->m_dwOperation)
        goto Exit;

    if (IsRename(pNode->m_dwOperation) )
    {
         fRet = GenerateRenameEntry( pNode, hFile );
         goto Exit;
    }

    //
    // Generate operations for Add/Modify/SetAttrib
    //
    
    // ensure that each persisted entry contains only necessary data
    // e.g. a setattrib entry will not contain a temp filename, or acl

    fRet = AppendRestoreMapEntry(
               hFile, 
               pNode->m_dwOperation,
               (pNode->m_dwOperation == OPR_SETATTRIB) ? pNode->m_dwAttributes : 0xFFFFFFFF,
               (pNode->m_dwOperation == OPR_FILE_MODIFY || 
                pNode->m_dwOperation == OPR_FILE_ADD) ? pNode->m_pszTemp : NULL,
               pNode->m_pPath1,
               NULL,      // pPath2 should matter only for renames, which are handled separately
               (pNode->m_dwOperation == OPR_SETACL) ? pNode->m_pbAcl : NULL,
               (pNode->m_dwOperation == OPR_SETACL) ? pNode->m_cbAcl : 0,
               (pNode->m_dwOperation == OPR_SETACL) ? pNode->m_fAclInline : 0);


    //
    // Generate an explicit set attrib operation 
    // entries except set attrib itself and delete.
    //

    if ( OPR_SETATTRIB   != pNode->m_dwOperation &&
         OPR_FILE_DELETE != pNode->m_dwOperation &&
         OPR_DIR_DELETE  != pNode->m_dwOperation &&
         pNode->m_dwAttributes != 0xFFFFFFFF &&
         pNode->m_dwAttributes != FILE_ATTRIBUTE_DIRECTORY )
    {
         fRet = AppendRestoreMapEntry(
                    hFile,
                    OPR_SETATTRIB,
                    pNode->m_dwAttributes,
                    NULL,
                    pNode->m_pPath1,
                    NULL,
                    NULL,
                    0,
                    0);
    }

    //
    // Generate an explicit set acl if needed
    //

    if ( pNode->m_pbAcl != NULL && 
         pNode->m_cbAcl != 0 &&
         OPR_SETACL   != pNode->m_dwOperation &&
         OPR_FILE_DELETE != pNode->m_dwOperation &&
         OPR_DIR_DELETE  != pNode->m_dwOperation)
    {
         fRet = AppendRestoreMapEntry(
                    hFile,
                    OPR_SETACL,
                    0xFFFFFFFF,
                    NULL,
                    pNode->m_pPath1,
                    NULL,
                    pNode->m_pbAcl,
                    pNode->m_cbAcl,
                    pNode->m_fAclInline);
    }

Exit:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\api.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    api.cpp

Abstract:
    This file contains the top level APIs, InitiateRestore and ResumeRestore.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"
extern CSRClientLoader  g_CSRClientLoader;

/////////////////////////////////////////////////////////////////////////////
//
// EnsureTrace
//
/////////////////////////////////////////////////////////////////////////////

//static BOOL  s_fTraceEnabled = FALSE;
static DWORD  s_dwTraceCount = 0;

void  EnsureTrace()
{
    if ( s_dwTraceCount++ == 0 )
    {
        ::InitAsyncTrace();
    }
}

void  ReleaseTrace()
{
    if ( --s_dwTraceCount == 0 )
    {
        ::TermAsyncTrace();
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreContext
//
/////////////////////////////////////////////////////////////////////////////

class CRestoreContext : public IRestoreContext
{
public:
    CRestoreContext();

protected:
    ~CRestoreContext();

// operations - IRestoreContext methods
public:
    BOOL  IsAnyDriveOfflineOrDisabled( LPWSTR szOffline );
    void  SetSilent();
    void  SetUndo();
    BOOL  Release();

// attributes
public:
    int        m_nRP;
    CRDIArray  m_aryDrv;
    BOOL       m_fSilent;
    BOOL       m_fUndo;
};

/////////////////////////////////////////////////////////////////////////////
// CRestoreContext - construction / destruction

CRestoreContext::CRestoreContext()
{
    m_nRP     = -1;
    m_fSilent = FALSE;
    m_fUndo   = FALSE;
}

CRestoreContext::~CRestoreContext()
{
    m_aryDrv.DeleteAll();
}

/////////////////////////////////////////////////////////////////////////////
// CRestoreContext - IRestoreContext methods

BOOL
CRestoreContext::IsAnyDriveOfflineOrDisabled( LPWSTR szOffline )
{
    TraceFunctEnter("CRestoreContext::IsAnyDriveOffline");
    BOOL  fRet = FALSE;

    szOffline[0] = L'\0';

    for ( int i = m_aryDrv.GetUpperBound();  i >= 0;  i-- )
    {
        if ( m_aryDrv[i]->IsOffline() || m_aryDrv[i]->IsExcluded())
        {
            ::lstrcat( szOffline, L" " );
            ::lstrcat( szOffline, m_aryDrv[i]->GetMount() );
            fRet = TRUE;
        }
    }

    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

void
CRestoreContext::SetSilent()
{
    TraceFunctEnter("CRestoreContext::SetSilent");
    m_fSilent = TRUE;
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

void
CRestoreContext::SetUndo()
{
    TraceFunctEnter("CRestoreContext::SetUndo");
    m_fUndo = TRUE;
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreContext::Release()
{
    TraceFunctEnter("CRestoreContext::Release");
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
//
// Helper Functions
//
/////////////////////////////////////////////////////////////////////////////

BOOL
IsAdminUser()
{
    TraceFunctEnter("IsAdminUser");
    BOOL                      fRet = FALSE;
    LPCWSTR                   cszErr;
    PSID                      pSidAdmin = NULL;
    SID_IDENTIFIER_AUTHORITY  cSIA = SECURITY_NT_AUTHORITY;
    BOOL                      fRes;

    if ( !::AllocateAndInitializeSid( &cSIA, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &pSidAdmin ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::AllocateAndInitializeSid failed - %ls", cszErr);
        goto Exit;
    }

    if ( !::CheckTokenMembership( NULL, pSidAdmin, &fRes ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CheckMembership failed - %ls", cszErr);
        goto Exit;
    }

    DebugTrace(0, "IsAdminUser = %d", fRes);

    fRet = fRes;
Exit:
    if ( pSidAdmin != NULL )
        ::FreeSid( pSidAdmin );
    TraceFunctLeave();
    return( fRet );
}

//
// NOTE: 7/28/00 - skkhang
//  Behavior of AdjustTokenPrivilege is a little bit confusing.
//  It returns TRUE if given privilege does not exist at all, so you need to
//  call GetLastError to see if it's ERROR_SUCCESS or ERROR_NOT_ALL_ASSIGNED
//  (meaning the privilege does not exist.)
//  Also, if the privilege was already enabled, tpOld will be empty. You
//  don't need to restore the privilege in that case.
//
BOOL
CheckPrivilege( LPCWSTR szPriv, BOOL fCheckOnly )
{
    TraceFunctEnter("CheckPrivilege");
    BOOL              fRet = FALSE;
    LPCWSTR           cszErr;
    HANDLE            hToken = NULL;
    LUID              luid;
    TOKEN_PRIVILEGES  tpNew;
    TOKEN_PRIVILEGES  tpOld;
    DWORD             dwRes;

    // Prepare Process Token
    if ( !::OpenProcessToken( ::GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hToken ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::OpenProcessToken failed - %ls", cszErr);
        goto Exit;
    }

    // Get Luid
    if ( !::LookupPrivilegeValue( NULL, szPriv, &luid ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LookupPrivilegeValue failed - %ls", cszErr);
        goto Exit;
    }

    // Try to enable the privilege
    tpNew.PrivilegeCount           = 1;
    tpNew.Privileges[0].Luid       = luid;
    tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if ( !::AdjustTokenPrivileges( hToken, FALSE, &tpNew, sizeof(tpNew), &tpOld, &dwRes ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::AdjustTokenPrivileges(ENABLE) failed - %ls", cszErr);
        goto Exit;
    }

    if ( ::GetLastError() == ERROR_NOT_ALL_ASSIGNED )
    {
        // This means process does not even have the privilege so
        // AdjustTokenPrivilege simply ignored the request.
        ErrorTrace(0, "Privilege '%ls' does not exist, probably user is not an admin.", szPriv);
        goto Exit;
    }

    if ( fCheckOnly )
    {
        // Restore the privilege if it was not enabled
        if ( tpOld.PrivilegeCount > 0 )
        {
            if ( !::AdjustTokenPrivileges( hToken, FALSE, &tpOld, sizeof(tpOld), NULL, NULL ) )
            {
                cszErr = ::GetSysErrStr();
                ErrorTrace(0, "::AdjustTokenPrivileges(RESTORE) failed - %ls", cszErr);
                goto Exit;
            }
        }
    }

    fRet = TRUE;
Exit:
    if ( hToken != NULL )
        ::CloseHandle( hToken );
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// IsSRFrozen
//
//  This routine checks if SR is frozen. If any error happens during Drive
//  Table creation or System Drive does not exist (broken drive table???),
//  return value is FALSE.
//
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
IsSRFrozen()
{
    EnsureTrace();
    TraceFunctEnter("IsSRFrozen");
    BOOL       fRet = FALSE;
    CRDIArray  aryDrv;
    int        i;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();

    if ( !::CreateDriveList( 0, aryDrv, TRUE ) )
        goto Exit;

    for ( i = aryDrv.GetUpperBound();  i >= 0;  i-- )
    {
        if ( aryDrv[i]->IsSystem() )
        {
            fRet = aryDrv[i]->IsFrozen();
            goto Exit;
        }
    }

Exit:
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// CheckPrivilegesForRestore
//
//  This routine checks if necessary privileges can be set, to verify if
//  logon user has necessary credential (Administrators or Backup Operators.)
//
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
CheckPrivilegesForRestore()
{
    EnsureTrace();
    TraceFunctEnter("CheckPrivilegesForRestore");
    BOOL  fRet = FALSE;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();    

// NOTE: 8/17/00 - skkhang
//
//  Backup operator does not have below two privileges... SE_SECURITY_NAME
//  is enabled by default for SYSTEM so probably can simply removed, but
//  SE_TAKE_OWNERSHIP is off for SYSTEM and needs to be turned on. To solve
//  the problem, this routine should accept parameter to distinguish
//  "Check"(from UI) and "Set"(from ResumeRestore.)
//
    if ( !::CheckPrivilege( SE_SECURITY_NAME, FALSE ) )
    {
        ErrorTrace(0, "Cannot enable SE_SECURITY_NAME privilege...");
        goto Exit;
    }
    if ( !::CheckPrivilege( SE_TAKE_OWNERSHIP_NAME, FALSE ) )
    {
        ErrorTrace(0, "Cannot enable SE_SHUTDOWN_NAME privilege...");
        goto Exit;
    }
    
    if ( !::CheckPrivilege( SE_BACKUP_NAME, FALSE ) )
    {
        ErrorTrace(0, "Cannot enable SE_BACKUP_NAME privilege...");
        goto Exit;
    }
    if ( !::CheckPrivilege( SE_RESTORE_NAME, FALSE ) )
    {
        ErrorTrace(0, "Cannot enable SE_RESTORE_NAME privilege...");
        goto Exit;
    }
    if ( !::CheckPrivilege( SE_SHUTDOWN_NAME, FALSE ) )
    {
        ErrorTrace(0, "Cannot enable SE_SHUTDOWN_NAME privilege...");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// InvokeDiskCleanup
//
//  This routine invokes Disk Cleanup Utility. A specific drive can be
//  provided.
//
/////////////////////////////////////////////////////////////////////////////

static LPCWSTR  s_cszDCUPath   = L"%windir%\\system32\\cleanmgr.exe";
static LPCWSTR  s_cszDCUName   = L"cleanmgr.exe";
static LPCWSTR  s_cszDCUOptDrv = L" /d ";

BOOL APIENTRY
InvokeDiskCleanup( LPCWSTR cszDrive )
{
    TraceFunctEnter("InvokeDiskCleanup");
    
     // Load SRClient
    g_CSRClientLoader.LoadSrClient();
    
    BOOL                 fRet = FALSE;
    LPCWSTR              cszErr;
    WCHAR                szCmdLine[MAX_PATH];
    STARTUPINFO          sSI;
    PROCESS_INFORMATION  sPI;

    if ( ::ExpandEnvironmentStrings( s_cszDCUPath, szCmdLine, MAX_PATH ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::GetFullPathName failed - %ls", cszErr);
        ::lstrcpy( szCmdLine, s_cszDCUName );
    }

    if ( cszDrive != NULL && cszDrive[0] != L'\0' )
    {
        ::lstrcat( szCmdLine, s_cszDCUOptDrv );
        ::lstrcat( szCmdLine, cszDrive );
    }

    DebugTrace(0, "szCmdLine='%s'", szCmdLine);
    ::ZeroMemory( &sSI, sizeof(sSI ) );
    sSI.cb = sizeof(sSI);
    if ( !::CreateProcess( NULL, szCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &sSI, &sPI ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateProcess failed - %ls", cszErr);
        goto Exit;
    }
    ::CloseHandle( sPI.hThread );
    ::CloseHandle( sPI.hProcess );

    // Should I wait for DCU to finish???

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( TRUE );
}


#ifdef DBG
/////////////////////////////////////////////////////////////////////////////
//
// TestRestore
//
//  This routine performs core restoration functionality, without reboot or
//  snapshot restoration.
//
/////////////////////////////////////////////////////////////////////////////
extern "C" __declspec(dllexport)
BOOL APIENTRY
TestRestore( int nRP )
{
    EnsureTrace();
    TraceFunctEnter("TestRestore");
    BOOL                      fRet = FALSE;
    CRDIArray                 aryDrv;
    RESTOREPOINTINFO          sRPI;
    STATEMGRSTATUS            sStatus;
    SRstrLogHdrV3             sLogHdr;
    CRestoreOperationManager  *pROMgr = NULL;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();    

    if ( !::CheckPrivilegesForRestore() )
        goto Exit;

    // Create Drive Table
    if ( !::CreateDriveList( nRP, aryDrv, FALSE ) )
        goto Exit;

    // Create Restore Point
    sRPI.dwEventType      = BEGIN_SYSTEM_CHANGE;
    sRPI.dwRestorePtType  = RESTORE;
    sRPI.llSequenceNumber = 0;
    ::LoadString( g_hInst, IDS_RESTORE_POINT_TEXT, sRPI.szDescription, MAX_DESC );
    if ( !::SRSetRestorePoint( &sRPI, &sStatus ) )
    {
        ErrorTrace(0, "::SRSetRestorePoint failed, nStatus=%d", sStatus.nStatus);
        goto Exit;
    }

    // Create the log file
    sLogHdr.dwRPNum  = nRP;
    sLogHdr.dwRPNew  = sStatus.llSequenceNumber;
    sLogHdr.dwDrives = aryDrv.GetSize();
    if ( !::CreateRestoreLogFile( &sLogHdr, aryDrv ) )
        goto Exit;

    
     // also call TS folks to get them to preserve RA keys on restore
    _VERIFY(TRUE==RemoteAssistancePrepareSystemRestore(SERVERNAME_CURRENT));

    // Create CRestoreOperationManager object
    if ( !::CreateRestoreOperationManager( &pROMgr ) )
        goto Exit;    

    // Perform the Restore Operation.
    if ( !pROMgr->Run( FALSE ) )
        goto Exit;        
    
    fRet = TRUE;
Exit:
    SAFE_RELEASE(pROMgr);
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}
#endif

#ifdef DBG
#define TIMEOUT_PROGRESSTHREAD  5000

#define TESTPROG_COUNT_CHGLOG   300
#define TESTPROG_TIME_PREPARE   1
#define TESTPROG_COUNT_RESTORE  100
#define TESTPROG_TIME_RESTORE   1
#define TESTPROG_TIME_SNAPSHOT  2000

DWORD WINAPI
TestProgressWindowThreadProc( LPVOID lpParam )
{
    CRestoreProgressWindow  *pProgress = (CRestoreProgressWindow*)lpParam;
    int   i, j;

    // Stage 1. Prepare (change log enumeration)
    pProgress->SetStage( RPS_PREPARE, 0 );
    for ( i = 0;  i < TESTPROG_COUNT_CHGLOG;  i++ )
    {
        ::Sleep( TESTPROG_TIME_PREPARE );
        for ( j = 0;  j < 10;  j++ )
            pProgress->Increment();
    }

    // Stage 2. Restore
    pProgress->SetStage( RPS_RESTORE, TESTPROG_COUNT_RESTORE );
    for ( i = 0;  i < TESTPROG_COUNT_RESTORE;  i++ )
    {
        ::Sleep( TESTPROG_TIME_RESTORE );
        pProgress->Increment();
    }

    // Stage 3. Snapshot
    pProgress->SetStage( RPS_SNAPSHOT, 0 );
    ::Sleep( TESTPROG_TIME_SNAPSHOT );

    pProgress->Close();

    return( 0 );
}

/////////////////////////////////////////////////////////////////////////////
//
// TestProgressWindow
//
//  This routine invokes Progress Window and simulates progress change
//
/////////////////////////////////////////////////////////////////////////////
extern "C" __declspec(dllexport)
BOOL APIENTRY
TestProgressWindow()
{
    EnsureTrace();
    TraceFunctEnter("TestProgressWindow");
    BOOL                    fRet = FALSE;
    CRestoreProgressWindow  *pProgress = NULL;
    HANDLE                  hThread = NULL;
    DWORD                   dwRet;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();    

    // Create progress window object
    if ( !::CreateRestoreProgressWindow( &pProgress ) )
        goto Exit;

    // Create progress window
    if ( !pProgress->Create() )
        goto Exit;
   
    // Create secondary thread for main restore operation
    hThread = ::CreateThread( NULL, 0, TestProgressWindowThreadProc, pProgress, 0, NULL );
    if ( hThread == NULL )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateThread failed - %ls", cszErr);
        goto Exit;
    }

    // Message loop, wait until restore thread closes progress window
    if ( !pProgress->Run() )
        goto Exit;

    // Double check if thread has been terminated
    dwRet = ::WaitForSingleObject( hThread, TIMEOUT_PROGRESSTHREAD );
    if ( dwRet == WAIT_FAILED )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::WaitForSingleObject failed - %ls", cszErr);
        goto Exit;
    }
    else if ( dwRet == WAIT_TIMEOUT )
    {
        ErrorTrace(0, "Timeout while waiting for the restore thread finishes...");
        goto Exit;
    }

    pProgress->Close();

    fRet = TRUE;
Exit:
    if ( hThread != NULL )
        ::CloseHandle( hThread );
    SAFE_RELEASE(pProgress);
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}
#endif


/////////////////////////////////////////////////////////////////////////////
//
// PrepareRestore
//
//  This routine creates a IRestoreContext for use by InitiateRestore.
//  IRestoreContext contains chosen restore point ID, drive list, etc.
//
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
PrepareRestore( int nRP, IRestoreContext **ppCtx )
{
    EnsureTrace();
    TraceFunctEnter("PrepareRestore");
    BOOL             fRet = FALSE;
    CRestoreContext  *pRC = NULL;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();
    
    if ( ppCtx == NULL )
    {
        ErrorTrace(0, "Invalid parameter, ppCtx is NULL.");
        goto Exit;
    }
    *ppCtx = NULL;

    if ( !::IsAdminUser() )
    {
        ErrorTrace(0, "Not an admin user");        
        goto Exit;
    }

    pRC = new CRestoreContext;
    if ( pRC == NULL )
    {
        ErrorTrace(0, "Insufficient memory...");
        goto Exit;
    }

    pRC->m_nRP = nRP;
    if ( !::CreateDriveList( nRP, pRC->m_aryDrv, FALSE ) )
    {
        ErrorTrace(0, "Creating drive list failed");
        goto Exit;
    }

    *ppCtx = pRC;

    fRet = TRUE;
Exit:
    if ( !fRet )
        SAFE_RELEASE(pRC);
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// InitiateRestore
//
//  This routine creates a temporary persistent storage with informations
//  like restore point ID. The storage will be used by ResumeRestore later.
//
/////////////////////////////////////////////////////////////////////////////

static LPCWSTR  s_cszRunOnceValueName      = L"*Restore";
static LPCWSTR  s_cszRestoreUIPath         = L"%SystemRoot%\\system32\\restore\\rstrui.exe";
static LPCWSTR  s_cszRunOnceOptInterrupted = L" -i";

BOOL APIENTRY
InitiateRestore( IRestoreContext *pCtx, DWORD *pdwNewRP )
{
    EnsureTrace();
    TraceFunctEnter("InitiateRestore");

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();
    
    BOOL              fRet = FALSE;
    HCURSOR           hCursor = NULL;
    RESTOREPOINTINFO  sRPI;
    STATEMGRSTATUS    sStatus;
    SRstrLogHdrV3     sLogHdr;
    CRestoreContext   *pRC;
    DWORD             dwVal;
    WCHAR             szUIPath[MAX_PATH];
    BOOL 			  fCreatedRp = FALSE;
    BOOL                      fRAReturn;
    
    if ( !::IsAdminUser() )
        goto Exit;

    // Set RunOnce key for interrupted case...
    // Doing this here before anything else so result screen would appear.    
    ::ExpandEnvironmentStrings( s_cszRestoreUIPath, szUIPath, MAX_PATH );
    ::lstrcat( szUIPath, s_cszRunOnceOptInterrupted );
    if ( !::SRSetRegStr( HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, s_cszRunOnceValueName, szUIPath ) )
        goto Exit;
    
    // similarly, set RestoreStatus key in SystemRestore
    // so that test tools can know status of silent restores
    // set this to indicate interrrupted status
    // if restore succeeds or reverts, this value will be updated
    if ( !::SRSetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszRestoreStatus, 2 ) )
        goto Exit;

        
    // Create Restore Point
    hCursor = ::SetCursor( ::LoadCursor( NULL, IDC_WAIT ) );

    // make this a nested restore point so that 
    // no other app can create a restore point between here and a reboot
    sRPI.dwEventType      = BEGIN_NESTED_SYSTEM_CHANGE;

    if (0 != GetSystemMetrics(SM_CLEANBOOT))    // safe mode
    {
        sRPI.dwRestorePtType = CANCELLED_OPERATION;
    }   
    else                                        // normal mode
    {
        sRPI.dwRestorePtType  = RESTORE;
    }
    
    sRPI.llSequenceNumber = 0;
    ::LoadString( g_hInst, IDS_RESTORE_POINT_TEXT, sRPI.szDescription, MAX_DESC );
    if ( !::SRSetRestorePoint( &sRPI, &sStatus ) )
    {
        ErrorTrace(0, "::SRSetRestorePoint failed, nStatus=%d", sStatus.nStatus);
        goto Exit;
    }
    if ( pdwNewRP != NULL )
        *pdwNewRP = sStatus.llSequenceNumber;

    fCreatedRp = TRUE;

    // Create the log file
    pRC = (CRestoreContext*)pCtx;    
    sLogHdr.dwFlags  = pRC->m_fSilent ? RLHF_SILENT : 0;
    sLogHdr.dwFlags |= pRC->m_fUndo ? RLHF_UNDO : 0;
    sLogHdr.dwRPNum  = pRC->m_nRP;
    sLogHdr.dwRPNew  = sStatus.llSequenceNumber;
    sLogHdr.dwDrives = pRC->m_aryDrv.GetSize();
    if ( !::CreateRestoreLogFile( &sLogHdr, pRC->m_aryDrv ) )
        goto Exit;

    
     // also call TS folks to get them to preserve RA keys on restore
    DebugTrace(0, "Calling  RA to preserve state"); 
    fRAReturn=RemoteAssistancePrepareSystemRestore(SERVERNAME_CURRENT);
    if (FALSE==fRAReturn)
    {
        ErrorTrace(0, "Call to RA failed");
        _ASSERT(0);
    }

    // Set RestoreInProgress registry key so winlogon would invoke us
    if ( !::SRSetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszRestoreInProgress, 1 ) )
        goto Exit;

    fRet = TRUE;

Exit:
    if (fRet == FALSE)
    {
        // if something failed and we had set a nested restore point,
        // end the nesting now
        
        if (fCreatedRp == TRUE)
        {
            sRPI.dwRestorePtType = RESTORE;
            sRPI.dwEventType = END_NESTED_SYSTEM_CHANGE;        
            SRSetRestorePoint( &sRPI, &sStatus );
        }

        // delete the runonce key 
        SHDeleteValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, s_cszRunOnceValueName);
    }

    if ( hCursor != NULL )
        ::SetCursor( hCursor );
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// ResumeRestore
//
//  This routine is the main routine to run the restore operation.
//
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
ResumeRestore()
{
    EnsureTrace();
    TraceFunctEnter("ResumeRestore");

     // Load SRClient
     g_CSRClientLoader.LoadSrClient();
    
    BOOL                      fRet = FALSE;
    LPCWSTR                   cszErr;
    DWORD                     dwInRestore, dwType, dwSize, dwRes;
    CRestoreOperationManager  *pROMgr = NULL;

    if ( !::CheckPrivilegesForRestore() )
        goto Exit;

    // 1. Even though winlogon would check the registry before calling this
    //    API, double check the registry key and then delete it.
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwRes = ::SHGetValue( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszRestoreInProgress, &dwType, &dwInRestore, &dwSize );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr();
        DebugTrace(0, "::SHGetValue failed - %ls", cszErr);
        goto Exit;
    }
    dwRes = ::SHDeleteValue( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszRestoreInProgress );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::SHDeleteValue failed - %ls", cszErr);
        goto Exit;
    }
    if ( dwInRestore == 0 )
    {
        DebugTrace(0, "RestoreInProgress is 0");
        goto Exit;
    }

    // 1. Create CRestoreOperationManager object.
    if ( !::CreateRestoreOperationManager( &pROMgr ) )
        goto Exit;

    // 2. Perform the Restore Operation.
    if ( !pROMgr->Run( TRUE ) )
        goto Exit;

    fRet = TRUE;
Exit:
    SAFE_RELEASE(pROMgr);
    TraceFunctLeave();
    ReleaseTrace();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\nttest\srdiag2\strutils.cxx ===
#include "srheader.hxx"

//+---------------------------------------------------------------------------
//
//  Method:		SrTstStrCat 
//
//  Synopsis:   Concatenates Str1 and Str1 and puts  resulting string in 
//				allocated buf returns address to the buf in plpDest
//				(char version)
//
//  Arguments:  plpDest:  pointer to pointer to the concat. string
//              szStr1 :  pointer to the 1st string
//              szStr2 :  pointer to the 2nd string
//
//  Returns:    HRESULT
//
//  History:    07-28-2000   a-robog   Created
//				09-24-2000   ristern   Moved out of the class
//				10-01-2000   ristern   Moved to strutils
//              04-May-2001  weiyouc   Copied to StrUtils.cxx
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT SrTstStrCat(IN  LPCSTR szStr1,
                    IN  LPCSTR szStr2,
                    OUT LPSTR *ppDest)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;

    DH_VDATEPTROUT(ppDest, LPSTR);
    DH_VDATEPTRIN (szStr1,char);
    DH_VDATEPTRIN (szStr2,char);

    dwSize = strlen(szStr1)+strlen(szStr2)+1;
    *ppDest = new char[dwSize];
    DH_ABORTIF(NULL == *ppDest,
               E_OUTOFMEMORY,
               TEXT("new char[...]"));

    strcpy(*ppDest,szStr1);
    strcat(*ppDest,szStr2);

ErrReturn:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:		SrTstTStrCat
//
//  Synopsis:   Concatenates Str1 and Str1 and puts  resulting string in 
//				allocated buf returns address to the buf in plpDest
//				(TCHAR version)
//
//  Arguments:  plpDest:  pointer to pointer to the concat. string
//              szStr1 :  pointer to the 1st string
//              szStr2 :  pointer to the 2nd string
//
//  Returns:    HRESULT
//
//  History:    07-28-2000   a-robog   Created
//				09-24-2000   ristern   Moved out of the class
//				09-30-2000	 ristern   Converted to TCHAR
//				10-01-2000   ristern   Moved to strutils	
//              04-May-2001  weiyouc   Copied to StrUtils.cxx
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT SrTstTStrCat(IN  LPCTSTR szStr1,
                     IN  LPCTSTR szStr2,
                     OUT LPTSTR *ppDest)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;

    DH_VDATEPTROUT(ppDest, LPTSTR);
    DH_VDATEPTRIN (szStr1, TCHAR);
    DH_VDATEPTRIN (szStr2, TCHAR);

    dwSize = _tcslen(szStr1)+_tcslen(szStr2)+1;
    *ppDest = new TCHAR[dwSize];
    DH_ABORTIF(NULL == *ppDest,
               E_OUTOFMEMORY,
               TEXT("new TCHAR[...]"));

    _tcscpy(*ppDest,szStr1);
    _tcscat(*ppDest,szStr2);

ErrReturn:
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Copy a wide (Unicode) string
//
//  Parameters: [pszSource]             -- The original string
//              [ppszDest]              -- The copy
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPWSTR *ppszDest)
{
    size_t     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    // 
    // Find the length of the original string
    //

    bufferSize = wcslen(pszSource) + 1;

    //
    // Allocate the buffer
    //

    *ppszDest = new WCHAR[bufferSize];

    if (NULL == *ppszDest)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Copy the string
    //

    if (S_OK == hr)
    {
        wcscpy(*ppszDest, pszSource);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Copy a multibyte string
//
//  Parameters: [pszSource]             -- The original string
//              [ppszDest]              -- The copy
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPSTR *ppszDest)
{
    size_t     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    // 
    // Find the length of the original string (in bytes for DBCS)
    //

    bufferSize = strlen(pszSource) + 1;

    //
    // Allocate the buffer
    //

    *ppszDest = new char[bufferSize];

    if (NULL == *ppszDest)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Copy the string
    //

    if (S_OK == hr)
    {
        strcpy(*ppszDest, pszSource);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a wide (Unicode) string to a multibyte string
//
//  Parameters: [pszSource]     -- The wide string
//              [ppszDest]      -- Where to put the multibyte string
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = WideCharToMultiByte(                        
                        CP_ACP,
                        0,
                        pszSource,
                        -1,
                        *ppszDest,
                        0,
                        NULL,
                        NULL);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Allocate the buffer
    //

    if(S_OK == hr)
    {
        *ppszDest = new char[bufferSize];

        if (NULL == *ppszDest)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pszSource,
                                -1,
                                *ppszDest,
                                bufferSize,
                                NULL,
                                NULL);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Clean up if there's an error
    //

    if (S_OK != hr && NULL != *ppszDest)
    {
        delete [] *ppszDest;
        *ppszDest = NULL;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a multibyte string to a wide (Unicode) string
//
//  Parameters: [pszSource]     -- The multibyte string
//              [ppszDest]      -- Where to put the wide string
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPWSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pszSource,
                        -1,
                        *ppszDest,
                        0);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Allocate the buffer
    //

    if(S_OK == hr)
    {
        *ppszDest = new WCHAR[bufferSize];

        if (NULL == *ppszDest)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszSource,
                            -1,
                            *ppszDest,
                            bufferSize);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Clean up if there's an error
    //

    if (S_OK != hr && NULL != *ppszDest)
    {
        delete [] *ppszDest;
        *ppszDest = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\dload.cpp ===
#include "stdwin.h"

extern CSRClientLoader  g_CSRClientLoader;
#include "dload_common.cpp"

// we assume DELAYLOAD_VERSION >= 0x0200
PfnDliHook __pfnDliFailureHook2 = SystemRestore_DelayLoadFailureHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\helpids.h ===
#ifndef _SR_HELPIDS
#define _SR_HELPIDS

//
// System Restore Tab help topics
//
#define IDH_SR_TURN_OFF         16001  // Turn off all drives (check box)
#define IDH_SR_SELECT_VOLUME    16002  // Volume list (list view)
#define IDH_SR_CHANGE_SETTINGS  16003  // Change settings (pushbutton)
#define IDH_SR_CONFIRM_CHANGE   16004  // OK or Apply
#define IDH_SR_CANCEL           16005  // Cancel
#define IDH_SR_TURN_OFF_DRIVE   16006  // Turn off single drive (check box)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the DllMain for SRRSTR.DLL.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"


HINSTANCE  g_hInst = NULL;


BOOL WINAPI
DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/ )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstance;
        ::DisableThreadLibraryCalls( hInstance );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        //
    }
   
    return TRUE;
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\drvtable.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    drvtable.cpp

Abstract:
    This file contains CRstrDriveInfo class and CreateDriveList function.

Revision History:
    Seong Kook Khang (SKKhang)  07/20/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"
#include "..\shell\resource.h"


static LPCWSTR  s_cszEmpty = L"";
WCHAR  s_szSysDrv[MAX_PATH];


/////////////////////////////////////////////////////////////////////////////
//
// CRstrDriveInfo class
//
/////////////////////////////////////////////////////////////////////////////

//
// NOTE - 7/26/00 - skkhang
//  CSRStr has one issue -- NULL return in case of memory failure. Even though
//  the behavior is just same with regular C language pointer, many codes are
//  blindly passing it to some external functions (e.g. strcmp) which does not
//  gracefully handle NULL pointer. Ideally and eventually all of code should
//  prevent any possible NULL pointers from getting passed to such functions,
//  but for now, I'm using an alternative workaround -- GetID, GetMount, and
//  GetLabel returns a static empty string instead of NULL pointer.
//

/////////////////////////////////////////////////////////////////////////////
// CRstrDriveInfo construction / destruction

CRstrDriveInfo::CRstrDriveInfo()
{
    m_dwFlags  = 0;
    m_hIcon[0] = NULL;
    m_hIcon[1] = NULL;

    m_llDSMin = SR_DEFAULT_DSMIN * MEGABYTE;
    m_llDSMax = SR_DEFAULT_DSMAX * MEGABYTE;
    m_uDSUsage     = 0;
    m_fCfgExcluded = FALSE;
    m_uCfgDSUsage  = 0;
    m_ulTotalBytes.QuadPart = 0;
}

CRstrDriveInfo::~CRstrDriveInfo()
{
    if ( m_hIcon[0] != NULL )
        ::DestroyIcon( m_hIcon[0] );
    if ( m_hIcon[1] != NULL )
        ::DestroyIcon( m_hIcon[1] );
}

BOOL CRstrDriveInfo::InitUsage (LPCWSTR cszID, INT64 llDSUsage)
{
    TraceFunctEnter("CRstrDriveInfo::InitUsage");
    //
    // calculate max datastore size - max (12% of disk, 400mb)
    //

    // read % from registry
    HKEY    hKey = NULL;
    DWORD   dwPercent = SR_DEFAULT_DISK_PERCENT;
    DWORD   dwDSMax = SR_DEFAULT_DSMAX;
    DWORD   dwDSMin = IsSystem() ? SR_DEFAULT_DSMIN : SR_DEFAULT_DSMIN_NONSYSTEM;
    ULARGE_INTEGER ulDummy;
    
    DWORD dwRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        s_cszSRRegKey, 0, KEY_READ, &hKey);

    if (ERROR_SUCCESS == dwRes)
    {
        RegReadDWORD(hKey, s_cszDiskPercent, &dwPercent);
        RegReadDWORD(hKey, s_cszDSMax, &dwDSMax);
        if (IsSystem())
            RegReadDWORD(hKey, s_cszDSMin, &dwDSMin);
        RegCloseKey(hKey);
    }
    else
    {
        ErrorTrace(0, "! RegOpenKeyEx : %ld", dwRes);
    }

    // BUGBUG - this call may not always give total disk space (per-user quota)
    ulDummy.QuadPart = 0;
    if (FALSE == GetDiskFreeSpaceEx (cszID, &ulDummy, &m_ulTotalBytes, NULL))
    {
        ErrorTrace(0, "! GetDiskFreeSpaceEx : %ld", GetLastError());
        goto done;
    }
    
    m_llDSMin = min(m_ulTotalBytes.QuadPart, (INT64) dwDSMin * MEGABYTE);

    m_llDSMax = min(m_ulTotalBytes.QuadPart, 
                    max( (INT64) dwDSMax * MEGABYTE, 
                         (INT64) dwPercent * m_ulTotalBytes.QuadPart / 100 ));

    if (m_llDSMax < m_llDSMin)
        m_llDSMax = m_llDSMin;
        
    //
    // take floor of this value
    //

    m_llDSMax = ((INT64) (m_llDSMax / (INT64) MEGABYTE)) * (INT64) MEGABYTE;


    DebugTrace(0, "m_llDSMax: %I64d, Size: %I64d", m_llDSMax, llDSUsage); 

    if ( ( llDSUsage == 0) || (llDSUsage > m_llDSMax) )
                          // not initialized, assume maximum
    {
        llDSUsage = m_llDSMax;
    }

    if ( ( llDSUsage - m_llDSMin > 0) && ( m_llDSMax - m_llDSMin > 0))
    {
         // + ((llDSUsage - m_llDSMin)/2) is to ensure that correct
         // rounding off happens here
        m_uDSUsage =( ((llDSUsage - m_llDSMin) * DSUSAGE_SLIDER_FREQ)
                      + ((m_llDSMax - m_llDSMin)/2))/( m_llDSMax - m_llDSMin);
    }
    else
        m_uDSUsage = 0;

    m_uCfgDSUsage  = m_uDSUsage;

done:
    TraceFunctLeave();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRstrDriveInfo operations

BOOL
CRstrDriveInfo::Init( LPCWSTR cszID, DWORD dwFlags, INT64 llDSUsage, LPCWSTR cszMount, LPCWSTR cszLabel )
{
    TraceFunctEnter("CRstrDriveInfo::Init");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    DWORD    dwRes;
    WCHAR    szMount[MAX_PATH];
    WCHAR    szLabel[MAX_PATH];

    m_dwFlags = dwFlags;
    m_strID   = cszID;

    if ( !IsOffline() )
    {
        // Get Mount Point (drive letter or root directory path) from Unique Volume ID
        //
        if ( !::GetVolumePathNamesForVolumeName( cszID, szMount, MAX_PATH, &dwRes ) && GetLastError() != ERROR_MORE_DATA)
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::GetVolumePathNamesForVolumeName failed - %ls", cszErr);
            // Instead of fail, use cszMount even if it may not accurate
            ::lstrcpy( szMount, cszMount );
        }
        else
        {
            szMount[MAX_PATH-1] = L'\0';

            if (lstrlenW (szMount) > MAX_MOUNTPOINT_PATH)
            {
                // Instead of fail, use cszMount even if it may not accurate
                ::lstrcpy( szMount, cszMount );
            }
        }

        // Get Volume Label from Mount Point
        //
        if ( !::GetVolumeInformation( cszID, szLabel, MAX_PATH, NULL, NULL, NULL, NULL, 0 ) )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::GetVolumeInformation failed - %ls", cszErr);
            // Instead of fail, use cszLabel even if it may not accurate
            ::lstrcpy( szLabel, cszLabel );
        }
    }

    if ( ( szMount[1] == L':' ) && ( szMount[2] == L'\\' ) && ( szMount[3] == L'\0' ) )
        szMount[2] = L'\0';
    m_strMount = szMount;
    m_strLabel = szLabel;

    InitUsage (cszID, llDSUsage);

    m_fCfgExcluded = IsExcluded();

    fRet = TRUE;
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::Init( LPCWSTR cszID, CDataStore *pDS, BOOL fOffline )
{
    TraceFunctEnter("CRstrDriveInfo::Init");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    DWORD    dwRes;
    WCHAR    szMount[MAX_PATH];
    WCHAR    szLabel[MAX_PATH];

    m_strID = cszID;

    UpdateStatus( pDS->GetFlags(), fOffline );

    if ( !fOffline )
    {
        // Get Mount Point (drive letter or root directory path) from Unique Volume ID
        //
        if ( !::GetVolumePathNamesForVolumeName( cszID, szMount, MAX_PATH, &dwRes ) && GetLastError() != ERROR_MORE_DATA )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::GetVolumePathNamesForVolumeName failed - %ls", cszErr);
            goto Exit;
        }
        else
        {
            szMount[MAX_PATH-1] = L'\0';

            if (lstrlenW (szMount) > MAX_MOUNTPOINT_PATH)
            {
                cszErr = ::GetSysErrStr();
                ErrorTrace(0, "mount point too long %ls", cszErr);
                goto Exit;
            }
        }

        // Get Volume Label from Mount Point
        //
        if ( !::GetVolumeInformation( cszID, szLabel, MAX_PATH, NULL, NULL, NULL, NULL, 0 ) )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::GetVolumeInformation failed - %ls", cszErr);
             // this is not a fatal error - this can happen if the
             // volume is being formatted for example. assume that the
             // label is empty
            szLabel[0]= L'\0';
        }
    }
    else
    {
        ::lstrcpyW (szMount, pDS->GetDrive());
        ::lstrcpyW (szLabel, pDS->GetLabel());
    }

    if ( ( szMount[1] == L':' ) && ( szMount[2] == L'\\' ) && ( szMount[3] == L'\0' ) )
        szMount[2] = L'\0';
    m_strMount = szMount;
    m_strLabel = szLabel;

    InitUsage (cszID, pDS->GetSizeLimit());

    m_fCfgExcluded = IsExcluded();

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::LoadFromLog( HANDLE hfLog )
{
    TraceFunctEnter("CRstrDriveInfo::LoadFromLog");
    BOOL     fRet = FALSE;
    DWORD    dwRes;
    WCHAR    szBuf[MAX_PATH];

    // Read m_dwFlags
    READFILE_AND_VALIDATE( hfLog, &m_dwFlags, sizeof(DWORD), dwRes, Exit );

    // Read m_strID
    if ( !::ReadStrAlign4( hfLog, szBuf ) )
    {
        ErrorTrace(0, "Cannot read drive ID...");
        goto Exit;
    }
    if ( szBuf[0] == L'\0' )
    {
        ErrorTrace(0, "Drive Guid is empty...");
        goto Exit;
    }
    m_strID = szBuf;

    // Read m_strMount
    if ( !::ReadStrAlign4( hfLog, szBuf ) )
    {
        ErrorTrace(0, "Cannot read drive mount point...");
        goto Exit;
    }
    m_strMount = szBuf;

    // Read m_strLabel
    if ( !::ReadStrAlign4( hfLog, szBuf ) )
    {
        ErrorTrace(0, "Cannot read drive mount point...");
        goto Exit;
    }
    m_strLabel = szBuf;

    m_fCfgExcluded = IsExcluded();
    // m_nCfgMaxSize = ...

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

void
CRstrDriveInfo::UpdateStatus( DWORD dwFlags, BOOL fOffline )
{
    TraceFunctEnter("CRstrDriveInfo::UpdateStatus");

    m_dwFlags = 0;

    if ( fOffline )
    {
        m_dwFlags |= RDIF_OFFLINE;
    }
    else
    {
        // check if frozen
        if ( ( dwFlags & SR_DRIVE_FROZEN ) != 0 )
            m_dwFlags |= RDIF_FROZEN;

        // check if system drive
        if ( ( dwFlags & SR_DRIVE_SYSTEM ) != 0 )
        {
            m_dwFlags |= RDIF_SYSTEM;
        }
        else
        {
            // if not system drive, simply use MONITORED flag of drive table
            if ( ( dwFlags & SR_DRIVE_MONITORED ) == 0 )
                m_dwFlags |= RDIF_EXCLUDED;
        }
    }

    DebugTrace(0, "Status has been updated, m_dwFlags=%08X", m_dwFlags);

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
// CRstrDriveInfo - methods

DWORD
CRstrDriveInfo::GetFlags()
{
    return( m_dwFlags );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::IsExcluded()
{
    return( ( m_dwFlags & RDIF_EXCLUDED ) != 0 );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::IsFrozen()
{
    return( ( m_dwFlags & RDIF_FROZEN ) != 0 );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::IsOffline()
{
    return( ( m_dwFlags & RDIF_OFFLINE ) != 0 );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::IsSystem()
{
    return( ( m_dwFlags & RDIF_SYSTEM ) != 0 );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::RefreshStatus()
{
    TraceFunctEnter("CRstrDriveInfo::RefreshStatus");
    BOOL            fRet = FALSE;
    LPCWSTR         cszErr;
    WCHAR           szDTFile[MAX_PATH];
    DWORD           dwRes;
    CDriveTable     cDrvTable;
    CDataStore      *pDS;

    ::MakeRestorePath( szDTFile, s_szSysDrv, NULL );
    ::PathAppend( szDTFile, s_cszDriveTable );
    DebugTrace(0, "Loading drive table - %ls", szDTFile);

    dwRes = cDrvTable.LoadDriveTable( szDTFile );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "Cannot load a drive table - %ls", cszErr);
        ErrorTrace(0, "  szDTFile: '%ls'", szDTFile);
        goto Exit;
    }

    dwRes = cDrvTable.RemoveDrivesFromTable();
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "CDriveTable::RemoveDrivesFromTable failed - %ls", cszErr);
        // ignore error
    }

    pDS = cDrvTable.FindGuidInTable( (LPWSTR)GetID() );
    if ( pDS == NULL )
        UpdateStatus( 0, TRUE );
    else
        UpdateStatus( pDS->GetFlags(), FALSE );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

LPCWSTR
CRstrDriveInfo::GetID()
{
    return( ( m_strID.Length() > 0 ) ? m_strID : s_cszEmpty );
}

/////////////////////////////////////////////////////////////////////////////

LPCWSTR
CRstrDriveInfo::GetMount()
{
    return( ( m_strMount.Length() > 0 ) ? m_strMount : s_cszEmpty );
}

/////////////////////////////////////////////////////////////////////////////

LPCWSTR
CRstrDriveInfo::GetLabel()
{
     return( ( m_strLabel.Length() > 0 ) ? m_strLabel : s_cszEmpty );
}

/////////////////////////////////////////////////////////////////////////////

void
CRstrDriveInfo::SetMountAndLabel( LPCWSTR cszMount, LPCWSTR cszLabel )
{
    TraceFunctEnter("CRstrDriveInfo::SetMountAndLabel");
    m_strMount = cszMount;
    m_strLabel = cszLabel;
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

HICON
CRstrDriveInfo::GetIcon( BOOL fSmall )
{
    TraceFunctEnter("CRstrDriveInfo::GetIcon");
    LPCWSTR  cszErr;
    int      nIdx = fSmall ? 0 : 1;
    int      cxIcon, cyIcon;
    HICON    hIcon;

    if ( m_hIcon[nIdx] != NULL )
        goto Exit;

    cxIcon = ::GetSystemMetrics( fSmall ? SM_CXSMICON : SM_CXICON );
    cyIcon = ::GetSystemMetrics( fSmall ? SM_CYSMICON : SM_CYICON );
    hIcon = (HICON)::LoadImage( g_hInst, MAKEINTRESOURCE(IDI_DRIVE_FIXED),
                                IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR );
    if ( hIcon == NULL )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadImage failed - %ls", cszErr);
        goto Exit;
    }

    m_hIcon[nIdx] = hIcon;

Exit:
    TraceFunctLeave();
    return( m_hIcon[nIdx] );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::SaveToLog( HANDLE hfLog )
{
    TraceFunctEnter("CRstrDriveInfo::SaveToLog");
    BOOL   fRet = FALSE;
    BYTE   pbBuf[7*MAX_PATH];
    DWORD  dwSize = 0;
    DWORD  dwRes;

    *((DWORD*)pbBuf) = m_dwFlags;
    dwSize += sizeof(DWORD);
    dwSize += ::StrCpyAlign4( pbBuf+dwSize, m_strID );
    dwSize += ::StrCpyAlign4( pbBuf+dwSize, m_strMount );
    dwSize += ::StrCpyAlign4( pbBuf+dwSize, m_strLabel );
    WRITEFILE_AND_VALIDATE( hfLog, pbBuf, dwSize, dwRes, Exit );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

UINT
CRstrDriveInfo::GetDSUsage()
{
    TraceFunctEnter("CRstrDriveInfo::GetDSUsage");
    TraceFunctLeave();
    return( m_uDSUsage );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::GetUsageText( LPWSTR szUsage )
{
    TraceFunctEnter("CRstrDriveInfo::GetUsageText");
    INT64  llUsage;
    int    nPercent;
    int    nUsage;

    if (m_llDSMax - m_llDSMin > 0)
        llUsage  = m_llDSMin + ( m_llDSMax - m_llDSMin ) * m_uCfgDSUsage / DSUSAGE_SLIDER_FREQ;
    else
        llUsage = m_llDSMin;

    if (m_ulTotalBytes.QuadPart !=  0)
    {
         // the m_ulTotalBytes.QuadPart/200 addition is to ensure that
         // the correct round off happens
        nPercent = (llUsage + (m_ulTotalBytes.QuadPart/200)) * 100/
            m_ulTotalBytes.QuadPart;
    }
    else nPercent = 0;
    
    nUsage   = llUsage / ( 1024 * 1024 );
    ::wsprintf( szUsage, L"%d%% (%d MB)", nPercent, nUsage );

    TraceFunctLeave();
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::GetCfgExcluded( BOOL *pfExcluded )
{
    TraceFunctEnter("CRstrDriveInfo::GetCfgExcluded");
    BOOL  fRet = FALSE;

    if ( m_fCfgExcluded != IsExcluded() )
    {
        *pfExcluded = m_fCfgExcluded;
        fRet = TRUE;
    }

    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

void
CRstrDriveInfo::SetCfgExcluded( BOOL fExcluded )
{
    TraceFunctEnter("CRstrDriveInfo::SetCfgExcluded");
    m_fCfgExcluded = fExcluded;
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::GetCfgDSUsage( UINT *puPos )
{
    TraceFunctEnter("CRstrDriveInfo::GetCfgDSUsage");
    BOOL  fRet = FALSE;

    if ( m_uCfgDSUsage != m_uDSUsage )
    {
        *puPos = m_uCfgDSUsage;
        fRet = TRUE;
    }

    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

void
CRstrDriveInfo::SetCfgDSUsage( UINT uPos )
{
    TraceFunctEnter("CRstrDriveInfo::SetCfgDSUsage");
    m_uCfgDSUsage = uPos;
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

void
CloseRestoreUI()
{
    WCHAR szPath[MAX_PATH], szTitle[MAX_PATH] = L"";
    if (ExpandEnvironmentStrings(L"%windir%\\system32\\restore\\rstrui.exe", szPath, MAX_PATH))
    {
        if (ERROR_SUCCESS == SRLoadString(szPath, IDS_RESTOREUI_TITLE, szTitle, MAX_PATH))
        {
            HWND hWnd = FindWindow(CLSNAME_RSTRSHELL, szTitle);
            if (hWnd != NULL)
                PostMessage(hWnd, WM_CLOSE, 0, 0);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::ApplyConfig( HWND hWnd )
{
    TraceFunctEnter("CRstrDriveInfo::ApplyConfig");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    INT64    llUsage;
    DWORD    dwRes;

    if ( m_fCfgExcluded != IsExcluded() )
    {
        if ( m_fCfgExcluded )
        {
            WCHAR  szTitle[MAX_STR];
            WCHAR  szMsg[MAX_STR+2*MAX_PATH];

            // Confirm if it's ok to turn drive or SR off.
            ::LoadString( g_hInst, IDS_SYSTEMRESTORE, szTitle,
                          sizeof(szTitle)/sizeof(WCHAR) );
            if ( IsSystem() )
                ::LoadString( g_hInst, IDS_CONFIRM_TURN_SR_OFF, szMsg,
                              sizeof(szMsg)/sizeof(WCHAR) );
            else
            {
                ::SRFormatMessage( szMsg, IDS_CONFIRM_TURN_DRV_OFF, GetLabel() ? GetLabel() : L"", GetMount() );
            }
            if ( ::MessageBox( hWnd, szMsg, szTitle, MB_YESNO ) == IDNO )
            {
                m_fCfgExcluded = IsExcluded();
                goto Exit;
            }

            //
            // if disabling all of SR, close the wizard if open
            //
            if (IsSystem())
            {
                CloseRestoreUI();
            }
            
            dwRes = ::DisableSR( m_strID );
            if ( dwRes != ERROR_SUCCESS )
            {
                ShowSRErrDlg (IDS_ERR_SR_ON_OFF);
                cszErr = ::GetSysErrStr( dwRes );
                ErrorTrace(0, "::DisableSR failed - %ls", cszErr);
                goto Exit;
            }

            m_dwFlags |= RDIF_EXCLUDED;
        }
        else
        {
            // 
            // make a synchronous call to enable sr
            // this will block till the firstrun checkpoint is created 
            // and the service is fully initialized
            //
            dwRes = ::EnableSREx( m_strID, TRUE );
            if ( dwRes != ERROR_SUCCESS )
            {
                ShowSRErrDlg (IDS_ERR_SR_ON_OFF);
                cszErr = ::GetSysErrStr( dwRes );
                ErrorTrace(0, "::EnableSR failed - %ls", cszErr);
                goto Exit;
            }

            m_dwFlags &= ~RDIF_EXCLUDED;
        }
    }

    if ( m_uCfgDSUsage != m_uDSUsage )
    {
        if (m_llDSMax - m_llDSMin > 0)
            llUsage = m_llDSMin + (m_llDSMax - m_llDSMin)* m_uCfgDSUsage /DSUSAGE_SLIDER_FREQ;
        else
            llUsage = m_llDSMin;


        dwRes = ::SRUpdateDSSize( m_strID, llUsage );
        if ( dwRes != ERROR_SUCCESS )
        {
            LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
            ErrorTrace(0, "::SRUpdateDriveTable failed - %ls", cszErr);
            goto Exit;
        }

        m_uDSUsage = m_uCfgDSUsage;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRstrDriveInfo::Release()
{
    TraceFunctEnter("CRstrDriveInfo::Release");
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
//
// Helper Function
//
/////////////////////////////////////////////////////////////////////////////

//
// Enumerate Volumes without Drive Table if SR is disabled and DS not exists.
//
BOOL
EnumVolumes( CRDIArray &aryDrv )
{
    TraceFunctEnter("EnumVolumes");
    BOOL            fRet = FALSE;
    LPCWSTR         cszErr;
    HANDLE          hEnumVol = INVALID_HANDLE_VALUE;
    WCHAR           szVolume[MAX_PATH];
    WCHAR           szMount[MAX_PATH];
    DWORD           cbMount;
    CRstrDriveInfo  *pDrv = NULL;
    DWORD           dwFlags;

    hEnumVol = ::FindFirstVolume( szVolume, MAX_PATH );
    if ( hEnumVol == INVALID_HANDLE_VALUE )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::FindFirstVolume failed - %ls", cszErr);
        goto Exit;
    }

    // dummy space for system drive
    if ( !aryDrv.AddItem( NULL ) )
        goto Exit;

    do
    {
        HANDLE  hfDrv;
DebugTrace(0, "Guid=%ls", szVolume);

        if ( !::GetVolumePathNamesForVolumeName( szVolume, szMount, MAX_PATH, &cbMount ) && GetLastError() != ERROR_MORE_DATA)
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::GetVolumePathNamesForVolumeName failed - %ls", cszErr);
            continue;
        }
        else
        {
            szMount[MAX_PATH-1] = L'\0';

            if (lstrlenW (szMount) > MAX_MOUNTPOINT_PATH)
                continue;
        }

        DebugTrace(0, "  Mount=%ls", szMount);
        if ( ::GetDriveType( szMount ) != DRIVE_FIXED )
        {
            DebugTrace(0, "Non-fixed drive");
            // includes only the fixed drives.
            continue;
        }
        hfDrv = ::CreateFile( szVolume, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
        if ( hfDrv == INVALID_HANDLE_VALUE )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::CreateFile(volume) failed - %ls", cszErr);
            // probably an unformatted drive.
            continue;
        }
        ::CloseHandle( hfDrv );

        pDrv = new CRstrDriveInfo;
        if ( pDrv == NULL )
        {
            FatalTrace(0, "Insufficient memory...");
            goto Exit;
        }
        dwFlags = RDIF_EXCLUDED;
        if ( ::IsSystemDrive( szVolume ) )
        {
            dwFlags |= RDIF_SYSTEM;
            if ( !aryDrv.SetItem( 0, pDrv ) )
                goto Exit;
        }
        else
        {
            if ( !aryDrv.AddItem( pDrv ) )
                goto Exit;
        }
        if ( !pDrv->Init( szVolume, dwFlags, 0, szMount, NULL ) )
            goto Exit;

        pDrv = NULL;
    }
    while ( ::FindNextVolume( hEnumVol, szVolume, MAX_PATH ) );

    fRet = TRUE;
Exit:
    if ( pDrv != NULL )
    if ( hEnumVol != INVALID_HANDLE_VALUE )
        ::FindVolumeClose( hEnumVol );
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
LoadDriveTable( LPCWSTR cszRPDir, CRDIArray &aryDrv, BOOL fRemoveDrives)
{
    TraceFunctEnter("LoadDriveTable");
    BOOL                    fRet = FALSE;
    LPCWSTR                 cszErr;
    WCHAR                   szDTFile[MAX_PATH];
    DWORD                   dwRes;
    CDriveTable             cDrvTable;
    SDriveTableEnumContext  sDTEnum = { NULL, 0 };
    CDataStore              *pDS;
    CRstrDriveInfo          *pDrv = NULL;
    BOOL                    fOffline;

    ::MakeRestorePath( szDTFile, s_szSysDrv, cszRPDir );
    ::PathAppend( szDTFile, s_cszDriveTable );
    DebugTrace(0, "Loading drive table - %ls", szDTFile);

    dwRes = cDrvTable.LoadDriveTable( szDTFile );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "Cannot load a drive table - %ls", cszErr);
        ErrorTrace(0, "  szDTFile: '%ls'", szDTFile);
        goto Exit;
    }

    // If this is for the current drive table, try to update information
    // about removed volumes.
    if ( cszRPDir == NULL )
    {
        if (fRemoveDrives)
            cDrvTable.RemoveDrivesFromTable();
        else
        {
            sDTEnum.Reset();
            pDS = cDrvTable.FindFirstDrive (sDTEnum);
            while (pDS != NULL)
            {
                pDS->IsVolumeDeleted();   // mark deleted volumes as inactive
                pDS = cDrvTable.FindNextDrive( sDTEnum );
            }
        }
    }

    sDTEnum.Reset();
    pDS = cDrvTable.FindFirstDrive( sDTEnum );
    while ( pDS != NULL )
    {
        int      i;
        LPCWSTR  cszGuid = pDS->GetGuid();

        DebugTrace(0, "Drive: %ls %ls", pDS->GetDrive(), cszGuid);
        if ( cszRPDir != NULL )  // not the current restore point
        {
            for ( i = aryDrv.GetUpperBound();  i >= 0;  i-- )
            {
                CRstrDriveInfo  *pExist = aryDrv.GetItem( i );
                if ( ::lstrcmpi( cszGuid, pExist->GetID() ) == 0 )
                {
                    // Match has been found. Check if it's offline, in which
                    // case mount point and volume label should be updated to the
                    // latest ones.
                    if ( pExist->IsOffline() )
                        pExist->SetMountAndLabel( pDS->GetDrive(), pDS->GetLabel() );

                    break;
                }
                pDrv = NULL;
            }
            if ( i >= 0 )
                goto NextDrv;
        }

        pDrv = new CRstrDriveInfo;
        if ( pDrv == NULL )
        {
            FatalTrace(0, "Insufficient memory...");
            goto Exit;
        }

        //
        // mark a drive as offline if it's not in the current restore point
        // or it's inactive in the current restore point
        //
        fOffline = (cszRPDir != NULL) || !(pDS->GetFlags() & SR_DRIVE_ACTIVE);
        if ( !pDrv->Init( cszGuid, pDS, fOffline ) )
            goto Exit;

        if (( pDrv->GetMount() == NULL ) || ( (pDrv->GetMount())[0] == L'\0' ))
        {
            pDrv->Release();
            goto NextDrv;
        }

        if ( pDrv->IsSystem() )
        {
            if ( !aryDrv.SetItem( 0, pDrv ) )
                goto Exit;
        }
        else
        {
            if ( !aryDrv.AddItem( pDrv ) )
                goto Exit;
        }
        pDrv = NULL;

NextDrv:
        pDS = cDrvTable.FindNextDrive( sDTEnum );
    }

    fRet = TRUE;
Exit:
    if ( !fRet )
        SAFE_RELEASE(pDrv);
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
UpdateDriveList( CRDIArray &aryDrv )
{
    TraceFunctEnter("UpdateDriveTable");
    BOOL            fRet = FALSE;
    LPCWSTR         cszErr;
    DWORD           dwDisable = 0;            
    WCHAR           szDTFile[MAX_PATH];
    DWORD           dwRes;
    CDriveTable     cDrvTable;
    CDataStore      *pDS;
    CRstrDriveInfo  *pDrv;
    int             i;

    // Check if SR is disabled
    if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDisableSR, &dwDisable ) )
    if ( dwDisable != 0 )
    {
        for ( i = aryDrv.GetUpperBound();  i >= 0;  i-- )
        {
            pDrv = (CRstrDriveInfo*)aryDrv[i];
            pDrv->UpdateStatus( SR_DRIVE_FROZEN, FALSE );
        }
        goto Done;
    }

    ::MakeRestorePath( szDTFile, s_szSysDrv, NULL );
    ::PathAppend( szDTFile, s_cszDriveTable );
    DebugTrace(0, "Loading drive table - %ls", szDTFile);

    dwRes = cDrvTable.LoadDriveTable( szDTFile );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "Cannot load a drive table - %ls", cszErr);
        ErrorTrace(0, "  szDTFile: '%ls'", szDTFile);
        goto Exit;
    }

    dwRes = cDrvTable.RemoveDrivesFromTable();
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "CDriveTable::RemoveDrivesFromTable failed - %ls", cszErr);
        // ignore error
    }

    for ( i = aryDrv.GetUpperBound();  i >= 0;  i-- )
    {
        pDrv = (CRstrDriveInfo*)aryDrv[i];
        pDS = cDrvTable.FindGuidInTable( (LPWSTR)pDrv->GetID() );
        if ( ( pDS == NULL ) || ( pDS->GetDrive() == NULL ) || ( (pDS->GetDrive())[0] == L'\0' ) )
            pDrv->UpdateStatus( 0, TRUE );
        else
            pDrv->UpdateStatus( pDS->GetFlags(), FALSE );
    }

Done:
    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateAndLoadDriveInfoInstance
//
//  This routine creates a CRstrDriveInfo class instance and load the content
//  from a log file.
//
/////////////////////////////////////////////////////////////////////////////

BOOL
CreateAndLoadDriveInfoInstance( HANDLE hfLog, CRstrDriveInfo **ppRDI )
{
    TraceFunctEnter("CreateAndLoadDriveInfoInstance");
    BOOL            fRet = FALSE;
    CRstrDriveInfo  *pRDI=NULL;

    if ( ppRDI == NULL )
    {
        ErrorTrace(0, "Invalid parameter, ppRDI is NULL.");
        goto Exit;
    }
    *ppRDI = NULL;

    pRDI = new CRstrDriveInfo;
    if ( pRDI == NULL )
    {
        ErrorTrace(0, "Insufficient memory...");
        goto Exit;
    }

    if ( !pRDI->LoadFromLog( hfLog ) )
        goto Exit;

    *ppRDI = pRDI;

    fRet = TRUE;
Exit:
    if ( !fRet )
        SAFE_RELEASE(pRDI);
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateDriveList
//
//  This routine creates a drive list consists of CDriveInfo class instances.
//
/////////////////////////////////////////////////////////////////////////////

BOOL
CreateDriveList( int nRP, CRDIArray &aryDrv, BOOL fRemoveDrives )
{
    TraceFunctEnter("CreateDriveList");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    DWORD    fDisable;

    if ( !::GetSystemDrive( s_szSysDrv ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "Cannot get system drive - %ls", cszErr);
        goto Exit;
    }
    DebugTrace(0, "SystemDrive=%ls", s_szSysDrv);

    // Check if SR is disabled
    if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDisableSR, &fDisable ) )
    {
        DebugTrace(0, "Cannot get disable reg key"); 
        goto Exit;
    }

    if ( fDisable )
    {
        DebugTrace(0, "SR is DISABLED!!!");

        // Enumerate instead of reading drive table...
        if ( !EnumVolumes( aryDrv ) )
            goto Exit;
    }
    else
    {
        // dummy space for system drive
        if ( !aryDrv.AddItem( NULL ) )
            goto Exit;

        // process the current drive table...
        if ( !LoadDriveTable( NULL, aryDrv, fRemoveDrives ) )
        {
            DebugTrace(0, "Loading current drive table failed");             
            goto Exit;
        }

        if ( nRP > 0 )
        {
            CRestorePointEnum  cEnum( s_szSysDrv, FALSE, FALSE );
            CRestorePoint      cRP;
            DWORD              dwRes;

            dwRes = cEnum.FindFirstRestorePoint( cRP );
            if ( dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND )
            {
                cszErr = ::GetSysErrStr(dwRes);
                ErrorTrace(0, "CRestorePointEnum::FindFirstRestorePoint failed - %ls", cszErr);
                goto Exit;
            }
            while ( (dwRes == ERROR_SUCCESS || dwRes == ERROR_FILE_NOT_FOUND) && ( cRP.GetNum() >= nRP ))
            {
                dwRes = cEnum.FindNextRestorePoint( cRP );
                if ( dwRes == ERROR_NO_MORE_ITEMS )
                    break;
                if ( dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND )
                {
                    cszErr = ::GetSysErrStr(dwRes);
                    ErrorTrace(0, "CRestorePointEnum::FindNextRestorePoint failed - %ls", cszErr);
                    goto Exit;
                }

                DebugTrace(0, "RPNum=%d", cRP.GetNum());
                if ( cRP.GetNum() >= nRP )
                {
                    // process drive table of each RP...
                    if ( !LoadDriveTable( cRP.GetDir(), aryDrv, fRemoveDrives))
                    {
                        // The last restore point does not have drive table...
                        // simply ignore it.
                    }
                }
            }
        }
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\dload_common.cpp ===
// this is a common file used by both srrstr.dll (rstrcore directory) and
// rstrui.exe (shell directory).

DWORD hook_DisableSR(LPCWSTR pszDrive)
{
    return ERROR_PROC_NOT_FOUND;
}

DWORD hook_EnableSR(LPCWSTR pszDrive)
{
    return ERROR_PROC_NOT_FOUND;    
}


DWORD hook_DisableFIFO( DWORD dwRPNum)
{
    return ERROR_PROC_NOT_FOUND;    
}


DWORD hook_EnableFIFO()
{
    return ERROR_PROC_NOT_FOUND;        
}

BOOL hook_SRSetRestorePointW( PRESTOREPOINTINFOW  pRPInfoW, 
                         PSTATEMGRSTATUS     pSMgrStatus)
{
    return FALSE;
}

DWORD hook_SRRemoveRestorePoint( DWORD dwRPNum)
{
    return ERROR_PROC_NOT_FOUND;    
}

DWORD hook_EnableSREx(LPCWSTR pszDrive, BOOL fWait)
{
    return ERROR_PROC_NOT_FOUND;            
}

DWORD hook_SRUpdateDSSize(LPCWSTR pszDrive, UINT64 ullSizeLimit)
{
    return ERROR_PROC_NOT_FOUND;    
}



FARPROC WINAPI SystemRestore_DelayLoadFailureHook( UINT unReason, PDelayLoadInfo pDelayInfo )
{
    if (unReason == dliFailLoadLib)
    {
         // Load SRClient
        if (TRUE == g_CSRClientLoader.LoadSrClient())
        {
            return (FARPROC) g_CSRClientLoader.m_hSRClient;
        }
    }

     // we are here because either unReason == dliFailLoadLib and srclient.dll
     // failed to load, or becuase a procedure could not be be found.

     //first make sure that it is srclient.dll we are talking about
    if(0!=lstrcmpiA( pDelayInfo->szDll, "srclient.dll" ))
    {
        return (FARPROC)NULL;
    }

     // check to see if the Import is by name or ordinal. If it is by
     // Ordinal, then it is not one of the functions we are interested
     // in.
    if(FALSE== pDelayInfo->dlp.fImportByName)
    {
        return (FARPROC)NULL;
    }
    
    if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "EnableSREx" ))
    {
        return (FARPROC)hook_EnableSREx;
    }

    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "EnableSR" ))
    {
        return (FARPROC)hook_EnableSR;
    }
    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "DisableFIFO" ))
    {
        return (FARPROC)hook_DisableFIFO;
    }
    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "EnableFIFO" ))
    {
        return (FARPROC)hook_EnableFIFO;
    }
    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "DisableSR" ))
    {
        return (FARPROC)hook_DisableSR;
    }
    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "SRSetRestorePointW" ))
    {
        return (FARPROC)hook_SRSetRestorePointW;
    }
    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "SRUpdateDSSize" ))
    {
        return (FARPROC)hook_SRUpdateDSSize;
    }
    else if(!lstrcmpiA( pDelayInfo->dlp.szProcName, "SRRemoveRestorePoint" ))
    {
        return (FARPROC)hook_SRRemoveRestorePoint;
    }    

    return (FARPROC)NULL; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\logfile.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    logfile.cpp

Abstract:
    This file contains the implementation of CRestoreLogFile class and
    ::CreateRestoreLogFile.

Revision History:
    Seong Kook Khang (SKKhang)  06/21/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"


static LPCWSTR  s_cszLogFile = L"%SystemRoot%\\system32\\restore\\rstrlog.dat";


/////////////////////////////////////////////////////////////////////////////
// CRestoreLogFile construction / destruction

CRestoreLogFile::CRestoreLogFile()
{
    m_szLogFile[0] = L'\0';
    m_hfLog        = INVALID_HANDLE_VALUE;
}

CRestoreLogFile::~CRestoreLogFile()
{
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreLogFile - methods

BOOL
CRestoreLogFile::Open()
{
    TraceFunctEnter("CRestoreLogFile::Open");
    BOOL             fRet = FALSE;
    LPCWSTR          cszErr;
    SRstrLogHdrBase  sHdrBase;
    DWORD            dwRes;

    if ( m_hfLog != INVALID_HANDLE_VALUE )
    {
        ErrorTrace(0, "File is already opened...");
        goto Exit;
    }

    if ( !Init() )
        goto Exit;

    m_hfLog = ::CreateFile( m_szLogFile, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
    if ( m_hfLog == INVALID_HANDLE_VALUE )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateFile failed - %ls", cszErr);
        goto Exit;
    }

    READFILE_AND_VALIDATE( m_hfLog, &sHdrBase, sizeof(SRstrLogHdrBase), dwRes, Exit );

    if ( ( sHdrBase.dwSig1 != RSTRLOG_SIGNATURE1 ) ||
         ( sHdrBase.dwSig2 != RSTRLOG_SIGNATURE2 ) ||
         ( sHdrBase.dwVer != RSTRLOG_VERSION ) )
    {
        ErrorTrace(0, "Invalid restore log file header signature...");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::Close()
{
    TraceFunctEnter("CRestoreLogFile::Close");
    BOOL  fRet = TRUE;

    if ( m_hfLog != INVALID_HANDLE_VALUE )
    {
        fRet = ::CloseHandle( m_hfLog );
        if ( fRet )
            m_hfLog = INVALID_HANDLE_VALUE;
    }

    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::ReadHeader( SRstrLogHdrV3 *pRPInfo, CRDIArray &aryDrv )
{
    TraceFunctEnter("CRestoreLogFile::ReadHeader");
    BOOL             fRet = FALSE;
    SRstrLogHdrBase  sHdr;
    DWORD            dwRes;
    DWORD            i;
    CRstrDriveInfo   *pRDI = NULL;

    if ( m_hfLog == INVALID_HANDLE_VALUE )
    {
        ErrorTrace(0, "File is not opened...");
        goto Exit;
    }

    READFILE_AND_VALIDATE( m_hfLog, pRPInfo, sizeof(SRstrLogHdrV3), dwRes, Exit );

    // read drive table information
    for ( i = 0;  i < pRPInfo->dwDrives;  i++ )
    {

        if ( !CreateAndLoadDriveInfoInstance( m_hfLog, &pRDI ) )
            goto Exit;

        if ( !aryDrv.AddItem( pRDI ) )
            goto Exit;
        pRDI = NULL;
    }

    fRet = TRUE;
Exit:
    if ( !fRet )
    {
        aryDrv.DeleteAll();
        SAFE_RELEASE(pRDI);
    }

    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::AppendHeader( SRstrLogHdrV3Ex *pExtInfo )
{
    TraceFunctEnter("CRestoreLogFile::AppendHeader");
    BOOL   fRet = FALSE;
    DWORD  dwRes;

    if ( m_hfLog == INVALID_HANDLE_VALUE )
    {
        ErrorTrace(0, "File is not opened...");
        goto Exit;
    }

    // Assuming ReadHeader has been called to move file pointer to a proper location.
    // Review if explicit setting of file pointer would be necessary.

    WRITEFILE_AND_VALIDATE( m_hfLog, pExtInfo, sizeof(SRstrLogHdrV3Ex), dwRes, Exit );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::WriteEntry( DWORD dwID, CRestoreMapEntry *pEnt, LPCWSTR cszMount )
{
    TraceFunctEnter("CRestoreLogFile::WriteEntry");
    BOOL           fRet = FALSE;
    BYTE           *pBuf = NULL;
    SRstrEntryHdr  *pEntHdr;
    DWORD          dwSize;
    DWORD          dwRes;
    WCHAR          szTemp[SR_MAX_FILENAME_LENGTH];
    DWORD          cbBuf;
    
    if ( m_hfLog == INVALID_HANDLE_VALUE )
    {
        ErrorTrace(0, "File is not opened...");
        goto Exit;
    }

    cbBuf = sizeof(SRstrEntryHdr);
    if (pEnt->GetPath1())
        cbBuf += (lstrlen(pEnt->GetPath1())+1)*sizeof(WCHAR);
    
    if (pEnt->GetPath2())
        cbBuf += (lstrlen(pEnt->GetPath2())+1)*sizeof(WCHAR);
    
    if (pEnt->GetAltPath())
        cbBuf += (lstrlen(pEnt->GetAltPath())+1)*sizeof(WCHAR);
    
    pBuf = (BYTE *) SRMemAlloc(cbBuf);
    if (! pBuf)
    {
        trace(0, "! SRMemAlloc for pBuf");
        goto Exit;
    }

    pEntHdr = (SRstrEntryHdr*) pBuf;
    pEntHdr->dwID  = dwID;
    pEntHdr->dwOpr = pEnt->GetOpCode();
    pEntHdr->llSeq = pEnt->GetSeqNum();
    pEntHdr->dwRes = pEnt->GetResult();
    pEntHdr->dwErr = pEnt->GetError();
    dwSize = sizeof(SRstrEntryHdr);

    // change \\?\Volume{Guid}\path to <Mountpoint>\Path
    wsprintf(szTemp, L"%s\\%s", cszMount, PathFindNextComponent(pEnt->GetPath1()+4));
    dwSize += ::StrCpyAlign4( pBuf+dwSize, szTemp );
    
    if (pEnt->GetPath2())
    	wsprintf(szTemp, L"%s\\%s", cszMount, PathFindNextComponent(pEnt->GetPath2()+4));    	
    dwSize += ::StrCpyAlign4( pBuf+dwSize, pEnt->GetPath2() ? szTemp : NULL );
    
    if (pEnt->GetAltPath())
    	wsprintf(szTemp, L"%s\\%s", cszMount, PathFindNextComponent(pEnt->GetAltPath()+4));    	    	
    dwSize += ::StrCpyAlign4( pBuf+dwSize, pEnt->GetAltPath() ? szTemp : NULL );

    WRITEFILE_AND_VALIDATE( m_hfLog, pBuf, dwSize, dwRes, Exit );

    fRet = TRUE;
Exit:
    if (pBuf)
        SRMemFree(pBuf);
    
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::WriteCollisionEntry( LPCWSTR cszSrc, LPCWSTR cszDst, LPCWSTR cszMount )
{
    TraceFunctEnter("CRestoreLogFile::WriteCollisionEntry");
    BOOL           fRet = FALSE;
    BYTE           *pBuf = NULL;
    SRstrEntryHdr  *pEntHdr;
    DWORD          dwSize;
    DWORD          dwRes;
    WCHAR          szTemp[SR_MAX_FILENAME_LENGTH];
    DWORD          cbBuf;
    
    if ( m_hfLog == INVALID_HANDLE_VALUE )
    {
        ErrorTrace(0, "File is not opened...");
        goto Exit;
    }

    cbBuf = sizeof(SRstrEntryHdr);
    if (cszSrc)
        cbBuf += (lstrlen(cszSrc)+1)*sizeof(WCHAR);

    if (cszDst)
        cbBuf += (lstrlen(cszDst)+1)*sizeof(WCHAR);

    pBuf = (BYTE *) SRMemAlloc(cbBuf);
    if (! pBuf)
    {
        trace(0, "! SRMemAlloc for pBuf");
        goto Exit;
    }

    pEntHdr = (SRstrEntryHdr*) pBuf;
    pEntHdr->dwID  = RSTRLOGID_COLLISION;
    pEntHdr->dwOpr = 0;
    pEntHdr->dwRes = 0;
    pEntHdr->dwErr = 0;
    dwSize = sizeof(SRstrEntryHdr);
    
    wsprintf(szTemp, L"%s\\%s", cszMount, PathFindNextComponent(cszSrc+4));    
    dwSize += ::StrCpyAlign4( pBuf+dwSize, szTemp );
    wsprintf(szTemp, L"%s\\%s", cszMount, PathFindNextComponent(cszDst+4));       
    dwSize += ::StrCpyAlign4( pBuf+dwSize, szTemp );
    dwSize += ::StrCpyAlign4( pBuf+dwSize, NULL );

    WRITEFILE_AND_VALIDATE( m_hfLog, pBuf, dwSize, dwRes, Exit );

    fRet = TRUE;
Exit:
    if (pBuf)
        SRMemFree(pBuf);
    
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::WriteMarker( DWORD dwMarker, DWORD dwErr )
{
    TraceFunctEnter("CRestoreLogFile::WriteMarker");
    BOOL           fRet = FALSE;
    BYTE           szBuf[MAX_PATH];
    SRstrEntryHdr  *pEntHdr = (SRstrEntryHdr*)szBuf;
    DWORD          dwSize;
    DWORD          dwRes;

    if ( m_hfLog == INVALID_HANDLE_VALUE )
    {
        ErrorTrace(0, "File is not opened...");
        goto Exit;
    }

    pEntHdr->dwID  = dwMarker;
    pEntHdr->dwOpr = 0;
    pEntHdr->dwRes = 0;
    pEntHdr->dwErr = dwErr;
    dwSize = sizeof(SRstrEntryHdr);

    WRITEFILE_AND_VALIDATE( m_hfLog, szBuf, dwSize, dwRes, Exit );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::IsValid()
{
    TraceFunctEnter("CRestoreLogFile::IsValid");
    TraceFunctLeave();
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreLogFile::Release()
{
    TraceFunctEnter("CRestoreLogFile::Release");
    Close();
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreLogFile operations

BOOL
CRestoreLogFile::Init()
{
    TraceFunctEnter("CRestoreLogFile::Init");
    BOOL  fRet = FALSE;

    // Construct internal file pathes
    if ( ::ExpandEnvironmentStrings( s_cszLogFile, m_szLogFile, MAX_PATH ) == 0 )
    {
        LPCWSTR cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::ExpandEnvironmentString failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateRestoreLogFile function
//
/////////////////////////////////////////////////////////////////////////////

BOOL
CreateRestoreLogFile( SRstrLogHdrV3 *pRPInfo, CRDIArray &aryDrv )
{
    TraceFunctEnter("CreateRestoreLogFile");
    BOOL             fRet = FALSE;
    LPCWSTR          cszErr;
    WCHAR            szLogFile[MAX_PATH];
    HANDLE           hfLog = INVALID_HANDLE_VALUE;
    SRstrLogHdrBase  sHdr;
    DWORD            dwRes;
    DWORD            i;

    // Construct internal file pathes
    if ( ::ExpandEnvironmentStrings( s_cszLogFile, szLogFile, MAX_PATH ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::ExpandEnvironmentString failed - %ls", cszErr);
        goto Exit;
    }

    // create log file, write header
    hfLog = ::CreateFile( szLogFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_WRITE_THROUGH, NULL );
    if ( hfLog == INVALID_HANDLE_VALUE )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateFile failed - %ls", cszErr);
        goto Exit;
    }

    sHdr.dwSig1 = RSTRLOG_SIGNATURE1;
    sHdr.dwSig2 = RSTRLOG_SIGNATURE2;
    sHdr.dwVer  = RSTRLOG_VERSION;
    WRITEFILE_AND_VALIDATE( hfLog, &sHdr, sizeof(SRstrLogHdrBase), dwRes, Exit );
    WRITEFILE_AND_VALIDATE( hfLog, pRPInfo, sizeof(SRstrLogHdrV3), dwRes, Exit );

    // write drive table information
    for ( i = 0;  i < pRPInfo->dwDrives;  i++ )
    {
        if ( !aryDrv[i]->SaveToLog( hfLog ) )
            goto Exit;
    }

    fRet = TRUE;
Exit:
    if ( hfLog != INVALID_HANDLE_VALUE )
        ::CloseHandle( hfLog );
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// OpenRestoreLogFile function
//
/////////////////////////////////////////////////////////////////////////////

BOOL
OpenRestoreLogFile( CRestoreLogFile **ppLogFile )
{
    TraceFunctEnter("OpenRestoreLogFile");
    BOOL             fRet = FALSE;
    CRestoreLogFile  *pLogFile=NULL;

    if ( ppLogFile == NULL )
    {
        ErrorTrace(0, "Invalid parameter, ppLogFile is NULL.");
        goto Exit;
    }
    *ppLogFile = NULL;

    pLogFile = new CRestoreLogFile;
    if ( pLogFile == NULL )
    {
        ErrorTrace(0, "Insufficient memory...");
        goto Exit;
    }

    if ( !pLogFile->Open() )
        goto Exit;

    *ppLogFile = pLogFile;

    fRet = TRUE;
Exit:
    if ( !fRet )
        SAFE_RELEASE(pLogFile);
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\password.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    srpasswd.cpp
 *
 *  Abstract:
 *    password filter routines to restore user's latest passwords
 *
 *  Revision History:
 *    Henry Lee (henrylee)     06/27/2000     created
 *
 *****************************************************************************/

#include "stdwin.h"
#include <ntlsa.h>
#include <ntsam.h>

extern "C"
{
#include <ntsamp.h>
#include <recovery.h>
}

#include "rstrcore.h"
extern CSRClientLoader  g_CSRClientLoader;

//+---------------------------------------------------------------------------
//
//  Function:   RegisterNotificationDLL
//
//  Synopsis:   registers/unregisters this DLL
//
//  Arguments:  [fRegister] -- TRUE to register, FALSE to unregister
//              [hKeyLM] -- key for HKEY_LOCAL_MACHINE or System
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD RegisterNotificationDLL (HKEY hKeyLM, BOOL fRegister)
{
    HKEY hKey = NULL;    
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ulType;
    ULONG ulSize = MAX_PATH * sizeof(WCHAR);
    WCHAR wcsBuffer[MAX_PATH];
    WCHAR wcsFileName[MAX_PATH];

    GetModuleFileNameW (g_hInst, wcsFileName, MAX_PATH);
    const ULONG ccFileName = lstrlenW (wcsFileName) + 1;

    if (hKeyLM == HKEY_LOCAL_MACHINE)
    {
        lstrcpy (wcsBuffer, L"System\\CurrentControlSet\\Control\\Lsa");
    }
    else
    {
        lstrcpy(wcsBuffer, L"CurrentControlSet\\Control\\Lsa");
        ChangeCCS(hKeyLM, wcsBuffer);        
    }

    dwErr = RegOpenKeyExW (hKeyLM, wcsBuffer,
                           0, KEY_READ | KEY_WRITE, &hKey);

    if (dwErr != ERROR_SUCCESS)
        goto Err;

    dwErr = RegQueryValueEx (hKey, L"Notification Packages",
                                0, &ulType, (BYTE *) wcsBuffer, &ulSize);

    if (dwErr != ERROR_SUCCESS)
        goto Err;

    for (ULONG i=0; i < ulSize/sizeof(WCHAR); i += lstrlenW(&wcsBuffer[i])+1)
    {
        if (fRegister)  // append at end
        {
            if (lstrcmpi (&wcsBuffer[i], wcsFileName) == 0)
                goto Err;               // it's already registered

            if (wcsBuffer[i] == L'\0')  // end of list
            {
                lstrcpy (&wcsBuffer[i], wcsFileName);
                wcsBuffer[ i + ccFileName ] = L'\0';  // add double NULL
                ulSize += ccFileName * sizeof(WCHAR);
                break;
            }
        }
        else // remove from the end
        {
            if (lstrcmpi (&wcsBuffer[i], wcsFileName) == 0)
            {
                wcsBuffer[i] = L'\0';
                ulSize -= ccFileName * sizeof(WCHAR);
                break;
            }
        }
    }

    dwErr = RegSetValueExW (hKey, L"Notification Packages",
                            0, ulType, (BYTE *) wcsBuffer, ulSize);
Err:
    if (hKey != NULL)
        RegCloseKey (hKey);

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDomainId
//
//  Synopsis:   stolen from setup, get the local domain ID
//
//  Arguments:  [ServerHandle] -- handle to the local SAM server
//              [pDomainId] -- output domain ID
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

NTSTATUS GetDomainId (SAM_HANDLE ServerHandle, PSID * pDomainId )
{
    NTSTATUS status = STATUS_SUCCESS;
    SAM_ENUMERATE_HANDLE EnumContext;
    PSAM_RID_ENUMERATION EnumBuffer = NULL;
    DWORD CountReturned = 0;
    PSID LocalDomainId = NULL;
    DWORD LocalBuiltinDomainSid[sizeof(SID) / sizeof(DWORD) + 
                                SID_MAX_SUB_AUTHORITIES];
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    BOOL bExit = FALSE;

    //
    // Compute the builtin domain sid.
    //
    RtlInitializeSid((PSID) LocalBuiltinDomainSid, &BuiltinAuthority, 1);
    *(RtlSubAuthoritySid((PSID)LocalBuiltinDomainSid,  0)) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Loop getting the list of domain ids from SAM
    //
    EnumContext = 0;
    do
    {
        //
        // Get several domain names.
        //
        status = SamEnumerateDomainsInSamServer (
                            ServerHandle,
                            &EnumContext,
                            (PVOID *) &EnumBuffer,
                            8192,
                            &CountReturned );

        if (!NT_SUCCESS (status))
        {
            goto exit;
        }

        if (status != STATUS_MORE_ENTRIES)
        {
            bExit = TRUE;
        }

        //
        // Lookup the domain ids for the domains
        //
        for (ULONG i = 0; i < CountReturned; i++)
        {
            //
            // Free the sid from the previous iteration.
            //
            if (LocalDomainId != NULL)
            {
                SamFreeMemory (LocalDomainId);
                LocalDomainId = NULL;
            }

            //
            // Lookup the domain id
            //
            status = SamLookupDomainInSamServer (
                            ServerHandle,
                            &EnumBuffer[i].Name,
                            &LocalDomainId );

            if (!NT_SUCCESS (status))
            {
                goto exit;
            }

            if (RtlEqualSid ((PSID)LocalBuiltinDomainSid, LocalDomainId))
            {
                continue;
            }

            *pDomainId = LocalDomainId;
            LocalDomainId = NULL;
            status = STATUS_SUCCESS;
            goto exit;
        }

        SamFreeMemory(EnumBuffer);
        EnumBuffer = NULL;
    }
    while (!bExit);

    status = STATUS_NO_SUCH_DOMAIN;

exit:
    if (EnumBuffer != NULL)
        SamFreeMemory(EnumBuffer);

    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   ForAllUsers
//
//  Synopsis:   iterate password changing for all local users
//
//  Arguments:  [hSam] -- handle to open SAM hive
//              [hSecurity] -- handle to open SECURITY hive
//              [hSystem] -- handle to open SYSTEM hive
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

NTSTATUS ForAllUsers (HKEY hSam, HKEY hSecurity, HKEY hSystem)
{
    NTSTATUS nts = STATUS_SUCCESS;
    NTSTATUS ntsEnum = STATUS_SUCCESS;
    BOOLEAN bPresent;
    BOOLEAN bNonNull;
    SAM_HANDLE ServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle;
    SAM_ENUMERATE_HANDLE EnumerationContext = NULL;
    SAM_RID_ENUMERATION *SamRidEnumeration;
    ULONG CountOfEntries;
    ULONG UserRid;
    UNICODE_STRING us;
    PSID LocalDomainId = NULL;
    USER_INTERNAL1_INFORMATION UserPasswordInfo;

    RtlInitUnicodeString (&us, L"");        // this machine
    nts = SamConnect (&us, &ServerHandle, 
                      SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN |
                      SAM_SERVER_ENUMERATE_DOMAINS, 
                      NULL);

    if (!NT_SUCCESS(nts))
        goto Err;

    nts = GetDomainId (ServerHandle, &LocalDomainId);

    if (!NT_SUCCESS(nts))
        goto Err;

    nts = SamOpenDomain( ServerHandle,
                         DOMAIN_READ | DOMAIN_LIST_ACCOUNTS | DOMAIN_LOOKUP |
                         DOMAIN_READ_PASSWORD_PARAMETERS,
                         LocalDomainId,
                         &DomainHandle );

    if (!NT_SUCCESS(nts))
        goto Err;
 
    do
    {
        ntsEnum = nts = SamEnumerateUsersInDomain (
                DomainHandle,
                &EnumerationContext,
                0,
                (PVOID *) &SamRidEnumeration,
                0,
                &CountOfEntries);

        if (nts != STATUS_MORE_ENTRIES && !NT_SUCCESS(nts))
        {
            goto Err;
        }

        for (UINT i=0; i < CountOfEntries; i++)
        {
            ULONG UserRid = SamRidEnumeration[i].RelativeId;

            nts = SamRetrieveOwfPasswordUser( UserRid,
                    hSecurity,
                    hSam,
                    hSystem,
                    NULL,   /* boot key not supported */
                    0,      /* boot key not supported */
                    &UserPasswordInfo.NtOwfPassword,
                    &bPresent,
                    &bNonNull);

            if (!NT_SUCCESS(nts))
                continue;
            
            nts = SamOpenUser (DomainHandle,
                               USER_READ_ACCOUNT | USER_WRITE_ACCOUNT |
                               USER_CHANGE_PASSWORD | 
                               USER_FORCE_PASSWORD_CHANGE,
                               UserRid,
                               &UserHandle);

            if (NT_SUCCESS(nts))
            {
                UserPasswordInfo.NtPasswordPresent = bPresent;
                UserPasswordInfo.LmPasswordPresent = FALSE;
                UserPasswordInfo.PasswordExpired = FALSE;

                nts = SamSetInformationUser(UserHandle,
                                            UserInternal1Information,
                                            &UserPasswordInfo);

                SamCloseHandle (UserHandle);
            }
        }

        SamFreeMemory (SamRidEnumeration);
    }
    while (ntsEnum == STATUS_MORE_ENTRIES);


Err:
    if (ServerHandle != NULL)
        SamCloseHandle (ServerHandle);

    if (DomainHandle != NULL)
        SamCloseHandle (DomainHandle);

    if (LocalDomainId != NULL)
        SamFreeMemory (LocalDomainId);

    return nts;
}

//+---------------------------------------------------------------------------
//
//  Function:   RestoreLsaSecrets
//
//  Synopsis:   restore machine account and autologon passwords
//
//  Arguments:
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD RestoreLsaSecrets ()
{
    HKEY hKey = NULL;
    LSA_OBJECT_ATTRIBUTES loa;
    LSA_HANDLE            hLsa = NULL;
    DWORD dwErr =  ERROR_SUCCESS;
    ULONG ulSize = 0;
    ULONG ulType = 0;
    WCHAR wcsBuffer [MAX_PATH];

    loa.Length                    = sizeof(LSA_OBJECT_ATTRIBUTES);
    loa.RootDirectory             = NULL;
    loa.ObjectName                = NULL;
    loa.Attributes                = 0;
    loa.SecurityDescriptor        = NULL;
    loa.SecurityQualityOfService  = NULL;

    if (LSA_SUCCESS (LsaOpenPolicy(NULL, &loa,
                     POLICY_VIEW_LOCAL_INFORMATION, &hLsa)))
    {
        dwErr = RegOpenKeyExW (HKEY_LOCAL_MACHINE, s_cszSRRegKey,
                           0, KEY_READ | KEY_WRITE, &hKey);

        if (dwErr != ERROR_SUCCESS)
            goto Err;

        ulSize = MAX_PATH * sizeof(WCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx (hKey, s_cszMachineSecret,
                                0, &ulType, (BYTE *) wcsBuffer, &ulSize))
        {
            wcsBuffer [ulSize / 2] = L'\0';
            dwErr = SetLsaSecret (hLsa, s_cszMachineSecret, wcsBuffer);
            if (ERROR_SUCCESS != dwErr)
                goto Err;

            RegDeleteValueW (hKey, s_cszMachineSecret);
        }

        ulSize = MAX_PATH * sizeof(WCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx (hKey, s_cszAutologonSecret,
                                0, &ulType, (BYTE *) wcsBuffer, &ulSize))
        {
            wcsBuffer [ulSize / 2] = L'\0';
            dwErr = SetLsaSecret (hLsa, s_cszAutologonSecret, wcsBuffer);
            if (ERROR_SUCCESS != dwErr)
                goto Err;

            RegDeleteValueW (hKey, s_cszAutologonSecret);
        }
    }
Err:
    if (hKey != NULL)
        RegCloseKey (hKey);

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RestoreRIDs
//
//  Synopsis:   restore next availble RID and password
//
//  Arguments:
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD RestoreRIDs (WCHAR *pszSamPath)
{
    HKEY hKeySam = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ulNextRid = 0;
    ULONG ulOldRid = 0;

    TENTER("RestoreRIDs");

    dwErr = RegLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSAMHiveName,
                         pszSamPath);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegLoadKeyW : %ld", dwErr);
        goto Err;
    }

    dwErr = RegOpenKeyW (HKEY_LOCAL_MACHINE, s_cszSamHiveName, &hKeySam);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegOpenKeyW on %S: %ld", s_cszSamHiveName, dwErr);        
        goto Err;
    }

    dwErr = RtlNtStatusToDosError(SamGetNextAvailableRid (hKeySam, &ulNextRid));
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! SamGetNextAvailableRid : %ld", dwErr);        
        goto Err;
    }

    RegCloseKey (hKeySam);
    hKeySam = NULL;

    dwErr = RegOpenKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSAMHiveName, &hKeySam);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegOpenKeyW on %S: %ld", s_cszRestoreSAMHiveName, dwErr);        
        goto Err;
    }

    // as an optimization we don't set the RID if it didn't change
    if (NT_SUCCESS(SamGetNextAvailableRid (hKeySam, &ulOldRid)) &&
        ulNextRid > ulOldRid)
    {
        dwErr = RtlNtStatusToDosError(SamSetNextAvailableRid (hKeySam,
                                                              ulNextRid));
        if (dwErr != ERROR_SUCCESS)
        {
            trace(0, "! SamSetNextAvailableRid : %ld", dwErr);
        }
    }

Err:
    if (hKeySam != NULL)
    {
        RegCloseKey (hKeySam);
    }
    RegUnLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSAMHiveName);

    TLEAVE();
    return dwErr;
}

DWORD RestorePasswords ()
{
    HKEY hKeySam = NULL, hKeySecurity = NULL, hKeySystem = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsSystem [MAX_PATH];
    WCHAR wcsPath [MAX_PATH];
    BOOLEAN OldPriv;
    CRestorePoint rp;
    DWORD dwTemp;

    InitAsyncTrace();
    
    TENTER("RestorePasswords");
    
    // Attempt to get restore privilege
    dwErr = RtlNtStatusToDosError (RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPriv));

    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RtlAdjustPrivilege : %ld", dwErr);
        goto Err0;
    }

    if (FALSE == GetSystemDrive (wcsSystem))
    {
        dwErr = GetLastError();
        trace(0, "! GetSystemDrive : %ld", dwErr);
        goto Err;
    }

    dwErr = GetCurrentRestorePoint(rp);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! GetCurrentRestorePoint : %ld", dwErr);
        goto Err;
    }

    MakeRestorePath (wcsPath, wcsSystem, rp.GetDir());
    lstrcatW (wcsPath, SNAPSHOT_DIR_NAME);
    lstrcatW (wcsPath, L"\\");
    lstrcatW (wcsPath, s_cszHKLMFilePrefix);
    lstrcatW (wcsPath, s_cszSamHiveName);

    dwErr = RegLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSAMHiveName, wcsPath);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegLoadKeyW on %S: %ld", s_cszRestoreSAMHiveName, dwErr);
        goto Err;
    }

    dwErr = RegOpenKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSAMHiveName, &hKeySam);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegOpenKeyW on %S: %ld", s_cszRestoreSAMHiveName, dwErr);
        goto Err;
    }

    MakeRestorePath (wcsPath, wcsSystem, rp.GetDir());
    lstrcatW (wcsPath, SNAPSHOT_DIR_NAME);
    lstrcatW (wcsPath, L"\\");
    lstrcatW (wcsPath, s_cszHKLMFilePrefix);
    lstrcatW (wcsPath, s_cszSecurityHiveName);

    dwErr = RegLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSECURITYHiveName, wcsPath);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegLoadKeyW on %S: %ld", s_cszRestoreSECURITYHiveName, dwErr);        
        goto Err;
    }
    
    dwErr = RegOpenKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSECURITYHiveName,&hKeySecurity);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegOpenKeyW on %S: %ld", s_cszRestoreSECURITYHiveName, dwErr);
        goto Err;
    }

    MakeRestorePath (wcsPath, wcsSystem, rp.GetDir());
    lstrcatW (wcsPath, SNAPSHOT_DIR_NAME);
    lstrcatW (wcsPath, L"\\");
    lstrcatW (wcsPath, s_cszHKLMFilePrefix);
    lstrcatW (wcsPath, s_cszSystemHiveName);

    dwErr = RegLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSYSTEMHiveName, wcsPath);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegLoadKeyW on %S: %ld", s_cszRestoreSYSTEMHiveName, dwErr);           
        goto Err;
    }

    dwErr = RegOpenKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSYSTEMHiveName, &hKeySystem);
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RegOpenKeyW on %S: %ld", s_cszRestoreSYSTEMHiveName, dwErr);        
        goto Err;
    }

    dwErr = RtlNtStatusToDosError(ForAllUsers(hKeySam,hKeySecurity,hKeySystem));
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! ForAllUsers : %ld", dwErr);
        goto Err;
    }

    dwErr = RestoreLsaSecrets ();
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! RestoreLsaSecrets : %ld", dwErr);           
    }
       

Err:
    if (hKeySam != NULL)
    {
        RegCloseKey (hKeySam);
    }

    dwTemp = RegUnLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSAMHiveName);
    if (ERROR_SUCCESS != dwTemp)
    {
        trace(0, "! RegUnLoadKeyW 0n %S : %ld", s_cszRestoreSAMHiveName, dwTemp);
    }
    
    if (hKeySecurity != NULL)
    {
        RegCloseKey (hKeySecurity);
    }
    dwTemp = RegUnLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSECURITYHiveName);
    if (ERROR_SUCCESS != dwTemp)
    {
        trace(0, "! RegUnLoadKeyW 0n %S : %ld", s_cszRestoreSECURITYHiveName, dwTemp);
    }
    
    if (hKeySystem != NULL)
    {
        RegCloseKey (hKeySystem);
    }
    dwTemp = RegUnLoadKeyW (HKEY_LOCAL_MACHINE, s_cszRestoreSYSTEMHiveName);
    if (ERROR_SUCCESS != dwTemp)
    {
        trace(0, "! RegUnLoadKeyW 0n %S : %ld", s_cszRestoreSYSTEMHiveName, dwTemp);
    }
    
    // restore the old privilege
    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, OldPriv, FALSE, &OldPriv);

Err0:
    // unregister this notification package
    RegisterNotificationDLL (HKEY_LOCAL_MACHINE, FALSE);

    TermAsyncTrace();
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForSAM
//
//  Synopsis:   waits for SAM database to initialize
//
//  Arguments:
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD WINAPI WaitForSAM (VOID *pv)
{
    NTSTATUS nts = STATUS_SUCCESS;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;

    // Load SRClient
    g_CSRClientLoader.LoadSrClient();
    
    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    nts = NtOpenEvent( &EventHandle,
                       SYNCHRONIZE|EVENT_MODIFY_STATE,
                       &EventAttributes );

    if ( !NT_SUCCESS(nts))
    {
        if( nts == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            nts = NtCreateEvent( &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE ); // The event is initially not signaled

            if( nts == STATUS_OBJECT_NAME_EXISTS ||
                nts == STATUS_OBJECT_NAME_COLLISION )
            {
                //
                // second chance, if the SAM created the event before we did
                //

                nts = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );
            }
        }

    }
    //
    // Loop waiting.
    //

    if (NT_SUCCESS(nts))
    {
        WaitStatus = WaitForSingleObject( EventHandle, 60*1000 ); // 60 Seconds

        if ( WaitStatus == WAIT_TIMEOUT )
        {
             nts = STATUS_TIMEOUT;
        }
        else if ( WaitStatus != WAIT_OBJECT_0 )
        {
             nts = STATUS_UNSUCCESSFUL;
        }
    }

    (VOID) NtClose( EventHandle );

    if (NT_SUCCESS(nts))   // Okay, SAM is available
    {
        dwErr = RestorePasswords();
    }
    else 
    {
        dwErr = RtlNtStatusToDosError (nts);
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeChangeNotify and PasswordChangeNotify
//
//  Synopsis:   callback functions from SAM
//
//  Arguments:
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

BOOLEAN NTAPI InitializeChangeNotify ()
{
     // we will call LoadSRClient from WaitForSAM
    
    HANDLE hThread = CreateThread (NULL,
                                   0,
                                   WaitForSAM,
                                   NULL,
                                   0,
                                   NULL);
    return TRUE;
}

NTSTATUS NTAPI PasswordChangeNotify ( PUNICODE_STRING UserName, 
                                      ULONG RelativeId,
                                      PUNICODE_STRING NewPassword )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\progress.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    progress.cpp

Abstract:
    This file contains the implementation of CRestoreProgressWindow class and
    ::CreateRestoreProgressWindow.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"


// Number of change log entries corresponding to one physical progress position.
//#define NUM_INC_PER_POS  5
// Time for each increment of progress bar during snapshot handling (msec.)
//#define TIMER_SNAPSHOT   40

// Position (percent) of progress bar where "restore" stage starts.
#define PROGBAR_POS_RESTORE   20
// Position (percent) of progress bar where "snapshot" stage starts.
#define PROGBAR_POS_SNAPSHOT  90


/////////////////////////////////////////////////////////////////////////////
// CRestoreOperationManager construction / destruction

CRestoreProgressWindow::CRestoreProgressWindow()
{
    m_hWnd      = NULL;
    m_hbmBrand  = NULL;
    m_hFntTitle = NULL;
    m_cxBar     = 0;
}

/////////////////////////////////////////////////////////////////////////////

CRestoreProgressWindow::~CRestoreProgressWindow()
{
    Close();
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreProgressWindow - methods

BOOL
CRestoreProgressWindow::Create()
{
    TraceFunctEnter("CRestoreProgressWindow::Create");
    BOOL  fRet = FALSE;
    HWND  hWnd;

    hWnd = ::CreateDialogParam( g_hInst, MAKEINTRESOURCE(IDD_PROGRESS), NULL, ExtDlgProc, (LPARAM)this );
    if ( hWnd == NULL )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateDialogParam failed - %ls", cszErr);
        goto Exit;
    }
    if ( hWnd != m_hWnd )
    {
        ErrorTrace(0, "Internal mismatch - hWnd=%08X, m_hWnd=%08X", hWnd, m_hWnd);
        m_hWnd = hWnd;
    }

    ::ShowWindow( m_hWnd, SW_SHOW );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreProgressWindow::Close()
{
    TraceFunctEnter("CRestoreProgressWindow::Create");
    BOOL  fRet = FALSE;

    if ( m_hWnd != NULL && ::SendMessage( m_hWnd, WM_CLOSE, 0, 0 ) == 0 )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::SendMessage failed - %ls", cszErr);
        goto Exit;
    }

    m_hWnd = NULL;

    if ( m_hbmBrand != NULL )
    {
        ::DeleteObject( m_hbmBrand );
        m_hbmBrand = NULL;
    }

    if ( m_hFntTitle != NULL )
    {
        ::DeleteObject( m_hFntTitle );
        m_hFntTitle = NULL;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreProgressWindow::Run()
{
    TraceFunctEnter("CRestoreProgressWindow::Run");
    MSG  msg;

    while ( ::GetMessage( &msg, NULL, 0, 0 ) )
    {
        if ( !::IsDialogMessage( m_hWnd, &msg ) )
        {
            ::TranslateMessage( &msg );
            ::DispatchMessage( &msg );
        }
    }

    TraceFunctLeave();
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreProgressWindow::SetStage( DWORD dwStage, DWORD dwBase )
{
    TraceFunctEnter("CRestoreProgressWindow::SetStage");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    UINT     uIdStatus;
    WCHAR    szStatus[MAX_STR];

    m_dwStage = dwStage;

    switch ( dwStage )
    {
    case RPS_PREPARE :
        uIdStatus   = IDS_PROGRESS_PREPARE;
        m_dwPosReal = 0;
        break;

    case RPS_RESTORE :
        uIdStatus   = IDS_PROGRESS_RESTORE;
        m_dwBase    = dwBase;
        m_dwPosReal = PROGBAR_POS_RESTORE * m_cxBar / 100;
        m_dwPosLog  = 0;
        break;

    case RPS_SNAPSHOT :
        uIdStatus   = IDS_PROGRESS_SNAPSHOT;
        m_dwPosReal = PROGBAR_POS_SNAPSHOT * m_cxBar / 100;
        break;

    default :
        ErrorTrace(0, "Unknown Stage constant - %u", dwStage );
        goto Exit;
    }

    szStatus[0] = L'\0';
    if ( ::LoadString( g_hInst, uIdStatus, szStatus, MAX_STR ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", uIdStatus, cszErr);
        // ignore error...
    }
    else if ( !::SetDlgItemText( m_hWnd, IDC_PROGDLG_STATUS, szStatus ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::SetDlgItemText failed - %ls", cszErr);
        // ignore error...
    }

    ::SendDlgItemMessage( m_hWnd, IDC_PROGDLG_BAR, PBM_SETPOS, m_dwPosReal, 0 );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreProgressWindow::Increment()
{
    TraceFunctEnter("CRestoreProgressWindow::Increment");
    BOOL   fRet = FALSE;
    DWORD  dwPosNew;

    //m_dwPosLog++;
    dwPosNew = m_dwPosReal;

    switch ( m_dwStage )
    {
    case RPS_PREPARE :
        //dwPosNew = ( m_dwPosLog / NUM_INC_PER_POS ) % ( m_cxBar + 1 );
        break;

    case RPS_RESTORE :
        m_dwPosLog++;
        if ( m_dwPosLog > m_dwBase )
        {
            ErrorTrace(0, "INTERNAL: m_dwPosLog(%u) is bigger than m_dwBase(%u)", m_dwPosLog, m_dwBase);
            m_dwPosLog = m_dwBase;
        }
        //dwPosNew = ( m_dwPosLog - 1 ) * m_cxBar / m_dwBase + 1;
        if (m_dwBase > 0)
        {
            dwPosNew = ( m_dwPosLog - 1 ) * m_cxBarReal / m_dwBase + 1 +
                        PROGBAR_POS_RESTORE * m_cxBar / 100;
        }        
        break;

    case RPS_SNAPSHOT :
        //dwPosNew = m_dwPosLog % ( m_cxBar + 1 );
        dwPosNew = m_cxBar;
        break;

    default :
        ErrorTrace(0, "m_dwStage(%u) is not Prepare or Restore...", m_dwStage);
        goto Exit;
    }

    if ( dwPosNew != m_dwPosReal )
    {
        m_dwPosReal = dwPosNew;
        ::SendDlgItemMessage( m_hWnd, IDC_PROGDLG_BAR, PBM_SETPOS, dwPosNew, 0 );
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreProgressWindow::Release()
{
    TraceFunctEnter("CRestoreProgressWindow::Release");
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreProgressWindow operations

BOOL
CRestoreProgressWindow::Init()
{
    TraceFunctEnter("CRestoreProgressWindow::Init");
    BOOL                  fRet = FALSE;
    INITCOMMONCONTROLSEX  sICC;

    sICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    sICC.dwICC  = ICC_PROGRESS_CLASS;
    if ( !::InitCommonControlsEx( &sICC ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::InitCommonControlsEx failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreProgressWindow::LoadAndSetBrandBitmap( HWND hDlg )
{
    TraceFunctEnter("CRestoreProgressWindow::LoadAndSetBrandBitmap");
    BOOL        fRet = FALSE;
    LPCWSTR     cszErr;
    HDC         hDC = NULL;
    int         nResIdBmp;
    HBITMAP     hbmBrand;
    BITMAP      bm;
    HWND        hwndBmp;
    RECT        rcCtrl;

    hDC = ::CreateCompatibleDC( NULL );
    if ( hDC == NULL )
    {
        cszErr = ::GetSysErrStr();
        FatalTrace(0, "::CreateCompatibleDC(NULL) failed - %ls", cszErr);
        goto Exit;
    }
    if ( ::GetDeviceCaps( hDC, BITSPIXEL ) > 8 )
        nResIdBmp = IDB_PROG_BRAND8;
    else
        nResIdBmp = IDB_PROG_BRAND4;
    ::DeleteDC( hDC );

    if ( m_hbmBrand != NULL )
    {
        if ( nResIdBmp == m_nResId )
        {
            // The current bitmap is compatible with new display setting.
            fRet = TRUE;
            goto Exit;
        }

        m_nResId = nResIdBmp;
        ::DeleteObject( m_hbmBrand );
    }

    hbmBrand = (HBITMAP)::LoadImage( g_hInst, MAKEINTRESOURCE(nResIdBmp),
                                        IMAGE_BITMAP, 0, 0, 0 );
    if ( hbmBrand == NULL )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadImage(%d) failed - %ls", nResIdBmp, cszErr);
        goto Exit;
    }
    // Get dimension of the bitmap.
    ::GetObject( hbmBrand, sizeof(bm), &bm );
    // Static control does not support RTL layout. Mirror the bitmap if necessary.
    if ( ( ::GetWindowLong( hDlg, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL ) != 0 )
    {
        HDC      hDCSrc, hDCDst;
        HBITMAP  hbmRTL;

        hDC = ::CreateCompatibleDC( NULL );
        hDCSrc = ::CreateCompatibleDC( hDC );
        hDCDst = ::CreateCompatibleDC( hDC );
        hbmRTL = ::CreateBitmapIndirect( &bm );
        ::SelectObject( hDCSrc, hbmBrand );
        ::SelectObject( hDCDst, hbmRTL );
        ::StretchBlt( hDCDst, 0, 0, bm.bmWidth, bm.bmHeight,
                            hDCSrc, bm.bmWidth-1, 0, -bm.bmWidth, bm.bmHeight,
                            SRCCOPY );
        ::DeleteDC( hDCDst );
        ::DeleteDC( hDCSrc );
        ::DeleteDC( hDC );
        ::DeleteObject( hbmBrand );
        m_hbmBrand = hbmRTL;
    }
    else
    {
        m_hbmBrand = hbmBrand;
    }


    // Get dimension of the static control.
    hwndBmp = ::GetDlgItem( hDlg, IDC_PROGDLG_BITMAP );
    ::GetWindowRect( hwndBmp, &rcCtrl );
    ::MapWindowPoints( NULL, hDlg, (LPPOINT)&rcCtrl, 2 );

    // Set the image.
    ::SendMessage( hwndBmp, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_hbmBrand );
    // Set width of the static control.
    ::SetWindowPos( hwndBmp, NULL,
                    rcCtrl.left,
                    (rcCtrl.bottom-rcCtrl.top-bm.bmHeight)/2+rcCtrl.top,
                    bm.bmWidth,
                    bm.bmHeight,
                    SWP_NOZORDER );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreProgressWindow operations - dialog procedure

INT_PTR CALLBACK
CRestoreProgressWindow::ExtDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    TraceFunctEnter("CRestoreProgressWindow::ExtDlgProc");
    int                     nRet = FALSE;
    CRestoreProgressWindow  *pProgWnd;

    if ( wMsg == WM_INITDIALOG )
    {
        ::SetWindowLong( hDlg, DWL_USER, lParam );
        pProgWnd = (CRestoreProgressWindow*)lParam;
    }
    else
    {
        pProgWnd = (CRestoreProgressWindow*)::GetWindowLong( hDlg, DWL_USER );
        if ( pProgWnd == NULL )
            goto Exit;
    }

    nRet = pProgWnd->RPWDlgProc( hDlg, wMsg, wParam, lParam );

Exit:
    TraceFunctLeave();
    return( nRet );
}

/////////////////////////////////////////////////////////////////////////////

int
CRestoreProgressWindow::RPWDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    TraceFunctEnter("CRestoreProgressWindow::RPWDlgProc");
    int      nRet = FALSE;
    HFONT    hFont;
    LOGFONT  lf;
    HDC      hDC;
    RECT     rcClient;
    UINT     uID;
    HBRUSH   hbrTitle;

    switch ( wMsg )
    {
    case WM_INITDIALOG :
        m_hWnd = hDlg;

        // Create a large font for branding title.
        hFont = (HFONT)::SendDlgItemMessage( hDlg, IDC_PROGDLG_TITLE, WM_GETFONT, 0, 0 );
        ::GetObject( hFont, sizeof(lf), &lf );
        hDC = ::GetDC( hDlg );
        lf.lfHeight = 0 - ( ::GetDeviceCaps( hDC, LOGPIXELSY ) * 12 / 72 );
        lf.lfWeight = FW_BOLD;
        ::ReleaseDC( hDlg, hDC );
        m_hFntTitle = ::CreateFontIndirect( &lf );
        ::SendDlgItemMessage( hDlg, IDC_PROGDLG_TITLE, WM_SETFONT, (WPARAM)m_hFntTitle, FALSE );

        // Load branding bitmap.
        LoadAndSetBrandBitmap( hDlg );

        // Get width of the progress bar.
        ::GetClientRect( ::GetDlgItem( hDlg, IDC_PROGDLG_BAR ), &rcClient );
        m_cxBar = rcClient.right - rcClient.left;
        m_cxBarReal = m_cxBar * ( PROGBAR_POS_SNAPSHOT - PROGBAR_POS_RESTORE ) / 100;
        // Set range of progress bar so it would exactly match with
        // real size, and set initial position to 0.
        ::SendDlgItemMessage( hDlg, IDC_PROGDLG_BAR, PBM_SETRANGE32, 0, m_cxBar );
        ::SendDlgItemMessage( hDlg, IDC_PROGDLG_BAR, PBM_SETPOS, 0, 0 );

        break;

    case WM_CLOSE :
        if ( !::DestroyWindow( hDlg ) )
        {
            LPCWSTR  cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::DestroyWindow failed - %ls", cszErr);
            goto Exit;
        }
        ::SetWindowLong( hDlg, DWL_MSGRESULT, 1 );
        break;

    case WM_CTLCOLORSTATIC :
        uID = ::GetWindowLong( (HWND)lParam, GWL_ID );
        if ( ( uID == IDC_PROGDLG_BITMAP ) || ( uID == IDC_PROGDLG_TITLE ) )
        {
            ::SetBkMode( (HDC)wParam, TRANSPARENT );
            hbrTitle = (HBRUSH)::GetStockObject( NULL_BRUSH );
        }
        else
            hbrTitle = NULL;
        nRet = (int)hbrTitle;
        goto Exit;

    case WM_DISPLAYCHANGE :
        LoadAndSetBrandBitmap( hDlg );
        break;

    case WM_DESTROY :
        ::PostQuitMessage( 0 );
        break;

    default:
        goto Exit;
    }

    nRet = TRUE;
Exit:
    TraceFunctLeave();
    return( nRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateRestoreProgressWindow function
//
/////////////////////////////////////////////////////////////////////////////

BOOL
CreateRestoreProgressWindow( CRestoreProgressWindow **ppProgWnd )
{
    TraceFunctEnter("CreateRestoreProgressWindow");
    BOOL                    fRet = FALSE;
    CRestoreProgressWindow  *pProgWnd=NULL;

    if ( ppProgWnd == NULL )
    {
        FatalTrace(0, "Invalid parameter, ppProgWnd is NULL.");
        goto Exit;
    }
    *ppProgWnd = NULL;

    pProgWnd = new CRestoreProgressWindow;
    if ( pProgWnd == NULL )
    {
        FatalTrace(0, "Insufficient memory...");
        goto Exit;
    }

    if ( !pProgWnd->Init() )
        goto Exit;

    *ppProgWnd = pProgWnd;

    fRet = TRUE;
Exit:
    if ( !fRet )
        SAFE_RELEASE(pProgWnd);
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\mapentry.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    mapentry.cpp

Abstract:
    This file contains the implementation of CRestoreMapEntry class
    derived classes for each operation types, and ::CreateRestoreMapEntry.

Revision History:
    Seong Kook Khang (SKKhang)  06/22/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"
#include "malloc.h"

static LPCWSTR  s_cszErr;



inline BOOL  IsLockedError( DWORD dwErr )
{
    return( ( dwErr == ERROR_ACCESS_DENIED ) ||
            ( dwErr == ERROR_SHARING_VIOLATION ) ||
            ( dwErr == ERROR_USER_MAPPED_FILE ) ||
            ( dwErr == ERROR_LOCK_VIOLATION ) );
}

BOOL  RenameLockedObject( LPCWSTR cszPath, LPWSTR szAlt )
{
    TraceFunctEnter("RenameLockedObject");
    BOOL  fRet = FALSE;

    //BUGBUG - following code is not guaranteeing the new name is unique.
    // In a rare instance, if same file name already exists in one of
    // the map entries, conflict might happen.
    if ( !::SRGetAltFileName( cszPath, szAlt ) )
        goto Exit;

    if ( !::MoveFile( cszPath, szAlt ) )
    {
        s_cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::MoveFile failed - %ls", s_cszErr);
        ErrorTrace(0, "    From Dst=%ls", cszPath);
        ErrorTrace(0, "    To Src=%ls", szAlt);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// Class Definitions
//
/////////////////////////////////////////////////////////////////////////////

// Process Dependency Flags
#define PDF_LOC   0x0001    // Dependency for location, e.g. Del & RENAME TO
#define PDF_OBJ   0x0002    // Dependency for object, e.g. Add & Rename FROM
#define PDF_BOTH  (PDF_LOC|PDF_OBJ)


/////////////////////////////////////////////////////////////////////////////

class CRMEDirCreate : public CRestoreMapEntry
{
public:
    CRMEDirCreate( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszShortFileName);

// operations - methods
public:
    void  Restore( CRestoreOperationManager* );
};

/////////////////////////////////////////////////////////////////////////////

class CRMEDirDelete : public CRestoreMapEntry
{
public:
    CRMEDirDelete( INT64 llSeq, LPCWSTR cszSrc );

// operations - methods
public:
    void  Restore( CRestoreOperationManager *pROMgr );
    void  ProcessLocked();
};

/////////////////////////////////////////////////////////////////////////////

class CRMEDirRename : public CRestoreMapEntry
{
public:
    CRMEDirRename( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszDst,
                   LPCWSTR cszShortFileName);

// operations - methods
public:
    LPCWSTR  GetPath2()
    {  return( m_strDst );  }
    void  Restore( CRestoreOperationManager *pROMgr );
    void  ProcessLocked();
};

/////////////////////////////////////////////////////////////////////////////

class CRMEFileCreate : public CRestoreMapEntry
{
public:
    CRMEFileCreate( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszTmp,
                    LPCWSTR cszShortFileName);

// operations - methods
public:
    LPCWSTR  GetPath2()
    {  return( m_strTmp );  }
    void  Restore( CRestoreOperationManager *pROMgr );
    void  ProcessLocked();    
};

/////////////////////////////////////////////////////////////////////////////

class CRMEFileDelete : public CRestoreMapEntry
{
public:
    CRMEFileDelete( INT64 llSeq, LPCWSTR cszSrc );

// operations - methods
public:
    void  Restore( CRestoreOperationManager *pROMgr );
    void  ProcessLocked();
};

/////////////////////////////////////////////////////////////////////////////

class CRMEFileModify : public CRestoreMapEntry
{
public:
    CRMEFileModify( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszTmp );

// operations - methods
public:
    LPCWSTR  GetPath2()
    {  return( m_strTmp );  }
    void  Restore( CRestoreOperationManager* );
    void  ProcessLocked();
};

/////////////////////////////////////////////////////////////////////////////

class CRMEFileRename : public CRestoreMapEntry
{
public:
    CRMEFileRename( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszDst,
                    LPCWSTR cszShortFileName );

// operations - methods
public:
    LPCWSTR  GetPath2()
    {  return( m_strDst );  }
    void  Restore( CRestoreOperationManager *pROMgr );
    void  ProcessLocked();
};

/////////////////////////////////////////////////////////////////////////////

class CRMESetAcl : public CRestoreMapEntry
{
public:
    CRMESetAcl( INT64 llSeq, LPCWSTR cszSrc, LPBYTE pbAcl, DWORD cbAcl, BOOL fInline, LPCWSTR cszDSPath );
    //CRMESetAcl( LPCWSTR cszSrc, LPBYTE pbAcl, DWORD cbAcl );
    //CRMESetAcl( LPCWSTR cszSrc, LPCWSTR cszAcl );
    ~CRMESetAcl();

// operations - methods
public:
    void  Restore( CRestoreOperationManager* );

// attributes
protected:
    CSRStr  m_strAclPath;   // string is empty if it's an inline Acl
    DWORD   m_cbAcl;
    LPBYTE  m_pbAcl;    // this is actually a SECURITY_DESCRIPTOR (with
                        // 20 bytes of header for self-relative format.)
};

/////////////////////////////////////////////////////////////////////////////

class CRMESetAttrib : public CRestoreMapEntry
{
public:
    CRMESetAttrib( INT64 llSeq, LPCWSTR cszSrc, DWORD dwAttr );

// operations - methods
public:
    void  Restore( CRestoreOperationManager* );
};

/////////////////////////////////////////////////////////////////////////////

class CRMEMountDelete : public CRestoreMapEntry
{
public:
    CRMEMountDelete( INT64 llSeq, LPCWSTR cszSrc );

// operations - methods
public:
    void  Restore( CRestoreOperationManager* );
};

/////////////////////////////////////////////////////////////////////////////

class CRMEMountCreate : public CRestoreMapEntry
{
public:
    CRMEMountCreate( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszDst);

// operations - methods
public:
    void  Restore( CRestoreOperationManager* );
};


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreMapEntry
//
/////////////////////////////////////////////////////////////////////////////

CRestoreMapEntry::CRestoreMapEntry( INT64 llSeq, DWORD dwOpr, LPCWSTR cszSrc )
{
    m_llSeq  = llSeq;
    m_dwOpr  = dwOpr;
    m_dwAttr = 0;
    m_strSrc = cszSrc;
    m_dwRes  = RSTRRES_UNKNOWN;
    m_dwErr  = 0;
}

/////////////////////////////////////////////////////////////////////////////

void
CRestoreMapEntry::ProcessLockedAlt()
{
    TraceFunctEnter("CRestoreMapEntry::ProcessLockedAlt");

    if ( !MoveFileDelay( m_strAlt, NULL ) )
        m_dwRes = RSTRRES_FAIL;

    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreMapEntry::Release()
{
    delete this;
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreMapEntry::ClearAccess( LPCWSTR cszPath )
{
    (void)::SetFileAttributes( cszPath, FILE_ATTRIBUTE_NORMAL );
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreMapEntry::MoveFileDelay( LPCWSTR cszSrc, LPCWSTR cszDst )
{
    TraceFunctEnter("CRestoreMapEntry::MoveFileDelay");
    BOOL  fRet = FALSE;

    if ( !::MoveFileEx( cszSrc, cszDst, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING ) )
    {
        m_dwErr = ::GetLastError();
        s_cszErr = ::GetSysErrStr(m_dwErr);
        ErrorTrace(0, "::MoveFileEx() failed - %ls", s_cszErr);
        ErrorTrace(0, "    From Src=%ls to Dst=%ls", cszSrc, cszDst);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////

void
CRestoreMapEntry::ProcessDependency( CRestoreOperationManager *pROMgr, DWORD dwFlags )
{
    TraceFunctEnter("CRestoreMapEntry::ProcessDependency");
    CRestoreMapEntry  *pEnt;

    if ( dwFlags & PDF_LOC )
    if ( pROMgr->FindDependentMapEntry( m_strSrc, TRUE, &pEnt ) )
        pEnt->SetResults( RSTRRES_LOCKED, 0 );

    if ( dwFlags & PDF_OBJ )
    if ( pROMgr->FindDependentMapEntry( m_strDst, FALSE, &pEnt ) )
        pEnt->SetResults( RSTRRES_LOCKED, 0 );

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEDirCreate
//
/////////////////////////////////////////////////////////////////////////////

CRMEDirCreate::CRMEDirCreate( INT64 llSeq, LPCWSTR cszSrc,
                              LPCWSTR cszShortFileName )
    : CRestoreMapEntry( llSeq, OPR_DIR_CREATE, cszSrc )
{
    m_strShortFileName = cszShortFileName;        
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_EXISTS if directory already exists.
// RSTRRES_FAIL   if file of same name already exists. (BUGBUG)
// RSTRRES_FAIL   if CreateDirectory API fails because of any other reasons.
// RSTRRES_OK     if directory is created successfully.
//
void  CRMEDirCreate::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEDirCreate::Restore");
    LPCWSTR  cszSrc;
    DWORD    dwAttr;
    BOOL     fCollision = FALSE;
    cszSrc = m_strSrc;
    DebugTrace(0, "DirCreate: Src=%ls", cszSrc);

    dwAttr = ::GetFileAttributes( cszSrc );
    if ( dwAttr != 0xFFFFFFFF )
    {
        if ( dwAttr & FILE_ATTRIBUTE_DIRECTORY )
        {
            m_dwRes = RSTRRES_EXISTS;
            DebugTrace(0, "The directory already exists...");
            //BUGBUG - Need to copy meta data...?
            goto Exit;
        }
        else
        {
            // let's rename the conflicting file to an alternate name, and keep going
            WCHAR   szAlt[SR_MAX_FILENAME_LENGTH];
            LPCWSTR cszMount;

            DebugTrace(0, "Entry already exists, but is not a directory!!!");
            DebugTrace(0, "    Src=%ls", cszSrc);

            if (FALSE == RenameLockedObject(cszSrc, szAlt))
            {
                ErrorTrace(0, "! RenameLockedObject");            
                m_dwRes = RSTRRES_FAIL;
                goto Exit;
            }

            m_strAlt = szAlt;
            fCollision = TRUE;  
        }
    }
     // The following function creates all sub directories under the
     // specified filename. 
     // we will ignore the error code from this function since the
     // directory may be able to be created anyway.
    CreateBaseDirectory(cszSrc);

     // now create the directory
    if ( !::CreateDirectory( cszSrc, NULL ) )
    {
        DWORD dwErr = SRCreateSubdirectory (cszSrc, NULL); // try renaming

        if (dwErr != ERROR_SUCCESS)
        {
            m_dwErr = dwErr;
            s_cszErr = ::GetSysErrStr( m_dwErr );
            m_dwRes = RSTRRES_FAIL;
            ErrorTrace(0, "SRCreateSubdirectory failed - %ls", s_cszErr);
            ErrorTrace(0, "    Src=%ls", cszSrc);
            goto Exit;
        }
    }

     // also set the short file name for the directory.
    SetShortFileName(cszSrc, m_strShortFileName);

    if (fCollision)
    {
        m_dwRes = RSTRRES_COLLISION;
    }
    else
    {
        m_dwRes = RSTRRES_OK;
    }

Exit:
    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEDirDelete
//
/////////////////////////////////////////////////////////////////////////////

CRMEDirDelete::CRMEDirDelete( INT64 llSeq, LPCWSTR cszSrc )
    : CRestoreMapEntry( llSeq, OPR_DIR_DELETE, cszSrc )
{
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_NOTFOUND if directory does not exist.
// RSTRRES_LOCKED   if directory itself or one of file/dir inside is locked.
// RSTRRES_IGNORE   if directory is not empty and requires dependency scan.
// RSTRRES_FAIL     if RemoveDirectory API fails because of any other reasons.
// RSTRRES_OK       if directory is deleted successfully.
//
void  CRMEDirDelete::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEDirDelete::Restore");
    LPCWSTR  cszSrc;

    cszSrc = m_strSrc;
    DebugTrace(0, "DirDelete: Src=%ls", cszSrc);

    if ( ::GetFileAttributes( cszSrc ) == 0xFFFFFFFF )
    {
        m_dwRes = RSTRRES_NOTFOUND;
        DebugTrace(0, "The directory not found...");
        goto Exit;
    }

    // RemoveDirectory might fail if the directory is read-only.
    (void)::ClearFileAttribute( cszSrc, FILE_ATTRIBUTE_READONLY );
    // Ignore even if it fails, as delete might succeed.

    if ( !::RemoveDirectory( cszSrc ) )
    {
        //BUGBUG - distinguish the reason of failure...
        m_dwErr = ::GetLastError();
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::RemoveDirectory failed - %ls", s_cszErr);
        ErrorTrace(0, "    Src=%ls", cszSrc);

        if ( ::IsLockedError(m_dwErr) )
        {
            ProcessDependency( pROMgr, PDF_LOC );
            m_dwRes = RSTRRES_LOCKED;
            goto Exit;
        }

        if ( m_dwErr == ERROR_DIR_NOT_EMPTY )
        {
            // Temporary Hack, just set result to RSTRRES_IGNORE to initiate
            // dependency scanning.
            m_dwRes = RSTRRES_IGNORE;
        }
        else
            m_dwRes = RSTRRES_FAIL;

#if 0
        // Scan for dependency...

        if ( FALSE /*dependency exists*/ )
        {
            DebugTrace(0, "Conflict detected, renaming to %ls", L"xxx");

            // Rename to prevent conflict

            if ( TRUE /*rename succeeded*/ )
            {
                m_dwRes = RSTRRES_CONFLICT;
            }
            else
            {
                //BUGBUG - this will overwrite LastError from RemoveDirectory...
                m_dwErr = ::GetLastError();
                s_cszErr = ::GetSysErrStr( m_dwErr );
                ErrorTrace(0, "::MoveFile failed - %ls", s_cszErr);
                m_dwRes = RSTRRES_FAIL;
            }
        }
        else
        {
            m_dwRes = RSTRRES_IGNORE;
        }
#endif

        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

void  CRMEDirDelete::ProcessLocked()
{
    TraceFunctEnter("CRMEDirDelete::ProcessLocked");

    if ( !MoveFileDelay( m_strSrc, NULL ) )
        m_dwRes = RSTRRES_FAIL;

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEDirRename
//
/////////////////////////////////////////////////////////////////////////////

CRMEDirRename::CRMEDirRename( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszDst,
                              LPCWSTR cszShortFileName )
    : CRestoreMapEntry( llSeq, OPR_DIR_RENAME, cszSrc )
{
    m_strDst = cszDst;
    m_strShortFileName = cszShortFileName;            
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_FAIL      if source directory does not exist.
// RSTRRES_COLLISION if target directory/file already exists.
// RSTRRES_LOCKED    if source directory itself or one of file/dir inside is locked.
// RSTRRES_FAIL      if MoveFile API fails because of any other reasons.
// RSTRRES_OK        if directory is renamed successfully.
//
// NOTE: Src and Dst are same with original operation. Which means,
//  restore should rename Dst to Src.
//
void  CRMEDirRename::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEDirRename::Restore");
    LPCWSTR           cszSrc, cszDst;
    DWORD             dwAttr;
    CRestoreMapEntry  *pEntNext;
    BOOL              fCollision = FALSE;
    
    cszSrc = m_strSrc;
    cszDst = m_strDst;
    DebugTrace(0, "DirRename: Src=%ls, Dst=%ls", cszSrc, cszDst);    

    if ( ::GetFileAttributes( cszDst ) == 0xFFFFFFFF )
    {
        m_dwErr = ERROR_NOT_FOUND;
        m_dwRes = RSTRRES_FAIL;
        ErrorTrace(0, "The current directory not found...");
        ErrorTrace(0, "    Dst=%ls", cszDst);
        goto Exit;
    }
    dwAttr = ::GetFileAttributes( cszSrc );
    if ( dwAttr != 0xFFFFFFFF )
    {
        WCHAR   szAlt[SR_MAX_FILENAME_LENGTH];
        
        DebugTrace(0, "Entry already exists, but is not a directory!!!");
        if (FALSE == RenameLockedObject(cszSrc, szAlt))
        {
            ErrorTrace(0, "! RenameLockedObject");            
            m_dwRes = RSTRRES_FAIL;
            goto Exit;
        }
        m_strAlt = szAlt;
        fCollision = TRUE;
    }

    // Check the next entry to see if this is a folder creation using
    // explorer. Note, only the immediately next entry will be checked,
    // to prevent any confusion or complications due to a dependency.
    if ( pROMgr->GetNextMapEntry( &pEntNext ) )
    if ( pEntNext->GetOpCode() == OPR_DIR_DELETE )
    if ( ::StrCmpI( cszSrc, pEntNext->GetPath1() ) == 0 )
    {
        // Found match, just update path name of the next entry...
        pEntNext->UpdateSrc( cszDst );
        m_dwRes = RSTRRES_IGNORE;
        goto Exit;
    }

    if ( !::MoveFile( cszDst, cszSrc ) )
    {
        m_dwErr = ::GetLastError();
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::MoveFile failed - %ls", s_cszErr);
        ErrorTrace(0, "    From Dst=%ls to Src=%ls", cszDst, cszSrc);

        if ( ::IsLockedError(m_dwErr) )
        {
            ProcessDependency( pROMgr, PDF_BOTH );
            m_dwRes = RSTRRES_LOCKED;
        }
        else
            m_dwRes = RSTRRES_FAIL;

        goto Exit;
    }

     // also set the short file name for the directory.
    SetShortFileName(cszSrc, m_strShortFileName);    

    if (fCollision)
        m_dwRes = RSTRRES_COLLISION;
    else        
        m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

void  CRMEDirRename::ProcessLocked()
{
    TraceFunctEnter("CRMEDirRename::ProcessLocked");

    if ( !MoveFileDelay( m_strDst, m_strSrc ) )
        m_dwRes = RSTRRES_FAIL;

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEFileCreate
//
/////////////////////////////////////////////////////////////////////////////

CRMEFileCreate::CRMEFileCreate( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszTmp,
                                LPCWSTR cszShortFileName)
    : CRestoreMapEntry( llSeq, OPR_FILE_ADD, cszSrc )
{
    m_strTmp = cszTmp;
    m_strShortFileName = cszShortFileName;    
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_OPTIMIZED if filter didn't make temp file for optimization purpose.
// RSTRRES_FAIL      if SRCopyFile fails because of any other reasons.
// RSTRRES_OK        if file is created successfully.
//
void  CRMEFileCreate::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEFileCreate::Restore");
    LPCWSTR  cszSrc, cszTmp;
    DWORD    dwRet;
    BOOL     fCollision = FALSE;
    DWORD    dwAttr;
    
    // If filter didn't make temp file because there's corresponding
    // file delete entry, simply ignore this entry.
    if ( m_strTmp.Length() == 0 )
    {
        m_dwRes = RSTRRES_OPTIMIZED;
        goto Exit;
    }

    cszSrc = m_strSrc;
    cszTmp = m_strTmp;
    DebugTrace(0, "FileCreate: Src=%ls", cszSrc);
    DebugTrace(0, "FileCreate: Tmp=%ls", cszTmp);

    // if the file already exists, rename existing and
    // continue - renamed file will be reported on result page
    dwAttr = ::GetFileAttributes( cszSrc );
    if ( dwAttr != 0xFFFFFFFF )
    {
        WCHAR   szAlt[SR_MAX_FILENAME_LENGTH];            
        
        DebugTrace(0, "Entry already exists!");
        if (FALSE == RenameLockedObject(cszSrc, szAlt))
        {
            CRestoreMapEntry  *pEnt;
            DebugTrace(0, "! RenameLockedObject");
             // check for any dependent operations that will fail
             // since this restore operation cannot proceed.
            if ( pROMgr->FindDependentMapEntry( m_strSrc, TRUE, &pEnt ) )
                pEnt->SetResults( RSTRRES_LOCKED, 0 );                
            m_dwRes = RSTRRES_LOCKED;            
            goto Exit;
        }
        m_strAlt = szAlt;
        fCollision = TRUE;
    }
    
     // create the parent directory if it does not exist
    CreateBaseDirectory(cszSrc);
    
    dwRet = ::SRCopyFile( cszTmp, cszSrc );
    if ( dwRet != ERROR_SUCCESS )
    {
        m_dwRes = RSTRRES_FAIL;
        m_dwErr = dwRet;
        goto Exit;
    }

     // also set the short file name for the File
    SetShortFileName(cszSrc, m_strShortFileName);    

    if (fCollision)
        m_dwRes = RSTRRES_COLLISION;
    else
        m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}


void  CRMEFileCreate::ProcessLocked()
{
    TraceFunctEnter("CRMEFileCreate::ProcessLocked");
    LPCWSTR  cszSrc, cszTmp;
    WCHAR    szAlt[SR_MAX_FILENAME_LENGTH];
    DWORD    dwErr;

    // If filter didn't make temp file because there's corresponding
    // file delete entry, simply ignore this entry.
    if ( m_strTmp.Length() == 0 )
    {
        m_dwRes = RSTRRES_OPTIMIZED;
        goto Exit;
    }
    
    cszSrc = m_strSrc;
    cszTmp = m_strTmp;
    

    DebugTrace(0, "Processlocked: Src=%ls", cszSrc);
    DebugTrace(0, "Processlocked: Tmp=%ls", cszTmp);

    if ( !::SRGetAltFileName( cszSrc, szAlt ) )
        goto Exit;    

    DebugTrace(0, "Processlocked: Alt=%ls", szAlt);
    
    dwErr = ::SRCopyFile( cszTmp, szAlt );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto Exit;
    }
    if ( !MoveFileDelay( szAlt, cszSrc ) )
        m_dwRes = RSTRRES_FAIL;
    
Exit:
    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEFileDelete
//
/////////////////////////////////////////////////////////////////////////////

CRMEFileDelete::CRMEFileDelete( INT64 llSeq, LPCWSTR cszSrc )
    : CRestoreMapEntry( llSeq, OPR_FILE_DELETE, cszSrc )
{
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_NOTFOUND   if file does not exist.
// RSTRRES_LOCKED_ALT if file is locked but can be renamed.
// RSTRRES_LOCKED     if file is locked and cannot be renamed.
// RSTRRES_FAIL       if DeleteFile API fails because of any other reasons.
// RSTRRES_OK         if file is deleted successfully.
//
void  CRMEFileDelete::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEFileDelete::Restore");
    LPCWSTR  cszSrc;
    WCHAR    szAlt[SR_MAX_FILENAME_LENGTH];

    cszSrc = m_strSrc;
    DebugTrace(0, "FileDelete: Src=%ls", cszSrc);

    if ( ::GetFileAttributes( cszSrc ) == 0xFFFFFFFF )
    {
        m_dwRes = RSTRRES_NOTFOUND;
        DebugTrace(0, "The file not found...");
        goto Exit;
    }

    (void)::ClearFileAttribute( cszSrc, FILE_ATTRIBUTE_READONLY );
    // Ignore even if it fails, because delete might succeed.

    if ( !::DeleteFile( cszSrc ) )
    {
        m_dwErr  = ::GetLastError();
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::DeleteFile failed - '%ls'", s_cszErr);

        if ( ::IsLockedError(m_dwErr) )
        {
            if ( ::RenameLockedObject( cszSrc, szAlt ) )
            {
                m_strAlt = szAlt;
                m_dwRes  = RSTRRES_LOCKED_ALT;
            }
            else
            {
                CRestoreMapEntry  *pEnt;
                 // check for any dependent operations that will fail
                 // since this restore operation cannot proceed.
                if ( pROMgr->FindDependentMapEntry( m_strSrc, FALSE, &pEnt ) )
                    pEnt->SetResults( RSTRRES_LOCKED, 0 );                
                m_dwRes = RSTRRES_LOCKED;
            }
        }
        else
            m_dwRes = RSTRRES_FAIL;

        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

void  CRMEFileDelete::ProcessLocked()
{
    TraceFunctEnter("CRMEFileDelete::ProcessLocked");

    if ( !MoveFileDelay( m_strSrc, NULL ) )
        m_dwRes = RSTRRES_FAIL;

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEFileModify
//
/////////////////////////////////////////////////////////////////////////////

CRMEFileModify::CRMEFileModify( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszTmp )
    : CRestoreMapEntry( llSeq, OPR_FILE_MODIFY, cszSrc )
{
    m_strTmp = cszTmp;
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_LOCKED_ALT if target file is locked but can be renamed.
// RSTRRES_FAIL       if target file is renamed but SRCopyFile still fails.
// RSTRRES_LOCKED     if target file is locked and cannot be renamed.
// RSTRRES_FAIL       if SRCopyFile fails because of any other reasons.
// RSTRRES_OK         if file is updated successfully.
//
void  CRMEFileModify::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEFileModify::Restore");
    LPCWSTR  cszSrc, cszTmp;
    WCHAR    szAlt[SR_MAX_FILENAME_LENGTH];

    cszSrc = m_strSrc;
    cszTmp = m_strTmp;
    DebugTrace(0, "FileModify: Src=%ls", cszSrc);
    DebugTrace(0, "FileModify: Tmp=%ls", cszTmp);

     // create the parent directory if it does not exist
    CreateBaseDirectory(cszSrc);
    
    m_dwErr = ::SRCopyFile( cszTmp, cszSrc );
    if ( m_dwErr != ERROR_SUCCESS )
    {
        if ( ::IsLockedError(m_dwErr) )
        {
            if ( ::RenameLockedObject( cszSrc, szAlt ) )
            {
                m_dwErr = ::SRCopyFile( cszTmp, cszSrc );
                if ( m_dwErr == ERROR_SUCCESS )
                {
                    m_strAlt = szAlt;
                    m_dwRes  = RSTRRES_LOCKED_ALT;
                }
                else
                    m_dwRes = RSTRRES_FAIL;
            }
            else
            {
                CRestoreMapEntry  *pEnt;

                 // Copy Tmp to Alt, we already have szAlt path name.
                m_dwErr = ::SRCopyFile( cszTmp, szAlt );
                if ( m_dwErr != ERROR_SUCCESS )
                {
                    m_dwRes = RSTRRES_FAIL;
                    goto Exit;
                }

                m_strAlt = szAlt;

                 // check for any dependent operations that will fail
                 // since this restore operation cannot proceed.
                
                
                if ( pROMgr->FindDependentMapEntry( m_strSrc, TRUE, &pEnt ) )
                    pEnt->SetResults( RSTRRES_LOCKED, 0 );
                m_dwRes = RSTRRES_LOCKED;
            }
        }
        else
            m_dwRes = RSTRRES_FAIL;

        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

void  CRMEFileModify::ProcessLocked()
{
    TraceFunctEnter("CRMEFileModify::ProcessLocked");

     // the problem here is that the file m_strAlt may not exist if
     // the FileModify was triggered as a dependency of another
     // operation (can only be a rename).  However, restore fails
     // before getting to this point - so this bug will be fixed for
     // longhorn unless reported by a customer.
    if ( !MoveFileDelay( m_strAlt, m_strSrc ) )
        m_dwRes = RSTRRES_FAIL;

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMEFileRename
//
/////////////////////////////////////////////////////////////////////////////

CRMEFileRename::CRMEFileRename( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszDst,
                                LPCWSTR cszShortFileName)
    : CRestoreMapEntry( llSeq, OPR_FILE_RENAME, cszSrc )
{
    m_strDst = cszDst;
    m_strShortFileName = cszShortFileName;        
}

/////////////////////////////////////////////////////////////////////////////
//
// RSTRRES_FAIL      if source file does not exist.
// RSTRRES_COLLISION if target file/directory already exists.
// RSTRRES_LOCKED    if source file is locked.
// RSTRRES_FAIL      if MoveFile API fails because of any other reasons.
// RSTRRES_OK        if file is renamed successfully.
//
// NOTE: Src and Dst are same with original operation. Which means,
//  restore should rename Dst to Src.
//
void  CRMEFileRename::Restore( CRestoreOperationManager *pROMgr )
{
    TraceFunctEnter("CRMEFileRename::Restore");
    LPCWSTR  cszSrc, cszDst;
    DWORD    dwAttr;
    BOOL     fCollision = FALSE;
    WCHAR    szAlt[SR_MAX_FILENAME_LENGTH];
            
    cszSrc = m_strSrc;
    cszDst = m_strDst;
    DebugTrace(0, "FileRename: Src=%ls", cszSrc);
    DebugTrace(0, "FileRename: Dst=%ls", cszDst);

    if ( ::GetFileAttributes( cszDst ) == 0xFFFFFFFF )
    {
        m_dwErr = ERROR_NOT_FOUND;
        m_dwRes = RSTRRES_FAIL;
        ErrorTrace(0, "The current file not found...");
        ErrorTrace(0, "    Dst=%ls", cszDst);
        goto Exit;
    }

    //
    // if source already exists, then need to get it out of the way
    //
    
    if ( ::StrCmpI( cszSrc, cszDst ) != 0 )
    {        
        dwAttr = ::GetFileAttributes( cszSrc );
        if ( dwAttr != 0xFFFFFFFF )
        {
            DebugTrace(0, "The target file already exists...");

            //
            // take care of the case where source has same name as destination's short filename
            // we don't want to inadvertently shoot ourselves in the foot
            // so we rename it to an alternate name, and rename the alternate name to the original source
            //
            
            WIN32_FIND_DATA wfd;        
            HANDLE          hFile = INVALID_HANDLE_VALUE;
            BOOL            fRenameAlt = FALSE;
            
            if ((hFile = FindFirstFile(cszDst, &wfd)) != INVALID_HANDLE_VALUE)
            {
                if ( ::StrCmpI(wfd.cAlternateFileName, PathFindFileName(cszSrc)) == 0)
                {                
                    fRenameAlt = TRUE;
                    trace(0, "Source filename same as dest's shortname");

                    // so construct a filename that will surely have a different short
                    // filename than the source
                    // prefix the unique name generated by restore with "sr" so that 
                    // this will get a different shortname
                    
                    WCHAR szModifiedDst[SR_MAX_FILENAME_LENGTH];
                    
                    lstrcpy(szModifiedDst, cszDst);
                    LPWSTR pszDstPath = wcsrchr(szModifiedDst, L'\\');
                    if (pszDstPath)
                    {
                        *pszDstPath = L'\0';
                    }
                    lstrcat(szModifiedDst, L"\\sr");
                    lstrcat(szModifiedDst, PathFindFileName(cszDst));

                    if (FALSE == SRGetAltFileName(szModifiedDst, szAlt))
                    {
                        ErrorTrace(0, "! SRGetAltFileName");    
                        m_dwRes = RSTRRES_FAIL;
                        goto Exit;
                    }

                    trace(0, "szAlt for unique shortname: %S", szAlt);

                    // now rename the original destination to this
                    
                    if (FALSE == MoveFile(cszDst, szAlt))
                    {
                        m_dwErr = GetLastError();                        
                        ErrorTrace(0, "! MoveFile %ld: %S to %S", m_dwErr, cszDst, szAlt);
                        m_dwRes = RSTRRES_FAIL;
                        goto Exit;
                    }

                    // and setup this to be renamed to the original source
                    
                    cszDst = szAlt;
                    fRenameAlt = TRUE;
                }
                FindClose(hFile);
            }
            else
            {
                trace(0, "! FindFirstFile : %ld", GetLastError());
            }
            
            if (! fRenameAlt)
            {
                if (FALSE == RenameLockedObject(cszSrc, szAlt))
                {
                    ErrorTrace(0, "! RenameLockedObject");            
                    m_dwErr= ERROR_ALREADY_EXISTS;
                    ProcessDependency( pROMgr, PDF_BOTH );
                    m_dwRes = RSTRRES_LOCKED;
                    goto Exit;
                }
                m_strAlt = szAlt;
                fCollision = TRUE;
            }
        }            
    }

     // create the parent directory if it does not exist
    CreateBaseDirectory(cszSrc);    

    if ( !::MoveFile( cszDst, cszSrc ) )
    {
        m_dwErr = ::GetLastError();
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::MoveFile failed - %ls", s_cszErr);
        ErrorTrace(0, "    From Dst=%ls to Src=%ls", cszDst, cszSrc);

        if ( ::IsLockedError(m_dwErr) )
        {
            ProcessDependency( pROMgr, PDF_BOTH );
            m_dwRes = RSTRRES_LOCKED;
        }
        else
            m_dwRes = RSTRRES_FAIL;

        goto Exit;
    }
    
     // also set the short file name for the file
    SetShortFileName(cszSrc, m_strShortFileName);    

    if (fCollision)
        m_dwRes = RSTRRES_COLLISION;
    else        
        m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

void  CRMEFileRename::ProcessLocked()
{
    TraceFunctEnter("CRMEFileRename::ProcessLocked");

    if ( !MoveFileDelay( m_strDst, m_strSrc ) )
        m_dwRes = RSTRRES_FAIL;

    TraceFunctLeave();
}

// This takes a filename of the type
// \device\harddiskvolume1\system vol info\_restore{GUID}\rp1\s001.acl
// and converts it to 
// \rp1\s001.acl 
void GetDSRelativeFileName(IN const WCHAR * pszFileName,
                           OUT WCHAR * pszRelativeFileName )
{
    TraceFunctEnter("GetDSRelativeFileName");
    
    WCHAR szFileNameCopy[MAX_PATH];
    WCHAR * pszCurrentPosition;
    WCHAR * pszLastSlash;    

    DebugTrace(0, "Acl file is %S", pszFileName);
    
     // initially copy input into the output buffer. This is what will
     // be returned if there is an unexpected error
    lstrcpy(pszRelativeFileName, pszFileName);
    
     // copy the file into a temporary buffer
    lstrcpy(szFileNameCopy, pszRelativeFileName );
    
     // Look for the trailing \   
    pszCurrentPosition= wcsrchr( szFileNameCopy, L'\\' );
     // bail if no \ was found or if we are at the start of the string
    if ( (NULL == pszCurrentPosition) ||
         (pszCurrentPosition == szFileNameCopy))
    {
        DebugTrace(0, "no \\ in the string");
        _ASSERT(0);
        goto cleanup;
    }
    pszLastSlash = pszCurrentPosition;
     // null terminate at the last slash so that we can find the next slash
    * pszLastSlash = L'\0';
    
     // Look for the next trailing \   
    pszCurrentPosition= wcsrchr( szFileNameCopy, L'\\' );
     // bail if no \ was found or if we are at the start of the string
    if (NULL == pszCurrentPosition) 
    {
        DebugTrace(0, "no second \\ in the string");
        _ASSERT(0);
        goto cleanup;
    }    
     // restore the  last slash 
    * pszLastSlash = L'\\';        
    
        
     // we have the relative path
    lstrcpy(pszRelativeFileName,pszCurrentPosition);
cleanup:
    
    TraceFunctLeave();
    return;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRMESetAcl
//
/////////////////////////////////////////////////////////////////////////////

CRMESetAcl::CRMESetAcl( INT64 llSeq, LPCWSTR cszSrc, LPBYTE pbAcl, DWORD cbAcl, BOOL fInline, LPCWSTR cszDSPath )
    : CRestoreMapEntry( llSeq, OPR_SETACL, cszSrc )
{
    if ( fInline )
    {
        m_cbAcl = cbAcl;
        m_pbAcl = new BYTE[cbAcl];
        if ( m_pbAcl != NULL )
            ::CopyMemory( m_pbAcl, pbAcl, cbAcl );
    }
    else
    {
        WCHAR  szAclPath[MAX_PATH];
        WCHAR  szRelativeAclFile[MAX_PATH];
        
         // in this case the path that the filter has given us looks like
         // \device\harddiskvolume1\system vol info\_restore{GUID}\rp1\s001.acl
         //
         // We need to change this file name to \rp1\s001.acl so that we
         // can prepend the DS path to this.
        GetDSRelativeFileName((LPCWSTR)pbAcl, szRelativeAclFile );

        ::lstrcpy( szAclPath, cszDSPath );
        ::PathAppend( szAclPath, (LPCWSTR)szRelativeAclFile);
        m_strAclPath = szAclPath;
        m_pbAcl      = NULL;
    }
}

/*
CRMESetAcl::CRMESetAcl( LPCWSTR cszSrc, LPBYTE pbAcl, DWORD cbAcl )
    : CRestoreMapEntry( OPR_SETACL, cszSrc )
{
    m_cbAcl = cbAcl;
    m_pbAcl = new BYTE[cbAcl];
    if ( m_pbAcl != NULL )
        ::CopyMemory( m_pbAcl, pbAcl, cbAcl );
}

CRMESetAcl::CRMESetAcl( LPCWSTR cszSrc, LPCWSTR cszAcl )
    : CRestoreMapEntry( OPR_SETACL, cszSrc )
{
    m_strAclPath = cszAcl;
    m_pbAcl = NULL;
}
*/

CRMESetAcl::~CRMESetAcl()
{
    SAFE_DEL_ARRAY(m_pbAcl);
}

/////////////////////////////////////////////////////////////////////////////

void  CRMESetAcl::Restore( CRestoreOperationManager* )
{
    TraceFunctEnter("CRMESetAcl::Restore");
    LPCWSTR     cszErr;
    LPCWSTR     cszSrc, cszAcl;
    
    SECURITY_INFORMATION SecurityInformation;
    PISECURITY_DESCRIPTOR_RELATIVE pRelative;

    cszSrc = m_strSrc;
    cszAcl = m_strAclPath;
    DebugTrace(0, "SetAcl: Src=%ls, path=%ls, cbAcl=%d", cszSrc, cszAcl, m_cbAcl);

    // read content of Acl if it's not inline
    if ( m_strAclPath.Length() > 0 )
    {
        HANDLE  hfAcl;
        DWORD   dwRes;
        
        hfAcl = ::CreateFile( cszAcl, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
        if ( hfAcl == INVALID_HANDLE_VALUE )
        {
            m_dwErr = ::GetLastError();
            m_dwRes = RSTRRES_FAIL;
            s_cszErr = ::GetSysErrStr( m_dwErr );
            ErrorTrace(0, "::CreateFile failed - %ls", s_cszErr);
            ErrorTrace(0, "    Acl=%ls", cszAcl);
            goto Exit;
        }
        m_cbAcl = ::GetFileSize( hfAcl, NULL );
        if ( m_cbAcl == 0xFFFFFFFF )
        {
            m_dwErr = ::GetLastError();
            m_dwRes = RSTRRES_FAIL;
            s_cszErr = ::GetSysErrStr( m_dwErr );
            ErrorTrace(0, "::GetFileSize failed - %ls", s_cszErr);
            ::CloseHandle( hfAcl );
            goto Exit;
        }
        m_pbAcl = new BYTE[m_cbAcl];
        if ( m_pbAcl == NULL )
        {
            m_dwErr = ERROR_NOT_ENOUGH_MEMORY;
            m_dwRes = RSTRRES_FAIL;
            FatalTrace(0, "Insufficient memory...");
            ::CloseHandle( hfAcl );
            goto Exit;
        }
        if ( !::ReadFile( hfAcl, m_pbAcl, m_cbAcl, &dwRes, NULL ) )
        {
            m_dwErr = ::GetLastError();
            m_dwRes = RSTRRES_FAIL;
            s_cszErr = ::GetSysErrStr( m_dwErr );
            ErrorTrace(0, "::ReadFile failed - %ls", s_cszErr);
            ::CloseHandle( hfAcl );
            goto Exit;
        }
        ::CloseHandle( hfAcl );
    }

    if ( m_pbAcl == NULL || m_cbAcl == 0 )
    {
        m_dwErr = ERROR_INTERNAL_ERROR;
        m_dwRes = RSTRRES_FAIL;
        ErrorTrace(0, "Null ACL...");
        goto Exit;
    }

    (void)::TakeOwnership( cszSrc );

    // Ignore any error because taking ownership might not be necessary.


    //
    // set the security info flags according to the data we have stored
    // in the self-relative sd.
    //

    pRelative = (PISECURITY_DESCRIPTOR_RELATIVE)m_pbAcl;

    if ((pRelative->Revision != SECURITY_DESCRIPTOR_REVISION) ||
        ((pRelative->Control & SE_SELF_RELATIVE) != SE_SELF_RELATIVE))
    {
        m_dwErr = ERROR_INTERNAL_ERROR;
        m_dwRes = RSTRRES_FAIL;
        ErrorTrace(0, "BAD SD FORMAT...");
        goto Exit;
    }

    //
    // paulmcd: 1/24/01
    // put all four flags on.  this way we always blast all four there.
    // this will not create the exact same SD on the file, as we
    // might have an SE_SACL_PRESENT control flag, but no SACL, but 
    // it will always create the semantically equivelant SD and will
    // delete anything that should not be there.
    //
   
    SecurityInformation = OWNER_SECURITY_INFORMATION
                            |GROUP_SECURITY_INFORMATION
                            |DACL_SECURITY_INFORMATION
                            |SACL_SECURITY_INFORMATION;

    //
    // paulmcd: copied from base\win32\client\backup.c
    //
    // If the security descriptor has AUTO_INHERITED set, 
    // set the appropriate REQ bits.
    //
    if (pRelative->Control & SE_DACL_AUTO_INHERITED) {
        pRelative->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if (pRelative->Control & SE_SACL_AUTO_INHERITED) {
        pRelative->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }

    if ( !::SetFileSecurity( cszSrc,
                             SecurityInformation,
                             (PSECURITY_DESCRIPTOR)m_pbAcl ) )
    {
        m_dwErr = ::GetLastError();
        m_dwRes = RSTRRES_FAIL;
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::SetFileSecurity failed - %ls", s_cszErr);
        ErrorTrace(0, "    Src=%ls", cszSrc);
        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    // delete Acl if it's not inline
    if ( m_strAclPath.Length() > 0 )
        SAFE_DEL_ARRAY(m_pbAcl);

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRMESetAttrib
//
/////////////////////////////////////////////////////////////////////////////

CRMESetAttrib::CRMESetAttrib( INT64 llSeq, LPCWSTR cszSrc, DWORD dwAttr )
    : CRestoreMapEntry( llSeq, OPR_SETATTRIB, cszSrc )
{
    m_dwAttr = dwAttr;
}

/////////////////////////////////////////////////////////////////////////////

void  CRMESetAttrib::Restore( CRestoreOperationManager* )
{
    TraceFunctEnter("CRMESetAttrib::Restore");
    LPCWSTR  cszSrc;

    cszSrc = m_strSrc;
    DebugTrace(0, "SetAttrib: Src=%ls, Attr=%08X", cszSrc, m_dwAttr);

    if ( !::SetFileAttributes( cszSrc, m_dwAttr ) )
    {
        m_dwErr = ::GetLastError();
        m_dwRes = RSTRRES_IGNORE;
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::SetFileAttributes failed - %ls", s_cszErr);
        ErrorTrace(0, "    Src=%ls, Attr=%08X", cszSrc, m_dwAttr);
        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////
//
// CRMEMountDelete
//
/////////////////////////////////////////////////////////////////////////////

CRMEMountDelete::CRMEMountDelete( INT64 llSeq, LPCWSTR cszSrc )
    : CRestoreMapEntry( llSeq, SrEventMountDelete, cszSrc )
{
}

/////////////////////////////////////////////////////////////////////////////

void  CRMEMountDelete::Restore( CRestoreOperationManager* )
{
    TraceFunctEnter("CRMEMountDelete::Restore");
    WCHAR * cszSrc;
    DWORD   dwBufReqd;

     // allocate space for the buffer since we have to append \\ to
     // the mount directory. Extra chars are for the trailing \\ and
     // the \0
    dwBufReqd = (lstrlen(m_strSrc) + 5) * sizeof(WCHAR);
    
    cszSrc = (WCHAR *) alloca(dwBufReqd);
        
    if (NULL == cszSrc)
    {
        ErrorTrace(0, "alloca for size %d failed", dwBufReqd);
        m_dwRes = RSTRRES_FAIL;
        goto Exit;
    }

    lstrcpy(cszSrc, m_strSrc);
    
    if (cszSrc[lstrlen(cszSrc) - 1] != L'\\')
    {
        wcscat(cszSrc, L"\\");
    }
    DebugTrace(0, "MountDelete: Src=%S", cszSrc);

    if ( FALSE == DoesDirExist( cszSrc )  )
    {
        m_dwRes = RSTRRES_NOTFOUND;
        DebugTrace(0, "The file not found...");
        goto Exit;
    }    

    (void)::ClearFileAttribute( cszSrc, FILE_ATTRIBUTE_READONLY );
    // Ignore even if it fails, because delete might succeed.

    if ( !::DeleteVolumeMountPoint(cszSrc))
    {
        m_dwErr = ::GetLastError();
         // we can ignore this error for restore purposes
        m_dwRes = RSTRRES_IGNORE;
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::DeleteVolumeMountPoint failed - '%ls'", s_cszErr);
        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////
//
// CRMEMountCreate
//
/////////////////////////////////////////////////////////////////////////////

CRMEMountCreate::CRMEMountCreate( INT64 llSeq, LPCWSTR cszSrc, LPCWSTR cszDst)
    : CRestoreMapEntry( llSeq, SrEventMountCreate, cszSrc )
{
    m_strDst = cszDst;    
}

/////////////////////////////////////////////////////////////////////////////

void  CRMEMountCreate::Restore( CRestoreOperationManager* )
{
    TraceFunctEnter("CRMEMountCreate::Restore");
    WCHAR * cszSrc;
    WCHAR * cszVolumeName;
    DWORD   dwBufReqd;

     // allocate space for the buffer since we have to append \\ to
     // the mount directory. Extra chars are for the trailing \\ and
     // the \0
    dwBufReqd = (lstrlen(m_strSrc) + 5) * sizeof(WCHAR);
    
    cszSrc = (WCHAR *) alloca(dwBufReqd);
        
    if (NULL == cszSrc)
    {
        ErrorTrace(0, "alloca for size %d failed", dwBufReqd);
        m_dwRes = RSTRRES_FAIL;
        goto Exit;
    }

    lstrcpy(cszSrc, m_strSrc);
    
    if (cszSrc[lstrlen(cszSrc) - 1] != L'\\')
    {
        wcscat(cszSrc, L"\\");
    }

     // allocate space for the volume name since we have to append \\ to
     // the volume name. Extra chars are for the trailing \\ and
     // the \0
    dwBufReqd = (lstrlen(m_strDst) + 5) * sizeof(WCHAR);
    
    cszVolumeName = (WCHAR *) alloca(dwBufReqd);
        
    if (NULL == cszVolumeName)
    {
        ErrorTrace(0, "alloca for size %d failed", dwBufReqd);
        m_dwRes = RSTRRES_FAIL;
        goto Exit;
    }

    lstrcpy(cszVolumeName, m_strDst);
    
    if (cszVolumeName[lstrlen(cszVolumeName) - 1] != L'\\')
    {
        wcscat(cszVolumeName, L"\\");
    }
    
    DebugTrace(0, "MountDelete: Src=%S, Volume Name=%S", cszSrc,cszVolumeName);

    if ( FALSE == DoesDirExist( cszSrc )  )
    {
         // try to create the directory if it does not exist
        if (FALSE ==CreateDirectory( cszSrc, // directory name
                                     NULL))  // SD
        {
            m_dwErr = ::GetLastError();
            m_dwRes = RSTRRES_FAIL;
            s_cszErr = ::GetSysErrStr( m_dwErr );
            ErrorTrace(0, "CreateDirectory failed %S", s_cszErr);
            goto Exit;
        }
    }

     // Workaround for filter bug where the filter
     // gives the volume name in the format \??\Volume{098089}\ 
     // whereas the correct format is \\?\Volume{098089}\ 
    cszVolumeName[1] = L'\\';
    
    if ( !::SetVolumeMountPoint(cszSrc, cszVolumeName))
    {
        m_dwErr = ::GetLastError();
        m_dwRes = RSTRRES_IGNORE;
        s_cszErr = ::GetSysErrStr( m_dwErr );
        ErrorTrace(0, "::DeleteVolumeMountPoint failed - '%ls'", s_cszErr);
        goto Exit;
    }

    m_dwRes = RSTRRES_OK;

Exit:
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////
//
// CreateRestoreMapEntry
//
/////////////////////////////////////////////////////////////////////////////

/*
// NOTE - 8/1/00 - skkhang
//
// Commented out to incorporate excluding restore map logic.
// But DO NOT delete this until we are comfortable 100% about removing
// restore map.
//
CRestoreMapEntry*
CreateRestoreMapEntry( RestoreMapEntry* pRME, LPCWSTR cszDrv, LPCWSTR cszDSPath )
{
    TraceFunctEnter("CreateRestoreMapEntry");
    LPCWSTR               cszSrc;
    PVOID                 pOpt;
    WCHAR                 szSrc[MAX_PATH];
    WCHAR                 szOpt[MAX_PATH];
    CRestoreMapEntry      *pEnt = NULL;

    //cszSrc = (LPCWSTR)pRME->m_bData;
    ::lstrcpy( szSrc, cszDrv );
    ::PathAppend( szSrc, (LPCWSTR)pRME->m_bData );

    pOpt = ::GetOptional( pRME );

    switch ( pRME->m_dwOperation )
    {
    case OPR_DIR_CREATE :
        pEnt = new CRMEDirCreate( szSrc );
        break;
    case OPR_DIR_DELETE :
        pEnt = new CRMEDirDelete( szSrc );
        break;
    case OPR_DIR_RENAME :
        ::lstrcpy( szOpt, cszDrv );
        ::PathAppend( szOpt, (LPCWSTR)pOpt );
        pEnt = new CRMEDirRename( szSrc, szOpt );
        break;
    case OPR_FILE_ADD :
        ::lstrcpy( szOpt, cszDSPath );
        ::PathAppend( szOpt, (LPCWSTR)pOpt );
        pEnt = new CRMEFileCreate( szSrc, szOpt );
        break;
    case OPR_FILE_DELETE :
        pEnt = new CRMEFileDelete( szSrc );
        break;
    case OPR_FILE_MODIFY :
        ::lstrcpy( szOpt, cszDSPath );
        ::PathAppend( szOpt, (LPCWSTR)pOpt );
        pEnt = new CRMEFileModify( szSrc, szOpt );
        break;
    case OPR_FILE_RENAME :
        ::lstrcpy( szOpt, cszDrv );
        ::PathAppend( szOpt, (LPCWSTR)pOpt );
        pEnt = new CRMEFileRename( szSrc, szOpt );
        break;
    case OPR_SETACL :
        pEnt = new CRMESetAcl( szSrc, (LPBYTE)pOpt, pRME->m_cbAcl, pRME->m_fAclInline, cszDSPath );
        break;
    case OPR_SETATTRIB :
        pEnt = new CRMESetAttrib( szSrc, pRME->m_dwAttribute );
        break;
    default :
        ErrorTrace(0, "Invalid operation type - %d", pRME->m_dwOperation);
        goto Exit;
    }

    if ( pEnt == NULL )
    {
        FatalTrace(0, "Insufficient memory...");
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( pEnt );
}
*/


//
// util function to append strings larger than MAX_PATH
//
void
MyPathAppend(
    LPWSTR pszSrc, 
    LPWSTR pszString)
{
    if (pszSrc && pszString)
    {
        pszSrc = pszSrc + lstrlen(pszSrc) - 1;
        if (*pszSrc != L'\\')	// append '\' if not already present in first string
        {
            pszSrc++;
            *pszSrc = L'\\';
        }
        pszSrc++;
        if (*pszString == L'\\')  // skip '\' if already present in second string
        {
            pszString++;
        }
        memcpy(pszSrc, pszString, (lstrlen(pszString) + 1) * sizeof(WCHAR));
    }
    return;
}



/////////////////////////////////////////////////////////////////////////////
//
// CreateRestoreMapEntryForUndo
//
/////////////////////////////////////////////////////////////////////////////
BOOL
CreateRestoreMapEntryFromChgLog( CChangeLogEntry* pCLE,
                                 LPCWSTR cszDrv,
                                 LPCWSTR cszDSPath,
                                 CRMEArray &aryEnt )
{
    TraceFunctEnter("CreateRestoreMapEntry");
    BOOL              fRet = FALSE;
    INT64             llSeq;
    WCHAR             szSrc[SR_MAX_FILENAME_LENGTH + MAX_PATH];
    WCHAR             szOpt[SR_MAX_FILENAME_LENGTH + MAX_PATH];
    DWORD             dwOpr;
    CRestoreMapEntry  *pEnt = NULL;
    BOOL              fOptimized = FALSE;

    llSeq = pCLE->GetSequenceNum();

    if (FALSE == pCLE->CheckPathLengths())
    {
        trace(0, "Filepath lengths too long");
        goto Exit;
    }
        
    ::lstrcpy( szSrc, cszDrv );
    MyPathAppend( szSrc, pCLE->GetPath1() );

    dwOpr = pCLE->GetType() & SrEventLogMask;

    // Create and add regular operation
    switch ( dwOpr )
    {
    case SrEventStreamChange :
    case SrEventStreamOverwrite :
        ::lstrcpy( szOpt, cszDSPath );
        MyPathAppend( szOpt, pCLE->GetRPDir() );
        MyPathAppend( szOpt, pCLE->GetTemp() );
        pEnt = new CRMEFileModify( llSeq, szSrc, szOpt );
        break;
    case SrEventAclChange :
        pEnt = new CRMESetAcl( llSeq, szSrc, pCLE->GetAcl(), pCLE->GetAclSize(), pCLE->GetAclInline(), cszDSPath );
        break;
    case SrEventAttribChange :
        pEnt = new CRMESetAttrib( llSeq, szSrc, pCLE->GetAttributes() );
        break;
    case SrEventFileDelete :
        if ( pCLE->GetTemp() != NULL && ::lstrlen( pCLE->GetTemp() ) > 0 )
        {
            ::lstrcpy( szOpt, cszDSPath );
            MyPathAppend( szOpt, pCLE->GetRPDir() );
            MyPathAppend( szOpt, pCLE->GetTemp() );
        }
        else
        {
            szOpt[0] = L'\0';
            fOptimized = TRUE;
        }
        pEnt = new CRMEFileCreate( llSeq, szSrc, szOpt, pCLE->GetShortName() );
        break;
    case SrEventFileCreate :
        pEnt = new CRMEFileDelete( llSeq, szSrc );
        break;
    case SrEventFileRename :
        ::lstrcpy( szOpt, cszDrv );
        MyPathAppend( szOpt, pCLE->GetPath2() );
        pEnt = new CRMEFileRename( llSeq, szSrc, szOpt, pCLE->GetShortName() );
        break;
    case SrEventDirectoryCreate :
        pEnt = new CRMEDirDelete( llSeq, szSrc);
        break;
    case SrEventDirectoryRename :
        ::lstrcpy( szOpt, cszDrv );
        MyPathAppend( szOpt, pCLE->GetPath2() );
        pEnt = new CRMEDirRename( llSeq, szSrc, szOpt, pCLE->GetShortName());
        break;
    case SrEventDirectoryDelete :
        pEnt = new CRMEDirCreate( llSeq, szSrc, pCLE->GetShortName() );
        break;

    case SrEventMountCreate :
        pEnt = new CRMEMountDelete( llSeq, szSrc );
        break;
    case SrEventMountDelete :
        ::lstrcpy( szOpt, pCLE->GetPath2() );
        pEnt = new CRMEMountCreate( llSeq, szSrc,szOpt);
        break;
        
    default :
        ErrorTrace(0, "Invalid operation type - %d", pCLE->GetType());
        goto Exit;
    }
    if ( pEnt == NULL )
    {
        FatalTrace(0, "Insufficient memory...");
        goto Exit;
    }
    if ( !aryEnt.AddItem( pEnt ) )
    {
        pEnt->Release();
        goto Exit;
    }

    if (fOptimized == FALSE)
    {
        // Add Acl if exists
        if ( ( dwOpr != SrEventAclChange ) && ( pCLE->GetAcl() != NULL ) )
        {
            pEnt = new CRMESetAcl( llSeq, szSrc, pCLE->GetAcl(), pCLE->GetAclSize(), pCLE->GetAclInline(), cszDSPath );
            if ( pEnt == NULL )
            {
                FatalTrace(0, "Insufficient memory...");
                goto Exit;
            }
            if ( !aryEnt.AddItem( pEnt ) )
            {
                pEnt->Release();
                goto Exit;
            }
        }
        
        // Add attribute if exists
        if ( ( dwOpr != SrEventAttribChange ) && ( pCLE->GetAttributes() != 0xFFFFFFFF ) )
        {
            pEnt = new CRMESetAttrib( llSeq, szSrc, pCLE->GetAttributes() );
            if ( pEnt == NULL )
            {
                FatalTrace(0, "Insufficient memory...");
                goto Exit;
            }
            if ( !aryEnt.AddItem( pEnt ) )
            {
                pEnt->Release();
                goto Exit;
            }
        }
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/*
  Note about handling locked files:

  Here is mail from SK about this:

Sorry about long mail. It's quite complicated, so I needed to write
things down. If you want to discuss further, please ping me today
4pm-5pm or tomorrow.
 
The initial code of ProcessDependency had a couple of problems, and
one fix made on 2001/05/18 by Brijesh for bug #398320 tried to solve
one of them but caused this delete & add bug as a side effect.
 
First of all, three type of ops can cause dependency if locked -
Delete, Rename, and Modify.
 
And there are two types of dependency:

1. Location. Failed delete or rename ops will leave a file/dir at a
location and can prevent later ops cannot create an object in
there. Create ops and destination of Rename ops (m_strSrc).
2. Object. Failed rename or modify ops can cause later ops cannot find
a proper file to work on. Delete ops, source of Rename ops (m_strDst),
Modify ops, SetAttrib and SetAcl.
 
Now the full list of scenarios the ProcessDependency must take care of are:
1. Delete ops. Compare m_strSrc with Location of the others.
2. Rename ops. Compare m_strDst with Location of the others.
3. Rename ops. Compare m_strSrc with Object of the others.
4. Modify ops. Compare m_strSrc with Object of the others.
 
ProcessDependency was broken because it had only two cases and was
comparing wrong pathes, so only #1 case was being handled
properly. Brijesh's fix corrected #2 and #3 case, but broke #1 case --
the new bug.
 
In order to fix this properly,
 
1. Remove ProcessDependency.
 
2. Replace each call to ProcessDependency by below codes:
DELETE (DirDelete and FileDelete)
    if ( pROMgr->FindDependentMapEntry( m_strSrc, FALSE, &pEnt ) )
        pEnt->SetResults( RSTRRES_LOCKED, 0 );
RENAME (DirRename and FileRename)
    if ( pROMgr->FindDependentMapEntry( m_strDst, FALSE, &pEnt ) )
        pEnt->SetResults( RSTRRES_LOCKED, 0 );
    if ( pROMgr->FindDependentMapEntry( m_strSrc, TRUE, &pEnt ) )
        pEnt->SetResults( RSTRRES_LOCKED, 0 );
MODIFY (FileModify)
    if ( pROMgr->FindDependentMapEntry( m_strSrc, TRUE, &pEnt ) )
        pEnt->SetResults( RSTRRES_LOCKED, 0 );
 
3. (optional) To be a little more clear, "fCheckSrc" flag of
FindDependentMapEntry could be renamed to "fCheckObj". I tried to
explain this in the comment of FindDependentMapEntry function, but as
I read it now, it seems not clear and easy enough...
 
 
And correct, dependency is not being checked cascaded.
 
Thanks,
 skkhang


Note from AshishS - I made a few of the modifications mentioned
above. The code already is doing the correct thing for renames so I
did not change it for SP1.

In particular,

1. The code for handling locked cases for Modify is incorrect if the
Modify operation was flagged as a dependent operation of another
operation that was found locked.

2. There is no code that handles a creation operation being
locked. However, a create operation should not really be locked since
the file should not exist.

3. SetAcl and SetAttrib cases should not be checked while checking for
dependency since since they cannot be done after the reboot
anyways. Restore should not fail because of these operations failing.

The following cases were checked along with the results:

Delete  a.dll 
Create  a.dll


Create a.dll
Del      a.dll   - this cannot be locked since a.dll should not exist



Create a.dll
Create restore point
Modify a.dll -      this succeeds but in the dependency check for modify,
the next setacl change is picked.  However, the delete also handles
the locked case independently
                              



Modify a.dll
Ren a.dll c.dll
Lock c.dll - This has two problems when the HandleLocked for Modify is
called, the temp file does not exist. This causes Handlelock to not
work as expected. However, before this, the SetACL fails since the
file a.dll does not exist.


 */
// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\resource.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    resource.h

Abstract:
    Contains constant definitions for resources.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#ifndef _RESOURCE_H__INCLUDED_
#define _RESOURCE_H__INCLUDED_
#pragma once


/////////////////////////////////////////////////////////////////////////////
//
// CONSTANTS
//
/////////////////////////////////////////////////////////////////////////////

#define IDC_STATIC  -1

#ifndef TBS_DOWNISLEFT
#define TBS_DOWNISLEFT  0x0400
#endif


/////////////////////////////////////////////////////////////////////////////
//
// ICON IDs
//
/////////////////////////////////////////////////////////////////////////////

#define IDI_SYSTEMRESTORE   101
#define IDI_DRIVE_FIXED     102


/////////////////////////////////////////////////////////////////////////////
//
// BITMAP IDs
//
/////////////////////////////////////////////////////////////////////////////

#define IDB_PROG_BRAND4     111
#define IDB_PROG_BRAND8     112


/////////////////////////////////////////////////////////////////////////////
//
// STRING IDs
//
/////////////////////////////////////////////////////////////////////////////

#define IDS_SYSTEMRESTORE           256

#define IDS_DRVSTAT_ACTIVE          272
#define IDS_DRVSTAT_FROZEN          273
#define IDS_DRVSTAT_EXCLUDED        274
#define IDS_DRVSTAT_OFFLINE         282
#define IDS_DRIVEPROP_TITLE         275
#define IDS_DRIVE_SUMMARY           276
#define IDS_SYSDRV_CANNOT_OFF       277
#define IDS_DRVLIST_COL_NAME        278
#define IDS_DRVLIST_COL_STATUS      279
#define IDS_CONFIRM_TURN_SR_OFF     280
#define IDS_CONFIRM_TURN_DRV_OFF    281
#define IDS_GROUP_POLICY_ON_OFF     283
#define IDS_GROUP_POLICY_CONFIG_ON_OFF 284

#define IDS_RESTORE_POINT_TEXT      288
#define IDS_ERROR_LOWPRIVILEGE      289
#define IDS_DRIVE_SUMMARY_NO_LABEL  290
#define IDS_SYSDRV_CANNOT_OFF_NO_LABEL   291
#define IDS_PROGRESS_PREPARE        292
#define IDS_PROGRESS_RESTORE        293
#define IDS_PROGRESS_SNAPSHOT       294
#define IDS_ERR_SR_SAFEMODE         295
#define IDS_ERR_SR_ON_OFF           296
#define IDS_SYSTEM_CHECKPOINT_TEXT  297


/////////////////////////////////////////////////////////////////////////////
//
// DIALOG IDs
//
/////////////////////////////////////////////////////////////////////////////

// Common Control IDs for Configuration Dialogs
//
// NOTE:
//  The ID range from 1010 to 1019 are reserved for controls those
//  should be disabled if SR is turned off.
//
#define IDC_TURN_OFF        1001
#define IDC_DRIVE_SUMMARY   1002
#define IDC_USAGE_GROUPBOX  1011    // Usage Settings Group-Box (static)
#define IDC_USAGE_HOWTO     1012    // Usage Settings Explanation Text (static)
#define IDC_USAGE_LABEL     1013    // Slider Label Text (static)
#define IDC_USAGE_SLIDER    1014    // Slider to Adjust Usage
#define IDC_USAGE_MIN       1015    // Label indicating Slider "Min"
#define IDC_USAGE_MAX       1016    // Label indicating Slider "Max"
#define IDC_USAGE_VALUE     1017    // Current Usage Value Text

#define IDC_DCU_HOWTO       1021    // Disk Cleanup Utility Explanation Text For Single Drive
#define IDC_DCU_INVOKE      1022    // Button to Run Disk Cleanup Utility
#define IDC_SYSTEM_DCU_HOWTO       1023    // Disk Cleanup Utility Explanation Text For System Drive (with multiple drives)
#define IDC_NORMAL_DCU_HOWTO       1024    // Disk Cleanup Utility Explanation Text For Normal Drive (with multiple drives)


// System Restore Tab for System CPL, Single Drive
//
#define IDD_SYSPROP_SINGLE  11
#define IDC_SD_STATUS           1101    // Status Text for Single Drive
#define IDC_SD_ICON             1102    // Drive Icon for Single Drive

// System Restore Tab for System CPL, Multiple Drives
//
#define IDD_SYSPROP_MULTI   12
#define IDC_DRIVE_GROUPBOX      1201
#define IDC_DRIVE_HOWTO         1202
#define IDC_DRIVE_LABEL         1203
#define IDC_DRIVE_LIST          1204    // List Control for Drives
#define IDC_DRIVE_SETTINGS      1205    // Button to Invoke Settings Dialog
#define IDC_RESTOREHELP_LINK    1206    // link to launch restore UI

// System Drive Settings Dialog for Multiple Drives
//
#define IDD_SYSPROP_SYSTEM      13
#define IDC_SYSDRV_CANNOT_OFF       1301

// Normal Drive Settings Dialog for Multiple Drives
//
#define IDD_SYSPROP_NORMAL      14

// Frozen Drive Settings Dialogs
//
#define IDD_SYSPROP_SYSTEM_FROZEN   15
#define IDD_SYSPROP_NORMAL_FROZEN   16

// Progress Dialog Box
//
#define IDD_PROGRESS        21
#define IDC_PROGDLG_BRAND       2101
#define IDC_PROGDLG_BITMAP      2102
#define IDC_PROGDLG_TITLE       2103
#define IDC_PROGDLG_BAR         2104
#define IDC_PROGDLG_STATUS      2105


#endif //_RESOURCE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\romgr.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    romgr.cpp

Abstract:
    This file contains the implementation of CRestoreOperationManager class and
    ::CreateRestoreOperationManager.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"
#include "srdefs.h"
#include "utils.h"
#include "..\snapshot\snappatch.h"

//
// global variable for mfex marker
//
DWORD g_dwExistingMFEXMarker;

CSRClientLoader  g_CSRClientLoader;

#define STR_REGPATH_SESSIONMANAGER  L"System\\CurrentControlSet\\Control\\Session Manager"
#define STR_REGVAL_MOVEFILEEX       L"PendingFileRenameOperations"


void SetRestoreStatusFailed()
{
    TraceFunctEnter("SetRestoreStatusFailed");

    if (!::SRSetRegDword(HKEY_LOCAL_MACHINE,s_cszSRRegKey,s_cszRestoreStatus,0))
    {
         // ignore the error since this is not a fatal error
        ErrorTrace(0,"SRSetRegDword failed.ec=%d", GetLastError());
    }
    TraceFunctLeave();
}

DWORD RestoreRIDs (WCHAR *pszSamPath);

/////////////////////////////////////////////////////////////////////////////
// CRestoreOperationManager construction / destruction

CRestoreOperationManager::CRestoreOperationManager()
{
    m_fFullRestore = TRUE;
    m_szMapFile[0] = L'\0';
    m_pLogFile     = NULL;
    m_pProgress    = NULL;
    m_dwRPNum      = 0;
    m_paryEnt      = NULL;
    m_fRebuildCatalogDb = FALSE;
}

/////////////////////////////////////////////////////////////////////////////

CRestoreOperationManager::~CRestoreOperationManager()
{
    SAFE_RELEASE(m_pLogFile);
    SAFE_RELEASE(m_pProgress);
}

/////////////////////////////////////////////////////////////////////////////
// CRestoreOperationManager - methods

#define TIMEOUT_RESTORETHREAD  5000

BOOL
CRestoreOperationManager::Run( BOOL fFull )
{
    TraceFunctEnter("CRestoreOperationManager::Run");
    BOOL    fRet = FALSE;
    HANDLE  hThread;
    DWORD   dwRet;

    // Create progress window
    if ( !m_pProgress->Create() )
        goto Exit;

    m_fFullRestore = fFull;

    // Create secondary thread for main restore operation
    hThread = ::CreateThread( NULL, 0, ExtThreadProc, this, 0, NULL );
    if ( hThread == NULL )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateThread failed - %ls", cszErr);

        //NOTE: should I try to run restore in the context of current thread?
        //

        goto Exit;
    }

    // Message loop, wait until restore thread closes progress window
    if ( !m_pProgress->Run() )
        goto Exit;

    // Double check if thread has been terminated
    dwRet = ::WaitForSingleObject( hThread, TIMEOUT_RESTORETHREAD );
    if ( dwRet == WAIT_FAILED )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::WaitForSingleObject failed - %ls", cszErr);
        goto Exit;
    }
    else if ( dwRet == WAIT_TIMEOUT )
    {
        ErrorTrace(0, "Timeout while waiting for the restore thread finishes...");
        goto Exit;
    }
    ::CloseHandle( hThread );

    fRet = TRUE;
Exit:
    // Close method is safe to call even if window is not open, so calling it
    // unconditionally.
    m_pProgress->Close();

    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

//
// If fChecKSrc is TRUE, it means the dependency is for the result of the
//  original operation (e.g. delete, rename FROM, etc.).  If it's FALSE, it
//  means the dependency is for the location which is being free'ed by the
//  original operation (e.g. add, rename TO, etc.).
//
BOOL
CRestoreOperationManager::FindDependentMapEntry( LPCWSTR cszPath, BOOL fCheckObj, CRestoreMapEntry **ppEnt )
{
    TraceFunctEnter("CRestoreOperationManager::FindDependentMapEntry");
    BOOL              fRet = FALSE;
    int               nEntAll;
    int               nEnt;
    CRestoreMapEntry  *pEnt;
    DWORD             dwOpr;
    LPCWSTR           cszDep;

    if ( ppEnt != NULL )
        *ppEnt = NULL;

    nEntAll = m_paryEnt[m_nDrv].GetSize();
    for ( nEnt = m_nEnt+1;  nEnt < nEntAll;  nEnt++ )
    {
        pEnt   = m_paryEnt[m_nDrv][nEnt];
        dwOpr  = pEnt->GetOpCode();
        cszDep = NULL;

        if ( fCheckObj )
        {
            switch ( dwOpr )
            {
            case OPR_DIR_RENAME :
            case OPR_FILE_RENAME :
                cszDep = pEnt->GetPath2();
                break;

            case OPR_DIR_DELETE :
            case OPR_FILE_DELETE :
            case OPR_FILE_MODIFY :
            //
            // ISSUE: SetAttrib and SetAcl cannot be processed by Session Manager.
            //  In order to properly handle them, there should be post processing
            //  just before displaying the result page. However, it might be
            //  possible that the target file/dir is in use at that moment.
            //
            case OPR_SETATTRIB :
            case OPR_SETACL :
                cszDep = pEnt->GetPath1();
                break;
            }
        }
        else
        {
            switch ( dwOpr )
            {
            case OPR_DIR_CREATE :
            case OPR_DIR_RENAME :
            case OPR_FILE_ADD :
            case OPR_FILE_RENAME :
                cszDep = pEnt->GetPath1();
                break;
            }
        }

        if ( cszDep != NULL )
        if ( ::StrCmpI( cszPath, cszDep ) == 0 )
            break;
    }

    if ( nEnt >= nEntAll )
        goto Exit;

    // Dependent Node Found
    if ( ppEnt != NULL )
        *ppEnt = pEnt;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreOperationManager::GetNextMapEntry( CRestoreMapEntry **ppEnt )
{
    TraceFunctEnter("CRestoreOperationManager::GetNextMapEntry");
    BOOL  fRet = FALSE;

    if ( ppEnt != NULL )
        *ppEnt = NULL;

    if ( m_nEnt >= m_paryEnt[m_nDrv].GetUpperBound() )
        goto Exit;

    if ( ppEnt != NULL )
        *ppEnt = m_paryEnt[m_nDrv][m_nEnt+1];

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}
    
/////////////////////////////////////////////////////////////////////////////

BOOL
CRestoreOperationManager::Release()
{
    TraceFunctEnter("CRestoreOperationManager::Release");
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreOperationManager operations

static LPCWSTR  s_cszMapFile = L"%SystemRoot%\\system32\\restore\\rstrmap.dat";

BOOL
CRestoreOperationManager::Init()
{
    TraceFunctEnter("CRestoreOperationManager::Init");
    BOOL           fRet = FALSE;
    SRstrLogHdrV3  sRPInfo;

    // Construct internal file pathes
    if ( ::ExpandEnvironmentStrings( s_cszMapFile, m_szMapFile, MAX_PATH ) == 0 )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::ExpandEnvironmentStrings failed - %s", cszErr);
        goto Exit;
    }

    // Open the log file and read restore point info
    if ( !::OpenRestoreLogFile( &m_pLogFile ) )
        goto Exit;
    if ( !m_pLogFile->ReadHeader( &sRPInfo, m_aryDrv ) )
        goto Exit;
    m_dwRPNum = sRPInfo.dwRPNum;
    m_dwRPNew = sRPInfo.dwRPNew;

    // Create progress window object
    if ( !::CreateRestoreProgressWindow( &m_pProgress ) )
        goto Exit;

    fRet = TRUE;
Exit:
    if ( !fRet )
    {
        SAFE_RELEASE(m_pLogFile);
        SAFE_RELEASE(m_pProgress);
    }

    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreOperationManager operations - worker thread

DWORD WINAPI
CRestoreOperationManager::ExtThreadProc( LPVOID lpParam )
{
    TraceFunctEnter("CRestoreOperationManager::ExtThreadProc");
    DWORD                     dwRet;
    CRestoreOperationManager  *pROMgr;
    
    pROMgr = (CRestoreOperationManager*)lpParam;
    dwRet = pROMgr->ROThreadProc();

    TraceFunctLeave();
    return( dwRet );
}

/////////////////////////////////////////////////////////////////////////////

DWORD
CRestoreOperationManager::ROThreadProc()
{
    TraceFunctEnter("CRestoreOperationManager::ROThreadProc");
    DWORD  dwRes;
    CSRLockFile  cLock;     // Lock/load designated files/dirs during a restore.
                            // In order to simulate it as realistic as possible,
                            //  locking will be in effect during the entire
                            //  restoration.
    CSnapshot  cSS;
    WCHAR      szSysDrv[MAX_SYS_DRIVE];  // System Drive
    WCHAR      szRPDir[MAX_RP_PATH];   // Restore Point Directory ("RPn")
    WCHAR      szSSPath[MAX_PATH];  // Full path of Restore Point Directory
    
    // 1. Initialization.
    dwRes = T2Initialize();
    if ( dwRes != ERROR_SUCCESS )
        goto Exit;

    // 2. Create restore map and read it.
    m_pProgress->SetStage( RPS_PREPARE, 0 );
    dwRes = T2CreateMap();
    if ( dwRes != ERROR_SUCCESS )
        goto Exit;

    // 3. Preprocessing. (?)

    //
    // Do snapshot init here to prevent low disk conditions after 
    // restore is done.
    //

    ::GetSystemDrive( szSysDrv );
    ::wsprintf( szRPDir, L"%s%d", s_cszRPDir, m_dwRPNum );
    ::MakeRestorePath( szSSPath, szSysDrv, szRPDir );
    

    // 
    // unpatch the snapshot if need be
    // if the snapshot has not been patched, this should be a no-op
    //
   
    lstrcat(szSSPath, SNAPSHOT_DIR_NAME);
    
    dwRes = PatchReconstructOriginal(szSSPath,      // original/patched snapshot path
                                     szSSPath);     // reconstruct in same directory
    if ( dwRes != ERROR_SUCCESS )
    {
        ErrorTrace(0, "! PatchReconstructOriginal : %ld", dwRes); 
        goto Exit;
    }

    ::MakeRestorePath( szSSPath, szSysDrv, szRPDir );
    
    dwRes = cSS.InitRestoreSnapshot( szSSPath );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR cszErr = NULL;
        cszErr = ::GetSysErrStr( dwRes ); 
        ErrorTrace(0, "cSS.InitResourceSnapshot failed - %ls", cszErr); 
        goto Exit;
    }

    // 4. Restore.
    m_pProgress->SetStage( RPS_RESTORE, m_dwTotalEntry );
    dwRes = T2DoRestore( FALSE );
    if ( dwRes != ERROR_SUCCESS )
    {
        goto Exit;
    }

    // 5. Postprocessing. (?)

    // 6. Snapshot handling.

    m_pProgress->SetStage( RPS_SNAPSHOT, 0 );
    
    if ( m_fFullRestore )
    {
        dwRes = T2HandleSnapshot( cSS, szSSPath );
        if ( dwRes != ERROR_SUCCESS )
        {
            m_pLogFile->WriteMarker(RSTRLOGID_SNAPSHOTFAIL, dwRes);
            T2UndoForFail();
            goto Exit;
        }
    }
    
Exit:

     // Regardless of whether the restore succeeded or failed, give
     // the user the impression that system restore is done with all
     // the things it had to do. So call SetStage to set the progress
     // bar to 90%. After that we will call Increment to make it go to
     // 100%
    m_pProgress->SetStage( RPS_SNAPSHOT, 0 );    
    
    m_pProgress->Increment();
    Sleep(1000);

    
    T2CleanUp();

    m_pLogFile->WriteMarker( RSTRLOGID_ENDOFMAP, 0 );  // ignore error...
    m_pLogFile->Close();
    m_pProgress->Close();

    if (dwRes != ERROR_SUCCESS)
        SetRestoreStatusFailed();

    TraceFunctLeave();
    return( dwRes );
}


/////////////////////////////////////////////////////////////////////////////

DWORD
CRestoreOperationManager::T2Initialize()
{
    TraceFunctEnter("CRestoreOperationManager::T2Initialize");
    
     // Reset the registry flag to clear the disk full error
    _VERIFY(TRUE==SetRestoreError(ERROR_SUCCESS)); // clear this error
    TraceFunctLeave();
    return( ERROR_SUCCESS );
}

/////////////////////////////////////////////////////////////////////////////

/*
// NOTE - 8/1/00 - skkhang
//
// Commented out to incorporate excluding restore map logic.
// But DO NOT delete this until we are comfortable 100% about removing
// restore map.
//
DWORD
CRestoreOperationManager::T2CreateMap()
{
    TraceFunctEnter("CRestoreOperationManager::T2CreateMap");
    DWORD             dwRet = ERROR_INTERNAL_ERROR;
    LPCWSTR           cszErr;
    DWORD             dwLE;
    HANDLE            hfMap = INVALID_HANDLE_VALUE;
    DWORD             dwLastPos = 0;
    LPCWSTR           cszDrv;
    WCHAR             szDSPath[MAX_PATH];
    RestoreMapEntry   *pRME = NULL;
    CRestoreMapEntry  *pEnt = NULL;
    int               i;
    SRstrLogHdrV3Ex   sHdrEx;

    hfMap = ::CreateFile( m_szMapFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if ( hfMap == INVALID_HANDLE_VALUE )
    {
        dwRet = ::GetLastError();
        //LOGLOG - CreateFile failed...
        goto Exit;
    }

    for ( i = 0;  i < m_aryDrv.GetSize();  i++ )
    {
        if ( m_aryDrv[i]->IsOffline() || m_aryDrv[i]->IsFrozen() || m_aryDrv[i]->IsExcluded() )
            continue;

        // set cszDrv to proper drive letters...
        cszDrv = m_aryDrv[i]->GetMount();
        ::MakeRestorePath( szDSPath, cszDrv, NULL );
        DebugTrace(0, "Drive #%d: Drv='%ls', DS='%ls'", i, cszDrv, szDSPath);

        dwLastPos = ::SetFilePointer( hfMap, 0, NULL, FILE_CURRENT );
        //??? should I check error from this???

        dwLE = ::CreateRestoreMap( (LPWSTR)cszDrv, m_dwRPNum, hfMap );
        if ( dwLE != ERROR_SUCCESS )
        {
            if ( dwLE != ERROR_NO_MORE_ITEMS )
            {
                cszErr = ::GetSysErrStr( dwLE );
                ErrorTrace(0, "::CreateRestoreMap failed - %ls", cszErr);
                dwRet = dwLE;
                goto Exit;
            }

            DebugTrace(0, "Nothing to restore in this drive...");
            // Some drive might not have any changes in there.
            // So gracefully ignore and move to the next drive.
            continue;
        }

        ::SetFilePointer( hfMap, dwLastPos, NULL, FILE_BEGIN );
        dwLE = ::GetLastError();
        if ( dwLE != NO_ERROR )
        {
            cszErr = ::GetSysErrStr( dwLE );
            ErrorTrace(0, "::SetFilePointer failed - %ls", cszErr);
            dwRet = dwLE;
            goto Exit;
        }

        while ( ::ReadRestoreMapEntry( hfMap, &pRME ) == ERROR_SUCCESS )
        {
            pEnt = ::CreateRestoreMapEntry( pRME, cszDrv, szDSPath );
            if ( pEnt == NULL )
                goto Exit;

            if ( !m_aryEnt.AddItem( pEnt ) )
                goto Exit;
            pEnt = NULL;
        }
    }

    ::FreeRestoreMapEntry(pRME);
    pRME = NULL;

    //sHdrEx.dwCount = m_aryEnt.GetSize();
    //m_pLogFile->AppendHeader( &sHdrEx );

    dwRet = ERROR_SUCCESS;
Exit:
    // clean up the list if necessary...
    if ( dwRet != ERROR_SUCCESS )
        if ( pRME != NULL )
            ::FreeRestoreMapEntry(pRME);

    if ( hfMap != INVALID_HANDLE_VALUE )
        ::CloseHandle( hfMap );
    TraceFunctLeave();
    return( dwRet );
}
*/

DWORD
CRestoreOperationManager::T2CreateMap()
{
    TraceFunctEnter("CRestoreOperationManager::T2CreateMap");
    DWORD    dwRet = ERROR_INTERNAL_ERROR;
    LPCWSTR  cszErr;
    int      nDrv;
    WCHAR    szDrv[MAX_PATH];
    WCHAR    szDSPath[MAX_PATH];
    int      i;

    m_dwTotalEntry = 0;
    nDrv = m_aryDrv.GetSize();

    if ( nDrv > 0 )
    {
        m_paryEnt = new CRMEArray[nDrv];
        if ( m_paryEnt == NULL )
        {
            FatalTrace(0, "Insufficient memory...");
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
    }

    for ( i = 0;  i < m_aryDrv.GetSize();  i++ )
    {
        if ( m_aryDrv[i]->IsOffline() || m_aryDrv[i]->IsFrozen() || m_aryDrv[i]->IsExcluded() )
            continue;

        // use the volume guid for each volume
        // we cannot use mountpoint paths because
        // restore might delete mount points before 
        // the operations on that volume are restored
        
        ::lstrcpy( szDrv, m_aryDrv[i]->GetID() );

        //cszDrv = m_aryDrv[i]->GetMount();
        ::MakeRestorePath( szDSPath, szDrv, NULL );
        DebugTrace(0, "Drive #%d: Drv='%ls', DS='%ls'", i, szDrv, szDSPath);

        // Following code assumes descructor of CChangeLogEntryEnum calls FindClose
        // automatically.
        CChangeLogEntryEnum  cEnum( szDrv, 0, m_dwRPNum, FALSE );
        CChangeLogEntry      cCLE;

        dwRet = cEnum.FindFirstChangeLogEntry( cCLE );
        if ( dwRet == ERROR_NO_MORE_ITEMS )
            continue;

        if ( dwRet != ERROR_SUCCESS )
        {
            cszErr = ::GetSysErrStr( dwRet );
            ErrorTrace(0, "FindFirstChangeLogEntry failed - %ls", cszErr);
            goto Exit;
        }

        while ( dwRet == ERROR_SUCCESS )
        {
            if ( !::CreateRestoreMapEntryFromChgLog( &cCLE, szDrv, szDSPath, m_paryEnt[i] ) )
                goto Exit;

            // Update progress bar.
            m_pProgress->Increment();

            dwRet = cEnum.FindNextChangeLogEntry( cCLE );
        }

        if ( dwRet != ERROR_NO_MORE_ITEMS )
        {
            cszErr = ::GetSysErrStr( dwRet );
            ErrorTrace(0, "FindNextChangeLogEntry failed - %ls", cszErr);
            goto Exit;
        }

        m_dwTotalEntry += m_paryEnt[i].GetSize();
    }

    dwRet = ERROR_SUCCESS;
Exit:
    // clean up the list if necessary...

    TraceFunctLeave();
    return( dwRet );
}

/////////////////////////////////////////////////////////////////////////////

DWORD
CRestoreOperationManager::T2DoRestore( BOOL fUndo )
{
    TraceFunctEnter("CRestoreOperationManager::T2DoRestore");
    DWORD  dwRet = ERROR_SUCCESS;
    DWORD  dwRes;
    DWORD  dwErr;
    ULARGE_INTEGER ulTotalFreeBytes;

    for ( m_nDrv = 0;  m_nDrv < m_aryDrv.GetSize();  m_nDrv++ )
    {
        for ( m_nEnt = 0;  m_nEnt < m_paryEnt[m_nDrv].GetSize();  m_nEnt++ )
        {
            CRestoreMapEntry  *pEnt = m_paryEnt[m_nDrv][m_nEnt];

            //
            // BUGBUG - this code is a workaround for filter logging
            // acl ops on FAT drives
            //
            // check if this volume supports acls
            // if not, no-op
            //

            if (pEnt->GetOpCode() == SrEventAclChange)
            {
                WCHAR szLabel[MAX_PATH];
                DWORD dwFlags = 0, dwRc;
            
                    if (::GetVolumeInformation(m_aryDrv[m_nDrv]->GetID(), 
                                               szLabel, MAX_PATH, NULL, NULL, &dwFlags, NULL, 0))
                {
                    if (! (dwFlags & FS_PERSISTENT_ACLS))
                    {
                        DebugTrace(0, "Ignoring ACL change on non-NTFS drive");	
                        continue;
                    }
                }
                else
                {
                    dwRc = GetLastError();
                    DebugTrace(0, "! GetVolumeInformation : %ld", dwRc);
                }
            }

            // Skip dependent entries of locked files
            if ( pEnt->GetResult() == RSTRRES_LOCKED )
                continue;

            // if any .CAT files are modified in the CATROOT directory,
            // we need to rebuild the catalog db later
            
            if (StrStrI(pEnt->GetPath1(), L"CatRoot") &&
                StrStrI(pEnt->GetPath1(), L".CAT"))
            {
                m_fRebuildCatalogDb = TRUE;
            }
            else if (pEnt->GetPath2() != NULL &&
                     StrStrI(pEnt->GetPath2(), L"CatRoot") &&
                     StrStrI(pEnt->GetPath2(), L".CAT"))
            {
                m_fRebuildCatalogDb = TRUE;
            }
                
                
            //
            // check if we have more than 60mb freespace
            // if we don't, pre-emptively undo the restore
            // 60mb was chosen so that there is a buffer between
            // the freeze threshold 50mb and the restore threshold -
            // this will avoid the case where we successfully restore
            // and freeze immediately after the reboot
            //
            
            if (FALSE == GetDiskFreeSpaceEx(m_aryDrv[m_nDrv]->GetID(),
                                            NULL, 
                                            NULL, 
                                            &ulTotalFreeBytes))
            {
                dwRet = GetLastError();
                ErrorTrace(0, "! GetDiskFreeSpaceEx : %ld - ignoring", dwRet);
            }            
            else
            {
                if (ulTotalFreeBytes.QuadPart <= THRESHOLD_RESTORE_DISKSPACE * MEGABYTE)
                {
                    DebugTrace(0, "***Less than 60MB free - initiating fifo***");
                    dwRet = T2Fifo( m_nDrv, m_dwRPNum );
                    if ( dwRet != ERROR_SUCCESS )
                    {
                        ErrorTrace(0, "! T2Fifo : %ld - ignoring", dwRet);
                    }

                    // 
                    // get free space again - if still below 60mb, bail
                    //
                    
                    if (FALSE == GetDiskFreeSpaceEx(m_aryDrv[m_nDrv]->GetID(),
                                                    NULL, 
                                                    NULL, 
                                                    &ulTotalFreeBytes))
                    {
                        dwRet = GetLastError();
                        ErrorTrace(0, "! GetDiskFreeSpaceEx : %ld - ignoring", dwRet);
                    }            
                    else
                    {
                        if (ulTotalFreeBytes.QuadPart <= THRESHOLD_RESTORE_DISKSPACE * MEGABYTE)
                        {
                            DebugTrace(0, "***Still less than 60MB free***");

                             // if disk is indeed full, set the registry flag to indicate this
                             // error
                             _VERIFY(TRUE==SetRestoreError(ERROR_DISK_FULL)); // set this error

                            if ( !fUndo )
                            {
                                ErrorTrace(0, "***Initiating Undo***");
                                T2UndoForFail();
                                dwRet = ERROR_INTERNAL_ERROR;
                                goto Exit;
                            }                
                        }   
                    }
                }
            }
            
            // RESTORE RESTORE RESTORE!!!
            pEnt->Restore( this );
            dwRes = pEnt->GetResult();
            dwErr = pEnt->GetError();
            DebugTrace(0, "Res=%d, Err=%d", dwRes, dwErr);

            if ( ( dwRes == RSTRRES_FAIL ) && ( dwErr == ERROR_DISK_FULL ) )
            {
                DebugTrace(0, "Disk full, initiating fifo to clean up memory...");
                dwRet = T2Fifo( m_nDrv, m_dwRPNum );
                if ( dwRet != ERROR_SUCCESS )
                    goto Exit;

                // Try again...
                pEnt->Restore( this );
                dwRes = pEnt->GetResult();
                dwErr = pEnt->GetError();
                DebugTrace(0, "Res=%d, Err=%d", dwRes, dwErr);
            }

             // if disk is indeed full, set the registry flag to indicate this
             // error
            if ( ( dwRes == RSTRRES_FAIL ) && ( dwErr == ERROR_DISK_FULL ) )
            {
                DebugTrace(0, "Restore failed agin because of Disk full. Setting Error");
                _VERIFY(TRUE==SetRestoreError(ERROR_DISK_FULL)); // set this error
            }

            // Locked or Locked_Alt should be handled after finishing normal entries...
            if ( ( dwRes == RSTRRES_LOCKED ) || ( dwRes == RSTRRES_LOCKED_ALT ) )
                continue;

            // if there was a file-directory collision, record the file rename entry first
            // so that it will displayed on the results screen
            if ( ( pEnt->GetOpCode() == OPR_DIR_CREATE ||
                   pEnt->GetOpCode() == OPR_DIR_RENAME ||
                   pEnt->GetOpCode() == OPR_FILE_ADD ||
                   pEnt->GetOpCode() == OPR_FILE_RENAME ) &&
                 ( pEnt->GetResult() == RSTRRES_COLLISION ) )
            {
                // add collision log entry
                m_pLogFile->WriteCollisionEntry( pEnt->GetPath1(), pEnt->GetAltPath(), m_aryDrv[m_nDrv]->GetMount() ); 
                pEnt->SetResults(RSTRRES_OK, ERROR_SUCCESS);
            }
            
            // Write log entry
            if ( !m_pLogFile->WriteEntry( m_nEnt, pEnt, m_aryDrv[m_nDrv]->GetMount() ) )
                goto Exit;

            if ( !fUndo && ( pEnt->GetResult() == RSTRRES_FAIL ) )
            {
                ErrorTrace(0, "Failure detected, initiating Undo...");
                T2UndoForFail();
                dwRet = ERROR_INTERNAL_ERROR;
                goto Exit;
            }

            // Temporary Hack for directory collision, scan forward.
            if ( ( pEnt->GetOpCode() == OPR_DIR_DELETE ) &&
                 ( pEnt->GetResult() == RSTRRES_IGNORE ) )
            {
                LPCWSTR  cszSrc = pEnt->GetPath1();

                for ( int j = m_nEnt+1;  j < m_paryEnt[m_nDrv].GetSize();  j++ )
                {
                    CRestoreMapEntry  *pEnt2 = m_paryEnt[m_nDrv][j];
                    DWORD             dwOpr  = pEnt2->GetOpCode();

                    if ( ( dwOpr == OPR_DIR_CREATE ) ||
                         ( dwOpr == OPR_DIR_RENAME ) ||
                         ( dwOpr == OPR_FILE_RENAME ) ||
                         ( dwOpr == OPR_FILE_ADD ) )
                        if ( ::StrCmpIW( cszSrc, pEnt2->GetPath1() ) == 0 )
                            break;
                }
                if ( j < m_paryEnt[m_nDrv].GetSize() )
                {
                    // found dependent node, current node should be renamed
                    WCHAR  szAlt[SR_MAX_FILENAME_LENGTH];

                    if ( !::SRGetAltFileName( cszSrc, szAlt ) )
                    {
                        // Fatal, possible only when total disk failure.
                        ErrorTrace(0, "Fatal failure, initiating Undo...");
                        T2UndoForFail();
                        dwRet = ERROR_INTERNAL_ERROR;
                        goto Exit;
                    }

                    if ( !::MoveFile( cszSrc, szAlt ) )
                    {
                        // Failed to rename the directory, so the dependent opr will fail.
                        // Abort the restore.
                        LPCWSTR  cszErr;

                        pEnt->SetResults( RSTRRES_FAIL, ::GetLastError() );
                        cszErr = ::GetSysErrStr( pEnt->GetError() );
                        ErrorTrace(0, "::MoveFile failed - %s", cszErr);
                        ErrorTrace(0, "   Src=%ls", cszSrc);
                        ErrorTrace(0, "   New=%ls", szAlt);
                        goto Exit;
                    }

                    // add collision log entry
                    m_pLogFile->WriteCollisionEntry( cszSrc, szAlt, m_aryDrv[m_nDrv]->GetMount() );
                }
            }

            // Update progress bar.
            m_pProgress->Increment();
        }
    }

    //
    // get the size of the existing movefileex entries
    // so that we can skip these when we transfer restore's movefileex entries
    // to the old registry
    //

    DWORD    dwType;        
    g_dwExistingMFEXMarker = 0;    
    if (ERROR_SUCCESS != SHGetValue( HKEY_LOCAL_MACHINE,
                                     STR_REGPATH_SESSIONMANAGER,
                                     STR_REGVAL_MOVEFILEEX,
                                     &dwType,
                                     NULL,
                                     &g_dwExistingMFEXMarker ))
    {
        g_dwExistingMFEXMarker = 0;
    }

    trace(0, "g_dwExistingMFEXMarker = %ld", g_dwExistingMFEXMarker);

    
    // Handles locked cases...
    for ( m_nDrv = 0;  m_nDrv < m_aryDrv.GetSize();  m_nDrv++ )
    {
        for ( m_nEnt = 0;  m_nEnt < m_paryEnt[m_nDrv].GetSize();  m_nEnt++ )
        {
            CRestoreMapEntry  *pEnt = m_paryEnt[m_nDrv][m_nEnt];
            dwRes = pEnt->GetResult();
            if ( dwRes == RSTRRES_LOCKED_ALT )
            {
                // Add MoveFileEx entry to delete alt object.
                pEnt->ProcessLockedAlt();
            }
            else if ( dwRes == RSTRRES_LOCKED )
            {
                // Add MoveFileEx entry.
                pEnt->ProcessLocked();
            }
            else
                continue;

            // Write log entry
            if ( !m_pLogFile->WriteEntry( m_nEnt, pEnt, m_aryDrv[m_nDrv]->GetMount() ) )
                goto Exit;

            // Update progress bar.
            m_pProgress->Increment();
        }
    }

Exit:
    TraceFunctLeave();
    return( dwRet );
}

/////////////////////////////////////////////////////////////////////////////

static LPCWSTR  s_cszRunOnceValueName      = L"*Restore";
static LPCWSTR  s_cszRestoreUIPath         = L"%SystemRoot%\\system32\\restore\\rstrui.exe";
static LPCWSTR  s_cszRunOnceOptNormal      = L" -c";
static LPCWSTR  s_cszRunOnceOptSilent      = L" -b";
static LPCWSTR  s_cszCatTimeStamp          = L"%SystemRoot%\\system32\\catroot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\\timestamp";
static LPCWSTR  s_cszRegLMSWRunOnce        = L"Microsoft\\Windows\\CurrentVersion\\RunOnce";
static LPCWSTR  s_cszRegLMSWWinLogon       = L"Microsoft\\Windows NT\\CurrentVersion\\Winlogon";
static LPCWSTR  s_cszRegSystemRestore      = L"Microsoft\\Windows NT\\CurrentVersion\\SystemRestore";
static LPCWSTR  s_cszRegValSfcScan         = L"SfcScan";
static LPCWSTR  s_cszRegValAllowProtectedRenames = L"AllowProtectedRenames";
static LPCWSTR  s_cszTZKeyInHive           = L"CurrentControlSet\\Control\\TimeZoneInformation";
static LPCWSTR  s_cszTZKeyInRegistry       = L"System\\CurrentControlSet\\Control\\TimeZoneInformation";

#define VALIDATE_DWRET(str) \
    if ( dwRet != ERROR_SUCCESS ) \
    { \
        cszErr = ::GetSysErrStr( dwRet ); \
        ErrorTrace(0, str " failed - %ls", cszErr); \
        goto Exit; \
    } \


DWORD
FindDriveMapping(HKEY hk, LPBYTE pSig, DWORD dwSig, LPWSTR pszDrive)
{
    DWORD dwIndex = 0;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwType, dwSize = MAX_PATH;
    BYTE  rgbSig[1024];
    DWORD cbSig = sizeof(rgbSig);
    LPCWSTR  cszErr;

    TENTER("FindDriveMapping");
    
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue( hk, 
                                 dwIndex++,
                                 pszDrive,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 rgbSig,
                                 &cbSig )))
    {
        if (0 == wcsncmp(pszDrive, L"\\DosDevice", 10))
        {  
            if (cbSig == dwSig &&
                (0 == memcmp(rgbSig, pSig, cbSig)))
                break;
        }
        dwSize = MAX_PATH;
        cbSig = sizeof(rgbSig);
    }

    TLEAVE();
    return dwRet;
}




DWORD
KeepMountedDevices(HKEY hkMount)
{
    HKEY    hkNew = NULL, hkOld = NULL;
    DWORD   dwIndex = 0;
    WCHAR   szValue[MAX_PATH], szDrive[MAX_PATH];
    BYTE    rgbSig[1024];
    DWORD   cbSig;
    DWORD   dwSize, dwType;
    DWORD   dwRet = ERROR_SUCCESS;
    LPCWSTR cszErr;

    TENTER("KeepMountedDevices");
    
    //
    // open the old and new MountedDevices
    //
    
    dwRet = ::RegOpenKey( hkMount, L"MountedDevices", &hkOld );
    VALIDATE_DWRET("::RegOpenKey");

    dwRet = ::RegOpenKey( HKEY_LOCAL_MACHINE, L"System\\MountedDevices", &hkNew );
    VALIDATE_DWRET("::RegOpenKey");

    //
    // enumerate the old devices 
    // delete volumes that don't exist in the new (i.e. current)
    //

    dwSize = MAX_PATH;
    cbSig = sizeof(rgbSig);
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue( hkOld, 
                                 dwIndex++,
                                 szValue,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 rgbSig,
                                 &cbSig )))
    {        
        if (0 == wcsncmp(szValue, L"\\??\\Volume", 10))
        {
            //
            // this is a Volume -> Signature mapping
            // check if the volume exists in the new 
            //
            
            trace(0, "Old Volume = %S", szValue);

            dwSize = sizeof(rgbSig);
            dwRet = RegQueryValueEx(hkNew, 
                                    szValue,
                                    NULL,
                                    &dwType,
                                    rgbSig,
                                    &dwSize);
            if (ERROR_SUCCESS != dwRet)
            {
                //
                // nope
                // so delete the volume and driveletter mapping from old
                //

                DWORD dwSave = FindDriveMapping(hkOld, rgbSig, cbSig, szDrive);
                dwRet = RegDeleteValue(hkOld, szValue);
                VALIDATE_DWRET("RegDeleteValue");                
                if (dwSave == ERROR_SUCCESS)
                {
                    dwIndex--;   // hack to make RegEnumValueEx work
                    dwRet = RegDeleteValue(hkOld, szDrive);
                    VALIDATE_DWRET("RegDeleteValue");                 
                }   

                trace(0, "Deleted old volume");
            }
        }
        else if (szValue[0] == L'#')
        {
            trace(0, "Old Mountpoint = %S", szValue);            
        }
        else if (0 == wcsncmp(szValue, L"\\DosDevice", 10))
        {            
            trace(0, "Old Drive = %S", szValue);
        }
        else
        {
            trace(0, "Old Unknown = %S", szValue);
        }            

        dwSize = MAX_PATH;
        cbSig = sizeof(rgbSig);
    }
                                 
    if (dwRet != ERROR_NO_MORE_ITEMS)
        VALIDATE_DWRET("::RegEnumValue");



    //
    // now enumerate the current (new) devices 
    //

    dwIndex = 0;
    dwSize = MAX_PATH;
    cbSig = sizeof(rgbSig);    
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue( hkNew, 
                                 dwIndex++,
                                 szValue,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 rgbSig,
                                 &cbSig )))
    {        
        if (0 == wcsncmp(szValue, L"\\??\\Volume", 10))
        {
            //
            // this is a Volume -> Signature mapping
            // copy the new volume to the old 
            //
            
            trace(0, "New Volume = %S", szValue);

            DWORD dwSave = FindDriveMapping(hkOld, rgbSig, cbSig, szDrive);    

            dwRet = RegSetValueEx(hkOld, 
                                  szValue,
                                  NULL,
                                  REG_BINARY,
                                  rgbSig,
                                  cbSig);
            VALIDATE_DWRET("::RegSetValueEx");       

            if (dwSave == ERROR_NO_MORE_ITEMS)
            {
                //
                // there is no driveletter for this volume in the old registry
                // so copy the new one to the old if it exists
                //

                if (ERROR_SUCCESS ==
                    FindDriveMapping(hkNew, rgbSig, cbSig, szDrive))
                {
                    dwRet = RegSetValueEx(hkOld, 
                                      szDrive,
                                      NULL,
                                      REG_BINARY,
                                      rgbSig,
                                      cbSig);
                    VALIDATE_DWRET("::RegSetValueEx");
                    trace(0, "Copied new driveletter %S to old", szDrive);                    
                }
            }
            else
            {
                //
                // preserve the old driveletter
                //

                trace(0, "Preserving old driveletter %S", szDrive);
            }
            
        }
        else if (szValue[0] == L'#')
        {
            //
            // this is a mountpoint specification
            // don't touch these
            //

            trace(0, "New Mountpoint = %S", szValue);
            
        }
        else if (0 == wcsncmp(szValue, L"\\DosDevice", 10))
        {
            //
            // this is a Driveletter -> Signature mapping
            // don't touch these
            //
            
            trace(0, "New Drive = %S", szValue);
        }
        else
        {
            trace(0, "New Unknown = %S", szValue);
        }    
        
        dwSize = MAX_PATH;        
        cbSig = sizeof(rgbSig);        
    }
                                 
    if (dwRet == ERROR_NO_MORE_ITEMS)
        dwRet = ERROR_SUCCESS;
        
    VALIDATE_DWRET("::RegEnumValue");    

Exit: 
    if (hkOld)
        RegCloseKey(hkOld);

    if (hkNew)
        RegCloseKey(hkNew);
        
    TLEAVE();
    return dwRet;
}


BOOL DeleteRegKey(HKEY hkOpenKey,
                  const WCHAR * pszKeyNameToDelete)
{
    TraceFunctEnter("DeleteRegKey");
    BOOL   fRet=FALSE;
    DWORD  dwRet;


     // this recursively deletes the key and all its subkeys
    dwRet = SHDeleteKey( hkOpenKey, // handle to open key
                         pszKeyNameToDelete);  // subkey name

    if (dwRet != ERROR_SUCCESS)
    {
         // key does not exist - this is not an error case.
        DebugTrace(0, "RegDeleteKey of %S failed ec=%d. Not an error.",
                   pszKeyNameToDelete, dwRet);
        goto cleanup;
    }

    DebugTrace(0, "RegDeleteKey of %S succeeded", pszKeyNameToDelete); 
    fRet = TRUE;
    
cleanup:
    TraceFunctLeave();
    return fRet;
}



DWORD PersistRegKeys( HKEY hkMountedHive,
                      const WCHAR * pszKeyNameInHive,
                      HKEY  hkOpenKeyInRegistry,
                      const WCHAR * pszKeyNameInRegistry,
                      const WCHAR * pszKeyBackupFile,
                      WCHAR * pszSnapshotPath)
{
    TraceFunctEnter("PersistRegKeys");
    HKEY   hKey=NULL;
    WCHAR  szDataFile[MAX_PATH];
    LPCWSTR cszErr;    
    DWORD dwRet=ERROR_INTERNAL_ERROR;
    BOOL  fKeySaved;
    DWORD  dwDisposition;
    
    
     // construct the name of the file that stores the backup we will
     // construct the name such that the file will get deleted after
     // the restore.
    wsprintf(szDataFile, L"%s%s\\%s.%s",pszSnapshotPath,SNAPSHOT_DIR_NAME,
             pszKeyBackupFile, s_cszRegHiveCopySuffix);
    
    DeleteFile(szDataFile);      // delete the file if it exists

    
     // first load the DRM key to a file
     // open the DRM key
    dwRet= RegOpenKeyEx(hkOpenKeyInRegistry, // handle to open key
                        pszKeyNameInRegistry, // name of subkey to open
                        0,   // reserved
                        KEY_READ, // security access mask
                        &hKey);   // handle to open key
    
    if (dwRet != ERROR_SUCCESS)
    {
         // key does not exist - this is not an error case.
        DebugTrace(0, "RegOpenKey of %S failed ec=%d", pszKeyNameInRegistry,
                   dwRet);
        fKeySaved = FALSE;
    }
    else
    {
         // key exist
        dwRet = RegSaveKey( hKey, // handle to key
                            szDataFile, // data file
                            NULL);  // SD
        if (dwRet != ERROR_SUCCESS)
        {
             // key does not exist - this is not an error case.
            DebugTrace(0, "RegSaveKey of %S failed ec=%d",
                       pszKeyNameInRegistry, dwRet);
            fKeySaved = FALSE;
        }
        else
        {
            DebugTrace(0, "Current DRM Key %S saved successfully",
                       pszKeyNameInRegistry);
            fKeySaved = TRUE;            
        }
    }


     // close the key 
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }
    
     // now replace the snapshotted DRM key with the new key
    
     // first delete the existing key
    DeleteRegKey(hkMountedHive, pszKeyNameInHive);

     // now check to see if the key existing in the old registry in
     // the first place
    if (fKeySaved == FALSE)
    {
        DebugTrace(0, "Current key %S did not exist. Leaving",
                   pszKeyNameInRegistry);
        goto Exit;
    }

     // Create the new DRM key
    dwRet = RegCreateKeyEx( hkMountedHive, // handle to open key
                            pszKeyNameInHive, // subkey name
                            0,        // reserved
                            NULL,     // class string
                            REG_OPTION_NON_VOLATILE, // special options
                            KEY_ALL_ACCESS, // desired security access
                            NULL, // inheritance
                            &hKey, // key handle 
                            &dwDisposition); // disposition value buffer
    VALIDATE_DWRET("::RegCreateKeyEx");
    _VERIFY(dwDisposition == REG_CREATED_NEW_KEY);
    dwRet= RegRestoreKey( hKey, // handle to key where restore begins
                          szDataFile, // registry file
                          REG_FORCE_RESTORE|REG_NO_LAZY_FLUSH); // options

    VALIDATE_DWRET("::RegRestoreKey");

    DebugTrace(0, "Successfully kept key %S", pszKeyNameInRegistry);    
    dwRet = ERROR_SUCCESS;
    
Exit:
    if (hKey)
        RegCloseKey(hKey);
    
    DeleteFile(szDataFile);      // delete the file if it exists    
    TraceFunctLeave();
    return dwRet;
}


//
// return the next string in multisz pszBuffer
// if no string, will return empty
//
LPWSTR
GetNextMszString(LPWSTR pszBuffer)
{
    return pszBuffer + lstrlen(pszBuffer) + 1;
}


// 
// read regvalue pszString in current registry,
// and replace it in the old registry
//
DWORD
ValueReplace(HKEY hkOldSystem, LPWSTR pszOldString, HKEY hkNewSystem, LPWSTR pszNewString)
{
    tenter("ValueReplace");
    
    WCHAR  szBuffer[MAX_PATH];
    BYTE   *pData = NULL;
    DWORD  dwType, dwSize, dwRet = ERROR_SUCCESS;
    LPWSTR pszValue = NULL;
    LPCWSTR cszErr;
    
    // split up the key and value in pszNewString    
    lstrcpy(szBuffer, pszNewString);
    pszValue = wcsrchr(szBuffer, L'\\');
    if (! pszValue)
    {   
        trace(0, "No value in %S", pszNewString);
        goto Exit;
    }
        
    *pszValue=L'\0';
    pszValue++;
    
    trace(0, "New Key=%S, Value=%S", szBuffer, pszValue);

    // get the value size    
    dwRet = SHGetValue(hkNewSystem, szBuffer, pszValue, &dwType, NULL, &dwSize);
    VALIDATE_DWRET("SHGetValue");
    
    pData = (BYTE *) SRMemAlloc(dwSize);
    if (! pData)
    {
        trace(0, "! SRMemAlloc");
        dwRet = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    // get the value
    dwRet = SHGetValue(hkNewSystem, szBuffer, pszValue, &dwType, pData, &dwSize);       
    VALIDATE_DWRET("SHGetValue");


    // split up the key and value in pszOldString    
    lstrcpy(szBuffer, pszOldString);
    pszValue = wcsrchr(szBuffer, L'\\');
    if (! pszValue)
    {   
        trace(0, "No value in %S", pszOldString);
        goto Exit;
    }
        
    *pszValue=L'\0';
    pszValue++;
    
    trace(0, "Old Key=%S, Value=%S", szBuffer, pszValue);

    // set the value in the old registry
    SHSetValue(hkOldSystem, szBuffer, pszValue, dwType, pData, dwSize);
    VALIDATE_DWRET("SHGetValue");

Exit:    
    if (pData)
    {
        SRMemFree(pData);
    }
    tleave();
    return dwRet;
}


//
// list of keys in KeysNotToRestore that we should ignore
//
LPWSTR g_rgKeysToRestore[] = {
    L"Installed Services",
    L"Mount Manager",
    L"Pending Rename Operations",
    L"Session Manager",
    L"Plug & Play"
    };
int g_nKeysToRestore = 5;


// 
// check if pszKey is to be preserved or restored
//
BOOL
IsKeyToBeRestored(LPWSTR pszKey)
{    
    for (int i=0; i < g_nKeysToRestore; i++)
    {
        if (lstrcmpi(g_rgKeysToRestore[i], pszKey) == 0)
            return TRUE;
    }

    return FALSE;
}


//
// copy the keys listed in System\CurrentControlSet\Control\BackupRestore\KeysNotToRestore
// from the current registry to the old registry
// -- with some exceptions
//

DWORD
PreserveKeysNotToRestore(HKEY hkOldSystem, LPWSTR pszSnapshotPath)
{
    HKEY    hkNewSystem = NULL;
    DWORD   dwIndex = 0;
    WCHAR   szName[MAX_PATH], szKey[MAX_PATH];
    BYTE    *pMszString = NULL;
    DWORD   dwSize, dwType, cbValue;
    DWORD   dwRet = ERROR_SUCCESS;
    LPCWSTR cszErr;
    HKEY    hkKNTR = NULL;
    
    TENTER("PreserveKeysNotToRestore");
    
    //
    // open the new system hive
    //   

    dwRet = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"System", 0, KEY_ALL_ACCESS, &hkNewSystem );
    VALIDATE_DWRET("::RegOpenKey");

    //
    // enumerate KeysNotToRestore
    //

    dwRet = ::RegOpenKeyEx( hkNewSystem, 
                          L"CurrentControlSet\\Control\\BackupRestore\\KeysNotToRestore",
                          0, KEY_READ,
                          &hkKNTR );
    VALIDATE_DWRET("::RegOpenKey");
    
    dwSize = MAX_PATH;
    cbValue = 0;
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue(hkKNTR, 
                                 dwIndex++,
                                 szName,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 NULL,
                                 &cbValue )))
    {        
        trace(0, "Name=%S", szName);
        if (FALSE == IsKeyToBeRestored(szName))
        {                        
            //
            // should preserve all the keys specified in this multisz value
            // 

            LPWSTR pszString = NULL;
            
            pMszString = (BYTE *) SRMemAlloc(cbValue);
            if (NULL == pMszString)
            {
                trace(0, "! SRMemAlloc");
                dwRet = ERROR_OUTOFMEMORY;
                goto Exit;
            }

            // read the multisz string
            dwRet = RegQueryValueEx(hkKNTR, 
                                    szName,
                                    NULL,
                                    &dwType,
                                    pMszString,
                                    &cbValue);
            VALIDATE_DWRET("RegQueryValueEx");              

            // process each element in the multisz string
            pszString = (LPWSTR) pMszString;
            do
            {
                // stop on null or empty string                
                if (! pszString || ! *pszString)
                    break;
                    
                trace(0, "Key = %S", pszString);

                // replace based on the last character of each key
                // if '\', then the whole key and subkeys are to be replaced in the old registry
                // if '*', it should be merged with the old -- we don't support this and will ignore
                // otherwise, it is a value to be replaced
                
                switch (pszString[lstrlen(pszString)-1])
                {
                    case L'*' :
                        trace(0, "Merge key - ignoring");
                        break;

                    case L'\\':
                        trace(0, "Replacing key");
                        lstrcpy(szKey, pszString);
                        szKey[lstrlen(szKey)-1]=L'\0';
                        ChangeCCS(hkOldSystem, szKey);
                        PersistRegKeys(hkOldSystem,           // mounted hive
                                       szKey,                 // key name in hive
                                       hkNewSystem,           // open key in registry
                                       pszString,             // key name in registry
                                       s_cszDRMKeyBackupFile, // name of backup file 
                                       pszSnapshotPath);      // snapshot path
                        break;
                        
                    default:
                        trace(0, "Replacing value");
                        lstrcpy(szKey, pszString);
                        ChangeCCS(hkOldSystem, szKey);
                        ValueReplace(hkOldSystem, szKey, hkNewSystem, pszString);
                        break;                        
                }     
            }   while (pszString = GetNextMszString(pszString));

            SRMemFree(pMszString);
            pMszString = NULL;
        }
        
        dwSize = MAX_PATH;
        cbValue = 0;
    }
                                 

Exit: 
    if (hkNewSystem)
        RegCloseKey(hkNewSystem);

    if (pMszString)
    {
        SRMemFree(pMszString);
    }

    if (hkKNTR)
    {
        RegCloseKey(hkKNTR);
    }
    
    TLEAVE();
    return dwRet;
}



DWORD
RestorePendingRenames(LPWSTR pwcBuffer, LPWSTR pszSSPath)
{
    TraceFunctEnter("RestorePendingRenames");
    
    WCHAR szSrc[MAX_PATH];
    DWORD dwRc = ERROR_SUCCESS;
    int iFirst = 0;
    int iSecond = 0;
    int iFile = 1;

    while (pwcBuffer[iFirst] != L'\0')
    {
        iSecond = iFirst + lstrlenW(&pwcBuffer[iFirst]) + 1;
        DebugTrace(0, "Src : %S, Dest : %S", &pwcBuffer[iFirst], &pwcBuffer[iSecond]);
        
        if (pwcBuffer[iSecond] != L'\0')
        {                        
            // restore the snapshot file MFEX-i.DAT in the snapshot dir
            // to the source file
    
            wsprintf(szSrc, L"%s%s\\MFEX-%d.DAT", pszSSPath, SNAPSHOT_DIR_NAME, iFile++);
            DebugTrace(0, "%S -> %S", szSrc, &pwcBuffer[iFirst+4]);
            
            SRCopyFile(szSrc, &pwcBuffer[iFirst+4]);
        }
        iFirst = iSecond + lstrlenW(&pwcBuffer[iSecond]) + 1;
    }

    TraceFunctLeave();
    return dwRc;    
}



static DWORD
HandleSoftwareHive( LPCWSTR cszDat, WCHAR * pszSnapshotPath )
{
    TraceFunctEnter("HandleSoftwareHive");
    DWORD    dwRet,dwSafeMode;
    LPCWSTR  cszErr;
    BOOL     fRegLoaded = FALSE;
    HKEY     hkMount = NULL;    // HKEY of temporary mount point of registry file
    WCHAR    szUIPath[MAX_PATH]=L"";



    // 1. Load registry-to-be-restored temporarily.
    dwRet = ::RegLoadKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp, cszDat );
    VALIDATE_DWRET("::RegLoadKey");
    fRegLoaded = TRUE;
    dwRet = ::RegOpenKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp, &hkMount );
    VALIDATE_DWRET("::RegOpenKey");

    // 2.1 Set RunOnce key for result page.
    ::ExpandEnvironmentStrings( s_cszRestoreUIPath, szUIPath, MAX_PATH );
    ::lstrcat( szUIPath, s_cszRunOnceOptNormal );
    if ( !::SRSetRegStr( hkMount, s_cszRegLMSWRunOnce, s_cszRunOnceValueName, szUIPath ) )
        goto Exit;

#if 0    
    // 2.2 Set SfcScan key to initiate WFP scanning after the restore.
    if ( !::SRSetRegDword( hkMount, s_cszRegLMSWWinLogon, s_cszRegValSfcScan, 2 ) )
        goto Exit;
#endif

    // 2.3 Set RestoreStatus value to 1 to denote restore success
    // test tools can use this when invoking silent restores to check success
    
    if ( !::SRSetRegDword( hkMount, s_cszRegSystemRestore, s_cszRestoreStatus, 1 ) )
    {
         // ignore the error since this is not a fatal error
        ErrorTrace(0,"SRSetRegDword failed.ec=%d", GetLastError());
    }

    // Write in the registry whether we are doing a restore from safe mode.
    if (0 != GetSystemMetrics(SM_CLEANBOOT))
    {
        TRACE(0, "Restore from safemode");
        dwSafeMode=1;
    }
    else
    {
        dwSafeMode=0;
    }
     // now write in the new registry about the status
    if ( !::SRSetRegDword( hkMount, s_cszRegSystemRestore, s_cszRestoreSafeModeStatus, dwSafeMode ) )
    {
         // ignore the error since this is not a fatal error
        ErrorTrace(0,"SRSetRegDword of safe mode status failed.ec=%d",
                   GetLastError());
    }    
    
     // 3. also set the new DRM keys
    {
        WCHAR    szDRMKeyNameInHive[MAX_PATH];    
         // ignore the error code since this is not a fatal error
        wsprintf(szDRMKeyNameInHive, L"Classes\\%s",s_cszDRMKey1);     
        PersistRegKeys(hkMount, // mounted hive
                       szDRMKeyNameInHive, // key name in hive
                       HKEY_CLASSES_ROOT, // open key in registry
                       s_cszDRMKey1, // key name in registry
                       s_cszDRMKeyBackupFile, // name of backup file 
                       pszSnapshotPath); // snapshot path
        
        wsprintf(szDRMKeyNameInHive, L"Classes\\%s",s_cszDRMKey2);         
        PersistRegKeys(hkMount, // mounted hive
                       szDRMKeyNameInHive, // key name in hive
                       HKEY_CLASSES_ROOT, // open key in registry
                       s_cszDRMKey2, // key name in registry
                       s_cszDRMKeyBackupFile, // name of backup file 
                       pszSnapshotPath); // snapshot path
    }        
        
     // also ignore the Remote assistance reg key
    {
        WCHAR    szRAKeyInRegistry[MAX_PATH];        
        
        wsprintf(szRAKeyInRegistry, L"%s\\%s",s_cszSoftwareHiveName,
                 s_cszRemoteAssistanceKey);
        PersistRegKeys(hkMount, // mounted hive
                       s_cszRemoteAssistanceKey, // key name in hive
                       HKEY_LOCAL_MACHINE, // open key in registry
                       szRAKeyInRegistry, // key name in registry
                       s_cszDRMKeyBackupFile, // name of backup file 
                       pszSnapshotPath); // snapshot path
    }

    // also ignore the Password Hints key
    {
        WCHAR    szHintKeyInRegistry[MAX_PATH];

        wsprintf(szHintKeyInRegistry, L"%s\\%s",s_cszSoftwareHiveName,
                 s_cszPasswordHints);

        PersistRegKeys(hkMount, // mounted hive
                       s_cszPasswordHints,       // key name in hive
                       HKEY_LOCAL_MACHINE, // open key in registry
                       szHintKeyInRegistry, // key name in registry
                       s_cszDRMKeyBackupFile, // name of backup file
                       pszSnapshotPath); // snapshot path
    }
    
    // also ignore the IE Content Advisor key
    {
        WCHAR    szContentAdvisorKeyInRegistry[MAX_PATH];

        wsprintf(szContentAdvisorKeyInRegistry, L"%s\\%s",
                 s_cszSoftwareHiveName,
                 s_cszContentAdvisor);

        PersistRegKeys(hkMount, // mounted hive
                       s_cszContentAdvisor,  // key name in hive
                       HKEY_LOCAL_MACHINE, // open key in registry
                       szContentAdvisorKeyInRegistry,// key name in registry
                       s_cszDRMKeyBackupFile, // name of backup file
                       pszSnapshotPath); // snapshot path
    }    

    // 4. Save the LSA secrets
    GetLsaRestoreState (hkMount);
    
Exit:
    if ( hkMount != NULL )
        (void)::RegCloseKey( hkMount );
    if ( fRegLoaded )
        (void)::RegUnLoadKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp );

    TraceFunctLeave();
    return( dwRet );
}

static DWORD
HandleSystemHive( LPCWSTR cszDat, LPWSTR pszSSPath )
{
    TraceFunctEnter("HandleSystemHive");
    DWORD    dwRet;
    LPCWSTR  cszErr;
    WCHAR    szWPAKeyNameInHive[MAX_PATH];    
    BOOL     fRegLoaded = FALSE;
    HKEY     hkMount = NULL;    // HKEY of temporary mount point of registry file
    LPWSTR   szRestoreMFE = NULL, szOldMFE = NULL;
    BYTE     * pszData = NULL, *pNewPos = NULL;
    DWORD    cbData1=0, cbData2=0, cbData=0;
    DWORD    dwCurrent = 1;
    WCHAR    szSessionManager[MAX_PATH];
    
    // 1. Load registry-to-be-restored temporarily.
    dwRet = ::RegLoadKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp, cszDat );
    VALIDATE_DWRET("::RegLoadKey");
    fRegLoaded = TRUE;
    dwRet = ::RegOpenKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp, &hkMount );
    VALIDATE_DWRET("::RegOpenKey");


    // get the session manager regkey
    lstrcpy(szSessionManager, s_cszRegLMSYSSessionMan);
    ChangeCCS(hkMount, szSessionManager);

    
     //persist WPA registry keys
    wsprintf(szWPAKeyNameInHive, L"%s\\%s", szSessionManager, s_cszWPAKeyRelative);    
           
    PersistRegKeys( hkMount,// mounted hive
                    szWPAKeyNameInHive,// key name in hive
                    HKEY_LOCAL_MACHINE,// open key in registry
                    s_cszWPAKey,// key name in registry
                    s_cszDRMKeyBackupFile,// name of backup file
                    pszSSPath);    // snapshot path

    //
    // process KeysNotToRestore key
    // and transfer listed keys to old system hive
    //

    PreserveKeysNotToRestore(hkMount, pszSSPath);

    
    // process movefileex entries from old registry

    szOldMFE = ::SRGetRegMultiSz( hkMount, szSessionManager, SRREG_VAL_MOVEFILEEX, &cbData1 );
    if (szOldMFE != NULL)
    {
        dwRet = RestorePendingRenames(szOldMFE, pszSSPath);
        VALIDATE_DWRET("RestorePendingRenames");
    }
    
    // copy restore's movefileex entries 
    // 
    // skip entries that were already there before restore began
    //

    szRestoreMFE = ::SRGetRegMultiSz( HKEY_LOCAL_MACHINE, SRREG_PATH_SESSIONMGR, SRREG_VAL_MOVEFILEEX, &cbData2 );                    
    if ( cbData2 > g_dwExistingMFEXMarker && szRestoreMFE != NULL )
    {
        trace(0, "Restore MFE entries exist");        

        if (g_dwExistingMFEXMarker > 0)
        {
            szRestoreMFE = (LPWSTR) ((BYTE *) szRestoreMFE + g_dwExistingMFEXMarker - sizeof(WCHAR));            
            cbData2 -= g_dwExistingMFEXMarker - sizeof(WCHAR);        
        }
        DebugTrace(0, "RestoreMFE:%S, cbData2:%ld", szRestoreMFE, cbData2);
        
        // allocate memory for old and new entries

        pszData = (BYTE *) malloc(cbData1 + cbData2);
        if (! pszData)
        {
            ErrorTrace(0, "! malloc");
            dwRet = ERROR_OUTOFMEMORY;
            goto Exit;
        }

        // append old entries AFTER restore's entries
        
        cbData = 0;
        if (szRestoreMFE != NULL)
        {            
            memcpy(pszData, szRestoreMFE, cbData2);

            // truncate last '\0' if more to append

            if (szOldMFE != NULL)     
            {
                cbData = cbData2 - sizeof(WCHAR);
                pNewPos = pszData + cbData;
            }
            else
            {
                cbData = cbData2;
                pNewPos = pszData;
            }
        }

        if (szOldMFE != NULL)
        {
            memcpy(pNewPos, szOldMFE, cbData1); 
            cbData += cbData1;              
        }
        
        if ( !::SRSetRegMultiSz( hkMount, szSessionManager, SRREG_VAL_MOVEFILEEX, (LPWSTR) pszData, cbData ) )
        {
            ErrorTrace(0, "! SRSetRegMultiSz");
            goto Exit;
        }

        free(pszData);
        
        // Set AllowProtectedRenames key for MoveFileEx.
        if ( !::SRSetRegDword( hkMount, szSessionManager, s_cszRegValAllowProtectedRenames, 1 ) )
            goto Exit;
    }


    // get the timezone regkey
    lstrcpy(szSessionManager, s_cszTZKeyInHive);
    ChangeCCS(hkMount, szSessionManager);
    
    // 
    // transfer timezone information from new registry to old registry
    // ie. don't restore timezone, since we can't restore time 
    //

    PersistRegKeys( hkMount, 
                    szSessionManager,
                    HKEY_LOCAL_MACHINE,
                    s_cszTZKeyInRegistry,
                    s_cszDRMKeyBackupFile,
                    pszSSPath);


    //
    // use the currently existing mounted devices info
    // i.e. all current volumes will be put back into the old registry
    // however for volumes that existed in the old registry,
    // the driveletter mapping from the old registry will be used
    //

//    dwRet = KeepMountedDevices(hkMount);
//    VALIDATE_DWRET("KeepMountedDevices");

    // Register password filter DLL to set old->new passwords
    dwRet = RegisterNotificationDLL (hkMount, TRUE);
    VALIDATE_DWRET("RegisterNotificationDLL");
    
Exit:
    if ( szRestoreMFE != NULL )
        delete [] szRestoreMFE;
    if ( szOldMFE != NULL )
        delete [] szOldMFE;
        
    if ( hkMount != NULL )
        (void)::RegCloseKey( hkMount );
    if ( fRegLoaded )
        (void)::RegUnLoadKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp );

    TraceFunctLeave();
    return( dwRet );
}

DWORD
CRestoreOperationManager::T2HandleSnapshot( CSnapshot & cSS, WCHAR * szSSPath )
{
    TraceFunctEnter("CRestoreOperationManager::T2HandleSnapshot");
    DWORD      dwRet;
    LPCWSTR    cszErr;
    WCHAR      szRegHive[MAX_PATH];
    WCHAR      szCatTSPath[MAX_PATH];   // Full path of CatRoot\TimeStamp

    // 1. Initialize Snapshot Handling Module. ( already done by caller )

    // 2. Manipulate HKLM\SOFTWARE Hive.
    dwRet = cSS.GetSoftwareHivePath( szSSPath, szRegHive, MAX_PATH );
    VALIDATE_DWRET("CSnapshot::GetSoftwareHivePath");
    LogDSFileTrace(0,L"SWHive: ", szRegHive);    

    dwRet = ::HandleSoftwareHive( szRegHive, szSSPath);
    if ( dwRet != ERROR_SUCCESS )
        goto Exit;

    // 3. Manipulate HKLM\SYSTEM Hive.
    dwRet = cSS.GetSystemHivePath( szSSPath, szRegHive, MAX_PATH );
    VALIDATE_DWRET("CSnapshot::GetSystemHivePath");
    LogDSFileTrace(0,L"SysHive: ", szRegHive);        

    dwRet = ::HandleSystemHive( szRegHive, szSSPath );
    if ( dwRet != ERROR_SUCCESS )
        goto Exit;

    // 3.5 Manipulate the HKLM\SAM Hive.
    dwRet = cSS.GetSamHivePath ( szSSPath, szRegHive, MAX_PATH );
    VALIDATE_DWRET("CSnapshot::GetSamHivePath");
    LogDSFileTrace(0,L"SamHive: ", szRegHive);

    dwRet = RestoreRIDs ( szRegHive );
    if (dwRet != ERROR_SUCCESS)
        goto Exit;

    // 4. Restore the Snapshot.
    dwRet = cSS.RestoreSnapshot( szSSPath );
    //VALIDATE_DWRET("CSnapshot::RestoreSnapshot");

    // 5. Cleanup Snapshot Handling Module.
    //dwRet = ::CleanupAfterRestore( szSSPath );
    //VALIDATE_DWRET("CSnapshot::CleanupAfterRestore");

    // 6. Delete timestamp file for WFP

    if (m_fRebuildCatalogDb == TRUE)
    {
        (void)::ExpandEnvironmentStrings( s_cszCatTimeStamp, szCatTSPath, MAX_PATH );
        if ( !::DeleteFile( szCatTSPath ) )
        {
            cszErr = ::GetSysErrStr();
            DebugTrace(0, "::DeleteFile(timestamp) failed - %ls", cszErr);
            // ignore error...
        }
    }
    
Exit:
    TraceFunctLeave();
    return( dwRet );
}

/////////////////////////////////////////////////////////////////////////////

DWORD
CRestoreOperationManager::T2CleanUp()
{
    TraceFunctEnter("CRestoreOperationManager::T2CleanUp");
    int   i;

    for ( i = m_aryDrv.GetUpperBound();  i >= 0;  i-- )
        m_paryEnt[i].ReleaseAll();
    delete [] m_paryEnt;

    m_aryDrv.DeleteAll();

    TraceFunctLeave();
    return( ERROR_SUCCESS );
}


DWORD
WriteFifoLog(LPWSTR pszLog, LPWSTR pwszDir, LPWSTR pwszDrive)
{
    FILE        *f = NULL;
    WCHAR       szLog[MAX_PATH];
    DWORD       dwRc = ERROR_INTERNAL_ERROR;
    WCHAR       wszTime[MAX_PATH] = L"";
    WCHAR       wszDate[MAX_PATH] = L"";
    CDataStore  *pds = NULL;
    
    TENTER("WriteFifoLog");

    TRACE(0, "Fifoed %S on drive %S",  pwszDir, pwszDrive);            

    f = (FILE *) _wfopen(szLog, L"a");
    if (f)
    {
        _wstrdate(wszDate);
        _wstrtime(wszTime);
        fwprintf(f, L"%s-%s : Fifoed %s on drive %s\n", wszDate, wszTime, pwszDir, pwszDrive);
        fclose(f);
        dwRc = ERROR_SUCCESS;
    }
    else
    {
        TRACE(0, "_wfopen failed on %s", szLog);
    }
    
    TLEAVE();
    return dwRc;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
CRestoreOperationManager::T2Fifo( int nDrv, DWORD dwRpNum )
{
    TraceFunctEnter("CRestoreOperationManager::T2Fifo");
    
    DWORD       dwErr = ERROR_SUCCESS;
    CDriveTable dt;
    CDataStore  *pds = NULL;
    BOOL        fFifoed = FALSE;
    DWORD       dwLastFifoedRp;
    WCHAR       szFifoedRpPath[MAX_PATH];
    CDataStore  *pdsLead = NULL, *pdsSys = NULL;
    BOOL        fFirstIteration;
    SDriveTableEnumContext dtec = {NULL, 0};
    WCHAR       szPath[MAX_PATH], szSys[MAX_PATH];
    WCHAR       szFifoedPath[MAX_PATH], szRpPath[MAX_PATH];
    DWORD       dwTargetRPNum = 0;
    WCHAR       szLog[MAX_PATH];
    
    ::GetSystemDrive(szSys);
    MakeRestorePath(szPath, szSys, s_cszDriveTable);    
    CHECKERR(dt.LoadDriveTable(szPath), L"LoadDriveTable");

    pdsSys = dt.FindSystemDrive();    
    if (pdsSys == NULL)
    {
        TRACE(0, "! FindSystemDrive");
        goto Err;
    }    
    MakeRestorePath(szLog, pdsSys->GetDrive(), s_cszFifoLog);    
    
    pdsLead = NULL;
    fFirstIteration = TRUE;
    pds = dt.FindDriveInTable((LPWSTR) m_aryDrv[nDrv]->GetID());    
    
    while (pds)            
    {
        fFifoed = FALSE;
        
        //
        // skip the drive we fifoed first
        //
        
        if (pds != pdsLead)
        {        
            //
            // enum forward, don't skip last
            //
            
            CRestorePointEnum   rpe( pds->GetDrive(), TRUE, FALSE );   
            CRestorePoint       rp;

            //
            // blow away any obsolete "Fifoed" directories
            //
            
            MakeRestorePath(szFifoedRpPath, pds->GetDrive(), s_cszFifoedRpDir);              
            CHECKERR( Delnode_Recurse(szFifoedRpPath, TRUE, NULL),
                      "Delnode_Recurse");

            //
            // blow away any obsolete "RP0" directories
            //
            
            MakeRestorePath(szFifoedRpPath, pds->GetDrive(), L"RP0");              
            CHECKERR( Delnode_Recurse(szFifoedRpPath, TRUE, NULL),
                      "Delnode_Recurse");

            //
            // loop through restore points on this drive
            //
            
            dwErr = rpe.FindFirstRestorePoint (rp);

            //
            // enumeration can return ERROR_FILE_NOT_FOUND for restorepoints
            // that are missing rp.log
            // we will just continue in this case
            //
            
            while (dwErr == ERROR_SUCCESS || dwErr == ERROR_FILE_NOT_FOUND)
            {
                //
                // check if we've reached the target RP num
                //
                
                if (dwTargetRPNum)
                {
                    if (rp.GetNum() > dwTargetRPNum)
                    {
                        TRACE(0, "Target restore point reached");
                        break;
                    }
                }            
                
                //
                // check if we've reached the selected rp
                //
                
                if (rp.GetNum() >= dwRpNum)
                {                 
                    //
                    // don't fifo current rp
                    //
                    
                    trace(0, "No more rps to fifo");
                    break;
                }            

                                                                    
                //
                // throw away this restore point on this drive       
                //

                // move the rp dir to a temp dir "Fifoed"
                // this is to make the fifo of a single rp atomic
                // to take care of unclean shutdowns
                
                MakeRestorePath(szRpPath, pds->GetDrive(), rp.GetDir());
                MakeRestorePath(szFifoedPath, pds->GetDrive(), s_cszFifoedRpDir);
                if (! MoveFile(szRpPath, szFifoedPath))
                {
                    dwErr = GetLastError();
                    TRACE(0, "! MoveFile from %S to %S : %ld", szRpPath, szFifoedPath, dwErr);
                    goto Err;
                }

                // blow away the temp fifoed directory
                
                CHECKERR(Delnode_Recurse(szFifoedPath, TRUE, NULL), 
                         L"Delnode_Recurse");                
                dwLastFifoedRp = rp.GetNum();                
                fFifoed = TRUE;              

                //
                // write to the fifo log
                //

                WriteFifoLog(szLog, rp.GetDir(), pds->GetDrive());
                
                dwErr = rpe.FindNextRestorePoint(rp);          
            }            
        }

        //
        // go to next drive
        //
        
        if (fFirstIteration)
        {
            if (! fFifoed)  // we did not fifo anything
            {
                break;
            }
        
            pdsLead = pds;
            pds = dt.FindFirstDrive(dtec);
            fFirstIteration = FALSE;
            dwTargetRPNum = dwLastFifoedRp; // fifo till what we fifoed just now
        }
        else
        {
            pds = dt.FindNextDrive(dtec);
        }
    }

    dwErr = ERROR_SUCCESS;
    
Err:    
    TraceFunctLeave();
    return( dwErr );
}


DWORD DeleteAllChangeLogs(WCHAR * pszRestorePointPath)
{
    TraceFunctEnter("DeleteAllFilesBySuffix");
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    WCHAR szFindFileData[MAX_PATH];
    
     // first construct the prefix of the file that stores the HKLM registry
     // snapshot.
    wsprintf(szFindFileData, L"%s\\%s*", pszRestorePointPath,
             s_cszCurrentChangeLog);
    
    dwErr = ProcessGivenFiles(pszRestorePointPath, DeleteGivenFile,
                              szFindFileData);
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "Deleting files failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;        
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    TraceFunctLeave();    
    return dwReturn;
}

/////////////////////////////////////////////////////////////////////////////

// Starting from the new "Restore" type restore point, enumerate
// change log entries and undo them. The order should be reverse (from
// the latest operation to the earliest operation.)
DWORD
CRestoreOperationManager::T2UndoForFail()
{
    TraceFunctEnter("CRestoreOperationManager::T2UndoForFail");
    DWORD    dwRet = ERROR_INTERNAL_ERROR;
    LPCWSTR  cszErr;
    HANDLE   hFilter = NULL;
    WCHAR    szDrv[MAX_PATH];
    WCHAR    szRestorePointPath[MAX_PATH];    
    WCHAR    szDSPath[MAX_PATH];
    int      i;

    // Cleanup m_aryEnt to free up as much memory as possible and prepare
    // to get the list of operations to be undone.
    for ( i = m_aryDrv.GetUpperBound();  i >= 0;  i-- )
        m_paryEnt[i].ReleaseAll();

    m_pLogFile->WriteMarker( RSTRLOGID_STARTUNDO, 0 );

    // Stop filter from monitoring
    dwRet = ::SrCreateControlHandle( SR_OPTION_OVERLAPPED, &hFilter );
    if ( dwRet != ERROR_SUCCESS )
    {
        ErrorTrace(0, "::SrCreateControlHandle failed - %d", dwRet);
        
        //One reason this can happen is if the SR service is still running.
         // Stop the service and try again

        if (IsSRServiceRunning() )
        {
            StopSRService(TRUE); // wait until service is stopped
        
            dwRet = ::SrCreateControlHandle( SR_OPTION_OVERLAPPED, &hFilter );
            if ( dwRet != ERROR_SUCCESS )
            {
                ErrorTrace(0, "::SrCreateControlHandle failed again - %d",
                           dwRet);            
            }
        }
        
        if ( dwRet != ERROR_SUCCESS )
        {
             //ISSUE - should I abort or continue???            
            goto Exit;
        }
    }
    dwRet = ::SrStopMonitoring( hFilter );
    if ( dwRet != ERROR_SUCCESS )
    {
        ErrorTrace(0, "::SrStopMonitoring failed - %ls", ::GetSysErrStr(dwRet));
        //ISSUE - should I abort or continue???
        goto Exit;
    }

    // Get change log entries to be undone
    for ( i = 0;  i < m_aryDrv.GetSize();  i++ )
    {
        if ( m_aryDrv[i]->IsOffline() || m_aryDrv[i]->IsFrozen() || m_aryDrv[i]->IsExcluded() )
            continue;

        // use the volume guid for each volume
        // we cannot use mountpoint paths because
        // restore might delete mount points before 
        // the operations on that volume are restored
        
        ::lstrcpy( szDrv, m_aryDrv[i]->GetID() );
        
        //cszDrv = m_aryDrv[i]->GetMount();
        ::MakeRestorePath( szDSPath, szDrv, NULL );
        DebugTrace(0, "Drive #%d: Drv='%ls', DS='%ls'", i, szDrv, szDSPath);

        CChangeLogEntryEnum  cEnum( szDrv, 0, m_dwRPNew, TRUE );
        CChangeLogEntry      cCLE;

        dwRet = cEnum.FindFirstChangeLogEntry( cCLE );
        if ( dwRet == ERROR_NO_MORE_ITEMS )
            goto EndOfChgLog;

        if ( dwRet != ERROR_SUCCESS )
        {
            cszErr = ::GetSysErrStr( dwRet );
            ErrorTrace(0, "FindFirstChangeLogEntry failed - %ls", cszErr);
            // even in case of error, try to revert as many operations as possible...
            goto EndOfChgLog;
        }

        while ( dwRet == ERROR_SUCCESS )
        {
            if ( !::CreateRestoreMapEntryFromChgLog( &cCLE, szDrv, szDSPath, m_paryEnt[i] ) )
            {
                // even in case of error, try to revert as many operations as possible...
                goto EndOfChgLog;
            }

            dwRet = cEnum.FindNextChangeLogEntry( cCLE );
        }

        if ( dwRet != ERROR_NO_MORE_ITEMS )
        {
            cszErr = ::GetSysErrStr( dwRet );
            ErrorTrace(0, "FindNextChangeLogEntry failed - %ls", cszErr);
            // even in case of error, try to revert as many operations as possible...
            goto EndOfChgLog;
        }

EndOfChgLog:
        cEnum.FindClose();
    }

    // UNDO!!!
    dwRet = T2DoRestore( TRUE );
    if ( dwRet != ERROR_SUCCESS )
        goto Exit;


    // Nuke everything in the RP directory

    // Get change logs  to be deleted
    for ( i = 0;  i < m_aryDrv.GetSize();  i++ )
    {
        if ( m_aryDrv[i]->IsOffline() || m_aryDrv[i]->IsFrozen() || m_aryDrv[i]->IsExcluded() )
            continue;

        // set cszDrv to proper drive letters...
        ::lstrcpy( szDrv, m_aryDrv[i]->GetMount() );
        if ( szDrv[2] == L'\0' )
        {
            szDrv[2] = L'\\';
            szDrv[3] = L'\0';
        }
        ::MakeRestorePath( szDSPath, szDrv, NULL );
        wsprintf(szRestorePointPath, L"%s\\%s%d",szDSPath, s_cszRPDir,
                 m_dwRPNew);
        LogDSFileTrace(0, L"Deleting changelogs from ", szRestorePointPath);
        DeleteAllChangeLogs(szRestorePointPath);
    }

    // 
    // change restorestatus in the registry to indicate that revert happened
    // successfully
    //
    SetRestoreStatusFailed();
    
    dwRet = ERROR_SUCCESS;
Exit:
    m_pLogFile->WriteMarker( RSTRLOGID_ENDOFUNDO, 0 );

    TraceFunctLeave();
    return( dwRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateRestoreOperationManager function
//
/////////////////////////////////////////////////////////////////////////////

BOOL
CreateRestoreOperationManager( CRestoreOperationManager **ppROMgr )
{
    TraceFunctEnter("CreateRestoreOperationManager");
    BOOL                      fRet = FALSE;
    CRestoreOperationManager  *pROMgr=NULL;

    if ( ppROMgr == NULL )
    {
        FatalTrace(0, "Invalid parameter, ppROMgr is NULL.");
        goto Exit;
    }
    *ppROMgr = NULL;

    pROMgr = new CRestoreOperationManager;
    if ( pROMgr == NULL )
    {
        FatalTrace(0, "Insufficient memory...");
        goto Exit;
    }

    if ( !pROMgr->Init() )
        goto Exit;

    *ppROMgr = pROMgr;

    fRet = TRUE;
Exit:
    if ( !fRet )
        SAFE_RELEASE(pROMgr);
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\rstrcore.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    rstrcore.h

Abstract:
    Common header file for SRRSTR component.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#ifndef _RSTRCORE_H__INCLUDED_
#define _RSTRCORE_H__INCLUDED_
#pragma once


#include "srshutil.h"


/////////////////////////////////////////////////////////////////////////////
//
// Constant Definitions
//
/////////////////////////////////////////////////////////////////////////////

#define MAX_STATUS  256
#define MAX_STR     1024

#define DSUSAGE_SLIDER_FREQ     10      // Granularity of DS Usage Slider Bar

#define SRREG_VAL_LOCKFILELIST   L"LockFileList"
#define SRREG_VAL_LOADFILELIST   L"LoadFileList"



/////////////////////////////////////////////////////////////////////////////
//
// Helper Macros
//
/////////////////////////////////////////////////////////////////////////////

#define VALIDATE_READFILE(hf, buf, size, read, label) \
    if ( !::ReadFile( hf, buf, size, &read, NULL ) ) \
    { \
        LPCWSTR cszErr = ::GetSysErrStr(); \
        DebugTrace(0, "::ReadFile failed - %ls", cszErr); \
        goto label; \
    } \

#define VALIDATE_READSIZE(size, read, label) \
    if ( read != size ) \
    { \
        DebugTrace(TRACE_ID, "Unexpected EOF (size=%d, read=%d)...", size, read); \
        goto label; \
    } \

#define READFILE_AND_VALIDATE(hf, buf, size, read, label) \
    VALIDATE_READFILE(hf, buf, size, read, label) \
    VALIDATE_READSIZE(size, read, label) \

#define VALIDATE_WRITEFILE(hf, buf, size, written, label) \
    if ( !::WriteFile( hf, buf, size, &written, NULL ) ) \
    { \
        LPCWSTR cszErr = ::GetSysErrStr(); \
        DebugTrace(TRACE_ID, "::WriteFile failed - %ls", cszErr); \
        goto label; \
    } \

#define VALIDATE_WRITTENSIZE(size, written, label) \
    if ( written != size ) \
    { \
        DebugTrace(TRACE_ID, "Incomplete Write (size=%d, written=%d)...", size, written); \
        goto label; \
    } \

#define WRITEFILE_AND_VALIDATE(hf, buf, size, read, label) \
    VALIDATE_WRITEFILE(hf, buf, size, read, label) \
    VALIDATE_WRITTENSIZE(size, read, label) \


/////////////////////////////////////////////////////////////////////////////
//
// Global Variables / Helper Functions
//
/////////////////////////////////////////////////////////////////////////////

// from main.cpp
//
extern HINSTANCE  g_hInst;

// from api.cpp
//
extern void  EnsureTrace();
extern void  ReleaseTrace();

// from password.cpp
//
DWORD RegisterNotificationDLL (HKEY hKeyLM, BOOL fRegister);


/////////////////////////////////////////////////////////////////////////////
//
// Drive Table Management
//
/////////////////////////////////////////////////////////////////////////////

class CRstrDriveInfo
{
public:
    CRstrDriveInfo();
    ~CRstrDriveInfo();

public:
    DWORD    GetFlags();
    BOOL     IsExcluded();
    BOOL     IsFrozen();
    BOOL     IsOffline();
    BOOL     IsSystem();
    BOOL     RefreshStatus();
    LPCWSTR  GetID();
    LPCWSTR  GetMount();
    LPCWSTR  GetLabel();
    void     SetMountAndLabel( LPCWSTR cszMount, LPCWSTR cszLabel );
    HICON    GetIcon( BOOL fSmall );
    BOOL     SaveToLog( HANDLE hfLog );
    UINT     GetDSUsage();
    BOOL     GetUsageText( LPWSTR szUsage );
    BOOL     GetCfgExcluded( BOOL *pfExcluded );
    void     SetCfgExcluded( BOOL fExcluded );
    BOOL     GetCfgDSUsage( UINT *puPos );
    void     SetCfgDSUsage( UINT uPos );
    BOOL     ApplyConfig( HWND hWnd );
    BOOL     Release();
    BOOL     InitUsage (LPCWSTR cszID, INT64 llDSUsage);

// operations
public:
    BOOL  Init( LPCWSTR cszID, CDataStore *pDS, BOOL fOffline );
    BOOL  Init( LPCWSTR cszID, DWORD dwFlags, INT64 llDSUsage, LPCWSTR cszMount,
 LPCWSTR cszLabel );
    BOOL  LoadFromLog( HANDLE hfLog );
    void  UpdateStatus( DWORD dwFlags, BOOL fOffline );

// attributes
protected:
    DWORD   m_dwFlags;
    CSRStr  m_strID;        // Unique Volume GUID
    CSRStr  m_strMount;     // Mount Point (drive letter or root directory path)
    CSRStr  m_strLabel;     // Volume Label
    HICON   m_hIcon[2];     // Large Icon for this drive
    INT64   m_llDSMin;      // Minimum size of DS
    INT64   m_llDSMax;      // Maximum size of DS
    UINT    m_uDSUsage;     // Current DS Usage by Service
    BOOL    m_fCfgExcluded;     // Configured value of "Exclude"
    UINT    m_uCfgDSUsage;      // Configured value of "DS Usage"
    ULARGE_INTEGER   m_ulTotalBytes;
};

typedef CSRDynPtrArray<CRstrDriveInfo*, 8>  CRDIArray;

BOOL  CreateAndLoadDriveInfoInstance( HANDLE hfLog, CRstrDriveInfo **ppRDI );
BOOL  CreateDriveList( int nRP, CRDIArray &aryDrv, BOOL fRemoveDrives );
BOOL  UpdateDriveList( CRDIArray &aryDrv );

/////////////////////////////////////////////////////////////////////////////
//
// CRestoreOperationManager class
//
/////////////////////////////////////////////////////////////////////////////

// forward declaration
class CRestoreMapEntry;
class CRestoreLogFile;
class CRestoreProgressWindow;

typedef CSRDynPtrArray<CRestoreMapEntry*, 64>  CRMEArray;

class CRestoreOperationManager
{
public:
    CRestoreOperationManager();

protected:
    ~CRestoreOperationManager();

// operations - methods
public:
    BOOL  Run( BOOL fFull );
    BOOL  FindDependentMapEntry( LPCWSTR cszSrc, BOOL fCheckSrc, CRestoreMapEntry **ppEnt );
    BOOL  GetNextMapEntry( CRestoreMapEntry **ppEnt );
    BOOL  Release();

// operations
public:
    BOOL  Init();

// operations - worker thread
protected:
    static DWORD WINAPI ExtThreadProc( LPVOID lpParam );
    DWORD  ROThreadProc();
    DWORD  T2Initialize();
    DWORD  T2EnumerateDrives();
    DWORD  T2CreateMap();
    DWORD  T2DoRestore( BOOL fUndo );
    DWORD  T2HandleSnapshot( CSnapshot & cSS, WCHAR * szSSPath );
    DWORD  T2CleanUp();
    DWORD  T2Fifo( int nDrv, DWORD dwRPNum );
    DWORD  T2UndoForFail();

// attributes

protected:
    BOOL                    m_fFullRestore;     // internal debug purpose only
    WCHAR                   m_szMapFile[MAX_PATH];
    CRestoreLogFile         *m_pLogFile;
    CRestoreProgressWindow  *m_pProgress;
    DWORD                   m_dwRPNum;
    DWORD                   m_dwRPNew;
    CRDIArray               m_aryDrv;
    CRMEArray               *m_paryEnt;
    DWORD                   m_dwTotalEntry;
    BOOL                    m_fRebuildCatalogDb;

    // Restore Context
    int   m_nDrv;       // Current drive being restored
    int   m_nEnt;       // Current map entry being restored
};

BOOL  CreateRestoreOperationManager( CRestoreOperationManager **ppROMgr );


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreMapEntry class
//
/////////////////////////////////////////////////////////////////////////////

class CRestoreMapEntry
{
public:
    CRestoreMapEntry( INT64 llSeq, DWORD dwOpr, LPCWSTR cszSrc );

// operations - methods
public:
    INT64  GetSeqNum()
    {  return( m_llSeq );  }
    DWORD  GetOpCode()
    {  return( m_dwOpr );  }
    DWORD  GetAttr()
    {  return( m_dwAttr );  }
    DWORD  GetResult()
    {  return( m_dwRes );  }
    DWORD  GetError()
    {  return( m_dwErr );  }
    LPCWSTR  GetPath1()
    {  return( m_strSrc );  }
    virtual LPCWSTR  GetPath2()
    {  return( NULL );  }
    LPCWSTR  GetAltPath()
    {  return( m_strAlt );  }
    void  SetResults( DWORD dwRes, DWORD dwErr )
    {  m_dwRes = dwRes;   m_dwErr = dwErr;  }
    void  UpdateSrc( LPCWSTR cszPath )
    {  m_strSrc = cszPath;  }
    virtual void  ProcessLocked()  {}
    virtual void  Restore( CRestoreOperationManager *pROMgr ) {}
    void  ProcessLockedAlt();
    BOOL  Release();

// operations
protected:
    BOOL  ClearAccess( LPCWSTR cszPath );
    BOOL  MoveFileDelay( LPCWSTR cszSrc, LPCWSTR cszDst );
    void  ProcessDependency( CRestoreOperationManager *pROMgr, DWORD dwFlags );

// attributes
protected:
    INT64   m_llSeq;
    DWORD   m_dwOpr;
    DWORD   m_dwAttr;
    CSRStr  m_strSrc;
    CSRStr  m_strDst;
    CSRStr  m_strTmp;
    CSRStr  m_strAlt;   // Alternative file name for renaming locked file/dir.
    DWORD   m_dwRes;
    DWORD   m_dwErr;
    CSRStr  m_strShortFileName;
};


BOOL  CreateRestoreMapEntryFromChgLog( CChangeLogEntry* pCLE, LPCWSTR cszDrv, LPCWSTR cszDSPath, CRMEArray &aryEnt );


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreLogFile class
//
/////////////////////////////////////////////////////////////////////////////

class CRestoreLogFile
{
public:
    CRestoreLogFile();

protected:
    ~CRestoreLogFile();

public:
    BOOL  Open();
    BOOL  Close();
    BOOL  ReadHeader( SRstrLogHdrV3 *pRPInfo , CRDIArray &aryDrv );
    BOOL  AppendHeader( SRstrLogHdrV3Ex *pExtInfo );
    BOOL  WriteEntry( DWORD dwID, CRestoreMapEntry *pEnt, LPCWSTR cszMount );
    BOOL  WriteCollisionEntry( LPCWSTR cszSrc, LPCWSTR cszDst, LPCWSTR cszMount
);
    BOOL  WriteMarker( DWORD dwMarker, DWORD dwErr );
    BOOL  IsValid();
    BOOL  Release();

// operations
public:
    BOOL  Init();

// attributes
protected:
    WCHAR   m_szLogFile[MAX_PATH];
    HANDLE  m_hfLog;
};

BOOL  CreateRestoreLogFile( SRstrLogHdrV3 *pRPInfo, CRDIArray &aryDrv );
BOOL  OpenRestoreLogFile( CRestoreLogFile **ppLogFile );


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreProgressWindow class
//
/////////////////////////////////////////////////////////////////////////////

class CRestoreProgressWindow
{
public:
    CRestoreProgressWindow();

protected:
    ~CRestoreProgressWindow();

// operations - methods
public:
    BOOL  Create();
    BOOL  Close();
    BOOL  Run();
    BOOL  SetStage( DWORD dwStage, DWORD dwBase );
    BOOL  Increment();
    BOOL  Release();

// operations
public:
    BOOL  Init();
    BOOL  LoadAndSetBrandBitmap( HWND hwndCtrl );

// operations - dialog procedure
protected:
    static INT_PTR CALLBACK ExtDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
    int  RPWDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );

// attributes
protected:
    HWND     m_hWnd;
    HBITMAP  m_hbmBrand;
    int      m_nResId;
    HFONT    m_hFntTitle;

    int      m_cxBar;       // Client width of progress bar.
    int      m_cxBarReal;   // Width of progress bar portion corresponds to "restore" stage.
    DWORD    m_dwStage;     // Current stage.
    DWORD    m_dwBase;      // Maximum position value, valid only for RPS_RESTORE.
    DWORD    m_dwPosLog;    // Logical position, e.g. number of change log entries.
    DWORD    m_dwPosReal;   // Physical position of progress bar.
};

// Restore Progress Stage
enum
{
    RPS_PREPARE = 0,
    RPS_RESTORE,
    RPS_SNAPSHOT
};

BOOL  CreateRestoreProgressWindow( CRestoreProgressWindow **ppDlg );

#endif //_RSTRCORE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\stubs.cpp ===
#include "stdwin.h"
#include <srconfig.h>
#include <utils.h>
#include <respoint.h>
#include <srapi.h>
#include <evthandler.h>
#include <enumlogs.h>
#include <ntservice.h>

CEventHandler * g_pEventHandler = NULL;
CSRConfig * g_pSRConfig = NULL;
CNTService * g_pSRService = NULL;

DWORD CEventHandler::SRUpdateMonitoredListS (LPWSTR pszXMLFile)
{
    return 0;
}

void CEventHandler::RefreshCurrentRp (BOOL fScanAllDrives)
{
}

void CNTService::LogEvent(WORD wType, DWORD dwID,
                  void * pRawData,
                  DWORD dwDataSize,
                  const WCHAR* pszS1,
                  const WCHAR* pszS2,
                  const WCHAR* pszS3)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\srshutil.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    srshutil.cpp

Abstract:
    This file contains the implementation of common utility functions.

Revision History:
    Seong Kook Khang (SKKhang)  06/22/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"

/****************************************************************************/

LPWSTR  IStrDup( LPCWSTR cszSrc )
{
    TraceFunctEnter("IStrDup");
    int     ccLen = 0 ;
    LPWSTR  szNew = NULL ;

    if ( cszSrc == NULL || cszSrc[0] == L'\0' )
        goto Exit;

    ccLen = ::lstrlen( cszSrc );
    szNew = new WCHAR[ccLen+2];
    if ( szNew == NULL )
    {
        //LOGLOG - Insufficient memory!!!
        goto Exit;
    }

    ::lstrcpy( szNew, cszSrc );

Exit:
    TraceFunctLeave();
    return( szNew );
}

/****************************************************************************/

DWORD  StrCpyAlign4( LPBYTE pbDst, LPCWSTR cszSrc )
{
    DWORD  dwLen = 0 ;

    if ( cszSrc != NULL )
        dwLen = ::lstrlen( cszSrc ) * sizeof(WCHAR);

    if ( cszSrc == NULL || dwLen == 0 )
    {
        *((LPDWORD)pbDst) = 0;
    }
    else
    {
        dwLen = ( dwLen + sizeof(WCHAR) + 3 ) & ~3;
        *((LPDWORD)pbDst) = dwLen;
        ::lstrcpy( (LPWSTR)(pbDst+sizeof(DWORD)), cszSrc );
    }
    return( dwLen+sizeof(DWORD) );
}

/****************************************************************************/

BOOL  ReadStrAlign4( HANDLE hFile, LPWSTR szStr )
{
    TraceFunctEnter("ReadStrAlign4");
    BOOL    fRet = FALSE;
    DWORD   dwLen;
    DWORD   dwRes;

    READFILE_AND_VALIDATE( hFile, &dwLen, sizeof(DWORD), dwRes, Exit );

    if ( dwLen > MAX_PATH*sizeof(WCHAR)+sizeof(DWORD) )
    {
        // Broken log file...
        goto Exit;
    }

    if ( dwLen > 0 )
    {
        READFILE_AND_VALIDATE( hFile, szStr, dwLen, dwRes, Exit );
    }
    else
        szStr[0] = L'\0';

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL
SRFormatMessage( LPWSTR szMsg, UINT uFmtId, ... )
{
    TraceFunctEnter("SRFormatMessage");
    BOOL     fRet = FALSE;
    va_list  marker;
    WCHAR    szFmt[MAX_STR];

    va_start( marker, uFmtId );
    ::LoadString( g_hInst, uFmtId, szFmt, MAX_STR );
    if ( 0 == ::FormatMessage( FORMAT_MESSAGE_FROM_STRING,
                    szFmt,
                    0,
                    0,
                    szMsg,
                    MAX_STR,
                    &marker ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::FormatMessage failed - %ls", cszErr);
        goto Exit;
    }
    va_end( marker );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL  ShowSRErrDlg( UINT uMsgId )
{
    TraceFunctEnter("ShowSRErrDlg");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    WCHAR    szTitle[256];
    WCHAR    szMsg[1024];

    if ( ::LoadString( g_hInst, IDS_SYSTEMRESTORE, szTitle,
                       sizeof(szTitle )/sizeof(WCHAR) ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_SYSTEMRESTORE, cszErr);
        goto Exit;
    }
    if ( ::LoadString( g_hInst, uMsgId, szMsg,
                       sizeof(szMsg )/sizeof(WCHAR) ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", uMsgId, cszErr);
        goto Exit;
    }

    ::MessageBox( NULL, szMsg, szTitle, MB_OK );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL  SRGetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD *pdwData )
{
    TraceFunctEnter("SRGetRegDword");
    BOOL   fRet = FALSE;
    DWORD  dwType;
    DWORD  dwRes;
    DWORD  cbData;

    dwType = REG_DWORD;
    cbData = sizeof(DWORD);
    dwRes = ::SHGetValue( hKey, cszSubKey, cszValue, &dwType, pdwData, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::SHGetValue failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL  SRSetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD dwData )
{
    TraceFunctEnter("SRSetRegDword");
    BOOL   fRet = FALSE;
    DWORD  dwRes;

    dwRes = ::SHSetValue( hKey, cszSubKey, cszValue, REG_DWORD, &dwData, sizeof(DWORD) );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::SHSetValue failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL  SRSetRegStr( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, LPCWSTR cszData )
{
    TraceFunctEnter("SRSetRegStr");
    BOOL   fRet = FALSE;
    DWORD  dwRes;

    dwRes = ::SHSetValue( hKey, cszSubKey, cszValue, REG_SZ, cszData, sizeof(WCHAR)*::lstrlen(cszData) );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::SHSetValue failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/
/*
LPWSTR  SRGetRegMultiSz( HKEY hkRoot, LPCWSTR cszSubKey, LPCWSTR cszValue, LPDWORD pdwData )
{
    TraceFunctEnter("SRGetRegMultiSz");
    LPCWSTR  cszErr;
    DWORD    dwRes;
    HKEY     hKey = NULL;
    DWORD    dwType;
    DWORD    cbData;
    LPWSTR   szBuf = NULL;

    dwRes = ::RegOpenKeyEx( hkRoot, cszSubKey, 0, KEY_ALL_ACCESS, &hKey );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegOpenKey() failed - %ls", cszErr);
        goto Exit;
    }

    dwRes = ::RegQueryValueEx( hKey, cszValue, 0, &dwType, NULL, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegQueryValueEx(len) failed - %ls", cszErr);
        goto Exit;
    }
    if ( dwType != REG_MULTI_SZ )
    {
        ErrorTrace(0, "Type of '%ls' is %u (not REG_MULTI_SZ)...", cszValue, dwType);
        goto Exit;
    }
    if ( cbData == 0 )
    {
        ErrorTrace(0, "Value '%ls' is empty...", cszValue);
        goto Exit;
    }

    szBuf = new WCHAR[cbData+2];
    dwRes = ::RegQueryValueEx( hKey, cszValue, 0, &dwType, (LPBYTE)szBuf, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegQueryValueEx(data) failed - %ls", cszErr);
        delete [] szBuf;
        szBuf = NULL;
    }

    if ( pdwData != NULL )
        *pdwData = cbData;

Exit:
    if ( hKey != NULL )
        ::RegCloseKey( hKey );
    TraceFunctLeave();
    return( szBuf );
}
*/
/****************************************************************************/
/*
BOOL  SRSetRegMultiSz( HKEY hkRoot, LPCWSTR cszSubKey, LPCWSTR cszValue, LPCWSTR cszData, DWORD cbData )
{
    TraceFunctEnter("SRSetRegMultiSz");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    DWORD    dwRes;
    HKEY     hKey = NULL;

    dwRes = ::RegOpenKeyEx( hkRoot, cszSubKey, 0, KEY_ALL_ACCESS, &hKey );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegOpenKey() failed - %ls", cszErr);
        goto Exit;
    }

    dwRes = ::RegSetValueEx( hKey, cszValue, 0, REG_MULTI_SZ, (LPBYTE)cszData, cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegSetValueEx() failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    if ( hKey != NULL )
        ::RegCloseKey( hKey );
    TraceFunctLeave();
    return( fRet );
}
*/
/****************************************************************************/

/////////////////////////////////////////////////////////////////////////////
//
// CSRStr class
//
/////////////////////////////////////////////////////////////////////////////

CSRStr::CSRStr()
{
    TraceFunctEnter("CSRStr::CSRStr()");

    m_cch = 0;
    m_str = NULL;

    TraceFunctLeave();
}

/****************************************************************************/

CSRStr::CSRStr( LPCWSTR cszSrc )
{
    TraceFunctEnter("CSRStr::CSRStr(LPCWSTR)");

    m_str = NULL;
    SetStr( cszSrc );

    TraceFunctLeave();
}

/****************************************************************************/

CSRStr::~CSRStr()
{
    TraceFunctEnter("CSRStr::~CSRStr");

    Empty();

    TraceFunctLeave();
}

/****************************************************************************/

int  CSRStr::Length()
{
    TraceFunctEnter("CSRStr::Length");
    TraceFunctLeave();
    return( m_cch );
}

/****************************************************************************/

CSRStr::operator LPCWSTR()
{
    TraceFunctEnter("CSRStr::operator LPCWSTR");
    TraceFunctLeave();
    return( m_str );
}

/****************************************************************************/

void  CSRStr::Empty()
{
    TraceFunctEnter("CSRStr::Empty");

    if ( m_str != NULL )
    {
        delete [] m_str;
        m_str = NULL;
        m_cch = 0;
    }

    TraceFunctLeave();
}

/****************************************************************************/

BOOL  CSRStr::SetStr( LPCWSTR cszSrc, int cch )
{
    TraceFunctEnter("CSRStr::SetStr(LPCWSTR,int)");
    BOOL  fRet = FALSE;

    Empty();

    if ( cszSrc == NULL )
        goto Exit;

    if ( cch == -1 )
        cch = ::lstrlen( cszSrc );

    if ( cch > 0 )
    {
        m_str = new WCHAR[cch+2];
        if ( m_str == NULL )
        {
            ErrorTrace(TRACE_ID, "Insufficient memory...");
            goto Exit;
        }
        ::StrCpyN( m_str, cszSrc, cch+1 );
        m_str[cch] = L'\0';
        m_cch = cch;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

const CSRStr&  CSRStr::operator =( LPCWSTR cszSrc )
{
    TraceFunctEnter("CSRStr::operator =(LPCWSTR)");

    SetStr( cszSrc );

    TraceFunctLeave();
    return( *this );
}


/////////////////////////////////////////////////////////////////////////////
//
// CSRLockFile class
//
/////////////////////////////////////////////////////////////////////////////

CSRLockFile::CSRLockFile()
{
    TraceFunctEnter("CSRLockFile::CSRLockFile()");
    LPCWSTR  cszErr;
    LPWSTR   szList;
    DWORD    cbData;
    LPCWSTR  cszPath;
    DWORD    dwAttr;
    HANDLE   hLock;
    HMODULE  hLoad;

    szList = ::SRGetRegMultiSz( HKEY_LOCAL_MACHINE, SRREG_PATH_SHELL, SRREG_VAL_LOCKFILELIST, &cbData );
    if ( szList != NULL )
    {
        cszPath = szList;
        while ( *cszPath != L'\0' )
        {
            dwAttr = ::GetFileAttributes( cszPath );
            if ( dwAttr != 0xFFFFFFFF )
            {
                if ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
                {
                    // Lock Directory...
                    hLock = ::CreateFile( cszPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
                }
                else
                {
                    // Lock File...
                    hLock = ::CreateFile( cszPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
                }
                if ( hLock == INVALID_HANDLE_VALUE )
                {
                    cszErr = ::GetSysErrStr();
                    ErrorTrace(0, "::CreateFile() failed - %ls", cszErr);
                    ErrorTrace(0, "    cszPath='%ls'", cszPath);
                }

                m_aryLock.AddItem( hLock );
            }
            else
                ErrorTrace(0, "Object does not exist - '%ls'", cszPath);

            cszPath += ::lstrlen( cszPath ) + 1;
        }
    }
    delete [] szList;

    szList = ::SRGetRegMultiSz( HKEY_LOCAL_MACHINE, SRREG_PATH_SHELL, SRREG_VAL_LOADFILELIST, &cbData );
    if ( szList != NULL )
    {
        cszPath = szList;
        while ( *cszPath != L'\0' )
        {
            dwAttr = ::GetFileAttributes( cszPath );
            if ( dwAttr != 0xFFFFFFFF )
            {
                hLoad = ::LoadLibrary( cszPath );
                if ( hLoad == NULL )
                {
                    cszErr = ::GetSysErrStr();
                    ErrorTrace(0, "::LoadLibrary() failed - %ls", cszErr);
                    ErrorTrace(0, "    cszPath='%ls'", cszPath);
                }

                m_aryLoad.AddItem( hLoad );
            }
            else
                ErrorTrace(0, "Executable does not exist - '%ls'", cszPath);

            cszPath += ::lstrlen( cszPath ) + 1;
        }
    }
    delete [] szList;

    TraceFunctLeave();
}

/****************************************************************************/

CSRLockFile::~CSRLockFile()
{
    TraceFunctEnter("CSRLockFile::~CSRLockFile");
    LPCWSTR  cszErr;
    int      i;

    for ( i = m_aryLock.GetUpperBound();  i >= 0;  i-- )
        if ( m_aryLock[i] != INVALID_HANDLE_VALUE )
        if ( !::CloseHandle( m_aryLock[i] ) )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::CloseHandle(m_aryLock[%d]) failed - %ls", i, cszErr);
        }

    for ( i = m_aryLoad.GetUpperBound();  i >= 0;  i-- )
        if ( m_aryLoad[i] != NULL )
        if ( !::FreeLibrary( m_aryLoad[i] ) )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::CloseHandle(m_aryLoad[%d]) failed - %ls", i, cszErr);
        }

    TraceFunctLeave();
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\srshutil.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    srshutil.h

Abstract:
    This file contains declaration of utility functions/classes like
    CSRStr, CDynArray, etc.

Revision History:
    Seong Kook Khang (SKKhang)  06/22/00
        created

******************************************************************************/

#ifndef _SRSHUTIL_H__INCLUDED_
#define _SRSHUTIL_H__INCLUDED_
#pragma once


/////////////////////////////////////////////////////////////////////////////
//
// Constant Definitions
//
/////////////////////////////////////////////////////////////////////////////

#define FA_BLOCK  ( FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM )


/////////////////////////////////////////////////////////////////////////////
//
// Utility Functions
//
/////////////////////////////////////////////////////////////////////////////

extern LPWSTR   IStrDup( LPCWSTR cszSrc );

extern DWORD  StrCpyAlign4( LPBYTE pbDst, LPCWSTR cszSrc );
extern BOOL   ReadStrAlign4( HANDLE hFile, LPWSTR szStr );

extern BOOL  SRFormatMessage( LPWSTR szMsg, UINT uFmtId, ... );
extern BOOL  ShowSRErrDlg( UINT uMsgId );

extern BOOL    SRGetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD *pdwData );
extern BOOL    SRSetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD dwData );
extern BOOL    SRSetRegStr( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, LPCWSTR cszData );
extern BOOL  SRGetAltFileName( LPCWSTR cszPath, LPWSTR szAltName );

// NTFS.CPP
extern DWORD  ClearFileAttribute( LPCWSTR cszFile, DWORD dwMask );
extern DWORD  TakeOwnership( LPCWSTR cszPath );
extern DWORD  SRCopyFile( LPCWSTR cszSrc, LPCWSTR cszDst );


/////////////////////////////////////////////////////////////////////////////
//
// CSRStr class
//
/////////////////////////////////////////////////////////////////////////////

//
// NOTE - 7/26/00 - skkhang
//  CSRStr has one issue -- NULL return in case of memory failure. Even though
//  the behavior is just same with regular C language pointer, many codes are
//  blindly passing it to some external functions (e.g. strcmp) which does not
//  gracefully handle NULL pointer. Ideally and eventually all of code should
//  prevent any possible NULL pointers from getting passed to such functions,
//  but for now, I'm using an alternative workaround -- GetID, GetMount, and
//  GetLabel returns a static empty string instead of NULL pointer.
//

class CSRStr
{
public:
    CSRStr();
    CSRStr( LPCWSTR cszSrc );
    ~CSRStr();

// Attributes
public:
    int  Length();
    operator LPCWSTR();

protected:
    int     m_cch;
    LPWSTR  m_str;

// Operations
public:
    void  Empty();
    BOOL  SetStr( LPCWSTR cszSrc, int cch = -1 );
    const CSRStr& operator =( LPCWSTR cszSrc );
};


/////////////////////////////////////////////////////////////////////////////
//
// CSRDynPtrArray class
//
/////////////////////////////////////////////////////////////////////////////

template<class type, int nBlock>
class CSRDynPtrArray
{
public:
    CSRDynPtrArray();
    ~CSRDynPtrArray();

// Attributes
public:
    int   GetSize()
    {  return( m_nCur );  }
    int   GetUpperBound()
    {  return( m_nCur-1 );  }
    type  GetItem( int nItem );
    type  operator[]( int nItem )
    {  return( GetItem( nItem ) );  }

protected:
    int   m_nMax;   // Maximum Item Count
    int   m_nCur;   // Current Item Count
    type  *m_ppTable;

// Operations
public:
    BOOL  AddItem( type item );
    BOOL  SetItem( int nIdx, type item );
    BOOL  Empty();
    void  DeleteAll();
    void  ReleaseAll();
};

template<class type, int nBlock>
CSRDynPtrArray<type, nBlock>::CSRDynPtrArray()
{
    m_nMax = 0;
    m_nCur = 0;
    m_ppTable = NULL;
}

template<class type, int nBlock>
CSRDynPtrArray<type, nBlock>::~CSRDynPtrArray()
{
    Empty();
}

template<class type, int nBlock>
type  CSRDynPtrArray<type, nBlock>::GetItem( int nItem )
{
    if ( nItem < 0 || nItem >= m_nCur )
    {
        // ERROR - Out of Range
    }
    return( m_ppTable[nItem] );
}

template<class type, int nBlock>
BOOL  CSRDynPtrArray<type, nBlock>::AddItem( type item )
{
    TraceFunctEnter("CSRDynPtrArray::AddItem");
    BOOL  fRet = FALSE;
    type  *ppTableNew;

    if ( m_nCur == m_nMax )
    {
        m_nMax += nBlock;

        // Assuming m_ppTable and m_nMax are always in sync.
        // Review if it's necessary to validate this assumption.
        if ( m_ppTable == NULL )
            ppTableNew = (type*)::HeapAlloc( ::GetProcessHeap(), 0, m_nMax*sizeof(type) );
        else
            ppTableNew = (type*)::HeapReAlloc( ::GetProcessHeap(), 0, m_ppTable, m_nMax * sizeof(type) );

        if ( ppTableNew == NULL )
        {
            FatalTrace(0, "Insufficient memory...");
            goto Exit;
        }
        m_ppTable = ppTableNew;
    }
    m_ppTable[m_nCur++] = item;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

template<class type, int nBlock>
BOOL  CSRDynPtrArray<type, nBlock>::SetItem( int nIdx, type item )
{
    if ( nIdx >= m_nMax )
        return( FALSE );

    m_ppTable[nIdx] = item;
    if ( nIdx >= m_nCur )
        m_nCur = nIdx+1;

    return( TRUE );
}

template<class type, int nBlock>
BOOL  CSRDynPtrArray<type, nBlock>::Empty()
{
    if ( m_ppTable != NULL )
    {
        ::HeapFree( ::GetProcessHeap(), 0, m_ppTable );
        m_ppTable = NULL;
        m_nMax = 0;
        m_nCur = 0;
    }
    return( TRUE );
}

template<class type, int nBlock>
void  CSRDynPtrArray<type, nBlock>::DeleteAll()
{
    for ( int i = m_nCur-1;  i >= 0;  i-- )
        delete m_ppTable[i];

    Empty();
}

template<class type, int nBlock>
void  CSRDynPtrArray<type, nBlock>::ReleaseAll()
{
    for ( int i = m_nCur-1;  i >= 0;  i-- )
        m_ppTable[i]->Release();

    Empty();
}


/////////////////////////////////////////////////////////////////////////////
//
// CSRLockFile class
//
/////////////////////////////////////////////////////////////////////////////
//
// This class reads multiple paths from the registry and either lock them
//  using ::CreateFile or load them using ::LoadLibrary. This is only for
//  test purpose - initiate locked-file-handling during a restoration.
//
class CSRLockFile
{
public:
    CSRLockFile();
    ~CSRLockFile();

protected:
    CSRDynPtrArray<HANDLE,16>   m_aryLock;
    CSRDynPtrArray<HMODULE,16>  m_aryLoad;
};


#endif //_SRSHUTIL_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\syscfg.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    syscfg.cpp

Abstract:
    This file contains SRGetCplPropPage function for System Control Panel.

Revision History:
    Seong Kook Khang (SKKhang)  07/19/00
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrcore.h"
#include "resource.h"
#include "helpids.h"

#define SRHELPURL  L"hcp://services/subsite?node=TopLevelBucket_4/Fixing_a_problem&select=TopLevelBucket_4/Fixing_a_problem/Using_System_Restore_to_undo_changes"

/////////////////////////////////////////////////////////////////////////////
//
// Static Variables
//
/////////////////////////////////////////////////////////////////////////////

WCHAR  s_szDrvStatus[5][MAX_STATUS] = { L"---" };

#define SRHELPFILE              L"sysrestore.hlp"

static const DWORD MAIN_HELP_MAP[] =
{
    IDC_TURN_OFF,       IDH_SR_TURN_OFF,            // Turn off all drives (check box)
    IDC_DRIVE_LIST,     IDH_SR_SELECT_VOLUME,       // Volume list (list view)
    IDC_DRIVE_SETTINGS, IDH_SR_CHANGE_SETTINGS,     // Change settings (pushbutton)
    0,                  0
};

static const DWORD DRIVE_HELP_MAP[] = 
{
    IDC_TURN_OFF,   IDH_SR_TURN_OFF_DRIVE,
    IDOK,           IDH_SR_CONFIRM_CHANGE,      // OK or Apply
    IDCANCEL,       IDH_SR_CANCEL,              // Cancel        
    0,              0
};

extern CSRClientLoader  g_CSRClientLoader;

/////////////////////////////////////////////////////////////////////////////
//
// Helper Functions
//
/////////////////////////////////////////////////////////////////////////////

void
EnableControls( HWND hDlg, int nFirst, int nLast, BOOL fEnable )
{
    int  i;

    for ( i = nFirst;  i <= nLast;  i++ )
        ::EnableWindow( ::GetDlgItem( hDlg, i ), fEnable );
}

LPCWSTR
GetDriveStatusText( CRstrDriveInfo *pRDI )
{
    if ( pRDI->IsOffline() )
        return( s_szDrvStatus[4] );
    else if ( pRDI->IsExcluded() )
        return( s_szDrvStatus[3] );
    else if ( pRDI->IsFrozen() )
        return( s_szDrvStatus[2] );
    else
        return( s_szDrvStatus[1] );
}

void
UpdateDriveStatus( HWND hwndList, CRDIArray *paryDrv )
{
    TraceFunctEnter("UpdateDriveStatus");
    int     i;
    WCHAR   szStat[256];
    LVITEM  lvi;

    if ( ::UpdateDriveList( *paryDrv ) )
    {
        for ( i = paryDrv->GetUpperBound();  i >= 0;  i-- )
        {
            ::lstrcpy( szStat, ::GetDriveStatusText( paryDrv->GetItem( i ) ) );
            lvi.mask     = LVIF_TEXT;
            lvi.iItem    = i;
            lvi.iSubItem = 1;
            lvi.pszText  = szStat;
            ::SendMessage( hwndList, LVM_SETITEM, 0, (LPARAM)&lvi );
        }
    }

    TraceFunctLeave();
}

void
ApplySettings( CRstrDriveInfo *pRDI )
{
    MessageBox(NULL, pRDI->GetMount(), L"SR", MB_OK);
}


/////////////////////////////////////////////////////////////////////////////
//
// Drive Settings Dialog for Multiple Drives
//
/////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK
SRCfgDriveSettingsDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    TraceFunctEnter("SRCfgDriveSettingsDlgProc");
    static BOOL     s_fDirty = FALSE;
    static UINT     s_uUsage;
    BOOL            fRet = FALSE;
    CRstrDriveInfo  *pRDI;
    WCHAR           szMsg[MAX_STR+2*MAX_PATH];
    WCHAR           szDCU[MAX_STR];
    HWND            hCtrl;
    BOOL            fCheck;
    UINT            uPos;
    DWORD           dwRet;
    DWORD           dwDSMin;
    
    if ( uMsg == WM_INITDIALOG )
    {
        ::SetWindowLong( hDlg, DWL_USER, lParam );
        pRDI = (CRstrDriveInfo*)lParam;
    }
    else
    {
        pRDI = (CRstrDriveInfo*)::GetWindowLong( hDlg, DWL_USER );
    }

    switch ( uMsg )
    {
    case WM_INITDIALOG :
        s_fDirty = FALSE;

        // Set Dialog Title
        ::SRFormatMessage( szMsg, IDS_DRIVEPROP_TITLE, pRDI->GetMount() );
        ::SetWindowText( hDlg, szMsg );

        // Set Dialog Heading
        if (lstrlen(pRDI->GetLabel()) != 0)
        {
            ::SRFormatMessage( szMsg, IDS_DRIVE_SUMMARY, pRDI->GetLabel(), pRDI->GetMount(), ::GetDriveStatusText( pRDI ) );
        }
        else
        {
            ::SRFormatMessage( szMsg, IDS_DRIVE_SUMMARY_NO_LABEL, pRDI->GetMount(), ::GetDriveStatusText( pRDI ) );
        }        

        ::SetDlgItemText( hDlg, IDC_DRIVE_SUMMARY, szMsg );

        // Read the SR_DEFAULT_DSMIN from the registry
        if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDSMin, &dwDSMin ) )
            dwDSMin = SR_DEFAULT_DSMIN;


        if ( pRDI->IsSystem() )
        {
            // Set Explaination About System Drive Cannot Be Off
            if (lstrlen(pRDI->GetLabel()) != 0)
            {            
                ::SRFormatMessage( szMsg, IDS_SYSDRV_CANNOT_OFF, pRDI->GetLabel(), pRDI->GetMount() );
            }
            else
            {
                ::SRFormatMessage( szMsg, IDS_SYSDRV_CANNOT_OFF_NO_LABEL, pRDI->GetMount());
            }
            ::SetDlgItemText( hDlg, IDC_SYSDRV_CANNOT_OFF, szMsg );

            //format IDC_SYSTEM_DCU_HOWTO text for the System Drive
            if( !::GetDlgItemText( hDlg, IDC_SYSTEM_DCU_HOWTO, szDCU, MAX_STR ) )
                ErrorTrace( 0, "GetDlgItemText failed for IDC_SYSTEM_DCU_HOWTO: %s", (LPCSTR)szMsg );
            wsprintf( szMsg, szDCU, dwDSMin );
            ::SetDlgItemText( hDlg, IDC_SYSTEM_DCU_HOWTO, szMsg );
        }
        else
        {
            fCheck = pRDI->IsExcluded();
            ::CheckDlgButton( hDlg, IDC_TURN_OFF, fCheck ? BST_CHECKED : BST_UNCHECKED );
            EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, !fCheck );
			
            //format IDC_NORMAL_DCU_HOWTO text for the Normal Drive
            if( !::GetDlgItemText( hDlg, IDC_NORMAL_DCU_HOWTO, szDCU, MAX_STR ) )
                ErrorTrace( 0, "GetDlgItemText failed for IDC_NORMAL_DCU_HOWTO: %s", (LPCSTR)szMsg );
            wsprintf( szMsg, szDCU, dwDSMin );
            ::SetDlgItemText( hDlg, IDC_NORMAL_DCU_HOWTO, szMsg );
        }

        hCtrl = ::GetDlgItem( hDlg, IDC_USAGE_SLIDER );
        ::SendMessage( hCtrl, TBM_SETRANGE, 0, MAKELONG( 0, DSUSAGE_SLIDER_FREQ ) );
        //::SendMessage( hCtrl, TBM_SETTICFREQ, 10, 0 );
        s_uUsage = pRDI->GetDSUsage();
        ::SendMessage( hCtrl, TBM_SETPOS, TRUE, s_uUsage );
        pRDI->GetUsageText( szMsg );
        ::SetDlgItemText( hDlg, IDC_USAGE_VALUE, szMsg );


        // Check the policy to see if local config is enabled
        if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableConfig, &dwRet ) )
        {
            ErrorTrace(0, "Group Policy disables SR configuration...");
            EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, FALSE );
            ::LoadString( g_hInst, IDS_GROUP_POLICY_CONFIG_ON_OFF, szMsg,
                      sizeof(szMsg)/sizeof(WCHAR) );
            ::SetDlgItemText( hDlg, IDC_TURN_OFF, szMsg );

            EnableWindow( ::GetDlgItem( hDlg, IDC_TURN_OFF ), FALSE );        
        }
        
        break;

    case WM_COMMAND :
        switch ( LOWORD(wParam) )
        {
        case IDC_TURN_OFF :
            fCheck = ::IsDlgButtonChecked( hDlg, IDC_TURN_OFF );
            EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, !fCheck );
            pRDI->SetCfgExcluded( fCheck );
            s_fDirty = TRUE;
            break;

        case IDC_DCU_INVOKE :
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                WCHAR  szDrv[4] = L"";

                szDrv[0] = (pRDI->GetMount())[0];
                szDrv[1] = L'\0';
                InvokeDiskCleanup( szDrv );
            }
            break;

        case IDOK :
            if ( s_fDirty )
                if ( !pRDI->ApplyConfig( hDlg ) )
                {
                    // refresh the on/off button in case the user cancelled
                    BOOL fCheck = pRDI->IsExcluded();
                    ::CheckDlgButton( hDlg, IDC_TURN_OFF, fCheck ? 
                                      BST_CHECKED : BST_UNCHECKED );
                }
            ::EndDialog( hDlg, IDOK );
            break;

        case IDCANCEL :
            ::EndDialog( hDlg, IDCANCEL );
            break;
        }
        break;

    case WM_HSCROLL :
        hCtrl = ::GetDlgItem( hDlg, IDC_USAGE_SLIDER );
        uPos = ::SendMessage( hCtrl, TBM_GETPOS, 0, 0 );
        if ( uPos != s_uUsage )
        {
            s_uUsage = uPos;
            pRDI->SetCfgDSUsage( uPos );
            ::SendMessage( hCtrl, TBM_SETPOS, TRUE, uPos );

            // Set Usage Text
            pRDI->GetUsageText( szMsg );
            ::SetDlgItemText( hDlg, IDC_USAGE_VALUE, szMsg );

            s_fDirty = TRUE;
        }
        break;
        
    case WM_CONTEXTMENU:
        if ( !::WinHelp ( (HWND) wParam,
                          SRHELPFILE,
                          HELP_CONTEXTMENU,
                          (DWORD_PTR) DRIVE_HELP_MAP) )
        {
            trace (0, "! WinHelp : %ld", GetLastError());                    
        }
        break;

    case WM_HELP:
        if (((LPHELPINFO) lParam)->hItemHandle)
        {
            if ( !::WinHelp ( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                              SRHELPFILE,
                              HELP_WM_HELP,
                              (DWORD_PTR) DRIVE_HELP_MAP) )
            {
                trace (0, "! WinHelp : %ld", GetLastError());                    
            }
        }
        break;
        
    default:
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// Property Page Proc for Multiple Drives
//
/////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK
SRCfgMultiDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    TraceFunctEnter("SRCfgMultiDlgProc");
    BOOL            fRet = FALSE;
    HWND            hCtrl;
    LVCOLUMN        lvc;
    WCHAR           szColText[256];
    CRDIArray       *paryDrv;
    CRstrDriveInfo  *pRDI;
    HIMAGELIST      himl;
    HICON           hIcon;
    int             i;
    int             nIdx;
    LONG            lRet;
    LVITEM          lvi;
    WCHAR           szName[2*MAX_PATH];
    int             nItem;
    WCHAR           szStat[256];
    BOOL            fDisable;
    DWORD           dwRet;
    
    if ( uMsg == WM_INITDIALOG )
    {
        PROPSHEETPAGE  *pPSP;
        pPSP    = (PROPSHEETPAGE*)lParam;
        paryDrv = (CRDIArray*)pPSP->lParam;
        ::SetWindowLong( hDlg, DWL_USER, (LPARAM)paryDrv );
    }
    else
    {
        paryDrv = (CRDIArray*)::GetWindowLong( hDlg, DWL_USER );
    }

    // if drive info is not available, skip our code.
    if ( paryDrv == NULL )
        goto Exit;

    switch ( uMsg )
    {
    case WM_INITDIALOG :
        hCtrl = ::GetDlgItem( hDlg, IDC_DRIVE_LIST );

        // Set full row selection
        //::SendMessage( hCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT );

        // Set column headers
        lvc.mask    = LVCF_TEXT | LVCF_WIDTH;
        lvc.cx      = 150;
        ::LoadString( g_hInst, IDS_DRVLIST_COL_NAME, szColText,
                      sizeof(szColText)/sizeof(WCHAR) );
        lvc.pszText = szColText;
        ::SendMessage( hCtrl, LVM_INSERTCOLUMN, 0, (LPARAM)&lvc );
        lvc.mask     = LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        lvc.cx       = 80;
        ::LoadString( g_hInst, IDS_DRVLIST_COL_STATUS, szColText,
                      sizeof(szColText)/sizeof(WCHAR) );
        lvc.pszText  = szColText;
        lvc.iSubItem = 1;
        ::SendMessage( hCtrl, LVM_INSERTCOLUMN, 1, (LPARAM)&lvc );

        // Create and set ImageList
        himl = ::ImageList_Create( 16, 16, ILC_COLOR | ILC_MASK, paryDrv->GetSize(), 0 );

        for ( i = 0;  i < paryDrv->GetSize();  i++ )
        {

            pRDI = paryDrv->GetItem( i );
            ::ImageList_AddIcon( himl, pRDI->GetIcon( TRUE ) );
            ::wsprintf( szName, L"%ls (%ls)", pRDI->GetLabel(), pRDI->GetMount() );
            ::lstrcpy( szStat, ::GetDriveStatusText( pRDI ) );

            lvi.mask     = LVIF_TEXT | LVIF_IMAGE;
            lvi.iItem    = i;
            lvi.iSubItem = 0;
            lvi.pszText  = szName;
            lvi.iImage   = i;
            nItem = ::SendMessage( hCtrl, LVM_INSERTITEM, 0, (LPARAM)&lvi );
            lvi.mask     = LVIF_TEXT;
            lvi.iItem    = nItem;
            lvi.iSubItem = 1;
            lvi.pszText  = szStat;
            ::SendMessage( hCtrl, LVM_SETITEM, 0, (LPARAM)&lvi );
        }

        ListView_SetItemState( hCtrl, 0, LVIS_SELECTED, LVIS_SELECTED );
        ::SendMessage( hCtrl, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)himl );
        ::ShowWindow( hCtrl, SW_SHOW );

        fDisable = paryDrv->GetItem( 0 )->IsExcluded();
        
        ::CheckDlgButton( hDlg, IDC_TURN_OFF, fDisable );
        ::EnableControls( hDlg, IDC_DRIVE_GROUPBOX, IDC_DRIVE_SETTINGS, !fDisable );

        //Group Policy
        if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableSR, &dwRet ) )
        {
            ::CheckDlgButton( hDlg, IDC_TURN_OFF, dwRet != 0 );
            ::LoadString( g_hInst, IDS_GROUP_POLICY_ON_OFF, szColText,
                      sizeof(szColText)/sizeof(WCHAR) );
            ::SetDlgItemText( hDlg, IDC_TURN_OFF, szColText );
            ::EnableWindow( ::GetDlgItem( hDlg, IDC_TURN_OFF ), FALSE );
        }

        // Check the policy to see if local config is enabled
        if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableConfig, &dwRet ) )
        {
            ErrorTrace(0, "Group Policy disables SR configuration...");
            EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, FALSE );
            ::LoadString( g_hInst, IDS_GROUP_POLICY_ON_OFF, szColText,
                      sizeof(szColText)/sizeof(WCHAR) );
            ::SetDlgItemText( hDlg, IDC_TURN_OFF, szColText );
            EnableWindow( ::GetDlgItem( hDlg, IDC_TURN_OFF ), FALSE );
        }
        

        break;

    case WM_COMMAND :
        switch ( LOWORD(wParam ) )
        {
        case IDC_TURN_OFF :
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                fDisable = ( ::IsDlgButtonChecked( hDlg, IDC_TURN_OFF ) == BST_CHECKED );
               
                // 
                // if safemode, cannot re-enable
                //
                if (fDisable == FALSE &&
                    paryDrv->GetItem(0)->IsExcluded() )
                {
                    if (0 != GetSystemMetrics(SM_CLEANBOOT))
                    {
                        ShowSRErrDlg(IDS_ERR_SR_SAFEMODE);
                        ::CheckDlgButton( hDlg, IDC_TURN_OFF, TRUE );                        
                        break;
                    }
                }        
                
                //::EnableControls( hDlg, IDC_DRIVE_GROUPBOX, IDC_DRIVE_SETTINGS, !fDisable );
                paryDrv->GetItem( 0 )->SetCfgExcluded( fDisable );
                //::UpdateDriveStatus( ::GetDlgItem( hDlg, IDC_DRIVE_LIST ), paryDrv );
                PropSheet_Changed( ::GetParent(hDlg), hDlg );
            }
            break;

        case IDC_DRIVE_SETTINGS :
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                UINT  uRet;
                UINT  uDlgId;

                hCtrl = ::GetDlgItem( hDlg, IDC_DRIVE_LIST );
                nIdx = ::SendMessage( hCtrl, LVM_GETNEXTITEM, -1, LVNI_SELECTED );
                pRDI = paryDrv->GetItem( nIdx );
                if ( pRDI->IsFrozen() )
                {
                    if ( pRDI->IsSystem() ) 
                        uDlgId = IDD_SYSPROP_SYSTEM_FROZEN;
                    else
                        uDlgId = IDD_SYSPROP_NORMAL_FROZEN;
                }
                else
                {
                    if ( pRDI->IsSystem() )
                        uDlgId = IDD_SYSPROP_SYSTEM;
                    else
                        uDlgId = IDD_SYSPROP_NORMAL;
                }

                uRet = ::DialogBoxParam( g_hInst,
                                         MAKEINTRESOURCE(uDlgId),
                                         ::GetParent( hDlg ),
                                         SRCfgDriveSettingsDlgProc,
                                         (LPARAM)pRDI );
                if ( uRet == IDOK )
                {
                    ::UpdateDriveStatus( hCtrl, paryDrv );
                }
                pRDI->SetCfgDSUsage (pRDI->GetDSUsage() );
            }
            break;         
        }
        break;
        
    case WM_NOTIFY :
        switch ( ((LPNMHDR)lParam)->code )
        {
        case LVN_ITEMCHANGED :
            hCtrl = ::GetDlgItem( hDlg, IDC_DRIVE_LIST );
            nIdx = ::SendMessage( hCtrl, LVM_GETNEXTITEM, -1, LVNI_SELECTED );
            fDisable = ( nIdx < 0 ) ||
                       paryDrv->GetItem( nIdx )->IsOffline();
            ::EnableWindow( ::GetDlgItem( hDlg, IDC_DRIVE_SETTINGS ), !fDisable );
            break;

        case PSN_APPLY :               
            if ( paryDrv->GetItem( 0 )->ApplyConfig( ::GetParent( hDlg ) ) )
                lRet = PSNRET_NOERROR;
            else
                lRet = PSNRET_INVALID;
            fDisable = paryDrv->GetItem( 0 )->IsExcluded();    
            
            ::UpdateDriveStatus( ::GetDlgItem( hDlg, IDC_DRIVE_LIST ), paryDrv );
            ::EnableControls( hDlg, IDC_DRIVE_GROUPBOX, IDC_DRIVE_SETTINGS, !fDisable );
            // refresh the on/off button in case the user cancelled
            ::CheckDlgButton( hDlg, IDC_TURN_OFF, fDisable ? BST_CHECKED : BST_UNCHECKED );
            ::SetWindowLong( hDlg, DWL_MSGRESULT, lRet );
            break;

        case NM_CLICK:
        case NM_RETURN:
            if (wParam == IDC_RESTOREHELP_LINK)
            {
                // launch help
                ShellExecuteW(NULL, L"open",
                              SRHELPURL, 
                              NULL, NULL, SW_SHOW);                
            }
            break;
        }
        break;

    case WM_CONTEXTMENU:
        if ( !::WinHelp ( (HWND) wParam,
                          SRHELPFILE,
                          HELP_CONTEXTMENU,
                          (DWORD_PTR) MAIN_HELP_MAP) )
        {
            trace (0, "! WinHelp : %ld", GetLastError());                    
        }
        break;

    case WM_HELP:
        if (((LPHELPINFO) lParam)->hItemHandle)
        {
            if ( !::WinHelp ( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                              SRHELPFILE,
                              HELP_WM_HELP,
                              (DWORD_PTR) MAIN_HELP_MAP) )
            {
                trace (0, "! WinHelp : %ld", GetLastError());                    
            }
        }
        break;
        
    case WM_NCDESTROY :
        paryDrv->ReleaseAll();
        delete paryDrv;
        ::SetWindowLong( hDlg, DWL_USER, NULL );
        break;

    default:
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// Property Page Proc for Single Drive
//
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK
SRCfgSingleDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    TraceFunctEnter("SRCfgSingleDlgProc");
    static UINT     s_uUsage;
    BOOL            fRet = FALSE;
    HWND            hCtrl;
    CRstrDriveInfo  *pRDI;
    HDC             hDC;
    PAINTSTRUCT     ps;
    RECT            rcCtrl;
    POINT           ptIcon;
    WCHAR           szMsg[MAX_STR+2*MAX_PATH];
    WCHAR           szDCU[MAX_STR];
    BOOL            fCheck;
    UINT            uPos;
    LONG            lRet;
    DWORD           dwRet;
    DWORD           dwDSMin;
    
    if ( uMsg == WM_INITDIALOG )
    {
        PROPSHEETPAGE   *pPSP;
        pPSP = (PROPSHEETPAGE*)lParam;
        pRDI = (CRstrDriveInfo*)pPSP->lParam;
        ::SetWindowLong( hDlg, DWL_USER, (LPARAM)pRDI );
    }
    else
    {
        pRDI = (CRstrDriveInfo*)::GetWindowLong( hDlg, DWL_USER );
    }

    // if drive info is not available, skip our code.
    if ( pRDI == NULL )
        goto Exit;

    switch ( uMsg )
    {
    case WM_INITDIALOG :
        // hide DCU if SR is not frozen
        if ( !pRDI->IsFrozen() )
        {
            ::ShowWindow( ::GetDlgItem( hDlg, IDC_DCU_HOWTO ), SW_HIDE );
            ::ShowWindow( ::GetDlgItem( hDlg, IDC_DCU_INVOKE ), SW_HIDE );
        }
        else // format IDC_DCU_HOWTO if SR is frozen
        {
            if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDSMin, &dwDSMin ) )
	            dwDSMin = SR_DEFAULT_DSMIN;
            if ( !::GetDlgItemText( hDlg, IDC_DCU_HOWTO, szDCU, MAX_STR ) )
                ErrorTrace( 0, "GetDlgItemText failed for IDC_DCU_HOWTO: %s", (LPCSTR)szMsg );
            wsprintf( szMsg, szDCU, dwDSMin );
            ::SetDlgItemText( hDlg, IDC_DCU_HOWTO, szMsg );
        }

        // drive icon
        hCtrl = ::GetDlgItem( hDlg, IDC_SD_ICON );
        ::ShowWindow( hCtrl, SW_HIDE );
        // drive status
        if (lstrlen(pRDI->GetLabel()) != 0)
        {
            ::SRFormatMessage( szMsg, IDS_DRIVE_SUMMARY, pRDI->GetLabel(), pRDI->GetMount(), ::GetDriveStatusText( pRDI ) );
        }
        else
        {
            ::SRFormatMessage( szMsg, IDS_DRIVE_SUMMARY_NO_LABEL, pRDI->GetMount(), ::GetDriveStatusText( pRDI ) );
        }
        ::SetDlgItemText( hDlg, IDC_SD_STATUS, szMsg );

        hCtrl = ::GetDlgItem( hDlg, IDC_USAGE_SLIDER );
        ::SendMessage( hCtrl, TBM_SETRANGE, 0, MAKELONG( 0, DSUSAGE_SLIDER_FREQ ) );
        //::SendMessage( hCtrl, TBM_SETTICFREQ, 10, 0 );
        s_uUsage = pRDI->GetDSUsage();
        ::SendMessage( hCtrl, TBM_SETPOS, TRUE, s_uUsage );
        pRDI->GetUsageText( szMsg );
        ::SetDlgItemText( hDlg, IDC_USAGE_VALUE, szMsg );

        fCheck = pRDI->IsExcluded();
        ::CheckDlgButton( hDlg, IDC_TURN_OFF, fCheck );
       
        EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, ! fCheck);

        //Group Policy
        if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableSR, &dwRet ))
        {
            ::CheckDlgButton( hDlg, IDC_TURN_OFF, dwRet != 0 );
            ::LoadString( g_hInst, IDS_GROUP_POLICY_ON_OFF, szMsg,
                       sizeof(szMsg)/sizeof(WCHAR) );
            ::SetDlgItemText( hDlg, IDC_TURN_OFF, szMsg );
            ::EnableWindow( ::GetDlgItem( hDlg, IDC_TURN_OFF ), FALSE );
        }

        // Check the policy to see if local config is enabled
        if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableConfig, &dwRet ) )
        {
            ErrorTrace(0, "Group Policy disables SR configuration...");
            EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, FALSE );

            ::LoadString( g_hInst, IDS_GROUP_POLICY_ON_OFF, szMsg,
                      sizeof(szMsg)/sizeof(WCHAR) );
            ::SetDlgItemText( hDlg, IDC_TURN_OFF, szMsg );
            EnableWindow( ::GetDlgItem( hDlg, IDC_TURN_OFF ), FALSE );
        }
        
        break;

    case WM_PAINT :
        hDC = ::BeginPaint( hDlg, &ps );
        ::GetWindowRect( ::GetDlgItem( hDlg, IDC_SD_ICON ), &rcCtrl );
        ptIcon.x = rcCtrl.left;
        ptIcon.y = rcCtrl.top;
        ::ScreenToClient( hDlg, &ptIcon );
        ::DrawIconEx( hDC, ptIcon.x, ptIcon.y, pRDI->GetIcon(TRUE), 0, 0, 0, NULL, DI_NORMAL );
        ::EndPaint( hDlg, &ps );

    case WM_COMMAND :
        switch ( LOWORD(wParam ) )
        {
        case IDC_TURN_OFF :        
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                fCheck = ::IsDlgButtonChecked( hDlg, IDC_TURN_OFF );
                
                // 
                // if safemode, cannot re-enable
                //
                if (fCheck == FALSE &&
                    pRDI->IsExcluded())
                {
                    if (0 != GetSystemMetrics(SM_CLEANBOOT))
                    {
                        ShowSRErrDlg(IDS_ERR_SR_SAFEMODE);
                        ::CheckDlgButton( hDlg, IDC_TURN_OFF, TRUE );                        
                        break;
                    }
                }        
                            
                EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, !fCheck );
                pRDI->SetCfgExcluded( fCheck );
                PropSheet_Changed( ::GetParent(hDlg), hDlg );
            }
            break;

        case IDC_DCU_INVOKE :
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                InvokeDiskCleanup( NULL );
            }
            break;
        }
        break;

    case WM_NOTIFY :    
        if ( ((LPNMHDR)lParam)->code == PSN_APPLY )
        {
            if ( pRDI->ApplyConfig( ::GetParent(hDlg) ) )
                lRet = PSNRET_NOERROR;
            else
                lRet = PSNRET_INVALID;

            fCheck = pRDI->IsExcluded();    

            //
            // update drive status
            //
            if (lstrlen(pRDI->GetLabel()) != 0)
            {
                ::SRFormatMessage( szMsg, IDS_DRIVE_SUMMARY, pRDI->GetLabel(), pRDI->GetMount(), ::GetDriveStatusText( pRDI ) );
            }
            else
            {
                ::SRFormatMessage( szMsg, IDS_DRIVE_SUMMARY_NO_LABEL, pRDI->GetMount(), ::GetDriveStatusText( pRDI ) );
            }
            ::SetDlgItemText( hDlg, IDC_SD_STATUS, szMsg );
            ::CheckDlgButton( hDlg, IDC_TURN_OFF, fCheck );
            EnableControls( hDlg, IDC_USAGE_GROUPBOX, IDC_USAGE_VALUE, ! fCheck);        

            ::SetWindowLong( hDlg, DWL_MSGRESULT, lRet );
        }
        else if ( ((LPNMHDR)lParam)->code == NM_CLICK ||
                  ((LPNMHDR)lParam)->code == NM_RETURN )
        {
            if (wParam == IDC_RESTOREHELP_LINK)
            {
                // launch help
                ShellExecuteW(NULL, L"open",
                              SRHELPURL, 
                              NULL, NULL, SW_SHOW);                
            }
        }
        break;

    case WM_HSCROLL :
        hCtrl = ::GetDlgItem( hDlg, IDC_USAGE_SLIDER );
        uPos = ::SendMessage( hCtrl, TBM_GETPOS, 0, 0 );
        if ( uPos != s_uUsage )
        {
            s_uUsage = uPos;
            pRDI->SetCfgDSUsage( uPos );
            ::SendMessage( hCtrl, TBM_SETPOS, TRUE, uPos );

            // Set Usage Text
            pRDI->GetUsageText( szMsg );
            ::SetDlgItemText( hDlg, IDC_USAGE_VALUE, szMsg );

            PropSheet_Changed( ::GetParent(hDlg), hDlg );
        }
        break;

    case WM_CONTEXTMENU:
        if ( !::WinHelp ( (HWND) wParam,
                          SRHELPFILE,
                          HELP_CONTEXTMENU,
                          (DWORD_PTR) MAIN_HELP_MAP) )
        {
            trace (0, "! WinHelp : %ld", GetLastError());                    
        }
        break;

    case WM_HELP:
        if (((LPHELPINFO) lParam)->hItemHandle)
        {
            if ( !::WinHelp ( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                              SRHELPFILE,
                              HELP_WM_HELP,
                              (DWORD_PTR) MAIN_HELP_MAP) )
            {
                trace (0, "! WinHelp : %ld", GetLastError());                    
            }
        }
        break;
        
    case WM_NCDESTROY :
        pRDI->Release();
        ::SetWindowLong( hDlg, DWL_USER, NULL );
        break;

    default:
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// SRGetCplPropPage
//
//  This routine creates a property page for System Restore tab of
//  System Control Panel.
//
/////////////////////////////////////////////////////////////////////////////
HPROPSHEETPAGE APIENTRY
SRGetCplPropPage()
{
    EnsureTrace();
    TraceFunctEnter("SRGetCplPropPage");
    DWORD           dwRet=0;
    HPROPSHEETPAGE  hPSP = NULL;
    LPCWSTR         cszErr;
    PROPSHEETPAGE   psp;
    CRDIArray       *paryDrv = NULL;
    DWORD           dwDisable;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();
    
    // Check credential
    if ( !::CheckPrivilegesForRestore() )
        goto Exit;

    // Check the policy to see if SR is enabled
    if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableSR, &dwRet ) )
        if ( dwRet != 0 )
        {
            ErrorTrace(0, "Group Policy disables SR...");
            goto Exit;
        }
        
    // if the registry says that SR is enabled, make sure we are
    // enabled correctly (service is started, startup mode is correct)
    
    // if registry says we are enabled, but service start type is disabled
    // disable us now    
    if (::SRGetRegDword( HKEY_LOCAL_MACHINE,
                         s_cszSRRegKey,
                         s_cszDisableSR,
                         &dwDisable ) )
    {
        DWORD  dwStart;
        
        if (0 == dwDisable)
        {            
            if (ERROR_SUCCESS == GetServiceStartup(s_cszServiceName, &dwStart) &&
                (dwStart == SERVICE_DISABLED || dwStart == SERVICE_DEMAND_START))
            {
                EnableSREx(NULL, TRUE);                
                DisableSR(NULL);
            }
            else
            {
                EnableSR(NULL);
            }
        }
    }

    paryDrv = new CRDIArray;
    if ( paryDrv == NULL )
    {
        FatalTrace(0, "Insufficient memory...");
        goto Exit;
    }

    if ( !::CreateDriveList( -1, *paryDrv, TRUE ) )
        goto Exit;

    if ( paryDrv->GetSize() == 0 )
    {
        ErrorTrace(0, "Drive List is empty...???");
        goto Exit;
    }

    // Load resource strings for drive status
    ::LoadString( g_hInst, IDS_DRVSTAT_ACTIVE,   s_szDrvStatus[1], MAX_STATUS );
    ::LoadString( g_hInst, IDS_DRVSTAT_FROZEN,   s_szDrvStatus[2], MAX_STATUS );
    ::LoadString( g_hInst, IDS_DRVSTAT_EXCLUDED, s_szDrvStatus[3], MAX_STATUS );
    ::LoadString( g_hInst, IDS_DRVSTAT_OFFLINE,  s_szDrvStatus[4], MAX_STATUS );

    ::ZeroMemory( &psp, sizeof(PROPSHEETPAGE) );
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hInst;
    psp.pszTitle    = NULL;

    if ( paryDrv->GetSize() > 1 )
    {
        // property page for multiple drives
        psp.lParam      = (LPARAM)paryDrv;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_SYSPROP_MULTI);
        psp.pfnDlgProc  = SRCfgMultiDlgProc;
    }
    else
    {
        // property page for single drive
        psp.lParam      = (LPARAM)paryDrv->GetItem( 0 );
        psp.pszTemplate = MAKEINTRESOURCE(IDD_SYSPROP_SINGLE);
        psp.pfnDlgProc  = SRCfgSingleDlgProc;
    }

    hPSP = ::CreatePropertySheetPage( &psp );
    if ( hPSP == NULL )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreatePropertySheetPage failed - %ls", cszErr);
        goto Exit;
    }

Exit:
    if ( hPSP == NULL )
        SAFE_DELETE(paryDrv);
    TraceFunctLeave();
    ReleaseTrace();
    return( hPSP );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\rstrcore\stdwin.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdwin.h

Abstract:
    Precompiled header file.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <aclapi.h>
#include <regstr.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <shellapi.h>
#include <delayimp.h>

#define USE_TRACING 1
#ifdef DBG
#define DEBUG
#endif
#include <dbgtrace.h>
#include <srdefs.h>
#include <utils.h>
#include <srrpcapi.h>
#include <datastormgr.h>
#include <snapshot.h>
#include <restmap.h>
#include <srshell.h>
#include <winsta.h>

#define TRACE_ID  123


#define EXPORT  extern "C" __declspec(dllexport)


#define SAFE_RELEASE(p) \
    if ( (p) != NULL ) \
    { \
        (p)->Release(); \
        p = NULL; \
    } \

#define SAFE_DELETE(p) \
    if ( (p) != NULL ) \
    { \
        delete p; \
        p = NULL; \
    } \

#define SAFE_DEL_ARRAY(p) \
    if ( (p) != NULL ) \
    { \
        delete [] p; \
        p = NULL; \
    } \


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\evthandler.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    evthandler.h
 *
 *  Abstract:
 *    CEventHandler class definition
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _EVTHANDLER_H_
#define _EVTHANDLER_H_

#include "srrestoreptapi.h"
#include "counter.h"


typedef DWORD (WINAPI* WORKITEMFUNC)(PVOID);


// shell notifications

DWORD WINAPI OnDiskFree_200(PVOID pszDrive);
DWORD WINAPI OnDiskFree_80(PVOID pszDrive);
DWORD WINAPI OnDiskFree_50(PVOID pszDrive);

DWORD WINAPI PostFilterIo(PVOID pNum);
extern "C" void CALLBACK TimerCallback(PVOID, BOOLEAN);
extern "C" void CALLBACK IoCompletionCallback(DWORD dwErrorCode,
                                              DWORD dwBytesTrns,
                                              LPOVERLAPPED pOverlapped);

extern "C" void CALLBACK IdleRequestCallback(PVOID pContext, BOOLEAN fTimerFired);
extern "C" void CALLBACK IdleStartCallback(PVOID pContext, BOOLEAN fTimerFired);
extern "C" void CALLBACK IdleStopCallback(PVOID pContext, BOOLEAN fTimerFired);

#define MAX_IOCTLS 5

typedef struct  _SR_OVERLAPPED 
{
    OVERLAPPED        m_overlapped;
    HANDLE            m_hDriver;
    DWORD             m_dwRecordLength;
    PSR_NOTIFICATION_RECORD m_pRecord;

} SR_OVERLAPPED, *LPSR_OVERLAPPED;



class CEventHandler {

public:
    CEventHandler();
    ~CEventHandler();

    // rpc functions
    
    DWORD DisableSRS(LPWSTR szDrive);
    DWORD EnableSRS(LPWSTR szDrive);
    
    DWORD DisableFIFOS(DWORD);
    DWORD EnableFIFOS();

    DWORD SRUpdateMonitoredListS(LPWSTR);
    DWORD SRUpdateDSSizeS(LPWSTR pszDrive, UINT64 ullSizeLimit);
    DWORD SRSwitchLogS();

    BOOL  SRSetRestorePointS(PRESTOREPOINTINFOW, PSTATEMGRSTATUS);
    DWORD SRRemoveRestorePointS(DWORD);
	DWORD SRPrintStateS();

    // actions on the datastore
    
    DWORD OnReset(LPWSTR pszDrive);          // filter initiated or DisableSRS/EnableSRS initiated
    DWORD OnFreeze(LPWSTR pszDrive);         // filter initiated or OnLowDisk initiated
    DWORD OnThaw(LPWSTR pszDrive);           // OnTimer initiated    
    DWORD OnCompress(LPWSTR pszDrive);       // OnIdle initiated
    DWORD OnFifo(LPWSTR pszDrive, DWORD dwTargetRp, int nPercent, BOOL fIncludeCurrentRp, BOOL fFifoAtleastOneRp);    
                                             // filter initiated or timer initiated

    DWORD OnBoot();                          // initialize all activity
    DWORD OnFirstRun();                         
    DWORD OnTimer(LPVOID, BOOL);             // timer callback
    DWORD OnIdle();
    void  OnStop();                          // stop all activity

    // filter notifications

    void  OnAny_Notification(DWORD dwErrorCode,           
                             DWORD dwBytesTrns, 
                             LPOVERLAPPED pOverlapped);
    void  OnFirstWrite_Notification(LPWSTR pszDrive);
    void  OnVolumeError_Notification(LPWSTR pszDrive, ULONG ulError);
    void  OnSize_Notification(LPWSTR pszDrive, ULONG ulSize);

    DWORD WaitForStop( );
    void  SignalStop( );
    DWORD XmlToBlob(LPWSTR);
    DWORD QueueWorkItem(WORKITEMFUNC pFunc, PVOID pv);
    void  RefreshCurrentRp(BOOL fScanAllDrives);
    
    CCounter* GetCounter() {
        return &m_Counter;
    }

    CLock* GetLock() {
        return &m_DSLock;
    }

    CRestorePoint       m_CurRp;
    HANDLE              m_hIdleStartHandle;
    HANDLE              m_hIdleRequestHandle;
    HANDLE              m_hIdleStopHandle;
    
private:
    CLock               m_DSLock;
    HANDLE              m_hTimerQueue;
    HANDLE              m_hTimer;
    HINSTANCE           m_hIdle;
    CCounter            m_Counter;
    BOOL                m_fNoRpOnSystem;
    FILETIME            m_ftFreeze;
    BOOL                m_fIdleSrvStarted;
    int                 m_nNestedCallCount;
    HMODULE             m_hCOMDll;
    BOOL                m_fCreateRpASAP;    

    DWORD InitIdleDetection();
    BOOL  EndIdleDetection();  
    DWORD InitTimer();
    BOOL  EndTimer();
    BOOL  IsMachineIdle();
    BOOL  IsTimeForAutoRp();
    DWORD WriteRestorePointLog(LPWSTR pszFullPath, 
                               PRESTOREPOINTINFOW pRPInfo);
};

extern CEventHandler *g_pEventHandler;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\evthandler.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    evthandler.cpp
 *
 *  Abstract:
 *    CEventHandler class methods
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#include "precomp.h"
#include "..\rstrcore\resource.h"
#include "ntservmsg.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#define IDLE_STACKSIZE        32768      // 32K stack for idle thread

CEventHandler        *g_pEventHandler;     

// constructor

CEventHandler::CEventHandler()
{
    m_hTimerQueue = m_hTimer = NULL;
    m_hIdle = NULL;
    m_fNoRpOnSystem = TRUE;
    m_fIdleSrvStarted = FALSE;
    m_ftFreeze.dwLowDateTime = 0;
    m_ftFreeze.dwHighDateTime = 0;
    m_nNestedCallCount = 0;
    m_hCOMDll = NULL;
    m_hIdleRequestHandle = NULL;
    m_hIdleStartHandle = NULL;
    m_hIdleStopHandle = NULL;
    m_fCreateRpASAP = FALSE;
}


// destructor

CEventHandler::~CEventHandler()
{
}


// the RPC API

DWORD 
CEventHandler::DisableSRS(LPWSTR pszDrive)
{
    DWORD   dwRc = ERROR_SUCCESS;
    BOOL    fHaveLock = FALSE;
    HANDLE  hEventSource = NULL;
    
    tenter("CEventHandler::DisableSRS");

    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pDataStoreMgr && g_pSRConfig);
    
    // if whole of SR is disabled, then
    //      - set firstrun and cleanup flag to yes
    //      - set stop event 
    
    if (! pszDrive || IsSystemDrive(pszDrive))
    {     
        trace(0, "Disabling all of SR");
        
        dwRc = SrStopMonitoring(g_pSRConfig->GetFilter());
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! SrStopMonitoring : %ld", dwRc);
            goto done;
        }
            
        dwRc = g_pSRConfig->SetFirstRun(SR_FIRSTRUN_YES);
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! SetFirstRun : %ld", dwRc);
            goto done;
        }
        
        g_pDataStoreMgr->DestroyDataStore(NULL);
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! DestroyDataStore : %ld", dwRc);
            goto done;
        }

        // set the filter start to disabled only if this is a 
        // real disable
        // if it's a reset, filter needs to start the next boot
        
        if (g_pSRConfig->GetResetFlag() == FALSE)
        {            
            dwRc = SetServiceStartup(s_cszFilterName, SERVICE_DISABLED);
            if (ERROR_SUCCESS != dwRc)
            {
                trace(0, "! SetServiceStartup : %ld", dwRc);
                goto done;
            }

            // done, we are disabled
            
            dwRc = g_pSRConfig->SetDisableFlag(TRUE);
            if (dwRc != ERROR_SUCCESS)
            {
                trace(0, "! SetDisableFlag : %ld", dwRc);
                goto done;
            }            
        }        

        // set the stop event
        // this will bring us down gracefully
        
        SignalStop();

        if (g_pSRConfig->m_dwTestBroadcast)
            PostTestMessage(g_pSRConfig->m_uiTMDisable, NULL, NULL);

        // write to event log
        hEventSource = RegisterEventSource(NULL, s_cszServiceName);
        if (hEventSource != NULL)
        {
            SRLogEvent (hEventSource, EVENTLOG_INFORMATION_TYPE, EVMSG_SYSDRIVE_DISABLED,
                        NULL, 0, NULL, NULL, NULL);
            DeregisterEventSource(hEventSource);
        }            
        
        trace(0, "SR disabled");          
    }  
    else
    {
        trace(0, "Disabling drive %S", pszDrive);
        
        // first tell filter to stop monitoring,
        // then build _filelst.cfg and pass down    

        dwRc = g_pDataStoreMgr->MonitorDrive(pszDrive, FALSE);
        if (ERROR_SUCCESS != dwRc)
        {
            trace(0, "! g_pDataStoreMgr->MonitorDrive for %s : %ld", pszDrive, dwRc);
            goto done;
        }
    }

done:
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}



DWORD 
CEventHandler::EnableSRS(LPWSTR pszDrive)
{
    tenter("CEventHandler::EnableSRS");
    BOOL    fHaveLock = FALSE;
    DWORD   dwRc = ERROR_SUCCESS;

    LOCKORLEAVE(fHaveLock);

    trace(0, "EnableSRS");

    ASSERT(g_pSRConfig);
    
    if (! pszDrive || IsSystemDrive(pszDrive))
    {     
        //
        // if safe mode, then don't 
        //

        if (TRUE == g_pSRConfig->GetSafeMode())
        {
            DebugTrace(0, "Cannot enable SR in safemode");
            dwRc = ERROR_BAD_ENVIRONMENT;
            goto done;
        }
        
        // system drive
    
        g_pSRConfig->SetDisableFlag(FALSE);
    
        dwRc = SetServiceStartup(s_cszFilterName, SERVICE_BOOT_START);
        if (ERROR_SUCCESS != dwRc)
        {
            trace(0, "! SetServiceStartup : %ld", dwRc);
            goto done;
        }

        dwRc = SetServiceStartup(s_cszServiceName, SERVICE_AUTO_START);
        if (ERROR_SUCCESS != dwRc)
        {
            trace(0, "! SetServiceStartup : %ld", dwRc);
            goto done;
        }        
    }  
    else
    {
        ASSERT(g_pDataStoreMgr);

        // build _filelst.cfg and pass down    

        dwRc = g_pDataStoreMgr->MonitorDrive(pszDrive, TRUE);
        if (ERROR_SUCCESS != dwRc)
        {
            trace(0, "! g_pDataStoreMgr->MonitorDrive for %s : %ld", pszDrive, dwRc);
            goto done;
        }
    }

done:
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}



DWORD 
CEventHandler::DisableFIFOS(DWORD dwRPNum)
{
    tenter("CEventHandler::DisableFIFOS");
    BOOL fHaveLock = FALSE;
    DWORD dwRc = ERROR_SUCCESS;
    
    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pSRConfig);
    
    g_pSRConfig->SetFifoDisabledNum(dwRPNum);
    trace(0, "Disabled FIFO from RP%ld", dwRPNum);

done:    
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}



DWORD 
CEventHandler::EnableFIFOS()
{
    tenter("CEventHandler::EnableFIFOS");
    BOOL fHaveLock = FALSE;
    DWORD dwRc = ERROR_SUCCESS;
    
    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pSRConfig);
    
    g_pSRConfig->SetFifoDisabledNum(0);
    trace(0, "Reenabled FIFO");

done:    
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}


// API and internal method to create a new restore point -
// this will ask filter to create a restore point folder,
// take the system snapshot, and write the restore point log

BOOL 
CEventHandler::SRSetRestorePointS(
    PRESTOREPOINTINFOW pRPInfo,  
    PSTATEMGRSTATUS    pSmgrStatus )
{
    tenter("CEventHandler::SRSetRestorePointS");

    DWORD           dwRc = ERROR_SUCCESS;
    WCHAR           szRPDir[MAX_RP_PATH];
    DWORD           dwRPNum = 1;
    BOOL            fHaveLock = FALSE;
    HKEY            hKey = NULL;
    CRestorePoint   rpLast;
    BOOL            fSnapshot = TRUE;
    DWORD           dwSaveType;
    BOOL            fUpdateMonitoredList = FALSE;
    DWORD           dwSnapshotResult = ERROR_SUCCESS;
    BOOL            fSerialized;
    

    if (! pRPInfo || ! pSmgrStatus)
    {
        trace(0, "Invalid arguments");
        dwRc = ERROR_INVALID_DATA;        
        goto done;
    }

    if (pRPInfo->dwRestorePtType > MAX_RPT)
    {
        trace(0, "Restore point type out of valid range");
        dwRc = ERROR_INVALID_DATA;
        goto done;
    }

    if (pRPInfo->dwEventType < MIN_EVENT ||
        pRPInfo->dwEventType > MAX_EVENT)
    {
        trace(0, "Event type out of valid range");
        dwRc = ERROR_INVALID_DATA;
        goto done;
    }

    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pDataStoreMgr && g_pSRConfig);    

    // 
    // special processing for FIRSTRUN checkpoint 
    //
    
    if (pRPInfo->dwRestorePtType == FIRSTRUN) 
    {
        // first remove the Run key if it exists
        // the function run from the Run entry in srclient.dll may not have been 
        // able to delete itself if it was run in non-admin context
        // so we will make sure we delete it here

        HKEY hKey;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, 
                                        L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 
                                        &hKey))
        {
            RegDeleteValue(hKey, L"SRFirstRun");
            RegCloseKey(hKey);
        }


        // if this is really the first checkpoint
        // then allow it no matter who's trying to create it
        // if not, then bail
     
        if (m_fNoRpOnSystem == FALSE)
        {
            trace(0, "Trying to create FirstRun rp when an rp already exists");
            dwRc = ERROR_ALREADY_EXISTS;
            goto done;
        }
    }
    
    //
    // if this is a restore restore point or system checkpoint,  
    // then erase any nested rp context 
    // this will make sure that restore can happen
    // even if some erratic client failed to call END_NESTED
    //

    if (pRPInfo->dwRestorePtType == RESTORE || 
        pRPInfo->dwRestorePtType == CHECKPOINT ||
        pRPInfo->dwRestorePtType == FIRSTRUN)
    {
        trace(0, "Resetting nested refcount to 0");
        m_nNestedCallCount = 0;
    }


    // 
    // get the current rp number
    // dwRPNum will be overwritten if a new restore point is created 
    // after all the prelim checks
    //
    
    dwRPNum = (m_fNoRpOnSystem == FALSE) ? m_CurRp.GetNum() : 0;

    
    // 
    // if this is a nested call
    // then don't create nested rps
    //

    if (pRPInfo->dwEventType == END_NESTED_SYSTEM_CHANGE)
    {
        // adjust refcount only if called for the current restore point

        if (pRPInfo->llSequenceNumber == 0 ||
            pRPInfo->llSequenceNumber == dwRPNum)
        {                
            dwRc = ERROR_SUCCESS;                
            if (m_nNestedCallCount > 0)                
                m_nNestedCallCount--;         
        }
        else if (pRPInfo->llSequenceNumber < dwRPNum)
        {
            dwRc = ERROR_SUCCESS;
            trace(0, "END_NESTED called for older rp - not adjusting refcount");
        }
        else
        {
            dwRc = ERROR_INVALID_DATA;
            trace(0, "END_NESTED called for non-existent rp - not adjusting refcount");
        }
        
        if (pRPInfo->dwRestorePtType != CANCELLED_OPERATION)
        {
            goto done;
        }            
        
    }
    else if (pRPInfo->dwEventType == BEGIN_NESTED_SYSTEM_CHANGE)
    {
        if (m_nNestedCallCount > 0)
        {
            dwRc = ERROR_SUCCESS;                        
            m_nNestedCallCount++;            
            goto done;
        }
    }            

    
    // check if this is a request to remove restore point
    // provided for backward compat only
    // new clients should use SRRemoveRestorePoint

    if (pRPInfo->dwEventType == END_SYSTEM_CHANGE ||
        pRPInfo->dwEventType == END_NESTED_SYSTEM_CHANGE)
    {
        if (pRPInfo->dwRestorePtType == CANCELLED_OPERATION)
        {
            dwRc = SRRemoveRestorePointS((DWORD) pRPInfo->llSequenceNumber);
            goto done;
        }
        else
        {
            dwRc = ERROR_SUCCESS;
            goto done;
        }
    }

    // if this is safe mode, don't create restore point
    //
    // however, allow restore UI to be able to create a hidden restore point in safemode        
    //
    
    if (g_pSRConfig->GetSafeMode() == TRUE)
    {
        if (pRPInfo->dwRestorePtType == CANCELLED_OPERATION)
        {
            // we need this rp only for undo in case of failure
            // so we don't need snapshot (snapshotting will fail in safemode)
            
            trace(0, "Restore rp - creating snapshot in safemode");
        }
        else
        {
            trace(0, "Cannot create restore point in safemode");
            dwRc = ERROR_BAD_ENVIRONMENT;
            goto done;
        }
    }

    //
    // if system drive is frozen,
    // then see if it can be thawed 
    // if not, then cannot create rp
    //

    if (g_pDataStoreMgr->IsDriveFrozen(g_pSRConfig->GetSystemDrive()))
    {
        if (ERROR_SUCCESS != g_pDataStoreMgr->ThawDrives(TRUE))
        {
            trace(0, "Cannot create rp when system drive is frozen");
            dwRc = ERROR_DISK_FULL;
            goto done;
        }
    }    

    if (hKey)
        RegCloseKey(hKey);   
    
    // ask filter to create restore point
    // filter will return the restore point number - i for RPi - in dwRPNum

    dwRc = SrCreateRestorePoint( g_pSRConfig->GetFilter(), &dwRPNum );
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! SrCreateRestorePoint : %ld", dwRc);
        goto done;
    }
    wsprintf( szRPDir, L"%s%ld", s_cszRPDir, dwRPNum );


    //
    // update the current restore point object
    // write rp.log with cancelled restorepoint type
    //

    if (m_fNoRpOnSystem == FALSE)
    {
        rpLast.SetDir(m_CurRp.GetDir());
    }
    
    m_CurRp.SetDir(szRPDir);
    dwSaveType = pRPInfo->dwRestorePtType;
    pRPInfo->dwRestorePtType = CANCELLED_OPERATION;
    m_CurRp.Load(pRPInfo);
    dwRc = m_CurRp.WriteLog();
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! WriteLog : %ld", dwRc);
        goto done;
    }
            
    // create system snapshot
    // if there is no explicit regkey that disabled it

    if (fSnapshot)
    {          
        WCHAR       szFullPath[MAX_PATH];        
        CSnapshot   Snapshot;          
        
        if (m_hCOMDll == NULL)
        {
            m_hCOMDll = LoadLibrary(s_cszCOMDllName);
    
            if (NULL == m_hCOMDll)
            {                       
                dwRc = GetLastError();
                trace(0, "LoadLibrary of %S failed ec=%d", s_cszCOMDllName, dwRc);
                goto done;
            }
        }
    
        // BUGBUG - this does not seem to make any difference
        // so remove it
#if 0        
        if (FALSE == SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL))
        {
            trace(0, "! SetThreadPriority first");
        }
#endif
        
        if (dwSaveType == RESTORE || 
            dwSaveType == CANCELLED_OPERATION)
        {
            fSerialized = TRUE;
            trace(0, "Setting fSerialized to TRUE");
        }
        else
        {
            fSerialized = FALSE;
            trace(0, "Setting fSerialized to FALSE");
        }

        MakeRestorePath (szFullPath, g_pSRConfig->GetSystemDrive(), szRPDir);        
        dwRc = Snapshot.CreateSnapshot(szFullPath, 
                                       m_hCOMDll,
                                       m_fNoRpOnSystem ? NULL : rpLast.GetDir(), 
                                       fSerialized);

#if 0
        if (FALSE == SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL))
        {
            trace(0, "! SetThreadPriority second");
        }        
#endif
        dwSnapshotResult = dwRc;        
    }
    

    // ask the datastoremgr to persist drivetable for old restore point
    // and reset per-rp flags for the new restore point
    
    dwRc = g_pDataStoreMgr->SwitchRestorePoint(m_fNoRpOnSystem ? NULL : &rpLast);
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "! SwitchRestorePoint : %ld", dwRc);
        goto done;
    }

    m_fNoRpOnSystem = FALSE;


    // 
    // restore point is fully created
    // write rp.log again
    // this time with the real restorepoint type
    //

    if (dwSnapshotResult == ERROR_SUCCESS)
    {
        pRPInfo->dwRestorePtType = dwSaveType;
        m_CurRp.Load(pRPInfo);    
        dwRc = m_CurRp.WriteLog();
        if ( ERROR_SUCCESS != dwRc )
        {
            trace(0, "! WriteLog : %ld", dwRc);
            goto done;
        }
                
        trace(0, "****Created %S %S****", szRPDir, pRPInfo->szDescription);
    }
    else
    {
        trace(0, "****Cancelled %S - snapshot failed", szRPDir);
    }        
    

    // if drives need to be thawed, then recreate blob
    // and deactivate thaw timer
    
    if ( TRUE == g_pDataStoreMgr->IsDriveFrozen(NULL) )
    {
        if (ERROR_SUCCESS == g_pDataStoreMgr->ThawDrives(FALSE))
        {
            m_ftFreeze.dwLowDateTime = 0;
            m_ftFreeze.dwHighDateTime = 0;
            fUpdateMonitoredList = TRUE;
        }
        else
        {
            dwRc = ERROR_DISK_FULL; 
            goto done;
        }
    } 

     // Also update the filter monitored list blob if this is an idle
     // time restore point or if this is the first run restore
     // point. We update the monitored list at first run since the
     // initial blob is created before the first user logs on to the
     // machine and before the first user's profile exists. So we want
     // to update rhe monitored list at first run since by now the
     // user's profile has been created.

    if (fUpdateMonitoredList ||
        (pRPInfo->dwRestorePtType == CHECKPOINT) ||
        (pRPInfo->dwRestorePtType == FIRSTRUN) )
    {
        dwRc = SRUpdateMonitoredListS(NULL);
    }
        

    // 
    // if rp creation succeeded,
    // and this is the outermost nested call
    // then bump refcount to 1
    //

    if (dwRc == ERROR_SUCCESS && 
        pRPInfo->dwEventType == BEGIN_NESTED_SYSTEM_CHANGE)
    {
        m_nNestedCallCount = 1;
    }

    //
    // send thaw complete test message
    //

    if (fUpdateMonitoredList)
    {
        if (g_pSRConfig->m_dwTestBroadcast)
            PostTestMessage(g_pSRConfig->m_uiTMThaw, NULL, NULL);        
    }            

    
    // if WMI is serialized, then check fifo conditions here
    // else this would happen in DoWMISnapshot

    if (fSerialized)
    {
        g_pDataStoreMgr->TriggerFreezeOrFifo();
    }    
    
done:
    trace(0, "Nest level : %d", m_nNestedCallCount);  

    if (dwSnapshotResult != ERROR_SUCCESS)
        dwRc = dwSnapshotResult;
        
    // populate return struct
    
    if (pSmgrStatus)
    {
        pSmgrStatus->nStatus = dwRc;
        pSmgrStatus->llSequenceNumber = (INT64) dwRPNum;  
    }
    
    UNLOCK( fHaveLock );
    tleave();               
    return ( dwRc == ERROR_SUCCESS ) ? TRUE : FALSE;
}

  
// this api is provided to remove a restore point
// removing a restore point simply takes away the ability to restore
// to this point - all the changes in this restore point are preserved

DWORD 
CEventHandler::SRRemoveRestorePointS(
    DWORD dwRPNum)
{
    tenter("CEventHandler::SRRemoveRestorePointS");

    BOOL            fHaveLock = FALSE;
    WCHAR           szRPDir[MAX_PATH];
    WCHAR           szFullPath[MAX_PATH];
    DWORD           dwRc = ERROR_SUCCESS;
    CSnapshot       Snapshot;
    CRestorePoint   rp;
    CDataStore      *pds = NULL;
    INT64           llOld, llNew;

    if (dwRPNum < 1)
    {
        dwRc = ERROR_INVALID_DATA;
        goto done;
    }    

    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pSRConfig);
    
    // if there is no rp, then no-op
    
    if (m_fNoRpOnSystem)
    {
        dwRc = ERROR_INVALID_DATA;
        goto done;
    }

    
    wsprintf(szRPDir, L"%s%ld", s_cszRPDir, dwRPNum);

    // read the restore point log
   
    rp.SetDir(szRPDir);
    dwRc = rp.ReadLog();
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! rp.ReadLog : %ld", dwRc);
        dwRc = ERROR_INVALID_DATA;        
        goto done;
    }
        
    // delete snapshot

    MakeRestorePath (szFullPath, g_pSRConfig->GetSystemDrive(), szRPDir);        
    dwRc = Snapshot.DeleteSnapshot(szFullPath);
    if (dwRc != ERROR_SUCCESS)
        goto done;

    
    // cancel this restore point

    rp.Cancel();

    //
    // adjust the restorepointsize file
    // and the in-memory counters in the service
    //

    pds = g_pDataStoreMgr->GetDriveTable()->FindSystemDrive();
    if (! pds)
    {
        trace(0, "! FindSystemDrive");
        goto done;
    }

    llOld = 0;
    dwRc = rp.ReadSize(g_pSRConfig->GetSystemDrive(), &llOld);
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "! rp.ReadSize : %ld", dwRc);
        goto done;
    }

    llNew = 0;
    dwRc = pds->CalculateRpUsage(&rp, &llNew, TRUE, FALSE);
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "! CalculateRpUsage : %ld", dwRc);
        goto done;
    }

    trace(0, "llOld = %I64d, llNew = %I64d", llOld, llNew);

    // 
    // now update the correct variable in the correct object
    //
    pds->UpdateDataStoreUsage (llNew - llOld, rp.GetNum() == m_CurRp.GetNum());
    
done:
    UNLOCK(fHaveLock);    
    tleave();
    return dwRc;
}



DWORD 
CEventHandler::SRUpdateMonitoredListS(
    LPWSTR pszXMLFile)
{
    tenter("CEventHandler::SRUpdateMonitoredListS");
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    BOOL    fHaveLock = FALSE;

    LOCKORLEAVE(fHaveLock);
    
    ASSERT(g_pDataStoreMgr && g_pSRConfig);

    // convert xml to blob
    
    dwRc = XmlToBlob(pszXMLFile);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    // reload to filter
    
    dwRc = SrReloadConfiguration(g_pSRConfig->GetFilter());
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! SrReloadConfiguration : %ld", dwRc);
        goto done;
    }    

    trace(0, "****Reloaded config file****");
    
done:
    UNLOCK(fHaveLock);    
    tleave();
    return dwRc;
}


DWORD
CEventHandler::SRUpdateDSSizeS(LPWSTR pwszVolumeGuid, UINT64 ullSizeLimit)
{
    tenter("CEventHandler::SRUpdateDSSizeS");

    UINT64          ullTemp;
    DWORD           dwRc = ERROR_SUCCESS;
    CDataStore      *pds = NULL;
    BOOL            fHaveLock = FALSE;
    BOOL            fSystem;

    LOCKORLEAVE(fHaveLock);
    
    ASSERT(g_pDataStoreMgr);

    pds = g_pDataStoreMgr->GetDriveTable()->FindDriveInTable(pwszVolumeGuid);
    if (! pds)
    {
        trace(0, "Volume not in drivetable : %S", pwszVolumeGuid);
        dwRc = ERROR_INVALID_DRIVE;
        goto done;
    }

    fSystem = pds->GetFlags() & SR_DRIVE_SYSTEM;
    if (ullSizeLimit < (g_pSRConfig ? g_pSRConfig->GetDSMin(fSystem) : 
                       (fSystem ? SR_DEFAULT_DSMIN:SR_DEFAULT_DSMIN_NONSYSTEM)
                        * MEGABYTE))
    {
        trace(0, "SRUpdateDSSizeS %I64d less than dwDSMin", ullSizeLimit);
        dwRc = ERROR_INVALID_PARAMETER;
        goto done;
    }
    
    ullTemp = pds->GetSizeLimit();     // save previous size
    pds->SetSizeLimit(0);              // reset the datastore size
    pds->UpdateDiskFree (NULL);        // calculate the default size

    if (ullSizeLimit > pds->GetSizeLimit())
    {
        pds->SetSizeLimit (ullTemp);
        trace(0, "SRUpdateDSSizeS %I64d greater than limit", ullSizeLimit);
        dwRc = ERROR_INVALID_PARAMETER;
        goto done;
    }

    pds->SetSizeLimit(ullSizeLimit);

    g_pDataStoreMgr->GetDriveTable()->SaveDriveTable((CRestorePoint *) NULL);

    // 
    // this might change fifo conditions
    // so check and trigger fifo if necessary
    // 
    
    g_pDataStoreMgr->TriggerFreezeOrFifo();    
    
done:
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}



DWORD
CEventHandler::SRSwitchLogS()
{
    tenter("CEventHandler::SRSwitchLogS");

    DWORD dwRc = ERROR_SUCCESS;
    BOOL  fHaveLock;

    LOCKORLEAVE(fHaveLock);
    
    ASSERT(g_pSRConfig);

    dwRc = SrSwitchAllLogs(g_pSRConfig->GetFilter());
    if (ERROR_SUCCESS != dwRc)
        trace(0, "! SrSwitchLog : %ld", dwRc);

done:    
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}


DWORD
CEventHandler::XmlToBlob(LPWSTR pszwXml)
{
    tenter("CEventHandler::XmlToBlob");   

    DWORD               dwRc = ERROR_INTERNAL_ERROR;
    WCHAR               szwDat[MAX_PATH], szwXml[MAX_PATH];
    CFLDatBuilder       FLDatBuilder;

    ASSERT(g_pSRConfig);

    MakeRestorePath(szwDat, g_pSRConfig->GetSystemDrive(), s_cszFilelistDat);

    if (0 == ExpandEnvironmentStrings(s_cszWinRestDir, szwXml, sizeof(szwXml) / sizeof(WCHAR)))
    {
        dwRc = GetLastError();
        trace(0, "! ExpandEnvironmentStrings");
        goto done;
    }
    lstrcat(szwXml, s_cszFilelistXml);
        
    if ( ! pszwXml )
    {
        pszwXml = szwXml;
    }

    if (FALSE == FLDatBuilder.BuildTree(pszwXml, szwDat))
    {
        trace(0, "! FLDatBuilder.BuildTree");
        goto done;
    }

    if (pszwXml && pszwXml != szwXml && 0 != lstrcmpi(pszwXml, szwXml))
    {
        // copy the new filelist 
        SetFileAttributes(szwXml, FILE_ATTRIBUTE_NORMAL);
        if (FALSE == CopyFile(pszwXml, szwXml, FALSE))
        {
            dwRc = GetLastError();
            trace(0, "! CopyFile : %ld", dwRc);
            goto done;
        }
    }

    // set filelist.xml to be S+H+R
    SetFileAttributes(szwXml, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);            
    dwRc = ERROR_SUCCESS;


done:
    tleave();
    return dwRc;
}


// SR ACTIONS


DWORD 
CEventHandler::OnFirstRun()
{
    tenter("CEventHandler::OnFirstRun");   

    DWORD               dwRc = ERROR_SUCCESS;
    RESTOREPOINTINFO    RPInfo;
    STATEMGRSTATUS      SmgrStatus;        
    LPSTR               pszDat = NULL, pszXml = NULL;
    WCHAR               szwDat[MAX_PATH], szwXml[MAX_PATH];
    
    trace(0, "Firstrun detected");
    
    dwRc = XmlToBlob(NULL);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    // ask filter to start monitoring               
    
    dwRc = SrStartMonitoring(g_pSRConfig->GetFilter());
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! SrStartMonitoring : %ld", dwRc);
        goto done;   
    }

    // change firstrun in the registry

    dwRc = g_pSRConfig->SetFirstRun(SR_FIRSTRUN_NO);
    if ( dwRc != ERROR_SUCCESS )
    {
        trace(0, "! g_pSRConfig->SetFirstRun : %ld", dwRc);
        goto done;
    }
    
    // create firstrun restore point

    if (! g_pDataStoreMgr->IsDriveFrozen(g_pSRConfig->GetSystemDrive()) &&
          g_pSRConfig->GetCreateFirstRunRp() != 0)
    {
        RPInfo.dwEventType = BEGIN_SYSTEM_CHANGE; 
        RPInfo.dwRestorePtType = FIRSTRUN;
        if (ERROR_SUCCESS != SRLoadString(L"srrstr.dll", IDS_SYSTEM_CHECKPOINT_TEXT, RPInfo.szDescription, MAX_PATH))
        {
            trace(0, "Using default hardcoded text");
            lstrcpy(RPInfo.szDescription, s_cszSystemCheckpointName);
        }
        
        if ( FALSE == SRSetRestorePointS( &RPInfo, &SmgrStatus ))
        {
            // 
            // even if this fails
            // keep the service running
            //
            trace(0, "Cannot create firstrun restore point : %ld", SmgrStatus.nStatus);            
        }
    }
        
    //
    // in future re-enables, service should create firstrun rp
    //
        
    if (g_pSRConfig->m_dwCreateFirstRunRp == 0)
        g_pSRConfig->SetCreateFirstRunRp(TRUE);       

done:            
    tleave();  
    return dwRc;
}


// stuff to do at boot
// read in all the config values from registry
// initialize communication with filter
// call OnFirstRun if necessary
// setup timer & idle detection
// start RPC server

DWORD 
CEventHandler::OnBoot()
{
    BOOL    fHaveLock = FALSE;
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    BOOL    fSendEnableMessage = FALSE;
    DWORD   dwFlags;
    
    tenter("CEventHandler::OnBoot");   

    dwRc = m_DSLock.Init(); 
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "m_DSLock.Init() : %ld", dwRc);
        goto done;
    }   

    LOCKORLEAVE(fHaveLock);
    
    // initialize the counter
    
    dwRc = m_Counter.Init();
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! CCounter::Init : %ld", dwRc);
        goto done;
    }

    // read all values from registry
    // create global events 

    g_pSRConfig = new CSRConfig;
    if ( ! g_pSRConfig )
    {
        dwRc = ERROR_NOT_ENOUGH_MEMORY;
        trace(0, "Out of Memory");
        goto done;
    }
    dwRc = g_pSRConfig->Initialize();    
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! g_pSRConfig->Initialize : %ld", dwRc);
        goto done;
    }
    trace(0, "SRBoottask: SRConfig initialized");

    if ( g_pSRConfig->GetDisableFlag() == TRUE )
    {
        // check if we're forced to enable

        if ( g_pSRConfig->GetDisableFlag_GroupPolicy() == FALSE )
        {
            dwRc = EnableSRS(NULL);
            if (ERROR_SUCCESS != dwRc)
            {
                trace(0, "! EnableSRS : %ld", dwRc);
                goto done;
            }
        }
        else
        {
            // we are not forced to enable
            // so we don't need to check if group policy is not configured or is disabling us
            // since we are disabled anyway
            
            trace(0, "SR is disabled - stopping");
            dwRc = ERROR_SERVICE_DISABLED;
            goto done;
        }            
    }

    // open the filter handle
    // this will load the filter if not already loaded
    
    dwRc = g_pSRConfig->OpenFilter();
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! g_pSRConfig->OpenFilter : %ld", dwRc);
        goto done;
    }
    trace(0, "SRBoottask: Filter handle opened");

    //
    // we might do a firstrun if the datastore is corrupted
    // (_filelst.cfg missing)
    // in this case, the filter might be ON
    // turn off the filter
    //
    
    if ( g_pSRConfig->GetFirstRun() == SR_FIRSTRUN_YES )
    {                
        dwRc = SrStopMonitoring(g_pSRConfig->GetFilter());
        trace(0, "SrStopMonitoring returned : %ld", dwRc);
    }
    
    // initialize the datastore
    
    g_pDataStoreMgr = new CDataStoreMgr;
    if ( ! g_pDataStoreMgr )
    {
        trace(0, "Out of Memory");
        dwRc = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }    
    dwRc = g_pDataStoreMgr->Initialize (g_pSRConfig->GetFirstRun() == SR_FIRSTRUN_YES);
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! g_pDataStore.Initialize : %ld", dwRc);
        goto done;
    }
    trace(0, "SRBoottask: Datastore initialized");

    // check if we are newly disabled from group policy

    if ( g_pSRConfig->GetDisableFlag_GroupPolicy() == TRUE && 
        g_pSRConfig->GetDisableFlag() == FALSE )
    {
        DisableSRS (NULL);
        dwRc = ERROR_SERVICE_DISABLED;
        goto done;
    }

    // check if this is first run

    if ( g_pSRConfig->GetFirstRun() == SR_FIRSTRUN_YES )
    {
        fSendEnableMessage = TRUE;
        dwRc = OnFirstRun( );
        if ( ERROR_SUCCESS != dwRc )
        {
            trace(0, "! OnFirstRun : %ld", dwRc);
            goto done;
        }
        trace(0, "SRBoottask: FirstRun completed");
    }

    // remember the latest restore point
    
    RefreshCurrentRp(TRUE); 

    if (ERROR_SUCCESS == g_pDataStoreMgr->GetFlags(g_pSRConfig->GetSystemDrive(), &dwFlags))
    {
        if (dwFlags & SR_DRIVE_ERROR)
        {
            // a volume error happened in the last session
            // we should create a restore point at next idle time

            m_fCreateRpASAP = TRUE;
            trace(0, "Volume error occurred in last session - create rp at next idle");
        }
    }
    else
    {
        trace(0, "! g_pDataStoreMgr->GetFlags()");        
    }
    
    
    // register filter ioctls
    
    if (! QueueUserWorkItem(PostFilterIo, (PVOID) MAX_IOCTLS, WT_EXECUTEDEFAULT))
    {
        dwRc = GetLastError();
        trace(0, "! QueueUserWorkItem : %ld", dwRc);
        goto done;
    }


    // start idle time detection

    // register idle callback
    
    if (FALSE == RegisterWaitForSingleObject(&m_hIdleRequestHandle, 
                                             g_pSRConfig->m_hIdleRequestEvent,
                                             (WAITORTIMERCALLBACK) IdleRequestCallback,
                                             NULL,
                                             g_pSRConfig->m_dwIdleInterval*1000,
                                             WT_EXECUTEDEFAULT))
    {
        dwRc = GetLastError();
        trace(0, "! RegisterWaitForSingleObject : %ld", dwRc);
        goto done;
    }                                    
    
    
    // now request for idle

    SetEvent(g_pSRConfig->m_hIdleRequestEvent);
    

    //
    // if there are no mounted drives
    // shell will give us all the notifications
    // so don't start timer thread
    //

    // BUGBUG - keep this?
    // don't start timer at all
    
    // if (FALSE == g_pDataStoreMgr->GetDriveTable()->AnyMountedDrives())
    // {
        g_pSRConfig->m_dwTimerInterval = 0;
    // }
    
    // set up timer 

    dwRc = InitTimer();
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! InitTimer : %ld", dwRc);
        goto done;
    }
    

    // start rpc server

    dwRc = RpcServerStart();
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! RpcServerStart : %ld", dwRc);
        goto done;
    }   
                                                 
                                
    // all initialization complete

    SetEvent( g_pSRConfig->m_hSRInitEvent );
    
    if (fSendEnableMessage)
    {
        // write to event log        
       
        HANDLE hEventSource = RegisterEventSource(NULL, s_cszServiceName);
        if (hEventSource != NULL)
        {
            SRLogEvent (hEventSource, EVENTLOG_INFORMATION_TYPE, EVMSG_SYSDRIVE_ENABLED,
                        NULL, 0, NULL, NULL, NULL);
            DeregisterEventSource(hEventSource);
        }
        
        if (g_pSRConfig->m_dwTestBroadcast)
            PostTestMessage(g_pSRConfig->m_uiTMEnable, NULL, NULL);
    }
    
done:
    UNLOCK(fHaveLock);
    tleave( );
    return dwRc;
}


// method to shutdown the service gracefully

void
CEventHandler::OnStop()
{
    DWORD   dwRc;

    tenter("CEventHandler::OnStop");

    if (g_pSRConfig == NULL)
    {
        trace(0, "g_pSRConfig = NULL");
        goto Err;
    }
    
    // stop everything
    // BUGBUG - do we need to take the lock here?
    // since all the stops are blocking in themselves
    // and this has to preempt any running activity,
    // blocking here is not such a good idea


    // stop the rpc server

    RpcServerShutdown();
    trace(0, "SRShutdowntask: RPC server shutdown");

    // kill the timer and timer queue

    EndTimer();
    trace(0, "SRShutdownTask: Timer stopped");
        
    // 
    // blocking calls to unregister idle event callbacks
    //
    if (m_hIdleRequestHandle != NULL)
    {
        if (FALSE == UnregisterWaitEx(m_hIdleRequestHandle, INVALID_HANDLE_VALUE))
        {
            trace(0, "! UnregisterWaitEx : %ld", GetLastError());
        }
        m_hIdleRequestHandle = NULL;
    }
    
    if (m_hIdleStartHandle != NULL)
    {
        if (FALSE == UnregisterWaitEx(m_hIdleStartHandle, INVALID_HANDLE_VALUE))
        {
            trace(0, "! UnregisterWaitEx : %ld", GetLastError());
        }
        m_hIdleStartHandle = NULL;
    }

    if (m_hIdleStopHandle != NULL)
    {
        if (FALSE == UnregisterWaitEx(m_hIdleStopHandle, INVALID_HANDLE_VALUE))
        {
            trace(0, "! UnregisterWaitEx : %ld", GetLastError());
        }
        m_hIdleStopHandle = NULL;
    }


    
    // we are done with the filter

    g_pSRConfig->CloseFilter();


    trace(0, "Filter handle closed");
    
    // wait for any queued user work items and pending IOCTLs to complete

    m_Counter.WaitForZero();
    trace(0, "SRShutdownTask: Pending ioctls + work items completed");

    
    //
    // free the COM+ db dll
    //
    
    if (NULL != m_hCOMDll)
    {
        _VERIFY(TRUE==FreeLibrary(m_hCOMDll));
        m_hCOMDll = NULL;
    }
    
        
    // kill the datastoremgr 
        
    if (g_pDataStoreMgr)
    {
        g_pDataStoreMgr->SignalStop();        
        delete g_pDataStoreMgr;
        g_pDataStoreMgr = NULL;
    }

    // kill SRConfig

    if (g_pSRConfig)
    {
        delete g_pSRConfig;
        g_pSRConfig = NULL;
    }

Err:    
    tleave();
    return;
}


DWORD 
CEventHandler::OnFreeze( LPWSTR pszDrive )
{
    tenter("CEventHandler::OnFreeze");
    
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    BOOL    fHaveLock;
    
    LOCKORLEAVE(fHaveLock);
    
    ASSERT(g_pDataStoreMgr);

    //
    // if drive is already frozen, no-op
    //
        
    if (g_pDataStoreMgr->IsDriveFrozen(pszDrive))
    {
        dwRc = ERROR_SUCCESS;
        goto done;
    }
        
    dwRc = g_pDataStoreMgr->FreezeDrive( pszDrive );
    if ( ERROR_SUCCESS != dwRc )
    {
        trace(0, "! g_pDataStoreMgr->FreezeDrive : %ld", dwRc);
    }

done:    
    UNLOCK( fHaveLock );
    tleave();
    return dwRc;
}


DWORD
CEventHandler::OnReset(LPWSTR pszDrive)
{
    tenter("CEventHandler::OnReset");
    BOOL    fHaveLock;
    DWORD   dwRc = ERROR_INTERNAL_ERROR;

    ASSERT(g_pSRConfig);

    LOCKORLEAVE(fHaveLock);
    
    g_pSRConfig->SetResetFlag(TRUE);
    
    dwRc = DisableSRS(pszDrive);  
    if (ERROR_SUCCESS != dwRc)
        goto done;    
    
    // if not system drive, enable this drive
    // else, the service will stop
    // and do a firstrun the next boot
    
    if (pszDrive && ! IsSystemDrive(pszDrive))
    {
        dwRc = EnableSRS(pszDrive);
    }
    
done:
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}



DWORD 
CEventHandler::OnFifo(
    LPWSTR  pszDrive, 
    DWORD   dwTargetRp, 
    int     nTargetPercent, 
    BOOL    fIncludeCurrentRp,
    BOOL    fFifoAtleastOneRp)
{
    tenter("CEventHandler::OnFifo");
    BOOL    fHaveLock;
    DWORD   dwRc = ERROR_INTERNAL_ERROR;

    LOCKORLEAVE(fHaveLock);
    
    ASSERT(g_pDataStoreMgr);

    dwRc = g_pDataStoreMgr->Fifo(pszDrive, dwTargetRp, nTargetPercent, fIncludeCurrentRp, fFifoAtleastOneRp);
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "! g_pDataStoreMgr->Fifo : %ld", dwRc);
    }

done:    
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}


DWORD 
CEventHandler::OnCompress(LPWSTR pszDrive)
{
    tenter("CEventHandler::OnCompress");
    BOOL    fHaveLock;
    DWORD   dwRc = ERROR_INTERNAL_ERROR;    
    
    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pDataStoreMgr && g_pSRConfig);
    
    dwRc = g_pDataStoreMgr->Compress(pszDrive, 
                                     g_pSRConfig->m_dwCompressionBurst);                                     
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! g_pDataStoreMgr->Compress : %ld", dwRc);
    }

done:
    UNLOCK(fHaveLock);
    tleave();    
    return dwRc;
}


DWORD 
CEventHandler::SRPrintStateS()
{
    tenter("CEventHandler::SRPrintStateS");
    BOOL    fHaveLock;
    DWORD   dwRc = ERROR_SUCCESS;    
	HANDLE 	hFile = INVALID_HANDLE_VALUE;
	WCHAR   wcsPath[MAX_PATH];
	
    LOCKORLEAVE(fHaveLock);

    ASSERT(g_pDataStoreMgr);    

	if (0 == ExpandEnvironmentStrings(L"%temp%\\sr.txt", wcsPath, MAX_PATH))
	{
        dwRc = GetLastError();
        trace(0, "! ExpandEnvironmentStrings : %ld", dwRc);
        goto done;
    }
    
    hFile = CreateFileW (wcsPath,   // file name
                         GENERIC_WRITE, // file access
                         0,             // share mode
                         NULL,          // SD
                         CREATE_ALWAYS, // how to create
                         0,             // file attributes
                         NULL);         // handle to template file

    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwRc = GetLastError();
        trace(0, "! CreateFileW : %ld", dwRc);
        goto done;
    }

    trace(0, "**** SR State ****");
    
    dwRc = g_pDataStoreMgr->GetDriveTable()->ForAllDrives(CDataStore::Print, (LONG_PTR) hFile);

    trace(0, "**** SR State ****");

done:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
		
	UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}


// timer 
// this needs to monitor datastore size and free disk space on all drives
// and trigger fifo/freeze if needed

DWORD
CEventHandler::OnTimer(
    LPVOID lpParam,
    BOOL   fTimeout)
{
    DWORD           dwRc = ERROR_SUCCESS;
    LPWSTR          pszDrive = NULL;
    DWORD           dwFlags;
    BOOL            fHaveLock;
    SDriveTableEnumContext dtec = {NULL, 0};        

    tenter("CEventHandler::OnTimer");

    // get the lock within 5 seconds
    // if we can't get the lock, then don't block 
    // we shall come back 2 minutes later and try again

    // the wait times are such that idle callback has a somewhat
    // higher priority than timer to get the lock

    LOCKORLEAVE_EX(fHaveLock, 5000);
    
    // got the lock - no one else is doing anything
    
    ASSERT(g_pDataStoreMgr && g_pSRConfig);    


    // trigger freeze or fifo on each drive 
    // this will :
    //      a. check free space and trigger freeze or fifo
    //      b. check datastore usage percent and trigger fifo
    
    g_pDataStoreMgr->TriggerFreezeOrFifo();
    
done:
    UNLOCK(fHaveLock);
    tleave();
    return dwRc;
}



// open filter handle and register ioctls

DWORD WINAPI
PostFilterIo(PVOID pNum)
{
    tenter("CEventHandler::SendIOCTLs");

    DWORD   dwRc = ERROR_SUCCESS;
    INT     index;

    ASSERT(g_pSRConfig && g_pEventHandler);

    // 
    // if shutting down, don't bother to post
    //
    
    if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
    {
        trace(0, "Stop signalled - not posting io requests");
        goto done;
    }

    //
    // bind the completion to a callback
    //
    
    if ( ! BindIoCompletionCallback(g_pSRConfig->GetFilter(),
                                    IoCompletionCallback,
                                    0) )
    {
        dwRc = GetLastError();
        trace(0, "! BindIoCompletionCallback : %ld", dwRc);
        goto done;
    }

    
    //
    // post io completion requests
    //
    
    for (index = 0; index < (INT_PTR) pNum; index++) 
    {
        CHAR  pszEventName[MAX_PATH];
        LPSR_OVERLAPPED pOverlap = NULL;
        DWORD nBytes =0 ;
            
        pOverlap = (LPSR_OVERLAPPED) SRMemAlloc( sizeof(SR_OVERLAPPED) );
        if (! pOverlap)
        {
            trace(0, "! Out of memory");
            dwRc = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        // create an event, a handle, and put it in the completion port.

        memset( &pOverlap->m_overlapped, 0, sizeof(OVERLAPPED) );

        pOverlap->m_dwRecordLength = sizeof(SR_NOTIFICATION_RECORD) 
                        + (SR_MAX_FILENAME_LENGTH*sizeof(WCHAR));

        pOverlap->m_pRecord = 
           (PSR_NOTIFICATION_RECORD) SRMemAlloc(pOverlap->m_dwRecordLength);

        ASSERT(g_pSRConfig);
        
        pOverlap->m_hDriver = g_pSRConfig->GetFilter();
    

        // post ioctl - this should return ERROR_IO_PENDING

        dwRc = SrWaitForNotification( pOverlap->m_hDriver,
                                      pOverlap->m_pRecord ,
                                      pOverlap->m_dwRecordLength,
                                      (LPOVERLAPPED) pOverlap );

        if ( dwRc != 0 && dwRc != ERROR_IO_PENDING )
        {
            trace(0, "! SrWaitForNotification : %ld", dwRc);
            goto done;
        }

        g_pEventHandler->GetCounter()->Up( );   // one more pending ioctl 
    }

    trace(0, "Filter Io posted");

done:
    tleave();
    return dwRc;
}


// FILTER NOTIFICATION HANDLERS

// generic notification handler

extern "C" void CALLBACK
IoCompletionCallback( 
    DWORD           dwErrorCode,
    DWORD           dwBytesTrns,
    LPOVERLAPPED    pOverlapped )
{
    ULONG           uError = 0;    
    LPSR_OVERLAPPED pSROverlapped = (LPSR_OVERLAPPED) pOverlapped;
    BOOL            fResubmit = FALSE;
    WCHAR           szVolumeGuid[MAX_PATH], szTemp[MAX_PATH];
    
    tenter("IoCompletionCallback");    
   
    if (! pSROverlapped || pSROverlapped->m_hDriver == INVALID_HANDLE_VALUE)
    {
        trace(0, "! Null overlapped or driver handle");
        goto done;
    }

    trace(0, "Received filter notification : errorcode=%08x, type=%08x", 
             dwErrorCode, pSROverlapped->m_pRecord->NotificationType);

    if ( dwErrorCode != 0 )  // we cancelled it
    {
        trace(0, "Cancelled operation");
        goto done;
    }


    UnicodeStringToWchar(pSROverlapped->m_pRecord->VolumeName, szTemp);     
    wsprintf(szVolumeGuid, L"\\\\?\\Volume%s\\", szTemp);

    
    // handle notification 

    ASSERT(g_pEventHandler);
    ASSERT(g_pSRConfig);    
    if (! g_pEventHandler || ! g_pSRConfig)
    {
        trace(0, "global is NULL");
        goto done;
    }
    
    switch( pSROverlapped->m_pRecord->NotificationType )
    {
    case SrNotificationVolumeFirstWrite:
        g_pEventHandler->OnFirstWrite_Notification(szVolumeGuid);
        break;

    case SrNotificationVolume25MbWritten:                                                    
        g_pEventHandler->OnSize_Notification(szVolumeGuid, 
                                             pSROverlapped->m_pRecord->Context);
        break;

    case SrNotificationVolumeError:
        g_pEventHandler->OnVolumeError_Notification(szVolumeGuid, 
                                                    pSROverlapped->m_pRecord->Context);
        break;

    default:
        trace(0, "Unknown notification");
        ASSERT(0);        
        break;
    }

    // check for stop signal

    ASSERT(g_pSRConfig);
    
    if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
        goto done;
       
    // re-submit the ioctl to the driver 

    memset( &pSROverlapped->m_overlapped, 0, sizeof(OVERLAPPED) );
    pSROverlapped->m_dwRecordLength = sizeof(SR_NOTIFICATION_RECORD)
                                      + (SR_MAX_FILENAME_LENGTH*sizeof(WCHAR));
    memset( pSROverlapped->m_pRecord, 0, pSROverlapped->m_dwRecordLength);
    pSROverlapped->m_hDriver = g_pSRConfig->GetFilter();

    uError = SrWaitForNotification( pSROverlapped->m_hDriver,
                                    pSROverlapped->m_pRecord ,
                                    pSROverlapped->m_dwRecordLength,
                                    (LPOVERLAPPED) pSROverlapped );

    if ( uError != 0 && uError != ERROR_IO_PENDING )
    {
        trace(0, "! SrWaitForNotification : %ld", uError);
        goto done;
    }

    fResubmit = TRUE;

done:
    // if we didn't resubmit, there is one less io request pending
    
    if (FALSE == fResubmit && g_pEventHandler != NULL)
        g_pEventHandler->GetCounter()->Down();

    tleave();
    return;
}


// first write notification handler
// this will be sent when the first monitored op happens on a new drive
// or a newly created restore point
// RESPONSE: update the drive table to indicate that this is a new drive
// and/or that this drive is a participant in this restore point

void
CEventHandler::OnFirstWrite_Notification(LPWSTR pszGuid)
{
    DWORD   dwRc = ERROR_SUCCESS;
    WCHAR   szMount[MAX_PATH];
    BOOL    fHaveLock;
    CDataStore *pdsNew = NULL, *pds=NULL;
    
    tenter("CEventHandler::OnFirstWrite_Notification");

    trace(0, "First write on %S", pszGuid);

    LOCKORLEAVE(fHaveLock);
    
    ASSERT(g_pDataStoreMgr);
    ASSERT(g_pSRConfig);
    
    dwRc = g_pDataStoreMgr->GetDriveTable()->FindMountPoint(pszGuid, szMount);
    if (ERROR_BAD_PATHNAME == dwRc)
    {        
        // the mountpoint path is too long for us to support
        // so disable the filter on this volume
        CDataStore ds(NULL);
        ds.LoadDataStore(NULL, pszGuid, NULL, 0, 0, 0);        
        dwRc = SrDisableVolume(g_pSRConfig->GetFilter(), ds.GetNTName());
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! SrDisableVolume : %ld", dwRc);
        }
        else
        {
            WCHAR wcsPath[MAX_PATH];
            MakeRestorePath (wcsPath, pszGuid, L"");

            // delete the restore directory
            dwRc = Delnode_Recurse (wcsPath, TRUE,
                                     g_pDataStoreMgr->GetStopFlag());
            if (dwRc != ERROR_SUCCESS)
            {
                trace(0, "! Delnode_Recurse : %ld", dwRc);
            }
            trace(0, "Mountpoint too long - disabled volume %S", pszGuid);
        }
        goto done;
    }        
        
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! FindMountPoint on %S : %ld", pszGuid, dwRc);
        goto done;
    }

    pdsNew = g_pDataStoreMgr->GetDriveTable()->FindDriveInTable(pszGuid);

    dwRc = g_pDataStoreMgr->GetDriveTable()->AddDriveToTable(szMount, pszGuid);
    if (ERROR_SUCCESS != dwRc)
    {
        trace(0, "! AddDriveToTable on %S", pszGuid);
        goto done;
    }

    if (ERROR_SUCCESS != g_pDataStoreMgr->SetDriveParticipation (pszGuid, TRUE))
        trace(0, "! SetDriveParticipation on %S", pszGuid);


    //    
    // if less than 50mb free, or if SR is already frozen, then freeze 
    //
    
    pds = g_pDataStoreMgr->GetDriveTable()->FindDriveInTable(pszGuid);
    if (pds)
    {
        // update the active bit too
        pds->SetActive(TRUE);

        // then check diskfree 
        pds->UpdateDiskFree(NULL);
        if ( (pds->GetDiskFree() <= THRESHOLD_FREEZE_DISKSPACE * MEGABYTE) ||
             (g_pDataStoreMgr->IsDriveFrozen(g_pSRConfig->GetSystemDrive())) )
        {
            g_pDataStoreMgr->FreezeDrive(pszGuid);
        }
    }        
    else
    {
        //
        // we just added the drive, so should never get here
        //
        
        ASSERT(0);
    }

done:
    UNLOCK(fHaveLock);
    tleave();
    return;
}


// 25MB notification handler
// this will be sent when the filter has copied 25MB of data to the datastore
// on some drive 
// RESPONSE: update the datastore size and check fifo conditions

void
CEventHandler::OnSize_Notification(LPWSTR pszGuid, ULONG ulRp)
{
    tenter("CEventHandler::OnSize_Notification");

    int             nPercent = 0;
    BOOL            fHaveLock;
    DWORD           dwRc = ERROR_SUCCESS;

    LOCKORLEAVE(fHaveLock);

    trace(0, "25mb copied on drive %S", pszGuid);
    trace(0, "for RP%ld", ulRp);
    
    if ((DWORD) ulRp != m_CurRp.GetNum())
    {
        trace(0, "This is an obsolete notification");
        goto done;
    }
    
    ASSERT(g_pDataStoreMgr);
    
    g_pDataStoreMgr->UpdateDataStoreUsage(pszGuid, SR_NOTIFY_BYTE_COUNT);

    if ( ERROR_SUCCESS == g_pDataStoreMgr->GetUsagePercent(pszGuid, &nPercent)
         && nPercent >= THRESHOLD_FIFO_PERCENT )
    {
        OnFifo(pszGuid, 
               0,                       // no target rp
               TARGET_FIFO_PERCENT,     // target percent
               TRUE,                    // fifo current rp if necessary (freeze)
               FALSE);                  
    }

done:
    UNLOCK(fHaveLock);    
    tleave();
    return;
}


// disk full notification handler
// this will be sent when the filter encounters an error on a volume
// ideally, this should never be sent 
// if diskfull, freeze SR on this drive
// else disable SR on this drive 

void
CEventHandler::OnVolumeError_Notification(LPWSTR pszGuid, ULONG ulError)
{
    tenter("CEventHandler::OnVolumeError_Notification");
    BOOL    fHaveLock;
    DWORD   dwRc = ERROR_SUCCESS;
    
    LOCKORLEAVE(fHaveLock);
    
    trace(0, "Volume Error on %S", pszGuid);
    trace(0, "Error : %ld", ulError);

    ASSERT(g_pDataStoreMgr);
    ASSERT(g_pSRConfig);

    if (ulError == ERROR_DISK_FULL)
    {      
        // no more disk space - freeze
        // NOTE: we don't check to see if the drive is already
        // frozen here. If for some reason we are out of sync with
        // the driver, this will fix it
        
        g_pDataStoreMgr->FreezeDrive(pszGuid);
    }
    else
    {
        // fifo all restore points prior to the current one

        dwRc = g_pDataStoreMgr->Fifo(g_pSRConfig->GetSystemDrive(), 0, 0, FALSE, FALSE);
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! Fifo : %ld", dwRc);
        }

        // make the current rp a cancelled rp 
        // so that UI will not display it
        
        if (! m_fNoRpOnSystem)
        {
            SRRemoveRestorePointS(m_CurRp.GetNum()); 
            // m_CurRp.Cancel();
        }
        
        // log the error in the drivetable
        
        dwRc = g_pDataStoreMgr->SetDriveError(pszGuid);
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! SetDriveError : %ld", dwRc);
        }
    }

done:
    UNLOCK(fHaveLock);
    tleave();
    return;
}


// disk space notifications sent by the shell

DWORD WINAPI
OnDiskFree_200(PVOID pszDrive)
{
    // thaw

    ASSERT(g_pEventHandler);   
    
    (g_pEventHandler->GetCounter())->Down();

    return 0;
}


DWORD WINAPI
OnDiskFree_80(PVOID pszDrive)
{
    // fifo
    
    ASSERT(g_pEventHandler);
    
    g_pEventHandler->OnFifo((LPWSTR) pszDrive, 
                            0,                      // no target rp
                            TARGET_FIFO_PERCENT,    // target percent
                            TRUE,                   // fifo current rp if necessary (freeze)
                            TRUE);                  // fifo atleast one restore point
                            
    (g_pEventHandler->GetCounter())->Down();

    return 0;
}

DWORD WINAPI 
OnDiskFree_50(PVOID pszDrive)
{
    TENTER("OnDiskFree_50");
   
    DWORD dwRc = ERROR_SUCCESS;
 
    // freeze

    ASSERT(g_pEventHandler);
    ASSERT(g_pDataStoreMgr);

    //
    // check if there is some rp directory
    // if none, then don't bother 
    //

    CRestorePointEnum *prpe = new CRestorePointEnum((LPWSTR) pszDrive, FALSE, FALSE);  // backward, include current
    CRestorePoint     *prp = new CRestorePoint;


    if (!prpe || !prp)
    {
        trace(0, "Cannot allocate memory for restore point enum");
        goto done;
    }
    
    dwRc = prpe->FindFirstRestorePoint(*prp);
    if (dwRc == ERROR_SUCCESS || dwRc == ERROR_FILE_NOT_FOUND)
    {            
        g_pEventHandler->OnFreeze((LPWSTR) pszDrive);
    }   
    else
    {
        trace(0, "Nothing in datastore -- so not freezing");
    }

    if (prpe)
        delete prpe;
    if (prp)
        delete prp;

    (g_pEventHandler->GetCounter())->Down();

done:    
    TLEAVE();
    return 0;
}



// stop event management

void
CEventHandler::SignalStop()
{
    if ( g_pSRConfig ) 
    {
        SetEvent( g_pSRConfig->m_hSRStopEvent );
    }
}



DWORD
CEventHandler::WaitForStop()
{
    if ( g_pSRConfig )
    {
        WaitForSingleObject( g_pSRConfig->m_hSRStopEvent, INFINITE );
        return g_pSRConfig->GetResetFlag() ? ERROR_NO_SHUTDOWN_IN_PROGRESS : ERROR_SHUTDOWN_IN_PROGRESS;
    }
    else
        return ERROR_INTERNAL_ERROR;    
}


//
// perform idle tasks
// 
DWORD
CEventHandler::OnIdle()
{
    DWORD   dwThawStatus = ERROR_NO_MORE_ITEMS;
    DWORD   dwRc = ERROR_NO_MORE_ITEMS;
    BOOL    fCreateAuto = FALSE;
    ULARGE_INTEGER *pulFreeze = NULL;
    
    tenter("CEventHandler::OnIdle");

    trace(0, "Idleness detected");

    ASSERT(g_pSRConfig);
    ASSERT(g_pDataStoreMgr);

    // 
    // check thaw timer to see if
    // there are frozen drives
    //

    pulFreeze = (ULARGE_INTEGER *) &m_ftFreeze;
    if (pulFreeze->QuadPart != 0)
    {
        FILETIME        ftNow;
        ULARGE_INTEGER  *pulNow;
        
        GetSystemTimeAsFileTime(&ftNow);
        pulNow = (ULARGE_INTEGER *) &ftNow;

        // 
        // if more than 15 minutes since freeze happened 
        // try to thaw
        //
        
        if (pulNow->QuadPart - pulFreeze->QuadPart >= 
            ((INT64) g_pSRConfig->m_dwThawInterval * 1000 * 1000 * 10))
        {           
            dwThawStatus = g_pDataStoreMgr->ThawDrives(TRUE);    
            if (dwThawStatus != ERROR_SUCCESS)
            {
                trace(0, "Cannot thaw drives yet");
            }        
        }
    }
    else
    {
        fCreateAuto = IsTimeForAutoRp();
    }


    // make periodic checkpoint if it is time to make an auto-rp or 
    // time to thaw drives or
    // a volume error happened in the previous session
    
    if ( dwThawStatus == ERROR_SUCCESS ||
         fCreateAuto == TRUE ||
         m_fCreateRpASAP == TRUE )
    {        
        RESTOREPOINTINFO RPInfo;
        STATEMGRSTATUS   SmgrStatus;

        RPInfo.dwEventType = BEGIN_SYSTEM_CHANGE; 
        RPInfo.dwRestorePtType = m_fNoRpOnSystem ? FIRSTRUN : CHECKPOINT;
        if (ERROR_SUCCESS != SRLoadString(L"srrstr.dll", IDS_SYSTEM_CHECKPOINT_TEXT, RPInfo.szDescription, MAX_PATH))
        {
            lstrcpy(RPInfo.szDescription, s_cszSystemCheckpointName);
        }
        SRSetRestorePointS(&RPInfo, &SmgrStatus);

        dwRc = SmgrStatus.nStatus;         
        if (dwRc != ERROR_SUCCESS)
            goto done;      

        m_fCreateRpASAP = FALSE;
        
        // we made a restore point and perhaps thawed some drives
        // let's not push it any further
        // compress on next idle opportunity
    }
    else
    {   
        // if system is running on battery
        // skip these tasks

        if (g_pSRConfig->IsSystemOnBattery())
        {
            trace(0, "System on battery -- skipping idle tasks");
            goto done;
        }
                        
        // fifo restore points older than a specified age
        // if the fifo age is set to 0, that means this feature
        // is turned off
        
        if (g_pSRConfig->m_dwRPLifeInterval > 0)
        {
            g_pDataStoreMgr->FifoOldRps(g_pSRConfig->m_dwRPLifeInterval);
        }
        
        // compress backed up files - pick any drive
        
        dwRc = OnCompress( NULL );

        //
        // if we have more to compress, request idle again
        //
        
        if (dwRc == ERROR_OPERATION_ABORTED)
        {
            SetEvent(g_pSRConfig->m_hIdleRequestEvent);        
        }            
    }

done:        
    tleave();
    return dwRc;
}


extern "C" void CALLBACK
IdleRequestCallback(PVOID pContext, BOOLEAN fTimerFired)
{
    BOOL    fRegistered = FALSE;
    HANDLE  *pWaitHandle = NULL;
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fHaveLock = FALSE;

    tenter("CEventHandler::IdleRequestCallback");
    
    ASSERT(g_pEventHandler);
    ASSERT(g_pSRConfig);

    if (g_pEventHandler == NULL || g_pSRConfig == NULL)
    {
        trace(0, "global is Null");
        goto Err;
    }
    
    fHaveLock = g_pEventHandler->GetLock()->Lock(CLock::TIMEOUT);
    if (! fHaveLock)
    {
        trace(0, "Cannot get lock");
        goto Err;
    }
    
    // 
    // first off, if the stop event is triggered
    // and we are here for some reason,
    // bail blindly
    // 
    
    if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
    {
        trace(0, "Stop event signalled - bailing out of idle");
        goto Err;
    }
    
    //
    // idleness is requested or timer fired
    // re-register for idle again
    //
    
    if (fTimerFired)
        trace(0, "Timed out");
    else
        trace(0, "Idle request event received");
    
    // 
    // if already registered for idle
    // then do nothing
    //

    if (g_pEventHandler->m_hIdleStartHandle != NULL)
    {
        trace(0, "Already registered for idle");
        goto Err;
    }
   
    dwErr = RegisterIdleTask(ItSystemRestoreIdleTaskId,
                             &(g_pSRConfig->m_hIdle),
                             &(g_pSRConfig->m_hIdleStartEvent),
                             &(g_pSRConfig->m_hIdleStopEvent));                             
    if (dwErr != ERROR_SUCCESS) 
    {
        trace(0, "! RegisterIdleTask : %ld", dwErr);
    }
    else
    {
        trace(0, "Registered for idle");        

        //
        // register idle callback
        //
        if (FALSE == RegisterWaitForSingleObject(&g_pEventHandler->m_hIdleStartHandle, 
                                                 g_pSRConfig->m_hIdleStartEvent,
                                                 (WAITORTIMERCALLBACK) IdleStartCallback,
                                                 NULL,
                                                 INFINITE,
                                                 WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
        {
            dwErr = GetLastError();
            trace(0, "! RegisterWaitForSingleObject for startidle: %ld", dwErr);
            goto Err;
        }           
        
        if (FALSE == RegisterWaitForSingleObject(&g_pEventHandler->m_hIdleStopHandle, 
                                                 g_pSRConfig->m_hIdleStopEvent,
                                                 (WAITORTIMERCALLBACK) IdleStopCallback,
                                                 NULL,
                                                 INFINITE,
                                                 WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
        {
            dwErr = GetLastError();
            trace(0, "! RegisterWaitForSingleObject for stopidle: %ld", dwErr);
            goto Err;
        }                   
    }            


Err:
    if (g_pEventHandler)
    {
        if (fHaveLock) 
            g_pEventHandler->GetLock()->Unlock(); 
    }
    
    return;
}



extern "C" void CALLBACK
IdleStartCallback(PVOID pContext, BOOLEAN fTimerFired)
{
    DWORD  dwErr = ERROR_SUCCESS;
    BOOL   fHaveLock = FALSE;
    
    tenter("CEventHandler::IdleStartCallback");
    
    ASSERT(g_pEventHandler);
    ASSERT(g_pSRConfig);

    if (g_pEventHandler == NULL || g_pSRConfig == NULL)
    {
        trace(0, "global is Null");
        goto Err;
    }

    fHaveLock = g_pEventHandler->GetLock()->Lock(CLock::TIMEOUT);
    if (! fHaveLock)
    {
        trace(0, "Cannot get lock");
        goto Err;
    }
    
    // 
    // first off, if the stop event is triggered
    // and we are here for some reason,
    // bail blindly
    // 
    
    if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
    {
        trace(0, "Stop event signalled - bailing out of idle");
        goto Err;
    }
    
    //
    // idleness occurred
    //
    
    trace(0, "fTimerFired = %d", fTimerFired);
    
    g_pEventHandler->OnIdle();
    
    dwErr = UnregisterIdleTask(g_pSRConfig->m_hIdle,
                               g_pSRConfig->m_hIdleStartEvent,
                               g_pSRConfig->m_hIdleStopEvent);                             
    if (dwErr != ERROR_SUCCESS) 
    {
        trace(0, "! UnregisterIdleTask : %ld", dwErr);
    }         
    else
    {
        trace(0, "Unregistered from idle");
    }

    //
    // we are done - record this
    // since we registered for this callback only once,
    // we don't have to call UnregisterWait on this handle -
    // or so I hope
    //
    
    g_pEventHandler->m_hIdleStartHandle = NULL;
    
Err:
    if (g_pEventHandler)
    {
        if (fHaveLock) 
            g_pEventHandler->GetLock()->Unlock();
    }
    return;
}


extern "C" void CALLBACK
IdleStopCallback(PVOID pContext, BOOLEAN fTimerFired)
{
    tenter("IdleStopCallback");

    BOOL   fHaveLock = FALSE;    
    
    if (g_pEventHandler == NULL)
    {
        trace(0, "global is Null");
        goto Err;
    }

    fHaveLock = g_pEventHandler->GetLock()->Lock(CLock::TIMEOUT);
    if (! fHaveLock)
    {
        trace(0, "Cannot get lock");
        goto Err;
    }
    
    trace(0, "Idle Stop event signalled");

    g_pEventHandler->m_hIdleStopHandle = NULL;

Err:
    if (g_pEventHandler)
    {
        if (fHaveLock) 
            g_pEventHandler->GetLock()->Unlock();
    }
    tleave();
}


// set up timer 

DWORD
CEventHandler::InitTimer()
{
    DWORD dwRc = ERROR_SUCCESS;

    tenter("CEventHandler::InitTimer");

    ASSERT(g_pSRConfig);

    //
    // if the timer interval is specified as 0,
    // then don't create timer
    //
    
    if (g_pSRConfig->m_dwTimerInterval == 0)
    {
        trace(0, "Not starting timer");
        goto done;
    }
    
    m_hTimerQueue = CreateTimerQueue();
    if (! m_hTimerQueue)
    {
        dwRc = GetLastError();
        trace(0, " ! CreateTimerQueue : %ld", dwRc);
        goto done;
    }
    
    if (FALSE == CreateTimerQueueTimer(&m_hTimer,
                                       m_hTimerQueue,
                                       TimerCallback,
                                       NULL,
                                       g_pSRConfig->m_dwTimerInterval * 1000,     // milliseconds
                                       g_pSRConfig->m_dwTimerInterval * 1000,     // periodic
                                       WT_EXECUTEINIOTHREAD))
    {
        dwRc = GetLastError();
        trace(0, "! CreateTimerQueueTimer : %ld", dwRc);
        goto done;
    }

    trace(0, "SRBoottask: Timer started");
    
done:
    tleave();
    return dwRc;
}


// end timer

BOOL 
CEventHandler::EndTimer()
{
    DWORD dwRc;
    BOOL  fRc = TRUE;
    
    tenter("CEventHandler::EndTimer");

    if ( ! m_hTimerQueue )
    {
        trace(0 , "! m_hTimerQueue = NULL");
        goto done;
    }

    // delete timer queue should wait for current timer tasks to end
    
    if (FALSE == (fRc = DeleteTimerQueueEx( m_hTimerQueue, INVALID_HANDLE_VALUE )))
    {
        trace(0, "! DeleteTimerQueueEx : %ld", GetLastError());
    }

    m_hTimerQueue = NULL;
    m_hTimer = NULL;

done:
    tleave( );
    return fRc;
}


BOOL
CEventHandler::IsTimeForAutoRp()
{
    tenter("CEventHandler::IsTimeForAutoRp");

    FILETIME       *pftRp, ftNow;
    ULARGE_INTEGER *pulRp, *pulNow;
    BOOL           fRc = FALSE;
    INT64          llInterval, llSession;

    ASSERT(g_pSRConfig && g_pDataStoreMgr);

    if (m_fNoRpOnSystem)
    {
        // if SR is frozen, we will create a restore point via the thaw codepath in OnIdle
        // we will get here ONLY if we get idle time before we have created the firstrun checkpoint -
        // we won't create an idle checkpoint before the firstrun checkpoint if we have a Run key waiting
        // to create one
        
        HKEY hKey;
        DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, 
                                 L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 
                                 &hKey);
        if (dwRet == ERROR_SUCCESS)
        {
            dwRet = RegQueryValueEx(hKey, L"SRFirstRun", NULL, NULL, NULL, NULL);
            RegCloseKey(hKey);
        }

        if (dwRet == ERROR_SUCCESS)
        {
            trace(0, "Run entry exists to create firstrun checkpoint - not creating idle checkpoint");
            fRc = FALSE;
            goto done;
        }
        else
        {
            fRc = TRUE;
            goto done;
        }
    }

    // get the last restore point creation time and the current time
    
    pftRp = m_CurRp.GetTime();
    GetSystemTimeAsFileTime(&ftNow);
    
    pulRp = (ULARGE_INTEGER *) pftRp;
    pulNow = (ULARGE_INTEGER *) &ftNow;
       
    
    // check the last restore point time with current time
    // if the difference is greater than GlobalInterval, it's time to make a new one
    // all comparisions in filetime units - i.e. 100's of nanoseconds

    // if GlobalInterval is 0, this is turned off
    
    llInterval = (INT64) g_pSRConfig->m_dwRPGlobalInterval * 10 * 1000 * 1000;
    if ( llInterval > 0 && 
         pulNow->QuadPart - pulRp->QuadPart >= llInterval )
    {
        trace(0, "24 hrs elapsed since last restore point");
        fRc = TRUE;
        goto done;
    }

    // if the last restore point was more than 10hrs ago, 
    // and the current session began more than 10hrs ago,
    // then we haven't made a restore point for the last 10hrs in the current session
    // again, it's time to make a new one
    // this will ensure that we keep making checkpoints every 10hrs of session time, 
    // idleness permitting

    // if SessionInterval is 0, this is turned off

    // if system is on battery, skip creating session rp
    
    if (g_pSRConfig->IsSystemOnBattery())
    {
        trace(0, "System on battery -- skipping session rp check");
        goto done;
    }
    
    llSession = (INT64) GetTickCount() * 10 * 1000;        
    llInterval = (INT64) g_pSRConfig->m_dwRPSessionInterval * 10 * 1000 * 1000;
    if ( llInterval > 0 && 
         llSession >= llInterval  &&
         pulNow->QuadPart - pulRp->QuadPart >= llInterval ) 
    {
        trace(0, "10 hrs elapsed in current session since last restore point");
        fRc = TRUE;
        goto done;
    }
    
    // if we reach here, no restore point needs to be created now
    // fRc is already FALSE

done:
    tleave();
    return fRc;
}


void
CEventHandler::RefreshCurrentRp(BOOL fScanAllDrives)
{    
    tenter("CEventHandler::RefreshCurrentRp");

    DWORD                   dwErr;
    SDriveTableEnumContext  dtec = {NULL, 0};
    CDataStore              *pds = NULL;
    
    ASSERT(g_pSRConfig && g_pDataStoreMgr);

    //
    // get the most recent valid restore point
    // cancelled restore points are considered valid as well
    // if rp.log is missing, we will enumerate back up to the point where it exists
    // and consider that the most recent restore point
    //
    
    CRestorePointEnum *prpe = new CRestorePointEnum(g_pSRConfig->GetSystemDrive(), FALSE, FALSE);
    if (!prpe)
    {
        trace(0, "Cannot allocate memory for restore point enum");
        goto done;
    }
    
    dwErr = prpe->FindFirstRestorePoint(m_CurRp);       
    while (dwErr == ERROR_FILE_NOT_FOUND)
    {
        fScanAllDrives = FALSE;
        dwErr = prpe->FindNextRestorePoint(m_CurRp);
    }
    
    if (dwErr == ERROR_SUCCESS)
    {
        trace(0, "Current Restore Point: %S", m_CurRp.GetDir());
        m_fNoRpOnSystem = FALSE;

        // update the participate bits on each datastore -
        // we need to do this every time we come up
        // because we might have missed filter firstwrite
        // notifications
        
        if (fScanAllDrives)
        {
            dwErr = g_pDataStoreMgr->UpdateDriveParticipation(NULL, m_CurRp.GetDir());            
            if (dwErr != ERROR_SUCCESS)
            {
                trace(0, "UpdateDriveParticipation : %ld", dwErr);
            }
        }
    }        
    else
    {
        trace(0, "No live restore points on system");
        m_fNoRpOnSystem = TRUE;
    }

    //
    // if any drive is newly frozen,
    // record freeze time
    //
    
    if (m_ftFreeze.dwLowDateTime == 0 && 
        m_ftFreeze.dwHighDateTime == 0 &&
        g_pDataStoreMgr->IsDriveFrozen(NULL))
    {
        GetSystemTimeAsFileTime(&m_ftFreeze);
    }
    else    // not frozen
    {
        m_ftFreeze.dwLowDateTime = 0;
        m_ftFreeze.dwHighDateTime = 0;
    }

    prpe->FindClose ();   
    delete prpe;

done:    
    tleave();
}


// queue a work item to a thread from the thread pool
// keep a count of all such queued items

DWORD
CEventHandler::QueueWorkItem(WORKITEMFUNC pFunc, PVOID pv)
{
    m_Counter.Up();
    if (! QueueUserWorkItem(pFunc, pv, WT_EXECUTELONGFUNCTION))
        m_Counter.Down();
            
    return GetLastError();
}


// CALLBACK functions
// calls through to eventhandler methods

// timer

extern "C" void CALLBACK 
TimerCallback(
    PVOID    lpParam,
    BOOLEAN  fTimeout)
{
    if ( g_pEventHandler )
        g_pEventHandler->OnTimer( lpParam, fTimeout );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\ntservice.h ===
// ntservice.h
//
// Definitions for CNTService
//

#ifndef _NTSERVICE_H_
#define _NTSERVICE_H_


#define SERVICE_CONTROL_USER 128

class CNTService
{
public:
    CNTService();
    ~CNTService();

    void LogEvent(WORD wType, DWORD dwID,
                  void * pRawData = NULL,
                  DWORD dwDataSize = 0,
                  const WCHAR* pszS1 = NULL,
                  const WCHAR* pszS2 = NULL,
                  const WCHAR* pszS3 = NULL);
    
    void SetStatus(DWORD dwState);
    void Run();
    
    void OnStop();
    void OnShutdown();
    void OnInterrogate();
    
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);

    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_Status;

private:
    HANDLE m_hEventSource;

};

extern CNTService * g_pSRService;

void WINAPI SRServiceHandler(DWORD dwOpcode);


#endif // _NTSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\counter.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    counter.h
 *
 *  Abstract:
 *    simple counter class - up/down counter, wait till zero
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  05/02/2000
 *        created
 *
 *****************************************************************************/

#ifndef _COUNTER_H_
#define _COUNTER_H_

#include <windows.h>

#define INLINE_EXPORT_SPEC __declspec( dllexport)

class INLINE_EXPORT_SPEC CCounter
{
private:
    HANDLE              _hEvent;
    LONG                _lCount;

public:
    CCounter( )
    {
        _lCount = 0;
        _hEvent = NULL;
    }

    DWORD Init ()
    {
        _hEvent = CreateEvent ( NULL, TRUE, TRUE, L"SRCounter" );
        return _hEvent == NULL ? GetLastError() : ERROR_SUCCESS;
    }

    ~CCounter( )
    {
        if ( _hEvent != NULL )
            CloseHandle( _hEvent );
    }

    void Up( )
    {    
        if (InterlockedIncrement (&_lCount) == 1)
        {
            if (_hEvent != NULL)
            	ResetEvent ( _hEvent );
        }     
    }

    DWORD Down( )
    {	
        if ( InterlockedDecrement(&_lCount) == 0 )
        {
            if (_hEvent != NULL && FALSE == SetEvent ( _hEvent ))
            {
                return GetLastError();
            }
        }       
        return ERROR_SUCCESS;
    }

    DWORD WaitForZero( )
    {    
        if (_hEvent != NULL)
        {
         	return WaitForSingleObject( _hEvent, 10 * 60000 );  /* 10 minutes */
        }
        else
           return ERROR_INTERNAL_ERROR;
    }

    LONG GetCount( )
    {
        return _lCount;
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#include <srapi.h>


#include "srdefs.h"
#include "ntservice.h"
#include "flstructs.h"
#include "flbuilder.h"
#include "utils.h"
#include "srrestoreptapi.h"

// use the _ASSERT and _VERIFY in dbgtrace.h
#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef _VERIFY
#undef _VERIFY
#endif

#include <dbgtrace.h>

#include "datastormgr.h"
#include "srconfig.h"
#include "srrpcs.h"
#include "counter.h"
#include "evthandler.h"
#include "snapshot.h"
#include <accctrl.h>

#include "idletask.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\rpcapi.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    rpcapi.cpp
 *
 *  Abstract:
 *    callthroughs for server-side rpc api 
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/13/2000
 *        created
 *
 *****************************************************************************/

#include "precomp.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

BOOL CallerIsAdminOrSystem ()
{
    BOOL fAdminOrSystem = FALSE;

    if (RPC_S_OK == RpcImpersonateClient (NULL))
    {
        fAdminOrSystem = IsAdminOrSystem();

        RpcRevertToSelf();
    }
    return fAdminOrSystem;
};

BOOL CallerIsAdminOrSystemOrPowerUsers()
{
    BOOL fPowerUsers = FALSE;

    if (RPC_S_OK == RpcImpersonateClient (NULL))
    {
        fPowerUsers = IsAdminOrSystem() || IsPowerUsers();

        RpcRevertToSelf();
    }
    return fPowerUsers;
}

extern "C" DWORD DisableSRS(handle_t hif, LPCWSTR pszDrive)
{
    tenter ("DisableSRS");

    if (!CallerIsAdminOrSystem())
    {
        trace (0, "DisableSRS Caller is not admin nor system");
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->DisableSRS((LPWSTR) pszDrive) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD EnableSRS(handle_t hif, LPCWSTR pszDrive)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->EnableSRS((LPWSTR) pszDrive) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD ResetSRS(handle_t hif, LPCWSTR pszDrive)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->OnReset((LPWSTR) pszDrive) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD DisableFIFOS(handle_t hif, DWORD dwRPNum)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->DisableFIFOS(dwRPNum) : ERROR_SERVICE_DISABLED;
}

extern "C" BOOL SRSetRestorePointS(
    handle_t hif,    
    PRESTOREPOINTINFOW pRPInfo,  
    PSTATEMGRSTATUS    pSMgrStatus)
{
    tenter("SRSetRestorePointS");

    if (pRPInfo == NULL || pRPInfo->dwRestorePtType != FIRSTRUN)
    {
        if (!CallerIsAdminOrSystemOrPowerUsers())
        {
            trace (0, "SRSetRestorePointS caller is not admin nor system nor powerusers");
            if (pSMgrStatus != NULL)
            {
                pSMgrStatus->nStatus = ERROR_ACCESS_DENIED;
                pSMgrStatus->llSequenceNumber = 0;
            }
            return FALSE;
        }
    }

    return g_pEventHandler ? g_pEventHandler->SRSetRestorePointS(pRPInfo, pSMgrStatus) : FALSE;
}

extern "C" DWORD SRRemoveRestorePointS(
    handle_t hif,    
    DWORD dwRPNum)
{
    tenter("SRRemoveRestorePointS");

    if (!CallerIsAdminOrSystemOrPowerUsers())
    {
        trace (0, "SRSetRestorePointS caller is not admin nor system nor powerusers");
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->SRRemoveRestorePointS(dwRPNum) : ERROR_SERVICE_DISABLED;
}


extern "C" DWORD EnableFIFOS(handle_t hif)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->EnableFIFOS() : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD SRUpdateMonitoredListS(handle_t hif, LPCWSTR pszXMLFile)    
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->SRUpdateMonitoredListS((LPWSTR) pszXMLFile) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD SRUpdateDSSizeS(handle_t hif, LPCWSTR pszDrive, UINT64 ullSizeLimit)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->SRUpdateDSSizeS((LPWSTR) pszDrive, ullSizeLimit) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD SRSwitchLogS(handle_t hif)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->SRSwitchLogS() : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD FifoS(handle_t hif, LPCWSTR pszDrive, DWORD dwTargetRp, int nPercent, BOOL fIncludeCurrentRp, BOOL fFifoAtleastOneRp)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->OnFifo((LPWSTR) pszDrive,
                                                     dwTargetRp,
                                                     nPercent,
                                                     fIncludeCurrentRp,
                                                     fFifoAtleastOneRp) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD CompressS(handle_t hif, LPCWSTR pszDrive)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->OnCompress((LPWSTR) pszDrive) : ERROR_SERVICE_DISABLED;
}

extern "C" DWORD FreezeS(handle_t hif, LPCWSTR pszDrive)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->OnFreeze((LPWSTR) pszDrive) : ERROR_SERVICE_DISABLED;
}


// fImproving - TRUE means going up
//				FALSE means going down

extern "C" void SRNotifyS(handle_t hif, LPCWSTR pszDrive, DWORD dwFreeSpaceInMB, BOOL fImproving)
{
    tenter("SRNotifyS");

    trace(0, "**Shell : drive = %S, dwFreeSpaceInMB = %ld, fImproving = %d",
             pszDrive, dwFreeSpaceInMB, fImproving);

    if (!CallerIsAdminOrSystem())
    {
        trace(0, "SRNotifyS caller is not admin nor system");
        return;
    }
    
    WORKITEMFUNC pf = NULL;
    
    if (g_pEventHandler)
    {
        if (dwFreeSpaceInMB >= 200 && fImproving == TRUE)
        {
            pf = OnDiskFree_200;
        }
        else if (dwFreeSpaceInMB <= 49 && fImproving == FALSE)
        {
            pf = OnDiskFree_50;
        }
        else if (dwFreeSpaceInMB <= 79 && fImproving == FALSE)
        {
            pf = OnDiskFree_80;
        }

        if (pf != NULL)
        {
            g_pEventHandler->QueueWorkItem(pf, (PVOID) pszDrive);
        }
    }
}


extern "C" DWORD SRPrintStateS(handle_t hif)
{
    if (!CallerIsAdminOrSystem())
    {
        return ERROR_ACCESS_DENIED;
    }

    return g_pEventHandler ? g_pEventHandler->SRPrintStateS() : ERROR_SERVICE_DISABLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\ntservice.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    NTService.cpp
 *
 *  Abstract:
 *    This file contains the implementation of CNTService class.
 *
 *  Revision History:
 *    Ashish Sikka  ( ashishs )  05/08/2000
 *        created
 *****************************************************************************/

#include "precomp.h"

#include "ntservmsg.h"    // generated from the MC message compiler

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#define TRACEID  8970

CNTService * g_pSRService=NULL; 

#define SERVICE_WAIT_HINT  30     // seconds


extern "C" void CALLBACK
StopCallback(
    PVOID   pv,
    BOOLEAN TimerOrWaitFired);

    
//
// static variables
//


CNTService::CNTService() 
{
    TraceFunctEnter("CNTService:CNTService");
    
    m_hEventSource = NULL;

    //
    // Set up the initial service status 
    //

    m_hServiceStatus = NULL;
    m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_Status.dwCurrentState = SERVICE_START_PENDING;
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_SHUTDOWN;
    m_Status.dwWin32ExitCode = 0;
    m_Status.dwServiceSpecificExitCode = 0;
    m_Status.dwCheckPoint = 0;
    m_Status.dwWaitHint = 0;
    
    TraceFunctLeave();
    
}

CNTService::~CNTService()
{
    TENTER("CNTService::~CNTService");

    if (m_hEventSource) 
    {
        ::DeregisterEventSource(m_hEventSource);
    }

    TLEAVE();
}


//
// Logging functions
//

void CNTService::LogEvent(
    WORD wType, DWORD dwID,
    void * pRawData,
    DWORD dwDataSize,
    const WCHAR* pszS1,
    const WCHAR* pszS2,
    const WCHAR* pszS3)
{
    TraceFunctEnter("CNTService::LogEvent");
    
    //
    // Check the event source has been registered and if
    // not then register it now
    //

    if (!m_hEventSource) 
    {
        m_hEventSource = ::RegisterEventSource(NULL, s_cszServiceName);
    }

    SRLogEvent (m_hEventSource, wType, dwID, pRawData,
                dwDataSize, pszS1, pszS2, pszS3);

    TraceFunctLeave();
}




//
// ServiceMain 
//
//This function immediately reports the service as having started.
//However, all the initialization is done after the service is
//started.  We chose to do this becuase this service may have a long
//initialization time and it may be tricky to keep giving hints to the
//SCM during this time. Also, the service does all the work itself and
//does not service any clients. So it is OK to do initialization after
//the service is reported to be started.
void CNTService::ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    DWORD  dwRc = ERROR_SUCCESS;
    HANDLE  hSRStopWait = NULL;
    
    TENTER("CNTService::ServiceMain()");

    // Register the control request handler

    m_hServiceStatus = RegisterServiceCtrlHandler(s_cszServiceName,
                                                  SRServiceHandler);

    if (m_hServiceStatus != NULL) 
    {
        HKEY    hKey = NULL;
        DWORD   dwBreak = 0;

/*        
         // tell the service manager that we are starting
         // Also inform the Controls accepted
        m_Status.dwCheckPoint = 0;
        m_Status.dwWaitHint = SERVICE_WAIT_HINT*1000;
        SetStatus(SERVICE_START_PENDING);
*/
        //
        // Tell the service manager we are running
        //

        m_Status.dwCheckPoint = 0;
        m_Status.dwWaitHint = 0;        
        SetStatus(SERVICE_RUNNING);

        
        // break into debugger if need to debug
        // this is controlled by setting regkey SRService\DebugBreak to 1

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                         s_cszServiceRegKey,
                                         0,
                                         KEY_READ, 
                                         &hKey))                             
        {        
            RegReadDWORD(hKey, s_cszDebugBreak, &dwBreak);
            ASSERT (dwBreak != 1);
            RegCloseKey(hKey);
        }
                        
        //
        // do boot time tasks - including firstrun if necessary
        //
        
        g_pEventHandler = new CEventHandler;
        if ( ! g_pEventHandler )
        {
            dwRc = GetLastError();        
            TRACE(TRACEID, "! out of memory");
            goto done;
        }

        dwRc = g_pEventHandler->OnBoot( );
        if ( ERROR_SUCCESS != dwRc )
        {
            TRACE(TRACEID, "g_pEventHandler->OnBoot : error=%ld", dwRc);
            goto done;
        }

        // bind the stop event to a callback
        // so that this gets called on a thread pool thread
        // when the stop event is signalled
        
        if (FALSE == RegisterWaitForSingleObject(&hSRStopWait, 
                                                 g_pSRConfig->m_hSRStopEvent, 
                                                 StopCallback, 
                                                 NULL,
                                                 INFINITE,
                                                 WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
        {
            dwRc = GetLastError();
            trace(0, "! RegisterWaitForSingleObject : %ld", dwRc);
            goto done;
        }
        
    }
    else
    {
         // There is not much we can do here if we do not have the
         // Service handle. So we will just log an error and exit.
        dwRc = GetLastError();
        DebugTrace(TRACEID, "RegisterServiceCtrlHandler failed %d", dwRc);
        LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_CTRLHANDLERNOTINSTALLED);
    }

done:
    if (dwRc != ERROR_SUCCESS)
    {          
        if (g_pEventHandler)
        {
            g_pEventHandler->OnStop();
            delete g_pEventHandler;
            g_pEventHandler = NULL;
        }
        
        m_Status.dwWin32ExitCode = (dwRc != ERROR_SERVICE_DISABLED) ? 
                                    dwRc : ERROR_SUCCESS;
        SetStatus(SERVICE_STOPPED);

        if (dwRc != ERROR_SERVICE_DISABLED)
            LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_FAILEDINI, &dwRc, sizeof(dwRc));        
    }
    
    TLEAVE();
}

//
// SetStatus:
//

void CNTService::SetStatus(DWORD dwState)
{
    TENTER("CNTService::SetStatus");
    
    TRACE(TRACEID, "SetStatus(%lu, %lu)", m_hServiceStatus, dwState);

    m_Status.dwCurrentState = dwState;

    ::SetServiceStatus(m_hServiceStatus, &m_Status);

    TLEAVE();
}

void CNTService::OnStop()
{
    TENTER("CNTService::OnStop");
        
     // BUGBUG what happens if the service has not started completely
     // yet ? We need to make sure that OnStop can only be called after
     // g_pEventHandler has been initialized.    
    if (NULL != g_pEventHandler)
    {
        // Tell SCM we are stopping

        m_Status.dwWin32ExitCode = 0;
        m_Status.dwCheckPoint = 0;   
        // we will stop in half the time we took to start or lesser
        m_Status.dwWaitHint = (SERVICE_WAIT_HINT/2)*1000;    
        SetStatus(SERVICE_STOP_PENDING);

        // complete all tasks
        
        g_pEventHandler->SignalStop();  
    }

    TLEAVE();    
}

// OnInterrogate is called by the SCM to get information about the
// current status of the service. Since this must report information
// about the service immediately to the SCM, we will run this in the
// same thread on which the handler function is called.
void CNTService::OnInterrogate()
{
    TENTER("CNTService::OnInterrogate");

     // report the status
    ::SetServiceStatus(m_hServiceStatus, &m_Status);    
    TLEAVE();    
}


//
// Handler : static member function (callback) to handle commands from the
// service control manager
//

void WINAPI SRServiceHandler(DWORD dwOpcode)
{
    //
    // Get a pointer to the object
    //
    TENTER("CNTService::Handler");

    
    TRACE(TRACEID, "CNTService::Handler(%lu)", dwOpcode);

    switch (dwOpcode) 
    {
        case SERVICE_CONTROL_STOP: // 1
            //
            // if someone disables the service explicitly
            // then disable all of SR
            //
            if (NULL != g_pSRService)
            {
                DWORD dwStart = 0;
                if (ERROR_SUCCESS == GetServiceStartup(s_cszServiceName, &dwStart))
                {
                    if (dwStart == SERVICE_DISABLED || dwStart == SERVICE_DEMAND_START)
                    {
                        if (g_pEventHandler)
                            g_pEventHandler->DisableSRS(NULL);
                        break;
                    }
                }
                else
                {
                    trace(TRACEID, "! GetServiceStartup");
                }   
            }

            //
            // else fallover
            //
            
        case SERVICE_CONTROL_SHUTDOWN: // 5
             // BUGBUG - g_pSRService should be accessed in critical section
            if (NULL != g_pSRService)
            {
                g_pSRService->OnStop();
            }

            break;

        case SERVICE_CONTROL_PAUSE: // 2
        case SERVICE_CONTROL_CONTINUE: // 3            
             // we do not do anything here
            break;
            
        case SERVICE_CONTROL_INTERROGATE: // 4
             // BUGBUG - g_pSRService should be accessed in critical section
            if (NULL != g_pSRService)
            {            
                g_pSRService->OnInterrogate();
            }
            break;
                        
        default:
            break;
    }
    
    TLEAVE();
}
        



/////////////////////////////////////////////////////////////////////////////
// Exported functions
/////////////////////////////////////////////////////////////////////////////



extern "C"
{
    
VOID WINAPI ServiceMain( 
    DWORD dwArgc, 
    LPWSTR *lpwzArgv )
{
     // Initialize tracing
    InitAsyncTrace();

    TraceFunctEnter("ServiceMain");
    
    g_pSRService = new CNTService();
    if (NULL == g_pSRService)
    {
         // in this case we will just exit. This is because we cannot
         // report any status here.
        
         // SCM will assume that the service has failed since it did
         // not call RegisterServiceCtrlHandler().
        goto cleanup;
    }
    
    g_pEventHandler = NULL;
    g_pSRService->ServiceMain( dwArgc, NULL );

cleanup:
    TraceFunctLeave();
}
    

    
BOOL WINAPI DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /* lpReserved */
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
       DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
   }
   
   return TRUE;
}


// callback for service stop event

void CALLBACK
StopCallback(
    PVOID   pv,
    BOOLEAN TimerOrWaitFired)
{
    
    if (g_pEventHandler)
    {
        g_pEventHandler->OnStop();
        delete g_pEventHandler;
        g_pEventHandler = NULL;
    }

    if (g_pSRService)
    {
        g_pSRService->SetStatus(SERVICE_STOPPED);        
        delete g_pSRService;
        g_pSRService = NULL;
    }

    TermAsyncTrace();    
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\srconfig.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    srconfig.cpp
 *
 *  Abstract:
 *    CSRConfig methods
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/15/2000
 *        created
 *
 *****************************************************************************/

#include "precomp.h"
extern "C"
{
#include <powrprof.h>
}

CSRConfig *g_pSRConfig;    // the global instance


CSRConfig::CSRConfig()
{
    m_hSRInitEvent = m_hSRStopEvent = m_hIdleRequestEvent = NULL;
    m_hIdleStartEvent = m_hIdleStopEvent = NULL;  
    m_hFilter = NULL;
    ::GetSystemDrive(m_szSystemDrive);
    m_fCleanup = FALSE;
    m_fSafeMode = FALSE;
    m_fReset = FALSE;
    m_dwFifoDisabledNum = 0;
    m_dwFreezeThawLogCount = 0;    
    lstrcpy(m_szGuid, L"");
}

CSRConfig::~CSRConfig()
{
    if (m_hSRInitEvent)
        CloseHandle(m_hSRInitEvent);

    if (m_hSRStopEvent)
        CloseHandle(m_hSRStopEvent);

    if (m_hIdleRequestEvent)
        CloseHandle(m_hIdleRequestEvent);
        
    CloseFilter();
}


void
CSRConfig::SetDefaults()
{
    m_dwDisableSR = FALSE;
    m_dwDisableSR_GroupPolicy = 0xFFFFFFFF;  // not configured
    m_dwFirstRun = SR_FIRSTRUN_NO;
    m_dwTimerInterval = SR_DEFAULT_TIMERINTERVAL;
    m_dwIdleInterval = SR_DEFAULT_IDLEINTERVAL;
    m_dwCompressionBurst = SR_DEFAULT_COMPRESSIONBURST;
    m_dwRPSessionInterval = SR_DEFAULT_RPSESSIONINTERVAL;
    m_dwDSMax = SR_DEFAULT_DSMAX;
    m_dwDSMin = SR_DEFAULT_DSMIN;
    m_dwRPGlobalInterval = SR_DEFAULT_RPGLOBALINTERVAL;
    m_dwRPLifeInterval = SR_DEFAULT_RPLIFEINTERVAL;    
    m_dwThawInterval = SR_DEFAULT_THAW_INTERVAL;
    m_dwDiskPercent = SR_DEFAULT_DISK_PERCENT;
    m_dwTestBroadcast = 0;
    m_dwCreateFirstRunRp = 1;
}


void
CSRConfig::ReadAll()
{
    HKEY    hKeyCur = NULL, hKeyCfg = NULL, hKeyFilter = NULL, hKey = NULL;
    HKEY    hKeyGP = NULL;
    DWORD   dwRc;
    POWER_POLICY pp;
    GLOBAL_POWER_POLICY gpp;
    UINT uiPowerScheme = 0;
 
    TENTER("CSRConfig::ReadAll");

    // open the group policy key, ignore failures if key doesn't exist
    RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                         s_cszGroupPolicy,
                         0,
                         KEY_READ,
                         &hKeyGP);

    // open SystemRestore regkeys
    
    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        s_cszSRRegKey,
                        0,
                        KEY_READ, 
                        &hKeyCur);
    if (ERROR_SUCCESS != dwRc)                                    
    {
        TRACE(0, "! RegOpenKeyEx on %S : %ld", s_cszSRRegKey, dwRc);
        goto done;
    }

    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        s_cszSRCfgRegKey,
                        0,
                        KEY_READ, 
                        &hKeyCfg);
    if (ERROR_SUCCESS != dwRc)                                    
    {
        TRACE(0, "! RegOpenKeyEx on %S : %ld", s_cszSRCfgRegKey, dwRc);
        goto done;
    }

    
    // open the filter regkey
    
    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        s_cszFilterRegKey,
                        0,
                        KEY_READ, 
                        &hKeyFilter);
    if (ERROR_SUCCESS != dwRc)                                   
    {
        TRACE(0, "! RegOpenKeyEx on %S : %ld", s_cszFilterRegKey, dwRc);
        goto done;
    }

    RegReadDWORD(hKeyCur, s_cszDisableSR, &m_dwDisableSR);      
    RegReadDWORD(hKeyCur, s_cszTestBroadcast, &m_dwTestBroadcast);        
    
    // read the group policy values to be enforced
    // read the corresponding local setting also

    if (hKeyGP != NULL)
        RegReadDWORD(hKeyGP, s_cszDisableSR, &m_dwDisableSR_GroupPolicy);

    // read firstrun - 1 means firstrun, 0 means not

    RegReadDWORD(hKeyFilter, s_cszFirstRun, &m_dwFirstRun);    

       
    // if firstrun, read other values from Cfg subkey
    // else read other values from main regkey
    
    hKey = (m_dwFirstRun == SR_FIRSTRUN_YES) ? hKeyCfg : hKeyCur;
            
    RegReadDWORD(hKey, s_cszDSMin, &m_dwDSMin);
    RegReadDWORD(hKey, s_cszDSMax, &m_dwDSMax);
    RegReadDWORD(hKey, s_cszRPSessionInterval, &m_dwRPSessionInterval);
    RegReadDWORD(hKey, s_cszRPGlobalInterval, &m_dwRPGlobalInterval);
    RegReadDWORD(hKey, s_cszRPLifeInterval, &m_dwRPLifeInterval);    
    RegReadDWORD(hKey, s_cszCompressionBurst, &m_dwCompressionBurst);
    RegReadDWORD(hKey, s_cszTimerInterval, &m_dwTimerInterval);
    RegReadDWORD(hKey, s_cszDiskPercent, &m_dwDiskPercent);
    RegReadDWORD(hKey, s_cszThawInterval, &m_dwThawInterval);   

    if (GetCurrentPowerPolicies (&gpp, &pp))
    {
        m_dwIdleInterval = max(pp.user.IdleTimeoutAc, pp.user.IdleTimeoutDc);
        m_dwIdleInterval = max(SR_DEFAULT_IDLEINTERVAL, m_dwIdleInterval*2);
    }
    
done:        
    if (hKeyCur) 
        RegCloseKey(hKeyCur);
    if (hKeyCfg) 
        RegCloseKey(hKeyCfg);
    if (hKeyFilter)
        RegCloseKey(hKeyFilter);
    if (hKeyGP)
        RegCloseKey (hKeyGP);

    TLEAVE();
}


// upon firstrun, write the current values to the current location

void
CSRConfig::WriteAll()
{
    TENTER("CSRConfig::WriteAll");
    HKEY    hKey = NULL;
    HKEY    hKeyCfg = NULL;
    DWORD   dwRc;
    
    // open SystemRestore regkey
    
    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        s_cszSRRegKey,
                        0,
                        KEY_WRITE, 
                        &hKey);
    if (ERROR_SUCCESS != dwRc)                                    
    {
        TRACE(0, "! RegOpenKeyEx on %S : %ld", s_cszSRRegKey, dwRc);
        goto done;
    }

    RegWriteDWORD(hKey, s_cszDisableSR, &m_dwDisableSR);
    RegWriteDWORD(hKey, s_cszDSMin, &m_dwDSMin);
    RegWriteDWORD(hKey, s_cszDSMax, &m_dwDSMax);
    RegWriteDWORD(hKey, s_cszRPSessionInterval, &m_dwRPSessionInterval);
    RegWriteDWORD(hKey, s_cszRPGlobalInterval, &m_dwRPGlobalInterval);
    RegWriteDWORD(hKey, s_cszRPLifeInterval, &m_dwRPLifeInterval);    
    RegWriteDWORD(hKey, s_cszCompressionBurst, &m_dwCompressionBurst);
    RegWriteDWORD(hKey, s_cszTimerInterval, &m_dwTimerInterval);
    RegWriteDWORD(hKey, s_cszDiskPercent, &m_dwDiskPercent);
    RegWriteDWORD(hKey, s_cszThawInterval, &m_dwThawInterval);    

    // secure our keys from other users
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        s_cszSRCfgRegKey,
                        0,
                        KEY_WRITE,
                        &hKeyCfg))
    {
        dwRc = SetAclInObject(hKeyCfg, SE_REGISTRY_KEY,KEY_ALL_ACCESS,KEY_READ, TRUE);
        RegCloseKey (hKeyCfg);
        hKeyCfg = NULL;

        if (ERROR_SUCCESS != dwRc)
        {
            TRACE(0, "! SetAclInObject %S : %ld", s_cszSRCfgRegKey, dwRc);
            goto done;
        }
    }

    dwRc = SetAclInObject(hKey, SE_REGISTRY_KEY, KEY_ALL_ACCESS, KEY_READ, TRUE);
    if (ERROR_SUCCESS != dwRc)
    {
        TRACE(0, "! SetAclInObject %S : %ld", s_cszSRRegKey, dwRc);
        goto done;
    }
    
done:  
    TLEAVE();
    if (hKey) 
        RegCloseKey(hKey);    
}


DWORD 
CSRConfig::SetMachineGuid()
{
    TENTER("CSRConfig::SetMachineGuid");

    HKEY    hKey = NULL;
    DWORD   dwErr, dwType, dwSize;
    WCHAR   szGuid[GUID_STRLEN];
    LPWSTR  pszGuid = NULL;

    // read the machine guid from the cfg regkey

    pszGuid = GetMachineGuid();
    if (! pszGuid)
    {
        GUID guid;

        UuidCreate(&guid);  

        dwErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              s_cszSRCfgRegKey, 0,
                              KEY_WRITE, &hKey);

        if (dwErr != ERROR_SUCCESS)
            goto Err;

        if (0 == StringFromGUID2 (guid, szGuid, sizeof(szGuid)/sizeof(WCHAR)))
            goto Err;

        dwErr = RegSetValueEx (hKey, s_cszSRMachineGuid,
                               0, REG_SZ, (BYTE *) szGuid,
                               (lstrlen(szGuid) + 1) * sizeof(WCHAR));
    
        if (dwErr != ERROR_SUCCESS)
            goto Err;

        pszGuid = (LPWSTR) szGuid;
    }
    
    RegCloseKey(hKey);
    hKey = NULL;

    // then copy it to the filter regkey 

    dwErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          s_cszFilterRegKey, 0,
                          KEY_WRITE, &hKey);

    if (dwErr != ERROR_SUCCESS)
        goto Err;

    dwErr = RegSetValueEx (hKey, s_cszSRMachineGuid,
                           0, REG_SZ, (BYTE *) pszGuid,
                           (lstrlen(pszGuid) + 1) * sizeof(WCHAR));   
    
Err:
    if (hKey)
        RegCloseKey(hKey);

    TLEAVE();
    return dwErr;
}


// method to set firstrun key in the registry and update member

DWORD
CSRConfig::SetFirstRun(DWORD dwValue)
{
    HKEY   hKeyFilter = NULL;
    DWORD  dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               s_cszFilterRegKey,
                               0,
                               KEY_WRITE, 
                               &hKeyFilter);
    if (ERROR_SUCCESS != dwRc)
        goto done;
    
    dwRc = RegWriteDWORD(hKeyFilter, s_cszFirstRun, &dwValue);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    m_dwFirstRun = dwValue;
    
done:
    if (hKeyFilter)
        RegCloseKey(hKeyFilter);
    return dwRc;
}


DWORD
CSRConfig::SetDisableFlag(DWORD dwValue)
{
    HKEY   hKeySR = NULL;
    DWORD  dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               s_cszSRRegKey,
                               0,
                               KEY_WRITE, 
                               &hKeySR);
    if (ERROR_SUCCESS != dwRc)
        goto done;
    
    dwRc = RegWriteDWORD(hKeySR, s_cszDisableSR, &dwValue);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    m_dwDisableSR = dwValue;
    
done:
    if (hKeySR)
        RegCloseKey(hKeySR);
    return dwRc;
}


DWORD
CSRConfig::SetCreateFirstRunRp(DWORD dwValue)
{
    HKEY   hKeySR = NULL;
    DWORD  dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               s_cszSRRegKey,
                               0,
                               KEY_WRITE, 
                               &hKeySR);
    if (ERROR_SUCCESS != dwRc)
        goto done;
    
    dwRc = RegWriteDWORD(hKeySR, s_cszCreateFirstRunRp, &dwValue);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    m_dwCreateFirstRunRp = dwValue;
    
done:
    if (hKeySR)
        RegCloseKey(hKeySR);
    return dwRc;
}


DWORD
CSRConfig::GetCreateFirstRunRp()
{
    HKEY   hKeySR = NULL;
    DWORD  dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               s_cszSRRegKey,
                               0,
                               KEY_READ, 
                               &hKeySR);
    if (ERROR_SUCCESS != dwRc)
        goto done;
    
    dwRc = RegReadDWORD(hKeySR, s_cszCreateFirstRunRp, &m_dwCreateFirstRunRp);
    
done:
    if (hKeySR)
        RegCloseKey(hKeySR);
    return m_dwCreateFirstRunRp;
}


// add datastore to regkey backup exclude list

DWORD
CSRConfig::AddBackupRegKey()
{
    HKEY    hKey = NULL;
    WCHAR   szPath[MAX_PATH];
    DWORD   dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                L"System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup",
                                0,
                                KEY_WRITE, 
                                &hKey);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    MakeRestorePath(szPath, L"\\", L"* /s");
    szPath[lstrlen(szPath)+1] = L'\0';  // second null terminator for multi sz
    dwRc = RegSetValueEx (hKey, 
                          L"System Restore",
                          0,
                          REG_MULTI_SZ,
                          (LPBYTE) szPath,
                          (lstrlen(szPath) + 2) * sizeof(WCHAR));  
    if (ERROR_SUCCESS != dwRc)
        goto done;

done:
    if (hKey)
        RegCloseKey(hKey);
        
    return dwRc;
}


void
CSRConfig::RegisterTestMessages()
{
    HWINSTA hwinstaUser = NULL; 
    HDESK   hdeskUser = NULL; 
    DWORD   dwThreadId; 
    HWINSTA hwinstaSave = NULL; 
    HDESK   hdeskSave = NULL; 
    DWORD   dwRc;

    TENTER("RegisterTestMessages");

    //
    // save current values
    //

    GetDesktopWindow(); 
    hwinstaSave = GetProcessWindowStation(); 
    dwThreadId = GetCurrentThreadId(); 
    hdeskSave = GetThreadDesktop(dwThreadId); 

    //
    // change desktop and winstation to interactive user
    //
    
    hwinstaUser = OpenWindowStation(L"WinSta0", FALSE, MAXIMUM_ALLOWED);

    if (hwinstaUser == NULL) 
    { 
        dwRc = GetLastError();
        trace(0, "! OpenWindowStation : %ld", dwRc);
        goto done;
    } 
    
    SetProcessWindowStation(hwinstaUser); 
    hdeskUser = OpenDesktop(L"Default", 0, FALSE, MAXIMUM_ALLOWED); 
    if (hdeskUser == NULL) 
    { 
        dwRc = GetLastError();
        trace(0, "! OpenDesktop : %ld", dwRc);
        goto done;
    } 
    
    SetThreadDesktop(hdeskUser); 

    //
    // register the test messages
    //

    m_uiTMFreeze = RegisterWindowMessage(s_cszTM_Freeze);
    m_uiTMThaw = RegisterWindowMessage(s_cszTM_Thaw);
    m_uiTMFifoStart = RegisterWindowMessage(s_cszTM_FifoStart);
    m_uiTMFifoStop = RegisterWindowMessage(s_cszTM_FifoStop);    
    m_uiTMEnable = RegisterWindowMessage(s_cszTM_Enable);
    m_uiTMDisable = RegisterWindowMessage(s_cszTM_Disable);	
    m_uiTMCompressStart = RegisterWindowMessage(s_cszTM_CompressStart);	    
    m_uiTMCompressStop = RegisterWindowMessage(s_cszTM_CompressStop);	        

done:
    //
    // restore old values
    //

    if (hdeskSave) 
        SetThreadDesktop(hdeskSave); 

    if (hwinstaSave)    
        SetProcessWindowStation(hwinstaSave); 

    //
    // close opened handles
    //
    
    if (hdeskUser)
        CloseDesktop(hdeskUser); 

    if (hwinstaUser)    
        CloseWindowStation(hwinstaUser);  
        
    TLEAVE();
}


    
DWORD
CSRConfig::Initialize()
{
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    WCHAR   szDat[MAX_PATH];
	
    TENTER("CSRConfig::Initialize");

    // read all config values from registry
    // use default if not able to read value

    SetDefaults();
    ReadAll();


    // is this safe mode?

    if (0 != GetSystemMetrics(SM_CLEANBOOT))
    {
        TRACE(0, "This is safemode");
        m_fSafeMode = TRUE;
    }

     // if _filelst.cfg does not exist, then consider this firstrun

    MakeRestorePath(szDat, GetSystemDrive(), s_cszFilelistDat);
    if (-1 == GetFileAttributes(szDat))
    {
        TRACE(0, "%S does not exist", s_cszFilelistDat);
        SetFirstRun(SR_FIRSTRUN_YES);
    }
    
    if (m_dwFirstRun == SR_FIRSTRUN_YES)
    {          
        SetMachineGuid();
        WriteAll();

        AddBackupRegKey();
    }

    TRACE(0, "%SFirstRun", m_dwFirstRun == SR_FIRSTRUN_YES ? L"" : L"Not ");

    // create events
    // give read access to everyone so that clients can wait on them

    // SR init
    m_hSRInitEvent = CreateEvent(NULL, FALSE, FALSE, s_cszSRInitEvent);
    if (! m_hSRInitEvent)
    {
        TRACE(0, "! CreateEvent on %S : %ld", s_cszSRInitEvent, GetLastError());
        goto done;
    }

    dwRc = SetAclInObject(m_hSRInitEvent, 
                          SE_KERNEL_OBJECT,
                          STANDARD_RIGHTS_ALL | GENERIC_ALL, 
                          STANDARD_RIGHTS_READ | GENERIC_READ | SYNCHRONIZE,
                          FALSE);

    if (dwRc != ERROR_SUCCESS)
    {
        TRACE(0, "! SetAclInObject : %ld", dwRc);
        goto done;
    }

    // SR stop                      
    m_hSRStopEvent = CreateEvent(NULL, TRUE, FALSE, s_cszSRStopEvent);
    if (! m_hSRStopEvent)
    {
        TRACE(0, "! CreateEvent on %S : %ld", s_cszSRStopEvent, GetLastError());
        goto done;
    }  
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        TRACE(0, "Stop Event already exists!");
        ResetEvent (m_hSRStopEvent);
    }

    dwRc = SetAclInObject(m_hSRStopEvent, 
                          SE_KERNEL_OBJECT,
                          STANDARD_RIGHTS_ALL | GENERIC_ALL, 
                          STANDARD_RIGHTS_READ | GENERIC_READ | SYNCHRONIZE,
                          FALSE);
    if (dwRc != ERROR_SUCCESS)
    {
        TRACE(0, "! SetAclInObject : %ld", dwRc);
        goto done;
    }                          

    // idle request
    m_hIdleRequestEvent = CreateEvent(NULL, FALSE, FALSE, s_cszIdleRequestEvent);
    if (! m_hIdleRequestEvent)
    {
        TRACE(0, "! CreateEvent on %S : %ld", s_cszIdleRequestEvent, GetLastError());
        goto done;
    }  

    dwRc = SetAclInObject(m_hIdleRequestEvent, 
                          SE_KERNEL_OBJECT,
                          STANDARD_RIGHTS_ALL | GENERIC_ALL, 
                          STANDARD_RIGHTS_READ | GENERIC_READ | SYNCHRONIZE,
                          FALSE);
    if (dwRc != ERROR_SUCCESS)
    {
        TRACE(0, "! SetAclInObject : %ld", dwRc);
        goto done;
    }    

    // 
    // register test messages
    //

    if (m_dwTestBroadcast)
    {
        RegisterTestMessages();
    }
    
    dwRc = ERROR_SUCCESS;

done:
    TLEAVE();
    return dwRc;
}


//
// function to check if system is running on battery
// 

BOOL CSRConfig::IsSystemOnBattery()
{
    tenter("CSRConfig::IsSystemOnBattery");
    BOOL                fRc = FALSE;
    SYSTEM_POWER_STATUS sps;
    
    if (FALSE == GetSystemPowerStatus(&sps))
    {
        trace(0, "! GetSystemPowerStatus : %ld", GetLastError());
        goto done;
    }

    fRc = (sps.ACLineStatus == 0);

done:    
    trace(0, "System %S battery", fRc ? L"on" : L"not on");       
    tleave();
    return fRc;
}


DWORD CSRConfig::OpenFilter()
{
    return SrCreateControlHandle(SR_OPTION_OVERLAPPED, &m_hFilter);
}


void CSRConfig::CloseFilter()
{
    if (m_hFilter)
    {
        CloseHandle(m_hFilter);
        m_hFilter = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\service\srconfig.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    srconfig.h
 *
 *  Abstract:
 *    CSRConfig class definition
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/13/2000
 *        created
 *
 *****************************************************************************/

#ifndef _SRCONFIG_H_
#define _SRCONFIG_H_

#include "srdefs.h"

class CSRConfig {

public:
    HANDLE  m_hFilter;
    DWORD   m_dwDisableSR;
    DWORD   m_dwDisableSR_GroupPolicy;
    DWORD   m_dwFirstRun;
    BOOL    m_fSafeMode;
    DWORD   m_dwDSMin;
    DWORD   m_dwDSMax;
    DWORD   m_dwRPSessionInterval;
    DWORD   m_dwRPGlobalInterval;
    DWORD   m_dwCompressionBurst;
    DWORD   m_dwTimerInterval;    
    DWORD   m_dwIdleInterval;
    WCHAR   m_szSystemDrive[MAX_PATH];
    WCHAR   m_szGuid[MAX_PATH];
    BOOL    m_fCleanup;
    BOOL    m_fReset;
    DWORD   m_dwFifoDisabledNum;
    DWORD   m_dwDiskPercent;
    DWORD   m_dwRPLifeInterval;
    DWORD   m_dwThawInterval;
    DWORD   m_dwTestBroadcast;    
    DWORD   m_dwCreateFirstRunRp;
    DWORD   m_dwFreezeThawLogCount;    
    UINT    m_uiTMFreeze;
    UINT    m_uiTMThaw;
    UINT    m_uiTMFifoStart;
    UINT    m_uiTMFifoStop;
    UINT    m_uiTMEnable;
    UINT    m_uiTMDisable;
    UINT    m_uiTMCompressStart;
    UINT    m_uiTMCompressStop;
    
    // event handles
    HANDLE  m_hSRInitEvent;
    HANDLE  m_hSRStopEvent;
    HANDLE  m_hIdleStartEvent;
    HANDLE  m_hIdleStopEvent;
    HANDLE  m_hIdleRequestEvent;
    HANDLE  m_hIdle;
    
    CSRConfig();     
    ~CSRConfig();   

    HANDLE GetFilter() {
        return m_hFilter;
    }

    LPWSTR GetSystemDrive() {
        return m_szSystemDrive;
    }

    DWORD GetFirstRun() {
        return m_dwFirstRun;
    }

    BOOL GetSafeMode() {
        return m_fSafeMode;
    }
    
    BOOL GetCleanupFlag() {
        return m_fCleanup;
    }

    BOOL GetResetFlag() {
        return m_fReset;
    }
    
    DWORD GetFifoDisabledNum() {
        return m_dwFifoDisabledNum;
    }

    DWORD GetDisableFlag () {
        return m_dwDisableSR;
    }

    DWORD GetDisableFlag_GroupPolicy () {
        return m_dwDisableSR_GroupPolicy;
    }
        
    void SetCleanupFlag(BOOL fCleanup) {
        m_fCleanup = fCleanup;
    }

    void SetResetFlag(BOOL fReset) {
        m_fReset = fReset;
    }
    
    void SetFifoDisabledNum(DWORD dwNum) {
        m_dwFifoDisabledNum = dwNum;
    }

    DWORD GetDSMin (BOOL fSystem)
    {
        if (fSystem)
            return m_dwDSMin * MEGABYTE;
        else
            return SR_DEFAULT_DSMIN_NONSYSTEM * MEGABYTE;
    }

    DWORD OpenFilter();
    void  CloseFilter();
    void  SetDefaults(); 
    void  WriteAll();   
    void  ReadAll();    
    DWORD Initialize(); 
    DWORD SetFirstRun(DWORD dwValue);
    DWORD SetDisableFlag (DWORD dwDisableSR);
    DWORD SetMachineGuid();
    DWORD AddBackupRegKey();
    void  RegisterTestMessages();
    DWORD SetCreateFirstRunRp(DWORD dwValue);
    DWORD GetCreateFirstRunRp();    
    BOOL  IsSystemOnBattery();
};


extern CSRConfig *g_pSRConfig;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\dload.cpp ===
#include "stdwin.h"
#include <delayimp.h>
#include "rstrpriv.h"

extern CSRClientLoader  g_CSRClientLoader;
#include "..\rstrcore\dload_common.cpp"

// we assume DELAYLOAD_VERSION >= 0x0200
PfnDliHook __pfnDliFailureHook2 = SystemRestore_DelayLoadFailureHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\extwrap.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    rstrmgr.cpp

Abstract:
    This file contains the implementation of the CRestoreManager class, which
    controls overall restoration process and provides methods to control &
    help user experience flow.

Revision History:
    Seong Kook Khang (SKKhang)  05/10/00
        created

******************************************************************************/

#include "stdwin.h"
#include <srrpcapi.h>
#include "enumlogs.h"
#include "rstrpriv.h"
#include "rstrmgr.h"
#include "extwrap.h"

/////////////////////////////////////////////////////////////////////////////
//
// CSRExternalWrapper class
//
/////////////////////////////////////////////////////////////////////////////

class CSRExternalWrapper : public ISRExternalWrapper
{
// ISRExternalWrapper methods
public:
    BOOL   BuildRestorePointList( CDPA_RPI *paryRPI );
    BOOL   DisableFIFO( DWORD dwRP );
    DWORD  EnableFIFO();
    //BOOL  SetRestorePoint( RESTOREPOINTINFO *pRPI, STATEMGRSTATUS *pStatus );
    BOOL   SetRestorePoint( LPCWSTR cszDesc, INT64 *pllRP );
    BOOL   RemoveRestorePoint( DWORD dwRP );
    BOOL   Release();
};

/////////////////////////////////////////////////////////////////////////////
// CSRExternalWrapper - ISRExternalWrapper methods

BOOL  CSRExternalWrapper::BuildRestorePointList( CDPA_RPI *paryRPI )
{
    TraceFunctEnter("CSRExternalWrapper::BuildRestorePointList");
    BOOL               fRet = FALSE;
    BOOL               fExist;
    CRestorePointEnum  cRPEnum;
    CRestorePoint      cRP;
    DWORD              dwRes;
    PSRPI              pRPI;

    dwRes = cRPEnum.FindFirstRestorePoint( cRP );

    // if rp.log doesn't exist for a restore point, we skip it and list all others
    while ( dwRes == ERROR_SUCCESS || dwRes == ERROR_FILE_NOT_FOUND)
    {
        // Ignoring any nonstandard restore point types (e.g. shutdown),
        // assuming they can no longer be created on Whistler.

        // skip restore points that don't have rp.log +
        // skip cancelled restore points

        if (dwRes != ERROR_FILE_NOT_FOUND && ! cRP.IsDefunct())
        {        
            pRPI = new SRestorePointInfo;
            if ( pRPI == NULL )
            {
                ErrorTrace(TRACE_ID, "Cannot create RPI Instance...");
                goto Exit;
            }

            pRPI->dwType  = cRP.GetType();
            pRPI->dwNum   = cRP.GetNum();
            pRPI->strDir  = cRP.GetDir();
            pRPI->strName = cRP.GetName();

            pRPI->stTimeStamp.SetTime( cRP.GetTime(), FALSE );
            if ( !paryRPI->AddItem( pRPI ) )
                goto Exit;
        }
        else
        {
            DebugTrace(TRACE_ID, "Ignoring cancelled restore point");            
        }   
            
        dwRes = cRPEnum.FindNextRestorePoint( cRP );
    }

    fRet = TRUE;
Exit:
    //BUGBUG - keep an eye on this, dummy at this moment
    cRPEnum.FindClose();

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CSRExternalWrapper::DisableFIFO( DWORD dwRP )
{
    TraceFunctEnter("CSRExternalWrapper::DisableFIFO");
    BOOL   fRet = FALSE;
    DWORD  dwRes;

    dwRes = ::DisableFIFO( dwRP );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::DisableFIFO failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

DWORD  CSRExternalWrapper::EnableFIFO()
{
    TraceFunctEnter("CSRExternalWrapper::EnableFIFO");
    DWORD  dwRes;

    dwRes = ::EnableFIFO();
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::EnableFIFO failed - %ls", cszErr);
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( dwRes );
}

/*
BOOL  CSRExternalWrapper::SetRestorePoint( RESTOREPOINTINFO *pRPI, STATEMGRSTATUS *pStatus )
{
    return( TRUE );
}
*/

/***************************************************************************/

BOOL  CSRExternalWrapper::SetRestorePoint( LPCWSTR cszDesc, INT64 *pllRP )
{
    TraceFunctEnter("CSRExternalWrapper::SetRestorePoint");
    BOOL              fRet = FALSE;
    RESTOREPOINTINFO  sRPInfo;
    STATEMGRSTATUS    sSmgrStatus;

    sRPInfo.dwEventType      = BEGIN_SYSTEM_CHANGE;
    sRPInfo.dwRestorePtType  = CHECKPOINT;
    sRPInfo.llSequenceNumber = 0;
    sRPInfo.szDescription[MAX_DESC_W-1] = L'\0';
    ::lstrcpyn( sRPInfo.szDescription, cszDesc, MAX_DESC_W );
    if ( !::SRSetRestorePoint( &sRPInfo, &sSmgrStatus ) )
    {
        ErrorTrace(0, "::SRSetRestorePoint failed, status=%d", sSmgrStatus.nStatus);
        goto Exit;
    }

    if ( pllRP != NULL )
        *pllRP = sSmgrStatus.llSequenceNumber;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CSRExternalWrapper::RemoveRestorePoint( DWORD dwRP )
{
    TraceFunctEnter("CSRExternalWrapper::RemoveRestorePoint");
    BOOL   fRet = FALSE;
    DWORD  dwRes;

    dwRes = ::SRRemoveRestorePoint( dwRP );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::SRRemoveRestorePoint failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CSRExternalWrapper::Release()
{
    TraceFunctEnter("CSRExternalWrapper::Release");
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
//
// CSRExternalWrapperStub class
//
/////////////////////////////////////////////////////////////////////////////

class CSRExternalWrapperStub : public ISRExternalWrapper
{
// ISRExternalWrapper methods
public:
    BOOL   BuildRestorePointList( CDPA_RPI *paryRPI );
    BOOL   DisableFIFO( DWORD dwRP );
    DWORD  EnableFIFO();
    //BOOL  SetRestorePoint( RESTOREPOINTINFO *pRPI, STATEMGRSTATUS *pStatus );
    BOOL   SetRestorePoint( LPCWSTR cszDesc, INT64 *pllRP );
    BOOL   RemoveRestorePoint( DWORD dwRP );
    BOOL   Release();
};

/////////////////////////////////////////////////////////////////////////////
// CSRExternalWrapperStub - ISRExternalWrapper methods

#define FTUNITPERDAY  ((INT64)24*60*60*1000*1000*10)

struct SRPIStub
{
    DWORD    dwType;
    LPCWSTR  cszName;
    //CSRTime  stTime;
};

static SRPIStub  s_aryRPIList[] =
{
    {  CHECKPOINT,          L"System Check Point"  },
    {  APPLICATION_INSTALL, L"Office 2000 Install"  },
    {  RESTORE,             L"Restore"  },
    {  CHECKPOINT,          L"System Check Point"  },
    {  CHECKPOINT,          L"System Check Point"  },
    {  CHECKPOINT,          L"System Check Point"  },
    {  APPLICATION_INSTALL, L"InocuLan Install"  },
    {  APPLICATION_INSTALL, L"Flight Simulator 2000 Install"  },
    {  APPLICATION_INSTALL, L"Norton Utilities Install"  },
    {  CHECKPOINT,          L"System Check Point"  },
    {  APPLICATION_INSTALL, L"Evil App Install"  },
    {  CHECKPOINT,          L"System Check Point"  },
    {  RESTORE,             L"Restore"  },
    {  RESTORE,             L"Restore"  },
    {  CHECKPOINT,          L"System Check Point"  },
    {  CHECKPOINT,          L"System Check Point"  }
};
#define COUNT_RPI_ENTRY  (sizeof(s_aryRPIList)/sizeof(SRPIStub))
static int  s_nRPTimeOff[COUNT_RPI_ENTRY] =
{  -60, -59, -57, -57, -31, -30, -6, -6, -6, -6, -4, -3, -2, -2, -1, 0  };

BOOL  CSRExternalWrapperStub::BuildRestorePointList( CDPA_RPI *paryRPI )
{
    TraceFunctEnter("CSRExternalWrapperStub::BuildRestorePointList");
    BOOL            fRet = FALSE;
    int             i;
    PSRPI           pRPI;
    ULARGE_INTEGER  ullTime;
    ULARGE_INTEGER  ullOff;

    ::GetSystemTimeAsFileTime( (PFILETIME)&ullTime );
    for ( i = 0;  i < COUNT_RPI_ENTRY;  i++ )
    {
        pRPI = new SRestorePointInfo;
        if ( pRPI == NULL )
        {
            ErrorTrace(TRACE_ID, "Insufficient memory, cannot allocate RPI");
            goto Exit;
        }
        pRPI->dwType  = s_aryRPIList[i].dwType;
        pRPI->strDir  = L"c:\\some\\dummy\\directory\\name";
        pRPI->strName = s_aryRPIList[i].cszName;
        ullOff = ullTime;
        ullOff.QuadPart += s_nRPTimeOff[i] * FTUNITPERDAY;
        pRPI->stTimeStamp.SetTime( (PFILETIME)&ullOff );
        paryRPI->AddItem( pRPI );
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CSRExternalWrapperStub::DisableFIFO( DWORD )
{
    TraceFunctEnter("CSRExternalWrapperStub::DisableFIFO");
    TraceFunctLeave();
    return( TRUE );
}

/***************************************************************************/

DWORD  CSRExternalWrapperStub::EnableFIFO()
{
    TraceFunctEnter("CSRExternalWrapperStub::EnableFIFO");
    TraceFunctLeave();
    return( ERROR_SUCCESS );
}

/*
BOOL  CSRExternalWrapperStub::SetRestorePoint( RESTOREPOINTINFO *pRPI, STATEMGRSTATUS *pStatus )
{
    TraceFunctEnter("CSRExternalWrapperStub::SetRestorePoint");
    TraceFunctLeave();
    return( TRUE );
}
*/

/***************************************************************************/

BOOL  CSRExternalWrapperStub::SetRestorePoint( LPCWSTR, INT64* )
{
    TraceFunctEnter("CSRExternalWrapperStub::SetRestorePoint");
    TraceFunctLeave();
    return( TRUE );
}

/***************************************************************************/

BOOL  CSRExternalWrapperStub::RemoveRestorePoint( DWORD )
{
    TraceFunctEnter("CSRExternalWrapperStub::RemoveRestorePoint");
    TraceFunctLeave();
    return( TRUE );
}

/***************************************************************************/

BOOL  CSRExternalWrapperStub::Release()
{
    TraceFunctEnter("CSRExternalWrapperStub::Release");
    delete this;
    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateSRExternalWrapper
//
/////////////////////////////////////////////////////////////////////////////

BOOL  CreateSRExternalWrapper( BOOL fUseStub, ISRExternalWrapper **ppExtWrap )
{
    TraceFunctEnter("CreateSRExternalWrapper");
    BOOL  fRet = FALSE;

    if ( fUseStub )
        *ppExtWrap = new CSRExternalWrapperStub;
    else
        *ppExtWrap = new CSRExternalWrapper;

    if ( *ppExtWrap == NULL )
    {
        ErrorTrace(TRACE_ID, "Insufficient memory...");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\setup\makefile.inc ===
$(LOCALTARGET)\filelist.xml: filelist.xml
    copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\frmbase.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    FrmBase.h

Abstract:
    This file defines ISRFrameBase interface, which is common base interface
    for front-end SR UI.

Revision History:
    Seong Kook Khang (SKKhang)  04/04/2000
        created

******************************************************************************/

#ifndef _FRMBASE_H__INCLUDED_
#define _FRMBASE_H__INCLUDED_

#pragma once


struct ISRFrameBase
{
    virtual DWORD  RegisterServer() = 0;
    virtual DWORD  UnregisterServer() = 0;
    virtual BOOL   InitInstance( HINSTANCE hInst ) = 0;
    virtual BOOL   ExitInstance() = 0;
    virtual void   Release() = 0;
    virtual int    RunUI( LPCWSTR szTitle, int nStart ) = 0;
};


extern BOOL  CreateSRFrameInstance( ISRFrameBase **pUI );


#endif //_FRMBASE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\extwrap.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    rstrmgr.h

Abstract:
    This file contains the declaration of the ISRExternalWrapper interface,
    which wrappes data store routines, service RPC routines, etc.  This is
    also necessary for providing "Test UI Mode" using stub functions.

Revision History:
    Seong Kook Khang (SKKhang)  05/10/00
        created

******************************************************************************/

#ifndef _EXTWRAP_H__INCLUDED_
#define _EXTWRAP_H__INCLUDED_

#pragma once


struct ISRExternalWrapper
{
// Restore Point Log Enumeration
    virtual BOOL   BuildRestorePointList( CDPA_RPI *paryRPI ) = 0;

// Service RPC
    virtual BOOL   DisableFIFO( DWORD dwRP ) = 0;
    virtual DWORD  EnableFIFO() = 0;
    //virtual BOOL  SetRestorePoint( RESTOREPOINTINFO *pRPI, STATEMGRSTATUS *pStatus ) = 0;
    virtual BOOL   SetRestorePoint( LPCWSTR cszDesc, INT64 *pllRP ) = 0;
    virtual BOOL   RemoveRestorePoint( DWORD dwRP ) = 0;
    virtual BOOL   Release() = 0;
};


extern ISRExternalWrapper  *g_pExternal;

BOOL  CreateSRExternalWrapper( BOOL fUseStub, ISRExternalWrapper **ppExtWrap );


#endif //_EXTWRAP_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\frmmars.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    FrmMars.cpp

Abstract:
    This file contains the implementation of the CSRFrameMars class, which
    implements SR UI using MARS / IE.

Revision History:
    Seong Kook Khang (SKKhang)  04/04/2000
        created

******************************************************************************/

#include "stdwin.h"
#include "stdatl.h"
#include <MarsHost.h>
#include "resource.h"
#include "rstrpriv.h"
#include <initguid.h>
#include "srui_htm.h"
#include "rstrmgr.h"
#include "rstrprog.h"
#include "rstrshl.h"
#include "FrmBase.h"
#include "srui_htm_i.c"


/////////////////////////////////////////////////////////////////////////////
//
// ATL Module for UI Frame
//
/////////////////////////////////////////////////////////////////////////////

CComModule  _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_RstrProgress, CRstrProgress)
    //OBJECT_ENTRY(CLSID_RstrEdit, CRstrEdit)
    OBJECT_ENTRY(CLSID_RestoreShellExternal, CRestoreShell)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//
// CSRFrameMars
//
/////////////////////////////////////////////////////////////////////////////

class CSRFrameMars : public ISRFrameBase
{
public:
    CSRFrameMars();
    ~CSRFrameMars();

// ISRUI_Base methods
public:
    DWORD  RegisterServer();
    DWORD  UnregisterServer();
    BOOL   InitInstance( HINSTANCE hInst );
    BOOL   ExitInstance();
    void   Release();
    int    RunUI( LPCWSTR szTitle, int nStart );

// Operations
protected:
    BOOL   CleanUp();
    DWORD  InvokeMARS( LPCWSTR szTitle );

// Attributes
protected:
    HWND  m_hWnd;
};


/////////////////////////////////////////////////////////////////////////////
// CSRFrameMars create instance

BOOL  CreateSRFrameInstance( ISRFrameBase **pUI )
{
    TraceFunctEnter("CreateSRFrameInstance");
    BOOL     fRet = TRUE;
    LPCWSTR  cszErr;

    *pUI = new CSRFrameMars;
    if ( *pUI == NULL )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "Creating SRUI Instance failed - %s", cszErr);
        fRet = FALSE;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CSRFrameMars construction/destruction

CSRFrameMars::CSRFrameMars()
{
    m_hWnd = NULL;
}

CSRFrameMars::~CSRFrameMars()
{
}


/////////////////////////////////////////////////////////////////////////////
// CSRFrameMars - ISRFrameBase methods

DWORD  CSRFrameMars::RegisterServer()
{
    TraceFunctEnter("CSRFrameMars::RegisterServer");
    DWORD    dwRet = 0;
    HRESULT  hr;

    hr = _Module.UpdateRegistryFromResource(IDR_RSTRUI, TRUE);
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "CComModule::UpdateRegistryFromResource failed, err=%l", hr);
        dwRet = hr;
        goto Exit;
    }
    hr = _Module.RegisterServer(TRUE);
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "CComModule::RegisterServer failed, err=%l", hr);
        dwRet = hr;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( dwRet );
}

DWORD  CSRFrameMars::UnregisterServer()
{
    TraceFunctEnter("CSRFrameMars::UnregisterServer");
    DWORD    dwRet = 0;
    HRESULT  hr;

    hr = _Module.UpdateRegistryFromResource(IDR_RSTRUI, FALSE);
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "CComModule::UpdateRegistryFromResource failed, err=%l", hr);
        dwRet = hr;
        goto Exit;
    }
    hr = _Module.UnregisterServer(TRUE);
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "CComModule::UnregisterServer failed, err=%l", hr);
        dwRet = hr;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( dwRet );
}

BOOL  CSRFrameMars::InitInstance( HINSTANCE hInst )
{
    TraceFunctEnter("CSRFrameMars::InitInstance");
    BOOL     fRet = TRUE;
    HRESULT  hr;

    //BUGBUG - Is this necessary???
    g_hInst = hInst;

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    // we're using apartment threading model
    hr = ::CoInitialize(NULL);
#endif
    if (FAILED(hr))
    {
        FatalTrace(TRACE_ID, "Cannot initialize COM, hr=%l", hr);
        fRet = FALSE;
        goto Exit;
    }

    _Module.Init(ObjectMap, hInst, &LIBID_RestoreUILib);

Exit:
    TraceFunctLeave();
    return( fRet );
}

BOOL  CSRFrameMars::ExitInstance()
{
    TraceFunctEnter("CSRFrameMars::ExitInstance");

    _Module.Term();
    ::CoUninitialize();

    TraceFunctLeave();
    return( TRUE );
}

void  CSRFrameMars::Release()
{
    TraceFunctEnter("CSRFrameMars::Release");

    // clean up...
    delete this;

    TraceFunctLeave();
}

int  CSRFrameMars::RunUI( LPCWSTR szTitle, int nStart )
{
    TraceFunctEnter("CSRFrameMars::RunUI");
    int      nRet = 0;
    HRESULT  hr;
    RECT     rc = { 0, 0, 0, 0 };

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
    _ASSERTE(SUCCEEDED(hRes));
    hr = CoResumeClassObjects();
#else
    // we're using apartment threading model
    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hr));

    if ( !g_pRstrMgr->SetStartMode( nStart ) )
    {
        nRet = E_FAIL;
        goto Exit;
    }

    //if ( g_cRestoreShell.Create( NULL, rc ) == NULL )
    //{
    //    nRet = E_FAIL;
    //    goto Exit;
    //}

    nRet = InvokeMARS( szTitle );
    if ( nRet != 0 )
        goto Exit;

    _Module.RevokeClassObjects();

Exit:
    TraceFunctLeave();
    return( nRet );
}


/////////////////////////////////////////////////////////////////////////////
// CSRFrameMars operations - internal

BOOL  CSRFrameMars::CleanUp()
{
    return( TRUE );
}

DWORD  CSRFrameMars::InvokeMARS( LPCWSTR szTitle )
{
    TraceFunctEnter("CSRFrameMars::InvokeMARS");
    DWORD               dwRet = 0;
    LPCWSTR             cszErr;
    WCHAR               szMarsPath[MAX_PATH+1];
    WCHAR               szSRPath[MAX_PATH+1];
    HMODULE             hMars;
    PFNMARSTHREADPROC   pfnMarsThreadProc;
    MARSTHREADPARAM     sMTP;
    WCHAR               szMainWndTitle[MAX_PATH+1];
    CComBSTR            bstrTitle, bstrSRPath;
    CSRMarsHost_Object  *pMH = NULL;
    HRESULT             hr;

    ::GetWindowsDirectory( szMarsPath, MAX_PATH );
    ::lstrcat( szMarsPath, L"\\pchealth\\helpctr\\binaries\\pchshell.dll" );
    hMars = ::LoadLibrary( szMarsPath );

    if ( hMars == NULL )
    {
#ifdef DEBUG
        MessageBox( NULL, szMarsPath, L"LoadLibrary failed", MB_OK );
#endif
        dwRet = ::GetLastError();
        cszErr = ::GetSysErrStr( dwRet );
        ErrorTrace(TRACE_ID, "::LoadLibrary('marscore.dll') failed - %s", cszErr);
        goto Exit;
    }

    pfnMarsThreadProc = (PFNMARSTHREADPROC)::GetProcAddress( hMars, (LPCSTR)MAKEINTRESOURCE(ORD_MARSTHREADPROC) );
    if ( pfnMarsThreadProc == NULL )
    {
#ifdef DEBUG
        MessageBox( NULL, L"Unknown", L"GetProcAddress failed", MB_OK );
#endif
        dwRet = ::GetLastError();
        cszErr = ::GetSysErrStr( dwRet );
        ErrorTrace(TRACE_ID, "::GetProcAddress failed - %s", cszErr);
        goto Exit;
    }

    bstrTitle = szTitle;
    ::GetModuleFileName( NULL, szSRPath, MAX_PATH );
    ::PathRemoveFileSpec( szSRPath );
    ::PathAppend( szSRPath, L"srframe.mmf" );
    bstrSRPath = szSRPath;

    ::ZeroMemory( &sMTP, sizeof(sMTP) );
    sMTP.cbSize       = sizeof(sMTP);
    sMTP.hIcon        = NULL;
    sMTP.nCmdShow     = SW_HIDE;
    sMTP.dwFlags      = MTF_MANAGE_WINDOW_SIZE;
    sMTP.pwszTitle    = bstrTitle;
    sMTP.pwszPanelURL = bstrSRPath;

    // Create an UI Instance.
    hr = CSRMarsHost_Object::CreateInstance( &pMH );
    if ( FAILED(hr) )
    {
#ifdef DEBUG
        MessageBox( NULL, szMarsPath, L"CreateInstance of MarsHost failed", MB_OK );
#endif
        dwRet = hr;
        ErrorTrace(TRACE_ID, "CHCPMarsHost_Object::CreateInstance failed, hr=%u", hr);
        goto Exit;
    }

    //
    // Add a reference count
    //
    pMH->AddRef();

    dwRet = pfnMarsThreadProc( pMH, &sMTP );

    if ( pMH )
        pMH->Release();

    if ( hMars )
        ::FreeLibrary( hMars );

Exit:
    TraceFunctLeave();
    return( dwRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\htmlui.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    htmlui.cpp

Abstract:
    This file contains the implementation of the CRestoreShell class, which
    provide several methods to be used by HTML scripts. This class wrappes the
    new CRestoreManager class.

Revision History:
    Seong Kook Khang (SKKhang)  10/08/99
        created
    Seong Kook Khang (SKKhang)  05/10/00
        Renamed from rstrshl.cpp to htmlui.cpp.
        New architecture for Whistler, now CRestoreShell is merely a dummy
        ActiveX control, wrapping the new CRestoreManager class. Most of the
        real functionalities were moved into CRestoreManager.

******************************************************************************/

#include "stdwin.h"
#include "stdatl.h"
#include "resource.h"
#include "rstrpriv.h"
#include "srui_htm.h"
#include "rstrmgr.h"
#include "rstrshl.h"
#include "rstrmap.h"
#include "winsta.h"

#define MAX_DATETIME_STR  256

#define PROGRESSBAR_INITIALIZING_MAXVAL     30
#define PROGRESSBAR_AFTER_INITIALIZING      30
#define PROGRESSBAR_AFTER_RESTORE_MAP       40
#define PROGRESSBAR_AFTER_RESTORE           100

#define CLIWND_RESTORE_TIMER_ID             1
#define CLIWND_RESTORE_TIMER_TIME           500


const IID IID_IMarsHost = { 0xCC6FFEB0,0xE379,0x427a,{0x98,0x10,0xA1,0x6B,0x7A,0x82,0x6A,0x89 }};

static LPCWSTR s_cszHelpAssistant = L"HelpAssistant";
#define HELPASSISTANT_STRINGID 114


BOOL  ConvSysTimeToVariant( PSYSTEMTIME pst, VARIANT *pvar )
{
    TraceFunctEnter("ConvSysTimeToVariant");
    BOOL  fRet = FALSE;

    if ( !::SystemTimeToVariantTime( pst, &V_DATE(pvar) ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::SystemTimeToVariantTime failed - %ls", cszErr);
        goto Exit;
    }
    V_VT(pvar) = VT_DATE;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

BOOL  ConvVariantToSysTime( VARIANT var, PSYSTEMTIME pst )
{
    TraceFunctEnter("ConvVariantToSysTime");
    BOOL  fRet = FALSE;

    if ( !::VariantTimeToSystemTime( V_DATE(&var), pst ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::VariantTimeToSystemTime failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

inline VARIANT_BOOL  ConvBoolToVBool( BOOL fVal )
{
    return( fVal ? VARIANT_TRUE : VARIANT_FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreShell construction

CRestoreShell::CRestoreShell()
{
    m_fFormInitialized = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreShell - IRestoreShell restore points enumerator

STDMETHODIMP
CRestoreShell::Item( INT nIndex, IRestorePoint** ppRP )
{
    TraceFunctEnter("CRestoreShell::Item");
    HRESULT            hr = S_OK;
    SRestorePointInfo  *pRPI;
    CRPIObj            *pRPIObj;

    VALIDATE_INPUT_ARGUMENT(ppRP);
    *ppRP = NULL;

    if ( nIndex < 0 || nIndex >= g_pRstrMgr->GetRPICount() )
    {
        ErrorTrace(TRACE_ID, "Invalid Argument, out of range");
        hr = E_INVALIDARG;
        goto Exit;
    }

    pRPI = g_pRstrMgr->GetRPI( nIndex );
    if ( pRPI == NULL )
    {
        hr = S_FALSE;
        goto Exit;
    }

    hr = CRPIObj::CreateInstance( &pRPIObj );
    if ( hr != S_OK || pRPIObj == NULL )
    {
        ErrorTrace(TRACE_ID, "Cannot create RestorePointObject Instance, hr=%d", hr);
        if ( hr == S_OK )
            hr = E_FAIL;
        goto Exit;
    }
    hr = pRPIObj->HrInit( pRPI );
    if ( FAILED(hr) )
        goto Exit;
    pRPIObj->AddRef();  // CreateInstance doesn't do this

    hr = pRPIObj->QueryInterface( IID_IRestorePoint, (void**)ppRP );
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "QI failed, hr=%d", hr);
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return hr;
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_Count( INT *pnCount )
{
    TraceFunctEnter("CRestoreShell::get_Count");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnCount);
    *pnCount = g_pRstrMgr->GetRPICount();

Exit:
    TraceFunctLeave();
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreShell - IRestoreShell properties

STDMETHODIMP
CRestoreShell::get_CurrentDate( VARIANT *pvarDate )
{
    TraceFunctEnter("CRestoreShell::get_CurrentDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  stToday;

    VALIDATE_INPUT_ARGUMENT(pvarDate);
    g_pRstrMgr->GetToday( &stToday );
    if ( !ConvSysTimeToVariant( &stToday, pvarDate ) )
        goto Exit;
/*
    if ( ::SystemTimeToVariantTime( &stToday, &V_DATE(pvarDate) ) == 0 )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::SystemTimeToVariantTime failed - %ls", cszErr);
        hr = E_FAIL;
        goto Exit;
    }
    V_VT(pvarDate) = VT_DATE;
*/

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return hr;
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_FirstDayOfWeek( INT *pnFirstDay )
{
    TraceFunctEnter("CRestoreShell::get_LocaleFirstDay");
    HRESULT  hr = S_OK;
    int      nFirstDay;

    VALIDATE_INPUT_ARGUMENT(pnFirstDay);
    *pnFirstDay = 0;
    nFirstDay = g_pRstrMgr->GetFirstDayOfWeek();
    if ( nFirstDay < 0 || nFirstDay > 6 )
    {
        hr = E_FAIL;
        goto Exit;
    }
    if ( nFirstDay == 6 )
        *pnFirstDay = 0;
    else
        *pnFirstDay = nFirstDay + 1;

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_IsSafeMode( VARIANT_BOOL *pfIsSafeMode )
{
    TraceFunctEnter("CRestoreShell::get_IsSafeMode");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfIsSafeMode);
    *pfIsSafeMode = ConvBoolToVBool( g_pRstrMgr->GetIsSafeMode() );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_IsUndo( VARIANT_BOOL *pfIsUndo )
{
    TraceFunctEnter("CRestoreShell::get_IsUndo");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfIsUndo);
    *pfIsUndo = ConvBoolToVBool( g_pRstrMgr->GetIsUndo() );

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::put_IsUndo( VARIANT_BOOL fIsUndo )
{
    TraceFunctEnter("CRestoreShell::put_IsUndo");

    g_pRstrMgr->SetIsUndo( fIsUndo );

    TraceFunctLeave();
    return( S_OK );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_LastRestore( INT *pnLastRestore )
{
    TraceFunctEnter("CRestoreShell::get_LastRestore");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnLastRestore);
    //Initialize();
    *pnLastRestore = g_pRstrMgr->GetLastRestore();

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_MainOption( INT *pnMainOption )
{
    TraceFunctEnter("CRestoreShell::get_MainOption");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnMainOption);
    *pnMainOption = g_pRstrMgr->GetMainOption();

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::put_MainOption( INT nMainOption )
{
    TraceFunctEnter("CRestoreShell::put_MainOption");
    HRESULT hr = S_OK;

    if ( !g_pRstrMgr->SetMainOption( nMainOption ) )
        hr = E_INVALIDARG;

    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_ManualRPName( BSTR *pbstrManualRP )
{
    TraceFunctEnter("CRestoreShell::get_ManualRPName");
    HRESULT  hr = S_OK;
    LPCWSTR  cszRPName;

    VALIDATE_INPUT_ARGUMENT(pbstrManualRP);
    cszRPName = g_pRstrMgr->GetManualRPName();
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrManualRP, cszRPName );

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::put_ManualRPName( BSTR bstrManualRP )
{
    TraceFunctEnter("CRestoreShell::put_ManualRPName");

    g_pRstrMgr->SetManualRPName( bstrManualRP );

    TraceFunctLeave();
    return( S_OK );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_MaxDate( VARIANT *pvarDate )
{
    TraceFunctEnter("CRestoreShell::get_MaxDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  stMax;

    VALIDATE_INPUT_ARGUMENT(pvarDate);
    g_pRstrMgr->GetMaxDate( &stMax );
    if ( !ConvSysTimeToVariant( &stMax, pvarDate ) )
        goto Exit;

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::get_MinDate( VARIANT *pvarDate )
{
    TraceFunctEnter("CRestoreShell::get_MinDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  stMin;

    VALIDATE_INPUT_ARGUMENT(pvarDate);
    g_pRstrMgr->GetMinDate( &stMin );
    if ( !ConvSysTimeToVariant( &stMin, pvarDate ) )
        goto Exit;

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_RealPoint( INT *pnPoint )
{
    TraceFunctEnter("CRestoreShell::get_RealPoint");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnPoint);
    *pnPoint = g_pRstrMgr->GetRealPoint();

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_RenamedFolders( IRenamedFolders **ppList )
{
    TraceFunctEnter("CRestoreShell::get_RenamedFolders");
    HRESULT  hr = S_OK;
    CRFObj   *pRF;

    VALIDATE_INPUT_ARGUMENT(ppList);
    hr = CComObject<CRenamedFolders>::CreateInstance( &pRF );
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "Cannot create CRenamedFolders object, hr=0x%08X", hr);
        goto Exit;
    }
    hr = pRF->QueryInterface( IID_IRenamedFolders, (void**)ppList );
    if ( FAILED(hr) )
    {
        ErrorTrace(TRACE_ID, "Cannot QI IRenamedFolders, hr=0x%08X", hr);
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return hr;
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_RestorePtSelected( VARIANT_BOOL *pfRPSel )
{
    TraceFunctEnter("CRestoreShell::get_RestorePtSelected");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfRPSel);

    *pfRPSel = ConvBoolToVBool( g_pRstrMgr->GetIsRPSelected() );

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::put_RestorePtSelected( VARIANT_BOOL fRPSel )
{
    TraceFunctEnter("CRestoreShell::put_RestorePtSelected");

    g_pRstrMgr->SetIsRPSelected( fRPSel );

    TraceFunctLeave();
    return( S_OK );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_SelectedDate( VARIANT *pvarDate )
{
    TraceFunctEnter("CRestoreShell::get_SelectedDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  stSel;
    //DATE        dateSel;

    VALIDATE_INPUT_ARGUMENT(pvarDate);
    g_pRstrMgr->GetSelectedDate( &stSel );
    if ( !ConvSysTimeToVariant( &stSel, pvarDate ) )
        goto Exit;

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::put_SelectedDate( VARIANT varDate )
{
    TraceFunctEnter("CRestoreShell::put_SelectedDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  stSel;

    if ( !ConvVariantToSysTime( varDate, &stSel ) )
        goto Exit;
    g_pRstrMgr->SetSelectedDate( &stSel );

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return hr;
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_SelectedName( BSTR *pbstrName )
{
    TraceFunctEnter("CRestoreShell::get_SelectedName");
    HRESULT  hr = S_OK;
    LPCWSTR  cszName;

    VALIDATE_INPUT_ARGUMENT(pbstrName);
    cszName = g_pRstrMgr->GetSelectedName();
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrName, cszName );

Exit:
    TraceFunctLeave();
    return hr;
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_SelectedPoint( INT *pnPoint )
{
    TraceFunctEnter("CRestoreShell::get_SelectedPoint");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnPoint);
    *pnPoint = g_pRstrMgr->GetSelectedPoint();

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestoreShell::put_SelectedPoint( INT nPoint )
{
    TraceFunctEnter("CRestoreShell::put_SelectedPoint");
    HRESULT  hr = S_OK;

    if ( nPoint < 0 || nPoint >= g_pRstrMgr->GetRPICount() )
    {
        ErrorTrace(TRACE_ID, "Index is out of range");
        hr = E_INVALIDARG;
        goto Exit;
    }
    if ( !g_pRstrMgr->SetSelectedPoint( nPoint ) )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_SmgrUnavailable( VARIANT_BOOL *pfSmgr )
{
    TraceFunctEnter("CRestoreShell::get_SmgrUnavailable");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfSmgr);
    *pfSmgr = ConvBoolToVBool( g_pRstrMgr->GetIsSmgrAvailable() );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_StartMode( INT *pnMode )
{
    TraceFunctEnter("CRestoreShell::get_StartMode");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnMode);
    *pnMode = g_pRstrMgr->GetStartMode();

Exit:
    TraceFunctLeave();
    return hr;
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_UsedDate( VARIANT *pvarDate )
{
    TraceFunctEnter("CRestoreShell::get_UsedDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  stDate;
    //DATE        dateDate;

    VALIDATE_INPUT_ARGUMENT(pvarDate);
    g_pRstrMgr->GetUsedDate( &stDate );
    if ( !ConvSysTimeToVariant( &stDate, pvarDate ) )
        goto Exit;

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::get_UsedName( BSTR *pbstrName )
{
    TraceFunctEnter("CRestoreShell::get_UsedDate");
    HRESULT  hr = S_OK;
    LPCWSTR  cszName;

    VALIDATE_INPUT_ARGUMENT(pbstrName);
    cszName = g_pRstrMgr->GetUsedName();
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrName, cszName );

Exit:
    TraceFunctLeave();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreShell - IRestoreShell properties - HTML UI Specific

STDMETHODIMP
CRestoreShell::get_CanNavigatePage( VARIANT_BOOL *pfCanNavigatePage )
{
    TraceFunctEnter("CRestoreShell::get_CanNavigatePage");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfCanNavigatePage);
    *pfCanNavigatePage = ConvBoolToVBool( g_pRstrMgr->GetCanNavigatePage() );

Exit:
    TraceFunctLeave();
    return( S_OK );
}

STDMETHODIMP
CRestoreShell::put_CanNavigatePage( VARIANT_BOOL fCanNavigatePage )
{
    TraceFunctEnter("CRestoreShell::put_CanNavigatePage");

    g_pRstrMgr->SetCanNavigatePage( fCanNavigatePage );

    TraceFunctLeave();
    return( S_OK );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreShell - IRestoreShell methods

STDMETHODIMP
CRestoreShell::BeginRestore( VARIANT_BOOL *pfBeginRestore )
{
    TraceFunctEnter("CRestoreShell::BeginRestore");
    HRESULT  hr = S_OK;
    BOOL     fRes;

    VALIDATE_INPUT_ARGUMENT(pfBeginRestore);

    fRes = g_pRstrMgr->BeginRestore();
    *pfBeginRestore = ConvBoolToVBool( fRes );

Exit:
    TraceFunctLeave();
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CRestoreShell - IRestoreShell methods

STDMETHODIMP
CRestoreShell::CheckRestore( VARIANT_BOOL *pfCheckRestore )
{
    TraceFunctEnter("CRestoreShell::BeginRestore");
    HRESULT  hr = S_OK;
    BOOL     fRes;

    VALIDATE_INPUT_ARGUMENT(pfCheckRestore);

    fRes = g_pRstrMgr->CheckRestore(FALSE); // show UI if any errors found
    *pfCheckRestore = ConvBoolToVBool( fRes );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

//
// This method is called only from the HTML code to decide whether to
// shutdown or not, and the external.window.close() is called to shutdown
// as sending a WM_CLOSE message to Mars causes problems
//
STDMETHODIMP
CRestoreShell::Cancel( VARIANT_BOOL *pfAbort )
{
    TraceFunctEnter("CRestoreShell::Cancel");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfAbort);
    *pfAbort = ConvBoolToVBool( g_pRstrMgr->Cancel() );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::CancelRestorePoint()
{
    TraceFunctEnter("CRestoreShell::CancelRestorePoint");
    HRESULT  hr = E_FAIL;

    if ( !g_pRstrMgr->CancelRestorePoint() )
        goto Exit;

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/*******************************************************************************/

STDMETHODIMP
CRestoreShell::CompareDate( VARIANT varDate1, VARIANT varDate2, INT *pnCmp )
{
    TraceFunctEnter("CRestoreShell::CompareDate");
    HRESULT  hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnCmp);
    VALIDATE_INPUT_VARIANT(varDate1, VT_DATE);
    VALIDATE_INPUT_VARIANT(varDate2, VT_DATE);
    *pnCmp = (long)V_DATE(&varDate1) - (long)V_DATE(&varDate2);

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::CreateRestorePoint( VARIANT_BOOL *pfSucceeded )
{
    TraceFunctEnter("CRestoreShell::CreateRestorePoint");
    HRESULT  hr = S_OK;
    BOOL     fRes;

    VALIDATE_INPUT_ARGUMENT(pfSucceeded);

    fRes = g_pRstrMgr->CreateRestorePoint();
    *pfSucceeded = ConvBoolToVBool( fRes );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::DisableFIFO( void )
{
    TraceFunctEnter("CRestoreShell::DisableFIFO");
    HRESULT  hr = S_OK;

    if ( !g_pRstrMgr->DisableFIFO() )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( hr );
}


/******************************************************************************/

STDMETHODIMP
CRestoreShell::EnableFIFO( void )
{
    TraceFunctEnter("CRestoreShell::EnableFIFO");
    HRESULT  hr = S_OK;

    if ( !g_pRstrMgr->EnableFIFO() )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::FormatDate( VARIANT varDate, VARIANT_BOOL fLongFmt, BSTR *pbstrDate )
{
    TraceFunctEnter("CRestoreShell::FormatDate");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  st;
    CSRStr      str;

    VALIDATE_INPUT_ARGUMENT(pbstrDate);
    VALIDATE_INPUT_VARIANT(varDate, VT_DATE);
    if ( !ConvVariantToSysTime( varDate, &st ) )
        goto Exit;
    if ( !g_pRstrMgr->FormatDate( &st, str, fLongFmt ) )
        goto Exit;
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrDate, str );

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::FormatLowDiskMsg( BSTR bstrFmt, BSTR *pbstrMsg )
{
    TraceFunctEnter("CRestoreShell::FormatLowDiskMsg");
    HRESULT  hr = E_FAIL;
    CSRStr   str;

    VALIDATE_INPUT_ARGUMENT(pbstrMsg);
    if ( !g_pRstrMgr->FormatLowDiskMsg( (WCHAR *)bstrFmt, str ) )
        goto Exit;
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrMsg, str );

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::FormatTime( VARIANT varTime, BSTR *pbstrTime )
{
    TraceFunctEnter("CRestoreShell::FormatTime");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  st;
    CSRStr      str;

    VALIDATE_INPUT_ARGUMENT(pbstrTime);
    VALIDATE_INPUT_VARIANT(varTime, VT_DATE);
    if ( !ConvVariantToSysTime( varTime, &st ) )
        goto Exit;
    if ( !g_pRstrMgr->FormatTime( &st, str ) )
        goto Exit;
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrTime, str );

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::GetLocaleDateFormat( VARIANT varDate, BSTR bstrFormat, BSTR *pbstrDate )
{
    TraceFunctEnter("CRestoreShell::GetLocaleDateFormat");
    HRESULT     hr = E_FAIL;
    SYSTEMTIME  st;
    CSRStr      str;

    VALIDATE_INPUT_ARGUMENT(pbstrDate);
    VALIDATE_INPUT_VARIANT(varDate, VT_DATE);
    if ( !ConvVariantToSysTime( varDate, &st ) )
        goto Exit;
    if ( !g_pRstrMgr->GetLocaleDateFormat( &st, bstrFormat, str ) )
        goto Exit;
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrDate, str );

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::GetYearMonthStr( INT nYear, INT nMonth, BSTR *pbstrYearMonth )
{
    TraceFunctEnter("CRestoreShell::GetYearMonthStr");
    HRESULT  hr = E_FAIL;
    CSRStr   str;

    VALIDATE_INPUT_ARGUMENT(pbstrYearMonth);
    if ( !g_pRstrMgr->GetYearMonthStr( nYear, nMonth, str ) )
        goto Exit;
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrYearMonth, str );

    hr = S_OK;
Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::InitializeAll()
{
    TraceFunctEnter("CRestoreShell::InitializeAll");
    HRESULT  hr = S_OK;

    if ( !g_pRstrMgr->InitializeAll() )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::Restore( OLE_HANDLE hwndProgress )
{
    TraceFunctEnter("CRestoreShell::Restore");
    HRESULT  hr = S_OK;

    if ( !g_pRstrMgr->Restore( (HWND)hwndProgress ) )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::SetFormSize( INT nWidth, INT nHeight )
{
    TraceFunctEnter("CRestoreShell::SetFormSize");
    HWND      hwndFrame;
    CWindow   cWnd;
    RECT      rc;
    HICON     hIconFrame;

    //
    // Cannot initialize more than once
    //
    if ( m_fFormInitialized )
        goto Exit;

    hwndFrame = g_pRstrMgr->GetFrameHwnd();
    if ( hwndFrame == NULL )
    {
        ErrorTrace(TRACE_ID, "hwndFrame is NULL");
        goto Exit;
    }
    cWnd.Attach( hwndFrame );
    cWnd.ModifyStyle( WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SIZEBOX, 0 );

    hIconFrame = (HICON)::LoadImage( _Module.GetResourceInstance(),
                                     MAKEINTRESOURCE(IDR_RSTRUI),
                                     IMAGE_ICON, 0, 0, LR_DEFAULTSIZE );
    if ( hIconFrame != NULL )
        cWnd.SetIcon( hIconFrame, TRUE );
    hIconFrame = (HICON)::LoadImage( _Module.GetResourceInstance(),
                                     MAKEINTRESOURCE(IDR_RSTRUI),
                                     IMAGE_ICON,
                                     ::GetSystemMetrics(SM_CXSMICON),
                                     ::GetSystemMetrics(SM_CYSMICON),
                                     LR_DEFAULTSIZE );
    if ( hIconFrame != NULL )
        cWnd.SetIcon( hIconFrame, FALSE );

    rc.left   = 0;
    rc.top    = 0;
    rc.right  = nWidth;
    rc.bottom = nHeight;
    ::AdjustWindowRectEx( &rc, cWnd.GetStyle(), FALSE, cWnd.GetExStyle() );
    cWnd.SetWindowPos(
                      NULL,
                      0,
                      0,
                      rc.right-rc.left,
                      rc.bottom-rc.top,
                      SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOZORDER);

    cWnd.CenterWindow(::GetDesktopWindow()); // ignore error return if any

    cWnd.ShowWindow(SW_SHOW);

    m_fFormInitialized = TRUE ;

Exit:
    TraceFunctLeave();
    return( S_OK );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::ShowMessage( BSTR bstrMsg )
{
    TraceFunctEnter("CRestoreShell::ShowMessage");
    WCHAR   szTitle[MAX_STR_TITLE];
    CSRStr  strMsg = bstrMsg;

    PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );
    ::MessageBox( g_pRstrMgr->GetFrameHwnd(), strMsg, szTitle, MB_OK | MB_ICONINFORMATION );

    TraceFunctLeave();
    return( S_OK );
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::CanRunRestore( VARIANT_BOOL *pfSucceeded )
{
    TraceFunctEnter("CRestoreShell::CanRunRestore");
    HRESULT  hr = S_OK;
    BOOL     fRes;
    VALIDATE_INPUT_ARGUMENT(pfSucceeded);
    
    fRes = g_pRstrMgr->CanRunRestore( FALSE );
    *pfSucceeded = ConvBoolToVBool( fRes );
Exit:
    TraceFunctLeave();
    return( hr );
}

/*
// check if this user is an RA Help Assistant

BOOL
IsRAUser(HANDLE hServer , PLOGONID pId, LPWSTR pszHelpAsst)
{
    TENTER("IsRAUser");
    
    WINSTATIONINFORMATION Info;
    ULONG Length;
    ULONG LogonId;
    BOOL  fRet = FALSE;

    
    LogonId = pId->LogonId;

    if ( !WinStationQueryInformation( hServer,
                                      LogonId,
                                      WinStationInformation,
                                      &Info,
                                      sizeof(Info),
                                      &Length ) )
    {
        trace(0, "! WinStationQueryInformation : %ld", GetLastError());
        goto done;
    }

    trace(0, "Logged user: %S", Info.UserName);
    
    if (0 == _wcsnicmp(Info.UserName, pszHelpAsst, lstrlen(pszHelpAsst)))
        fRet = TRUE;

done:
    TLEAVE();
    return fRet;
}
*/

/******************************************************************************/

//  --------------------------------------------------------------------------
//  GetLoggedOnUserCount
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns the count of logged on users on this machine. Ripped
//              straight out of shtdndlg.c in msgina.
//
//  History:    2000-03-29  vtan        created
//  --------------------------------------------------------------------------
int GetLoggedOnUserCount(void)
{
    int         iCount;
    HANDLE      hServer;
    PLOGONID    pLogonID, pLogonIDs;
    ULONG       ul, ulEntries;
    WCHAR       szHelpAsst[50];
    DWORD       dwErr;

    TENTER("GetLoggedOnUserCount");

/*    
    // get the "HelpAssistant" string from the resource exe
    dwErr = SRLoadString(L"sessmgr.exe", HELPASSISTANT_STRINGID, szHelpAsst, sizeof(szHelpAsst));
    if (dwErr != ERROR_SUCCESS)
    {
        trace(0, "! SRLoadString : %ld", dwErr);
        lstrcpy(szHelpAsst, s_cszHelpAssistant);
    }

    trace(0, "Help Asst string: %S", szHelpAsst);
*/
    
    iCount = 0;
    
    //  Open a connection to terminal services and get the number of sessions.
    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(
SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        if (WinStationEnumerate(hServer, &pLogonIDs, &ulEntries))
        {
            //  Iterate the sessions looking for active and disconnected sessions only.
            //  Then match the user name and domain (case INsensitive) for a result.
            for (ul = 0, pLogonID = pLogonIDs; ul < ulEntries; ++ul, ++pLogonID)
            {
                if ((pLogonID->State == State_Active) || (pLogonID->State ==
                                                          State_Disconnected) || (pLogonID->State == State_Shadow))
                {
                    // don't count RA Help Assistant user if present

                    if (FALSE == WinStationIsHelpAssistantSession(SERVERNAME_CURRENT, pLogonID->LogonId))
                        ++iCount;
                    else
                        trace(0, "RA session present - not counting");
                        
                }
            }

            //  Free any resources used.

            (BOOLEAN)WinStationFreeMemory(pLogonIDs);
        }

        (BOOLEAN)WinStationCloseServer(hServer);
    }

    TLEAVE();
    
    //  Return result.
    return(iCount);
}

/******************************************************************************/

STDMETHODIMP
CRestoreShell::DisplayOtherUsersWarning()
{
    TraceFunctEnter("CRestoreShell::DisplayOtherUsersWarning");
    HRESULT  hr = S_OK;
    WCHAR            szTitle[MAX_STR_TITLE];
    WCHAR            szMsg[MAX_STR_MSG];
    WCHAR            szMsg1[MAX_STR_MSG];
    WCHAR            szMsg2[MAX_STR_MSG];
    DWORD            dwUsersLoggedIn,dwCount,dwError;
    
    dwUsersLoggedIn = GetLoggedOnUserCount();
    
    if (dwUsersLoggedIn <= 1)
    {
         // there are no other users
        goto cleanup;
    }

     // there are other users - display warning
    dwCount=PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );
    if (dwCount==0)
    {
        dwError = GetLastError();
        ErrorTrace(0, "Loading IDS_RESTOREUI_TITLE failed %d",dwError);
        goto cleanup;
    }
    dwCount=PCHLoadString(IDS_ERR_OTHER_USERS_LOGGED_ON1, szMsg1, MAX_STR_MSG);
    if (dwCount==0)
    {
        dwError = GetLastError();
        ErrorTrace(0, "Loading IDS_ERR_OTHER_USERS_LOGGED_ON1 failed %d",
                   dwError);
        goto cleanup;
    }        
    dwCount=PCHLoadString(IDS_ERR_OTHER_USERS_LOGGED_ON2, szMsg2, MAX_STR_MSG);
    if (dwCount==0)
    {
        dwError = GetLastError();
        ErrorTrace(0, "Loading IDS_ERR_OTHER_USERS_LOGGED_ON2 failed %d",
                   dwError);
        goto cleanup;
    }                
    
    ::wsprintf( szMsg, L"%s %d%s", szMsg1,dwUsersLoggedIn -1, szMsg2 );
    ::MessageBox( g_pRstrMgr->GetFrameHwnd(),
                  szMsg,
                  szTitle,
                  MB_OK | MB_ICONWARNING | MB_DEFBUTTON2);
    
cleanup:
    TraceFunctLeave();
    return( hr );
}

//this returns TRUE if any move fileex entries exist
STDMETHODIMP
CRestoreShell::DisplayMoveFileExWarning(VARIANT_BOOL *pfSucceeded)
{
    TraceFunctEnter("CRestoreShell::DisplayOtherUsersWarning");
    HRESULT  hr = S_OK;
    DWORD    dwType, cbData, dwRes;
    BOOL     fRes;
    
    VALIDATE_INPUT_ARGUMENT(pfSucceeded);
    fRes = FALSE;

/*    
    // Check if MoveFileEx entries exist
    dwRes = ::SHGetValue( HKEY_LOCAL_MACHINE,
                          STR_REGPATH_SESSIONMANAGER,
                          STR_REGVAL_MOVEFILEEX,
                          &dwType,
                          NULL,
                          &cbData );
    if ( dwRes == ERROR_SUCCESS )
    {
        if ( cbData > 2* sizeof(WCHAR))
        {
            fRes = TRUE;
            ErrorTrace(0, "MoveFileEx entries exist...");
            ::ShowSRErrDlg( IDS_ERR_SR_MOVEFILEEX_EXIST );
        }
    }
*/

    *pfSucceeded = ConvBoolToVBool( fRes );    

Exit:
    TraceFunctLeave();
    return( hr );
}


//this returns TRUE if any move fileex entries exist
STDMETHODIMP
CRestoreShell::WasLastRestoreFromSafeMode(VARIANT_BOOL *pfSucceeded)
{
    TraceFunctEnter("CRestoreShell::WasLastRestoreFromSafeMode");
    HRESULT  hr = S_OK;
    BOOL     fRes;
    
    VALIDATE_INPUT_ARGUMENT(pfSucceeded);
    fRes = TRUE;
    
    fRes = ::WasLastRestoreInSafeMode();
    
    *pfSucceeded = ConvBoolToVBool( fRes );    

Exit:
    TraceFunctLeave();
    return( hr );
}
/***************************************************************************/


//
// END OF NEW CODE
//

// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\marshost.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    MarsHost.cpp

Abstract:
    Initialization of mars

Revision History:
    Anand Arvind (aarvind)      2000-01-05
        created
    Seong Kook Khang (SKKhang)  05/10/00
        Clean up, merge with MarsEvnt.cpp, etc. for Whistler.

******************************************************************************/

#include "stdwin.h"
#include "stdatl.h"
#include "rstrpriv.h"
#include "rstrmgr.h"
#include "MarsHost.h"


/////////////////////////////////////////////////////////////////////////////
//
// CSRWebBrowserEvents
//
/////////////////////////////////////////////////////////////////////////////

CSRWebBrowserEvents::CSRWebBrowserEvents()
{
}

CSRWebBrowserEvents::~CSRWebBrowserEvents()
{
    Detach();
}

void CSRWebBrowserEvents::Attach( /*[in]*/ IWebBrowser2* pWB )
{
    Detach();

    m_pWB2 = pWB;
    if( m_pWB2 )
    {
        CSRWebBrowserEvents_DispWBE2::DispEventAdvise( m_pWB2 );
    }
}

void CSRWebBrowserEvents::Detach()
{
    if( m_pWB2 )
    {
        CSRWebBrowserEvents_DispWBE2::DispEventUnadvise( m_pWB2 );
        m_pWB2.Release();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSRWebBrowserEvents - DWebBrowserEvents2 event methods

void __stdcall CSRWebBrowserEvents::BeforeNavigate2( IDispatch *pDisp,
                                                     VARIANT *URL,
                                                     VARIANT *Flags,
                                                     VARIANT *TargetFrameName,
                                                     VARIANT *PostData,
                                                     VARIANT *Headers,
                                                     VARIANT_BOOL *Cancel )
{
    //
    // We control navigation with the CanNavigatePage but for all help links
    // navigation should be auto-enabled. All Help links have a OnLink_ as
    // part of the URL so if this is contained in the URL
    //
    if( V_BSTR(URL) != NULL && wcsstr( V_BSTR(URL), L"OnLink_") != NULL )
    {
        *Cancel = VARIANT_FALSE ;
    }
    else
    {
        if ( g_pRstrMgr->GetCanNavigatePage() )
        {
            *Cancel = VARIANT_FALSE ;
        }
        else
        {
            *Cancel = VARIANT_TRUE ;
        }
    };
}

void __stdcall CSRWebBrowserEvents::NewWindow2( IDispatch **ppDisp,
                                                VARIANT_BOOL *Cancel )
{
}

void __stdcall CSRWebBrowserEvents::NavigateComplete2( IDispatch *pDisp,
                                                       VARIANT *URL )
{

}

void __stdcall CSRWebBrowserEvents::DocumentComplete( IDispatch *pDisp,
                                                      VARIANT *URL )
{

}


/////////////////////////////////////////////////////////////////////////////
//
// CSRMarsHost
//
/////////////////////////////////////////////////////////////////////////////

//#define PANEL_NAVBAR   L"NavBar"
#define PANEL_CONTENTS L"Contents"

CSRMarsHost::CSRMarsHost()
{
    m_fPassivated       = false;
    m_cWebBrowserEvents = NULL;
}

CSRMarsHost::~CSRMarsHost()
{
    (void)Passivate();

    if ( m_cWebBrowserEvents )
    {
        m_cWebBrowserEvents->Release();
    }
}

HRESULT  CSRMarsHost::FinalConstruct()
{
    HRESULT  hr = S_OK ;

    hr = CSRWebBrowserEvents_Object::CreateInstance( &m_cWebBrowserEvents );
    if ( FAILED(hr) )
        goto Exit;

    m_cWebBrowserEvents->AddRef();

Exit:
    return( hr );

}

HRESULT  CSRMarsHost::Passivate()
{
    m_fPassivated = true;

    if ( m_cWebBrowserEvents )
    {
        m_cWebBrowserEvents->Detach();
    }

    return( S_OK );

}

/////////////////////////////////////////////////////////////////////////////
// CSRMarsHost - IMarsHost methods

STDMETHODIMP CSRMarsHost::OnHostNotify( /*[in]*/ MARSHOSTEVENT event,
                                        /*[in]*/ IUnknown *punk,
                                        /*[in]*/ LPARAM lParam )
{
    HRESULT  hr;

    if( event == MARSHOST_ON_WIN_INIT )
    {
        g_pRstrMgr->SetFrameHwnd( (HWND)lParam );
    }

    if( event == MARSHOST_ON_WIN_PASSIVATE )
    {
        g_pRstrMgr->SetFrameHwnd( NULL );
    }

    //
    // Handle panel-related things.
    //
    if( event == MARSHOST_ON_PANEL_CONTROL_CREATE )
    {
        CComQIPtr<IMarsPanel> panel = punk;
        if( panel )
        {
            CComBSTR name;

            hr = panel->get_name( &name );
            if( FAILED(hr) )
            {
                goto Exit;
            }

            if( name == PANEL_CONTENTS )
            {
                CComPtr<IDispatch> disp;

                if( SUCCEEDED(panel->get_content( &disp )) )
                {
                    CComQIPtr<IWebBrowser2> wb2( disp );

                    if( wb2 )
                    {
                        wb2->put_RegisterAsDropTarget( VARIANT_FALSE );
                        m_cWebBrowserEvents->Attach( wb2 );
                    }
                }
            }
        }
    }

    hr = S_OK;
Exit:
    return( hr );
}

STDMETHODIMP CSRMarsHost::OnNewWindow2( /*[in,out]*/ IDispatch **ppDisp ,
                                        /*[in,out]*/ VARIANT_BOOL *Cancel )
{
    return( S_OK );
}

STDMETHODIMP CSRMarsHost::FindBehavior( /*[in]*/ IMarsPanel *pPanel,
                                        /*[in]*/ BSTR bstrBehavior,
                                        /*[in]*/ BSTR bstrBehaviorUrl,
                                        /*[in]*/ IElementBehaviorSite *pSite,
                                        /*[retval, out]*/ IElementBehavior **ppBehavior )
{
    return( S_OK );
}

STDMETHODIMP CSRMarsHost::OnShowChrome( /*[in]*/ BSTR bstrWebPanel,
                                        /*[in]*/ DISPID dispidEvent,
                                        /*[in]*/ BOOL fVisible,
                                        /*[in]*/ BSTR bstrCurrentPlace,
                                        /*[in]*/ IMarsPanelCollection *pMarsPanelCollection )
{
    return( S_OK );
}

STDMETHODIMP CSRMarsHost::PreTranslateMessage( /*[in]*/ MSG *msg )
{
    HRESULT  hr = S_OK;

    switch( msg->message )
    {
    case WM_CLOSE:
        {
            if ( g_pRstrMgr->DenyClose() )
            {
                goto Exit; // Cancel close when restoring
            }
        }
        break;

    case WM_DISPLAYCHANGE :
        {
            //
            // If display changes to 640x480 from something higher then
            // the window has to be resized to fit in the new display
            //
            RECT     rc;
            DWORD    dwWidth  = LOWORD(msg->lParam);
            DWORD    dwHeight = HIWORD(msg->lParam);
            CWindow  cWnd;

            cWnd.Attach( msg->hwnd );

            if ( dwHeight < 540 )
            {
                rc.left   = 0;
                rc.top    = 0;
                rc.right  = 620;
                rc.bottom = 420;

                //g_cRestoreShell.m_dwCurrentWidth  = rc.right ;
                //g_cRestoreShell.m_dwCurrentHeight = rc.bottom ;

                ::AdjustWindowRectEx( &rc, cWnd.GetStyle(), FALSE, cWnd.GetExStyle() );
                ::SetWindowPos(msg->hwnd,
                               NULL,
                               0,
                               0,
                               rc.right-rc.left,
                               rc.bottom-rc.top,
                               SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOZORDER);

                cWnd.CenterWindow(::GetDesktopWindow()); // ignore error return if any
            }
            else
            {
                rc.left   = 0;
                rc.top    = 0;
                rc.right  = 770;
                rc.bottom = 540;

                //g_cRestoreShell.m_dwCurrentWidth  = rc.right ;
                //g_cRestoreShell.m_dwCurrentHeight = rc.bottom ;

                ::AdjustWindowRectEx( &rc, cWnd.GetStyle(), FALSE, cWnd.GetExStyle() );
                ::SetWindowPos(msg->hwnd,
                               NULL,
                               0,
                               0,
                               rc.right-rc.left,
                               rc.bottom-rc.top,
                               SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOZORDER);

                cWnd.CenterWindow(::GetDesktopWindow()); // ignore error return if any
            }
        }
        break;

    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
        {
            if ( msg->wParam & MK_CONTROL ||
                 msg->wParam & MK_SHIFT   ||
                 GetKeyState(VK_MENU) < 0    )
            {
                goto Exit; // IE opens link in a seperate page so force cancelling
            }
        }
        break;

    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            if ( ( HIWORD(msg->lParam) & KF_ALTDOWN ) != 0 ) // Alt pressed
            {
                if ( msg->wParam == VK_LEFT  ||
                     msg->wParam == VK_RIGHT )
                {
                    goto Exit; // IE does not cancel Alt-Left so force cancelling
                }
            }
        }
        break;

    case WM_KEYDOWN:
    case WM_KEYUP:
        {
            switch( msg->wParam )
            {
            case VK_F5:
                goto Exit; // Disable refresh...

            case 'N':
                if ( GetKeyState(VK_CONTROL) < 0 )
                {
                    goto Exit; // Disable Ctrl-N combination
                }
            }
        }
        break;

    case WM_MOUSEWHEEL:
        //
        // Disable Mouse Wheel navigation... not used in SR
        //
        return( S_OK );
    }

    hr = E_NOTIMPL;

Exit:
    return( hr );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\htmlui2.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    htmlui2.cpp

Abstract:
    This file contains the implementation of the CRestorePointInfo class,
    which is scriptable object for restore point information.

Revision History:
    Seong Kook Khang (SKKhang)  06/21/99
        created
    Seong Kook Khang (SKKhang)  05/19/00
        Renamed from rpdata.cpp to htmlui2.cpp.
        Brought CRenamedFolders class from logfile.cpp.

******************************************************************************/

#include "stdwin.h"
#include "stdatl.h"
#include "resource.h"
#include "rstrpriv.h"
#include "srui_htm.h"
#include "rstrmgr.h"
#include "rstrshl.h"


/////////////////////////////////////////////////////////////////////////////
//
// CRestorePointInfo class
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CRestorePointInfo construction

//#define COUNT_RPT     13
//#define SIZE_RPT_STR  256

CRestorePointInfo::CRestorePointInfo()
{
}

STDMETHODIMP
CRestorePointInfo::HrInit( SRestorePointInfo *pRPI )
{
    TraceFunctEnter("CRestorePointInfo::HrInit");
    m_pRPI = pRPI;
{
LPCWSTR  cszName = pRPI->strName;
DebugTrace(TRACE_ID, "RP: '%ls'", cszName);
}
    TraceFunctLeave();
    return( S_OK );
}


/////////////////////////////////////////////////////////////////////////////
// CRestorePointInfo - IRestorePoint methods

STDMETHODIMP
CRestorePointInfo::get_Name( BSTR *pbstrName )
{
    TraceFunctEnter("CRestorePointInfo::get_Name");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pbstrName);
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrName, m_pRPI->strName );

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestorePointInfo::get_Type( INT *pnType )
{
    TraceFunctEnter("CRestorePointInfo::get_Type");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnType);
    *pnType = (INT)m_pRPI->dwType;

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestorePointInfo::get_SequenceNumber( INT *pnSeq )
{
    TraceFunctEnter("CRestorePointInfo::get_SquenceNumber");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnSeq);
    *pnSeq = m_pRPI->dwNum;

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestorePointInfo::get_TimeStamp( INT nOffDate, VARIANT *pvarTime )
{
    TraceFunctEnter("CRestorePointInfo::get_TimeStamp");
    HRESULT     hr = S_OK;
    SYSTEMTIME  st;

    VALIDATE_INPUT_ARGUMENT(pvarTime);
    ::VariantInit(pvarTime);
    V_VT(pvarTime) = VT_DATE;
    m_pRPI->stTimeStamp.GetTime( &st );
    ::SystemTimeToVariantTime( &st, &V_DATE(pvarTime) );
    if ( nOffDate != 0 )
        V_DATE(pvarTime) += nOffDate;

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestorePointInfo::get_Year( INT *pnYear )
{
    TraceFunctEnter("CRestorePointInfo::get_Year");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnYear);
    *pnYear = m_pRPI->stTimeStamp.GetYear();

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestorePointInfo::get_Month( INT *pnMonth )
{
    TraceFunctEnter("CRestorePointInfo::get_Month");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnMonth);
    *pnMonth = m_pRPI->stTimeStamp.GetMonth();

Exit:
    TraceFunctLeave();
    return( hr );
}

STDMETHODIMP
CRestorePointInfo::get_Day( INT *pnDay )
{
    TraceFunctEnter("CRestorePointInfo::get_Day");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pnDay);
    *pnDay = m_pRPI->stTimeStamp.GetDay();

Exit:
    TraceFunctLeave();
    return( hr );
}

#define RP_ADVANCED  1

STDMETHODIMP
CRestorePointInfo::get_IsAdvanced( VARIANT_BOOL *pfIsAdvanced )
{
    TraceFunctEnter("CRestorePointInfo::get_IsAdvanced");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(pfIsAdvanced);
    *pfIsAdvanced = ( m_pRPI->dwFlags == RP_ADVANCED );

Exit:
    TraceFunctLeave();
    return( hr );
}


STDMETHODIMP
CRestorePointInfo::CompareSequence( IRestorePoint *pRP, INT *pnCmp )
{
    TraceFunctEnter("CRestorePointInfo::CompareSequence");
    HRESULT hr = S_OK;
    INT     nSrc;
    INT     nCmp;

    VALIDATE_INPUT_ARGUMENT(pRP);
    VALIDATE_INPUT_ARGUMENT(pnCmp);
    hr = pRP->get_SequenceNumber( &nSrc );
    if ( FAILED(hr) )
        goto Exit;

    nCmp = (int)m_pRPI->dwNum - nSrc;
    if ( nCmp == 0 )
        *pnCmp = 0;
    else if ( nCmp > 0 )
        *pnCmp = 1;
    else
        *pnCmp = -1;

Exit:
    TraceFunctLeave();
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
// CRenamedFolders class
//
/////////////////////////////////////////////////////////////////////////////

CRenamedFolders::CRenamedFolders()
{
}


/////////////////////////////////////////////////////////////////////////////
// CRenamedFolders - IRenamedFolders methods

STDMETHODIMP
CRenamedFolders::get_Count( long *plCount )
{
    TraceFunctEnter("CRenamedFolders::get_Count");
    HRESULT hr = S_OK;

    VALIDATE_INPUT_ARGUMENT(plCount);
    *plCount = g_pRstrMgr->GetRFICount();

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRenamedFolders::get_OldName( long lIndex, BSTR *pbstrName )
{
    TraceFunctEnter("CRenamedFolders::OldName");
    HRESULT  hr = S_OK;
    PSRFI    pRFI;

    VALIDATE_INPUT_ARGUMENT(pbstrName);
    if ( lIndex < 0 || lIndex >= g_pRstrMgr->GetRFICount() )
    {
        ErrorTrace(TRACE_ID, "Invalid Argument, out of range");
        hr = E_INVALIDARG;
        goto Exit;
    }
    pRFI = g_pRstrMgr->GetRFI( lIndex );
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrName, pRFI->strOld );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRenamedFolders::get_NewName( long lIndex, BSTR *pbstrName )
{
    TraceFunctEnter("CRenamedFolders::NewName");
    HRESULT  hr = S_OK;
    PSRFI    pRFI;

    VALIDATE_INPUT_ARGUMENT(pbstrName);
    if ( lIndex < 0 || lIndex >= g_pRstrMgr->GetRFICount() )
    {
        ErrorTrace(TRACE_ID, "Invalid Argument, out of range");
        hr = E_INVALIDARG;
        goto Exit;
    }
    pRFI = g_pRstrMgr->GetRFI( lIndex );
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrName, pRFI->strNew );

Exit:
    TraceFunctLeave();
    return( hr );
}

/******************************************************************************/

STDMETHODIMP
CRenamedFolders::get_Location( long lIndex, BSTR *pbstrName )
{
    TraceFunctEnter("CRenamedFolders::Location");
    HRESULT  hr = S_OK;
    PSRFI    pRFI;

    VALIDATE_INPUT_ARGUMENT(pbstrName);
    if ( lIndex < 0 || lIndex >= g_pRstrMgr->GetRFICount() )
    {
        ErrorTrace(TRACE_ID, "Invalid Argument, out of range");
        hr = E_INVALIDARG;
        goto Exit;
    }
    pRFI = g_pRstrMgr->GetRFI( lIndex );
    ALLOCATEBSTR_AND_CHECK_ERROR( pbstrName, pRFI->strLoc );

Exit:
    TraceFunctLeave();
    return( hr );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\logfile.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    logfile.cpp

Abstract:
    This file contains the implementation of the ValidateLogFile() function,
    which reads and validate restore operations log file.

Revision History:
    Seong Kook Khang (SKKhang)  08/20/99
        created

******************************************************************************/

#include "stdwin.h"
#include "rstrpriv.h"
#include "srui_htm.h"
#include "rstrmgr.h"
#include "srapi.h"

static LPCWSTR  s_cszLogPath    = L"%SystemRoot%\\system32\\restore\\rstrlog.dat";
static LPCWSTR  s_cszWinInitErr = L"%SystemRoot%\\wininit.err";


/******************************************************************************/

BOOL  ReadStrAlign4( HANDLE hFile, LPWSTR pszStr )
{
    BOOL    fRet = FALSE;
    DWORD   dwLen;
    DWORD   dwRead;

    if ( !::ReadFile( hFile, &dwLen, sizeof(DWORD), &dwRead, NULL ) || dwRead != sizeof(DWORD) )
    {
        goto Exit;
    }
    if ( dwRead > MAX_PATH+4 )
    {
        // Broken log file...
        goto Exit;
    }
    if ( dwLen > 0 )
    {
        if ( !::ReadFile( hFile, pszStr, dwLen, &dwRead, NULL ) || dwRead != dwLen )
        {
            goto Exit;
        }
    }

    fRet = TRUE;
Exit:
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////
//
// CMappedFileRead class
//
/////////////////////////////////////////////////////////////////////////////

class CMappedFileRead
{
public:
    CMappedFileRead();
    ~CMappedFileRead();

// Operations
public:
    void  Close();
    BOOL  Open( LPCWSTR cszPath );
    BOOL  Read( LPVOID pBuf, DWORD cbBuf );
    BOOL  Read( DWORD *pdw );
    BOOL  ReadDynStr( LPWSTR szBuf, DWORD cchMax );

protected:

// Attributes
public:
    DWORD  GetAvail()  {  return( m_dwAvail );  }

protected:
    WCHAR   m_szPath[MAX_PATH];
    DWORD   m_dwSize;
    HANDLE  m_hFile;
    HANDLE  m_hMap;
    LPBYTE  m_pBuf;
    LPBYTE  m_pCur;
    DWORD   m_dwAvail;
};

/////////////////////////////////////////////////////////////////////////////
// CMappedFileRead construction / destruction

CMappedFileRead::CMappedFileRead()
{
    m_szPath[0] = L'\0';
    m_dwSize    = 0;
    m_hFile     = INVALID_HANDLE_VALUE;
    m_hMap      = INVALID_HANDLE_VALUE;
    m_pBuf      = NULL;
}

CMappedFileRead::~CMappedFileRead()
{
    Close();
}

/////////////////////////////////////////////////////////////////////////////
// CMappedFileRead operations

void  CMappedFileRead::Close()
{
    TraceFunctEnter("CMappedFileRead::Close");

    if ( m_pBuf != NULL )
    {
        ::UnmapViewOfFile( m_pBuf );
        m_pBuf = NULL;
    }
    if ( m_hMap != INVALID_HANDLE_VALUE )
    {
        ::CloseHandle( m_hMap );
        m_hMap = INVALID_HANDLE_VALUE;
    }
    if ( m_hFile != INVALID_HANDLE_VALUE )
    {
        ::CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }

    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::Open( LPCWSTR cszPath )
{
    TraceFunctEnter("CMappedFileRead::Open");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;

    Close();

    m_hFile = ::CreateFile( cszPath, GENERIC_READ,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, NULL );
    if ( m_hFile == INVALID_HANDLE_VALUE )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateFile failed - %ls", cszErr);
        goto Exit;
    }
    m_dwSize = ::GetFileSize( m_hFile, NULL );
    if ( m_dwSize == 0xFFFFFFFF )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::GetFileSize failed - %ls", cszErr);
        goto Exit;
    }

    m_hMap = ::CreateFileMapping( m_hFile, NULL, PAGE_READONLY, 0, 0, NULL );
    if ( m_hFile == INVALID_HANDLE_VALUE )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::CreateFileMapping failed - %ls", cszErr);
        goto Exit;
    }

    m_pBuf = (LPBYTE)::MapViewOfFile( m_hMap, FILE_MAP_READ, 0, 0, 0 );
    if ( m_pBuf == NULL )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::MapViewOfFile failed - %ls", cszErr);
        goto Exit;
    }

    ::lstrcpy( m_szPath, cszPath );
    m_pCur    = m_pBuf;
    m_dwAvail = m_dwSize;

    fRet = TRUE;
Exit:
    if ( !fRet )
        Close();
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::Read( LPVOID pBuf, DWORD cbBuf )
{
    TraceFunctEnter("CMappedFileRead::Read(LPVOID,DWORD)");
    BOOL  fRet = FALSE;

    if ( cbBuf > m_dwAvail )
    {
        ErrorTrace(0, "Insufficient data - %d bytes (need=%d bytes)\n", m_dwAvail, cbBuf);
        goto Exit;
    }

    ::CopyMemory( pBuf, m_pCur, cbBuf );

    m_pCur    += cbBuf;
    m_dwAvail -= cbBuf;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::Read( DWORD *pdw )
{
    TraceFunctEnter("CMappedFileRead::Read(DWORD*)");
    BOOL  fRet = FALSE;

    if ( sizeof(DWORD) > m_dwAvail )
    {
        ErrorTrace(0, "Insufficient data - %d bytes (need=%d bytes)\n", m_dwAvail, sizeof(DWORD));
        goto Exit;
    }

    *pdw = *((LPDWORD)m_pCur);

    m_pCur    += sizeof(DWORD);
    m_dwAvail -= sizeof(DWORD);

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////

BOOL  CMappedFileRead::ReadDynStr( LPWSTR szBuf, DWORD cchMax )
{
    TraceFunctEnter("CMappedFileRead::Read(LPWSTR,DWORD)");
    BOOL   fRet = FALSE;
    DWORD  dwLen;

    // note, this "length" is in bytes, not chars.
    if ( !Read( &dwLen ) )
        goto Exit;

    if ( dwLen == 0 )
    {
        szBuf[0] = L'\0';
        goto Done;
    }

    if ( dwLen > cchMax*sizeof(WCHAR) )
    {
        ErrorTrace(0, "Invalid string length - %d (max=%d)\n", dwLen, cchMax);
        goto Exit;
    }

    if ( !Read( szBuf, dwLen ) )
        goto Exit;

Done:
    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// ValidateLogFile function
//
/////////////////////////////////////////////////////////////////////////////

struct SRFINode
{
    PSRFI     pRFI;
    SRFINode  *pNext;
};

BOOL  ValidateLogFile( BOOL *pfSilent, BOOL *pfUndo )
{
    TraceFunctEnter("ValidateLogFile");
    BOOL             fRet = FALSE;
    WCHAR            szLogPath[MAX_PATH];
    CMappedFileRead  cMFR;
    SRstrLogHdrBase  sHdr1;
    SRstrLogHdrV3    sHdr2;
    SRstrLogHdrV3Ex  sHdr3;
    SRstrEntryHdr    sEntHdr;
    DWORD            i;
    DWORD            dwFlags;
    WCHAR            szBuf1[SR_MAX_FILENAME_LENGTH];
    WCHAR            szBuf2[SR_MAX_FILENAME_LENGTH];
    WCHAR            szBuf3[SR_MAX_FILENAME_LENGTH];
    PSRFI            pRFI;

    ::ExpandEnvironmentStrings( s_cszLogPath, szLogPath, MAX_PATH );

    if ( !cMFR.Open( szLogPath ) )
        goto Exit;

    if ( !cMFR.Read( &sHdr1, sizeof(sHdr1) ) )
        goto Exit;
    if ( ( sHdr1.dwSig1 != RSTRLOG_SIGNATURE1 ) ||
         ( sHdr1.dwSig2 != RSTRLOG_SIGNATURE2 ) )
    {
        ErrorTrace(0, "Invalid restore log file signature...");
        goto Exit;
    }
    if ( HIWORD(sHdr1.dwVer) != RSTRLOG_VER_MAJOR )
    {
        ErrorTrace(0, "Unknown restore log file version - %d (0x%08X)\n", HIWORD(sHdr1.dwVer), sHdr1.dwVer);
        goto Exit;
    }

    if ( !cMFR.Read( &sHdr2, sizeof(sHdr2) ) )
        goto Exit;
    if ( pfSilent != NULL )
        *pfSilent = ( ( sHdr2.dwFlags & RLHF_SILENT ) != 0 );
    if ( pfUndo != NULL )
        *pfUndo = ( ( sHdr2.dwFlags & RLHF_UNDO ) != 0 );
        
    g_pRstrMgr->SetRPsUsed( sHdr2.dwRPNum, sHdr2.dwRPNew );
    DebugTrace(0, "RP ID = %d, # of Drives = %d, New RP=%d", sHdr2.dwRPNum, sHdr2.dwDrives, sHdr2.dwRPNew);

    for ( i = 0;  i < sHdr2.dwDrives;  i++ )
    {
        if ( !cMFR.Read( &dwFlags ) )
            goto Exit;
        if ( !cMFR.ReadDynStr( szBuf1, MAX_PATH ) )
            goto Exit;
        if ( !cMFR.ReadDynStr( szBuf2, MAX_PATH ) )
            goto Exit;
        if ( !cMFR.ReadDynStr( szBuf3, MAX_PATH ) )
            goto Exit;
        DebugTrace(0, "Drv#%d - %08X, %ls, %ls, %ls", i, dwFlags, szBuf1, szBuf2, szBuf3);
        // Just ignore drive table...
    }

    //if ( !cMFR.Read( &sHdr3, sizeof(sHdr3) ) )
    //    goto Exit;
    //DebugTrace(0, "New RP ID = %d, # of Entries = %d", sHdr3.dwRPNew, sHdr3.dwCount);

    for ( i = 0;  cMFR.GetAvail() > 0;  i++ )
    {
        if ( !cMFR.Read( &sEntHdr, sizeof(sEntHdr) ) )
            goto Exit;

        if ( sEntHdr.dwRes == RSTRRES_FAIL )
            goto Exit;

        if ( ( sEntHdr.dwID == RSTRLOGID_STARTUNDO ) ||
             ( sEntHdr.dwID == RSTRLOGID_ENDOFUNDO ) )
            continue;

        if ( sEntHdr.dwID == RSTRLOGID_ENDOFMAP )
        {
            if ( cMFR.GetAvail() > 0 )
            {
                ErrorTrace(0, "Unknown trailing data after the EndOfMap marker...");
                // but ignore and continue...
            }
            break;
        }

        if ( !cMFR.ReadDynStr( szBuf1, SR_MAX_FILENAME_LENGTH ) )
            goto Exit;
        if ( !cMFR.ReadDynStr( szBuf2, SR_MAX_FILENAME_LENGTH ) )
            goto Exit;
        if ( !cMFR.ReadDynStr( szBuf3, SR_MAX_FILENAME_LENGTH ) )
            goto Exit;

        if ( sEntHdr.dwID == RSTRLOGID_COLLISION )
        {
            pRFI = new SRenamedFolderInfo;
            if ( pRFI == NULL )
            {
                FatalTrace(0, "Insufficient memory...");
                goto Exit;
            }
            pRFI->strOld = ::PathFindFileName( szBuf1 );
            pRFI->strNew = ::PathFindFileName( szBuf2 );
            ::PathRemoveFileSpec( szBuf2 );
            pRFI->strLoc = szBuf2;

            if ( !g_pRstrMgr->AddRenamedFolder( pRFI ) )
                goto Exit;
        }
    }

    fRet = TRUE;
Exit:
    cMFR.Close();

    TraceFunctLeave();
    return( fRet );
}


/******************************************************************************/

BOOL  CheckWininitErr()
{
    TraceFunctEnter("CheckWininitErr");
    BOOL   fRet = FALSE;
    WCHAR  szWinInitErr[MAX_PATH+1];

    ::ExpandEnvironmentStrings( s_cszWinInitErr, szWinInitErr, MAX_PATH );
    if ( ::GetFileAttributes( szWinInitErr ) != 0xFFFFFFFF )
    {
        DebugTrace(TRACE_ID, "WININIT.ERR file exists");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\main.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the implementation of WinMain

Revision History:
    Seong Kook Khang (skkhang)  06/07/99
        created
    Seong Kook Khang (skkhang)  05/10/00
        Restructured and cleaned up for Whistler

******************************************************************************/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f PCHealthps.mk in the project directory.

#include "stdwin.h"
#include "resource.h"       // resource include for this module
#include "rstrpriv.h"
#include "rstrerr.h"
#include "rstrmgr.h"
#include "extwrap.h"
#include "rstrmap.h"
#include "FrmBase.h"
#include <respoint.h>
#include <enumlogs.h>
#include "srrpcapi.h"

#include "NTServMsg.h"    // generated from the MC message compiler

#define RSTRUI_RETURN_CODE_SR_DISABLED            1
#define RSTRUI_RETURN_CODE_NO_DISK_SPACE          3
#define RSTRUI_RETURN_CODE_SMFROZEN               4
#define RSTRUI_RETURN_CODE_SMGR_NOT_ALIVE         5

#define SMGR_INIT_TIMEOUT   2000    // 2 seconds to wait after starting Stmgr to let it initialize itself
                                    // try thrice

enum
{
    CMDPARAM_INVALID = 0,   // invalid parameter...
    // initiating phase
    CMDPARAM_NORMAL,        // normal UI without any parameter
    CMDPARAM_REGSERVER,     // register COM server
    CMDPARAM_UNREGSERVER,   // unregister COM server
    CMDPARAM_SILENT,        // Silent Restore
    // after-boot phase
    CMDPARAM_CHECK,         // check log file and show result page (normal)
    CMDPARAM_INTERRUPTED,   // abnormal shutdown, initiate undo
    CMDPARAM_HIDERESULT,    // do not show success result page for Silent Restore
    // commands for debug
    CMDPARAM_RESULT_S,      // show success result page
    CMDPARAM_RESULT_F,      // show failure result page
    CMDPARAM_RESULT_LD,     // show low disk result page

    CMDPARAM_SENTINEL
};


// Forward declarations for file static functions
DWORD  ParseCommandParameter( DWORD *pdwRP );
void  ShowErrorMessage(HRESULT hr);
BOOL  IsFreeSpaceOnWindowsDrive( void );

extern BOOL  CheckWininitErr();
extern BOOL  ValidateLogFile( BOOL *pfSilent, BOOL *pfUndo );


// Application Instance
HINSTANCE  g_hInst = NULL;

// External Wrapper Instance
ISRExternalWrapper  *g_pExternal = NULL;

// Main Frame Instance
ISRFrameBase  *g_pMainFrm = NULL;

// Restore Manager Instance
CRestoreManager  *g_pRstrMgr = NULL;

CSRClientLoader  g_CSRClientLoader;


/////////////////////////////////////////////////////////////////////////////

BOOL  CancelRestorePoint()
{
    TraceFunctEnter("CancelRestorePoint");
    BOOL  fRet = TRUE;
    int   nUsedRP;

    nUsedRP = g_pRstrMgr->GetNewRP();
    if (nUsedRP == -1)   // not initialized, see if it's the current one
    {
        CRestorePoint rp;
        GetCurrentRestorePoint (rp);
        if (rp.GetType() == RESTORE)
            nUsedRP = rp.GetNum();
    }
    DebugTrace(0, "Deleting RP %d", nUsedRP);
    if ( nUsedRP > 0 )
        fRet = g_pExternal->RemoveRestorePoint( nUsedRP );

    TraceFunctLeave();
    return( fRet );
}

DWORD ProductFeedback (LPWSTR pszString)
{
    TraceFunctEnter("Product Feedback");

    HANDLE hFile = INVALID_HANDLE_VALUE;
    PROCESS_INFORMATION pi;
    STARTUPINFOW si;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbWritten = 0;
    const int MAX_STR = 1024;
    WCHAR wcsSystem[MAX_PATH];
    WCHAR wcsBuffer[MAX_STR];
    WCHAR wcsDataFile[MAX_PATH];    
    const WCHAR c_wcsCommand[] = L"%s\\dwwin.exe -d %s\\%s";
    const WCHAR c_wcsManifest[] = L"restore\\rstrdw.txt";
    const WCHAR c_wcsData[] = L"restore\\srpfdata.txt";    
    
    if (0 == GetSystemDirectoryW (wcsSystem, MAX_PATH))
    {
        dwErr = GetLastError();
        goto Err;
    }

    // construct the data file to be uploaded
    
    wsprintf (wcsDataFile, L"%s\\%s", wcsSystem, c_wcsData);
    hFile = CreateFileW ( wcsDataFile,   // file name
                          GENERIC_WRITE, // file access
                          0,             // share mode
                          NULL,          // SD
                          CREATE_ALWAYS, // how to create
                          0,             // file attributes
                          NULL);         // handle to template file

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        trace(0, "! CreateFile : %ld", dwErr);
        goto Err;
    }

    if (FALSE == WriteFile (hFile, (BYTE *) pszString,
                lstrlenW(pszString)*sizeof(WCHAR), &cbWritten, NULL))
    {
        dwErr = GetLastError();
        trace(0, "! WriteFile : %ld", dwErr);
        goto Err;
    }

    CloseHandle (hFile);
    hFile = INVALID_HANDLE_VALUE;
    
    
    wsprintf (wcsBuffer, L"%s\\%s", wcsSystem, c_wcsManifest);

    hFile = CreateFileW ( wcsBuffer,   // file name
                          GENERIC_WRITE, // file access
                          0,             // share mode
                          NULL,          // SD
                          CREATE_ALWAYS, // how to create
                          0,             // file attributes
                          NULL);         // handle to template file

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        trace(0, "! CreateFile : %ld", dwErr);
        goto Err;
    }

    PCHLoadString(IDS_PRODUCTFEEDBACK, wcsBuffer, MAX_STR-1);
    lstrcat(wcsBuffer, L"DataFiles=");
    lstrcat(wcsBuffer, wcsDataFile); 
    if (FALSE == WriteFile (hFile, (BYTE *) wcsBuffer,
                lstrlenW(wcsBuffer)*sizeof(WCHAR), &cbWritten, NULL))
    {
        dwErr = GetLastError();
        trace(0, "! WriteFile : %ld", dwErr);
        goto Err;
    }

    CloseHandle (hFile);
    hFile = INVALID_HANDLE_VALUE;

    wsprintf (wcsBuffer, c_wcsCommand, wcsSystem, wcsSystem, c_wcsManifest);

    ZeroMemory (&pi, sizeof(pi));
    ZeroMemory (&si, sizeof(si));

    if (CreateProcessW (NULL, wcsBuffer, NULL, NULL, TRUE, 
                        CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS,
                        NULL, wcsSystem, &si, &pi))
    {
        CloseHandle (pi.hThread);
        CloseHandle (pi.hProcess);
    }

Err:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);

    TraceFunctLeave();
    return dwErr;
}

DWORD RestoreHTCKey ()
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    WCHAR wszValue[] = L"text/x-component";
    
    if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_CLASSES_ROOT, L".htc", 0,
                              KEY_READ, &hKey))
    {
        dwErr = RegCreateKey(HKEY_CLASSES_ROOT, L".htc",  &hKey);

        if (ERROR_SUCCESS == dwErr)
        {
            dwErr = RegSetValueEx ( hKey, L"Content Type", 0, REG_SZ,
               (BYTE *) wszValue, sizeof(wszValue));

            RegCloseKey (hKey);
        }
    }

    return dwErr;
}

/////////////////////////////////////////////////////////////////////////////
//

extern "C" int
WINAPI wWinMain(
HINSTANCE   hInstance,
HINSTANCE   /*hPrevInstance*/,
LPSTR       /*lpCmdLine*/,
int         /*nShowCmd*/
)
{
    HRESULT       hr;
    int           nRet           = 0;
    DWORD         dwRet=0;
    LPWSTR        szCmdLine;
    LPCWSTR       szToken;
    const WCHAR   cszPrefix[]    = L"-/";
    int           nStartMode     = SRASM_NORMAL;
    BOOL          fLoadRes       = FALSE;
    int           nTries         = 0;
    BOOL          fRebootSystem  = FALSE;
    DWORD  dwCmd;
    DWORD  dwRP = 0xFFFFFFFF;
    BOOL   fWasSilent = FALSE;
    BOOL   fWasUndo = FALSE;
    DWORD  dwEventID = 0;
    DWORD  dwDisable = 0;
    BOOL   fSendFeedback = FALSE;
    WCHAR  szPFString[MAX_PATH];
    DWORD  dwPFID = 0;
    
#if !NOTRACE
    InitAsyncTrace();
#endif
    TraceFunctEnter("_tWinMain");

    g_hInst   = hInstance;

     // Load SRClient
    g_CSRClientLoader.LoadSrClient();
    
    //szCmdLine = ::GetCommandLine();     //this line necessary for _ATL_MIN_CRT
    //szToken   = ::PathGetArgs( szCmdLine );

    // Check credential and set necessary privileges
    if ( !::CheckPrivilegesForRestore() )
    {
        ::ShowSRErrDlg( IDS_ERR_LOW_PRIVILEGE );
        goto Exit;
    }

    // Parse command line parameter
    dwCmd = ParseCommandParameter( &dwRP );

    // Initialize class objects
    if ( !::CreateSRExternalWrapper( FALSE, &g_pExternal ) )
        goto Exit;

    if ( !::CreateSRFrameInstance( &g_pMainFrm ) )
        goto Exit;

    if ( !g_pMainFrm->InitInstance( hInstance ) )
        goto Exit;

    if ( !::CreateRestoreManagerInstance( &g_pRstrMgr ) )
        goto Exit;


    // if the registry says that SR is enabled, make sure we are
    // enabled correctly (service is started, startup mode is correct)
    
    // if registry says we are enabled, but service start type is disabled
    // disable us now
    if (::SRGetRegDword( HKEY_LOCAL_MACHINE,
                         s_cszSRRegKey,
                         s_cszDisableSR,
                         &dwDisable ) )
    {
        DWORD  dwStart;
        
        if (0 == dwDisable)
        {            
            if (ERROR_SUCCESS == GetServiceStartup(s_cszServiceName, &dwStart) &&
                (dwStart == SERVICE_DISABLED || dwStart == SERVICE_DEMAND_START))
            {
                EnableSR(NULL);                
                DisableSR(NULL);
            }
            else
            {
                EnableSR(NULL);
            }
        }
    }

    
    switch ( dwCmd )
    {
    case CMDPARAM_NORMAL :
        break;

    case CMDPARAM_REGSERVER :
        dwRet = g_pMainFrm->RegisterServer();
#if DBG==1
        if ( dwRet == ERROR_CALL_NOT_IMPLEMENTED )
            ::MessageBox(NULL, L"/RegServer is not supported...", L"CommandLine Options", MB_OK);
#endif
        goto Exit;

    case CMDPARAM_UNREGSERVER :
        dwRet = g_pMainFrm->UnregisterServer();
#if DBG==1
        if ( dwRet == ERROR_CALL_NOT_IMPLEMENTED )
            ::MessageBox(NULL, L"/UnregServer is not supported", L"CommandLine Options", MB_OK);
#endif
        goto Exit;

    case CMDPARAM_SILENT :
        g_pRstrMgr->SilentRestore( dwRP );
        goto Exit;

    case CMDPARAM_CHECK :
    case CMDPARAM_HIDERESULT :
        // check result of MoveFileEx, if it's possible...

        if ( ValidateLogFile( &fWasSilent, &fWasUndo ) )
        {
            nStartMode = SRASM_SUCCESS;
        }
        else
        {
            // Cancel restore point of "Restore" type
            ::CancelRestorePoint();
            nStartMode = SRASM_FAIL;            
        }

        g_pRstrMgr->SetIsUndo(fWasUndo);
        break;

    case CMDPARAM_INTERRUPTED :
        // read the log file to get the new restore point
        if (ValidateLogFile( &fWasSilent, &fWasUndo ))
        {
            nStartMode = SRASM_FAIL;
        }
        else
        {
            nStartMode = SRASM_FAIL;
        }

        g_pRstrMgr->SetIsUndo(fWasUndo);
        
        break;

    case CMDPARAM_RESULT_S :
        // read the log file, but ignore the result
        ValidateLogFile( NULL, &fWasUndo );
        nStartMode = SRASM_SUCCESS;
        g_pRstrMgr->SetIsUndo(fWasUndo);        
        break;
    case CMDPARAM_RESULT_F :
        // read the log file, but ignore the result
        ValidateLogFile( NULL, &fWasUndo );
        nStartMode = SRASM_FAIL;
        g_pRstrMgr->SetIsUndo(fWasUndo);        
        ::CancelRestorePoint();
        break;
    case CMDPARAM_RESULT_LD :
        // read the log file, but ignore the result
        ValidateLogFile( NULL, &fWasUndo );
        nStartMode = SRASM_FAILLOWDISK;
        g_pRstrMgr->SetIsUndo(fWasUndo);        
        ::CancelRestorePoint();
        break;

    default :
        // Invalid Parameter, simply invoke regular UI
#if DBG==1
        ::MessageBox(NULL, L"Unknown Option", L"CommandLine Options", MB_OK);
#endif
        break;
    }

     // also check to see if the Winlogon key to call restore has been
     // removed. In normal circumstances, this key should have been
     // deleted during the restore but if the machine was not shutdown
     // cleanly, this key can remain causing the machine to again
     // initiate restore on the next reboot.
    ::SHDeleteValue( HKEY_LOCAL_MACHINE, s_cszSRRegKey,s_cszRestoreInProgress);

     // if start mode is SRASM_FAIL, check to see if we failed becuase
     // of low disk space. If this is the case, show the low disk
     // space message.  Else check for the interrupted case.
    if (nStartMode == SRASM_FAIL)
    {
        DWORD dwRestoreStatus = ERROR_INTERNAL_ERROR;
        ::SRGetRegDword( HKEY_LOCAL_MACHINE, 
                         s_cszSRRegKey, 
                         s_cszRestoreStatus, 
                         &dwRestoreStatus );
        if (dwRestoreStatus != 0)   // interrupted
        {
            nStartMode = SRASM_FAILINTERRUPTED;
        }
        else // Cancel restore point of "Restore" type
        {
            if (TRUE == CheckForDiskSpaceError())
            {
                nStartMode = SRASM_FAILLOWDISK;
            }                
            ::CancelRestorePoint();
        }            
    }
    
    switch ( nStartMode )
    {
    case SRASM_FAIL:
        dwEventID = EVMSG_RESTORE_FAILED;
        dwPFID = IDS_PFFAILED;
        break;        
    case SRASM_FAILLOWDISK:
        dwEventID = EVMSG_RESTORE_FAILED;
        dwPFID = IDS_PFFAILEDLOWDISK;
        break;

    case SRASM_FAILINTERRUPTED:
        dwEventID = EVMSG_RESTORE_INTERRUPTED;
        dwPFID = IDS_PFINTERRUPTED;        
        break;

    case SRASM_SUCCESS:
        dwEventID = EVMSG_RESTORE_SUCCESS;
        dwPFID = IDS_PFSUCCESS;        
        break;

    default:
        break;
    }

    if (dwEventID != 0)
    {
        WCHAR       szUnknownRP [MAX_PATH];
        const WCHAR *pwszUsedName = g_pRstrMgr->GetUsedName();        
        HANDLE      hEventSource = RegisterEventSource(NULL, s_cszServiceName);
        DWORD       dwType = g_pRstrMgr->GetUsedType() + 1;
        WCHAR       szRPType[100], szTime1[50], szTime2[50];
        
        if (NULL == pwszUsedName)
        {
            PCHLoadString(IDS_UNKNOWN_RP, szUnknownRP, MAX_PATH-1);
            pwszUsedName = szUnknownRP;
        }
            
        if (hEventSource != NULL)
        {
            SRLogEvent (hEventSource, EVENTLOG_INFORMATION_TYPE, dwEventID,
               NULL, 0, pwszUsedName, NULL, NULL);
            DeregisterEventSource(hEventSource);
        }

        // construct a string for PF

        if (! fWasSilent)
        {
            PCHLoadString(IDS_UNKNOWN_RP + dwType, szRPType, sizeof(szRPType)/sizeof(WCHAR));      
            GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, NULL, szTime1, sizeof(szTime1)/sizeof(WCHAR));        
            GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, NULL, NULL, szTime2, sizeof(szTime2)/sizeof(WCHAR));
            
            if (SRFormatMessage(szPFString, dwPFID, szTime1, szTime2, pwszUsedName, szRPType, g_pRstrMgr->GetUsedType(), dwPFID-IDS_PFFAILED))
            {
                fSendFeedback = TRUE;
            }
            else
            {
                trace(0, "! SRFormatMessage");            
            }
        }
        
        
        {
            WCHAR szWMIRepository [MAX_PATH];

            GetSystemDirectory (szWMIRepository, MAX_PATH);
            lstrcatW (szWMIRepository, L"\\Wbem\\Repository.bak");
            Delnode_Recurse (szWMIRepository, TRUE, NULL);
        }
    }

    //
    // Before this, perform any necessary bookeeping operations those
    // are necessary for both of Normal & Silent Restore
    //
    if ( fWasSilent )
        goto Exit;

    // Maybe explicit registration is not really necessary... Doing it here always
    // if UI is going to be displayed.
    RestoreHTCKey();
    g_pMainFrm->RegisterServer();

    // Check if SR is frozen or disabled.
    if ( nStartMode == SRASM_NORMAL )
        if ( !g_pRstrMgr->CanRunRestore( TRUE ) )
            goto Exit;

    HWND    hwnd;
    TCHAR   szMainWndTitle[MAX_PATH+1];

    PCHLoadString(IDS_RESTOREUI_TITLE, szMainWndTitle, MAX_PATH);

    // Find Previous Instance.
    hwnd = ::FindWindow(CLSNAME_RSTRSHELL, szMainWndTitle);
    if (hwnd != NULL)
    {
        // If exist, activate it.
        ::ShowWindow(hwnd, SW_SHOWNORMAL);
        ::SetForegroundWindow(hwnd);
    }
    else
    {
        if ( g_pMainFrm != NULL )
        {
            nRet = g_pMainFrm->RunUI( szMainWndTitle, nStartMode );
        }
    }

Exit:

    //if (fSendFeedback)
    //    ProductFeedback(szPFString);

    if ( g_pRstrMgr != NULL )
    {
        fRebootSystem = g_pRstrMgr->NeedReboot();
        g_pRstrMgr->Release();
        g_pRstrMgr = NULL;
    }
    if ( g_pMainFrm != NULL )
    {
        g_pMainFrm->ExitInstance();
        g_pMainFrm->Release();
        g_pMainFrm = NULL;
    }

    if ( g_pExternal != NULL )
    {
        if ( !fRebootSystem )
        {
            //
            // Since FIFO has been disabled in the UI, if for any reason the UI crashes or
            // something bad happens we will come here and give FIFO a chance to resume
            //
            if ( g_pExternal->EnableFIFO() != ERROR_SUCCESS )
            {
                ErrorTrace(TRACE_ID, "EnableFIFO() failed");
            }
        }

        g_pExternal->Release();
    }

    DebugTrace(0, "Closing rstrui.exe...");
    TraceFunctLeave();
#if !NOTRACE
    TermAsyncTrace();
#endif

    if ( fRebootSystem )
    {
        ::ExitWindowsEx( EWX_REBOOT | EWX_FORCE, 0 );
    }

    return(nRet);
}

/******************************************************************************/

#if HANDLE_FIRST_RP

#define FIRSTRUN_MAX_RETRY  5
#define FIRSTRUN_SLEEP_LEN  2000

BOOL
CreateFirstRestorePoint()
{
    TraceFunctEnter("CreateFirstRestorePoint");
    BOOL              fRet = FALSE;
    DWORD             dwRes;
    HKEY              hKey = NULL;
    DWORD             dwType;
    char              szData[MAX_PATH];
    DWORD             dwDelay;
    DWORD             cbData;
    BOOL              fDelayDeleted = FALSE;
    int               i;
    RESTOREPOINTINFO  sRPInfo;
    STATEMGRSTATUS    sSmgrStatus;

    dwRes = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_cszIDSVXDKEY, 0, NULL, &hKey );
    if ( dwRes != ERROR_SUCCESS )
    {
        ErrorTrace(TRACE_ID, "RegOpenKeyEx('%s') failed, ret=%u", s_cszIDSVXDKEY, dwRes );
        goto Exit;
    }

    // Check DelayFirstRstpt registry key and delete it if exists
    dwType = REG_DWORD;
    cbData = sizeof(DWORD);
    dwRes = ::RegQueryValueEx( hKey, s_cszIDSDelayFirstRstpt, NULL, &dwType, (LPBYTE)&dwDelay, &cbData );
    if ( dwRes != ERROR_SUCCESS || dwType != REG_DWORD || cbData == 0 )
    {
        DebugTrace(TRACE_ID, "DelayFirstRstpt flag does not exist");
        goto Ignored;
    }
    if ( dwDelay != 1 )
    {
        DebugTrace(TRACE_ID, "DelayFirstRstpt flag is '%d'", dwDelay);
        goto Ignored;
    }

    // Check OOBEInProgress registry key and do nothing if it exists
    dwType = REG_SZ;
    cbData = MAX_PATH;
    dwRes = ::RegQueryValueEx( hKey, s_cszIDSOOBEInProgress, NULL, &dwType, (LPBYTE)szData, &cbData );
    if ( dwRes == ERROR_SUCCESS )
    {
        DebugTrace(TRACE_ID, "OOBEInProgress flag exists");
        goto Ignored;
    }

    // This should be before deleting DelayFirstRstpt because of the logic of
    // SRSetRestorePoint API.
    EnsureStateMgr();

    // Delete DelayFirstRstpt flag
    dwRes = ::RegDeleteValue( hKey, s_cszIDSDelayFirstRstpt );
    if ( dwRes == ERROR_SUCCESS )
        fDelayDeleted = TRUE;
    else
        ErrorTrace(TRACE_ID, "RegSetValueEx('%s') failed, ret=%u", s_cszIDSDelayFirstRstpt, dwRes );

    // Now set FirstRun restore point
    ::ZeroMemory( &sRPInfo, sizeof(sRPInfo) );
    sRPInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
    sRPInfo.dwRestorePtType = FIRSTRUN;
    ::lstrcpy( sRPInfo.szDescription, "CHECKPOINT" );
    for ( i = 0;  i < FIRSTRUN_MAX_RETRY;  i++ )
    {
        if ( i > 0 )
            ::Sleep( FIRSTRUN_SLEEP_LEN );

        if ( ::SRSetRestorePoint( &sRPInfo, &sSmgrStatus ) )
        {
            DebugTrace(TRACE_ID, "FirstRun restore point has been created!!!");
            break;
        }
        DebugTrace(TRACE_ID, "SRSetRestorePoint failed, i=%d, nStatus=%d", i, sSmgrStatus.nStatus);
    }

Ignored:
    fRet = TRUE;
Exit:
    if ( hKey != NULL )
    {
        if ( !fDelayDeleted )
        {
            dwRes = ::RegDeleteValue( hKey, s_cszIDSDelayFirstRstpt );
            if ( dwRes != ERROR_SUCCESS )
                ErrorTrace(TRACE_ID, "RegSetValueEx('%s') failed, ret=%u", s_cszIDSDelayFirstRstpt, dwRes );
        }
        ::RegCloseKey( hKey );
    }

    TraceFunctLeave();
    return( fRet );
}
#endif //HANDLE_FIRST_RP

/******************************************************************************/
//
// Note:
// =====
// This function loads the error message from resource only dll
// If the resource only dll could not be loaded, this function must not be
// used to display the error
//
void
ShowErrorMessage(
HRESULT hr
)
{
    TraceFunctEnter("ShowErrorMessage");

    int     nErrorMessageID = FALSE ;
    TCHAR   szErrorTitle[MAX_PATH+1];
    TCHAR   szErrorMessage[MAX_ERROR_STRING_LENGTH+1];

    // display error message and shut down gracefully
    switch (hr)
    {
    default:
    case E_UNEXPECTED:
    case E_FAIL:
        nErrorMessageID = IDS_ERR_RSTR_UNKNOWN;
        break;
    case E_OUTOFMEMORY:
        nErrorMessageID = IDS_ERR_RSTR_OUT_OF_MEMORY;
        break;
    case E_RSTR_CANNOT_CREATE_DOMDOC:
        nErrorMessageID = IDS_ERR_RSTR_CANNOT_CREATE_DOMDOC;
        break;
    case E_RSTR_INVALID_CONFIG_FILE:
    case E_RSTR_NO_PROBLEM_AREAS:
    case E_RSTR_NO_PROBLEM_AREA_ATTRS:
    case E_RSTR_NO_REQUIRED_ATTR:
        nErrorMessageID = IDS_ERR_RSTR_INVALID_CONFIG_FILE;
        break;
    }

    PCHLoadString(IDS_ERR_RSTR_TITLE, szErrorTitle, MAX_PATH);
    PCHLoadString(nErrorMessageID, szErrorMessage, MAX_ERROR_STRING_LENGTH);

    //
    // no owner window (use NULL)
    // we could use the GetDesktopWindow() and use that as the owner
    // if necessary
    //
    if ( nErrorMessageID )
    {
        ::MessageBox(NULL, szErrorMessage, szErrorTitle, MB_OK);
    }

    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////

DWORD
ParseCommandParameter( DWORD *pdwRP )
{
    TraceFunctEnter("ParseCommandParameter");
    DWORD    dwCmd = CMDPARAM_INVALID;
    LPCWSTR  cszCmd;

    cszCmd = ::PathGetArgs( ::GetCommandLine() );
    DebugTrace(0, "Cmd='%ls'", cszCmd);
    if ( ( cszCmd == NULL ) || ( *cszCmd == L'\0' ) )
    {
        dwCmd = CMDPARAM_NORMAL;
        goto Exit;
    }

    if ( ( *cszCmd == L'-' ) || ( *cszCmd == L'/' ) )
    {
        cszCmd++;
        DebugTrace(0, "Option='%ls'", cszCmd);
        if ( *cszCmd != L'\0' )
        {
            if ( ::StrCmpI( cszCmd, L"c" ) == 0 )
                dwCmd = CMDPARAM_CHECK;
            else if ( ::StrCmpI( cszCmd, L"regserver" ) == 0 )
                dwCmd = CMDPARAM_REGSERVER;
            else if ( ::StrCmpI( cszCmd, L"unregserver" ) == 0 )
                dwCmd = CMDPARAM_UNREGSERVER;
            else if ( ::ChrCmpI( *cszCmd, L'v' ) == 0 )
            {
                dwCmd = CMDPARAM_SILENT;
                cszCmd++;
                while ( ( *cszCmd != L'\0' ) &&
                        ( ( *cszCmd == L' ' ) || ( *cszCmd == L'\t' ) ) )
                    cszCmd++;
                if ( *cszCmd >= L'0' && *cszCmd <= L'9' )
                    *pdwRP = ::StrToInt( cszCmd );
            }
            else if ( ::StrCmpI( cszCmd, L"b" ) == 0 )
                dwCmd = CMDPARAM_HIDERESULT;
            else if ( ::StrCmpNI( cszCmd, L"result:", 7 ) == 0 )
            {
                cszCmd += 7;
                if ( ::StrCmpIW( cszCmd, L"s" ) == 0 )
                    dwCmd = CMDPARAM_RESULT_S;
                else if ( ::StrCmpIW( cszCmd, L"f" ) == 0 )
                    dwCmd = CMDPARAM_RESULT_F;
                else if ( ::StrCmpIW( cszCmd, L"ld" ) == 0 )
                    dwCmd = CMDPARAM_RESULT_LD;
            }
            else if ( ::StrCmpI( cszCmd, L"i" ) == 0 )
                dwCmd = CMDPARAM_INTERRUPTED;
        }
    }

Exit:
    DebugTrace(0, "m_dwCmd=%d, dwRP=%d", dwCmd, *pdwRP);
    TraceFunctLeave();
    return( dwCmd );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\marshost.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    MarsHost.h

Abstract:
    Initialization of mars

Revision History:
    Anand Arvind (aarvind)      2000-01-05
        created
    Seong Kook Khang (SKKhang)  05/10/00
        Clean up for Whistler.

******************************************************************************/

#ifndef _MARSHOST_H__INCLUDED_
#define _MARSHOST_H__INCLUDED_

#pragma once

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>

#include <exdisp.h>
#include <exdispid.h>

#include <marscore.h>

//#define MARS_NEW

/////////////////////////////////////////////////////////////////////////////
//
// CSRWebBrowserEvents
//
/////////////////////////////////////////////////////////////////////////////

class CSRWebBrowserEvents;
typedef IDispEventImpl<0,CSRWebBrowserEvents,&DIID_DWebBrowserEvents2,&LIBID_SHDocVw,1> CSRWebBrowserEvents_DispWBE2;

class ATL_NO_VTABLE CSRWebBrowserEvents :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CSRWebBrowserEvents_DispWBE2
    //public IDispEventImpl<0,CSRWebBrowserEvents,&DIID_DWebBrowserEvents2,&LIBID_SHDocVw,1>
{
public:
    CSRWebBrowserEvents();
    virtual ~CSRWebBrowserEvents();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSRWebBrowserEvents)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSRWebBrowserEvents)
    COM_INTERFACE_ENTRY2(IDispatch,          CSRWebBrowserEvents_DispWBE2)
    COM_INTERFACE_ENTRY2(DWebBrowserEvents2, CSRWebBrowserEvents_DispWBE2)
    //COM_INTERFACE_ENTRY(IDispatch)
    //COM_INTERFACE_ENTRY(DWebBrowserEvents2)
END_COM_MAP()

BEGIN_SINK_MAP(CSRWebBrowserEvents)
    SINK_ENTRY_EX(0, DIID_DWebBrowserEvents2, DISPID_BEFORENAVIGATE2,   BeforeNavigate2  )
    SINK_ENTRY_EX(0, DIID_DWebBrowserEvents2, DISPID_NEWWINDOW2,        NewWindow2       )
    SINK_ENTRY_EX(0, DIID_DWebBrowserEvents2, DISPID_NAVIGATECOMPLETE2, NavigateComplete2)
    SINK_ENTRY_EX(0, DIID_DWebBrowserEvents2, DISPID_DOCUMENTCOMPLETE,  DocumentComplete )
END_SINK_MAP()

// Attributes
protected:
    CComPtr<IWebBrowser2>  m_pWB2;

// Operations
public:
    void  Attach( /*[in]*/ IWebBrowser2* pWB );
    void  Detach();

// Event Handlers
public:
    void __stdcall BeforeNavigate2( IDispatch *pDisp, VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers, VARIANT_BOOL* Cancel );
    void __stdcall NewWindow2( IDispatch **ppDisp, VARIANT_BOOL* Cancel );
    void __stdcall NavigateComplete2( IDispatch *pDisp, VARIANT* URL );
    void __stdcall DocumentComplete( IDispatch *pDisp, VARIANT* URL );
};

typedef CComObject<CSRWebBrowserEvents> CSRWebBrowserEvents_Object;


/////////////////////////////////////////////////////////////////////////////
//
// CSRMarsHost
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CSRMarsHost :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSRMarsHost>,
    public IMarsHost
{
public:
    CSRMarsHost();
    virtual ~CSRMarsHost();

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CSRMarsHost)
    COM_INTERFACE_ENTRY(IMarsHost)
END_COM_MAP()

    HRESULT FinalConstruct();
    HRESULT Passivate();

// Attributes
public:
    CComPtr<IInternetSecurityManager> m_secmgr; // Aggregated object.

    bool                        m_fPassivated;
    CSRWebBrowserEvents_Object  *m_cWebBrowserEvents;

// IMarsHost methods
public:
    STDMETHOD(OnHostNotify)( /*[in]*/ MARSHOSTEVENT event,
                             /*[in]*/ IUnknown *punk,
                             /*[in]*/ LPARAM lParam );

    STDMETHOD(OnNewWindow2)( /*[in,out]*/ IDispatch **ppDisp,
                             /*[in,out]*/ VARIANT_BOOL *Cancel );

    STDMETHOD(FindBehavior)( /*[in]*/ IMarsPanel *pPanel,
                             /*[in]*/ BSTR bstrBehavior,
                             /*[in]*/ BSTR bstrBehaviorUrl,
                             /*[in]*/ IElementBehaviorSite *pSite,
                             /*[retval,out]*/ IElementBehavior **ppBehavior );

    STDMETHOD(OnShowChrome)( /*[in]*/ BSTR bstrWebPanel,
                             /*[in]*/ DISPID dispidEvent,
                             /*[in]*/ BOOL fVisible,
                             /*[in]*/ BSTR bstrCurrentPlace,
                             /*[in]*/ IMarsPanelCollection *pMarsPanelCollection );

	STDMETHOD(PreTranslateMessage)( /*[in]*/ MSG *msg );
};

typedef CComObject<CSRMarsHost> CSRMarsHost_Object;

/////////////////////////////////////////////////////////////////////////////


#endif //_MARSHOST_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PCHealth.rc
//
#define IDS_PROJNAME                           100
#define IDR_RSTRUI                             110
#define IDR_RSTRCLI                            111
#define IDR_RSTRCALENDAR                       112
#define IDR_RSTRPROGRESS                       113
#define IDR_RSTREDIT                           114

#define IDS_RESTOREUI_TITLE                    2048
#define IDS_ERR_RSTR_UNKNOWN                   2049
#define IDS_ERR_RSTR_INVALID_CONFIG_FILE       2050
#define IDS_ERR_RSTR_CANNOT_CREATE_DOMDOC      2051
#define IDS_ERR_RSTR_TITLE                     2052
#define IDS_ERR_RSTR_OUT_OF_MEMORY             2054
#define IDS_ERR_RSTR_LOW_DISK                  2056
#define IDS_ERR_ALL_DRIVES_NOT_ACTIVE1         2060
#define IDS_ERR_ALL_DRIVES_NOT_ACTIVE2         2061
#define IDS_ERR_SERVICE_DEAD                   2062
#define IDS_ERR_LOW_PRIVILEGE                  2063

#define IDS_RESTOREUI_INFOTIP                  2078
#define IDS_NONE                               2079
#define IDS_ENDOFDAY                           2080
#define IDS_CANCEL_RESTORE                     2081
#define IDS_ERR_SR_DISABLED                    2082
#define IDS_ERR_SR_MOVEFILEEX_EXIST            2083
#define IDS_SAVEAS_FILTER                      2084
#define IDS_SAVETEXT_DEFAULT                   2085
#define IDS_ERR_SR_FROZEN                      2087
#define IDS_RESTORE_SAFEMODE                   2088
#define IDS_ERR_SR_DISABLED_GROUP_POLICY       2089
#define IDS_ERR_DOMAIN_CHANGED                 2090
#define IDS_ERR_OTHER_USERS_LOGGED_ON1         2092
#define IDS_ERR_OTHER_USERS_LOGGED_ON2         2093
#define IDS_ERR_SR_LOWDISK                     2094
#define IDS_UNKNOWN_RP                         2095
#define IDS_APPLICATION_INSTALL                2096 
#define IDS_APPLICATION_UNINSTALL              2097
#define IDS_DESKTOP_SETTING                    2098    /* Not implemented */
#define IDS_ACCESSIBILITY_SETTING              2099    /* Not implemented */
#define IDS_OE_SETTING                         2100    /* Not implemented */
#define IDS_APPLICATION_RUN                    2101    /* Not implemented */
#define IDS_RESTORE                            2102
#define IDS_CHECKPOINT                         2103
#define IDS_WINDOWS_SHUTDOWN                   2104    /* Not implemented */
#define IDS_WINDOWS_BOOT                       2105    /* Not implemented */
#define IDS_DEVICE_DRIVER_INSTALL              2106
#define IDS_FIRSTRUN                           2107
#define IDS_MODIFY_SETTINGS                    2108
#define IDS_CANCELLED_OPERATION                2109  
#define IDS_BACKUP_RECOVERY                    2110
#define IDS_PRODUCTFEEDBACK                    2111
#define IDS_PFFAILED                           2112
#define IDS_PFFAILEDLOWDISK                    2113
#define IDS_PFSUCCESS                          2114
#define IDS_PFINTERRUPTED                      2115


#define ID_APP_EXIT     0x8001

#define IDD_PROCLIST        201
#define IDC_LIST_PROCESS    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrerr.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    rstrerr.h

Abstract:
    This file contains the Error Codes for use in various restore components

Revision History:
    Seong Kook Khang (skkhang)  04/20/99
        created

******************************************************************************/

#ifndef _RSTRERR_H__INCLUDED_
#define _RSTRERR_H__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#pragma once


// General defines
#define  MAX_ERROR_STRING_LENGTH   1024


//
// Trace IDs on the client side
//

#define E_RSTR_INVALID_CONFIG_FILE          MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0501)
#define E_RSTR_CANNOT_CREATE_DOMDOC         MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0502)
#define E_RSTR_NO_PROBLEM_AREAS             MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0503)
#define E_RSTR_NO_PROBLEM_AREA_ATTRS        MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0504)
#define E_RSTR_NO_REQUIRED_ATTR             MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0505)
#define E_RSTR_NO_UPLOAD_LIBRARY            MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0506)
#define E_RSTR_CANNOT_CREATE_TRANSLATOR     MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0507)
#define E_RSTR_INVALID_SPECFILE             MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0508)
#define E_RSTR_CANNOT_CREATE_DELTAENGINE    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0509)


//
// Application Specific Error Messages
//
// Right now, actual messages are only in rstrlog.exe tool.
//

#define ERROR_RSTR_CANNOT_CREATE_EXTRACT_DIR    0x2001
#define ERROR_RSTR_EXTRACT_FAILED               0x2002

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif //_RSTRERR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrpriv.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    rstrpriv.h

Abstract:
    This file defines common constants and utility macros, and contains the
    declarations of private utility functions.

Revision History:
    Seong Kook Khang (SKKhang)  07/07/99
        created

******************************************************************************/

#ifndef _RSTRPRIV_H__INCLUDED_
#define _RSTRPRIV_H__INCLUDED_

#pragma once

//#include <changelog.h>
#include <srdefs.h>
#include <srrestoreptapi.h>
#include <ppath.h>
#include <utils.h>
#include <snapshot.h>
#include <srshell.h>

// System Restore Application Start Mode
enum
{
    SRASM_NORMAL,       // Show Main Page
    SRASM_SUCCESS,      // Show Success Result Page
    SRASM_FAIL,         // Show Failure Result Page
    SRASM_FAILLOWDISK,  // Show Fail-Low-Disk Result Page
    SRASM_FAILINTERRUPTED
};

#ifdef TEST_UI_ONLY
////////////////////////////////////////////////////////////////////////////
// Temporary definitions until entire SR components are in place
////////////////////////////////////////////////////////////////////////////

// from constants.h
static LPCTSTR  s_cszHiddenSFPEnableVal = TEXT("2567");
static LPCTSTR  s_cszHiddenSFPDisableVal = TEXT("2803");

#if 0
// statemgr.dll
BOOL  DisableArchivingI( BOOL fMode );
#define DisableArchiving  DisableArchivingI

// from sfpcapi.h
extern BOOL  DisableSFP( BOOL fDisable, LPCTSTR pszKey );
extern BOOL  DisableFIFO( INT64 llSeqNum );
extern BOOL  EnableFIFO();

// from restoreptlog.h
typedef struct _RestorePtLogEntry
{
    DWORD   m_dwSize;
    DWORD   m_dwType;
    INT64   m_llSeqNum;
    time_t  ltime;
    WCHAR   m_szCab[16];
    CHAR    m_bDesc[1];
} RESTOREPTLOGENTRY, *PRESTOREPTLOGENTRY;

// from restoreptapi.h
BOOL  FindFirstRestorePt( PRESTOREPTLOGENTRY *ppEntry );
BOOL  FindNextRestorePt( PRESTOREPTLOGENTRY *ppEntry );
BOOL  ShutRestorePtAPI(PRESTOREPTLOGENTRY *ppEntry);
#endif

// from srrestoreptapi.h

// from chglogapi.h
extern BOOL  InitChgLogAPI();
extern BOOL  ShutChgLogAPI();
extern VOID  FreeChgLogPtr( LPVOID pPtr );
extern BOOL  GetArchiveDir( LPTSTR* ppszArchiveDir );
extern BOOL  RequestDSAccess( BOOL fMode );

// from vxdlog.h
enum
{
    OPR_UNKNOWN         = 0,
    OPR_FILE_ADD        = 1,
    OPR_FILE_DELETE     = 2,
    OPR_FILE_MODIFY     = 3,
    OPR_RENAME          = 4,
    OPR_SETATTRIB       = 5,
    OPR_DIR_CREATE      = 6,
    OPR_DIR_DELETE      = 7
};

typedef struct VXD_LOG_ENTRY
{
    DWORD  m_dwSize;
    DWORD  m_dwType;
    DWORD  m_dwAttrib;
    DWORD  m_dwSfp;
    DWORD  m_dwFlags;
    INT64  m_llSeq;
    CHAR   m_szProc[16];
    BYTE   m_bDrive[16];
    CHAR   m_szTemp[16];
    CHAR   m_bData[1];
} VxdLogEntry;

#define MAX_VXD_LOG_ENTRY  ( sizeof(VxdLogEntry) + 3 * MAX_PPATH_SIZE )

// from restmap.h
typedef struct RESTORE_MAP_ENTRY
{
    DWORD m_dwSize;
    DWORD m_dwOperation ;
    DWORD m_dwAttribute ;
    BYTE  m_bDrive[16];
    BYTE  m_szCab [16];
    BYTE  m_szTemp[16];
    CHAR  m_bData [ 1 ];
} RestoreMapEntry;

extern BOOL  CreateRestoreMap( INT64 nSeqNum, LPTSTR szRestFile, DWORD *pdwErrorCode );

////////////////////////////////////////////////////////////////////////////
// END of Temporary stuffs
////////////////////////////////////////////////////////////////////////////
#endif //def TEST_UI_ONLY

#ifdef TEST_UI_ONLY
#else
//extern "C" __declspec(dllimport) BOOL  DisableArchiving( BOOL fMode );
#endif


// RESTORE SHELL
#define TID_RSTR_MAIN           0x0500
#define TID_RSTR_CLIWND         0x0501
#define TID_RSTR_RPDATA         0x0502
#define TID_RSTR_RSTRMAP        0x0503
#define TID_RSTR_UTIL           0x0504
#define TID_RSTR_LOGFILE        0x0505
#define TID_RSTR_PROCLIST       0x0506
#define TID_RSTR_RSTRCAL        0x0507
#define TID_RSTR_RSTRPROG       0x0508
#define TID_RSTR_RSTRSHL        0x0509
#define TID_RSTR_RSTREDIT       0x050A
#define TID_RSTR_UNDO           0x050B

#define MAX_STR_TITLE  256
#define MAX_STR_MSG    1024

#define SAFE_RELEASE(p) \
    if ( (p) != NULL ) \
    { \
        (p)->Release(); \
        p = NULL; \
    } \

#define SAFE_DELETE(p) \
    if ( (p) != NULL ) \
    { \
        delete p; \
        p = NULL; \
    } \

#define SAFE_DEL_ARRAY(p) \
    if ( (p) != NULL ) \
    { \
        delete [] p; \
        p = NULL; \
    } \

#define VALIDATE_INPUT_ARGUMENT(x) \
    { \
        _ASSERT(NULL != x); \
        if (NULL == x) \
        { \
            ErrorTrace(TRACE_ID, "Invalid Argument, NULL input parameter"); \
            hr = E_INVALIDARG; \
            goto Exit; \
        } \
    }

#define VALIDATE_INPUT_VARIANT(var,type) \
    if (V_VT(&var) != type) \
    { \
        ErrorTrace(TRACE_ID, "Invalid Argument, V_VT(var)=%d is not expected type %d",V_VT(&var),type); \
        hr = E_INVALIDARG; \
        goto Exit; \
    } \

#define COPYBSTR_AND_CHECK_ERROR(bstrDest,bstrSrc) \
    { \
        _ASSERT(bstrSrc.Length() > 0); \
        bstrDest = bstrSrc; \
        if (!bstrDest) \
        { \
            FatalTrace(TRACE_ID, "Out of memory, cannot allocate string"); \
            hr = E_OUTOFMEMORY; \
            goto Exit; \
        } \
    }

#define COPYBSTRFROMLPCTSTR_AND_CHECK_ERROR(bstrDest,szSrc) \
    { \
        _ASSERT(szSrc); \
        _ASSERT(szSrc[0] != TCHAR('\0')); \
        bstrDest = szSrc; \
        if (!bstrDest) \
        { \
            FatalTrace(TRACE_ID, "Out of memory, cannot allocate string"); \
            hr = E_OUTOFMEMORY; \
            goto Exit; \
        } \
    }

#define ALLOCATEBSTR_AND_CHECK_ERROR(pbstrDest,bstrSrc) \
    { \
        if ( (LPCWSTR)(bstrSrc) == NULL || ((LPCWSTR)(bstrSrc))[0] == L'\0' ) \
        { \
            pbstrDest = NULL; \
        } \
        else \
        { \
            *pbstrDest = ::SysAllocString(bstrSrc); \
            if (NULL == *pbstrDest) \
            { \
                FatalTrace(TRACE_ID, "Out of memory, cannot allocate string"); \
                hr = E_OUTOFMEMORY; \
                goto Exit; \
            } \
        } \
    }


#define STR_REGPATH_RUNONCE         L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
#define STR_REGVAL_RUNONCE          L"*Restore"

#define UNDOTYPE_LOWDISK        1
#define UNDOTYPE_INTERRUPTED    2


#define RSTRMAP_MIN_WIN_DISK_SPACE_MB   (50)         // 50 MB limit for now
#define RSTRMAP_LOW_WIN_DISK_SPACE_MB   (10)         // 10 MB limit for now

//
// Registry key strings from the file constants.h
//
static LPCWSTR  s_cszUIFreezeSize = L"UIFreezeSize";
static LPCWSTR  s_cszSeqNumPath   = L"system\\restore\\rstrseq.log";

//extern HWND  g_hFrameWnd;

//
// Global Variables from MAIN.CPP
//
extern HINSTANCE  g_hInst;

inline int  PCHLoadString( UINT uID, LPWSTR lpBuf, int nBufMax )
{
    return( ::LoadString( g_hInst, uID, lpBuf, nBufMax ) );
}

//
// Functions from UNDO.CPP
//
extern BOOL    UndoRestore( int nType );
extern BOOL    CancelRestorePoint( void );

//
// Functions from UTIL.CPP
//
extern int      SRUtil_SetCalendarTypeBasedOnLocale(LCID locale);
extern LPCWSTR  GetSysErrStr();
extern LPCWSTR  GetSysErrStr( DWORD dwErr );
extern LPSTR    IStrDupA( LPCSTR szSrc );
extern LPWSTR   IStrDupW( LPCWSTR wszSrc );
extern BOOL     SRFormatMessage( LPWSTR szMsg, UINT uFmtId, ... );
extern BOOL     ShowSRErrDlg( UINT uMsgId, ... );
extern BOOL     SRGetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD *pdwData );
//extern LPWSTR  PathElem2Str( PathElement *pElem );
//extern LPWSTR  ParsedPath2Str( ParsedPath *pPath, LPCWSTR wszDrive );
extern BOOL     IsFreeSpaceOnWindowsDrive( void );
extern LANGID   GetDefaultUILang(void);
extern BOOL     ShutDownStateMgr(void);

#ifdef UNICODE
#define IStrDup IStrDupW
#else
#define IStrDup IStrDupA
#endif //ifdef UNICODE

//
// String handling class
//
class CSRStr
{
public:
    CSRStr();
    CSRStr( LPCWSTR wszSrc );
    CSRStr( LPCSTR szSrc );
    ~CSRStr();

// Attributes
public:
    int  LengthW();
    int  LengthA();
    inline int  Length()
    {
#ifdef UNICODE
        return( LengthW() );
#else
        return( LengthA() );
#endif
    }
    operator LPCWSTR();
    operator LPCSTR();

protected:
    int     m_cchW;
    LPWSTR  m_strW;
    int     m_cchA;
    LPSTR   m_strA;

// Operations
public:
    void  Empty();
    BOOL  SetStr( LPCWSTR wszSrc, int cch = -1 );
    BOOL  SetStr( LPCSTR szSrc, int cch = -1 );
    const CSRStr& operator =( LPCWSTR wszSrc );
    const CSRStr& operator =( LPCSTR szSrc );

protected:
    BOOL  ConvertA2W();
    BOOL  ConvertW2A();
    void  Release();
};


//
// Dynamic Array class
//
template<class type, int nBlock>
class CSRDynPtrArray
{
public:
    CSRDynPtrArray();
    ~CSRDynPtrArray();

// Attributes
public:
    int   GetSize()
    {  return( m_nCur );  }
    int   GetUpperBound()
    {  return( m_nCur-1 );  }
    type  GetItem( int nItem );
    type  operator[]( int nItem )
    {  return( GetItem( nItem ) );  }

protected:
    int   m_nMax;   // Maximum Item Count
    int   m_nCur;   // Current Item Count
    type  *m_ppTable;

// Operations
public:
    BOOL  AddItem( type item );
    BOOL  Empty();
    void  DeleteAll();
    void  ReleaseAll();
};

template<class type, int nBlock>
CSRDynPtrArray<type, nBlock>::CSRDynPtrArray()
{
    m_nMax = 0;
    m_nCur = 0;
    m_ppTable = NULL;
}

template<class type, int nBlock>
CSRDynPtrArray<type, nBlock>::~CSRDynPtrArray()
{
    Empty();
}

template<class type, int nBlock>
type  CSRDynPtrArray<type, nBlock>::GetItem( int nItem )
{
    if ( nItem < 0 || nItem >= m_nCur )
    {
        // ERROR - Out of Range
    }
    return( m_ppTable[nItem] );
}

template<class type, int nBlock>
BOOL  CSRDynPtrArray<type, nBlock>::AddItem( type item )
{
    type  *ppTableNew;

    if ( m_nCur == m_nMax )
    {
        m_nMax += nBlock;

        // Assuming m_ppTable and m_nMax are always in sync.
        // Review if it's necessary to validate this assumption.
        if ( m_ppTable == NULL )
            ppTableNew = (type*)::HeapAlloc( ::GetProcessHeap(), 0, m_nMax*sizeof(type) );
        else
            ppTableNew = (type*)::HeapReAlloc( ::GetProcessHeap(), 0, m_ppTable, m_nMax * sizeof(type) );

        if ( ppTableNew == NULL )
        {
            // FATAL, Memory Insufficient...
            return FALSE;
        }
        m_ppTable = ppTableNew;
    }
    m_ppTable[m_nCur++] = item;
    return( TRUE );
}

template<class type, int nBlock>
BOOL  CSRDynPtrArray<type, nBlock>::Empty()
{
    if ( m_ppTable != NULL )
    {
        ::HeapFree( ::GetProcessHeap(), 0, m_ppTable );
        m_ppTable = NULL;
        m_nMax = 0;
        m_nCur = 0;
    }
    return( TRUE );
}

template<class type, int nBlock>
void  CSRDynPtrArray<type, nBlock>::DeleteAll()
{
    for ( int i = m_nCur-1;  i >= 0;  i-- )
        delete m_ppTable[i];

    Empty();
}

template<class type, int nBlock>
void  CSRDynPtrArray<type, nBlock>::ReleaseAll()
{
    for ( int i = m_nCur-1;  i >= 0;  i-- )
        m_ppTable[i]->Release();

    Empty();
}


#endif //_RSTRPRIV_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrmap.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    rstrmap.h

Abstract:
    This file contains the declaration of the CRestoreMapManager class, which
    manages restore map and performs necessary operations

Revision History:
    Seong Kook Khang (SKKhang)  07/06/99
        created

    Anand Arvind (aarvind) 1999-10-10
        Added status for tracking of restore process
        Split restore process into three seperate operations
        If A: or B: then no restoring takes place

******************************************************************************/

#ifndef _RSTRMAP_H__INCLUDED_
#define _RSTRMAP_H__INCLUDED_

#pragma once

enum
{
    RSTRMAP_STATUS_NONE = 0,
    RSTRMAP_STATUS_STARTED,
    RSTRMAP_STATUS_INITIALIZING,
    RSTRMAP_STATUS_CREATING_MAP,
    RSTRMAP_STATUS_RESTORING,
    RSTRMAP_STATUS_FINISHED

};

struct SMapEntry
{
    DWORD     dwID;             // Internal ID Number
    DWORD     dwOperation;      // Type of Operation
    DWORD     dwFlags;
    DWORD     dwAttribute;      // Attribute
    CSRStr    strDrive;         // Hard drive GUID
    CSRStr    strCab;           // CAB file name
    CSRStr    strTemp;          // Temp file name
    CSRStr    strTempPath;      // Full path of Temp file
    CSRStr    strSrc;           // Source path
    CSRStr    strSrcSFN;        // Source path, SFN
    CSRStr    strDst;           // Destination path
    CSRStr    strDstSFN;        // Destination path, SFN
    DWORD     dwRes;            // Result of Operation
    DWORD     dwErr;            // Error code, if applicable
    SMapEntry  *pNext;          // Link
};


/////////////////////////////////////////////////////////////////////////////
// CRestoreMapManager

class CRestoreMapManager
{
public:
    CRestoreMapManager();
    ~CRestoreMapManager();

// Operations
public:
    BOOL   Initialize( INT64 llSeqNum, BOOL fUI );
    BOOL   InitRestoreMap( INT64 llSeqNum, INT nMinProgressVal, INT nMaxProgressVal, BOOL fUI );
    BOOL   FInit_Initialize( INT64 llSeqNum, LPCWSTR cszCAB, BOOL fUI );
    BOOL   FInit_RestoreMap( INT64 llSeqNum, LPCWSTR cszCAB, INT nMinProgressVal, INT nMaxProgressVal, BOOL fUI );
    BOOL   DoOperation( BOOL fUI, INT nMinProgressVal, INT nMaxProgressVal);
    INT    CurrentProgress(void);
    BOOL   AreRestoreDrivesActive( BOOL *fAllDrivesActive, WCHAR *szInactiveDrives);

protected:
    void   CleanUp();
    DWORD  ExtractFile( LPCWSTR cszCAB, LPCWSTR cszTmp, LPCWSTR cszDrive, LPCWSTR &rcszTmp );
    void   ExtractFile( SMapEntry *pEnt );
    BOOL   CreatePlaceHolderFile( LPCWSTR cszFile );
    BOOL   ProcessRegSnapLog( LPCWSTR cszRegCAB );
    BOOL   UpdateSystemRegistry( LPCWSTR cszTmpPath, BOOL fUI );
    BOOL   UpdateUserRegistry( LPCWSTR cszTmpPath );
    BOOL   ScanDependency( SMapEntry *pEnt );
    BOOL   UpdateWinInitForDirRename( SMapEntry *pEntRen );
    BOOL   CanFIFO( int chDrive );

    BOOL  IsDriveValid( LPCWSTR cszDrive );

    void  OprFileAdd( SMapEntry *pEnt );
    void  OprFileDelete( SMapEntry *pEnt );
    void  OprFileModify( SMapEntry *pEnt );
    void  OprRename( SMapEntry *pEnt );
    void  OprSetAttribute( SMapEntry *pEnt );
    void  OprDirectoryCreate( SMapEntry *pEnt );
    void  OprDirectoryDelete( SMapEntry *pEnt );
    void  AbortRestore( BOOL fUndo, BOOL fIsDiskFull, BOOL fUI );
    void  ChangeSrcToCPFileName( SMapEntry *pEnt );
    void  SetRegKeyRestoreFail( BOOL fUI );
    void  SetRegKeyRestoreFailLowDisk( BOOL fUI );

    void  GetSFN( SMapEntry *pEnt, DWORD dwFlags = 0 );

    BOOL  InitLogFile( DWORD dwEntry );
    BOOL  WriteLogEntry( SMapEntry *pEnt );
    void  CloseLogFile();

    BOOL  InitWinInitFile();
    BOOL  WriteWinInitEntry( LPCWSTR cszKey, LPCWSTR cszVal );
    BOOL  CloseWinInitFile( BOOL fDiscard );

    BOOL  CreateS2LMapFile();
    BOOL  WriteS2LMapEntry( DWORD dwType, LPCWSTR cszSFN, LPCWSTR cszLFN, DWORD dwAttr = 0 );
    BOOL  CloseS2LMapFile();

// Attributes
protected:
    SMapEntry  m_sMapEnt;            // Regular Map Entries
    SMapEntry  m_sMapReg;            // Map Entries for the Registry
    INT        m_nMaxMapEnt ;        // Number of map entries
    INT        m_nMaxMapReg ;        // Number of registry map entries
    INT        m_nRestoreStatus ;    // Status of operation
    INT        m_nRestoreProgress ;  // Progress value
    INT        m_fInitChgLogCalled ; // Called API so shutdown to be done
    INT        m_fRMapEntriesExist ; // Set if there are no entires in Restore Map

    WCHAR      m_szDSArchive[MAX_PATH+1];
    WCHAR      m_szWinInitPath[MAX_PATH+1];
    WCHAR      m_szWinInitErr[MAX_PATH+1];
    HANDLE     m_hfLog;
    HANDLE     m_hfSeqNumLog;
    INT        m_pfDrive[26];
    BOOL       m_fFIFODisabled;

    WCHAR      m_szWITmp[MAX_PATH];
    HANDLE     m_hfWinInitTmp;
    WCHAR      m_szS2LMap[MAX_PATH+1];
    HANDLE     m_hfS2LMap;
};


#endif //_RSTRMAP_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrprog.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    rstrprog.cpp

Abstract:
    This file contains the implementation of the CRstrProgress class, which
    wraps Progress Bar control from the Common Control.

Revision History:
    Seong Kook Khang (SKKhang)  10/08/99
        created

******************************************************************************/

#include "stdwin.h"
#include "stdatl.h"
#include "resource.h"
#include "rstrpriv.h"
#include "srui_htm.h"
#include "rstrprog.h"


#ifndef WS_EX_LAYOUTRTL
#define WS_EX_NOINHERITLAYOUT   0x00100000L // Disable inheritence of mirroring by children
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif /* WS_EX_LAYOUTRTL */

/////////////////////////////////////////////////////////////////////////////
//
// CRstrProgress
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CRstrProgress message handlers

LRESULT
CRstrProgress::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceFunctEnter("CRstrProgress::OnSetFocus");
    LRESULT lRes = CComControl<CRstrProgress>::OnSetFocus(uMsg, wParam, lParam, bHandled);
    if (m_bInPlaceActive)
    {
        DoVerbUIActivate(&m_rcPos,  NULL);
        if(!IsChild(::GetFocus()))
            m_cCtrl.SetFocus();
    }
    TraceFunctLeave();
    return lRes;
}

LRESULT
CRstrProgress::OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
    TraceFunctEnter("CRstrProgress::OnCreate");
    RECT rc;
    WORD wLangId ;

    GetWindowRect(&rc);
    rc.right -= rc.left;
    rc.bottom -= rc.top;
    rc.top = rc.left = 0;

    //
    // Based on language change method of creating the progress bar
    //
    wLangId = GetDefaultUILang();

    if ( PRIMARYLANGID(wLangId) == LANG_ARABIC ||
         PRIMARYLANGID(wLangId) == LANG_HEBREW )
    {
        m_cCtrl.Create(m_hWnd, rc, NULL,
                        WS_BORDER | WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
                        WS_EX_LAYOUTRTL, IDC_PROGRESS);
    }
    else
    {
        m_cCtrl.Create(m_hWnd, rc, NULL,
                        WS_BORDER | WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
                        0, IDC_PROGRESS);
    };

    Fire_OnCreate();

    TraceFunctLeave();
    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRstrProgress - IOleInPlaceObject methods

STDMETHODIMP
CRstrProgress::SetObjectRects( LPCRECT prcPos, LPCRECT prcClip )
{
    TraceFunctEnter("CRstrProgress::SetObjectRects");
    IOleInPlaceObjectWindowlessImpl<CRstrProgress>::SetObjectRects(prcPos, prcClip);
    int cx, cy;
    cx = prcPos->right - prcPos->left;
    cy = prcPos->bottom - prcPos->top;
    ::SetWindowPos(m_cCtrl.m_hWnd, NULL, 0,
        0, cx, cy, SWP_NOZORDER | SWP_NOACTIVATE);
    TraceFunctLeave();
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRstrProgress - IRstrProgress properties

STDMETHODIMP
CRstrProgress::get_hWnd( OLE_HANDLE *phWnd )
{
    TraceFunctEnter("CRstrProgress::get_hWnd");
    HRESULT  hr = S_OK;
    VALIDATE_INPUT_ARGUMENT(phWnd);

    *phWnd = (OLE_HANDLE)m_cCtrl.m_hWnd;

Exit:
    TraceFunctLeave();
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRstrProgress::put_Max( long lMax )
{
    TraceFunctEnter("CRstrProgress::put_Max");

    long  lMin = m_cCtrl.SendMessage( PBM_GETRANGE, TRUE, NULL );
    m_cCtrl.SendMessage( PBM_SETRANGE32, lMin, lMax );

    TraceFunctLeave();
    return( S_OK );
}

STDMETHODIMP
CRstrProgress::get_Max( long *plMax )
{
    TraceFunctEnter("CRstrProgress::get_Max");
    HRESULT  hr = S_OK;
    VALIDATE_INPUT_ARGUMENT(plMax);

    *plMax = m_cCtrl.SendMessage( PBM_GETRANGE, FALSE, NULL );

Exit:
    TraceFunctLeave();
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRstrProgress::put_Min( long lMin )
{
    TraceFunctEnter("CRstrProgress::put_Min");

    long  lMax = m_cCtrl.SendMessage( PBM_GETRANGE, FALSE, NULL );
    m_cCtrl.SendMessage( PBM_SETRANGE32, lMin, lMax );

    TraceFunctLeave();
    return( S_OK );
}

STDMETHODIMP
CRstrProgress::get_Min( long *plMin )
{
    TraceFunctEnter("CRstrProgress::get_Min");
    HRESULT  hr = S_OK;
    VALIDATE_INPUT_ARGUMENT(plMin);

    *plMin = m_cCtrl.SendMessage( PBM_GETRANGE, TRUE, NULL );

Exit:
    TraceFunctLeave();
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRstrProgress::put_Value( long lValue )
{
    TraceFunctEnter("CRstrProgress::put_Value");

    m_cCtrl.SendMessage( PBM_SETPOS, lValue, 0 );

    TraceFunctLeave();
    return( S_OK );
}

STDMETHODIMP
CRstrProgress::get_Value( long *plValue )
{
    TraceFunctEnter("CRstrProgress::get_Value");
    HRESULT  hr = S_OK;
    VALIDATE_INPUT_ARGUMENT(plValue);

    *plValue = m_cCtrl.SendMessage( PBM_GETPOS, 0, 0 );

Exit:
    TraceFunctLeave();
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CRstrProgress - IRstrProgress methods


/////////////////////////////////////////////////////////////////////////////
// CRstrProgress - DRstrProgressEvents firing methods

STDMETHODIMP
CRstrProgress::Fire_OnCreate()
{
    TraceFunctEnter("CRstrProgress::Fire_OnCreate");
    HRESULT  hr = S_OK ;
    CComPtr<IDispatch>  pDispatch;
    DISPPARAMS  dpArgs = { NULL, NULL, 0, 0 };

    Lock();
    IUnknown  **ppUnk = m_vec.begin();
    while ( ppUnk < m_vec.end() )
    {
        if ( *ppUnk != NULL )
        {
            pDispatch  = reinterpret_cast<IDispatch*>(*ppUnk);
            hr = pDispatch->Invoke( 1,  // DISPID_DRSTRCALENDAREVENTS_ONCREATE
                                IID_NULL,
                                LOCALE_USER_DEFAULT,
                                DISPATCH_METHOD,
                                &dpArgs,
                                NULL,
                                NULL,
                                NULL );
            DebugTrace(TRACE_ID, "Invoke returned %d", hr);
        }
        ppUnk++;
    }
    Unlock();

    TraceFunctLeave();
    return( hr );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrprog.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    rstrprog.h

Abstract:
    This file contains the declaration of the CRstrProgress class, which
    wraps Progress control from the Common Control.

Revision History:
    Seong Kook Khang (SKKhang)  10/08/99
        created

******************************************************************************/

#ifndef _RSTRPROG_H__INCLUDED_
#define _RSTRPROG_H__INCLUDED_

#pragma once

//#include "resource.h"       // main symbols
//#include <atlctl.h>


#define IDC_PROGRESS  100


/////////////////////////////////////////////////////////////////////////////
// CRstrProgress

class ATL_NO_VTABLE CRstrProgress :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CRstrProgress, IRstrProgress, &IID_IRstrProgress, &LIBID_RestoreUILib>,
	public CComControl<CRstrProgress>,
	public IPersistStreamInitImpl<CRstrProgress>,
	public IOleControlImpl<CRstrProgress>,
	public IOleObjectImpl<CRstrProgress>,
	public IOleInPlaceActiveObjectImpl<CRstrProgress>,
	public IViewObjectExImpl<CRstrProgress>,
	public IOleInPlaceObjectWindowlessImpl<CRstrProgress>,
	public IPersistStorageImpl<CRstrProgress>,
	public ISpecifyPropertyPagesImpl<CRstrProgress>,
	public IQuickActivateImpl<CRstrProgress>,
	public IDataObjectImpl<CRstrProgress>,
	public IProvideClassInfo2Impl<&CLSID_RstrProgress, NULL, &LIBID_RestoreUILib>,
    public IConnectionPointContainerImpl<CRstrProgress>,
    public IConnectionPointImpl<CRstrProgress, &DIID_DRstrProgressEvents>,
	public CComCoClass<CRstrProgress, &CLSID_RstrProgress>
{
public:
	CContainedWindow m_cCtrl;
	
	CRstrProgress() : m_cCtrl(PROGRESS_CLASS, this, 1)
    {
        m_bWindowOnly = TRUE;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_RSTRPROGRESS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRstrProgress)
	COM_INTERFACE_ENTRY(IRstrProgress)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CRstrProgress)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("BackColor",   DISPID_BACKCOLOR,   CLSID_StockColorPage)
	PROP_ENTRY("ForeColor",   DISPID_FORECOLOR,   CLSID_StockColorPage)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CRstrProgress)
    CONNECTION_POINT_ENTRY(DIID_DRstrProgressEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CRstrProgress)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	CHAIN_MSG_MAP(CComControl<CRstrProgress>)
ALT_MSG_MAP(1)
	// Replace this with message map entries for superclassed SysMonthCal32
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);

// IOleInPlaceObject
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IRstrProgress
public:
	OLE_COLOR m_clrBackColor;
	OLE_COLOR m_clrForeColor;

public:
    STDMETHOD(get_hWnd)( OLE_HANDLE *phWnd );
    STDMETHOD(put_Max)( long lMax );
    STDMETHOD(get_Max)( long *plMax );
    STDMETHOD(put_Min)( long lMin );
    STDMETHOD(get_Min)( long *plMin );
    STDMETHOD(put_Value)( long lValue );
    STDMETHOD(get_Value)( long *plValue );

// DRstrProgressEvents firing methods
public:
    STDMETHOD(Fire_OnCreate)();

// Properties
protected:

// Operations
protected:
};


#endif //_RSTRPROG_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrmgr.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    rstrmgr.cpp

Abstract:
    This file contains the implementation of the CRestoreManager class, which
    controls overall restoration process and provides methods to control &
    help user experience flow.

Revision History:
    Seong Kook Khang (SKKhang)  05/10/00
        created

******************************************************************************/

#include "stdwin.h"
#include "resource.h"
#include "rstrpriv.h"
#include "rstrmgr.h"
#include "extwrap.h"
#include "..\rstrcore\resource.h"

#define MAX_STR_DATETIME  256
#define MAX_STR_MESSAGE   1024

/*
#define PROGRESSBAR_INITIALIZING_MAXVAL     30
#define PROGRESSBAR_AFTER_INITIALIZING      30
#define PROGRESSBAR_AFTER_RESTORE_MAP       40
#define PROGRESSBAR_AFTER_RESTORE           100
*/

#define GET_FLAG(mask)      ( ( m_dwFlags & (mask) ) != 0 )
#define SET_FLAG(mask,val)  ( (val) ? ( m_dwFlags |= (mask) ) : ( m_dwFlags &= ~(mask) ) )


/////////////////////////////////////////////////////////////////////////////
//
// CSRTime
//
/////////////////////////////////////////////////////////////////////////////

CSRTime::CSRTime()
{
    SetToCurrent();
}

const CSRTime& CSRTime::operator=( const CSRTime &cSrc )
{
    TraceFunctEnter("CSRTime::operator=");
    m_st = cSrc.m_st;
    TraceFunctLeave();
    return( *this );
}

PSYSTEMTIME  CSRTime::GetTime()
{
    TraceFunctEnter("CSRTime::GetTime -> SYSTEMTIME*");
    TraceFunctLeave();
    return( &m_st );
}

void  CSRTime::GetTime( PSYSTEMTIME pst )
{
    TraceFunctEnter("CSRTime::GetTime -> SYSTEMTIME*");
    *pst = m_st;
    TraceFunctLeave();
}

BOOL  CSRTime::GetTime( PFILETIME pft )
{
    TraceFunctEnter("CSRTime::GetTime -> FILETIME*");
    BOOL  fRet = FALSE;

    if ( !::SystemTimeToFileTime( &m_st, pft ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::SystemTimeToFileTime failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

#define COMPARE_AND_EXIT_ON_DIFF(a,b) \
    nDiff = (a) - (b); \
    if ( nDiff != 0 ) \
        goto Exit; \

int  CSRTime::Compare( CSRTime &cTime )
{
    TraceFunctEnter("CSRTime::Compare");
    int         nDiff;
    SYSTEMTIME  *st = cTime.GetTime();

    COMPARE_AND_EXIT_ON_DIFF( m_st.wYear,         st->wYear );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wMonth,        st->wMonth );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wDay,          st->wDay );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wHour,         st->wYear );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wMinute,       st->wMonth );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wSecond,       st->wDay );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wMilliseconds, st->wDay );

Exit:
    TraceFunctLeave();
    return( nDiff );
}

int  CSRTime::CompareDate( CSRTime &cTime )
{
    TraceFunctEnter("CSRTime::CompareDate");
    int         nDiff;
    SYSTEMTIME  *st = cTime.GetTime();

    COMPARE_AND_EXIT_ON_DIFF( m_st.wYear,  st->wYear );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wMonth, st->wMonth );
    COMPARE_AND_EXIT_ON_DIFF( m_st.wDay,   st->wDay );

Exit:
    TraceFunctLeave();
    return( nDiff );
}

BOOL  CSRTime::SetTime( PFILETIME pft, BOOL fLocal )
{
    TraceFunctEnter("CSRTime::SetFileTime");
    BOOL  fRet = FALSE;
    FILETIME    ft;
    SYSTEMTIME  st;

    if ( !fLocal )
    {
        if ( !::FileTimeToLocalFileTime( pft, &ft ) )
        {
            LPCWSTR  cszErr = ::GetSysErrStr();
            ErrorTrace(TRACE_ID, "::FileTimeToLocalFileTime failed - %ls", cszErr);
            goto Exit;
        }
    }
    else
        ft = *pft;

    if ( !::FileTimeToSystemTime( &ft, &st ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::FileTimeToSystemTime failed - %ls", cszErr);
        goto Exit;
    }
    m_st = st;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

void  CSRTime::SetTime( PSYSTEMTIME st )
{
    TraceFunctEnter("CSRTime::SetSysTime");
    m_st = *st;
    TraceFunctLeave();
}

void  CSRTime::SetToCurrent()
{
    TraceFunctEnter("CSRTime::SetToCurrent");
    ::GetLocalTime( &m_st );
    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreManager
//
/////////////////////////////////////////////////////////////////////////////

BOOL  CreateRestoreManagerInstance( CRestoreManager **ppMgr )
{
    TraceFunctEnter("CreateRestoreManagerInstance");
    BOOL  fRet = FALSE;

    if ( ppMgr == NULL )
    {
        FatalTrace(TRACE_ID, "Invalid parameter, ppMgr is NULL...");
        goto Exit;
    }
    *ppMgr = new CRestoreManager;
    if ( *ppMgr == NULL )
    {
        FatalTrace(TRACE_ID, "Cannot create CRestoreManager instance...");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreManager construction

CRestoreManager::CRestoreManager()
{
    TraceFunctEnter("CRestoreManager::CRestoreManager");

    m_nStartMode  = SRRSM_NORMAL;
    m_fNeedReboot = FALSE;
    m_hwndFrame   = NULL;

    m_nMainOption = RMO_RESTORE;
    //m_nStatus     = SRRMS_NONE;
    m_fDenyClose  = FALSE;
    m_dwFlags     = 0;
    m_dwFlagsEx   = 0;
    m_nSelectedRP = 0;
    m_nRealPoint  = 0;
    m_ullManualRP = 0;

    m_nRPUsed     = -1;
    m_nRPNew      = -1;

    //m_nRPI         = 0;
    //m_aryRPI      = NULL;
    m_nLastRestore = -1;
    
    m_pCtx         =NULL;
    
    //m_nRFI    = 0;
    //m_aryRFI = NULL;

    //DisableArchiving( FALSE );

    TraceFunctLeave();
}

CRestoreManager::~CRestoreManager()
{
    TraceFunctEnter("CRestoreManager::~CRestoreManager");

    Cleanup();

    TraceFunctLeave();
}

void  CRestoreManager::Release()
{
    TraceFunctEnter("CRestoreManager::Release");

    delete this;

    TraceFunctLeave();
}

void FormatDriveNameProperly(WCHAR * pszDrive)
{
    WCHAR * pszIndex;
    pszIndex = wcschr( pszDrive, L':' );
    if (NULL != pszIndex)
    {
        *pszIndex = L'\0';
    }
}
     

/////////////////////////////////////////////////////////////////////////////
// CRestoreManager properties - Common

BOOL  CRestoreManager::CanRunRestore( BOOL fThawIfFrozen )
{
    TraceFunctEnter("CRestoreManager::CanRunRestore");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    DWORD    fDisable = FALSE;
    DWORD    dwDSMin;
    DWORD    dwRes, dwType, cbData;
    WCHAR    szMsg[MAX_STR_MSG];
    WCHAR    szTitle[MAX_STR_TITLE];
    ULARGE_INTEGER ulTotal, ulAvail, ulFree;
    WCHAR    szSystemDrive[10], szSystemDriveCopy[10];
    
    // Check if SR is disabled via group policy
    if ( ::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszGroupPolicy, s_cszDisableSR, &fDisable ) && fDisable)
    {
        ErrorTrace(0, "SR is DISABLED by group policy!!!");
        ::ShowSRErrDlg( IDS_ERR_SR_DISABLED_GROUP_POLICY );
        goto Exit;
    }

    fDisable = FALSE;
    // Check if SR is disabled
    if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDisableSR, &fDisable ) )
        goto Exit;
    if ( fDisable )
    {
        ErrorTrace(0, "SR is DISABLED!!!");

        //
        // if safemode, show different error message
        //
        if (0 != GetSystemMetrics(SM_CLEANBOOT))
        {
            ShowSRErrDlg(IDS_RESTORE_SAFEMODE);
            goto Exit;
        }
        
        if ( ::LoadString( g_hInst, IDS_ERR_SR_DISABLED, 
                           szMsg, MAX_STR_MESSAGE ) == 0 )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_ERR_SR_DISABLED,
cszErr);
            goto Exit;
        }
        if ( ::LoadString( g_hInst, IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE ) == 0 )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_RESTOREUI_TITLE, cszErr);
            // continue anyway...
        }
        if ( ::MessageBox( NULL, szMsg, szTitle, MB_YESNO ) == IDYES )
        {
            STARTUPINFO sSI;
            PROCESS_INFORMATION sPI;
            WCHAR szCmdLine[MAX_PATH] = L"control sysdm.cpl,,4";

            ZeroMemory (&sSI, sizeof(sSI));
            sSI.cb = sizeof(sSI);
            if ( !::CreateProcess( NULL, szCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &sSI, &sPI ) )
            {
                cszErr = ::GetSysErrStr();
                ErrorTrace(0, "::CreateProcess failed - %ls", cszErr);
                goto Exit;
            }
            ::CloseHandle( sPI.hThread );
            ::CloseHandle( sPI.hProcess );
        }
        goto Exit;
    }
    
    // Check if service is running
    if ( FALSE == IsSRServiceRunning())
    {
        ErrorTrace(0, "Service is not running...");
        ::ShowSRErrDlg( IDS_ERR_SERVICE_DEAD );
        goto Exit;
    }


    // get free disk space
    
    ulTotal.QuadPart = 0;
    ulAvail.QuadPart = 0;
    ulFree.QuadPart  = 0;

    if ( FALSE == GetSystemDrive( szSystemDrive ) )
    {
        ErrorTrace(0, "SR cannot get system drive!!!");
        goto CheckSRAgain;
    }

    if ( szSystemDrive[2] != L'\\' )
         szSystemDrive[2] = L'\\';

    
    // Check if SR is frozen
    if ( fThawIfFrozen && ::IsSRFrozen() )
    {
        ErrorTrace(0, "SR is Frozen!!!");

        if ( FALSE == GetDiskFreeSpaceEx( szSystemDrive,
                                          &ulAvail,
                                          &ulTotal,
                                          &ulFree ) )
        {
            ErrorTrace(0, "SR cannot get free disk space!!!");
            goto CheckSRAgain;
        }

        if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDSMin, &dwDSMin ) )
            dwDSMin = SR_DEFAULT_DSMIN;

        if ( ulFree.QuadPart >= (dwDSMin * MEGABYTE) )
        {
            STATEMGRSTATUS sMgrStatus;
            RESTOREPOINTINFO  sRPInfo;

            // Thaw SR by creating a restore point

            sRPInfo.dwEventType      = BEGIN_SYSTEM_CHANGE;
            sRPInfo.dwRestorePtType  = CHECKPOINT;
            sRPInfo.llSequenceNumber = 0;
            if (ERROR_SUCCESS != SRLoadString(L"srrstr.dll", IDS_SYSTEM_CHECKPOINT_TEXT, sRPInfo.szDescription, MAX_PATH))
            {            
                lstrcpy(sRPInfo.szDescription, s_cszSystemCheckpointName);
            }
            if ( !::SRSetRestorePoint( &sRPInfo, &sMgrStatus ) )
            {
                ErrorTrace(TRACE_ID, "SRSetRestorePoint failed");
                goto CheckSRAgain;
            }
        }
    }

CheckSRAgain:

    // Check if SR is frozen
    if ( ::IsSRFrozen() )
    {
        if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDSMin, &dwDSMin ) )
        {
            dwDSMin = SR_DEFAULT_DSMIN;
        }
        lstrcpy(szSystemDriveCopy, szSystemDrive);
        FormatDriveNameProperly(szSystemDriveCopy);
        ::SRFormatMessage( szMsg, IDS_ERR_SR_FROZEN, dwDSMin,
                           szSystemDriveCopy );
        if ( ::LoadString( g_hInst, IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE ) == 0 )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_RESTOREUI_TITLE, cszErr);
            // continue anyway...
        }
        if ( ::MessageBox( NULL, szMsg, szTitle, MB_YESNO ) == IDYES )
        {
            ::InvokeDiskCleanup( szSystemDrive );
        }
        goto Exit;
    }

    // check if there is enough free space for restore to operate without freezing
    // needed free space = 60mb for restoration + 20 mb for restore restore point
    if (FALSE == GetDiskFreeSpaceEx(szSystemDrive,
                                    &ulAvail,
                                    &ulTotal,
                                    &ulFree))
    {
        ErrorTrace(0, "! GetDiskFreeSpaceEx : %ld", GetLastError());
        goto Exit;
    }            

    if (ulFree.QuadPart <= THRESHOLD_UI_DISKSPACE * MEGABYTE)
    {
        DebugTrace(0, "***Less than 80MB free - cannot run restore***");        
        
        ::SRFormatMessage( szMsg, IDS_ERR_SR_LOWDISK, THRESHOLD_UI_DISKSPACE, szSystemDrive );
        if ( ::LoadString( g_hInst, IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE ) == 0 )
        {
            cszErr = ::GetSysErrStr();
            ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_RESTOREUI_TITLE, cszErr);
            // continue anyway...
        }
        if ( ::MessageBox( NULL, szMsg, szTitle, MB_YESNO ) == IDYES )
        {
            ::InvokeDiskCleanup( szSystemDrive );
        }
        goto Exit;
    }
    
    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

int  CRestoreManager::GetFirstDayOfWeek()
{
    TraceFunctEnter("CRestoreManager::GetFirstDayOfWeek");
    int    nFirstDay = -1;
    WCHAR  szBuf[100];
    int    nRet;
    int    nDay;

    nRet = ::GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IFIRSTDAYOFWEEK,
                            szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if ( nRet == 0 )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "GetLocaleInfo(IFIRSTDAYOFWEEK) failed - %ls", cszErr);
        goto Exit;
    }
    nDay = ::_wtoi( szBuf );
    if ( nDay < 0 || nDay > 6 )
    {
        ErrorTrace(TRACE_ID, "Out of range, IFIRSTDAYOFWEEK = %d", nDay);
        goto Exit;
    }

    DebugTrace(TRACE_ID, "nFirstDay=%d", nFirstDay);
    nFirstDay = nDay;

Exit:
    TraceFunctLeave();
    return( nFirstDay );
}

/***************************************************************************/

BOOL  CRestoreManager::GetIsRPSelected()
{
    TraceFunctEnter("CRestoreManager::GetIsRPSelected");
    TraceFunctLeave();
    return( GET_FLAG( SRRMF_ISRPSELECTED ) );
}

/***************************************************************************/

BOOL  CRestoreManager::GetIsSafeMode()
{
    TraceFunctEnter("CRestoreManager::GetIsSafeMode");
    BOOL  fIsSafeMode;

    fIsSafeMode = ( ::GetSystemMetrics( SM_CLEANBOOT ) != 0 );

    TraceFunctLeave();
    return( fIsSafeMode );
}

/***************************************************************************/

BOOL  CRestoreManager::GetIsSmgrAvailable()
{
    TraceFunctEnter("CRestoreManager::GetIsSmgrAvailable");

#if BUGBUG  //NYI
    WCHAR  szTitle[MAX_STR_TITLE];
    WCHAR  szFmt[MAX_STR_MSG];
    WCHAR  szMsg[MAX_STR_MSG];

    DWORD  dwType, dwValue, dwSize, dwRet;
    WCHAR  szBuf[16];

    HRESULT hr = S_OK;
    BOOL    fSmgrUnavailable = FALSE ;

    VALIDATE_INPUT_ARGUMENT(pfSmgr);

    //
    // If StateMgr is not alive
    //
    if ( NULL == FindWindow(s_cszIDCSTATEMGRPROC, s_cszIDSAPPTITLE))
    {
        PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );
        PCHLoadString( IDS_ERR_RSTR_SMGR_NOT_ALIVE, szMsg, MAX_STR_MSG );
        ::MessageBox( m_hWndShell, szMsg, szTitle, MB_OK | MB_ICONINFORMATION );
        fSmgrUnavailable = TRUE ;
    }

    //
    // If SM is frozen
    //
    dwType = REG_DWORD;
    dwSize = sizeof(dwValue);
    dwRet  = ::SHGetValue(HKEY_LOCAL_MACHINE,
                          s_cszReservedDiskSpaceKey,
                          s_cszStatus, &dwType, &dwValue, &dwSize );

    if ( dwRet == ERROR_SUCCESS && dwValue == SMCONFIG_FROZEN )
    {
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwRet = ::SHGetValue(HKEY_LOCAL_MACHINE,
                                s_cszReservedDiskSpaceKey,
                                s_cszMin, &dwType, &dwValue, &dwSize );
        if ( dwRet != ERROR_SUCCESS || dwValue == 0 )
            dwValue = SMCONFIG_MIN;
        PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );
        PCHLoadString( IDS_RESTORE_SMFROZEN, szFmt, MAX_STR_MSG );
        ::wsprintf( szMsg, szFmt, dwValue );
        ::MessageBox( m_hWndShell, szMsg, szTitle, MB_OK | MB_ICONINFORMATION );
        fSmgrUnavailable = TRUE ;
    }
    else {
        //
        // If SR is disabled
        //
        dwType = REG_SZ;
        dwSize = sizeof(szBuf)-1;
        dwRet  = ::SHGetValue( HKEY_LOCAL_MACHINE,
                               L"System\\CurrentControlSet\\Services\\VxD\\VxDMon",
                               L"SystemRestore", &dwType, szBuf, &dwSize );
        if ( dwRet != ERROR_SUCCESS || StrCmpI( szBuf, L"Y" ) != 0 )
        {
            PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );
            PCHLoadString( IDS_RESTORE_DISABLED, szMsg, MAX_STR_MSG );
            ::MessageBox( m_hWndShell, szMsg, szTitle, MB_OK | MB_ICONINFORMATION );
            fSmgrUnavailable = TRUE ;
        }

    };

    if ( fSmgrUnavailable ) {
        *pfSmgr = VARIANT_TRUE ;
    }
    else
        *pfSmgr = VARIANT_FALSE ;
#endif //BUGBUG

    TraceFunctLeave();
    return( TRUE );
}

/***************************************************************************/

BOOL  CRestoreManager::GetIsUndo()
{
    TraceFunctEnter("CRestoreManager::GetIsUndo");
    TraceFunctLeave();
    return( GET_FLAG( SRRMF_ISUNDO ) );
}

/***************************************************************************/

int  CRestoreManager::GetLastRestore()
{
    TraceFunctEnter("CRestoreManager::GetLastRestore");
    int  nLastRP;

    if ( UpdateRestorePointList() )
        nLastRP = m_nLastRestore;
    else
        nLastRP = -1;

    TraceFunctLeave();
    return( nLastRP );
}

/***************************************************************************/

int  CRestoreManager::GetMainOption()
{
    TraceFunctEnter("CRestoreManager::GetMainOption");
    TraceFunctLeave();
    return( m_nMainOption );
}

/***************************************************************************/

LPCWSTR  CRestoreManager::GetManualRPName()
{
    TraceFunctEnter("CRestoreManager::GetManualRPName");
    TraceFunctLeave();
    return( m_strManualRP );
}

/***************************************************************************/

void  CRestoreManager::GetMaxDate( PSYSTEMTIME pstMax )
{
    TraceFunctEnter("CRestoreManager::GetMaxDate");
    m_stRPMax.GetTime( pstMax );
    TraceFunctLeave();
}

/***************************************************************************/

void  CRestoreManager::GetMinDate( PSYSTEMTIME pstMin )
{
    TraceFunctEnter("CRestoreManager::GetMinDate");
    m_stRPMin.GetTime( pstMin );
    TraceFunctLeave();
}

/***************************************************************************/

int  CRestoreManager::GetRealPoint()
{
    TraceFunctEnter("CRestoreManager::GetRealPoint");
    TraceFunctLeave();
    return( m_nRealPoint );
}

/***************************************************************************/

PSRFI  CRestoreManager::GetRFI( int nIndex )
{
    TraceFunctEnter("CRestoreManager::GetRFI");
    PSRFI  pRet = NULL;

    if ( nIndex < 0 || nIndex >= m_aryRFI.GetSize() )
    {
        ErrorTrace(TRACE_ID, "Out of range, nIndex=%d - m_nRFI=%d", nIndex, m_aryRFI.GetSize());
        goto Exit;
    }

    pRet = m_aryRFI[nIndex];
    if ( pRet == NULL )
    {
        ErrorTrace(TRACE_ID, "FATAL, entry is NULL: nIndex=%d, m_nRFI=%d", nIndex, m_aryRFI.GetSize());
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( pRet );
}

/***************************************************************************/

int  CRestoreManager::GetRFICount()
{
    TraceFunctEnter("CRestoreManager::GetRFICount");
    TraceFunctLeave();
    return( m_aryRFI.GetSize() );
}

/***************************************************************************/

PSRPI  CRestoreManager::GetRPI( int nIndex )
{
    TraceFunctEnter("CRestoreManager::GetRPI");
    PSRPI  pRet = NULL;

    if ( nIndex < 0 || nIndex >= m_aryRPI.GetSize() )
    {
        ErrorTrace(TRACE_ID, "Out of range, nIndex=%d - m_nRPI=%d", nIndex, m_aryRPI.GetSize());
        goto Exit;
    }

    pRet = m_aryRPI[nIndex];
    if ( pRet == NULL )
    {
        ErrorTrace(TRACE_ID, "FATAL, entry is NULL: nIndex=%d, m_nRPI=%d", nIndex, m_aryRPI.GetSize());
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return( pRet );
}

/***************************************************************************/

int  CRestoreManager::GetRPICount()
{
    TraceFunctEnter("CRestoreManager::GetRPICount");
    TraceFunctLeave();
    return( m_aryRPI.GetSize() );
}

/***************************************************************************/

void  CRestoreManager::GetSelectedDate( PSYSTEMTIME pstSel )
{
    TraceFunctEnter("CRestoreManager::GetSelectedDate");
    m_stSelected.GetTime( pstSel );
    TraceFunctLeave();
}

/***************************************************************************/

LPCWSTR  CRestoreManager::GetSelectedName()
{
    TraceFunctEnter("CRestoreManager::GetSelectedName");
    TraceFunctLeave();
    return( m_strSelected );
}

/***************************************************************************/

int  CRestoreManager::GetSelectedPoint()
{
    TraceFunctEnter("CRestoreManager::GetSelectedPoint");
    TraceFunctLeave();
    return( m_nSelectedRP );
}

/***************************************************************************/

int  CRestoreManager::GetStartMode()
{
    TraceFunctEnter("CRestoreManager::GetStartMode");
    TraceFunctLeave();
    return( m_nStartMode );
}

/***************************************************************************/

void  CRestoreManager::GetToday( PSYSTEMTIME pstToday )
{
    TraceFunctEnter("CRestoreManager::GetToday");
    m_stToday.GetTime( pstToday );
    TraceFunctLeave();
}

/***************************************************************************/

void  CRestoreManager::SetIsRPSelected( BOOL fSel )
{
    TraceFunctEnter("CRestoreManager::SetIsRPSelected");
    SET_FLAG( SRRMF_ISRPSELECTED, fSel );
    TraceFunctLeave();
}

/***************************************************************************/

void  CRestoreManager::SetIsUndo( BOOL fUndo )
{
    TraceFunctEnter("CRestoreManager::SetIsUndo");
    SET_FLAG( SRRMF_ISUNDO, fUndo );
    TraceFunctLeave();
}

/***************************************************************************/

BOOL  CRestoreManager::SetMainOption( int nOpt )
{
    TraceFunctEnter("CRestoreManager::SetMainOption");
    BOOL  fRet = FALSE;

    if ( nOpt >= RMO_RESTORE && nOpt <  RMO_MAX )
    {
        m_nMainOption = nOpt;
        fRet = TRUE;
    }

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

void  CRestoreManager::SetManualRPName( LPCWSTR cszRPName )
{
    TraceFunctEnter("CRestoreManager::SetManualRPName");

    m_strManualRP = cszRPName;

    TraceFunctLeave();
}

/***************************************************************************/

void  CRestoreManager::SetSelectedDate( PSYSTEMTIME pstSel )
{
    TraceFunctEnter("CRestoreManager::SetSelectedDate");
    int  nTop;
    int  i;

    m_stSelected.SetTime( pstSel );
    if ( m_aryRPI.GetSize() == 0 )
        goto Exit;

    nTop = 0;
    for ( i = m_aryRPI.GetUpperBound();  i > 0;  i-- )  // exclude 0
    {
        CSRTime  &rst = m_aryRPI[i]->stTimeStamp;
        if ( m_stSelected.CompareDate( rst ) < 0 )
            continue;
        if ( rst.Compare( m_aryRPI[nTop]->stTimeStamp ) > 0 )
            nTop = i;
    }
    m_nRealPoint = nTop;

Exit:
    TraceFunctLeave();
}

/***************************************************************************/

BOOL  CRestoreManager::SetSelectedPoint( int nRP )
{
    TraceFunctEnter("CRestoreManager::SetSelectedPoint");
    BOOL  fRet = FALSE;

    if ( nRP < 0 || nRP >= m_aryRPI.GetSize() )
    {
        ErrorTrace(TRACE_ID, "Index is out of range");
        goto Exit;
    }

    // Set a flag to indicate a RP has been selected
    SetIsRPSelected( TRUE );

    // Set selected time
    m_stSelected = m_aryRPI[nRP]->stTimeStamp;

    m_nSelectedRP = nRP;
    m_nRealPoint  = nRP;
    UpdateRestorePoint();

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::SetStartMode( int nMode )
{
    TraceFunctEnter("CRestoreManager::SetStartMode");
    BOOL  fRet = FALSE;

    m_nStartMode = nMode;
    if ( nMode != SRRSM_NORMAL )
    {
        //if ( !LoadSettings() )
        //    goto Exit;
    }

    fRet = TRUE;
//Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

void  CRestoreManager::GetUsedDate( PSYSTEMTIME pstDate )
{
    TraceFunctEnter("CRestoreManager::GetUsedDate");
    int  i;

    m_stToday.GetTime( pstDate );
    if ( m_nRPUsed <= 0 )
        goto Exit;

    for ( i = m_aryRPI.GetUpperBound();  i >= 0;  i-- )
        if ( m_aryRPI[i]->dwNum == (DWORD)m_nRPUsed )
        {
            m_aryRPI[i]->stTimeStamp.GetTime( pstDate );
            break;
        }

Exit:
    TraceFunctLeave();
}

/***************************************************************************/

LPCWSTR  CRestoreManager::GetUsedName()
{
    TraceFunctEnter("CRestoreManager::GetUsedName");
    LPCWSTR  cszName = NULL;
    int      i;

    if ( m_nRPUsed <= 0 )
        goto Exit;
    for ( i = m_aryRPI.GetUpperBound();  i >= 0;  i-- )
        if ( m_aryRPI[i]->dwNum == (DWORD)m_nRPUsed )
        {
            cszName = m_aryRPI[i]->strName;
            break;
        }

Exit:
    TraceFunctLeave();
    return( cszName );
}


/***************************************************************************/

DWORD  CRestoreManager::GetUsedType()
{
    TraceFunctEnter("CRestoreManager::GetUsedType");
    DWORD    dwType = -1;
    int      i;

    if ( m_nRPUsed <= 0 )
        goto Exit;
    for ( i = m_aryRPI.GetUpperBound();  i >= 0;  i-- )
        if ( m_aryRPI[i]->dwNum == (DWORD)m_nRPUsed )
        {
            dwType = m_aryRPI[i]->dwType;
            break;
        }

Exit:
    TraceFunctLeave();
    return( dwType );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreManager properties - HTML UI specific

BOOL  CRestoreManager::GetCanNavigatePage()
{
    TraceFunctEnter("CRestoreManager::GetCanNavigatePage");
    TraceFunctLeave();
    return( GET_FLAG( SRRMF_CANNAVIGATEPAGE ) );
}

void  CRestoreManager::SetCanNavigatePage( BOOL fCanNav )
{
    TraceFunctEnter("CRestoreManager::SetCanNavigatePage");
    SET_FLAG( SRRMF_CANNAVIGATEPAGE, fCanNav );
    TraceFunctLeave();
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreManager properties

PSRPI  CRestoreManager::GetUsedRP()
{
    TraceFunctEnter("CRestoreManager::GetUsedRP");
    PSRPI  pRPI = NULL;
    int    i;

    if ( m_nRPUsed <= 0 )
        goto Exit;
    for ( i = m_aryRPI.GetUpperBound();  i >= 0;  i-- )
        if ( m_aryRPI[i]->dwNum == (DWORD)m_nRPUsed )
        {
            pRPI = m_aryRPI[i];
            goto Exit;
        }

Exit:
    TraceFunctLeave();
    return( pRPI );
}

int  CRestoreManager::GetNewRP()
{
    TraceFunctEnter("CRestoreManager::GetNewRP");
    TraceFunctLeave();
    return( m_nRPNew );
}

BOOL CRestoreManager::CheckForDomainChange (WCHAR *pwszFilename, WCHAR *pszMsg)
{
    BOOL fError = FALSE;
    WCHAR wcsCurrent [MAX_PATH];
    WCHAR wcsFile [MAX_PATH];
    WCHAR szMsg [MAX_STR_MSG];

    if (ERROR_SUCCESS == GetDomainMembershipInfo (NULL, wcsCurrent))
    {
        HANDLE hFile = CreateFileW ( pwszFilename,   // file name
                          GENERIC_READ, // file access
                          0,             // share mode
                          NULL,          // SD
                          OPEN_EXISTING, // how to create
                          0,             // file attributes
                          NULL);         // handle to template file

        if (INVALID_HANDLE_VALUE != hFile)
        {
            DWORD dwSize = GetFileSize (hFile, NULL);
            DWORD cbRead;

            if (dwSize != 0xFFFFFFFF && dwSize < MAX_PATH &&
                   (TRUE == ReadFile (hFile, (BYTE *) wcsFile,
                    dwSize, &cbRead, NULL)))
            {
                if (memcmp (wcsCurrent, wcsFile, cbRead) != 0)
                    fError = TRUE;
            }

            CloseHandle (hFile);
        }

        if (fError)
        {
            WCHAR szTitle[MAX_STR_TITLE];
            WCHAR szNone[MAX_STR_TITLE];
            WCHAR *pwszComputer2 = wcsFile;
            WCHAR *pwszDomain2 = pwszComputer2 + lstrlenW(pwszComputer2)+ 1;
            WCHAR *pwszFlag2 = pwszDomain2 + lstrlenW(pwszDomain2) + 1;
            WCHAR *pwszComputer1 = wcsCurrent;
            WCHAR *pwszDomain1 = pwszComputer1 + lstrlenW(pwszComputer1)+ 1;
            WCHAR *pwszFlag1 =  pwszDomain1 + lstrlenW (pwszDomain1) + 1;
            WCHAR *pwszWorkgroup1 = NULL;
            WCHAR *pwszWorkgroup2 = NULL;

            if ( ::LoadString( g_hInst, IDS_NONE, szNone, MAX_STR_TITLE) == 0)
            {
                lstrcpy (szNone, L" ");   // use blanks instead
            }
            pwszWorkgroup1 = szNone;
            pwszWorkgroup2 = szNone;

            if (pwszFlag1[0] != L'1')  // change domain to workgroup
            {
                WCHAR *pTemp = pwszWorkgroup1;
                pwszWorkgroup1 = pwszDomain1;
                pwszDomain1 = pTemp;
            }

            if (pwszFlag2[0] != L'1')  // change domain to workgroup
            {
                WCHAR *pTemp = pwszWorkgroup2;
                pwszWorkgroup2 = pwszDomain2;
                pwszDomain2 = pTemp;
            }
            PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );

            ::SRFormatMessage( pszMsg, IDS_ERR_DOMAIN_CHANGED,
                                   pwszComputer1, pwszComputer2,
                                   pwszWorkgroup1, pwszWorkgroup2,
                                   pwszDomain1, pwszDomain2 );

            ::MessageBox( m_hwndFrame, pszMsg, szTitle, MB_ICONWARNING | MB_DEFBUTTON2);
        }
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRestoreManager operations
// Check Restore
// this creates a restore context (m_pCtx) which will be used by BeginRestore
BOOL  CRestoreManager::CheckRestore( BOOL fSilent )
{
    TraceFunctEnter("CRestoreManager::CheckRestore");
    BOOL             fRet = FALSE;
    DWORD            dwRP;

    WCHAR            szTitle[MAX_STR_TITLE];
    WCHAR            szMsg[MAX_STR_MSG];
    WCHAR            szMsg1[MAX_STR_MSG];
    WCHAR            szMsg2[MAX_STR_MSG];
    WCHAR            szOfflineDrives[MAX_STR_MSG];


    m_fDenyClose = TRUE;

    // Disable FIFO starting from the chosen restore point.
    dwRP = m_aryRPI[m_nRealPoint]->dwNum;
    if ( !g_pExternal->DisableFIFO( dwRP ) )
    {
        ErrorTrace(0, "DisableFIFO(%d) failed...", dwRP);
        goto Exit;
    }

    if ( !::PrepareRestore( dwRP, &m_pCtx ) )
    {
        ErrorTrace(0, "Prepare Restore failed...");        
        goto Exit;
    }

    if ( !fSilent )
    {
        //
        // Check if all drives are valid, if some drives are not valid ask user if
        // we should continue with the restore process
        //
        if ( m_pCtx->IsAnyDriveOfflineOrDisabled( szOfflineDrives ) )
        {
            PCHLoadString( IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE );
            PCHLoadString( IDS_ERR_ALL_DRIVES_NOT_ACTIVE1, szMsg1, MAX_STR_MSG );
            PCHLoadString( IDS_ERR_ALL_DRIVES_NOT_ACTIVE2, szMsg2, MAX_STR_MSG );
            ::wsprintf( szMsg, L"%s %s %s", szMsg1, szOfflineDrives, szMsg2 );
            ::MessageBox( m_hwndFrame, szMsg, szTitle,
                          MB_ICONWARNING | MB_DEFBUTTON2);
            

        }
    }
    else
    {
        m_pCtx->SetSilent();
    }
    
    if (!fSilent)
    {
        WCHAR wcsFile [MAX_PATH];
        WCHAR wcsDrive [MAX_PATH / 2];

        GetSystemDrive (wcsDrive);
        MakeRestorePath( wcsFile, wcsDrive, m_aryRPI[m_nRealPoint]->strDir);
        lstrcat (wcsFile, L"\\snapshot\\domain.txt");

        CheckForDomainChange (wcsFile ,szMsg);
    }

    if (GET_FLAG(SRRMF_ISUNDO))
    {
        m_pCtx->SetUndo();
    }
    
    fRet = TRUE;
    
Exit:
    m_fDenyClose = FALSE;
    if ( !fRet )
        SAFE_RELEASE(m_pCtx);
    TraceFunctLeave();
    return( fRet );
}

/////////////////////////////////////////////////////////////////////////////
// CRestoreManager operations
// this uses a restore context (m_pCtx) which was created by CheckRestore
// CheckRestore must be called before this function is called
BOOL  CRestoreManager::BeginRestore( )
{
    TraceFunctEnter("CRestoreManager::BeginRestore");
    BOOL             fRet = FALSE;
    DWORD            dwRP;
    DWORD            dwNewRP;

    m_fDenyClose = TRUE;
    if (NULL == m_pCtx)
    {
        ErrorTrace(0, "m_pCtx is NULL");
        _ASSERT(0);
        goto Exit;        
    }

    // Disable FIFO starting from the chosen restore point.
    dwRP = m_aryRPI[m_nRealPoint]->dwNum;
    if ( !g_pExternal->DisableFIFO( dwRP ) )
    {
        ErrorTrace(0, "DisableFIFO(%d) failed...", dwRP);
        goto Exit;
    }

    if ( !::InitiateRestore( m_pCtx, &dwNewRP ) )
        goto Exit;

    m_fNeedReboot = TRUE;
/*
    if ( ::ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        DebugTrace(0, "ExitWindowsEx succeeded");
    }
    else
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        DebugTrace(0, "ExitWindowsEx failed - %ls", cszErr);

        if ( !g_pExternal->RemoveRestorePoint( dwNewRP ) )
            goto Exit;

        goto Exit;
    }
*/

    fRet = TRUE;
Exit:
    m_fDenyClose = FALSE;
    if ( !fRet )
        SAFE_RELEASE(m_pCtx);
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::Cancel()
{
    TraceFunctEnter("CRestoreManager::Cancel");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    WCHAR    szTitle[256];
    WCHAR    szMsg[1024];

    if ( m_fDenyClose )
        goto Exit;

/*
    if ( ::LoadString( g_hInst, IDS_RESTOREUI_TITLE, szTitle, sizeof(szTitle ) ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_RESTOREUI_TITLE, cszErr);
        goto Exit;
    }
    if ( ::LoadString( g_hInst, IDS_CANCEL_RESTORE, szMsg, sizeof(szMsg ) ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_CANCEL_RESTORE, cszErr);
        goto Exit;
    }

    if ( ::MessageBox( m_hwndFrame, szMsg, szTitle, MB_YESNO ) == IDNO )
        goto Exit;
*/

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::CancelRestorePoint()
{
    TraceFunctEnter("CRestoreManager::CancelRestorePoint");
    BOOL              fRet = FALSE;
    RESTOREPOINTINFO  sRPInfo;
    STATEMGRSTATUS    sSmgrStatus;
    HCURSOR           hCursor;

    hCursor = ::SetCursor( ::LoadCursor( NULL, IDC_WAIT ) );

/*
    sRPInfo.dwEventType      = END_SYSTEM_CHANGE;
    sRPInfo.dwRestorePtType  = CANCELLED_OPERATION ;
    sRPInfo.llSequenceNumber = m_ullManualRP;
    //if ( !::SRSetRestorePoint( &sRPInfo, &sSmgrStatus ) )
    if ( !g_pExternal->SetRestorePoint( &sRPInfo, &sSmgrStatus ) )
    {
        // Why SRSetRestorePoint returns FALSE even though it succeeded?
        // 5/16/00 - would this work now?
        //ErrorTrace(TRACE_ID, "SRSetRestorePoint cancellation failed");
        goto Exit;
    }
*/

    if ( !UpdateRestorePointList() )
        goto Exit;

    fRet = TRUE;
Exit:
    if ( hCursor != NULL )
        ::SetCursor( hCursor );
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::CreateRestorePoint()
{
    TraceFunctEnter("CRestoreManager::CreateRestorePoint");
    BOOL              fRet = FALSE;
    HCURSOR           hCursor;

    hCursor = ::SetCursor( ::LoadCursor( NULL, IDC_WAIT ) );

    if ( !g_pExternal->SetRestorePoint( m_strManualRP, NULL ) )
        goto Exit;

    //m_ullManualRP = sSmgrStatus.llSequenceNumber;

    if ( !UpdateRestorePointList() )
        goto Exit;

    fRet = TRUE;
Exit:
    if ( hCursor != NULL )
        ::SetCursor( hCursor );
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::DisableFIFO()
{
    TraceFunctEnter("CRestoreManager::DisableFIFO");
    BOOL   fRet = FALSE;
    DWORD  dwSize;

    if ( !g_pExternal->DisableFIFO( 1 ) )
    {
        ErrorTrace(TRACE_ID, "DisableFIFO(1) failed...");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::EnableFIFO()
{
    TraceFunctEnter("CRestoreManager::EnableFIFO");
    BOOL   fRet = FALSE;
    DWORD  dwSize;

    if ( g_pExternal->EnableFIFO() != ERROR_SUCCESS )
    {
        ErrorTrace(TRACE_ID, "EnableFIFO() failed...");
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::FormatDate( PSYSTEMTIME pst, CSRStr &str, BOOL fLongFmt )
{
    TraceFunctEnter("CRestoreManager::FormatDate");
    BOOL   fRet;
    DWORD  dwFlag;

    dwFlag = fLongFmt ? DATE_LONGDATE : DATE_SHORTDATE;
    fRet = GetDateStr( pst, str, dwFlag, NULL );

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::FormatLowDiskMsg( LPCWSTR cszFmt, CSRStr &str )
{
    TraceFunctEnter("CRestoreManager::FormatLowDiskMsg");
    BOOL   fRet = FALSE;
    DWORD  dwSize;
    WCHAR  szBuf[MAX_STR_MESSAGE];

    if ( !::SRGetRegDword( HKEY_LOCAL_MACHINE, s_cszSRRegKey, s_cszDSMin, &dwSize ) )
        dwSize = SR_DEFAULT_DSMIN;
    ::wsprintf( szBuf, cszFmt, dwSize );
    str = szBuf;

    fRet = TRUE;
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::FormatTime( PSYSTEMTIME pst, CSRStr &str )
{
    TraceFunctEnter("CRestoreManager::FormatTime");
    BOOL  fRet;

    fRet = GetTimeStr( pst, str, 0 );

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::GetLocaleDateFormat( PSYSTEMTIME pst, LPCWSTR cszFmt, CSRStr &str )
{
    TraceFunctEnter("CRestoreManager::GetLocaleDateFormat");
    BOOL  fRet;

    fRet = GetDateStr( pst, str, 0, cszFmt );

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::GetYearMonthStr( int nYear, int nMonth, CSRStr &str )
{
    TraceFunctEnter("CRestoreManager::GetYearMonthStr");
    BOOL        fRet;
    SYSTEMTIME  st;

    st.wYear  = (WORD)nYear;
    st.wMonth = (WORD)nMonth;
    st.wDay   = 1;
    fRet = GetDateStr( &st, str, DATE_YEARMONTH, NULL );

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::InitializeAll()
{
    TraceFunctEnter("CRestoreManager::InitializeAll");
    BOOL  fRet = FALSE;

    //
    // The InitializeAll function is called every time the user goes to Screen 2
    // to display the calendar so get the system calendar type and set it here
    //
    SRUtil_SetCalendarTypeBasedOnLocale(LOCALE_USER_DEFAULT);

    if ( !UpdateRestorePointList() )
        goto Exit;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::Restore( HWND hwndProgress )
{
    TraceFunctEnter("CRestoreManager::Restore");

#if BUGBUG
    DWORD    dwThreadId ;

    m_hwndProgress = (HWND)hwndProgress;

    //
    // Reset the current bar size
    //
    m_lCurrentBarSize = 0 ;

    //
    // Create thread to run the restore map init
    //
    m_RSThread = CreateThread(NULL,
                  0,
                  RestoreThreadStart,
                  this,
                  0,
                  &dwThreadId);

    if( NULL == m_RSThread )
    {
        FatalTrace(TRACE_ID, "Unable to create Restore thread; hr=0x%x", GetLastError());
        hr = E_FAIL ;
    }
#endif //BUGBUG

    TraceFunctLeave();
    return( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreManager operations

BOOL  CRestoreManager::AddRenamedFolder( PSRFI pRFI )
{
    TraceFunctEnter("CRestoreManager::AddRenamedFolder");
    BOOL  fRet;

    fRet = m_aryRFI.AddItem( pRFI );

    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::SetRPsUsed( int nRPUsed, int nRPNew )
{
    TraceFunctEnter("CRestoreManager::SetRPsUsed");
    BOOL       fRet = FALSE;
    DWORD      dwRet;
    WCHAR      szSysDrv[MAX_PATH];
    WCHAR      szRPDir[MAX_PATH];
    WCHAR      szSSPath[MAX_PATH];
    CSnapshot  cSS;

    if ( !UpdateRestorePointList() )
        goto Exit;

    m_nRPUsed = nRPUsed;
    m_nRPNew  = nRPNew;

    // Calls CSnapshot::CleanupAfterRestore. It is supposed to be safe
    // to call even if there was no restore, so I'm just calling it
    // whenever the log file validation happens.
    ::GetSystemDrive( szSysDrv );
    ::wsprintf( szRPDir, L"%s%d", s_cszRPDir, nRPUsed );
    ::MakeRestorePath( szSSPath, szSysDrv, szRPDir );
    dwRet = cSS.CleanupAfterRestore( szSSPath );
    if ( dwRet != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr(dwRet);
        ErrorTrace(0, "CSnapshot::CleanupAfterRestore failed - %ls", cszErr);
        // ignore the error
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::SilentRestore( DWORD dwRP )
{
    TraceFunctEnter("CRestoreManager::SilentRestore");
    BOOL  fRet = FALSE;
    int   i;

    if ( !CanRunRestore( FALSE ) )
        goto Exit;

    if ( !UpdateRestorePointList() )
        goto Exit;

    if ( dwRP == 0xFFFFFFFF )
    {
        if ( m_aryRPI.GetSize() == 0 )
        {
            goto Exit;
        }
        m_nRealPoint = m_aryRPI.GetUpperBound();
    }
    else
    {
        for ( i = m_aryRPI.GetUpperBound();  i >= 0;  i-- )
        {
            if ( m_aryRPI[i]->dwNum == dwRP )
            {
                m_nRealPoint = i;
                break;
            }
        }
        if ( i < 0 )
        {
            goto Exit;
        }
    }
    DebugTrace(0, "m_nRealPoint=%d, m_nRP=%d", m_nRealPoint, m_aryRPI[m_nRealPoint]->dwNum);

    if ( !CheckRestore(TRUE) )
    {
        ErrorTrace(0, "CheckRestore failed"); 
        goto Exit;
    }
    if ( !BeginRestore( ) )
    {
        ErrorTrace(0, "BeginRestore failed");
        goto Exit;
    }

    m_fNeedReboot = TRUE;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreManager operations - internal

void  CRestoreManager::Cleanup()
{
    TraceFunctEnter("CRestoreManager::Cleanup");
    int  i;

    for ( i = m_aryRPI.GetUpperBound();  i >= 0;  i-- )
    {
        if ( m_aryRPI[i] != NULL )
            delete m_aryRPI[i];
    }
    m_aryRPI.Empty();

    for ( i = m_aryRFI.GetUpperBound();  i >= 0;  i-- )
    {
        if ( m_aryRFI[i] != NULL )
            delete m_aryRFI[i];
    }
    m_aryRFI.Empty();

    TraceFunctLeave();
}

/***************************************************************************/

BOOL  CRestoreManager::GetDateStr( PSYSTEMTIME pst, CSRStr &str, DWORD dwFlags, LPCWSTR cszFmt )
{
    TraceFunctEnter("CRestoreManager::GetDateStr");
    BOOL   fRet = FALSE;
    int    nRet;
    WCHAR  szBuf[MAX_STR_DATETIME];

    nRet = ::GetDateFormat( LOCALE_USER_DEFAULT, dwFlags, pst, cszFmt, szBuf, MAX_STR_DATETIME );
    if ( nRet == 0 )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::GetDateFormat failed - %s", cszErr);
        goto Exit;
    }
    str = szBuf;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

BOOL  CRestoreManager::GetTimeStr( PSYSTEMTIME pst, CSRStr &str, DWORD dwFlags )
{
    TraceFunctEnter("CRestoreManager::GetTimeStr");
    BOOL   fRet = FALSE;
    int    nRet;
    WCHAR  szBuf[MAX_STR_DATETIME];

    nRet = ::GetTimeFormat( LOCALE_USER_DEFAULT, dwFlags, pst, NULL, szBuf, MAX_STR_DATETIME );
    if ( nRet == 0 )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::GetTimeFormat failed - %s", cszErr);
        goto Exit;
    }
    str = szBuf;

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/***************************************************************************/

void  CRestoreManager::UpdateRestorePoint()
{
    TraceFunctEnter("CRestoreManager::UpdateRestorePoint");
    PSRPI       pRPI;
    SYSTEMTIME  st;
    WCHAR       szBuf[MAX_STR_MESSAGE];
    CSRStr      strTime;

    m_strSelected.Empty();

    //if ( m_nRPI <= 0 || m_aryRPI == NULL )
    //    goto Exit;

    pRPI = m_aryRPI[m_nSelectedRP];
    pRPI->stTimeStamp.GetTime( &st );
    GetTimeStr( &st, strTime, TIME_NOSECONDS );
    ::lstrcpy( szBuf, strTime );
    ::lstrcat( szBuf, L" " );
    ::lstrcat( szBuf, pRPI->strName );
    m_strSelected = szBuf;

//Exit:
    TraceFunctLeave();
}

/***************************************************************************/

struct SRPINode
{
    PSRPI     pRPI;
    SRPINode  *pNext;
};

BOOL  CRestoreManager::UpdateRestorePointList()
{
    TraceFunctEnter("CRestoreManager::UpdateRestorePointList");
    BOOL     fRet = FALSE;
    int      i;
    CSRTime  stRP;

    //BUGBUG - Release old restore point list
    m_aryRPI.DeleteAll();

    if ( !g_pExternal->BuildRestorePointList( &m_aryRPI ) )
        goto Exit;
    DebugTrace(TRACE_ID, "# of RP=%d", m_aryRPI.GetSize());

    m_stToday.SetToCurrent();
    m_stRPMin = m_stToday;
    m_stRPMax = m_stToday;
    m_nLastRestore = -1;

    for ( i = 0;  i < m_aryRPI.GetSize();  i++ )
    {
        // Find last "Restore"
        if ( m_aryRPI[i]->dwType == RESTORE )
            m_nLastRestore = i;

        // Get range of dates
        stRP = m_aryRPI[i]->stTimeStamp;
        if ( ( i == 0 ) || ( stRP.Compare( m_stRPMin ) < 0 ) )
            m_stRPMin = stRP;
        if ( stRP.Compare( m_stRPMax ) > 0 )
            m_stRPMax = stRP;
    }

    //
    // BUGBUG - what happens if there were one or more RP, and then when
    //  UI refreshes, everything got FIFOed. Need a thoroughful review...
    //
    if ( m_aryRPI.GetSize() > 0 )
    {
        m_nSelectedRP = m_aryRPI.GetUpperBound();
        m_nRealPoint  = m_aryRPI.GetUpperBound();
        UpdateRestorePoint();
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CRestoreManager attributes

HWND  CRestoreManager::GetFrameHwnd()
{
    TraceFunctEnter("CRestoreManager::GetFrameHwnd");
    TraceFunctLeave();
    return( m_hwndFrame );
}

void  CRestoreManager::SetFrameHwnd( HWND hWnd )
{
    TraceFunctEnter("CRestoreManager::SetFrameHwnd");
    m_hwndFrame = hWnd;
    TraceFunctLeave();
}

/***************************************************************************/

/*
int  CRestoreManager::GetStatus()
{
    TraceFunctEnter("CRestoreManager::GetStatus");
    DebugTrace(TRACE_ID, "m_nStatus=%d", m_nStatus);
    TraceFunctLeave();
    return( m_nStatus );
}
*/

/***************************************************************************/

BOOL  CRestoreManager::DenyClose()
{
    TraceFunctEnter("CRestoreManager::DenyClose");
    DebugTrace(TRACE_ID, "m_fDenyClose=%d", m_fDenyClose);
    TraceFunctLeave();
    return( m_fDenyClose );
}

/***************************************************************************/

BOOL  CRestoreManager::NeedReboot()
{
    TraceFunctEnter("CRestoreManager::NeedReboot");
    DebugTrace(TRACE_ID, "m_fNeedReboot=%d", m_fNeedReboot);
    TraceFunctLeave();
    return( m_fNeedReboot );
}



// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrmgr.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    rstrmgr.h

Abstract:
    This file contains the declaration of the CRestoreManager class, which
    controls overall restoration process and provides methods to control &
    help user experience flow.

Revision History:
    Seong Kook Khang (SKKhang)  05/10/00
        created

******************************************************************************/

#ifndef _RSTRMGR_H__INCLUDED_
#define _RSTRMGR_H__INCLUDED_

#pragma once


/////////////////////////////////////////////////////////////////////////////
//
// Constant Definitions
//
/////////////////////////////////////////////////////////////////////////////

// SR Restore Start Mode
enum
{
    SRRSM_NORMAL = 0,
    SRRSM_SUCCESS,
    SRRSM_FAIL,
    SRRSM_FAILLOWDISK
};

// SR Restore Manager Status
enum
{
    SRRMS_NONE = 0,
    SRRMS_STARTED,
    SRRMS_INITIALIZING,
    SRRMS_CREATING_MAP,
    SRRMS_RESTORING,
    SRRMS_FINISHED
};

// Functionality Chosen in the Main Page
enum
{
    RMO_RESTORE = 0,
    RMO_CREATERP,
    RMO_UNDO,
    RMO_MAX
};

// SR Restore Manager Flags
#define SRRMF_CANNAVIGATEPAGE       0x00000001
#define SRRMF_ISUNDO                0x00000002
#define SRRMF_ISRPSELECTED          0x00000004


/////////////////////////////////////////////////////////////////////////////
//
// CSRTime Definitions
//
/////////////////////////////////////////////////////////////////////////////

class CSRTime
{
public:
    CSRTime();

public:
    const CSRTime& operator=( const CSRTime &cSrc );

public:
    int  GetYear()   {  return( m_st.wYear );  }
    int  GetMonth()  {  return( m_st.wMonth );  }
    int  GetDay()    {  return( m_st.wDay );  }
    operator PSYSTEMTIME() const;
    //operator (FILETIME*)();
    PSYSTEMTIME  GetTime();
    void         GetTime( PSYSTEMTIME pst );
    BOOL         GetTime( PFILETIME pft );

public:
    int   Compare( CSRTime &time );
    int   CompareDate( CSRTime &time );
    BOOL  SetTime( PFILETIME ft, BOOL fLocal=TRUE );
    void  SetTime( PSYSTEMTIME st );
    void  SetToCurrent();

protected:
    SYSTEMTIME  m_st;   // Date/Time in UTC
};


/////////////////////////////////////////////////////////////////////////////
//
// Structure Definitions
//
/////////////////////////////////////////////////////////////////////////////

struct SRestorePointInfo
{
    DWORD      dwType;
    DWORD      dwNum;
    CSRStr     strDir;
    CSRStr     strName;
    CSRTime    stTimeStamp;
    DWORD      dwFlags;
};

typedef SRestorePointInfo  *PSRPI;
typedef CSRDynPtrArray<PSRPI, 32>  CDPA_RPI;

struct SRenamedFolderInfo
{
    CSRStr  strOld;
    CSRStr  strNew;
    CSRStr  strLoc;
};

typedef SRenamedFolderInfo  *PSRFI;
typedef CSRDynPtrArray<PSRFI, 16>  CDPA_RFI;


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreManager
//
/////////////////////////////////////////////////////////////////////////////

class CRestoreManager
{
public:
    CRestoreManager();
    ~CRestoreManager();
    void  Release();

// Properties - main flow
public:
    BOOL     CanRunRestore( BOOL fThawIfFrozen );
    int      GetFirstDayOfWeek();
    BOOL     GetIsRPSelected();
    BOOL     GetIsSafeMode();
    BOOL     GetIsSmgrAvailable();
    BOOL     GetIsUndo();
    int      GetLastRestore();
    int      GetMainOption();
    LPCWSTR  GetManualRPName();
    void     GetMaxDate( PSYSTEMTIME pstMax );
    void     GetMinDate( PSYSTEMTIME pstMin );
    int      GetRealPoint();
    PSRFI    GetRFI( int nIndex );
    int      GetRFICount();
    PSRPI    GetRPI( int nIndex );
    int      GetRPICount();
    void     GetSelectedDate( PSYSTEMTIME pstSel );
    LPCWSTR  GetSelectedName();
    int      GetSelectedPoint();
    int      GetStartMode();
    void     GetToday( PSYSTEMTIME pstToday );
    void     SetIsRPSelected( BOOL fSel );
    void     SetIsUndo( BOOL fUndo );
    BOOL     SetMainOption( int nOpt );
    void     SetManualRPName( LPCWSTR cszRPName );
    void     SetSelectedDate( PSYSTEMTIME pstSel );
    BOOL     SetSelectedPoint( int nRP );
    BOOL     SetStartMode( int nMode );
    void     GetUsedDate( PSYSTEMTIME pstDate );
    LPCWSTR  GetUsedName();
    DWORD    GetUsedType();    

// Properties - HTML UI specific
public:
    BOOL  GetCanNavigatePage();
    void  SetCanNavigatePage( BOOL fCanNav );

// Properties
public:
    PSRPI   GetUsedRP();
    int     GetNewRP();

// Operations - main flow
public:
    BOOL  CheckRestore( BOOL fSilent );
    BOOL  BeginRestore();
    BOOL  Cancel();
    BOOL  CancelRestorePoint();
    BOOL  CreateRestorePoint();
    BOOL  DisableFIFO();
    BOOL  EnableFIFO();
    BOOL  FormatDate( PSYSTEMTIME pst, CSRStr &str, BOOL fLongFmt );
    BOOL  FormatLowDiskMsg( LPCWSTR cszFmt, CSRStr &str );
    BOOL  FormatTime( PSYSTEMTIME pst, CSRStr &str );
    BOOL  GetLocaleDateFormat( PSYSTEMTIME pst, LPCWSTR cszFmt, CSRStr &str );
    BOOL  GetYearMonthStr( int nYear, int nMonth, CSRStr &str );
    BOOL  InitializeAll();
    BOOL  Restore( HWND hwndProgress );

// Operations
public:
    BOOL  AddRenamedFolder( PSRFI pRFI );
    BOOL  SetRPsUsed( int nRPUsed, int nRPNew );
    BOOL  SilentRestore( DWORD dwRP );

// Operations - internal
protected:
    void  Cleanup();
    BOOL  GetDateStr( PSYSTEMTIME pst, CSRStr &str, DWORD dwFlags, LPCWSTR cszFmt );
    BOOL  GetTimeStr( PSYSTEMTIME pst, CSRStr &str, DWORD dwFlags );
    void  UpdateRestorePoint();
    BOOL  UpdateRestorePointList();
    BOOL  CheckForDomainChange (WCHAR *pwszFilename, WCHAR *pszMsg);

// Attributes
public:
    HWND  GetFrameHwnd();
    //int   GetStatus();
    BOOL  DenyClose();
    BOOL  NeedReboot();
    void  SetFrameHwnd( HWND hWnd );
    void  SetIdealSize( int cx, int cy );

protected:
    int      m_nStartMode;
    BOOL     m_fNeedReboot;
    HWND     m_hwndFrame;

    CSRTime  m_stToday;         // Current local date/time
    int      m_nMainOption;     // Option on main screen
    //int      m_nStatus;
    BOOL     m_fDenyClose;
    DWORD    m_dwFlags;
    DWORD    m_dwFlagsEx;
    int      m_nSelectedRP;
    CSRTime  m_stSelected;
    CSRStr   m_strSelected;
    int      m_nRealPoint;
    INT64    m_ullManualRP;
    CSRStr   m_strManualRP;

    int      m_nRPUsed;     // RP used for the last restore
    int      m_nRPNew;      // New "Restore" RP created by the last restore

    // Restore Point specific informations
    CDPA_RPI  m_aryRPI;
    //int       m_nRPI;
    //PSRPI    *m_aryRPI;
    int       m_nLastRestore;
    CSRTime   m_stRPMin;
    CSRTime   m_stRPMax;

    CDPA_RFI  m_aryRFI;
    //int       m_nRFI;
    //PSRFI  *m_aryRFI;
    IRestoreContext  *m_pCtx;    
};

extern CRestoreManager  *g_pRstrMgr;

BOOL  CreateRestoreManagerInstance( CRestoreManager **ppMgr );


#endif //_RSTRMGR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\stdatl.h ===
// stdatl.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDATL_H__INCLUDED_)
#define _STDATL_H__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_MIN_CRT
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

extern  CComModule      _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>

#include <comdef.h>
#include <shlobj.h>

#include <exdisp.h>

#include <marscore.h>

//#include <list>

#include <windowsx.h>
#include <commdlg.h>
#include <commctrl.h>
#include <objsafe.h>

// error ids
//#include "clierror.h"

// common config info
//#include "config.h"

//extern  CCommonConfig   g_ccCommonConfig;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDATL_H__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\rstrshl.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    rstrshl.h

Abstract:
    This file contains the declaration of the CRestoreShell class, which
    provide several methods to be used by HTML scripts. This class wrappes the
    new CRestoreManager class.

Revision History:
    Seong Kook Khang (SKKhang)  10/08/99
        created
    Seong Kook Khang (SKKhang)  05/10/00
        new architecture for Whistler, now CRestoreShell is merely a dummy
        ActiveX control, wrapping the new CRestoreManager class. Most of the
        real functionalities were moved into CRestoreManager.

******************************************************************************/

#ifndef _RSTRSHL_H__INCLUDED_
#define _RSTRSHL_H__INCLUDED_

#pragma once


/////////////////////////////////////////////////////////////////////////////
//
// CRestorePointInfo
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRestorePointInfo :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IRestorePoint, &IID_IRestorePoint, &LIBID_RestoreUILib>
{
public:
    CRestorePointInfo();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CRestorePointInfo)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRestorePointInfo)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRestorePoint)
END_COM_MAP()

// Attributes
public:
    SRestorePointInfo  *m_pRPI;

// Methods
public:
    STDMETHOD(HrInit)( SRestorePointInfo *pRPI );

// IRestorePoint methods
public:
    STDMETHOD(get_Name)( BSTR *pbstrName );
    STDMETHOD(get_Type)( INT *pnType );
    STDMETHOD(get_SequenceNumber)( INT *pnSeq );
    STDMETHOD(get_TimeStamp)( INT nOffDate, VARIANT *pvarTime );
    STDMETHOD(get_Year)( INT *pnYear );
    STDMETHOD(get_Month)( INT *pnMonth );
    STDMETHOD(get_Day)( INT *pnDate );
    STDMETHOD(get_IsAdvanced)( VARIANT_BOOL *pfIsAdvanced );

    STDMETHOD(CompareSequence)( IRestorePoint *pRP, INT *pnCmp );
};

typedef CComObject<CRestorePointInfo>  CRPIObj;


/////////////////////////////////////////////////////////////////////////////
//
// CRenamedFolders
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRenamedFolders :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IRenamedFolders, &IID_IRenamedFolders, &LIBID_RestoreUILib>
{
public:
    CRenamedFolders();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CRenamedFolders)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRenamedFolders)
    COM_INTERFACE_ENTRY(IRenamedFolders)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRestorePoint methods
public:
    STDMETHOD(get_Count)   ( long *plCount );
    STDMETHOD(get_OldName) ( long lIndex, BSTR *pbstrName );
    STDMETHOD(get_NewName) ( long lIndex, BSTR *pbstrName );
    STDMETHOD(get_Location)( long lIndex, BSTR *pbstrName );
};

typedef CComObject<CRenamedFolders>  CRFObj;


/////////////////////////////////////////////////////////////////////////////
//
// CRestoreShell
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRestoreShell :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IRestoreShell, &IID_IRestoreShell, &LIBID_RestoreUILib>,
    public CComCoClass<CRestoreShell, &CLSID_RestoreShellExternal>
{
public:
    CRestoreShell();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CRestoreShell)
DECLARE_CLASSFACTORY_SINGLETON(CRestoreShell)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRestoreShell)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRestoreShell)
END_COM_MAP()

    //HRESULT FinalConstruct();
    //void    FinalRelease();

// Attributes
protected:
    BOOL  m_fFormInitialized;

// IRestoreShell Restore Points Enumerator
public:
    STDMETHOD(Item)( INT nIndex, IRestorePoint** ppRP );
    STDMETHOD(get_Count)( INT *pnCount );

// IRestoreShell Properties
public:
    STDMETHOD(get_CurrentDate)      ( VARIANT *pvarDate );
    STDMETHOD(get_FirstDayOfWeek)   ( INT *pnFirstDay );
    STDMETHOD(get_IsSafeMode)       ( VARIANT_BOOL *pfIsSafeMode );
    STDMETHOD(get_IsUndo)           ( VARIANT_BOOL *pfIsUndo );
    STDMETHOD(put_IsUndo)           ( VARIANT_BOOL fIsUndo );
    STDMETHOD(get_LastRestore)      ( INT *pnLastRestore );
    STDMETHOD(get_MainOption)       ( INT *pnMainOption );
    STDMETHOD(put_MainOption)       ( INT nMainOption );
    STDMETHOD(get_ManualRPName)     ( BSTR *pbstrManualRP );
    STDMETHOD(put_ManualRPName)     ( BSTR bstrManualRP );
    STDMETHOD(get_MaxDate)          ( VARIANT *pvarDate );
    STDMETHOD(get_MinDate)          ( VARIANT *pvarDate );
    STDMETHOD(get_RealPoint)        ( INT *pnPoint );
    STDMETHOD(get_RenamedFolders)   ( IRenamedFolders **ppList );
    STDMETHOD(get_RestorePtSelected)( VARIANT_BOOL *pfRPSel );
    STDMETHOD(put_RestorePtSelected)( VARIANT_BOOL fRPSel );
    STDMETHOD(get_SelectedDate)     ( VARIANT *pvarDate );
    STDMETHOD(put_SelectedDate)     ( VARIANT varDate );
    STDMETHOD(get_SelectedName)     ( BSTR *pbstrName );
    STDMETHOD(get_SelectedPoint)    ( INT *pnPoint );
    STDMETHOD(put_SelectedPoint)    ( INT nPoint );
    STDMETHOD(get_SmgrUnavailable)  ( VARIANT_BOOL *pfSmgr );
    STDMETHOD(get_StartMode)        ( INT *pnMode );
    STDMETHOD(get_UsedDate)         ( VARIANT *pvarDate );
    STDMETHOD(get_UsedName)         ( BSTR *pbstrName );

// IRestoreShell Properties - HTML UI specific
public:
    STDMETHOD(get_CanNavigatePage)  ( VARIANT_BOOL *pfCanNavigatePage );
    STDMETHOD(put_CanNavigatePage)  ( VARIANT_BOOL fCanNavigatePage );

// IRestoreShell Methods
public:
    STDMETHOD(BeginRestore)              ( VARIANT_BOOL *pfBeginRestore );
    STDMETHOD(CheckRestore)              ( VARIANT_BOOL *pfCheckRestore );
    STDMETHOD(Cancel)                    ( VARIANT_BOOL *pfAbort );  
    STDMETHOD(CancelRestorePoint)        ();
    STDMETHOD(CompareDate)               (/*[in]*/ VARIANT varDate1, /*[in]*/ VARIANT varDate2,/*[out, retval]*/ INT *pnCmp);
    STDMETHOD(CreateRestorePoint)        (/*[out,retval]*/ VARIANT_BOOL *pfSucceeded);
    STDMETHOD(DisableFIFO)               ();
    STDMETHOD(EnableFIFO)                ();
    STDMETHOD(FormatDate)                (/*[in]*/ VARIANT varDate, /*[in]*/ VARIANT_BOOL fLongFmt, /*[out, retval]*/ BSTR *pbstrDate);
    STDMETHOD(FormatLowDiskMsg)          (BSTR bstrFmt, BSTR *pbstrMsg);
    STDMETHOD(FormatTime)                (/*[in]*/ VARIANT varTime, /*[out, retval]*/ BSTR *pbstrTime);
    STDMETHOD(GetLocaleDateFormat)       (/*[in]*/ VARIANT varDate, BSTR bstrFormat, BSTR *pbstrDate );
    STDMETHOD(GetYearMonthStr)           (/*[in]*/ INT nYear, /*[in]*/ INT nMonth, /*[out, retval]*/ BSTR *pbstrDate);
    STDMETHOD(InitializeAll)             ();
    STDMETHOD(Restore)                   ( OLE_HANDLE hwndProgress);
    STDMETHOD(SetFormSize)               (/*[in]*/ INT nWidth, /*[in]*/ INT nHeight);
    STDMETHOD(ShowMessage)               (BSTR bstrMsg);
    STDMETHOD(CanRunRestore)             (/*[out,retval]*/ VARIANT_BOOL *pfSucceeded);
    STDMETHOD(DisplayOtherUsersWarning)  ();
    STDMETHOD(DisplayMoveFileExWarning)  (/*[out,retval]*/ VARIANT_BOOL *pfSucceeded);
    STDMETHOD(WasLastRestoreFromSafeMode)  (/*[out,retval]*/ VARIANT_BOOL *pfSucceeded);        
};

//extern CComPtr<CRestoreShell>  g_pRestoreShell;

//
// END OF NEW CODE
//

/////////////////////////////////////////////////////////////////////////////

#if OLD_CODE
enum
{
    RESTORE_STATUS_NONE = 0,
    RESTORE_STATUS_STARTED,
    RESTORE_STATUS_INITIALIZING,
    RESTORE_STATUS_CREATING_MAP,
    RESTORE_STATUS_RESTORING,
    RESTORE_STATUS_FINISHED

};

/////////////////////////////////////////////////////////////////////////////
//
// CRestoreShell
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRestoreShell :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IRestoreShell, &IID_IRestoreShell, &LIBID_RestoreUILib>
    public CComCoClass<CRestoreShell, &CLSID_RestoreShellExternal>
{
public:
    CRestoreShell();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CRestoreShell)
DECLARE_CLASSFACTORY_SINGLETON(CRestoreShell)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRestoreShell)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRestoreShell)
END_COM_MAP()

    HRESULT FinalConstruct();
    void    FinalRelease();

    //
    // Attributes
    //
protected:
    DATE                m_dateToday;
    VARIANT             m_varSelectedDate;
    VARIANT             m_varCurrentDate;
    long                m_lStartMode;
    //long                m_lRestoreType;       // 0 means EOD, 1 means Restore Point
    DWORD               m_dwSelectedPoint;
    DWORD               m_dwRealPoint;
    BOOL                m_fRestorePtSelected ;
    long                m_lLastRestore;
    BOOL                m_fIsUndo;
    BOOL                m_fCanNavigatePage ;
    BOOL                m_fWindowCreated ;
    CComBSTR            m_bstrEndOfDay;
    CComBSTR            m_bstrRestorePoint;

#ifndef TEST_UI_ONLY
    CRestoreMapManager  m_cMapMgr;
#endif
    int                 m_nRPI;
    RPI                 **m_aryRPI;

    UINT64              m_ullSeqNum;
    LONG                m_lCurrentBarSize;        // to update progress bar
    INT64               m_llDCurTempDiskUsage ;   // Current size of files in DS-TEMP
    INT64               m_llDMaxTempDiskUsage ;   // Max size of DS-TEMP before starting restore
    INT                 m_nRestoreStatus ;        // Restore status
    HANDLE              m_RSThread ;              // Thread to carry out restore
    HWND                m_hwndProgress;
    HWND                m_hWndShell ;
    INT                 m_nMainOption ;           // Option on main screen

    UINT64  m_ullManualRP;
    CSRStr  m_strManualRP;

    //
    // Operations
    //
public:

    BOOL     Initialize();
    void     MonitorDataStoreProc();
    DWORD    RestoreThread(void);
    void     SetProgressPos( long lPos );
    BOOL     SetStartMode( long lMode );
    BOOL     CreateRestoreSigFile();
    BOOL     DeleteRestoreSigFile();
    void     ShutdownWindow();
    void     UpdateRestorePoint();
    INT      CurrentRestoreStatus(void);
    BOOL     CanNavigatePage(void);
    HWND     GetWindowHandle( void );
    void     SetWindowHandle( HWND hWnd );

    DWORD    m_dwCurrentWidth ;
    DWORD    m_dwCurrentHeight ;

    //
    // Operations -- internal methods
    //
private:
    BOOL     GetDSTempDiskUsage(INT64 *pllD_DiskUsage);
    BOOL     LoadSettings();
    void     StoreSettings();

    //
    // IRestoreShell Restore Points Enumerator
    //
public:
    STDMETHOD(Item)( long lIndex, IRestorePoint** ppRP );
    STDMETHOD(get_Count)( long *plCount );

    //
    // IRestoreShell Methods
    //
public:
};
#endif //OLD_CODE

#endif //_RSTRSHL_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\marsui\makefile.inc ===
$(LOCALTARGET)\srframe.mmf: srframe.mmf
    copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\stdwin.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdwin.h

Abstract:
    Precompiled header file.

Revision History:
    Seong Kook Khang (SKKhang)  06/20/00
        created

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlwapi.h>

// for debug trace
#include <dbgtrace.h>
#define TRACE_ID  0


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\stubs.cpp ===
#include "stdwin.h"
#include <srconfig.h>
#include <utils.h>
#include <respoint.h>
#include <srapi.h>
#include <evthandler.h>
#include <enumlogs.h>
#include <ntservice.h>
#include <datastormgr.h>

CEventHandler * g_pEventHandler = NULL;
CSRConfig * g_pSRConfig = NULL;
CNTService * g_pSRService = NULL;
CDataStoreMgr * g_pDataStoreMgr = NULL;

DWORD CEventHandler::SRUpdateMonitoredListS (LPWSTR pszXMLFile)
{
    return 0;
}

void CEventHandler::RefreshCurrentRp (BOOL fScanAllDrives)
{
}

void CNTService::LogEvent(WORD wType, DWORD dwID,
                  void * pRawData,
                  DWORD dwDataSize,
                  const WCHAR* pszS1,
                  const WCHAR* pszS2,
                  const WCHAR* pszS3)
{
}

DWORD CDriveTable::ForAllDrives (PDATASTOREMETHOD pMethod, LONG_PTR lParam)
{
    return 0;
}

DWORD CDataStore::SwitchRestorePoint(LONG_PTR pRestorePoint)
{
    return 0;
}

DWORD CDataStoreMgr::TriggerFreezeOrFifo() 
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\testui.h ===
// empty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\shell\util.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    util.cpp

Abstract:
    This file contains the implementation of common utility functions.

Revision History:
    Seong Kook Khang (SKKhang)  07/07/99
        created

******************************************************************************/


#include "stdwin.h"
#include "resource.h"
#include "rstrpriv.h"


/////////////////////////////////////////////////////////////////////////////
//
// Utility Functions
//
/////////////////////////////////////////////////////////////////////////////

#define CAL_TYPE_GREGORIAN_LOCALZED               1
#define CAL_TYPE_GREGORIAN_ENGLISH                2
#define CAL_TYPE_ERA_JAPAN                        3
#define CAL_TYPE_ERA_TAIWAN                       4
#define CAL_TYPE_ERA_KOREA                        5
#define CAL_TYPE_ARABIC_HIJRI                     6
#define CAL_TYPE_THAI                             7
#define CAL_TYPE_HEBREW                           8
#define CAL_TYPE_GREGORIAN_MIDDLE_EAST_FRENCH     9
#define CAL_TYPE_GREGORIAN_ARABIC                 10
#define CAL_TYPE_GREGORIAN_TRANSLITERATED_ENGLISH 11
#define CAL_TYPE_GREGORIAN_TRANSLITERATED_FRENCH  12

#define CAL_RSTRUI_GREGORIAN  1
#define CAL_RSTRUI_OTHER      2

static int s_nCalType = CAL_RSTRUI_GREGORIAN ;

int SRUtil_SetCalendarTypeBasedOnLocale(LCID locale)
{

    LPCWSTR  cszErr;
    int      nRet;
    WCHAR    szCalType[8];
    int      nCalType;

    nRet = ::GetLocaleInfo( locale,
                            LOCALE_ICALENDARTYPE,
                            szCalType,
                            sizeof(szCalType)/sizeof(WCHAR));
    if ( nRet == 0 )
    {
        cszErr = ::GetSysErrStr();
        //        ErrorTrace(TRACE_ID, "GetLocaleInfo(%d) failed - %s", locale, cszErr);
        goto Exit;
    }

    nCalType = ::_wtoi( szCalType );

    if ( CAL_TYPE_GREGORIAN_LOCALZED               == nCalType ||
         CAL_TYPE_GREGORIAN_ENGLISH                == nCalType ||
         CAL_TYPE_GREGORIAN_MIDDLE_EAST_FRENCH     == nCalType ||
         CAL_TYPE_GREGORIAN_ARABIC                 == nCalType ||
         CAL_TYPE_GREGORIAN_TRANSLITERATED_ENGLISH == nCalType ||
         CAL_TYPE_GREGORIAN_TRANSLITERATED_FRENCH  == nCalType )
    {
        s_nCalType = CAL_RSTRUI_GREGORIAN ;
    }
    else
    {
        s_nCalType = CAL_RSTRUI_OTHER ;
    }

Exit:

    return nRet ;

}

/******************************************************************************/

LPSTR  IStrDupA( LPCSTR szSrc )
{
    TraceFunctEnter("IStrDupA");
    int    ccLen = 0 ;
    LPSTR  szNew = NULL;

    if ( szSrc == NULL || szSrc[0] == '\0' )
        goto Exit;

    ccLen = ::lstrlenA( szSrc );
    szNew = new char[ccLen+2];

    if ( szNew != NULL )
    {
        ::lstrcpyA( szNew, szSrc );
    }

Exit:
    TraceFunctLeave();
    return( szNew );
}

/******************************************************************************/

LPWSTR  IStrDupW( LPCWSTR wszSrc )
{
    TraceFunctEnter("IStrDupW");
    int    ccLen   = 0 ;
    LPWSTR  wszNew = NULL ;

    if ( wszSrc == NULL || wszSrc[0] == L'\0' )
        goto Exit;

    ccLen  = ::lstrlenW( wszSrc );
    wszNew = new WCHAR[ccLen+2];

    if ( wszNew != NULL )
    {
        ::lstrcpyW( wszNew, wszSrc );
    }

Exit:
    TraceFunctLeave();
    return( wszNew );
}

/****************************************************************************/

BOOL
SRFormatMessage( LPWSTR szMsg, UINT uFmtId, ... )
{
    TraceFunctEnter("SRFormatMessage");
    BOOL     fRet = FALSE;
    va_list  marker;
    WCHAR    szFmt[MAX_STR_MSG];

    va_start( marker, uFmtId );
    ::LoadString( g_hInst, uFmtId, szFmt, MAX_STR_MSG );
    if ( 0 == ::FormatMessage( FORMAT_MESSAGE_FROM_STRING,
                    szFmt,
                    0,
                    0,
                    szMsg,
                    MAX_STR_MSG,
                    &marker ) )
    {
        LPCWSTR  cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::FormatMessage failed - %ls", cszErr);
        goto Exit;
    }
    va_end( marker );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL  ShowSRErrDlg( UINT uMsgId, ... )
{
    TraceFunctEnter("ShowSRErrDlg");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    va_list  marker;
    WCHAR    szTitle[MAX_STR_TITLE];
    WCHAR    szFmt[MAX_STR_MSG];
    WCHAR    szMsg[MAX_STR_MSG];

    if ( ::LoadString( g_hInst, IDS_RESTOREUI_TITLE, szTitle, MAX_STR_TITLE ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", IDS_RESTOREUI_TITLE, cszErr);
        goto Exit;
    }

    if ( ::LoadString( g_hInst, uMsgId, szFmt, MAX_STR_MSG ) == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LoadString(%u) failed - %ls", uMsgId, cszErr);
        goto Exit;
    }

    va_start( marker, uMsgId );
    ::wvsprintf( szMsg, szFmt, marker );
    va_end( marker );

    ::MessageBox( NULL, szMsg, szTitle, MB_OK );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/****************************************************************************/

BOOL  SRGetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD *pdwData )
{
    TraceFunctEnter("SRGetRegDword");
    BOOL   fRet = FALSE;
    DWORD  dwType;
    DWORD  dwRes;
    DWORD  cbData;

    dwType = REG_DWORD;
    cbData = sizeof(DWORD);
    dwRes = ::SHGetValue( hKey, cszSubKey, cszValue, &dwType, pdwData, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        LPCWSTR  cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::SHGetValue failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

/******************************************************************************/
/*
static WCHAR  s_wszPath[MAX_PATH];

LPWSTR  PathElem2Str( PathElement *pElem )
{
    TraceFunctEnter("PathElem2Str");
    int  cch = pElem->pe_length / sizeof(USHORT) - 1;

    ::StrCpyNW( s_wszPath, pElem->pe_unichars, cch+1 );
//    for ( int i = 0;  i < ccLen;  i++ )
//        wszElem[i] = pElem->pe_unichars[i];
    s_wszPath[cch] = '\0';

    TraceFunctLeave();
    return( s_wszPath );
}

LPWSTR  ParsedPath2Str( ParsedPath *pPath, LPCWSTR wszDrive )
{
    TraceFunctEnter("ParsedPath2Str");
    LPWSTR       wszAppend;
    PathElement  *pElem;
    int          cch;

    if ( pPath != NULL )
    {
        ::lstrcpyW( s_wszPath, wszDrive );
        wszAppend = s_wszPath + ::lstrlenW( s_wszPath );

        for ( pElem = pPath->pp_elements;  pElem->pe_length > 0;  pElem = IFSNextElement( pElem ) )
        {
            DebugTrace(0, "pElem->pe_length=%d", pElem->pe_length);
            *wszAppend++ = L'\\';
            cch = pElem->pe_length / sizeof(USHORT) - 1;
            ::StrCpyNW( wszAppend, pElem->pe_unichars, cch+1 );
            wszAppend += cch;
        }
        *wszAppend = L'\0';
    }
    else
    {
        *s_wszPath = L'\0';
    }

    TraceFunctLeave();
    return( s_wszPath );
}
*/

/******************************************************************************/

//
// Check if we have enough free space in Windows directory and this is
// greater than the minimum requirments for carrying out a restore, this
// also reads and caches the registry data. If registry data cannot be
// read defaults in the code will be used
//
BOOL IsFreeSpaceOnWindowsDrive( void )
{

    TraceFunctEnter("IsFreeSpaceOnWindowsDrive");

    static BOOL    fFirstTime = TRUE ;
    static DWORD   dwMinValidSpace = RSTRMAP_MIN_WIN_DISK_SPACE_MB * (1024 * 1024) ;
    static WCHAR   szWinPath[MAX_PATH+1];

    ULARGE_INTEGER i64FreeBytesToCaller;
    ULARGE_INTEGER i64FreeBytes ;
    ULARGE_INTEGER i64TotalBytes ;
    BOOL           fResult = FALSE ;
    BOOL           fRetVal = TRUE ;
    DWORD          dwError;
    LPCWSTR        cszErr;

    long           lRetVal = 0;
    HKEY           hKey = NULL;
    DWORD          dwVal = 0;
    DWORD          dwType = 0;
    DWORD          cbData = sizeof(DWORD);

    //
    // Read registry and get the size of FreezeSize and set the min
    // size for disk on data store
    //
    if ( fFirstTime )
    {

#ifdef LEGACY_CODE
        if ( !::GetWindowsDirectory( szWinPath, MAX_PATH ) )
        {
            cszErr = GetSysErrStr();
            ErrorTrace(TRACE_ID, "::GetWindowsDirectory failed - %s", cszErr);
            goto Exit;
        }

        DebugTrace(TRACE_ID, "Opening: %s", s_cszReservedDiskSpaceKey);

        //
        // Open HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\StateMgr\ReservedDiskSpace
        // for reading
        //
        lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               s_cszReservedDiskSpaceKey,
                               0,
                               KEY_READ,
                               &hKey);

        if( ERROR_SUCCESS == lRetVal)
        {

            DebugTrace(TRACE_ID, "Querying: %s", s_cszUIFreezeSize);

            //
            // Read "FreezeSize"
            //
            lRetVal = RegQueryValueEx(hKey,
                                      s_cszUIFreezeSize,
                                      0,
                                      &dwType,
                                      (LPBYTE)&dwVal,
                                      &cbData);

            if( ERROR_SUCCESS == lRetVal)
            {
                if ( dwVal < RSTRMAP_LOW_WIN_DISK_SPACE_MB )
                {
                    dwVal = RSTRMAP_LOW_WIN_DISK_SPACE_MB;
                };
                dwMinValidSpace = dwVal * (1024 * 1024) ;
            }
            else
            {
                ErrorTrace(TRACE_ID, "RegQueryValueEx failed; hr=0x%x", GetLastError());
            }


        }
        else
        {
            ErrorTrace(TRACE_ID, "RegOpenKeyEx failed; hr=0x%x", GetLastError());
        }
#endif //def LEGACY_CODE

        fFirstTime = FALSE ;
    }


    fRetVal = TRUE ;

    fResult = GetDiskFreeSpaceEx(szWinPath,
                                 (PULARGE_INTEGER) &i64FreeBytesToCaller,
                                 (PULARGE_INTEGER) &i64TotalBytes,
                                 (PULARGE_INTEGER) &i64FreeBytes);

    if ( fResult )
    {
        //
        // Now check if disk free space is greater than min space (high 4GB)
        //
        if (i64FreeBytes.HighPart > 0 )
        {
            goto Exit;
        }
        else if (i64FreeBytesToCaller.LowPart > dwMinValidSpace )
        {
            goto Exit;
        }
        else
        {
            fRetVal = FALSE ;
            goto Exit;
        }
    }
    else
    {
        //
        // If the function fails its Ok to try to go on as the Restore Undo
        // should handle it if things get very full
        //
        dwError = ::GetLastError();
        ErrorTrace(TRACE_ID, "GetDiskFreeSpaceEx failed. ec=%d", dwError);
        goto Exit;

    };

 Exit:

    TraceFunctLeave();

    return fRetVal ;

}

//
// Get the default language for the current user
//
LANGID GetDefaultUILang(void)
{
    OSVERSIONINFO Osv ;
    BOOL IsWindowsNT ;

    LANGID wUILang = MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US);

    Osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;

    if(!GetVersionEx(&Osv))
    {
        goto Exit ;
    }

    IsWindowsNT = (BOOL) (Osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ;

    //
    // Get the UI language by one of three methods, depending on the system
    //
    if(!IsWindowsNT)
    {
        //
        // Case 1: Running on Windows 9x. Get the system UI language from registry:
        //
        CHAR szData[32]   ;
        DWORD dwErr, dwSize = sizeof(szData) ;
        HKEY hKey          ;

        dwErr = RegOpenKeyEx(
                             HKEY_USERS,
                             TEXT(".Default\\Control Panel\\desktop\\ResourceLocale"),
                             0,
                             KEY_READ,
                             &hKey
                             ) ;

        if(ERROR_SUCCESS != dwErr)
        {
            goto Exit ;
        }

        dwErr = RegQueryValueEx(
                                hKey,
                                TEXT(""),
                                NULL,  //reserved
                                NULL,  //type
                                (LPBYTE) szData,
                                &dwSize
                                ) ;

        if(ERROR_SUCCESS != dwErr)
        {
            goto Exit ;
        }

        dwErr = RegCloseKey(hKey) ;

        // Convert string to number
        wUILang = (LANGID) strtol(szData, NULL, 16) ;
    }

 Exit:

    return wUILang ;
}

/////////////////////////////////////////////////////////////////////////////
//
// CSRStr
//
/////////////////////////////////////////////////////////////////////////////

CSRStr::CSRStr()
{
    TraceFunctEnter("CSRStr::CSRStr()");

    m_cchW = 0;
    m_strW = NULL;
    m_cchA = 0;
    m_strA = NULL;

    TraceFunctLeave();
}

CSRStr::CSRStr( LPCWSTR wszSrc )
{
    TraceFunctEnter("CSRStr::CSRStr(LPCWSTR)");

    m_strW = NULL;
    m_strA = NULL;
    SetStr( wszSrc );

    TraceFunctLeave();
}

CSRStr::CSRStr( LPCSTR szSrc )
{
    TraceFunctEnter("CSRStr::CSRStr(LPCSTR)");

    m_strW = NULL;
    m_strA = NULL;
    SetStr( szSrc );

    TraceFunctLeave();
}

CSRStr::~CSRStr()
{
    TraceFunctEnter("CSRStr::~CSRStr");

    Empty();

    TraceFunctLeave();
}

int  CSRStr::LengthW()
{
    TraceFunctEnter("CSRStr::CountW");

    if ( m_cchW == 0 && m_strA != NULL )
        ConvertA2W();

    TraceFunctLeave();
    return( m_cchW );
}

int  CSRStr::LengthA()
{
    TraceFunctEnter("CSRStr::CountA");

    if ( m_cchA == 0 && m_strW != NULL )
        ConvertW2A();

    TraceFunctLeave();
    return( m_cchA );
}

CSRStr::operator LPCWSTR()
{
    TraceFunctEnter("CSRStr::operator LPCWSTR");

    if ( m_strW == NULL && m_strA != NULL )
        ConvertA2W();

    TraceFunctLeave();
    return( m_strW );
}

CSRStr::operator LPCSTR()
{
    TraceFunctEnter("CSRStr::operator LPCSTR");

    if ( m_strA == NULL && m_strW != NULL )
        ConvertW2A();

    TraceFunctLeave();
    return( m_strA );
}

void  CSRStr::Empty()
{
    TraceFunctEnter("CSRStr::Empty");

    if ( m_strW != NULL )
    {
        delete [] m_strW;
        m_strW = NULL;
        m_cchW = 0;
    }
    if ( m_strA != NULL )
    {
        delete [] m_strA;
        m_strA = NULL;
        m_cchA = 0;
    }

    TraceFunctLeave();
}

BOOL  CSRStr::SetStr( LPCWSTR wszSrc, int cch )
{
    TraceFunctEnter("CSRStr::SetStr(LPCWSTR,int)");
    BOOL  fRet = FALSE;

    Empty();

    if ( wszSrc == NULL )
        goto Exit;

    if ( cch == -1 )
        cch = ::lstrlenW( wszSrc );

    if ( cch > 0 )
    {
        m_strW = new WCHAR[cch+2];
        if ( m_strW == NULL )
        {
            ErrorTrace(TRACE_ID, "Insufficient memory...");
            goto Exit;
        }
        ::StrCpyNW( m_strW, wszSrc, cch+1 );
        m_strW[cch] = L'\0';
        m_cchW = cch;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

BOOL  CSRStr::SetStr( LPCSTR szSrc, int cch )
{
    TraceFunctEnter("CSRStr::SetStr(LPCSTR,int)");
    BOOL  fRet = FALSE;

    Empty();

    if ( szSrc == NULL )
        goto Exit;

    if ( cch == -1 )
        cch = ::lstrlenA( szSrc );

    if ( cch > 0 )
    {
        m_strA = new char[cch+2];
        if ( m_strA == NULL )
        {
            ErrorTrace(TRACE_ID, "Insufficient memory...");
            goto Exit;
        }
        ::lstrcpynA( m_strA, szSrc, cch+1 );
        m_strA[cch] = L'\0';
        m_cchA = cch;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

const CSRStr&  CSRStr::operator =( LPCWSTR wszSrc )
{
    TraceFunctEnter("CSRStr::operator =(LPCWSTR)");

    SetStr( wszSrc );

    TraceFunctLeave();
    return( *this );
}

const CSRStr&  CSRStr::operator =( LPCSTR szSrc )
{
    TraceFunctEnter("CSRStr::operator =(LPCSTR)");

    SetStr( szSrc );

    TraceFunctLeave();
    return( *this );
}

BOOL  CSRStr::ConvertA2W()
{
    TraceFunctEnter("CSRStr::ConvertA2W");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    int      cch;

    cch = ::MultiByteToWideChar( CP_ACP, 0, m_strA, m_cchA, NULL, 0 );
    if ( cch == 0 )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(TRACE_ID, "::MultiByteToWideChar failed - %s", cszErr);
        goto Exit;
    }
    m_strW = new WCHAR[cch+2];
    if ( m_strW == NULL )
    {
        ErrorTrace(TRACE_ID, "Insufficient memory...");
        goto Exit;
    }
    m_cchW = ::MultiByteToWideChar( CP_ACP, 0, m_strA, m_cchA, m_strW, cch );
    if ( m_cchW != cch )
    {
        ErrorTrace(TRACE_ID, "::MultiByteToWideChar returns inconsistent length - %d / %d", cch, m_cchW);
        delete [] m_strW;
        m_strW = NULL;
        m_cchW = 0;
        goto Exit;
    }
    m_strW[m_cchW] = L'\0';

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

BOOL  CSRStr::ConvertW2A()
{
    TraceFunctEnter("CSRStr::ConvertW2A");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    int      cch;

    cch = ::WideCharToMultiByte( CP_ACP, 0, m_strW, m_cchW, NULL, 0, NULL, NULL );
    if ( cch == 0 )
    {
        cszErr = GetSysErrStr();
        ErrorTrace(TRACE_ID, "::WideCharToMultiByte failed - %s", cszErr);
        goto Exit;
    }
    m_strA = new char[cch+2];
    if ( m_strA == NULL )
    {
        ErrorTrace(TRACE_ID, "Insufficient memory...");
        goto Exit;
    }
    m_cchA = ::WideCharToMultiByte( CP_ACP, 0, m_strW, m_cchW, m_strA, cch, NULL, NULL );
    if ( m_cchA != cch )
    {
        ErrorTrace(TRACE_ID, "::WideCharToMultiByte returns inconsistent length - %d / %d", cch, m_cchA);
        delete [] m_strA;
        m_strA = NULL;
        m_cchA = 0;
        goto Exit;
    }
    m_strA[m_cchA] = '\0';

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\snapshot\snappatch.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    srdefs.h
 *
 *  Abstract:
 *    declarations for snapshot patch functions 
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/23/2001
 *        created
 *
 *****************************************************************************/

#ifndef _SNAPPATCH_H
#define _SNAPPATCH_H

DWORD 
PatchGetReferenceRpNum(
    DWORD  dwCurrentRp);

DWORD
PatchReconstructOriginal(
    LPCWSTR pszCurrentDir,
    LPWSTR  pszDestDir);

DWORD
PatchComputePatch(
    LPCWSTR pszCurrentDir);

DWORD
PatchGetRpNumberFromPath(
    LPWSTR pszPath,
    PDWORD pdwRpNum);

DWORD 
PatchGetReferenceRpPath(
    DWORD dwCurrentRp,
    LPWSTR pszRefRpPath);

DWORD
PatchGetReferenceRpNum(
    DWORD  dwCurrentRp);

DWORD
PatchGetPatchWindow();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\snapshot\snapshoth.h ===
#ifndef _SNAPSHOTH_H_
#define _SNAPSHOTH_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>

// iis snapshotting headers
#include <initguid.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <mddefw.h>

// use the _ASSERT and _VERIFY in dbgtrace.h
#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef _VERIFY
#undef _VERIFY
#endif

#include <dbgtrace.h>

#include <snapshot.h>
#include <srdefs.h>
#include <utils.h>

#include <utils.h>

#include <enumlogs.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\snapshot\utest\stubs.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlwapi.h>

#include <shellapi.h>
#include <srconfig.h>
#include <snapshot.h>
#include <stdio.h>
#include <dbgtrace.h>
#include <utils.h>
#include <srdefs.h>
#include <respoint.h>
#include <srapi.h>
#include <evthandler.h>
#include <ntservice.h>
#include <datastormgr.h>

CEventHandler * g_pEventHandler = NULL;
CSRConfig * g_pSRConfig = NULL;
CNTService * g_pSRService = NULL;
CDataStoreMgr * g_pDataStoreMgr = NULL;

DWORD CEventHandler::SRUpdateMonitoredListS (LPWSTR pszXMLFile)
{
    return 0;
}

void CEventHandler::RefreshCurrentRp (BOOL fScanAllDrives)
{
}

void CNTService::LogEvent(WORD wType, DWORD dwID,
                  void * pRawData,
                  DWORD dwDataSize,
                  const WCHAR* pszS1,
                  const WCHAR* pszS2,
                  const WCHAR* pszS3)
{
}

DWORD CDriveTable::ForAllDrives (PDATASTOREMETHOD pMethod, LONG_PTR lParam)
{
    return 0;
}

DWORD CDataStore::SwitchRestorePoint(LONG_PTR pRestorePoint)
{
    return 0;
}

DWORD CDataStoreMgr::TriggerFreezeOrFifo() 
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\snapshot\utest\snaputest.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    chglog.cpp
 *
 *  Abstract:
 *    Tool for enumerating the change log - forward/reverse
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/09/2000
 *        created
 *
 *****************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include <snapshot.h>
#include <stdio.h>

// use the _ASSERT and _VERIFY in dbgtrace.h
#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef _VERIFY
#undef _VERIFY
#endif

#include <dbgtrace.h>
#include <utils.h>
#include <srdefs.h>

CSnapshot g_CSnapshot;
DWORD SetPrivilegeInAccessToken(WCHAR * pszPrivilegeName);

DWORD DeleteAllChangeLogs(WCHAR * pszRestorePointPath)
{
    TraceFunctEnter("DeleteAllFilesBySuffix");
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    WCHAR szFindFileData[MAX_PATH];
    
     // first construct the prefix of the file that stores the HKLM registry
     // snapshot.
    wsprintf(szFindFileData, L"%s\\%s*", pszRestorePointPath,
             s_cszCurrentChangeLog);
    
    dwErr = ProcessGivenFiles(pszRestorePointPath, DeleteGivenFile,
                              szFindFileData);
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "Deleting files failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;        
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    TraceFunctLeave();
    return dwReturn;
}


DWORD SaveRegKey(HKEY    hKey,  // handle to parent key
                 WCHAR * pszSubKeyName,   // name of subkey to backup
                 WCHAR * pszFileName,  // filename of backup file 
                 WCHAR * pszDirName);   // directory to create above file

void __cdecl
main()
{
    PWSTR *    argv = NULL;
    int argc;
    WCHAR     szSystemHive[MAX_PATH];
    DWORD     dwReturn;
    
    InitAsyncTrace();
    

    argv = CommandLineToArgvW(GetCommandLine(), &argc);

    if (! argv)
    {
        printf("Error parsing arguments");
        goto done;
    }
    
    if (argc !=3)
    {
        printf("Usage: snaputest c|r path");
        goto done;
    }

    if (0==lstrcmp(argv[1],L"c"))
    {
        _VERIFY(ERROR_SUCCESS==g_CSnapshot.CreateSnapshot(argv[2], NULL,NULL, TRUE));
    }
    else if (0==lstrcmp(argv[1], L"r" ))
    {
        dwReturn = g_CSnapshot.InitRestoreSnapshot(argv[2]);
        
        _ASSERT(ERROR_SUCCESS==dwReturn);
        
        dwReturn = g_CSnapshot.GetSystemHivePath(argv[2],
                                                 szSystemHive,
                                                 MAX_PATH);
        _ASSERT(ERROR_SUCCESS==dwReturn);
        
        dwReturn= DoesFileExist(szSystemHive);

        _ASSERT(TRUE==dwReturn);

        dwReturn=g_CSnapshot.GetSoftwareHivePath(argv[2],
                                                  szSystemHive,
                                                  MAX_PATH);

        _ASSERT(ERROR_SUCCESS==dwReturn);

        
        dwReturn= DoesFileExist(szSystemHive);
        _ASSERT(TRUE==dwReturn);
        
        dwReturn = g_CSnapshot.RestoreSnapshot(argv[2]);

        _ASSERT(ERROR_SUCCESS==dwReturn);        
    }
    
    else if (0==lstrcmp(argv[1], L"d" ))
    {
        _VERIFY(ERROR_SUCCESS==g_CSnapshot.CleanupAfterRestore(argv[2]));
    }
    else if (0==lstrcmp(argv[1], L"D" ))
    {
        _VERIFY(ERROR_SUCCESS==g_CSnapshot.DeleteSnapshot(argv[2]));
    }    
    
    else
    {
        printf("Usage: snaputest c|r path");
        goto done;        
    }





    
done:
#if 0
    SetPrivilegeInAccessToken(SE_BACKUP_NAME);    
	SetPrivilegeInAccessToken(SE_RESTORE_NAME);	
    CopyFileTimes(L"d:\\a.dll", L"d:\\c.dll");
    
    
    WCHAR wcsBuffer[MAX_PATH];
    if (GetVolumeNameForVolumeMountPoint (L"c:\\", wcsBuffer, MAX_PATH))
    {
        lstrcat(wcsBuffer, L"temp1\\temp2\\foo.dll");
        CreateBaseDirectory(wcsBuffer);
    }
#endif
    
    TermAsyncTrace();
    return;
}








DWORD SetPrivilegeInAccessToken(WCHAR * pszPrivilegeName)
{
    TraceFunctEnter("CSnapshot::SetPrivilegeInAccessToken");
    
    HANDLE           hProcess;
    HANDLE           hAccessToken=NULL;
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;
    DWORD            dwReturn = ERROR_INTERNAL_ERROR, dwErr;


    
    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        dwReturn = GetLastError();
        ErrorTrace(0, "GetCurrentProcess failed ec=%d", dwReturn);
        goto done;
    }

    if (!OpenProcessToken(hProcess,
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hAccessToken))
    {
        dwErr=GetLastError();
        ErrorTrace(0, "OpenProcessToken failed ec=%d", dwErr);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }
        goto done;
    }

    if (!LookupPrivilegeValue(NULL,
                              pszPrivilegeName,
                              &luidPrivilegeLUID))
    {
        dwErr=GetLastError();        
        ErrorTrace(0, "LookupPrivilegeValue failed ec=%d",dwErr);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }        
        goto done;
    }

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hAccessToken,
                               FALSE,  // Do not disable all
                               &tpTokenPrivilege,
                               sizeof(TOKEN_PRIVILEGES),
                               NULL,   // Ignore previous info
                               NULL))  // Ignore previous info
    {
        dwErr=GetLastError();
        ErrorTrace(0, "AdjustTokenPrivileges");
        if (dwErr != NO_ERROR)
        {
            dwReturn = dwErr;
        }
        goto done;
    }
    
    dwReturn = ERROR_SUCCESS;

done:
    if (hAccessToken != NULL)
    {
        _VERIFY(TRUE==CloseHandle(hAccessToken));
    }
    
    TraceFunctLeave();
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\snapshot\snappatch.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    snappatch.cpp
 *
 *  Abstract:
 *    functions for computing snapshot patch, and reconstructing snapshot from patch
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/22/2001
 *        created
 *
 *****************************************************************************/


#include "snapshoth.h"
#include "..\service\srconfig.h"

DWORD g_dwPatchWindow = 0xFFFFFFFF;


//
// get patch window
// 0 if patching is turned off
//

DWORD
PatchGetPatchWindow()
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY  hKey = NULL;

    tenter("PatchGetPatchWindow");
    
    if (g_dwPatchWindow == 0xFFFFFFFF)
    {
        // uninitialized
        // read from the registry
        
        g_dwPatchWindow = 0;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                          s_cszSRRegKey,
                                          0,
                                          KEY_READ, 
                                          &hKey))
        {        
            RegReadDWORD(hKey, s_cszPatchWindow, &g_dwPatchWindow);
            RegCloseKey(hKey);            
        }
        
        trace(0, "Initializing g_dwPatchWindow = %ld", g_dwPatchWindow);
    }

    tleave();
    return g_dwPatchWindow;        
}


//
// get reference rp for a given rp
// RP1-RP10  -> reference is RP1
// RP11-RP20 -> reference is RP11 and so on
//

DWORD 
PatchGetReferenceRpNum(
    DWORD  dwCurrentRp)
{
    
    if (PatchGetPatchWindow() == 0)
        return dwCurrentRp;
    else
        return (dwCurrentRp/PatchGetPatchWindow())*PatchGetPatchWindow() + 1;
}


DWORD 
PatchGetReferenceRpPath(
    DWORD dwCurrentRp,
    LPWSTR pszRefRpPath)
{
    tenter("PatchGetReferenceRpPath");
    
    WCHAR  szRp[MAX_RP_PATH], szSys[MAX_SYS_DRIVE]=L"";   
    DWORD  dwRefRpNum = PatchGetReferenceRpNum(dwCurrentRp);
    DWORD  dwErr = ERROR_SUCCESS;

    wsprintf(szRp, L"%s%ld", s_cszRPDir, dwRefRpNum);
    
    GetSystemDrive(szSys);
    MakeRestorePath(pszRefRpPath, szSys, szRp);
    if (0xFFFFFFFF == GetFileAttributes(pszRefRpPath))
    {
        // RP directory does not exist -- it must've been fifoed
        // try RefRP
        trace(0, "Original rp does not exist -- trying RefRP");
        wsprintf(szRp,L" %s%ld", s_cszReferenceDir, dwRefRpNum);
        MakeRestorePath(pszRefRpPath, szSys, szRp);
        if (0xFFFFFFFF == GetFileAttributes(pszRefRpPath))
        {
            // this does not exist either -- something wrong
            trace(0, "RefRP does not exist either -- bailing");
            dwErr = ERROR_NOT_FOUND;
            goto Err;
        }            
    }

    trace(0, "Current Rp: %ld, Reference : %S", dwCurrentRp, pszRefRpPath);
    
Err:
    tleave();
    return dwErr;
}


//
// extract rp number from path
//

DWORD
PatchGetRpNumberFromPath(
    LPCWSTR pszPath,
    PDWORD pdwRpNum)
{
    while (*pszPath != L'\0')
    {
        if (0 == wcsncmp(pszPath, s_cszRPDir, lstrlen(s_cszRPDir)))
        {
            pszPath += lstrlen(s_cszRPDir);
            *pdwRpNum = _wtol(pszPath);
            if (*pdwRpNum == 0)
                continue;
            else
                return ERROR_SUCCESS;
        }
        pszPath++;
    }
    return ERROR_NOT_FOUND;
}

//
// compute the diff
//

DWORD
PatchComputePatch(
    LPCWSTR pszCurrentDir) 
{
    tenter("PatchComputePatch");

    DWORD  dwErr = ERROR_SUCCESS;
    WCHAR  szTemp[MAX_PATH], szRef[MAX_PATH];
    FILE*  f = NULL;
    DWORD  dwCurRpNum;    

    // check if patching is turned off
    
    if (PatchGetPatchWindow() == 0)
    {
        trace(0, "No patching");
        goto Err;
    }        
    
    // get the reference directory for this rp
    
    CHECKERR(PatchGetRpNumberFromPath(pszCurrentDir, &dwCurRpNum),
             L"PatchGetRpNumberFromPath");

    CHECKERR(PatchGetReferenceRpPath(dwCurRpNum, szRef),
             L"PatchGetReferenceRpPath");


    // check if this directory is already patched

    lstrcpy(szTemp, pszCurrentDir);
    lstrcat(szTemp, L"\\");
    lstrcat(szTemp, s_cszPatchCompleteMarker);
    if (0xFFFFFFFF != GetFileAttributes(szTemp))
    {
        trace(0, "%S already patched", pszCurrentDir);
        goto Err;
    }
    
    // call the library api to compute the patch
    // this is a blocking call till the patching completes 
    // progress callback is used to terminate it 

    
    // PlaceHolder for library call (pszCurrentDir, szRef)

    
    // check if we completed the patch successfully
    // if so, then write a zero-byte file inside the directory to indicate this

    lstrcpy(szTemp, pszCurrentDir);
    lstrcat(szTemp, L"\\");
    lstrcat(szTemp, s_cszPatchCompleteMarker);
    f = (FILE *) _wfopen(szTemp, L"w");
    if (!f)
    {
        dwErr = GetLastError();
        trace(0, "! Cannot create %S : %ld", szTemp, dwErr);
        goto Err;
    }
    fclose(f);
    
Err:
    tleave();
    return dwErr;
}

//
// patch progress callback
//

BOOL
PatchContinueCallback()
{
    tenter("PatchContinueCallback");

    BOOL fRc;

    trace(0, "PatchContinueCallback called");
    
    if (!g_pSRConfig)
    {
        trace(0, "g_pSRConfig = NULL -- terminating patch");
        fRc = FALSE;
    }
    else if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
    {
        trace(0, "Stop signalled -- terminating patch");
        fRc = FALSE;
    }
    else
    {
        fRc = TRUE;
    }

    tleave();
    return fRc;
}



//
// reconstruct the original
//

DWORD
PatchReconstructOriginal(
    LPCWSTR pszCurrentDir,
    LPWSTR  pszDestDir)
{
    tenter("PatchReconstructOriginal");

    DWORD  dwErr = ERROR_SUCCESS;
    WCHAR  szReferenceDir[MAX_PATH];
    WCHAR  szSys[MAX_SYS_DRIVE]=L"";
    DWORD  dwCurRpNum;    

    // check if patching is turned off
    
    if (PatchGetPatchWindow() == 0)
    {
        trace(0, "No patching");
        goto Err;
    }  

    
    CHECKERR(PatchGetRpNumberFromPath(pszCurrentDir, &dwCurRpNum),
             L"PatchGetRpNumberFromPath");

    CHECKERR(PatchGetReferenceRpPath(dwCurRpNum, szReferenceDir),
             L"PatchGetReferenceRpPath");


    // call the library api to reconstruct the snapshot
    
    // PlaceHolder for library call (pszCurrentDir, szReferenceDir, pszDestDir)

    
Err:
    tleave();
    return dwErr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\diskcleanup.cpp ===
/******************************************************************
   Copyright (c) 2000 Microsoft Corporation

   diskcleanup.cpp -- disk cleanup COM object for SR

   Description:
        delete datastores from stale builds


******************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <wtypes.h>
#include <winuser.h>
#include "diskcleanup.h"
#include "resource.h"
#include <utils.h>
#include <srdefs.h>

extern HMODULE ghModule;

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::LoadBootIni
//
//  Synopsis:   parse the boot.ini file
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CSREmptyVolumeCache2::LoadBootIni()
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR *pwszThisGuid = NULL;
    CHAR *pszContent = NULL;
    CHAR *pszLine = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    CHAR szArcName[MAX_PATH];
    CHAR szOptions[MAX_PATH];

    pwszThisGuid = GetMachineGuid ();  // always exclude the current datastore
    if (pwszThisGuid != NULL && pwszThisGuid[0] != L'\0')
    {
        lstrcpyW (_wszGuid[_ulGuids], s_cszRestoreDir);
        lstrcatW (_wszGuid[_ulGuids], pwszThisGuid );
        _ulGuids++;
    }

    // Read the contents of the boot.ini file into a string.

    hFile = CreateFileW (L"c:\\boot.ini", 
                             GENERIC_READ, 
                             FILE_SHARE_READ,
                             NULL, OPEN_EXISTING, 0, NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwErr = GetLastError();
        return dwErr;
    }

    DWORD dwBytesRead = 0;
    DWORD dwBytesToRead = GetFileSize(hFile, NULL);

    if (dwBytesToRead == 0xFFFFFFFF || 0 == dwBytesToRead)
    {
        dwErr = GetLastError();
        goto Err;
    }

    pszContent = new CHAR [dwBytesToRead];

    if (pszContent == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Err;
    }

    if (FALSE==ReadFile(hFile, pszContent, dwBytesToRead, &dwBytesRead, NULL))
    {
        dwErr = GetLastError();
        goto Err;
    }

    if (dwBytesToRead != dwBytesRead)
    {
        dwErr = ERROR_READ_FAULT;
        goto Err;
    }

    CloseHandle (hFile);
    hFile = INVALID_HANDLE_VALUE;

    pszLine = pszContent;
    for (UINT i = 0; i < dwBytesRead; i++)
    {
        if (pszContent[i] == '=')    // field indicator
            pszContent[i] = '\0';    // process only the 1st field

        if (pszContent[i] == '\n')   // end-of-line indicator
        {
            pszContent[i] = '\0';

            if (strncmp (pszLine, "multi", 5) == 0)
            {
                HANDLE hGuidFile;
                WCHAR wcsPath[MAX_PATH];
                WCHAR wcsGuid [RESTOREGUID_STRLEN];
                OBJECT_ATTRIBUTES oa;
                UNICODE_STRING us;
                IO_STATUS_BLOCK iosb;

                wsprintfW (wcsPath, L"\\ArcName\\%hs\\System32\\Restore\\"
                                    L"MachineGuid.txt", pszLine);

                RtlInitUnicodeString (&us, wcsPath);

                InitializeObjectAttributes ( &oa, &us, OBJ_CASE_INSENSITIVE, 
                                             NULL, NULL);

                NTSTATUS nts = NtCreateFile (&hGuidFile,
                        FILE_GENERIC_READ,
                        &oa,
                        &iosb,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_WRITE | FILE_SHARE_DELETE | FILE_SHARE_READ,
                        FILE_OPEN,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0);

                if (!NT_SUCCESS(nts))
                {
                    dwErr = RtlNtStatusToDosError (nts);
                }
                else
                {
                    dwBytesToRead = RESTOREGUID_STRLEN * sizeof(WCHAR);
                    DWORD dwRead = 0;

                    dwErr = ERROR_SUCCESS;

                    if (FALSE == ReadFile (hGuidFile, (BYTE *) wcsGuid, 
                                 dwBytesToRead, &dwRead, NULL))
                    {
                        dwErr = GetLastError();
                    }

                    if (_ulGuids < ARRAYSIZE && ERROR_SUCCESS == dwErr)
                    {
                       lstrcpyW (_wszGuid[_ulGuids], s_cszRestoreDir);
                       lstrcatW (_wszGuid[_ulGuids], (wcsGuid[0]==0xFEFF) ?
                            &wcsGuid[1] : wcsGuid );
                       _ulGuids++;
                    }
                    NtClose (hGuidFile);
                 }
            }
            pszLine = &pszContent [i+1];  // skip to next line
        }
    }

Err:
    if (pszContent != NULL)
        delete [] pszContent;

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::EnumDataStores
//
//  Synopsis:   enumerate the data store on a volume
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CSREmptyVolumeCache2::EnumDataStores (DWORDLONG *pdwlSpaceUsed,
                                            IEmptyVolumeCacheCallBack *picb,
                                            BOOL fPurge,
                                            WCHAR *pwszVolume)
{
    HANDLE hFind = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    WIN32_FIND_DATA wfd;
    WCHAR wcsPath [MAX_PATH];

    *pdwlSpaceUsed = 0;

    if (pwszVolume == NULL || pwszVolume[0] == L'\0')   // no volume defined
        return dwErr;

    wsprintfW (wcsPath, L"%s%s\\%s*", pwszVolume,
                                      s_cszSysVolInfo, s_cszRestoreDir);

    hFind = FindFirstFileW (wcsPath, &wfd);

    if (hFind == INVALID_HANDLE_VALUE)    // no files
        return dwErr;

    do
    {
        if (TRUE == _fStop)
        {
            FindClose (hFind);
            return ERROR_OPERATION_ABORTED;
        }

        if (!lstrcmp(wfd.cFileName, L".") || !lstrcmp(wfd.cFileName, L".."))
            continue;

        for (UINT i=0; i < _ulGuids; i++)
        {
            if (lstrcmpi (_wszGuid[i], wfd.cFileName) == 0)
            {
                break;   // data store match
            }
        }

        if (i >= _ulGuids)  // no data store match
        {
            if (picb != NULL)
            {
                WCHAR wcsDataStore[MAX_PATH];

                lstrcpyW (wcsPath, pwszVolume);
                lstrcatW (wcsPath, s_cszSysVolInfo);
                lstrcatW (wcsPath, L"\\");
                lstrcatW (wcsPath, wfd.cFileName);

                if (!fPurge)    // calculate space usage
                {
                    dwErr = GetFileSize_Recurse (wcsPath, 
                                                 (INT64*) pdwlSpaceUsed, 
                                                 &_fStop);
                }
                else            // delete the data store
                {
                    dwErr = Delnode_Recurse (wcsPath, TRUE, &_fStop);
                }
            }
            else
            {
                *pdwlSpaceUsed = 1;  // indicate something to clean up
            }
        }
    }
    while (FindNextFileW (hFind, &wfd));

    FindClose (hFind);

    if (picb != NULL)   // update the progress bar
    {
        if (!fPurge)
            picb->ScanProgress (*pdwlSpaceUsed, EVCCBF_LASTNOTIFICATION , NULL); 
        else
            picb->PurgeProgress (*pdwlSpaceUsed,0,EVCCBF_LASTNOTIFICATION,NULL);
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::ForAllMountPoints
//
//  Synopsis:   call EnumerateDataStores for each mount point
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT CSREmptyVolumeCache2::ForAllMountPoints (DWORDLONG *pdwlSpaceUsed,
                                                IEmptyVolumeCacheCallBack *picb,
                                                 BOOL fPurge)
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = EnumDataStores (pdwlSpaceUsed, picb, fPurge, _wszVolume);

    if (ERROR_SUCCESS == dwErr)
    {
        WCHAR wszMount [MAX_PATH];
        HANDLE hFind = FindFirstVolumeMountPoint (_wszVolume,wszMount,MAX_PATH);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                dwErr = EnumDataStores (pdwlSpaceUsed, picb, fPurge, wszMount);

                if (dwErr != ERROR_SUCCESS)
                    break;
            }
            while (FindNextVolumeMountPoint (hFind, wszMount, MAX_PATH));

            FindVolumeMountPointClose (hFind);
        }
    }

    return HRESULT_FROM_WIN32 (dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CSRClassFactory::CreateInstance
//
//  Synopsis:   create the disk cleanup plugin object
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT CSRClassFactory::CreateInstance (IUnknown *pUnkOuter,
                REFIID riid,
                void **ppvObject)
{
    HRESULT hr = S_OK;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CSREmptyVolumeCache2 *pevc = new CSREmptyVolumeCache2();
    if (pevc == NULL)
        return E_OUTOFMEMORY;

    hr = pevc->QueryInterface (riid, ppvObject);

    pevc->Release();  // release constructor's reference

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::InitializeEx
//
//  Synopsis:   initialize the disk cleanup plugin object
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT CSREmptyVolumeCache2::InitializeEx (
	HKEY hkRegKey,
	const WCHAR *pcwszVolume,
	const WCHAR *pcwszKeyName,
	WCHAR **ppwszDisplayName,
	WCHAR **ppwszDescription,
	WCHAR **ppwszBtnText,
	DWORD *pdwFlags)
{
    DWORDLONG dwlSpaceUsed = 0;
    WCHAR *pwszDisplay = NULL;
    WCHAR *pwszDescription = NULL;
    HRESULT hr=S_OK;

    pwszDisplay = (WCHAR *) CoTaskMemAlloc (MAX_PATH / 2 * sizeof(WCHAR)); 
    if (NULL == pwszDisplay)
    {
        hr = E_OUTOFMEMORY;
        goto Err;
    }

    pwszDescription = (WCHAR *) CoTaskMemAlloc (MAX_PATH * 2 * sizeof(WCHAR));
    if (NULL == pwszDescription)
    {
        hr = E_OUTOFMEMORY;
        goto Err;
    }
    
    if (0 == LoadStringW (ghModule, IDS_DISKCLEANUP_DISPLAY, 
                          pwszDisplay, MAX_PATH / 2))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Err;
    }

    if (0 == LoadStringW (ghModule, IDS_DISKCLEANUP_DESCRIPTION, 
                          pwszDescription, MAX_PATH * 2))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Err;
    }
                               
    lstrcpyW (_wszVolume, pcwszVolume);

    LoadBootIni();  // best effort, okay to fail

    ForAllMountPoints (&dwlSpaceUsed, NULL, FALSE);

    if (pdwFlags)
    {
        *pdwFlags |= (EVCF_ENABLEBYDEFAULT |
                      EVCF_ENABLEBYDEFAULT_AUTO |
                      EVCF_DONTSHOWIFZERO);
    }

    if (dwlSpaceUsed == 0)
        hr = S_FALSE;

Err:
    if (FAILED(hr))
    {
        if (pwszDisplay)
            CoTaskMemFree (pwszDisplay);
        if (pwszDescription)
            CoTaskMemFree (pwszDescription);

        if (ppwszDisplayName)
            *ppwszDisplayName = NULL;
        if (ppwszDescription)
            *ppwszDescription = NULL;
    }
    else
    {
        if (ppwszDisplayName)
            *ppwszDisplayName = pwszDisplay;
        if (ppwszDescription)
            *ppwszDescription = pwszDescription;
    }

    if (ppwszBtnText)                // no advanced button text
        *ppwszBtnText = NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::GetSpaceUsed
//
//  Synopsis:   returns how much space can be freed on a volume
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT CSREmptyVolumeCache2::GetSpaceUsed ( DWORDLONG *pdwlSpaceUsed,
 	                                         IEmptyVolumeCacheCallBack *picb)

{
    return ForAllMountPoints (pdwlSpaceUsed, picb, FALSE); 
}

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::Purge
//
//  Synopsis:   frees the disk space on a volume
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT CSREmptyVolumeCache2::Purge ( DWORDLONG dwlSpaceToFree,
                                      IEmptyVolumeCacheCallBack *picb)
{
    return ForAllMountPoints (&dwlSpaceToFree, picb, TRUE); 
}

//+---------------------------------------------------------------------------
//
//  Function:   CSREmptyVolumeCache2::Deactivate
//
//  Synopsis:   signal the disk cleanup plugin to stop processing
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT CSREmptyVolumeCache2::Deactivate (DWORD *pdwFlags)
{
    HRESULT hr=S_OK;

    if (pdwFlags)
        *pdwFlags = 0;  // no flags to be returned

    _fStop = TRUE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\diskcleanup.h ===
/******************************************************************
   Copyright (c) 2000 Microsoft Corporation

   diskcleanup.h -- disk cleanup COM object for SR

   Description:
        delete datastores from stale builds


******************************************************************/

#include <emptyvc.h>

extern long g_cLock;

//+---------------------------------------------------------------------------
//
//  Class:      CSREmptyVolumeCache2
//
//  Synopsis:   implements IEmptyVolumeCache2
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

class CSREmptyVolumeCache2 : IEmptyVolumeCache2
{
public:

    STDMETHOD(QueryInterface) (REFIID riid, void ** ppObject)
    {
        if (riid == IID_IEmptyVolumeCache2)
        {
            *ppObject = (IEmptyVolumeCache2 *) this;
            AddRef();
        }
     	else if (riid == IID_IEmptyVolumeCache)
        {
            *ppObject = (IEmptyVolumeCache *) this;
            AddRef();
        }
        else return E_NOINTERFACE;

        return S_OK;
    }

    STDMETHOD_(ULONG, AddRef) ()
    {
        return InterlockedIncrement (&_lRefs);
    }

    STDMETHOD_(ULONG, Release) ()
    {
        if (0 == InterlockedDecrement (&_lRefs))
        {
            delete this;
            return 0;
        }
        return _lRefs;
    }

    CSREmptyVolumeCache2 ()
    {
	    _lRefs = 1;
	    _fStop = FALSE;
        InterlockedIncrement (&g_cLock);
        _ulGuids = 0;

        for (int i=0; i < ARRAYSIZE; i++)
            _wszGuid[i][0] = L'\0';

        _wszVolume[0] = L'\0';
    }

    ~CSREmptyVolumeCache2 ()
    {
        InterlockedDecrement (&g_cLock);
    }

    STDMETHOD(Initialize) (
        HKEY hkRegKey,
        const WCHAR * pcwszVolume,
        WCHAR **ppwszDisplayName,
        WCHAR **ppwszDescription,
        DWORD *pdwFlags)
    {
        return InitializeEx (
                hkRegKey,
                pcwszVolume,
                NULL,
                ppwszDisplayName,
                ppwszDescription,
                NULL,
                pdwFlags);
    }

    STDMETHOD(InitializeEx) (
        HKEY hkRegKey,
        const WCHAR *pcwszVolume,
        const WCHAR *pcwszKeyName,
        WCHAR **ppwszDisplayName,
        WCHAR **ppwszDescription,
        WCHAR **ppwszBtnText,
        DWORD *pdwFlags);

    STDMETHOD(GetSpaceUsed) (
        DWORDLONG *pdwlSpaceUsed,
        IEmptyVolumeCacheCallBack *picb);

    STDMETHOD(Purge) (
        DWORDLONG dwlSpaceToFree,
        IEmptyVolumeCacheCallBack *picb);

    STDMETHOD(ShowProperties) (HWND hwnd)
    {
        return S_OK;  // no special UI
    }

    STDMETHOD(Deactivate) (DWORD *pdwFlags);

private:
    DWORD LoadBootIni ();
    DWORD EnumDataStores (DWORDLONG *pdwlSpaceUsed,
                          IEmptyVolumeCacheCallBack *picb,
                          BOOL fPurge,
                          WCHAR *pwszVolume);

    HRESULT ForAllMountPoints (DWORDLONG *pdwlSpaceUsed,
                               IEmptyVolumeCacheCallBack *picb,
                               BOOL fPurge);

    static const enum { ARRAYSIZE = 16 };
    static const enum { RESTOREGUID_STRLEN = 64 };

    LONG   _lRefs;
    BOOL   _fStop;
    ULONG  _ulGuids;
    WCHAR  _wszGuid [ARRAYSIZE][RESTOREGUID_STRLEN];
    WCHAR  _wszVolume [MAX_PATH];  // DOS drive letter
};

//+---------------------------------------------------------------------------
//
//  Class:      CSRClassFactory
//
//  Synopsis:   generic class factory
//
//  Arguments:
//
//  History:    20-Jul-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

class CSRClassFactory : IClassFactory
{
public:

    STDMETHOD(QueryInterface) (REFIID riid, void ** ppObject)
    {
        if (riid == IID_IClassFactory)
        {
            *ppObject = (IClassFactory *) this;
            AddRef();
        }
        else
        {
            return E_NOINTERFACE;
        }
        return S_OK;
    }

    STDMETHOD_(ULONG, AddRef) ()
    {
        return InterlockedIncrement (&_lRefs);
    }

    STDMETHOD_(ULONG, Release) ()
    {
        if (0 == InterlockedDecrement (&_lRefs))
        {
            delete this;
            return 0;
        }
        return _lRefs;
    }

    CSRClassFactory ()
    {
        _lRefs = 1;
        InterlockedIncrement (&g_cLock);
    }

    ~CSRClassFactory ()
    {
        InterlockedDecrement (&g_cLock);
    }

    STDMETHOD(CreateInstance) (IUnknown *pUnkOuter,
			    REFIID riid,
 			    void **ppvObject);

    STDMETHOD(LockServer) (BOOL fLock)
    {
        if (fLock)  InterlockedIncrement(&g_cLock);
        else        InterlockedDecrement(&g_cLock);
        return S_OK;
    }

private:
    LONG _lRefs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//
// need this to access older WMI methods 
// BUGBUG - better alternative is to change the params
// to use the new methods
//
#define FRAMEWORK_ALLOW_DEPRECATED 0

#include "stdafx.h"
#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>
#include <wbemidl.h>
#include <setupbat.h>

#include "diskcleanup.h"
#include "..\rstrcore\resource.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

void UnattendedFileParameters ();

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{a47401f6-a8a6-40ea-9c29-b8f6026c98b8}";
CLSID CLSID_SYSTEMRESTORE = {0xa47401f6, 0xa8a6, 0x40ea, 
                             {0x9c, 0x29, 0xb8, 0xf6, 0x02, 0x6c, 0x98, 0xb8}} ;

WCHAR *GUID_SRDiskCleanup = L"{7325c922-bb81-47b0-8b2f-a5f8605e242f}";
CLSID Clsid_SRDiskCleanup = {/*7325c922-bb81-47b0-8b2f-a5f8605e242f*/
    0x7325c922,
    0xbb81,
    0x47b0,
    {0x8b, 0x2f, 0xa5, 0xf8, 0x60, 0x5e, 0x24, 0x2f}
};

//Count number of objects and number of locks.
long g_cLock=0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
        
    if (CLSID_SYSTEMRESTORE == rclsid)
    {
        CWbemGlueFactory *pObj;

        pObj=new CWbemGlueFactory();

        if (NULL==pObj)
            return E_OUTOFMEMORY;

        hr=pObj->QueryInterface(riid, ppv);

        if (FAILED(hr))
            delete pObj;
    }
    else if (rclsid == Clsid_SRDiskCleanup)
    {
        CSRClassFactory *pcf = new CSRClassFactory ();

        if (pcf == NULL)
            return E_OUTOFMEMORY;

        hr = pcf->QueryInterface (riid, ppv);

        pcf->Release();  // release constructor refcount

    }
    else hr = E_FAIL;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"SYSTEMRESTORE"))
    {
        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
    }
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}


DWORD
CopyMofFile()
{   
    TENTER("CopyMofFile");
    
    WCHAR                       szSrc[MAX_PATH];
    IMofCompiler                *pimof = NULL;
    HRESULT                     hr;
    WBEM_COMPILE_STATUS_INFO    Info;
    BOOL                        fInitialized = FALSE;
    
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        trace(0, "! CoInitialize : %ld", hr);
        goto done;
    }

    fInitialized = TRUE;
    
    //
    // create an IMofCompiler instance
    //

    hr = CoCreateInstance(  CLSID_MofCompiler,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IMofCompiler,
                            (LPVOID*) &pimof );
    if (FAILED(hr) || NULL == pimof)
    {
        trace(0, "! CoCreateInstance : %ld", hr);
        goto done;
    }


    //
    // get the path of the source mof file
    // %windir%\system32\restore\sr.mof
    //

    if (0 == ExpandEnvironmentStrings(s_cszWinRestDir, szSrc, MAX_PATH))
    {
        hr = (HRESULT) GetLastError();        
        trace(0, "! ExpandEnvironmentStrings : %ld", hr);
        goto done;
    }  
    lstrcat(szSrc, s_cszMofFile);

    
    //
    // compile the mof file
    //
    
    hr = pimof->CompileFile(szSrc,
                            0,  // no server & namespace
                            0,  // no user
                            0,  // no authority
                            0,  // no password
                            0,  // no options
                            0,  // no class flags
                            0,  // no instance flags
                            &Info );
    if (hr != S_OK)
    {
        trace(0, "! CompileFile : %ld", hr);
        goto done;
    }

                              
done:    
    if (pimof)
    {
        pimof->Release();
    }
    
    if (fInitialized)
        CoUninitialize();
        
    TLEAVE();
    return hr;    
}

    
//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    WCHAR      wcID[128];
    WCHAR      wcCLSID[128];
    WCHAR      wcModule[MAX_PATH];
    WCHAR * pName = L"";
    WCHAR * pModel = L"Both";
    HKEY hKey1 = NULL, hKey2 = NULL, hKeySR = NULL;
    DWORD   dwRc;
    
    // Create the path.
    
    lstrcpy(wcCLSID, L"SOFTWARE\\CLASSES\\CLSID\\");
    lstrcat(wcCLSID, GUIDSTRING);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, wcCLSID, &hKey1);
    if (hKey1 != NULL)
    {
        RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName,
                      (lstrlen(pName)+1) * sizeof(WCHAR));
        RegCreateKey(hKey1, L"InprocServer32",&hKey2);

        if (hKey2 != NULL)
        {
            GetModuleFileName(ghModule, wcModule,  MAX_PATH);
            RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *) wcModule, 
                                        (lstrlen(wcModule)+1) * sizeof(WCHAR));
            RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, 
                         (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(WCHAR));

            CloseHandle(hKey2);
        }
        CloseHandle(hKey1);
    }

    // copy the sr.mof file into the wbem directories
    // get the wbem directories from the registry
    
//    dwRc = CopyMofFile();   

    lstrcpy(wcCLSID, L"SOFTWARE\\CLASSES\\CLSID\\");
    lstrcat(wcCLSID, GUID_SRDiskCleanup);

    RegCreateKey(HKEY_LOCAL_MACHINE, wcCLSID, &hKey1);
    if (hKey1 != NULL)
    {
        RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, 
                       (lstrlen(pName)+1) * sizeof(WCHAR));
        RegCreateKey(hKey1, L"InprocServer32", &hKey2);

        if (hKey2 != NULL)
        {
            GetModuleFileName(ghModule, wcModule,  MAX_PATH);
            RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *) wcModule,
                                        (lstrlen(wcModule)+1) * sizeof(WCHAR));
            RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ,
                         (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(WCHAR));
            CloseHandle(hKey2);
        }

        RegCreateKey(hKey1, L"DefaultIcon", &hKey2);
        if (hKey2 != NULL)
        {
            lstrcpy (wcModule, L"%SystemRoot%\\system32\\srclient.dll,0");
            RegSetValueEx(hKey2, NULL, 0, REG_EXPAND_SZ,  (BYTE *) wcModule,
                         (lstrlen(wcModule)+1) * sizeof(WCHAR));
            CloseHandle(hKey2);
        }

        CloseHandle(hKey1);
    }

    RegCreateKey(HKEY_LOCAL_MACHINE, 
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches"
        L"\\System Restore", &hKey1);

    if (hKey1 != NULL)
    {
        RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *) GUID_SRDiskCleanup,
                (lstrlen(GUID_SRDiskCleanup)+1) * sizeof(WCHAR));
    }

    UnattendedFileParameters();

    return NOERROR;
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR      wcID[128];
    WCHAR      wcCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    lstrcpy(wcCLSID, L"SOFTWARE\\CLASSES\\CLSID\\");
    lstrcat(wcCLSID, GUIDSTRING);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, wcCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        CloseHandle(hKey);
    }

    lstrcpy(wcCLSID, L"SOFTWARE\\CLASSES\\CLSID\\");
    lstrcat(wcCLSID, GUID_SRDiskCleanup);

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, wcCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        RegDeleteKey(hKey, L"DefaultIcon");
        CloseHandle(hKey);
    }

	// then delete the clsid keys for both SystemRestoreProv and SRDiskCleanup
	
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\CLASSES\\CLSID\\", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, GUIDSTRING);
        RegDeleteKey(hKey, GUID_SRDiskCleanup); 
        CloseHandle(hKey);
    }

    RegDeleteKey(HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches"
        L"\\System Restore");

    return NOERROR;
}

void UnattendedFileParameters ()
{
    HKEY hKey = NULL;
    WCHAR * pwNull = L"";
    DWORD dwAnswerLength = MAX_PATH;
    LONG lAnswer = 0;
    WCHAR wcsAnswerFile [MAX_PATH];
    WCHAR wcsAnswer [MAX_PATH];

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, s_cszSRCfgRegKey, 0, 
                        KEY_WRITE, &hKey))
        return;    

    if (0 == GetSystemDirectoryW (wcsAnswerFile,MAX_PATH))
        return;

    lstrcatW (wcsAnswerFile, L"\\");
    lstrcatW (wcsAnswerFile, WINNT_GUI_FILE_W);

    /*
    if( GetPrivateProfileString( s_cszSRUnattendedSection,
                                 L"MaximumDataStoreSize",
                                 pwNull,
                                 wcsAnswer,
                                 dwAnswerLength,
                                 wcsAnswerFile ) )
    {
        if( lstrcmpW (pwNull, wcsAnswer ))
        {
            lAnswer = wcstol (wcsAnswer,NULL,10);
            if (lAnswer > 0)
                RegWriteDWORD(hKey, s_cszDSMax, (DWORD *) &lAnswer);
        }
    }
    */

    if( GetPrivateProfileString( s_cszSRUnattendedSection,
                                 L"RestorePointLife",
                                 pwNull,
                                 wcsAnswer,
                                 dwAnswerLength,
                                 wcsAnswerFile ) )
    {
        if( lstrcmpW (pwNull, wcsAnswer ))
        {
            lAnswer = wcstol (wcsAnswer,NULL,10);
            lAnswer *= 24 * 3600;    // convert days to seconds
            if (lAnswer > 0)
                RegWriteDWORD(hKey, s_cszRPLifeInterval, (DWORD *) &lAnswer);
        }
    }

    if( GetPrivateProfileString( s_cszSRUnattendedSection,
                                 L"CheckpointCalendarFrequency",
                                 pwNull,
                                 wcsAnswer,
                                 dwAnswerLength,
                                 wcsAnswerFile ) )
    {
        if( lstrcmpW (pwNull, wcsAnswer ))
        {
            lAnswer = wcstol (wcsAnswer,NULL,10);
            lAnswer *= 24 * 3600;    // convert days to seconds
            if (lAnswer > 0)
                RegWriteDWORD(hKey, s_cszRPGlobalInterval, (DWORD *) &lAnswer);
        }
    }

    if( GetPrivateProfileString( s_cszSRUnattendedSection,
                                 L"CheckPointSessionFrequency",
                                 pwNull,
                                 wcsAnswer,
                                 dwAnswerLength,
                                 wcsAnswerFile ) )
    {
        if( lstrcmpW (pwNull, wcsAnswer ))
        {
            lAnswer = wcstol (wcsAnswer,NULL,10);
            lAnswer *= 3600;    // convert hours to seconds
            if (lAnswer > 0)
                RegWriteDWORD(hKey, s_cszRPSessionInterval, (DWORD *) &lAnswer);
        }
    }

    if( GetPrivateProfileString( s_cszSRUnattendedSection,
                                 L"MaximumDataStorePercentOfDisk",
                                 pwNull,
                                 wcsAnswer,
                                 dwAnswerLength,
                                 wcsAnswerFile ) )
    {
        if( lstrcmpW (pwNull, wcsAnswer ))
        {
            lAnswer = wcstol (wcsAnswer,NULL,10);
            if (lAnswer <= 100 && lAnswer > 0)
                RegWriteDWORD(hKey, s_cszDiskPercent, (DWORD *) &lAnswer);
        }
    }

    RegCloseKey (hKey);
    return;
}


void CALLBACK
CreateFirstRunRp(
    HWND hwnd, 
    HINSTANCE hinst, 
    LPSTR lpszCmdLine, 
    int nCmdShow)
{
    RESTOREPOINTINFO    RPInfo;
    STATEMGRSTATUS      SmgrStatus;               
    DWORD               dwValue;
    HANDLE              hInit = NULL;
    
    //
    // first remove ourselves from Run key
    //

    HKEY hKey;
    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, 
                             L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 
                             &hKey);
    if (dwRet == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey, L"SRFirstRun");
        RegCloseKey(hKey);
    }

    //
    // wait until the service has fully initialized
    // query thrice at 10 second intervals
    //
    
    dwRet = WAIT_FAILED;
    int i = 0;
    while (i++ <= 3)
    {
        hInit = OpenEvent(SYNCHRONIZE, FALSE, s_cszSRInitEvent);
        if (hInit == NULL)
        {
            if (i >= 3) 
            {
                break;
            }    
            Sleep(10000);
        }
        else
        {
            dwRet = WaitForSingleObject(hInit, 60*1000); // 1 minute
            break;
        }
    }
    
    //
    // reset registry value CreateFirstRunRp
    // so that service will create firstrun rp in the future
    //
    
    dwValue = 1;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, 
                                    s_cszSRRegKey, 
                                    &hKey))
    {
        RegWriteDWORD(hKey, s_cszCreateFirstRunRp, &dwValue);
        RegCloseKey(hKey);
    }
    
    //
    // try creating firstrun rp now
    //

    if (dwRet != WAIT_FAILED)
    {
        RPInfo.dwEventType = BEGIN_SYSTEM_CHANGE; 
        RPInfo.dwRestorePtType = FIRSTRUN;
        if (ERROR_SUCCESS != SRLoadString(L"srrstr.dll", IDS_SYSTEM_CHECKPOINT_TEXT, RPInfo.szDescription, MAX_DESC_W))
        {
            lstrcpy(RPInfo.szDescription, s_cszSystemCheckpointName);
        }
        SRSetRestorePoint(&RPInfo, &SmgrStatus);
    }
    

    if (hInit)
    {
        CloseHandle(hInit);
    }
    
    return;
}




//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;
    
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);

         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"SYSTEMRESTORE");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\resource.h ===
#define IDS_DISKCLEANUP_DISPLAY     1
#define IDS_DISKCLEANUP_DESCRIPTION 2
#define IDS_RSTRUI 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\snapshot\snapshot.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    snapshot.cpp
 *
 *  Abstract:
 *    CSnapshot, CSnapshot class functions
 *
 *  Revision History:
 *    Ashish Sikka (ashishs)  05/05/2000
 *        created
 *
 *****************************************************************************/

#include "snapshoth.h"
#include "srrpcapi.h"
#include "srapi.h"
#include "..\datastor\datastormgr.h"
#include "..\service\evthandler.h"


#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


static LPCWSTR s_cszCOMDBBackupFile   = L"ComDb.Dat";
static LPCWSTR s_cszWMIBackupFile     = L"Repository";
static LPCWSTR s_cszIISBackupFile     = L"IISDB";
static LPCWSTR s_cszIISSuffix         = L".MD";
static LPCWSTR s_cszIISBackupPath     = L"%windir%\\system32\\inetsrv\\metaback\\";
static LPCWSTR s_cszIISOriginalPath   = L"%windir%\\system32\\inetsrv\\metabase.bin";
static LPCWSTR s_cszSnapshotUsrClassLocation  = L"Local Settings\\Application Data\\Microsoft\\Windows\\UsrClass.dat";
static LPCWSTR s_cszSnapshotUsrClass  = L"USRCLASS_";
static LPCWSTR s_cszSnapshotNtUser    = L"NTUSER_";
static LPCWSTR s_cszClassesKey        = L"_Classes";
static LPCWSTR s_cszSnapshotUsersDefaultKey = L".DEFAULT";
static LPCWSTR s_cszSnapshotHiveList  = L"System\\CurrentControlSet\\Control\\Hivelist";
static LPCWSTR s_cszRestoreTempKey    = L"Restore122312";
static LPCWSTR s_cszHKLMPrefix        = L"\\Registry\\Machine\\";
static LPCSTR s_cszRegDBBackupFn      = "RegDBBackup";
static LPCSTR s_cszRegDBRestoreFn     = "RegDBRestore";

#define VALIDATE_DWRET(str) \
    if ( dwRet != ERROR_SUCCESS ) \
    { \
        ErrorTrace(0, str " failed ec=%d", dwRet); \
        goto Exit; \
    } \

#define LOAD_KEY_NAME         TEXT("BackupExecReg")


DWORD SnapshotCopyFile(WCHAR * pszSrc,
                       WCHAR * pszDest);

struct WMISnapshotParam
{
    HANDLE hEvent;
    CRestorePoint  *pRpLast;
    BOOL   fSerialized;
    WCHAR  szSnapshotDir[MAX_PATH];
};

DWORD WINAPI DoWMISnapshot(VOID * pParam);

DWORD DoIISSnapshot(WCHAR * pszSnapshotDir);

DWORD SnapshotRestoreFilelistFiles(WCHAR * pszSnapshotDir, BOOL fSnapshot);

DWORD CallSnapshotCallbacks(LPCWSTR pszEnumKey, LPCWSTR pszSnapshotDir, BOOL fSnapshot);

CSnapshot::CSnapshot()
{
    TraceFunctEnter("CSnapshot::CSnapshot");
    
    m_hRegdbDll = NULL;
    m_pfnRegDbBackup = NULL;
    m_pfnRegDbRestore = NULL;

    TraceFunctLeave();
}

CSnapshot::~CSnapshot()
{
    TraceFunctEnter("CSnapshot::~CSnapshot");
    m_pfnRegDbBackup = NULL;
    m_pfnRegDbRestore = NULL;    
    if (NULL != m_hRegdbDll)
    {        
        _VERIFY(TRUE==FreeLibrary(m_hRegdbDll));
    }
    TraceFunctLeave();    
}

DWORD 
CSnapshot::DeleteSnapshot(WCHAR * pszRestoreDir)
{
    TraceFunctEnter("CSnapshot::DeleteSnapshot");
    
    WCHAR           szSnapshotDir[MAX_PATH];
    BOOL            fStop=FALSE;
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;

     // create the snapshot directory name from the restore directory
     // name and create the actual directory.
    lstrcpy(szSnapshotDir, pszRestoreDir);
    lstrcat(szSnapshotDir, SNAPSHOT_DIR_NAME);    

    
    dwErr = Delnode_Recurse(szSnapshotDir,
                            TRUE, // Delete the ROOT dir
                            &fStop);
    if (dwErr != ERROR_SUCCESS)
    {
        ErrorTrace(0, "Fatal error %ld deleting snapshot directory",dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
    TraceFunctLeave();
    return dwReturn;        
}

// the following function checks to see if the file passed in is a
// temporary copy of a reghive created before the restore.
// It does this by checking if the file suffix is s_cszRegHiveCopySuffix
BOOL  IsRestoreCopy(const WCHAR * pszFileName)
{
    BOOL  fReturn=FALSE;
    DWORD dwLength, dwSuffixLen;

     // Find 
    dwLength = lstrlen(pszFileName);
    dwSuffixLen = lstrlen(s_cszRegHiveCopySuffix);
    if (dwSuffixLen > dwLength)
    {
        goto cleanup;
    }
    dwLength -= dwSuffixLen;

     // If the file is indeed a restore copy, dwLength points to the
     // first character of s_cszRegHiveCopySuffix
    if (0==lstrcmpi(pszFileName+dwLength, s_cszRegHiveCopySuffix))
    {
        fReturn = TRUE;
    }
    
cleanup:
    
    return fReturn;    
}

DWORD
ProcessPendingRenames(LPWSTR pszSnapshotDir)
{
    TraceFunctEnter("ProcessPendingRenames");
    
    WCHAR szDest[MAX_PATH];
    DWORD dwRc;
    HKEY  hKey = NULL;
    
    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        s_cszSessionManagerRegKey,
                        0,
                        KEY_READ, 
                        &hKey);
    if (ERROR_SUCCESS == dwRc)                                    
    {
        DWORD dwType = REG_MULTI_SZ;
        DWORD dwSize = 0;
        
        dwRc = RegQueryValueEx(hKey, s_cszMoveFileExRegValue, 0, &dwType, NULL, &dwSize);
        if (dwRc == ERROR_SUCCESS && dwSize > 0)
        {            
            WCHAR * pwcBuffer = new WCHAR [dwSize / 2];
                
            if (pwcBuffer == NULL)
            {
                trace(0, "Error allocating pwcBuffer");
                dwRc = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }

            dwRc = RegQueryValueEx(hKey, s_cszMoveFileExRegValue, 
                                   NULL, &dwType, (BYTE *) pwcBuffer, &dwSize);

            if (ERROR_SUCCESS == dwRc && REG_MULTI_SZ == dwType)
            {
                int iFirst = 0;
                int iSecond = 0;
                int iFile = 1;

                while ((iFirst < (int) dwSize/2) && pwcBuffer[iFirst] != L'\0')
                {
                    iSecond = iFirst + lstrlenW(&pwcBuffer[iFirst]) + 1;
                    DebugTrace(0, "Src : %S, Dest : %S", &pwcBuffer[iFirst], &pwcBuffer[iSecond]);                    
                    
                    if (pwcBuffer[iSecond] != L'\0')
                    {
                        // snapshot the source file to a file MFEX-i.DAT in the snapshot dir

                        wsprintf(szDest, L"%s\\MFEX-%d.DAT", pszSnapshotDir, iFile++);

                        SRCopyFile(&pwcBuffer[iFirst+4], szDest);                        
                    }
                    iFirst = iSecond + lstrlenW(&pwcBuffer[iSecond]) + 1;
                }
            }
            delete [] pwcBuffer;
        }
        else
        {
            dwRc = ERROR_SUCCESS;
        }
    }
    else
    {            
        trace(0, "! RegOpenKeyEx on %S : %ld", s_cszSessionManagerRegKey, dwRc);
    }

done: 
    if (hKey)
        RegCloseKey(hKey);
    TraceFunctLeave();
    return dwRc;
}


DWORD 
CSnapshot::CreateSnapshot(WCHAR * pszRestoreDir, HMODULE hCOMDll, LPWSTR pszRpLast, BOOL fSerialized)
{
    TraceFunctEnter("CSnapshot::CreateSnapshot");
    
    HANDLE hThread = NULL;
    HANDLE hEvent = NULL;
    WMISnapshotParam * pwsp = NULL;
    WCHAR pszSnapShotDir[MAX_PATH];
    DWORD  dwErr, dwAttrs;
    DWORD  dwReturn = ERROR_INTERNAL_ERROR;
    BOOL   fCoInitialized = FALSE;    
    BOOL   fWMISnapshotParamCleanup = TRUE;
    HRESULT hr;
    CTokenPrivilege tp;
    
     // create the snapshot directory name from the restore directory
     // name and create the actual directory.
    lstrcpy(pszSnapShotDir, pszRestoreDir);
    lstrcat(pszSnapShotDir, SNAPSHOT_DIR_NAME);
    if (FALSE == CreateDirectory( pszSnapShotDir, // directory name
                                  NULL))  // SD
    {
        dwErr = GetLastError();
        if (ERROR_ALREADY_EXISTS != dwErr)
        {
            ErrorTrace(0, "Fatal error %ld creating snapshot directory",dwErr);
            goto cleanup;
        }
    }
     // set the directory to be uncompressed by default
    dwAttrs = GetFileAttributesW (pszSnapShotDir);
    if ( (dwAttrs != INVALID_FILE_SIZE) && 
         (0 != (FILE_ATTRIBUTE_COMPRESSED & dwAttrs)) )
    {
        dwErr = CompressFile ( pszSnapShotDir,
                               FALSE, // uncompress
                               TRUE ); // target is a directory
        
        if (dwErr != ERROR_SUCCESS)
        {
            ErrorTrace(0, "! CreateDataStore CompressFile : %ld", dwErr);
             // this is not a fatal error
        }
    }

    pwsp = new WMISnapshotParam;
    if (NULL == pwsp)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        ErrorTrace(0, "cannot allocate CWMISnapshotParam");
        goto cleanup;
    }

    if (pszRpLast)
    {
        pwsp->pRpLast = new CRestorePoint;
        if (NULL == pwsp->pRpLast)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            ErrorTrace(0, "cannot allocate CRestorePoint");
            goto cleanup;
        }
        pwsp->pRpLast->SetDir(pszRpLast);
    }
    else
    {
        pwsp->pRpLast = NULL;
    }

    lstrcpyW (pwsp->szSnapshotDir, pszSnapShotDir);
    pwsp->fSerialized = fSerialized;
    hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);  // manual reset
    if (NULL == hEvent )
    {
        dwReturn = GetLastError();
        ErrorTrace(0, "! CreateEvent : %ld", dwReturn);
        goto cleanup;
    }

    if (FALSE == DuplicateHandle (GetCurrentProcess(),
                                  hEvent,
                                  GetCurrentProcess(),
                                  &pwsp->hEvent,
                                  0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        dwReturn = GetLastError();
        ErrorTrace(0, "! DuplicateHandle : %ld", dwReturn);
        goto cleanup;
    }

    if (! fSerialized)
    {
        trace(0, "Parallellizing WMI snapshot");
        hThread = CreateThread (NULL, 0, DoWMISnapshot, pwsp, 0, NULL);
        if (hThread == NULL)
        {
            dwReturn = GetLastError();
            ErrorTrace(0, "! CreateThread : %ld", dwReturn);
            CloseHandle (pwsp->hEvent);
            pwsp->hEvent = NULL;
            goto cleanup;
        }
        if (g_pEventHandler)
            g_pEventHandler->GetCounter()->Up();
        fWMISnapshotParamCleanup = FALSE; // ownership transferred
    }

     // before doing the registry snapshot, clear the restore error
     // this will prevent us from snapshotting a registry that has
     // this error set. Note this that error is only used for the
     // restore process and we do not want to restore any regsitries
     // what have this error set.
    _VERIFY(TRUE==SetRestoreError(ERROR_SUCCESS)); // clear this error    

    dwErr = ProcessPendingRenames(pszSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;
        goto cleanup;
    }
    
    dwErr = tp.SetPrivilegeInAccessToken(SE_BACKUP_NAME);
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "SetPrivilegeInAccessToken failed ec=%d", dwErr);
        dwReturn = ERROR_PRIVILEGE_NOT_HELD;
        goto cleanup;
    }

     // Create resgistry snapshot
    dwErr = DoRegistrySnapshot(pszSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;
        goto cleanup;
    }

    //snapshot files listed in filelist.xml
    dwErr = SnapshotRestoreFilelistFiles(pszSnapShotDir, TRUE);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;
        goto cleanup;
    }

    // do COM snapshot
    dwErr = DoCOMDbSnapshot(pszSnapShotDir, hCOMDll);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;        
        goto cleanup;
    }

    hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if (hr == RPC_E_CHANGED_MODE)
    {
        //
        // someone called it with other mode
        //
        
        hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    }    
    
    if (FAILED(hr))
    {
        dwReturn = (DWORD) hr;
        ErrorTrace(0, "! CoInitializeEx : %ld", dwReturn);
        goto cleanup;
    }

    fCoInitialized = TRUE;

     // do IIS snapshot
    dwErr = DoIISSnapshot(pszSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;        
        goto cleanup;
    }    

     
    lstrcatW (pszSnapShotDir, L"\\domain.txt");
    dwErr = GetDomainMembershipInfo (pszSnapShotDir, NULL);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;
        trace(0, "! GetDomainMembershipInfo : %ld", dwErr);
        goto cleanup;
    }

    // if serialized WMI snapshot, do it here
    if (fSerialized)
    {
        trace(0, "Serializing WMI snapshot");
        fWMISnapshotParamCleanup = FALSE;
        dwReturn = DoWMISnapshot(pwsp);
        if (dwReturn != ERROR_SUCCESS)
        {
            trace(0, "! DoWMISnapshot : %ld", dwErr);
            goto cleanup;
        }
    }
    else
    {    
        // wait for the WMI Pause to finish
        dwErr = WaitForSingleObject (hEvent, CLock::TIMEOUT);
        if (WAIT_TIMEOUT == dwErr)
        {
            trace (0, "WMI thread timed out");
        }
        else if (WAIT_FAILED == dwErr)
        {
            trace (0, "WaitForSingleObject failed");
        }        
        trace(0, "WMI Pause is done");
    }

    dwReturn = ERROR_SUCCESS;

cleanup:
    if (hEvent != NULL)
    {
        CloseHandle (hEvent);
    }

    if (fWMISnapshotParamCleanup && NULL != pwsp)
    {
        if (pwsp->pRpLast)
            delete pwsp->pRpLast;
        delete pwsp;
        trace(0, "CreateSnapshot released pwsp");
    }

    if (fCoInitialized)
        CoUninitialize();

    if (hThread != NULL)
        CloseHandle (hThread);

    TraceFunctLeave();
    return dwReturn;
}

BOOL IsWellKnownHKLMHive(WCHAR * pszHiveName)
{
    return ( (0==lstrcmpi(pszHiveName, s_cszSoftwareHiveName)) ||
             (0==lstrcmpi(pszHiveName, s_cszSystemHiveName  )) ||
             (0==lstrcmpi(pszHiveName, s_cszSamHiveName     )) ||
             (0==lstrcmpi(pszHiveName, s_cszSecurityHiveName)) );
}

DWORD SaveRegKey(HKEY    hKey,  // handle to parent key
                 const WCHAR * pszSubKeyName,   // name of subkey to backup
                 WCHAR * pszFileName)  // filename of backup file 
{
    TraceFunctEnter("SaveRegKey");
    
    DWORD dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwDisposition;
    
    HKEY  hKeyToBackup = NULL;
    
    
     // open the key - pass the REG_OPTION_BACKUP_RESTORE to bypass
     // security checking
    dwErr = RegCreateKeyEx(hKey, // handle to open key
                           pszSubKeyName, // subkey name
                           0,        // reserved
                           NULL, // class string
                           REG_OPTION_BACKUP_RESTORE, // special options
                           KEY_READ, // desired security access
                           NULL, // inheritance
                           &hKeyToBackup, // key handle 
                           &dwDisposition); // disposition value buffer

    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "RegCreateKeyEx failed for %S, error %ld",
                   pszSubKeyName, dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }

     // now make sure that the key already existed - else delete the key
    if (REG_OPENED_EXISTING_KEY != dwDisposition)
    {
         // no key existed - delete the key
        ErrorTrace(0, "Key %S did not exist, error %ld",
                   pszSubKeyName, dwErr);
        dwReturn = ERROR_FILE_NOT_FOUND;
        
        _VERIFY(ERROR_SUCCESS==RegCloseKey(hKeyToBackup));
        hKeyToBackup = NULL;
        
        _VERIFY(ERROR_SUCCESS==RegDeleteKey(hKey, // handle to open key
                                            pszSubKeyName));// subkey name

         // BUGBUG test above case
        goto cleanup;
    }
    
    dwErr = RegSaveKeyEx(hKeyToBackup,// handle to key
                         pszFileName,// data file
                         NULL,// SD	
                         REG_NO_COMPRESSION);
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "RegSaveKey failed for %S, error %ld",
                   pszSubKeyName, dwErr);
        LogDSFileTrace(0,L"File was ", pszFileName);        
        dwReturn = dwErr;
        goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
    
cleanup:
    if (NULL != hKeyToBackup)
    {
        _VERIFY(ERROR_SUCCESS==RegCloseKey(hKeyToBackup));
    }
    TraceFunctLeave();
    return dwReturn;
}





//  the saved NTUser.dat file name is of the form
//  _REGISTRY_USER_NTUSER_S-1-9-9-09
DWORD CreateNTUserDatPath(WCHAR * pszDest,
                          DWORD   dwDestLength,  // length in characters
                          WCHAR * pszSnapshotDir,
                          WCHAR * pszUserSID)
{
    TraceFunctEnter("CreateNTUserDatPath");
    
    DWORD  dwLengthRequired;
    
    dwLengthRequired = lstrlen(pszSnapshotDir) + lstrlen(s_cszUserPrefix) +
        lstrlen(s_cszSnapshotNtUser)+ lstrlen(pszUserSID) +2;
    
    if (dwDestLength < dwLengthRequired)
    {
        ErrorTrace(0, "Insuffcient buffer. Buffer passed in %d, Required %d",
                   dwDestLength, dwLengthRequired);
        
        TraceFunctLeave();
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    wsprintf(pszDest, L"%s\\%s%s%s", pszSnapshotDir, s_cszUserPrefix,
             s_cszSnapshotNtUser, pszUserSID);
    
    TraceFunctLeave();
    return ERROR_SUCCESS;
}

//  the saved UsrClass.dat file name is of the form
//  _REGISTRY_USER_USRCLASS_S-1-9-9-09
DWORD CreateUsrClassPath(WCHAR * pszDest,
                         DWORD   dwDestLength,  // length in characters
                         WCHAR * pszSnapshotDir,
                         WCHAR * pszUserSID)
{
    TraceFunctEnter("CreateUsrClassPath");
    
    DWORD  dwLengthRequired;
    
    dwLengthRequired = lstrlen(pszSnapshotDir) + lstrlen(s_cszUserPrefix) +
        lstrlen(s_cszSnapshotUsrClass)+ lstrlen(pszUserSID) +2;
    
    if (dwDestLength < dwLengthRequired)
    {
        ErrorTrace(0, "Insuffcient buffer. Buffer passed in %d, Required %d",
                   dwDestLength, dwLengthRequired);
        
        TraceFunctLeave();
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    wsprintf(pszDest, L"%s\\%s%s%s", pszSnapshotDir, s_cszUserPrefix,
             s_cszSnapshotUsrClass, pszUserSID);
    
    TraceFunctLeave();    
    return ERROR_SUCCESS;    
}


//
// function to write movefileex entries to a saved system hive file
//
DWORD
SrMoveFileEx(
    LPWSTR pszSnapshotDir, 
    LPWSTR pszSrc,
    LPWSTR pszDest)
{
    TraceFunctEnter("SrMoveFileEx");
    
    DWORD dwErr = ERROR_SUCCESS;
    HKEY  hkMount = NULL;
    DWORD cbData1 = 0;
    PBYTE pNewMFE = NULL, pOldMFE = NULL, pNewPos = NULL;
    BOOL  fRegLoaded = FALSE;
    WCHAR szNewEntry1[MAX_PATH];
    WCHAR szNewEntry2[MAX_PATH];
    WCHAR szNewEntry3[MAX_PATH];
    DWORD cbNewEntry1 = 0, cbNewEntry2 = 0, cbNewEntry3 = 0;
    WCHAR szSysHive[MAX_PATH];
    
    //
    // load system hive file
    //

    wsprintf(szSysHive, L"%s\\%s%s%s", pszSnapshotDir,
             s_cszHKLMFilePrefix, s_cszSystemHiveName, s_cszRegHiveCopySuffix);
    
    CHECKERR(RegLoadKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp, szSysHive ),
             L"RegLoadKey");

    fRegLoaded = TRUE;
    
    CHECKERR(RegOpenKey( HKEY_LOCAL_MACHINE, s_cszRegHiveTmp, &hkMount ),
             L"RegOpenKey");

    //
    // get old entries
    //

    lstrcpy(szSysHive, s_cszRegLMSYSSessionMan);
    ChangeCCS(hkMount, szSysHive);
    
    pOldMFE = (PBYTE) SRGetRegMultiSz( hkMount, szSysHive, SRREG_VAL_MOVEFILEEX, &cbData1 );

    //
    // alloc mem for old + new
    // allocate enough to hold 3 new paths + some extra characters
    //

    pNewMFE = (PBYTE) malloc(cbData1 + 4*MAX_PATH*sizeof(WCHAR));
    if (! pNewMFE)
    {
        ErrorTrace(0, "Out of memory");
        dwErr = ERROR_OUTOFMEMORY;
        goto Err;
    }
    if (pOldMFE)
        memcpy(pNewMFE, pOldMFE, cbData1);

    //
    // format new entries - a delete and a rename      
    //    

    wsprintf(szNewEntry2, L"\\\?\?\\%s", pszSrc);
    cbNewEntry2 = (lstrlen(szNewEntry2) + 1)*sizeof(WCHAR);

    wsprintf(szNewEntry3, L"!\\\?\?\\%s", pszDest);
    cbNewEntry3 = (lstrlen(szNewEntry3) + 1)*sizeof(WCHAR);
    
    DebugTrace(0, "%S", szNewEntry2);   
    DebugTrace(0, "%S", szNewEntry3);    

    //
    // find position to insert new entries - overwrite trailing '\0'
    //
    
    if (pOldMFE)
    {
        DebugTrace(0, "Old MFE entries exist");
        cbData1 -= sizeof(WCHAR);
        pNewPos = pNewMFE + cbData1; 
    }
    else
    {
        DebugTrace(0, "No old MFE entries exist");
        pNewPos = pNewMFE;
    }
   
    //
    // append rename
    //
 
    memcpy(pNewPos, (BYTE *) szNewEntry2, cbNewEntry2);
    pNewPos += cbNewEntry2;
    memcpy(pNewPos, (BYTE *) szNewEntry3, cbNewEntry3);
    pNewPos += cbNewEntry3;    
    
    //
    // add trailing '\0'
    //
    
    *((LPWSTR) pNewPos) = L'\0';  

    //
    // write back to registry
    //
    
    if (! SRSetRegMultiSz( hkMount, 
                           szSysHive, 
                           SRREG_VAL_MOVEFILEEX, 
                           (LPWSTR) pNewMFE, 
                           cbData1 + cbNewEntry2 + cbNewEntry3 + sizeof(WCHAR)))
    {
        ErrorTrace(0, "! SRSetRegMultiSz");
        dwErr = ERROR_INTERNAL_ERROR;
    }


Err:
    if (hkMount != NULL)
        RegCloseKey(hkMount);

    if (fRegLoaded)
        RegUnLoadKey(HKEY_LOCAL_MACHINE, s_cszRegHiveTmp);

    if (pOldMFE)
        delete pOldMFE;
        
    if (pNewMFE)
        free(pNewMFE);

    TraceFunctLeave();    
    return dwErr;
}


//  the saved UsrClass.dat file name is of the form
//  _REGISTRY_USER_USRCLASS_S-1-9-9-09
DWORD CreateUsrDefaultPath(WCHAR * pszDest,
                           DWORD   dwDestLength,  // length in characters
                           WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("CreateUsrDefaultPath");
    
    DWORD  dwLengthRequired;
    
    dwLengthRequired = lstrlen(pszSnapshotDir) + lstrlen(s_cszUserPrefix) +
        lstrlen(s_cszSnapshotUsersDefaultKey) +2;
    
    if (dwDestLength < dwLengthRequired)
    {
        ErrorTrace(0, "Insuffcient buffer. Buffer passed in %d, Required %d",
                   dwDestLength, dwLengthRequired);
        
        TraceFunctLeave();
        return ERROR_INSUFFICIENT_BUFFER;
    }

    wsprintf(pszDest, L"%s\\%s%s", pszSnapshotDir, s_cszUserPrefix,
             s_cszSnapshotUsersDefaultKey);
    
    TraceFunctLeave();    
    return ERROR_SUCCESS;    
}

DWORD SetNewRegistry(HKEY hBigKey, // handle to open key
                     const WCHAR * pszHiveName,  // subkey name
                     WCHAR * pszDataFile, // data file
                     WCHAR * pszOriginalFile,
                     WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("SetNewRegistry");
    
    DWORD dwErr, dwReturn=ERROR_INTERNAL_ERROR, dwDisposition;
    WCHAR szBackupFile[MAX_PATH];  // backup file
    HKEY  hLocalKey=NULL;
    REGSAM samDesired = MAXIMUM_ALLOWED;
    WCHAR szTempRegCopy[MAX_PATH];
    
     // first check to see if the file is a copy created for this
     // restore process. If not, we need to create a copy since
     // RegReplaceKey removes the input file.
    if (FALSE == IsRestoreCopy(pszDataFile))
    {
        wsprintf(szTempRegCopy, L"%s%s", pszDataFile,
                 s_cszRegHiveCopySuffix);
        
        dwErr = SnapshotCopyFile(pszDataFile, szTempRegCopy);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
            goto cleanup;
        }
    }
    else
    {
        lstrcpy(szTempRegCopy, pszDataFile);
    }
    
    wsprintf(szBackupFile, L"%s%s",szTempRegCopy,s_cszRegReplaceBackupSuffix);
    
    dwErr = RegCreateKeyEx( hBigKey,// handle to open key
                            pszHiveName,// subkey name
                            0,// reserved
                            NULL,// class string
                            REG_OPTION_BACKUP_RESTORE,// special options
                            samDesired,// desired security access
                            NULL,// inheritance
                            &hLocalKey,// key handle 
                            &dwDisposition );// disposition value buffer


   if ( ERROR_SUCCESS != dwErr )
   {
        ErrorTrace(0, "RegCreateKeyEx failed for %S, error %ld",
                   pszHiveName, dwErr);
        dwReturn = dwErr;
        goto cleanup;       
   }

   dwErr = RegReplaceKey( hLocalKey,
                          NULL,
                          szTempRegCopy,
                          szBackupFile );

   if ( dwErr != ERROR_SUCCESS )
   {
        ErrorTrace(0, "RegReplaceKey failed for %S, error %ld",
                   pszHiveName, dwErr);
        LogDSFileTrace(0,L"File was ", szTempRegCopy);   

        // 
        // last ditch effort - try movefileex
        //
        if (pszSnapshotDir)
        {
            DebugTrace(0, "Trying movefileex");
            dwReturn = SrMoveFileEx(pszSnapshotDir, szTempRegCopy, pszOriginalFile);        
            if (dwReturn != ERROR_SUCCESS)
            {
                ErrorTrace(0, "! SrMoveFileEx : %ld", dwReturn);
                goto cleanup;       
            }            
        }            
        else
        {
            _ASSERT(0);
            // we can't do anything here
        }
   }
   
   dwReturn = ERROR_SUCCESS;
   
cleanup:
   if (NULL != hLocalKey)
   {
       dwErr = RegCloseKey( hLocalKey );
       _ASSERT(ERROR_SUCCESS==dwErr);
   }
   TraceFunctLeave();
   return dwReturn;
}

// this function copies the file - it takes care of the attributes
// (like read only and hidden) which prevent overwrite of the file.
DWORD SnapshotCopyFile(WCHAR * pszSrc,
                       WCHAR * pszDest)
{
    TraceFunctEnter("SnapshotCopyFile");
    
    DWORD   dwErr, dwReturn=ERROR_INTERNAL_ERROR, dwAttr;
    BOOL    fRestoreAttr = FALSE;
    
     // if destination file does not exist, ignore
    if (DoesFileExist(pszDest))
    {
        dwAttr =GetFileAttributes(pszDest);  // name of file or directory
        if (dwAttr == -1)
        {
             // keep going. Maybe the copy will succeed            
            dwErr = GetLastError();
            ErrorTrace(0, "GetFileAttributes failed %d", dwErr);
            LogDSFileTrace(0,L"File was ", pszDest);
        }
        else
        {
             // we need to keep track of which attributes we will restore.
            dwAttr = dwAttr & (FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN|
                               FILE_ATTRIBUTE_NORMAL|
                               FILE_ATTRIBUTE_NOT_CONTENT_INDEXED|
                               FILE_ATTRIBUTE_OFFLINE|FILE_ATTRIBUTE_READONLY|
                               FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_TEMPORARY);
            fRestoreAttr = TRUE;

             // now set the attributes of the destination file to be
             // normal so that we can overwrite this file
            if (!SetFileAttributes( pszDest, // file name
                                    FILE_ATTRIBUTE_NORMAL )) // attributes
            {
                 // keep going. Maybe the copy will succeed            
                dwErr = GetLastError();
                ErrorTrace(0, "SetFileAttributes failed %d", dwErr);
                LogDSFileTrace(0,L"File was ", pszDest);      
            }
        }
    }


    
    dwErr = SRCopyFile(pszSrc, pszDest);
    if (dwErr != ERROR_SUCCESS)
    {
        ErrorTrace(0, "SRCopyFile failed. ec=%d", dwErr);
        LogDSFileTrace(0,L"src= ", pszSrc);
        LogDSFileTrace(0,L"dst= ", pszDest);        
        dwReturn = dwErr;
        goto cleanup;
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    if (TRUE == fRestoreAttr)
    {
         // now restore the attributes of the destination file 
        if (!SetFileAttributes( pszDest, // file name
                                dwAttr )) // attributes
        {
            dwErr = GetLastError();
            ErrorTrace(0, "SetFileAttributes failed %d", dwErr);
            LogDSFileTrace(0,L"File was ", pszDest);      
        }
    }
    
    TraceFunctLeave();
    return dwReturn;
}

// the following function attempts to copy the user profile hives
// (ntuser.dat and usrclass.dat) from the profile path (or vice versa).
// This can fail if the user's profile is in use.
//
// if fRestore is TRUE it  restores the profile
// if fRestore is FALSE it snapshots the profile
DWORD CopyUserProfile(HKEY   hKeyProfileList,
                      WCHAR * pszUserSID,
                      WCHAR * pszSnapshotDir,
                      BOOL    fRestore,
                      WCHAR * pszNTUserPath)
{
    TraceFunctEnter("CopyUserProfile");
    
    DWORD  dwReturn=ERROR_INTERNAL_ERROR, dwErr,dwSize,dwType;
    HKEY   hKeySID = NULL;
    WCHAR  szNTUserPath[MAX_PATH];
    int    cbNTUserPath = 0;
    PWCHAR pszSrc, pszDest;

     // find the ProfileImagePath

     //open the parent key
    dwErr = RegOpenKeyEx(hKeyProfileList,// handle to open key
                         pszUserSID,// subkey name
                         0,// reserved
                         KEY_READ,// security access mask
                         &hKeySID);// handle to open key
    

    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0,"Error %d in opening ProfileList of %S",
                   dwErr, pszUserSID);
        dwReturn = dwErr;
        goto cleanup;
    }

     //now query for the profile image path
    {
        WCHAR  szData[MAX_PATH];
        dwSize = sizeof(szData)/sizeof(WCHAR);
        dwType = REG_EXPAND_SZ;
        
        dwErr = RegQueryValueEx(hKeySID,// handle to key
                                s_cszSnapshotProfileImagePath, // value name
                                NULL, // reserved
                                &dwType, // type buffer
                                (LPBYTE) szData, // data buffer
                                &dwSize);// size of data buffer
        
        if (ERROR_SUCCESS != dwErr)
        {
            ErrorTrace(0,"Error %d in querying Profilepath of %S", dwErr,
                       pszUserSID);
            dwReturn = dwErr;        
            goto cleanup;        
        }
        
        if (0 == ExpandEnvironmentStrings( szData,
                                           szNTUserPath,
                                           sizeof(szNTUserPath)/sizeof(WCHAR)))
        {
            dwErr = GetLastError();
            ErrorTrace(0, "ExpandEnvironmentStrings failed for %S, ec=%d",
                       szData, dwErr);
            if (ERROR_SUCCESS != dwErr)
            {
                dwReturn = dwErr;
            }
            goto cleanup;
        }

        cbNTUserPath = lstrlen(szNTUserPath);
    }
        

    {
        WCHAR  szSnapshotPath[MAX_PATH];
        
         // save off the ntuser.dat into datastore
        lstrcat(szNTUserPath, L"\\");
        lstrcat(szNTUserPath, s_cszSnapshotNTUserDat);
        
        lstrcpy(pszNTUserPath, szNTUserPath);
    
        if (ERROR_SUCCESS!= CreateNTUserDatPath(
            szSnapshotPath,
            sizeof(szSnapshotPath)/sizeof(WCHAR),
            pszSnapshotDir, pszUserSID))
        {
            dwReturn=ERROR_INSUFFICIENT_BUFFER;                
            goto cleanup;
        }
        if (fRestore == TRUE)
        {
            pszSrc=szSnapshotPath;
            pszDest=szNTUserPath;       
        }
        else
        {
            pszSrc=szNTUserPath;
            pszDest=szSnapshotPath;        
        }
        
        
        if (fRestore)
        {
             // 
             // delete current ntuser.dat before putting old one back
             //
            
            if (FALSE == DeleteFile(pszDest))
            {
                ErrorTrace(0, "! DeleteFile on ntuser.dat : %ld", GetLastError());
            }
            else
            {
                DebugTrace(0, "NTuser.dat deleted");
            }
        }
        
        dwErr = SnapshotCopyFile(pszSrc, pszDest);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
            goto cleanup;
        }
        
         // save off the usrclass.dat also into datastore
        szNTUserPath[cbNTUserPath] = L'\0';
        lstrcat(szNTUserPath, L"\\");
        lstrcat(szNTUserPath, s_cszSnapshotUsrClassLocation);
        
        if (ERROR_SUCCESS!= CreateUsrClassPath(
            szSnapshotPath,
            sizeof(szSnapshotPath)/sizeof(WCHAR),
            pszSnapshotDir, pszUserSID))
        {
            dwReturn=ERROR_INSUFFICIENT_BUFFER;                
            goto cleanup;        
        }
        
        if (fRestore == TRUE)
        {
            pszSrc=szSnapshotPath;
            pszDest=szNTUserPath;       
        }
        else
        {
            pszSrc=szNTUserPath;
            pszDest=szSnapshotPath;        
        }
        
        if (fRestore)
        {
             // 
             // delete current usrclass.dat before putting old one back
             //
            
            if (FALSE == DeleteFile(pszDest))
            {
                ErrorTrace(0, "! DeleteFile on usrclass.dat", GetLastError());
            }
            else
            {
                DebugTrace(0, "Usrclass.dat deleted");
            }
        }
        
        dwErr = SnapshotCopyFile(pszSrc, pszDest);
        
        if (ERROR_SUCCESS != dwErr)
        {
             // if we are here and the usrclass file could not be copied,
             // then we can ignore this error since the usrclass file may
             // not exist.
            DebugTrace(0, "UsrClass cannot be copied. ec=%d. Ignoring this error",
                       dwErr);        
             //dwReturn = dwErr;
             //goto cleanup;
        }
    }
    

    dwReturn = ERROR_SUCCESS;
cleanup:
    if (NULL != hKeySID)
    {
        _VERIFY(ERROR_SUCCESS==RegCloseKey(hKeySID));
    }
    TraceFunctLeave();
    return dwReturn;
}

void CreateClassesKeyName( WCHAR * pszKeyName,
                           WCHAR * pszUserSID)
{
    wsprintf(pszKeyName, L"%s%s", pszUserSID, s_cszClassesKey);
}

DWORD ProcessUserRegKeys( WCHAR * pszUserSID,
                          WCHAR * pszSnapshotDir,
                          BOOL    fRestore,
                          WCHAR * pszOriginalFile)
{
    TraceFunctEnter("ProcessUserRegKeys");
    
    DWORD dwErr, dwReturn=ERROR_INTERNAL_ERROR;

    LPWSTR szDest = new WCHAR[MAX_PATH];
    LPWSTR szKeyName = new WCHAR[MAX_PATH];

    if (!szDest || !szKeyName)
    {
        ErrorTrace(0, "Cannot allocate memory");
        dwReturn = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (ERROR_SUCCESS != CreateNTUserDatPath(szDest,
                                             MAX_PATH,
                                             pszSnapshotDir, pszUserSID))
    {
        dwReturn=ERROR_INSUFFICIENT_BUFFER;        
        goto cleanup;
    }
    
    if (FALSE == fRestore)
    {
        dwErr = SaveRegKey(HKEY_USERS, 
                           pszUserSID, // Subkey to save
                           szDest);    // File to save in
    }
    else
    {
        dwErr = SetNewRegistry(HKEY_USERS, // handle to open key
                               pszUserSID, // subkey name
                               szDest,     // snapshot file
                               pszOriginalFile,         // original file
                               pszSnapshotDir);
    }                       
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "SaveRegKey or SetNewRegistry failed ec=%d", dwErr);        
        dwReturn = dwErr;
        goto cleanup;
    }

    if (ERROR_SUCCESS != CreateUsrClassPath(szDest,
                                            MAX_PATH,
                                            pszSnapshotDir, pszUserSID))
    {
        dwReturn=ERROR_INSUFFICIENT_BUFFER;                
        goto cleanup;
    }

    CreateClassesKeyName(szKeyName, pszUserSID);

    if (FALSE == fRestore)
    {    
        dwErr = SaveRegKey(HKEY_USERS, 
                           szKeyName, // Subkey to save
                           szDest);    // File to save in
    }
    else
    {
        dwErr = SetNewRegistry(HKEY_USERS, // handle to open key
                               szKeyName,  // subkey name
                               szDest,   // data file
                               pszOriginalFile,
                               pszSnapshotDir); 
    }                               
    
    if (ERROR_SUCCESS != dwErr)
    {
         // if we are here and the usrclass file could not be copied,
         // then we can ignore this error since the usrclass file may
         // not exist.
        DebugTrace(0, "UsrClass cannot be copied. ec=%d. Ignoring this error",
                   dwErr);
         //dwReturn = dwErr;
         //goto cleanup;        
    }    

    dwReturn = ERROR_SUCCESS;
    
cleanup:
    if (szDest)
        delete [] szDest;
    if (szKeyName)
        delete [] szKeyName;
    
    TraceFunctLeave();
    return dwReturn;
}


// the following function processes the HKeyUsers registry key
// if fRestore is TRUE it restores the registry key
// if fRestore is FALSE it snapshots the registry key
DWORD ProcessHKUsersKey( WCHAR * pszSnapshotDir,
                         IN HKEY hKeyHKLM,// handle to an open key from where
                          // Software\\Microsoft\\ can be read. 
                         BOOL    fRestore)
{
    TraceFunctEnter("ProcessHKUsersKey");
    
    WCHAR       szSID[100];
    DWORD       dwReturn=ERROR_INTERNAL_ERROR, dwErr;
    HKEY        hKeyProfileList = NULL;
    DWORD       dwIndex,dwSize;
    const WCHAR    *  pszProfileSubKeyName;
    
    if (TRUE == fRestore)
    {
         // in this case this is a loaded hive of the system. We need
         // to strip system from the subkey name to bew able to read
         // this subkey.
        pszProfileSubKeyName = s_cszSnapshotProfileList +
            lstrlen(s_cszSoftwareHiveName) + 1;
    }
    else
    {
        pszProfileSubKeyName = s_cszSnapshotProfileList;
    }
    
    // open the ProfileList and enumerate
    dwErr = RegOpenKeyEx( hKeyHKLM,// handle to open key
                          pszProfileSubKeyName,// subkey name
                          0,// subkey name
                          KEY_READ,// security access mask
                          &hKeyProfileList);// handle to open key
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "RegOpenKeyEx failed for ProfileList, error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }

    dwIndex = 0;
    dwSize = sizeof(szSID)/sizeof(WCHAR);
    while (ERROR_SUCCESS == (dwErr = RegEnumKeyEx( hKeyProfileList,
                                                    // handle to key to
                                                    // enumerate
                                                   dwIndex, // subkey index
                                                   szSID,// subkey name
                                                   &dwSize, // size of subkey
                                                    // buffer
                                                   NULL,     // reserved    
                                                   NULL, // class string buffer
                                                   NULL,// size of class
                                                    // string buffer
                                                   NULL)))// last write time
    {
        WCHAR  szOriginalFile[MAX_PATH];        
        LPWSTR pszOriginalFile = NULL;

        DebugTrace(0, "Enumerated Key %S", szSID);
        dwIndex++;
         // try to copy the file - if this fails we will try to save
         // the reg key

        lstrcpy(szOriginalFile, L"");
        dwErr = CopyUserProfile(hKeyProfileList, szSID, pszSnapshotDir,
                                fRestore, szOriginalFile);
        if (ERROR_SUCCESS != dwErr)
        {
            DebugTrace(0, "CopyUserProfile for %S failed. Error %d",
                       szSID, dwErr);
            
             // The copy may have failed since the user profile may be
             // currently loaded - try to use Registry functions for
             // this purpose.

            DebugTrace(0, "Trying registry APIs for  %S", szSID);

            if (0 == lstrcmp(szOriginalFile, L""))
                pszOriginalFile = NULL;
            else
                pszOriginalFile = szOriginalFile;

            dwErr = ProcessUserRegKeys(szSID, pszSnapshotDir, fRestore, pszOriginalFile);
                
            if (ERROR_SUCCESS != dwErr)
            {
                ErrorTrace(0, "Error %d saving key %S - ignoring", dwErr, szSID);

                //
                // ignore error -- if profile was deleted by hand
                // this could happen
                // we will just bravely carry on
                //
            }
        }
        dwSize = sizeof(szSID)/sizeof(WCHAR);        
    }

    {
        WCHAR szDest[MAX_PATH];        
         // also save the .default key
        if (ERROR_SUCCESS != CreateUsrDefaultPath(szDest,
                                                  sizeof(szDest)/sizeof(WCHAR),
                                                  pszSnapshotDir))
        {
            dwReturn=ERROR_INSUFFICIENT_BUFFER;        
            goto cleanup;
        }
        
        if (TRUE == fRestore)
        {
            dwErr = SetNewRegistry(HKEY_USERS, // handle to open key
                                   s_cszSnapshotUsersDefaultKey, // subkey name
                                   szDest, // data file
                                   NULL,
                                   NULL);
        }
        else
        {
            dwErr = SaveRegKey(HKEY_USERS,
                               s_cszSnapshotUsersDefaultKey,
                               szDest);
        }
        
        if (ERROR_SUCCESS != dwErr)
        {
            ErrorTrace(0, "Error processing default key ec=%d", dwErr);
            dwReturn = dwErr;
            
            _ASSERT(0);
            goto cleanup;
        }
    }
        
    dwReturn = ERROR_SUCCESS;
    
cleanup:

    if (NULL != hKeyProfileList)
    {
        _VERIFY(ERROR_SUCCESS==RegCloseKey(hKeyProfileList));
    }
    TraceFunctLeave();
    return dwReturn;
}


// the following function saves or restores a reg hive.
// if fRestore == TRUE it restores the reg hive 
// if fRestore == FALSE it saves the reg hive
DWORD SnapshotRegHive(WCHAR * pszSnapshotDir,
                      WCHAR * pszHiveName)
{
    TraceFunctEnter("SnapshotRegHive");
    
    DWORD  i,dwSnapDirLen, dwHivelen;
    WCHAR  szBackupFile[MAX_PATH];
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    WCHAR  * pszSubhiveName;
    
    
     // first construct the name of the file to store the hive
    wsprintf(szBackupFile, L"%s\\%s", pszSnapshotDir, pszHiveName);
    

     // now replace all \ in the copy of pszHiveName to _
    dwSnapDirLen=lstrlen(pszSnapshotDir)+1; // +1 is for the \\ after
                                            //pszSnapshotDir
    
    dwHivelen = lstrlen(pszHiveName);
    for (i=dwSnapDirLen; i< dwHivelen+ dwSnapDirLen; i++)
    {
        if (szBackupFile[i] == L'\\')
        {
            szBackupFile[i] = L'_';
        }
    }
    
     // figure out if it is the HKLM hive - we already snapshot the HK
     // users hive
    if (0 != _wcsnicmp( pszHiveName, s_cszHKLMPrefix,lstrlen(s_cszHKLMPrefix)))
    {
        DebugTrace(0, "%S is not a HKLM hive", pszHiveName);
        dwReturn = ERROR_SUCCESS;
        goto cleanup;
    }

     // get the hive name
    pszSubhiveName = pszHiveName + lstrlen(s_cszHKLMPrefix);

     // now check to see if the hive is one that we have created
     // ourselves. If so, ignore this hive
    if ( (lstrcmpi(pszSubhiveName,s_cszRestoreSAMHiveName)==0) ||
         (lstrcmpi(pszSubhiveName,s_cszRestoreSYSTEMHiveName)==0) ||
         (lstrcmpi(pszSubhiveName,s_cszRestoreSECURITYHiveName)==0) )
    {
        DebugTrace(0, "Ignoring %S since it a hive created by restore",
                   pszSubhiveName);
        dwReturn = ERROR_SUCCESS;
        goto cleanup;        
    }
    
    dwErr = SaveRegKey(HKEY_LOCAL_MACHINE,
                       pszSubhiveName,
                       szBackupFile);
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "SaveRegKey failed for HiveList, ec=%ld", dwErr);
        // now check to see if this is a well known HKLM hive. If not, ignore any errors in 
        // snapshotting this hive
        if (FALSE==IsWellKnownHKLMHive(pszSubhiveName))
        {
        	dwReturn=ERROR_SUCCESS;
        }
        else
        {
            dwReturn = dwErr;
        }
        goto cleanup;
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
     // call reg save key on this
    TraceFunctLeave();
    return dwReturn;
}




// the following function does processing of the HKLM key. It does it
// by reading the hives listed in the reg key
// System\\CurrentControlSet\\Control\\Hivelist. It ignores the Users
// subkeys.
DWORD DoHKLMSnapshot(IN WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("DoHKLMSnapshot");
    
    DWORD dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    HKEY         hKeyHiveList=NULL;
    WCHAR        szHiveName[MAX_PATH], szDataValue[MAX_PATH];
    DWORD        dwSize, dwValueIndex, dwDataSize;
    
    const WCHAR    *   pszHiveSubKeyName;

       // open the ProfileList and enumerate
    dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,// handle to open key
                          s_cszSnapshotHiveList,// Subkey name
                          0,// options
                          KEY_READ,// security access mask
                          &hKeyHiveList);// handle to open key
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "RegOpenKeyEx failed for HiveList, ec=%ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }

    for (dwValueIndex = 0; TRUE; dwValueIndex ++)
    {
        dwSize = sizeof(szHiveName)/sizeof(WCHAR);
        dwDataSize = sizeof(szDataValue); // this is in bytes
        
        dwErr= RegEnumValue(hKeyHiveList, // handle to key to query
                            dwValueIndex, // index of value to query
                            szHiveName, // value buffer
                            &dwSize,     // size of value buffer
                            NULL,    // reserved
                            NULL,    // type buffer
                            (PBYTE)szDataValue,    // data buffer
                            &dwDataSize);   // size of data buffer

        if (ERROR_SUCCESS != dwErr)
        {
            _ASSERT(ERROR_NO_MORE_ITEMS == dwErr);
            break;
        }
         // if the hive does not have a data file, do not back it up. 
        if (lstrlen(szDataValue) == 0)
        {
            DebugTrace(0, "There is no data for hive %S. Ignoring",
                       szHiveName);
            continue;
        }
        
        dwErr = SnapshotRegHive(pszSnapshotDir, szHiveName);
        
        if (ERROR_SUCCESS != dwErr)
        {
            ErrorTrace(0, "Processing failed for Hive %S, ec=%ld",
                       szHiveName, dwErr);
            dwReturn = dwErr;
            goto cleanup;
        }
    }
    
    dwReturn = ERROR_SUCCESS;
cleanup:
    if (NULL != hKeyHiveList)
    {
        _VERIFY(ERROR_SUCCESS==RegCloseKey(hKeyHiveList));
    }
    TraceFunctLeave();
    return dwReturn;
}


     
DWORD 
CSnapshot::DoRegistrySnapshot(WCHAR * pszSnapshotDir)
{
    DWORD       dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    
    TraceFunctEnter("CSnapshot::DoRegistrySnapshot");

    dwErr = ProcessHKUsersKey(pszSnapshotDir, HKEY_LOCAL_MACHINE,
                              FALSE); // need to do a snapshot
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "DoHKUsersSnapshot failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }


    // now snapshot other hives also
    dwErr = DoHKLMSnapshot(pszSnapshotDir);
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "DoHKLMSnapshot failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;        
    }

    dwReturn = ERROR_SUCCESS;

cleanup:
    
    TraceFunctLeave();    
    return dwReturn;
}


DWORD CSnapshot::GetCOMplusBackupFN(HMODULE hCOMDll)
{
    TraceFunctEnter("CSnapshot::GetCOMplusBackupFN");
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;

    if (NULL == hCOMDll)
    {    
        goto cleanup;
    }

     // now get the address of the Backup functions
     m_pfnRegDbBackup = (PF_REG_DB_API)GetProcAddress(hCOMDll,
                                                      s_cszRegDBBackupFn);
     if (NULL == m_pfnRegDbBackup)
     {
         dwErr = GetLastError();
         ErrorTrace(0, "Error getting function RegDBBackup. ec=%d", dwErr);
         if (ERROR_SUCCESS != dwErr)
         {
             dwReturn = dwErr;
         }
        goto cleanup;
     }

     dwReturn= ERROR_SUCCESS;
     
cleanup:
    TraceFunctLeave();
    return dwReturn;
}

DWORD CSnapshot::GetCOMplusRestoreFN()
{
    TraceFunctEnter("CSnapshot::GetCOMplusRestoreFN");
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;

     // first load the COM+ dll
    if (NULL == m_hRegdbDll)
    {    
        m_hRegdbDll = LoadLibrary(s_cszCOMDllName);    
        if (NULL == m_hRegdbDll)
        {                       
            dwReturn = GetLastError();
            trace(0, "LoadLibrary of %S failed ec=%d", s_cszCOMDllName, dwReturn);
            goto cleanup;
        }  
    }

     // now get the address of the Backup functions
     m_pfnRegDbRestore = (PF_REG_DB_API)GetProcAddress(m_hRegdbDll,
                                                       s_cszRegDBRestoreFn);
     if (NULL == m_pfnRegDbRestore)
     {
         dwErr = GetLastError();
         ErrorTrace(0, "Error getting function RegDBRestore. ec=%d", dwErr);
         if (ERROR_SUCCESS != dwErr)
         {
             dwReturn = dwErr;
         }
        goto cleanup;
     }

     dwReturn= ERROR_SUCCESS;
     
cleanup:
    TraceFunctLeave();
    return dwReturn;
}


void CreateCOMDBSnapShotFileName( WCHAR * pszSnapshotDir,
                                  WCHAR * pszCOMDBFile )
{
    wsprintf(pszCOMDBFile, L"%s\\%s", pszSnapshotDir, s_cszCOMDBBackupFile);
    return;
}



DWORD
CSnapshot::DoCOMDbSnapshot(WCHAR * pszSnapshotDir, HMODULE hCOMDll)
{
    TraceFunctEnter("CSnapshot::DoCOMDbSnapshot");
    
    DWORD dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    HMODULE   hModCOMDll=NULL;
    HRESULT   hr;
    WCHAR     szCOMDBFile[MAX_PATH];

    
    if (NULL == m_pfnRegDbBackup)
    {
        dwErr = GetCOMplusBackupFN(hCOMDll);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
            goto cleanup;
        }
    }

     // construct the path of the database backup file
    CreateCOMDBSnapShotFileName(pszSnapshotDir, szCOMDBFile);
    
    hr =m_pfnRegDbBackup( szCOMDBFile );
    
     // call the function to backup the file
    if ( FAILED(hr))
    {
        ErrorTrace(0, "Failed to snapshot COM DB. hr=0x%x", hr);
        goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
    TraceFunctLeave();
    return dwReturn;
}

void CreateWMISnapShotFileName( WCHAR * pszSnapshotDir,
                                WCHAR * pszWMIBackupFile )
{
    wsprintf(pszWMIBackupFile, L"%s\\%s", pszSnapshotDir,
             s_cszWMIBackupFile);
    return;
}

DWORD DoWMISnapshot(VOID * pParam)
{
    TraceFunctEnter("DoWMISnapshot");
    
    WMISnapshotParam * pwsp = (WMISnapshotParam *) pParam;
    DWORD dwErr = ERROR_SUCCESS;
    HRESULT   hr = S_OK;
    WCHAR     szWMIBackupFile[MAX_PATH];
    WCHAR     szWMIRepository[MAX_PATH];
    IWbemBackupRestoreEx *wbem ;    
    BOOL fCoInitialized = FALSE;
    CTokenPrivilege tp;
    BOOL      fHaveLock = FALSE;
    BOOL      fSerialized = TRUE;

    if (NULL == pwsp)
    {
        ErrorTrace(0, "pwsp=NULL");
        TraceFunctLeave();
        dwErr = ERROR_INVALID_PARAMETER;
        return dwErr;
    }
   
    fSerialized = pwsp->fSerialized;
 
    dwErr = tp.SetPrivilegeInAccessToken(SE_BACKUP_NAME);
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "SetPrivilegeInAccessToken failed ec=%d", dwErr);
        dwErr = ERROR_PRIVILEGE_NOT_HELD;
        goto cleanup;
    }

    hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if (hr == RPC_E_CHANGED_MODE)
    {
        //
        // someone called it with other mode
        //

        hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    }

    if (FAILED(hr))
    {
        dwErr = (DWORD) hr;
        ErrorTrace(0, "! CoInitializeEx : %ld", dwErr);
        goto cleanup;
    }

    fCoInitialized = TRUE;

     // construct the path of the database backup file
    CreateWMISnapShotFileName(pwsp->szSnapshotDir, szWMIBackupFile);

    GetSystemDirectory (szWMIRepository, MAX_PATH);
    lstrcatW (szWMIRepository, L"\\Wbem\\Repository");
    
    if ( SUCCEEDED(CoCreateInstance( CLSID_WbemBackupRestore,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWbemBackupRestoreEx,
                                   (LPVOID*)&wbem )) )
    {
        if (FAILED(hr = CoSetProxyBlanket (wbem,
                         RPC_C_AUTHN_DEFAULT,
                         RPC_C_AUTHZ_DEFAULT,
                         COLE_DEFAULT_PRINCIPAL,
                         RPC_C_AUTHN_LEVEL_CONNECT,
                         RPC_C_IMP_LEVEL_IMPERSONATE,
                         NULL,
                         EOAC_DYNAMIC_CLOAKING)))
        {
            TRACE(0, "CoSetProxyBlanket failed ignoring %x ", hr);
        }
 
        if (SUCCEEDED(hr = wbem->Pause()))
        {
            // signal to main thread that pause is done
            
            if (pwsp->hEvent != NULL)
            {
                SetEvent (pwsp->hEvent);
            }

            // get the datastore lock

            if (g_pEventHandler)
            {
                fHaveLock = g_pEventHandler->GetLock()->Lock(CLock::TIMEOUT);
                if (! fHaveLock)
                {
                    trace(0, "Cannot get lock");
                    dwErr = ERROR_INTERNAL_ERROR;
                    wbem->Resume();
                    wbem->Release();
                    goto cleanup;
                }
            }

            // do the main wmi snapshotting

            if (FALSE == CreateDirectoryW (szWMIBackupFile, NULL))
            {
                dwErr = GetLastError();
                if (ERROR_ALREADY_EXISTS != dwErr)
                {
                    ErrorTrace(0, "Failed to create repository dir. LastError=%d", dwErr);
                }
                else dwErr = ERROR_SUCCESS;
            }

            if (ERROR_SUCCESS == dwErr)
                dwErr = CopyFile_Recurse (szWMIRepository, szWMIBackupFile);

            hr = wbem->Resume();
            if ( FAILED(hr))
            {
                ErrorTrace(0, "Failed to resume WMI DB. ignoring hr=0x%x", hr);
            }
        }
        else
        {
            ErrorTrace(0, "Failed to pause WMI DB. ignoring hr=0x%x", hr);

            // signal to main thread anyway
            
            if (pwsp->hEvent != NULL)
            {
                SetEvent (pwsp->hEvent);
            }

            if (g_pEventHandler)
            {
                fHaveLock = g_pEventHandler->GetLock()->Lock(CLock::TIMEOUT);
                if (! fHaveLock)
                {
                    trace(0, "Cannot get lock with WMI Pause failed");
                    dwErr = ERROR_INTERNAL_ERROR;
                    wbem->Release();
                    goto cleanup;
                }
            }
        }
        wbem->Release() ;
    }

cleanup:

    if (pwsp->hEvent != NULL)
    {
        CloseHandle (pwsp->hEvent);
        pwsp->hEvent = NULL;
    }

    if (fCoInitialized)
        CoUninitialize();

    // now calculate accurate complete size of old restore point 
    // and snapshot size of current restore point
    
    if (g_pDataStoreMgr && fHaveLock)
    {        
        dwErr = g_pDataStoreMgr->GetDriveTable()->
                ForAllDrives(&CDataStore::SwitchRestorePoint, 
                         (LONG_PTR) pwsp->pRpLast);
        if (dwErr != ERROR_SUCCESS)
        {
            trace(0, "! SwitchRestorePoint : %ld", dwErr);
        }
        
        // if this is parallelized, then check fifo conditions here
        // else check it in SRSetRestorePointS

        if (! pwsp->fSerialized)
        {
            g_pDataStoreMgr->TriggerFreezeOrFifo();
        }
    }

    if (pwsp)
    {
        if (pwsp->pRpLast)
            delete pwsp->pRpLast;
        delete pwsp;
        pwsp = NULL;
        trace(0, "DoWMISnapshot released pwsp");
    }

    // release the datastore lock

    if (fHaveLock)
    {
        if (g_pEventHandler)
            g_pEventHandler->GetLock()->Unlock();
    }

    if (! fSerialized && g_pEventHandler)
        g_pEventHandler->GetCounter()->Down();

    TraceFunctLeave();
    return dwErr;
}

DWORD RestoreWMISnapshot(WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("RestoreWMISnapshot");
    
    IWbemBackupRestoreEx *wbem = NULL;    
    DWORD dwErr = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    BOOL  fPaused = FALSE;
    WCHAR     szWMIBackupFile[MAX_PATH];
    WCHAR     szWMIRepository[MAX_PATH];
    WCHAR     szWMITemp[MAX_PATH];
    CTokenPrivilege tp;

     // construct the path of the database backup file
    CreateWMISnapShotFileName(pszSnapshotDir, szWMIBackupFile);
    
    GetSystemDirectory (szWMIRepository, MAX_PATH);
    lstrcpyW (szWMITemp, szWMIRepository);
 
    lstrcatW (szWMIRepository, L"\\Wbem\\Repository");
    lstrcatW (szWMITemp, L"\\Wbem\\Repository.tmp");

    Delnode_Recurse (szWMITemp, TRUE, NULL);  // delete previous temp dirs
    if (FALSE == CreateDirectoryW (szWMITemp, NULL))
    {
        dwErr = GetLastError();
        if (dwErr != ERROR_ALREADY_EXISTS)
        {
            ErrorTrace(0, "Failed to create WMI temp dir. Ignoring error=0x%x", dwErr);
            dwErr = ERROR_SUCCESS;
            goto cleanup;
        }
        dwErr = ERROR_SUCCESS;
    }

    dwErr = CopyFile_Recurse (szWMIBackupFile, szWMITemp);
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "Failed CopyFile_Recurse. Ignoring error=0x%x", dwErr);
        dwErr = ERROR_SUCCESS;
        Delnode_Recurse (szWMITemp, TRUE, NULL);
        goto cleanup;
    }

    lstrcpyW (szWMIBackupFile, szWMIRepository);
    lstrcatW (szWMIBackupFile, L".bak");

    // If WMI is still running, try to stop it
    if ( SUCCEEDED(hr = CoCreateInstance( CLSID_WbemBackupRestore,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWbemBackupRestoreEx,
                                   (LPVOID*)&wbem )) )
    {
        tp.SetPrivilegeInAccessToken(SE_BACKUP_NAME);
        fPaused = SUCCEEDED(hr = wbem->Pause());
        if (FAILED(hr))
            TRACE(0, "Wbem Pause failed ignoring %x", hr);
    }
    else
    {
        TRACE(0, "CoCreateInstance failed ignoring %x", hr);
    }

    Delnode_Recurse (szWMIBackupFile, TRUE, NULL);  // delete leftover backups
    if (FALSE == MoveFile(szWMIRepository, szWMIBackupFile))
    {
        dwErr = GetLastError();
        ErrorTrace(0, "! MoveFile : %ld trying SrMoveFileEx", dwErr);

        // WMI has locked files, so try SrMoveFileEx
        dwErr = SrMoveFileEx(pszSnapshotDir, szWMIRepository, szWMIBackupFile);
        if (ERROR_SUCCESS == dwErr)
        {
            dwErr = SrMoveFileEx(pszSnapshotDir, szWMITemp, szWMIRepository);
            if (ERROR_SUCCESS != dwErr)
                ErrorTrace(0, "! SRMoveFileEx : %ld", dwErr);
        }
        else
        {
            ErrorTrace(0, "! SRMoveFileEx : %ld", dwErr);
            Delnode_Recurse (szWMITemp, TRUE, NULL);
        }
        goto cleanup;
    }

    if (FALSE == MoveFile(szWMITemp, szWMIRepository))
    {
        dwErr = GetLastError();
        ErrorTrace(0, "! MoveFile : %ld", dwErr);
        goto cleanup;
    }

    Delnode_Recurse (szWMIBackupFile, TRUE, NULL);

cleanup:

    if (wbem != NULL)
    {
        if (fPaused)
            wbem->Resume();
        wbem->Release();
    }

    TraceFunctLeave();
    return dwErr;
}


DWORD DoIISSnapshot(WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("DoIISSnapshot");
    
    DWORD           dwReturn=ERROR_INTERNAL_ERROR;
    HRESULT         hr;
    WCHAR           szRestorePath[MAX_PATH], szBackup[MAX_PATH], szTemp[MAX_PATH];
    IMSAdminBase2W  *pims = NULL;    
    
     // construct the path of the database backup file
    wsprintf(szRestorePath, L"%s\\%s", pszSnapshotDir, s_cszIISBackupFile);

    hr = CoCreateInstance( CLSID_MSAdminBase_W,
                                   NULL,
                                   CLSCTX_ALL,
                                   IID_IMSAdminBase2_W,
                                   (LPVOID*)&pims);
    if (FAILED(hr))                                   
    {
        ErrorTrace(0, "! CoCreateInstance : 0x%x - ignoring error", hr);
        dwReturn = ERROR_SUCCESS;
        goto cleanup;    
    }

    hr = pims->BackupWithPasswd(s_cszIISBackupFile,
                                MD_BACKUP_MAX_VERSION,
                                MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST | MD_BACKUP_FORCE_BACKUP,
                                NULL); 
    pims->Release() ;

    if (FAILED(hr))
    {
        ErrorTrace(0, "! BackupWithPasswd : 0x%x", hr);
        dwReturn = (DWORD) hr;
        goto cleanup;
    }

    //
    // move the file from their backup to our backup
    //
    
    if (0 == ExpandEnvironmentStrings(s_cszIISBackupPath, szTemp, MAX_PATH))
    {
        dwReturn = GetLastError();
        ErrorTrace(0, "! ExpandEnvironmentStrings : %ld", dwReturn);
        goto cleanup;
    }
    wsprintf(szBackup, L"%s%s%s%d", szTemp, s_cszIISBackupFile, s_cszIISSuffix, MD_BACKUP_MAX_VERSION);
    
    if (FALSE == MoveFile(szBackup, szRestorePath))
    {
        dwReturn = GetLastError();
        ErrorTrace(0, "! MoveFile : %ld", dwReturn);
        goto cleanup;
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
    TraceFunctLeave();
    return dwReturn;
}


DWORD RestoreIISSnapshot(WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("RestoreIISSnapshot");
    
    DWORD           dwReturn=ERROR_INTERNAL_ERROR;
    HRESULT         hr;
    WCHAR           szRestorePath[MAX_PATH], szDest[MAX_PATH];
    IMSAdminBase2W  *pims = NULL;    
    
     // construct the path of the database backup file

    wsprintf(szRestorePath, L"%s\\%s", pszSnapshotDir, s_cszIISBackupFile);

    //
    // if we don't have the file
    // there is nothing to restore 
    //

    if (0xFFFFFFFF == GetFileAttributes(szRestorePath))
    {
        DebugTrace(0, "IIS snapshot does not exist");
        dwReturn = ERROR_SUCCESS;
        goto cleanup;
    }    
    
    //
    // copy the file from our backup to their original location -
    // we can do a simple copy here because IIS should be shutdown
    // at this time
    //
    
    if (0 == ExpandEnvironmentStrings(s_cszIISOriginalPath, szDest, MAX_PATH))
    {
        dwReturn = GetLastError();
        ErrorTrace(0, "! ExpandEnvironmentStrings : %ld", dwReturn);
        goto cleanup;
    }
    
    if (ERROR_SUCCESS != (dwReturn = SnapshotCopyFile(szRestorePath, szDest)))
    {
        ErrorTrace(0, "! SnapshotCopyFile : %ld", dwReturn);
        goto cleanup;
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
    TraceFunctLeave();
    return dwReturn;
}


DWORD
SnapshotRestoreFilelistFiles(LPWSTR pszSnapshotDir, BOOL fSnapshot)
{
    TraceFunctEnter("SnapshotRestoreFilelistFiles");
    
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   dwIndex, dwDataSize, dwSize;
    LPWSTR  pszFilePart = NULL ;
    HKEY    hKey = NULL;
    BOOL    fLoaded = FALSE;
    
    if (fSnapshot == FALSE)  // restore
    {
        //
        // load the software hive of the registry to be restored
        //
        
        WCHAR szSoftwareHive[MAX_PATH];        
        
        wsprintf(szSoftwareHive, 
                 L"%s\\%s%s", 
                 pszSnapshotDir, 
                 s_cszHKLMFilePrefix, 
                 s_cszSoftwareHiveName);
        
        CHECKERR( RegLoadKey(HKEY_LOCAL_MACHINE,
                             LOAD_KEY_NAME,
                             szSoftwareHive),
                  L"RegLoadKey" ); 

        fLoaded = TRUE;                    
    }



    {
        WCHAR   szCallbacksKey[MAX_PATH];        
        
        wsprintf(szCallbacksKey,
                 L"%s\\%s\\%s", 
                 fSnapshot ? L"Software" : LOAD_KEY_NAME, 
                 s_cszSRRegKey2, s_cszCallbacksRegKey);        
        
        DebugTrace(0, "CallbacksKey=%S", szCallbacksKey);

        //
        // call registered snapshot callbacks
        //

        dwErr = CallSnapshotCallbacks(szCallbacksKey, pszSnapshotDir, fSnapshot);
        if (dwErr != ERROR_SUCCESS)
        {
            ErrorTrace(0, "! CallSnapshotCallbacks : %ld - ignoring", dwErr);
        }
    }


    {
        WCHAR   szSnapshotKey[MAX_PATH];        
        
        wsprintf(szSnapshotKey, 
                 L"%s\\%s\\%s", 
                 fSnapshot ? L"Software" : LOAD_KEY_NAME, 
                 s_cszSRRegKey2, s_cszSRSnapshotRegKey);

        DebugTrace(0, "SnapshotFilesKey=%S", szSnapshotKey);
        
        dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             szSnapshotKey, 
                             0,
                             KEY_READ,
                             &hKey);
        if (dwErr != ERROR_SUCCESS) // assume key does not exist
        {
            dwErr = ERROR_SUCCESS;
            DebugTrace(0, "No filelist files to snapshot/restore");
            goto Err;
        }
    }              

    
    for (dwIndex = 0; TRUE; dwIndex ++)
    {
        WCHAR szValue[MAX_PATH], szDest[MAX_PATH], szFile[MAX_PATH];
        
        dwSize = sizeof(szValue)/sizeof(WCHAR);
        dwDataSize = sizeof(szFile); // this is in bytes
        
        dwErr = RegEnumValue(hKey, // handle to key to query
                            dwIndex, // index of value to query
                            szValue, // value buffer
                            &dwSize,     // size of value buffer
                            NULL,    // reserved
                            NULL,    // type buffer
                            (PBYTE) szFile,    // data buffer
                            &dwDataSize);   // size of data buffer                            
        if (ERROR_SUCCESS != dwErr)
        {        
            break;
        }
        
        if (lstrlen(szFile) == 0)
        {
            continue;
        }

        //
        // construct snapshot file path
        // make a unique name for it by appending the enum index
        //

        pszFilePart = wcsrchr(szFile, L'\\');
        if (pszFilePart)
        {
            pszFilePart++;
        }
        else
        {
            pszFilePart = szFile;
        }
        
        wsprintf(szDest, L"%s\\%s-%d", pszSnapshotDir, pszFilePart, dwIndex);

        //
        // copy the file
        // if file does not exist, keep going
        //
        
        if (fSnapshot)  // from orig location to snapshot dir
        {
            SnapshotCopyFile(szFile, szDest);
        }
        else            // from snapshot dir to orig location
        {
            SnapshotCopyFile(szDest, szFile);
        }        
    }

    if (ERROR_NO_MORE_ITEMS == dwErr)
    {
        dwErr = ERROR_SUCCESS;
    }
    else
    {
        ErrorTrace(0, "! RegEnumValue : %ld", dwErr);
    }
    
Err:
    if (hKey)
        RegCloseKey(hKey);

    if (fLoaded)
        RegUnLoadKey( HKEY_LOCAL_MACHINE, LOAD_KEY_NAME );
        
    TraceFunctLeave();
    return dwErr;
}


DWORD CTokenPrivilege::SetPrivilegeInAccessToken(WCHAR * pszPrivilegeName)
{
    TraceFunctEnter("CSnapshot::SetPrivilegeInAccessToken");
    
    HANDLE           hProcess;
    HANDLE           hAccessToken=NULL;
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;   // enough for 1 priv
    DWORD            dwErr = ERROR_SUCCESS;
    
    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        dwErr = GetLastError();
        ErrorTrace(0, "GetCurrentProcess failed ec=%d", dwErr);
        goto done;
    }

    //
    // If there is a thread token, attempt to use it first
    //
    if (!OpenThreadToken (GetCurrentThread(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          TRUE, // check against process's security context
                          &hAccessToken))
    {
        if (!OpenProcessToken(hProcess,
                          TOKEN_DUPLICATE | TOKEN_QUERY,
                          &hAccessToken))
        {
            dwErr=GetLastError();
            ErrorTrace(0, "OpenProcessToken failed ec=%d", dwErr);
            goto done;
        }

        HANDLE hNewToken;  // dup the process token to workaround RPC problem

        if (FALSE == DuplicateTokenEx (hAccessToken,
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY | TOKEN_IMPERSONATE,
                     NULL, SecurityImpersonation, 
                     TokenImpersonation, &hNewToken))
        {
            dwErr=GetLastError();
            ErrorTrace(0, "DuplicateTokenEx failed ec=%d", dwErr);
            goto done;
        }

        CloseHandle (hAccessToken);  // close the old process token
        hAccessToken = hNewToken;    // use the new thread token

        if (TRUE == SetThreadToken (NULL, hAccessToken))
        {
            m_fNewToken = TRUE;
        }
        else
        {
            dwErr = GetLastError();
            ErrorTrace(0, "SetThreadToken failed ec=%d", dwErr);
            goto done;
        }
    }

    if (!LookupPrivilegeValue(NULL,
                              pszPrivilegeName,
                              &luidPrivilegeLUID))
    {
        dwErr=GetLastError();        
        ErrorTrace(0, "LookupPrivilegeValue failed ec=%d",dwErr);
        goto done;
    }

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hAccessToken,
                               FALSE,  // Do not disable all
                               &tpTokenPrivilege,
                               sizeof(TOKEN_PRIVILEGES),
                               NULL,   // Ignore previous info 
                               NULL))  // Ignore previous info
    {
        dwErr=GetLastError();
        ErrorTrace(0, "AdjustTokenPrivileges %ld", dwErr);
        goto done;
    }

    dwErr = ERROR_SUCCESS;

done:
    if (hAccessToken != NULL)
    {
        _VERIFY(TRUE==CloseHandle(hAccessToken));
    }
    
    TraceFunctLeave();
    return dwErr;
}

void RemoveReliabilityKey(WCHAR * pszSoftwareHive)
{
    HKEY   LocalKey = NULL;
    DWORD       dwStatus, disposition;
    
    dwStatus = RegLoadKey( HKEY_LOCAL_MACHINE,
                           LOAD_KEY_NAME,
                           pszSoftwareHive);
    
    if ( ERROR_SUCCESS == dwStatus )
    {
        
         /*
          * Open the reliability key
          */
        
        dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                   LOAD_KEY_NAME TEXT("\\Microsoft\\Windows\\CurrentVersion\\Reliability"),
                                   0,
                                   NULL,
                                   REG_OPTION_BACKUP_RESTORE,
                                   MAXIMUM_ALLOWED,
                                   NULL,
                                   &LocalKey,
                                   &disposition );
        
        if ( ERROR_SUCCESS == dwStatus )
        {
            RegDeleteValue( LocalKey, TEXT("LastAliveStamp") ) ;
            RegCloseKey( LocalKey ) ;
        }
        
        RegFlushKey( HKEY_LOCAL_MACHINE );
        RegUnLoadKey( HKEY_LOCAL_MACHINE, LOAD_KEY_NAME );
    }
}


DWORD CopyHKLMHiveForRestore(WCHAR * pszSnapshotDir, // Directory where
                              // snapshot files are kept
                             const WCHAR * pszRegBackupFile)
                                // Registry backup file
{
    TraceFunctEnter("CopyHKLMHiveForRestore");
    
    DWORD dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR    szDataFile[MAX_PATH], szBackupFile[MAX_PATH];

    if (IsRestoreCopy(pszRegBackupFile))
    {
        DebugTrace(0,"%S is already a backup file. Ignoring",pszRegBackupFile);
        dwReturn = ERROR_SUCCESS;
        goto cleanup;        
    }

/*
    // if patch file, ignore

    if (lstrcmpi(pszRegBackupFile + lstrlen(pszRegBackupFile) - lstrlen(s_cszPatchExtension), s_cszPatchExtension) != NULL)
    {
        DebugTrace(0, "%S is a patch file. Ignoring", pszRegBackupFile);
        dwReturn = ERROR_SUCCESS;
        goto cleanup;
    }
 */
 
     // construct the path name of the datafile 
    wsprintf(szDataFile, L"%s\\%s", pszSnapshotDir, pszRegBackupFile);

     // construct the path name of the backup file
    wsprintf(szBackupFile, L"%s\\%s%s", pszSnapshotDir, pszRegBackupFile,
             s_cszRegHiveCopySuffix);    

    dwErr = SnapshotCopyFile(szDataFile, szBackupFile);
    
    if (ERROR_SUCCESS != dwErr)
    {
        dwReturn = dwErr;
        goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
cleanup:
    TraceFunctLeave();
    return dwReturn;
}

DWORD RestoreHKLMHive(WCHAR * pszSnapshotDir, // Directory where
                                              // snapshot files are kept
                      const WCHAR * pszRegBackupFile)  // Registry backup file 
{
    TraceFunctEnter("RestoreHKLMHive");
    
    DWORD dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwDisposition, dwHiveNameLength;
    WCHAR  szHiveName[MAX_PATH];
    WCHAR    szDataFile[MAX_PATH];

     // first ignore anything with a . in it. This is because a
     // valid HKLM hive file will not have a . in it. 
    if (wcschr(pszRegBackupFile, L'.'))
    {
        dwReturn = ERROR_SUCCESS;
        goto cleanup;
    }
    
     // construct the Hive name
     //  1. copy everything after the HKLM prefix into the buffer
    lstrcpy(szHiveName,
            pszRegBackupFile+ lstrlen(s_cszHKLMPrefix));
     //  2. now NULL terminate where the RestoreCopySuffix starts
    dwHiveNameLength = lstrlen(szHiveName) - lstrlen(s_cszRegHiveCopySuffix);
    szHiveName[dwHiveNameLength] = L'\0';
    

     // construct the path name of the datafile and the backup file
    wsprintf(szDataFile, L"%s\\%s", pszSnapshotDir, pszRegBackupFile);

    if (0==lstrcmpi(szHiveName, s_cszSoftwareHiveName))
    {
         // if this is the software key then the LastAliveStamp must
         // be deleted
        RemoveReliabilityKey(szDataFile);
    }
    dwErr = SetNewRegistry(HKEY_LOCAL_MACHINE, // handle to open key
                           szHiveName,  // subkey name
                           szDataFile, // data file
                           NULL,
                           NULL);

    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "SetNewRegistry failed for %S, error %ld, file %S",
                   szHiveName, dwErr, pszRegBackupFile);
        // now check to see if this is a well known HKLM hive. If not,
        // ignore any errors in restoring this hive
        if (FALSE==IsWellKnownHKLMHive(szHiveName))
        {
        	dwReturn=ERROR_SUCCESS;
        }
        else
        {
            dwReturn = dwErr;
        }
        goto cleanup;
    }


    dwReturn = ERROR_SUCCESS;
    
cleanup:

    TraceFunctLeave();
    return dwReturn;
}


// the following loads the HKLM hive stored in the pszSnapshotDir
// in a temprary place.
DWORD LoadTempHKLM(IN  WCHAR * pszSnapshotDir,
                   IN  const WCHAR * pszHKLMHiveFile,
                   OUT HKEY  * phKeyTempHKLM)
{
    TraceFunctEnter("LoadTempHKLM");
    
    DWORD   dwErr, dwDisposition, i, dwResult=ERROR_INTERNAL_ERROR;

    *phKeyTempHKLM = NULL;
    
    dwErr = RegLoadKey( HKEY_LOCAL_MACHINE,// handle to open key
                        s_cszRestoreTempKey,// subkey name
                        pszHKLMHiveFile);// registry file name
    
    if (  ERROR_SUCCESS != dwErr )
    {
        ErrorTrace(0, "Failed ::RegLoadKey('%S') ec=%d",
                   pszHKLMHiveFile, dwErr);
        dwResult= dwErr;
        goto cleanup;
    }

     // this is how to unload the above hive
     // RegUnLoadKey( HKEY_LOCAL_MACHINE, s_cszRestoreTempKey);
    

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,// handle to open key
                         s_cszRestoreTempKey,// subkey name
                         0,// reserved
                         KEY_WRITE|KEY_READ,// security access mask
                         phKeyTempHKLM);// handle to open key
    

    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0,"Error %d in opening base key %S",
                   dwErr, s_cszRestoreTempKey);
        _VERIFY(ERROR_SUCCESS == RegUnLoadKey( HKEY_LOCAL_MACHINE,
                                               s_cszRestoreTempKey));
        dwResult= dwErr;        
        goto cleanup;
    }

    dwResult = ERROR_SUCCESS;
    
cleanup:

    TraceFunctLeave();
    return dwResult;
}


DWORD
CSnapshot::RestoreRegistrySnapshot(WCHAR * pszSnapshotDir)
{

    DWORD       dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    HKEY        hKeyTempHKLM=NULL;
    WCHAR       szHKLMHiveCopy[MAX_PATH], szHKLMHive[MAX_PATH];
    WCHAR       szHKLMPrefix[MAX_PATH];
    CTokenPrivilege tp;
    
    
    
    TraceFunctEnter("CSnapshot::RestoreRegistrySnapshot");

    dwErr = tp.SetPrivilegeInAccessToken(SE_RESTORE_NAME);
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "SetPrivilegeInAccessToken failed ec=%d", dwErr);
        dwReturn = ERROR_PRIVILEGE_NOT_HELD;
        goto cleanup;
    }

     // now create the path of the HKLM software hive.

     // first construct the name of the file that stores the HKLM registry
     // snapshot.
    wsprintf(szHKLMHive,L"%s\\%s%s", pszSnapshotDir, s_cszHKLMFilePrefix,
             s_cszSoftwareHiveName);

     // to restore the user profiles, we need to first load the HKLM
     // hive in a temporary place so that we can read the profile paths.
    
     // copy this hive  a temporary file
    wsprintf(szHKLMHiveCopy, L"%s.backuphive", szHKLMHive);

    DeleteFile(szHKLMHiveCopy); // delete it if it already exists    
  
    if (! CopyFile(szHKLMHive, szHKLMHiveCopy, FALSE))
    {
        dwErr = GetLastError();
        ErrorTrace(0, "CopyFile failed. ec=%d", dwErr);

        LogDSFileTrace(0,L"src= ", szHKLMHive);
        LogDSFileTrace(0,L"dst= ", szHKLMHiveCopy);
        
        if (ERROR_SUCCESS!= dwErr)
        {
            dwReturn = dwErr;
        }
        goto cleanup;
    }

    dwErr = LoadTempHKLM(pszSnapshotDir, szHKLMHiveCopy, &hKeyTempHKLM);

    if (ERROR_SUCCESS != dwErr)
    {
         // could not load hKeyTempHKLM - fatal error
        dwReturn = dwErr;
        ErrorTrace(0, "LoadTempHKLM failed");
        goto cleanup;
    }


    // need to copy back ntuser.dat for each user        
    dwErr = ProcessHKUsersKey(pszSnapshotDir,
                              hKeyTempHKLM,
                              TRUE); // need to do a restore - not a snapshot
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "DoHKUsersSnapshot failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }

     // first construct the prefix of the files that store the HKLM registry
     // snapshot.
    wsprintf(szHKLMPrefix, L"%s\\%s*%s", pszSnapshotDir, s_cszHKLMFilePrefix,
             s_cszRegHiveCopySuffix);
    
    // need to use RegReplaceKey to restore each hive of the registry
    dwErr = ProcessGivenFiles(pszSnapshotDir, RestoreHKLMHive,
                              szHKLMPrefix); 
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "ProcessGivenFiles failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;        
    }    

    dwReturn = ERROR_SUCCESS;

cleanup:
    
     // if the HKLM hive is loaded, unload it.
    if (NULL != hKeyTempHKLM)
    {
        _VERIFY(ERROR_SUCCESS==RegCloseKey(hKeyTempHKLM));
        _VERIFY(ERROR_SUCCESS == RegUnLoadKey( HKEY_LOCAL_MACHINE,
                                               s_cszRestoreTempKey));
    }

     // delete the copy of HKLM software hive - note that this will
     // fail if the copy file failed.
    DeleteFile(szHKLMHiveCopy);
    
    
    TraceFunctLeave();    
    return dwReturn;    
}


DWORD
CSnapshot::RestoreCOMDbSnapshot(WCHAR * pszSnapShotDir)
{
    // need to restore COM+ Db using RegDBRestore        
    TraceFunctEnter("CSnapshot::RestoreCOMDbSnapshot");
    
    DWORD dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    HMODULE   hModCOMDll=NULL;
    HRESULT   hr;
    WCHAR     szCOMDBFile[MAX_PATH];
    
    
    if (NULL == m_pfnRegDbRestore)
    {
        dwErr = GetCOMplusRestoreFN();
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
            goto cleanup;
        }
    }

     // construct the path of the database backup file
    CreateCOMDBSnapShotFileName(pszSnapShotDir, szCOMDBFile);
    
    hr =m_pfnRegDbRestore( szCOMDBFile );
    
     // call the function to backup the file
    if ( FAILED(hr))
    {
        ErrorTrace(0, "Failed to restore COM DB. hr=0x%x", hr);
        goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
    TraceFunctLeave();
    return dwReturn;
}

DWORD 
CSnapshot::RestoreSnapshot(WCHAR * pszRestoreDir)
{
    TraceFunctEnter("CSnapshot::RestoreSnapshot");
    
    WCHAR  szSnapShotDir[MAX_PATH];
    DWORD  dwErr;
    DWORD  dwReturn = ERROR_INTERNAL_ERROR;
    BOOL   fCoInitialized = FALSE;  
    HKEY   hKey = NULL;

    struct {
        DWORD  FilelistFiles : 1;
        DWORD  COMDb : 1;
        DWORD  WMI : 1;
        DWORD  IIS : 1;
        DWORD  Registry : 1;
    } ItemsCompleted = {0,0,0,0,0};
    
    HRESULT hr;

     // create the snapshot directory name from the restore directory
     // name and create the actual directory.
    lstrcpy(szSnapShotDir, pszRestoreDir);
    lstrcat(szSnapShotDir, SNAPSHOT_DIR_NAME);
     // does the directory exist ? 
    if (FALSE == DoesDirExist( szSnapShotDir))  // SD
    {
        ErrorTrace(0, "Snapshot directory does not exist");
        goto cleanup;
    }

    // restore files listed in filelist.xml
    dwErr = SnapshotRestoreFilelistFiles(szSnapShotDir, FALSE);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;
        goto cleanup;
    }

    //
    // mark completion
    //
    
    ItemsCompleted.FilelistFiles = 1;

     // Restore COM snapshot
    dwErr = RestoreCOMDbSnapshot(szSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;        
        goto cleanup;
    }    

    //
    // mark completion
    //
    
    ItemsCompleted.COMDb = 1;

    hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if (hr == RPC_E_CHANGED_MODE)
    {
        //
        // someone called it with other mode
        //
        
        hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );                        
    }  
    
    if (FAILED(hr))
    {
        dwReturn = (DWORD) hr;
        ErrorTrace(0, "! CoInitializeEx : %ld", dwReturn);
        goto cleanup;
    }

    fCoInitialized = TRUE;
    
    
     // restore perf counters

     // restore WMI snapshot
    dwErr = RestoreWMISnapshot(szSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;        
        goto cleanup;
    }

    //
    // mark completion
    //
    
    ItemsCompleted.WMI = 1;

    // restore IIS snapshot
    dwErr = RestoreIISSnapshot(szSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;        
        goto cleanup;
    }

    //
    // mark completion
    //
    
    ItemsCompleted.IIS = 1;

    // 
    // support debug hook to force failure path
    // this is checked before the registry restore
    // because registry revert does not work
    //
    
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       SRREG_PATH_SHELL,
                                       0,
                                       KEY_READ,
                                       &hKey) )
    {
        DWORD  dwDebugTestUndo;        
        if (ERROR_SUCCESS == RegReadDWORD(hKey, SRREG_VAL_DEBUGTESTUNDO, &dwDebugTestUndo))
        {
            if (dwDebugTestUndo != 0)
            {
                DebugTrace(0, "*** Initiating UNDO for test purposes ***");
                dwReturn = ERROR_INTERNAL_ERROR;
                RegCloseKey(hKey);
                goto cleanup;
            }
        }
        RegCloseKey(hKey);
    }


    //
    // now the registry snapshot is not atomic, so if we start it,
    // we have should assume it made changes.  so we mark it in advance
    // such that it if fails, we will blast the safe registry over the current
    // registry, effectively rolling back the partial changes the failed
    // call made.  this is a brute force, but simple, way to handle this error
    // case, which we expect will never happen.  InitRestoreSnapshot makes
    // all of the proper checks to ensure this api will succeed when called.
    //

    // 
    // update: rollback of registry is not really working
    // because RegReplaceKey fails on an already replaced hive
    // so this might result in reverted user hives and unreverted software/system
    // hives, which is pretty bad
    // so disable this functionality
    // 
    
//    ItemsCompleted.Registry = 1;

    //
    // Restore resgistry snapshot
    //
    
    dwErr = this->RestoreRegistrySnapshot(szSnapShotDir);
    if (dwErr != ERROR_SUCCESS)
    {
        dwReturn = dwErr;
        goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
    
cleanup:
    
    //
    // do we need to clean up any completed items due to a failed restore?
    //
        
    if (dwReturn != ERROR_SUCCESS)
    {
        CRestorePoint   rp;
        WCHAR           szSafeDir[MAX_PATH];
        WCHAR           szSystemVolume[8];

        dwErr = 0;

        DebugTrace(0, "srrstr!Error in RestoreSnapshot\n");

        //
        // get the "current" restore point location, it has a snapshot
        // of how things where prior to starting this restore
        //
        
        dwErr = GetCurrentRestorePoint(rp);
        if (dwErr != ERROR_SUCCESS) {
            DebugTrace(0, "srrstr!GetCurrentRestorePoint failed!\n");
            goto end;
        }

        //
        // make sure the "safe" snapshot is there for us to use
        //

        GetSystemDrive(szSystemVolume);
        MakeRestorePath(szSafeDir, szSystemVolume, rp.GetDir());


        if (ItemsCompleted.Registry) {
            if (ERROR_SUCCESS != InitRestoreSnapshot(szSafeDir)) {
                DebugTrace(0, "! InitRestoreSnapshot");
                goto end;
            }
        }   
        
        lstrcat(szSafeDir, SNAPSHOT_DIR_NAME);
        if (DoesDirExist(szSafeDir) == FALSE)
        {
            DebugTrace(0, "srrstr!Safe snapshot directory does not exist!\n");
            goto end;
        }

        DebugTrace(0, "srrstr!Safe restore point %S\n", szSafeDir);

        //
        // roll them back in reverse order
        //

        if (ItemsCompleted.Registry) {
            dwErr = RestoreRegistrySnapshot(szSafeDir);
            // ignore any error's, we want to restore as much as we can
            _ASSERT(dwErr == ERROR_SUCCESS);
            DebugTrace(0, "srrstr!Restored registry\n");
        }            
        if (ItemsCompleted.IIS) {
            dwErr = RestoreIISSnapshot(szSafeDir);
            // ignore any error's, we want to restore as much as we can
            _ASSERT(dwErr == ERROR_SUCCESS);
            DebugTrace(0, "srrstr!Restored IIS\n");
        }
        if (ItemsCompleted.WMI) {
            dwErr = RestoreWMISnapshot(szSafeDir);
            // ignore any error's, we want to restore as much as we can
            _ASSERT(dwErr == ERROR_SUCCESS);
            DebugTrace(0, "srrstr!Restored WMI\n");
        }
        if (ItemsCompleted.COMDb) {
            dwErr = RestoreCOMDbSnapshot(szSafeDir);
            // ignore any error's, we want to restore as much as we can
            _ASSERT(dwErr == ERROR_SUCCESS);
            DebugTrace(0, "srrstr!Restored COMDb\n");
        }
        if (ItemsCompleted.FilelistFiles) {
            dwErr = SnapshotRestoreFilelistFiles(szSafeDir, FALSE);
            // ignore any error's, we want to restore as much as we can
            _ASSERT(dwErr == ERROR_SUCCESS);
            DebugTrace(0, "srrstr!Restored FilelistFiles\n");
        }

end:        
        //
        // not much to do
        //
        ;

    }

    if (fCoInitialized)
        CoUninitialize();

    TraceFunctLeave();
    return dwReturn;    
}

 // this returns the path of the system hive. The caller must pass
 // in a buffer with lenght of this buffer in dwNumChars
DWORD
CSnapshot::GetSystemHivePath(WCHAR * pszRestoreDir,
                             WCHAR * pszHivePath,
                             DWORD   dwNumChars)
{

     // first construct the name of the file that stores the HKLM registry
     // snapshot.
    if (dwNumChars < MAX_PATH)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    wsprintf(pszHivePath,L"%s%s\\%s%s%s", pszRestoreDir, SNAPSHOT_DIR_NAME,
             s_cszHKLMFilePrefix, s_cszSystemHiveName, s_cszRegHiveCopySuffix);

    return ERROR_SUCCESS;
}

 // this returns the path of the software hive. The caller must pass
 // in a buffer with lenght of this buffer in dwNumChars
DWORD
CSnapshot::GetSoftwareHivePath(WCHAR * pszRestoreDir,
                               WCHAR * pszHivePath,
                               DWORD   dwNumChars)
{

     // first construct the name of the file that stores the HKLM registry
     // snapshot.
    if (dwNumChars < MAX_PATH)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    wsprintf(pszHivePath,L"%s%s\\%s%s%s", pszRestoreDir, SNAPSHOT_DIR_NAME,
             s_cszHKLMFilePrefix, s_cszSoftwareHiveName,
             s_cszRegHiveCopySuffix);
    
    return ERROR_SUCCESS;
}

DWORD CSnapshot::GetSamHivePath (WCHAR * pszRestoreDir,
                          WCHAR * pszHivePath,
                          DWORD   dwNumChars)
{
    if (dwNumChars < MAX_PATH)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    wsprintf(pszHivePath,L"%s%s\\%s%s%s", pszRestoreDir, SNAPSHOT_DIR_NAME,
             s_cszHKLMFilePrefix, s_cszSamHiveName,
             s_cszRegHiveCopySuffix);

    return ERROR_SUCCESS;
}

// this checks whether a specific HKLM registry hive is present in the
// snapshot directory
DWORD CheckHKLMFile(const WCHAR * pszSnapShotDir,
                    const WCHAR * pszHive)
{
    BOOL dwReturn = ERROR_FILE_NOT_FOUND;
    
    TraceFunctEnter("CheckHKLMFile");
    
    WCHAR szHivePath[MAX_PATH];
    
     // construct the name of the file
    wsprintf(szHivePath,L"%s\\%s%s", pszSnapShotDir, s_cszHKLMFilePrefix,
             pszHive);
    if (FALSE == DoesFileExist(szHivePath))
    {
        LogDSFileTrace(0, L"Can't find", szHivePath);
        goto cleanup;
    }
    
    dwReturn=ERROR_SUCCESS;
    
cleanup:
    TraceFunctLeave();
    return dwReturn;
}
     
// this checks whether all the files necessary to restore a snapshot
// are present in the snapshot directory
DWORD CheckforCriticalFiles(WCHAR * pszSnapShotDir)
{
    TraceFunctEnter("CheckforCriticalFiles");
    WCHAR szCOMDBFile[MAX_PATH];
    DWORD  dwRet=ERROR_FILE_NOT_FOUND;
    
    dwRet=CheckHKLMFile(pszSnapShotDir,s_cszSoftwareHiveName);
    VALIDATE_DWRET ("CheckHKLM file Software");

    dwRet=CheckHKLMFile(pszSnapShotDir,s_cszSystemHiveName);
    VALIDATE_DWRET ("CheckHKLM file System");

    dwRet=CheckHKLMFile(pszSnapShotDir,s_cszSamHiveName);
    VALIDATE_DWRET ("CheckHKLM file SAM");

    dwRet=CheckHKLMFile(pszSnapShotDir,s_cszSecurityHiveName);
    VALIDATE_DWRET ("CheckHKLM file Security");        

     // construct the path of the database backup file
    CreateCOMDBSnapShotFileName(pszSnapShotDir, szCOMDBFile);
    if (FALSE == DoesFileExist(szCOMDBFile))
    {
        LogDSFileTrace(0, L"Can't find", szCOMDBFile);
        dwRet = ERROR_FILE_NOT_FOUND;
        goto Exit;        
    }
    
    dwRet=ERROR_SUCCESS;
    
Exit:
    TraceFunctLeave();
    return dwRet;
}

 // This function must be called to Initialize a restore
 // operation. This must be called before calling
 // GetSystemHivePath GetSoftwareHivePath
DWORD
CSnapshot::InitRestoreSnapshot(WCHAR * pszRestoreDir)
{
    TraceFunctEnter("InitRestoreSnapshot");
    WCHAR           szSnapshotDir[MAX_PATH];
    WCHAR           szHKLMPrefix[MAX_PATH];
    
     // this copies all the HKLM registry hives to a temporary location
     // since:
     //   1. RegReplaceKey will move the file to another location, so
     //      we will lose the original registry hive.
     //   2. We need to do this ahead of time becuase we do not want to
     //      run out of disk space in the middle of the restore.
     //   3. Restore makes changes to the HKLM hives, we do not want
     //      restore to make these changes to the original registry hives. 

    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;

     // create the snapshot directory name from the restore directory
     // name and create the actual directory.
    lstrcpy(szSnapshotDir, pszRestoreDir);
    lstrcat(szSnapshotDir, SNAPSHOT_DIR_NAME);


    // make sure no obsolete files are left from the previous restore
    // could have happened if admin did not login since the last restore to this restore 
    // point

    CleanupAfterRestore(pszRestoreDir);


    dwErr = CheckforCriticalFiles(szSnapshotDir);
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0,"CheckforCriticalFiles failed ec=%d",dwErr);
        dwReturn = dwErr;
        goto cleanup;
    }
    
     // first construct the prefix of the file that stores the HKLM registry
     // snapshot.
    wsprintf(szHKLMPrefix, L"%s\\%s*", szSnapshotDir, s_cszHKLMFilePrefix);
    
    dwErr = ProcessGivenFiles(szSnapshotDir, CopyHKLMHiveForRestore,
                              szHKLMPrefix); 
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "copying hives failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;        
    }
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    TraceFunctLeave();
    return dwReturn;    
}

DWORD DeleteTempRestoreFile(WCHAR * pszSnapshotDir, // Directory where
                             // snapshot files are kept
                            const WCHAR * pszTempRestoreFile)
                              // Temp file created during restore
{
    TraceFunctEnter("DeleteTempRestoreFile");
    
    DWORD dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR    szDataFile[MAX_PATH];

     // construct the path name of the file 
    wsprintf(szDataFile, L"%s\\%s", pszSnapshotDir, pszTempRestoreFile);

    if (TRUE != DeleteFile(szDataFile))
    {
        dwErr = GetLastError();
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }
        
        ErrorTrace(0, "DeleteFile failed ec=%d", dwErr);
        LogDSFileTrace(0,L"File was ", szDataFile);                
         // we will ignore a failure in deleting a file
         //goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
//cleanup:
    TraceFunctLeave();
    return dwReturn;
}

DWORD DeleteAllFilesBySuffix(WCHAR * pszSnapshotDir,
                             const WCHAR * pszSuffix)
{
    TraceFunctEnter("DeleteAllFilesBySuffix");
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;
    WCHAR szFindFileData[MAX_PATH];
    
     // first construct the prefix of the file that stores the HKLM registry
     // snapshot.
    wsprintf(szFindFileData, L"%s\\*%s", pszSnapshotDir, pszSuffix);
    
    dwErr = ProcessGivenFiles(pszSnapshotDir, DeleteTempRestoreFile,
                              szFindFileData);
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "Deleting files failed error %ld", dwErr);
        dwReturn = dwErr;
        goto cleanup;        
    }
    
    dwReturn = ERROR_SUCCESS;
    
cleanup:
    TraceFunctLeave();
    return dwReturn;
}


// delete the reconstructed file corresponding to pszPatchFile

DWORD DeleteReconstructedTempFile(WCHAR * pszSnapshotDir, 
                                  const WCHAR * pszPatchFile)
{
    TraceFunctEnter("DeleteReconstructedTempFile");
    
    WCHAR    szDataFile[MAX_PATH];

    wsprintf(szDataFile, L"%s\\%s", pszSnapshotDir, pszPatchFile);     
    
    // remove the extension

    szDataFile[lstrlen(szDataFile)-lstrlen(s_cszPatchExtension)] = L'\0';

    if (TRUE != DeleteFile(szDataFile))
    {
        ErrorTrace(0, "! DeleteFile : %ld", GetLastError);
        LogDSFileTrace(0, L"File was ", szDataFile);                
    }

    TraceFunctLeave();
    return ERROR_SUCCESS;
}
      
   

DWORD DeleteAllReconstructedFiles(WCHAR * pszSnapshotDir)
{
    TraceFunctEnter("DeleteAllReconstructedFiles");
    
    DWORD  dwErr=ERROR_INTERNAL_ERROR;
    WCHAR  szFindFileData[MAX_PATH];
    
     // first construct the prefix of the file that stores the HKLM registry
     // snapshot.
    wsprintf(szFindFileData, L"%s\\*%s", pszSnapshotDir, s_cszPatchExtension);
    
    dwErr = ProcessGivenFiles(pszSnapshotDir, DeleteReconstructedTempFile,
                              szFindFileData);
    
    if (ERROR_SUCCESS != dwErr)
    {
        ErrorTrace(0, "Deleting files failed error %ld", dwErr);
        goto cleanup;        
    }    
    
cleanup:
    TraceFunctLeave();
    return dwErr;
}



// this function is called after a restore operation. This deletes all
// the files that were created as part of the restore operation and
// are not needed now.
DWORD
CSnapshot::CleanupAfterRestore(WCHAR * pszRestoreDir)
{
    WCHAR           szSnapshotDir[MAX_PATH];
    
    DWORD  dwErr, dwReturn=ERROR_INTERNAL_ERROR;

     // create the snapshot directory name from the restore directory
     // name and create the actual directory.
    lstrcpy(szSnapshotDir, pszRestoreDir);
    lstrcat(szSnapshotDir, SNAPSHOT_DIR_NAME);

    DeleteAllFilesBySuffix(szSnapshotDir, L".log");
    DeleteAllFilesBySuffix(szSnapshotDir, s_cszRegHiveCopySuffix);
    DeleteAllFilesBySuffix(szSnapshotDir, s_cszRegReplaceBackupSuffix );

    // 
    // delete reconstructed files
    //
    DeleteAllReconstructedFiles(szSnapshotDir);
    
    
    return ERROR_SUCCESS;
}


int MyExceptionFilter(int nExceptionCode)
{
    TENTER("MyExceptionFilter");

    trace(0, "Exception code=%d", nExceptionCode);

    TLEAVE();

    return EXCEPTION_EXECUTE_HANDLER;
}


// 
// function to call any registered callbacks
// does not guarantee any order
// 

DWORD
CallSnapshotCallbacks(
    LPCWSTR pszEnumKey,
    LPCWSTR pszSnapshotDir,
    BOOL    fSnapshot)
{
    TraceFunctEnter("CallSnapshotCallbacks");

    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwIndex = 0;
    DWORD dwSize, dwDataSize;
    WCHAR szDllPath[MAX_PATH], szDllName[MAX_PATH];
    PSNAPSHOTCALLBACK pCallbackFn = NULL;
    HKEY  hKey = NULL;
    HMODULE hDll = NULL;

    //
    // read SystemRestore\SnapshotCallbacks regkey
    // enumerate all registered values 
    //

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pszEnumKey, 
                         0,
                         KEY_READ,
                         &hKey);
    if (dwErr != ERROR_SUCCESS) // assume key does not exist
    {
        dwErr = ERROR_SUCCESS;
        DebugTrace(0, "No registered callbacks");
        goto Err;
    }
              
    
    for (dwIndex = 0; TRUE; dwIndex ++)
    {
        dwSize = sizeof(szDllName)/sizeof(WCHAR); // this is in characters
        dwDataSize = sizeof(szDllPath); // this is in bytes
        
        dwErr = RegEnumValue(hKey, // handle to key to query
                             dwIndex, // index of value to query
                             szDllName, // value buffer
                             &dwSize,     // size of value buffer
                             NULL,    // reserved
                             NULL,    // type buffer
                             (PBYTE) szDllPath,    // data buffer
                             &dwDataSize);   // size of data buffer                            
        if (ERROR_SUCCESS != dwErr)
        {        
            break;
        }

        if (0 == lstrcmp(szDllPath, L"") || 
            0 == lstrcmp(szDllPath, L" "))
            continue;
        
        //
        // catch any exceptions that may happen in the callback dll
        //

        _try {
            
            _try {
                //
                // load the registered library
                // and call "CreateSnapshot" or "RestoreSnapshot" depending on the situation
                //
                
                hDll = LoadLibrary(szDllPath);    
                if (hDll != NULL)
                {                
                    pCallbackFn = (PSNAPSHOTCALLBACK) GetProcAddress(hDll, fSnapshot ? s_cszCreateSnapshotCallback :
                                                                     s_cszRestoreSnapshotCallback);
                    if (pCallbackFn)
                    {
                        dwErr = (*pCallbackFn) (pszSnapshotDir);
                        if (dwErr != ERROR_SUCCESS)
                        {
                            ErrorTrace(0, "Dll: %S, Error:%ld - ignoring", szDllPath, dwErr);
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    else
                    {
                        ErrorTrace(0, "! GetProcAddress : %ld", GetLastError());
                        dwErr = GetLastError();
                    }            
                }
                else
                {
                    ErrorTrace(0, "! LoadLibrary on %S : %ld", szDllPath, GetLastError());
                }
            }
            _finally {

                if (hDll)
                {
                    FreeLibrary(hDll);
                    hDll = NULL;
                }
            }
        }
        _except (MyExceptionFilter(GetExceptionCode())) {
            
            // 
            // catch all exceptions right here 
            // we can't do much, just log it and keep going
            //
            
            ErrorTrace(0, "An exception occurred when loading and executing %S", szDllPath);
            ErrorTrace(0, "Handled exception - continuing");
        }                        
    }

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = ERROR_SUCCESS;

Err:
    if (hKey)
        RegCloseKey(hKey);

    TraceFunctLeave();
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9119D7D2_7AA7_49BA_9204_4FF7C6033B9A__INCLUDED_)
#define AFX_STDAFX_H__9119D7D2_7AA7_49BA_9204_4FF7C6033B9A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include "srrpc.h"    // header file generated by MIDL compiler
#include "srdefs.h"
#include "utils.h"
#include <dbgtrace.h>

#endif // !defined(AFX_STDAFX_H__9119D7D2_7AA7_49BA_9204_4FF7C6033B9A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\srrpc_c_stub.c ===
#include "srrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\srrpcc.cpp ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    srrpcc.cpp

Abstract:
    implements functions exported in srclient.DLL
    Exported API:
    SRSetRestorePoint / SRRemoveRestorePoint
    DisableSR / EnableSR
    DisableFIFO / EnableFIFO
    
    
Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/10/00 - Created

********************************************************************/

#include "stdafx.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


//
// function to check if SR configuration is disabled
// via group policy
//

DWORD 
CheckPolicy()
{
    DWORD dwPolicyEnabled = 0;
    DWORD dwErr = ERROR_SUCCESS;
    HKEY  hKey = NULL;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                      s_cszGroupPolicy,
                                      0,    
                                      KEY_READ, 
                                      &hKey))
    {       
        // if this value exists,
        // then config policy is either enabled or disabled
        // we need to disable access in both cases
        
        if (ERROR_SUCCESS == RegReadDWORD(hKey, s_cszDisableConfig, &dwPolicyEnabled))            
            dwErr = ERROR_ACCESS_DENIED;

        RegCloseKey(hKey);
    }
    
    return dwErr;            
}



// bind handle to endpoint 

DWORD
SRRPCInit(
        RPC_IF_HANDLE * pIfHandle,
        BOOL fVerifyRights)
{
    RPC_STATUS      status;
    LPWSTR          pszStringBinding = NULL;
    DWORD           dwRc = ERROR_SUCCESS;

    InitAsyncTrace();
    
    TENTER("SRRPCInit");

    //
    // if admin rights are required
    // 

    if (fVerifyRights && ! IsAdminOrSystem())
    {
        TRACE(0, "Caller does not have admin or localsystem rights");
        dwRc = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    //
    // check if the service is stopping
    // if it is, then we don't want to accept any more rpc calls
    //
    
    if (IsStopSignalled(NULL))
    {
        TRACE(0, "Service shut down - not accepting rpc call");
        dwRc = ERROR_SERVICE_DISABLED;
        goto exit;
    }
    
    // compose string to pass to binding api

    dwRc = (DWORD) RpcStringBindingCompose(NULL,
                                   s_cszRPCProtocol,
                                   NULL,
                                   s_cszRPCEndPoint,
                                   NULL,
                                   &pszStringBinding);
    if (dwRc != ERROR_SUCCESS) 
    {
        TRACE(0, "RPCStringBindingCompose: error=%ld", dwRc);
        goto exit;
    }

    // set the binding handle that will be used to bind to the server. 

    dwRc = (DWORD) RpcBindingFromStringBinding(pszStringBinding,
                                       pIfHandle);

    if (dwRc != ERROR_SUCCESS) 
    {
        TRACE(0, "RPCBindingFromStringBinding: error=%ld", dwRc);        
    }

    // free string 

    RpcStringFree(&pszStringBinding);  

    if (dwRc != ERROR_SUCCESS)
        goto exit;

    RPC_SECURITY_QOS qos;

    qos.Version = RPC_C_SECURITY_QOS_VERSION;
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH; // Important!!!
    qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
    qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    dwRc = RpcBindingSetAuthInfoEx(*pIfHandle,
                                     L"NT AUTHORITY\\SYSTEM",
                                     RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                     RPC_C_AUTHN_WINNT,
                                     0,
                                     0,
                                     &qos);

exit:
    TLEAVE();
    return dwRc;
}



// free binding handle

DWORD
SRRPCTerm(
        RPC_IF_HANDLE * pIfHandle)
{
    RPC_STATUS status;

    TENTER("SRRPCTerm");
    
    // free binding handle
    
    if (pIfHandle && *pIfHandle)
        status = RpcBindingFree(pIfHandle);  

    TLEAVE();

    TermAsyncTrace();
    return (DWORD) status;
}


// API to disable System Restore 

extern "C" DWORD WINAPI
DisableSR(LPCWSTR pszDrive)
{
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("DisableSR");

    //
    // check if sr config is disabled via group policy
    //

    dwRc = CheckPolicy();
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = DisableSRS(srrpc_IfHandle, pszDrive);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "DisableSRS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);


exit:
    TLEAVE();
    return dwRc;
}  


// private function to start the SR service
// fWait - if TRUE : function is synchronous - waits till service is started completely
//        if FALSE : function is asynchronous - does not wait for service to complete starting

DWORD 
StartSRService(BOOL fWait)
{
    DWORD       dwRc = ERROR_SUCCESS;
    SC_HANDLE   hSCM = ::OpenSCManager(NULL, 
                                       NULL, 
                                       SC_MANAGER_ALL_ACCESS); 
    SERVICE_STATUS Status;
    
    if (hSCM)
    {
        SC_HANDLE hSR = OpenService(hSCM,  
                                    s_cszServiceName, 
                                    SERVICE_ALL_ACCESS);
        if (hSR)
        {
            if (FALSE == StartService(hSR, 0, NULL))
            {
                dwRc = GetLastError();
                if (dwRc == ERROR_SERVICE_ALREADY_RUNNING)
                {
                    goto done;
                }
                
                if (FALSE == QueryServiceStatus(hSR, &Status))
                {
                    goto done;
                }
                else
                {
                    dwRc = Status.dwWin32ExitCode;
                    goto done;
                }
            }

            if (fWait)                
            {
                //
                // query the service until it starts or stops
                // try thrice
                //

                for (int i = 0; i < 3; i++)
                {
                    Sleep(2000);
                    if (FALSE == QueryServiceStatus(hSR, &Status))
                    {
                        goto done;
                    }

                    if (Status.dwCurrentState == SERVICE_STOPPED)
                    {
                        dwRc = Status.dwWin32ExitCode;
                        if (dwRc == ERROR_SUCCESS)
                        {
                            // 
                            // service masks DISABLED error code
                            // to avoid unnecessary event log messages
                            //
                            dwRc = ERROR_SERVICE_DISABLED;
                        }
                        goto done;
                    }

                    if (Status.dwCurrentState == SERVICE_RUNNING)    
                    {
                        //
                        // wait on init event
                        //
                        
                        HANDLE hInit = OpenEvent(SYNCHRONIZE, FALSE, s_cszSRInitEvent);
                        if (hInit)
                        {
                            dwRc = WaitForSingleObject(hInit, 120000); // wait for 2 minutes
                            CloseHandle(hInit);
                            if (dwRc == WAIT_OBJECT_0)
                            {
                                dwRc = ERROR_SUCCESS;
                                goto done;
                            }
                            else 
                            {
                                dwRc = ERROR_TIMEOUT;
                                goto done;
                            }
                        }
                    }
                }                       
            }
            CloseServiceHandle(hSR);            
        }
        else
        {
            dwRc = GetLastError();
        }
        
        CloseServiceHandle(hSCM);
    }
    else
    {
        dwRc = GetLastError();
    }

done:
    return dwRc;
}


DWORD
SetDisableFlag(DWORD dwValue)
{
    HKEY   hKeySR = NULL;
    DWORD  dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               s_cszSRRegKey,
                               0,
                               KEY_WRITE, 
                               &hKeySR);
    if (ERROR_SUCCESS != dwRc)
        goto done;
    
    dwRc = RegWriteDWORD(hKeySR, s_cszDisableSR, &dwValue);
    if (ERROR_SUCCESS != dwRc)
        goto done;
    
done:
    if (hKeySR)
        RegCloseKey(hKeySR);

    return dwRc;
}


// API to enable System Restore

extern "C" DWORD WINAPI
EnableSR(LPCWSTR pszDrive)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("EnableSR");

    //
    // check if sr config is disabled via group policy
    //

    dwRc = CheckPolicy();
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }
    
	// if whole of SR is enabled, then
	// set the boot mode of service/filter to automatic
    // and start the service    

	if (! pszDrive || IsSystemDrive((LPWSTR) pszDrive))
	{       
        //
        // if safe mode, then don't 
        //

        if (0 != GetSystemMetrics(SM_CLEANBOOT))
        {
            TRACE(0, "This is safemode");
            dwRc = ERROR_BAD_ENVIRONMENT;
            goto exit;
        }
        
		dwRc = SetServiceStartup(s_cszServiceName, SERVICE_AUTO_START);
		if (ERROR_SUCCESS != dwRc)
			goto exit;

		dwRc = SetServiceStartup(s_cszFilterName, SERVICE_BOOT_START);
		if (ERROR_SUCCESS != dwRc)
			goto exit;

        // set the disable flag to false
        // BUGBUG - this piece of code is duplicated in the service code as well
        // reason is: we need the ability to disable/enable SR from within and outside 
        // the service
        
        dwRc = SetDisableFlag(FALSE);
        if (ERROR_SUCCESS != dwRc)
            goto exit;
            
        dwRc = StartSRService(FALSE);
	} 
    else
    {
        // initialize
        dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
        if (dwRc != ERROR_SUCCESS)
        {
            goto exit;
        }

        // call remote procedure
        RpcTryExcept
        {
            dwRc = EnableSRS(srrpc_IfHandle, pszDrive);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
        {
            dwRc = RpcExceptionCode();         
            TRACE(0, "EnableSRS threw exception: error=%ld", dwRc);  
        }
        RpcEndExcept

        // terminate
        SRRPCTerm(&srrpc_IfHandle);
    }

exit:
    TLEAVE();
    return dwRc;
}



// API to enable System Restore - extended version

extern "C" DWORD WINAPI
EnableSREx(LPCWSTR pszDrive, BOOL fWait)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("EnableSREx");

    //
    // check if sr config is disabled via group policy
    //

    dwRc = CheckPolicy();
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }
    
    // if whole of SR is enabled, then
    // set the boot mode of service/filter to automatic
    // and start the service    

    if (! pszDrive || IsSystemDrive((LPWSTR) pszDrive))
    {       
        //
        // if safe mode, then don't 
        //

        if (0 != GetSystemMetrics(SM_CLEANBOOT))
        {
            TRACE(0, "This is safemode");
            dwRc = ERROR_BAD_ENVIRONMENT;
            goto exit;
        }
        
        dwRc = SetServiceStartup(s_cszServiceName, SERVICE_AUTO_START);
        if (ERROR_SUCCESS != dwRc)
            goto exit;

        dwRc = SetServiceStartup(s_cszFilterName, SERVICE_BOOT_START);
        if (ERROR_SUCCESS != dwRc)
            goto exit;

        // set the disable flag to false
        // BUGBUG - this piece of code is duplicated in the service code as well
        // reason is: we need the ability to disable/enable SR from within and outside 
        // the service
        
        dwRc = SetDisableFlag(FALSE);
        if (ERROR_SUCCESS != dwRc)
            goto exit;
            
        dwRc = StartSRService(fWait);
    } 
    else
    {
        // initialize
        dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
        if (dwRc != ERROR_SUCCESS)
        {
            goto exit;
        }

        // call remote procedure
        RpcTryExcept
        {
            dwRc = EnableSRS(srrpc_IfHandle, pszDrive);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
        {
            dwRc = RpcExceptionCode();         
            TRACE(0, "EnableSRS threw exception: error=%ld", dwRc);  
        }
        RpcEndExcept

        // terminate
        SRRPCTerm(&srrpc_IfHandle);
    }

exit:
    TLEAVE();
    return dwRc;
}


// API to update the list of protected files - UNICODE version
// pass the fullpath name of the XML file containing the updated list of files

extern "C" DWORD WINAPI
SRUpdateMonitoredListA(
        LPCSTR pszXMLFile)
{
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    LPWSTR  pwszXMLFile = NULL;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRUpdateMonitoredListA");    
    
    pwszXMLFile = ConvertToUnicode((LPSTR) pszXMLFile);
    if (! pwszXMLFile)
    {
        TRACE(0, "ConvertToUnicode");
        goto exit;
    }

    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = SRUpdateMonitoredListS(srrpc_IfHandle, pwszXMLFile);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();       
        TRACE(0, "SRUpdateMonitoredListS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept


    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    if (pwszXMLFile)
        SRMemFree(pwszXMLFile);

    TLEAVE();
    return dwRc;
}  



// API to update the list of protected files - UNICODE version
// pass the fullpath name of the XML file containing the updated list of files

extern "C" DWORD WINAPI
SRUpdateMonitoredListW(
        LPCWSTR pwszXMLFile)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRUpdateMonitoredListW");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = SRUpdateMonitoredListS(srrpc_IfHandle, pwszXMLFile);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();       
        TRACE(0, "SRUpdateMonitoredListS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept


    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}  


// API to set a restore point - ANSI version

extern "C" BOOL
SRSetRestorePointA(
    PRESTOREPOINTINFOA  pRPInfoA, 
    PSTATEMGRSTATUS     pSMgrStatus)
{
    BOOL                fRc = FALSE;
    RESTOREPOINTINFOW   RPInfoW;
    LPWSTR              pszDescW = NULL;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRSetRestorePointA");    

    // Initialize return values

    if (! pSMgrStatus || ! pRPInfoA)
    {
        goto exit;
    }
    
    pSMgrStatus->llSequenceNumber = 0;
    pSMgrStatus->nStatus = ERROR_INTERNAL_ERROR;


    // convert struct to unicode
    // since the string is the last member of the struct, we can memcpy 
    // all
    memcpy(&RPInfoW, pRPInfoA, sizeof(RESTOREPOINTINFOA));
    pszDescW = ConvertToUnicode(pRPInfoA->szDescription);
    if (! pszDescW)
    {
        TRACE(0, "ConvertToUnicode");
        goto exit;
    }
    lstrcpy(RPInfoW.szDescription, pszDescW);

    
    // initialize
    // don't need admin rights to call this api
    
    pSMgrStatus->nStatus = SRRPCInit(&srrpc_IfHandle, FALSE);
    if (pSMgrStatus->nStatus != ERROR_SUCCESS)
    {
        goto exit;
    }


    // call remote procedure
    RpcTryExcept
    {
        fRc = SRSetRestorePointS(srrpc_IfHandle, &RPInfoW, pSMgrStatus);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {        
        // set right error code if SR is disabled
        
        DWORD dwRc = RpcExceptionCode(); 
        if (RPC_S_SERVER_UNAVAILABLE == dwRc || 
            RPC_S_UNKNOWN_IF == dwRc)
        {
            pSMgrStatus->nStatus = ERROR_SERVICE_DISABLED; 
        }
        else
        {
             pSMgrStatus->nStatus = dwRc;
        }

        TRACE(0, "SRSetRestorePointS threw exception: nStatus=%ld", pSMgrStatus->nStatus); 
    }
    RpcEndExcept
    
    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    if (pszDescW)
        SRMemFree(pszDescW);

    TLEAVE();
    return fRc;
}  



// API to set a restore point - UNICODE version

extern "C" BOOL
SRSetRestorePointW(
    PRESTOREPOINTINFOW  pRPInfoW, 
    PSTATEMGRSTATUS     pSMgrStatus)
{
    BOOL    fRc = FALSE;
    DWORD   dwRc = ERROR_SUCCESS;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRSetRestorePointW");    

    // Initialize return values

    if (! pSMgrStatus || ! pRPInfoW)
    {
        goto exit;
    }
    
    pSMgrStatus->llSequenceNumber = 0;
    pSMgrStatus->nStatus = ERROR_INTERNAL_ERROR;

    // initialize
    pSMgrStatus->nStatus = SRRPCInit(&srrpc_IfHandle, FALSE);
    if (pSMgrStatus->nStatus != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        fRc = SRSetRestorePointS(srrpc_IfHandle, pRPInfoW, pSMgrStatus);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {        
        // set right error code if SR is disabled
        
        DWORD dwRc = RpcExceptionCode(); 
        if (RPC_S_SERVER_UNAVAILABLE == dwRc || 
            RPC_S_UNKNOWN_IF == dwRc)
        {
            pSMgrStatus->nStatus = ERROR_SERVICE_DISABLED; 
        }
        else
        {
             pSMgrStatus->nStatus = dwRc;
        }

        TRACE(0, "SRSetRestorePointS threw exception: nStatus=%ld", pSMgrStatus->nStatus); 
    }
    RpcEndExcept
    
    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return fRc;
} 



// API to remove a restore point

extern "C" DWORD
SRRemoveRestorePoint(
    DWORD dwRPNum)                        
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRRemoveRestorePoint");    

    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, FALSE);
    if (dwRc != ERROR_SUCCESS)
        goto exit;

    // call remote procedure
    RpcTryExcept
    {
        dwRc = SRRemoveRestorePointS(srrpc_IfHandle, dwRPNum);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {        
        dwRc = RpcExceptionCode();
        TRACE(0, "SRRemoveRestorePointS threw exception: error=%ld", dwRc); 
    }
    RpcEndExcept
    
    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}  



// api to disable FIFO

extern "C" DWORD WINAPI
DisableFIFO(
        DWORD dwRPNum)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("DisableFIFO");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = DisableFIFOS(srrpc_IfHandle, dwRPNum);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "DisableFIFOS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);
    
exit:
    TLEAVE();
    return dwRc;
}  



// api to enable FIFO

extern "C" DWORD WINAPI
EnableFIFO()
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("EnableFIFO");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = EnableFIFOS(srrpc_IfHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "EnableFIFOS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}




// api to reset SR

extern "C" DWORD WINAPI
ResetSR(
        LPCWSTR pszDrive)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("ResetSR");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = ResetSRS(srrpc_IfHandle, pszDrive);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "ResetSRS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);
    
exit:
    TLEAVE();
    return dwRc;
}  


// api to refresh the drive table from disk
// restore UI will call this - service will update its drivetable in memory

extern "C" DWORD WINAPI
SRUpdateDSSize(LPCWSTR pszDrive, UINT64 ullSizeLimit)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRUpdateDSSize");    
    
    //
    // check if sr config is disabled via group policy
    //
    dwRc = CheckPolicy();
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = SRUpdateDSSizeS(srrpc_IfHandle, pszDrive, ullSizeLimit);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "SRUpdateDSSizeS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}

extern "C" DWORD WINAPI
SRSwitchLog()
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRSwitchLog");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, FALSE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = SRSwitchLogS(srrpc_IfHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "SRSwitchLogS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}


extern "C" void WINAPI
SRNotify(LPCWSTR pszDrive, DWORD dwFreeSpaceInMB, BOOL fImproving)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRNotify");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, FALSE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        SRNotifyS(srrpc_IfHandle, pszDrive, dwFreeSpaceInMB, fImproving);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "SRNotifyS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return;
}


extern "C" void WINAPI
SRPrintState()
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("SRPrintState");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, FALSE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        SRPrintStateS(srrpc_IfHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "SRPrintStateS threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return;
}


extern "C" DWORD WINAPI
SRFifo(LPCWSTR pszDrive, DWORD dwTargetRp, int nPercent, BOOL fIncludeCurrentRp, BOOL fFifoAtleastOneRp)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("Fifo");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = FifoS(srrpc_IfHandle, pszDrive, dwTargetRp, nPercent, fIncludeCurrentRp, fFifoAtleastOneRp);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "Fifo threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}


extern "C" DWORD WINAPI
SRCompress(LPCWSTR pszDrive)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("Compress");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)    
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = CompressS(srrpc_IfHandle, pszDrive);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "Compress threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}


extern "C" DWORD WINAPI
SRFreeze(LPCWSTR pszDrive)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    handle_t srrpc_IfHandle = NULL;
    
    TENTER("Freeze");    
    
    // initialize
    dwRc = SRRPCInit(&srrpc_IfHandle, TRUE);
    if (dwRc != ERROR_SUCCESS)
    {
        goto exit;
    }

    // call remote procedure
    RpcTryExcept
    {
        dwRc = FreezeS(srrpc_IfHandle, pszDrive);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {
        dwRc = RpcExceptionCode();                 
        TRACE(0, "Freeze threw exception: error=%ld", dwRc);
    }
    RpcEndExcept

    // terminate
    SRRPCTerm(&srrpc_IfHandle);

exit:
    TLEAVE();
    return dwRc;
}


// registration of callback method for third-parties to 
// do their own snapshotting and restoration for their components
// clients will call this method with the full path of their dll.
// system restore will call "CreateSnapshot" and "RestoreSnapshot"
// methods in the registered dll when creating a restore point and 
// when restoring respectively

extern "C" DWORD WINAPI
SRRegisterSnapshotCallback(
    LPCWSTR pszDllPath)
{
    DWORD 	dwErr = ERROR_SUCCESS;
    HKEY  	hKey = NULL;
    LPWSTR	pszDllName = NULL;
    WCHAR   szKey[MAX_PATH];
    DWORD   dwDisposition;
    
    TENTER("RegisterSnapshotCallback");

    //
    // allow this only if admin or system
    //

    if (! IsAdminOrSystem())
    {
        dwErr = ERROR_ACCESS_DENIED;
        trace(0, "Not admin or system");
        goto Err;
    }

    if (pszDllPath == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        trace(0, "pszDllPath = NULL");
        goto Err;
    }

    //
    // add the dll to Software\...\SystemRestore\SnapshotCallbacks
    // each dll will be a value 
    // value name : name of dll, value: fullpath of dll
    // this way, the registration is idempotent
    // 

    // 
    // create/open the key 
    //

    lstrcpy(szKey, s_cszSRRegKey);
    lstrcat(szKey,  L"\\");
    lstrcat(szKey, s_cszCallbacksRegKey);

    CHECKERR( RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                             szKey,
                             0,
                             NULL,
                             0,
                             KEY_ALL_ACCESS, 
                             NULL,
                             &hKey,
                             &dwDisposition),
              L"RegCreateKeyEx" );


    //
    // get the dll name from the path
    // if the path is not specified, this is same as input param
    //
    
    pszDllName = wcsrchr(pszDllPath, L'\\');
    if (pszDllName == NULL)
    {
        pszDllName = (LPWSTR) pszDllPath;
    }
    else
    {
        pszDllName++;    // skip the '\'
    }    


    // 
    // if the value already exists
    // bail
    //
    
    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                         pszDllName,
                                         0,
                                         NULL,
                                         NULL,
                                         NULL))
    {
        trace(0, "Dll is already registered");
        dwErr = ERROR_ALREADY_EXISTS;
        goto Err;
    }

    
    //
    // add the value
    //
    
    CHECKERR(RegSetValueEx(hKey,
                           pszDllName,
                           0,
                           REG_SZ,
                           (BYTE *) pszDllPath,
                           (lstrlen(pszDllPath)+1)*sizeof(WCHAR)),
             L"RegSetValueEx");


    trace(0, "Added %S as snapshot callback", pszDllPath);

Err:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    TLEAVE();
    return dwErr;                  
}



// corresponding unregistration function to above function
// clients can call this to unregister any snapshot callbacks
// they have already registered

extern "C" DWORD WINAPI
SRUnregisterSnapshotCallback(
    LPCWSTR pszDllPath)
{
    DWORD 	dwErr = ERROR_SUCCESS;
    HKEY  	hKey = NULL;
    LPWSTR	pszDllName = NULL;
    WCHAR   szKey[MAX_PATH];

    TENTER("SRUnregisterSnapshotCallback");

    //
    // allow this only if admin or system
    //

    if (! IsAdminOrSystem())
    {
        dwErr = ERROR_ACCESS_DENIED;
        trace(0, "Not admin or system");
        goto Err;
    }

    if (pszDllPath == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        trace(0, "pszDllPath = NULL");
        goto Err;
    }

    //
    // add the dll to Software\...\SystemRestore\SnapshotCallbacks
    // each dll will be a value 
    // value name : name of dll, value: fullpath of dll
    // this way, the registration is idempotent
    // 

    // 
    // open the key 
    //

    lstrcpy(szKey, s_cszSRRegKey);
    lstrcat(szKey,  L"\\");
    lstrcat(szKey, s_cszCallbacksRegKey);

    CHECKERR( RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                           szKey,
                           0,
                           KEY_ALL_ACCESS,
                           &hKey),                           
              L"RegOpenKeyEx" );


    //
    // get the dll name from the path
    // if the path is not specified, this is same as input param
    //

    pszDllName = wcsrchr(pszDllPath, L'\\');
    if (pszDllName == NULL)
    {
        pszDllName = (LPWSTR) pszDllPath;
    }
    else
    {
        pszDllName++;    // skip the '\'
    }    
    
    //
    // remove the value
    //
    
    CHECKERR(RegDeleteValue(hKey,
                            pszDllName),
             L"RegDeleteValue");

    trace(0, "Removed %S from snapshot callback", pszDllPath);

Err:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    TLEAVE();
    return dwErr;                  
}


//
// test functions for snapshot callbacks
//

extern "C" DWORD WINAPI
CreateSnapshot(LPCWSTR pszSnapshotDir)
{
    TENTER("CreateSnapshot");

    WCHAR szFile[MAX_PATH];
    wsprintf(szFile, L"%s\\srclient.txt", pszSnapshotDir);
    
    DebugTrace(0, "Callback createsnapshot");
    if (FALSE == CopyFile(L"c:\\srclient.txt", szFile, FALSE))
    {
        trace(0, "! CopyFile");
    }

    TLEAVE();
    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
RestoreSnapshot(LPCWSTR pszSnapshotDir)
{
    TENTER("RestoreSnapshot");

    WCHAR szFile[MAX_PATH];
    wsprintf(szFile, L"%s\\srclient.txt", pszSnapshotDir);
    
    DebugTrace(0, "Callback restoresnapshot");
    if (FALSE == CopyFile(szFile, L"c:\\restored.txt", FALSE))
    {
        trace(0, "! CopyFile");
    }
    
    TLEAVE();
    return ERROR_SUCCESS;
}




// alloc/dealloc functions for midl compiler

void  __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(SRMemAlloc((DWORD) len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    SRMemFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\idl\import.h ===
/********************************************************************/
/**               Copyright(c) 1991 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	import.h
//
// Description: This file allows us to include standard system header files 
//		in the .idl file.  The main .idl file imports a file called 
//		import.idl. This allows the .idl file to use the types defined 
//		in these header files. It also causes the following line to 
//		be added in the MIDL generated header file:
//
//    		#include "import.h"
//
//   		Thus these types are available to the RPC stub routines as well.
//
//


#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#define HANDLE      DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\server\srrpcs.h ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    srrpcs.cpp

Abstract:
    header file for rpc server functions - SRRPCS.LIB
    
Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/02/00
              created

********************************************************************/

#ifndef _SRRPCS_H_
#define _SRRPCS_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI RpcServerShutdown();
DWORD WINAPI RpcServerStart();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\systemrestore.cpp ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   SystemRestore.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include <fwcommon.h>  // This must be the first include.

#include "SystemRestore.h"
#include "srdefs.h"
#include "srrestoreptapi.h"
#include "srrpcapi.h"
#include "enumlogs.h"
#include "utils.h"
#include "srshell.h"


// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================
CSystemRestore MySystemRestoreSet (PROVIDER_NAME_SYSTEMRESTORE, L"root\\default") ;

// Property names
//===============
const static WCHAR* pName = L"Description" ;
const static WCHAR* pNumber = L"SequenceNumber" ;
const static WCHAR* pType = L"RestorePointType" ;
const static WCHAR* pEventType = L"EventType" ;
const static WCHAR* pTime = L"CreationTime" ;


/*****************************************************************************
 *
 *  FUNCTION    :   CSystemRestore::CSystemRestore
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CSystemRestore::CSystemRestore (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CSystemRestore::~CSystemRestore
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CSystemRestore::~CSystemRestore ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CSystemRestore::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must 
*                       be filled in.  If there are no instances, return 
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/
HRESULT CSystemRestore::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

// TO DO: The following commented lines contain the 'set' methods for the
//        properties entered for this class.  They are commented because they
//        will NOT compile in their current form.  Each <Property Value> should be
//        replaced with the appropriate value.  Also, consider creating a new
//        method and moving these set statements and the ones from GetObject 
//        into that routine.  See the framework sample (ReindeerProv.cpp) for 
//        an example of how this might be done.
//
//        If the expectation is that there is more than one instance on the machine
//        EnumerateInstances should loop through the instances and fill them accordingly.
//
//        Note that you must ALWAYS set ALL the key properties.  See the docs for
//        further details.
///////////////////////////////////////////////////////////////////////////////
    WCHAR               szDrive[MAX_PATH]=L""; 

    GetSystemDrive(szDrive);
    
    CRestorePointEnum   RPEnum(szDrive, TRUE, FALSE);
    CRestorePoint       RP;
    DWORD               dwRc;
    FILETIME            *pft = NULL;

    if (!IsAdminOrSystem())
    {
        return (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));
    }
            
    dwRc = RPEnum.FindFirstRestorePoint(RP);

    while (dwRc == ERROR_SUCCESS)
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);
        if (! pInstance)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        
        pInstance->SetCHString(pName, RP.GetName());
        pInstance->SetDWORD(pNumber, RP.GetNum());
        pInstance->SetDWORD(pType, RP.GetType());
        pInstance->SetDWORD(pEventType, RP.GetEventType());
        
        if (pft = RP.GetTime())
        {
            WBEMTime wbt(*pft);    
            BSTR     bstrTime;
            if (bstrTime = wbt.GetBSTR())
            {
                pInstance->SetCHString(pTime, bstrTime);
                SysFreeString(bstrTime);
            }
        }
        
        hRes = pInstance->Commit();
        pInstance->Release();
                            
        dwRc = RPEnum.FindNextRestorePoint(RP);                
    }   

    RPEnum.FindClose();
    
    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CSystemRestore::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/
HRESULT CSystemRestore::GetObject ( CInstance* pInstance, long lFlags )
{
    // TO DO: The GetObject function is used to search for an instance of this
    //        class on the machine based on the key properties.  Unlike
    //        EnumerateInstances which finds all instances on the machine, GetObject
    //        uses the key properties to find the matching single instance and 
    //        returns that instance.
    //
    //        Use the CInstance Get functions (for example, call 
    //        GetCHString(L"Name", sTemp)) against pInstance to see the key values 
    //        the client requested.
    HRESULT hr = WBEM_E_NOT_FOUND;

//    if (<InstanceExists>)
//    {
// TO DO: The following commented lines contain the 'set' methods for the
//        properties entered for this class.  They are commented because they
//        will NOT compile in their current form.  Each <Property Value> should be
//        replaced with the appropriate value.
//
//        pInstance->SetCHString(pName, <Property Value>);
//        pInstance->SetVariant(pNumber, <Property Value>);
//        pInstance->SetVariant(pType, <Property Value>);
//
//        hr = WBEM_S_NO_ERROR;
//    }

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CSystemRestore::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CSystemRestore::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
     return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CSystemRestore::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CSystemRestore::PutInstance ( const CInstance &Instance, long lFlags)
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    CSystemRestore::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CSystemRestore::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    CSystemRestore::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CSystemRestore::ExecMethod ( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags)
{
    // For non-static methods, use the CInstance Get functions (for example, 
    // call GetCHString(L"Name", sTemp)) against Instance to see the key 
    // values the client requested.

    HRESULT hresult = WBEM_E_PROVIDER_NOT_CAPABLE;

    if (lstrcmpi(bstrMethodName, L"CreateRestorePoint") == 0)
    {
        hresult = CreateRestorePoint(pInParams, pOutParams);
    }        
    else if (lstrcmpi(bstrMethodName, L"Enable") == 0)  
    {
        hresult = Enable(pInParams, pOutParams);
    }
    else if (lstrcmpi(bstrMethodName, L"Disable") == 0)  
    {
        hresult = Disable(pInParams, pOutParams);
    }
    else if (lstrcmpi(bstrMethodName, L"Restore") == 0)  
    {
        hresult = Restore(pInParams, pOutParams);
    }
    else if (lstrcmpi(bstrMethodName, L"GetLastRestoreStatus") == 0)  
    {
        hresult = GetLastRestoreStatus(pInParams, pOutParams);
    }
    
    return hresult;
}



HRESULT CSystemRestore::CreateRestorePoint(
                        CInstance *pInParams,
                        CInstance *pOutParams)
{
    LPWSTR              pwszName = NULL;
    HRESULT             hr = WBEM_S_NO_ERROR;
    RESTOREPOINTINFOW   rpi;
    STATEMGRSTATUS      ss;

    ss.nStatus = ERROR_INVALID_PARAMETER;
    pInParams->GetWCHAR(L"Description", &pwszName);
    if (pwszName)
    {        
        pInParams->GetDWORD(L"RestorePointType", rpi.dwRestorePtType);
        pInParams->GetDWORD(L"EventType", rpi.dwEventType);    
        lstrcpy(rpi.szDescription, pwszName);

        // cannot create a RESTORE type restore point from WMI
        if (rpi.dwRestorePtType == RESTORE)
        {
            goto done;
        }

        ::SRSetRestorePoint(&rpi, &ss);        

        free(pwszName);   
    }
    
done:
	pOutParams->SetDWORD(L"ReturnValue", ss.nStatus);
    return hr;
}


HRESULT CSystemRestore::Enable(
                        CInstance *pInParams,
                        CInstance *pOutParams)
{
    LPWSTR              pwszDrive = NULL;
    HRESULT             hr = WBEM_E_INVALID_PARAMETER;
    bool                fWait = 0;
    DWORD               dwRc;
    
    pInParams->GetWCHAR(L"Drive", &pwszDrive);
    pInParams->Getbool(L"WaitTillEnabled", fWait);    
    if (pwszDrive)
    {
        if (0 == lstrcmpi(pwszDrive, L""))
            dwRc = ::EnableSREx(NULL, (BOOL) fWait);
        else        
            dwRc = ::EnableSREx(pwszDrive, (BOOL) fWait);
        
        pOutParams->SetDWORD(L"ReturnValue", dwRc);

        if (pwszDrive) free(pwszDrive);   

        hr = WBEM_S_NO_ERROR;
    }
    
    return hr;
}


HRESULT CSystemRestore::Disable(
                        CInstance *pInParams,
                        CInstance *pOutParams)
{
    LPWSTR              pwszDrive = NULL;
    HRESULT             hr = WBEM_E_INVALID_PARAMETER;
    DWORD               dwRc;
    
    pInParams->GetWCHAR(L"Drive", &pwszDrive);
    if (pwszDrive)
    {        
        if (0 == lstrcmpi(pwszDrive, L""))
            dwRc = ::DisableSR(NULL);
        else
            dwRc = ::DisableSR(pwszDrive);
            
        pOutParams->SetDWORD(L"ReturnValue", dwRc);

        if (pwszDrive) free(pwszDrive); 
        
        hr = WBEM_S_NO_ERROR;        
    }
    
    return hr;
}


HRESULT CSystemRestore::Restore(
                        CInstance *pInParams,
                        CInstance *pOutParams)
{
    HRESULT             hr = WBEM_E_INVALID_PARAMETER;
    DWORD               dwRp = 0, dwRpNew;
    IRestoreContext     *pCtx = NULL;
    DWORD               dwErr = ERROR_INTERNAL_ERROR;
    HMODULE             hModule = NULL;
    CRestorePoint       rp;
    WCHAR               szRp[MAX_RP_PATH];
    
    pInParams->GetDWORD(L"SequenceNumber", dwRp);

    if (dwRp == 0) 
        goto Err;

    hr = WBEM_S_NO_ERROR;

    // validate the restore point first
    
    wsprintf( szRp, L"%s%ld", s_cszRPDir, dwRp );
    rp.SetDir(szRp);
    dwErr = rp.ReadLog();
    if (dwErr != ERROR_SUCCESS)   // it doesn't exist
    {
        goto Err;
    }

    if (rp.GetType() == CANCELLED_OPERATION)    // cannot restore to it
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Err;
    }
    
    hModule = ::LoadLibraryW (L"srrstr.dll");

    if (hModule != NULL)
    {
        INITFUNC pInit = NULL;
        PREPFUNC pPrep = (PREPFUNC) GetProcAddress (hModule, "PrepareRestore");

        if (pPrep != NULL)
        {
            if (FALSE == (*pPrep) ((int) dwRp, &pCtx))
            {
                goto Err;
            }
        }
        else
        {
            dwErr = GetLastError();
            goto Err;
        }
        
        // 
        // make this a silent restore - no result page
        //
        
        pCtx->SetSilent();
        
        pInit = (INITFUNC) GetProcAddress (hModule, "InitiateRestore");
        if (pInit != NULL)
        {
            if (FALSE == (*pInit) (pCtx, &dwRpNew))
            {
                goto Err;
            }
            else
            {
                dwErr = ERROR_SUCCESS;
            }
        }
        else
        {
            dwErr = GetLastError();
            goto Err;
        }        
    }
    else dwErr = GetLastError();

Err:
    pOutParams->SetDWORD(L"ReturnValue", dwErr);     

    if (hModule != NULL)
        ::FreeLibrary (hModule);

    return hr;
}


HRESULT 
CSystemRestore::GetLastRestoreStatus(
    CInstance *pInParams,
    CInstance *pOutParams)
{
    HRESULT     hr = WBEM_S_NO_ERROR;
    DWORD       dwStatus = 0;
    HKEY        hkey = NULL;
    
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, s_cszSRRegKey, &hkey))
    {
        RegReadDWORD(hkey, s_cszRestoreStatus, &dwStatus);
        RegCloseKey(hkey);
    }
    else
    {
        dwStatus = 0xFFFFFFFF;
    }
    
    pOutParams->SetDWORD(L"ReturnValue", dwStatus);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\server\srrpcs.cpp ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    sfprpcs.cpp

Abstract:
    implements server rpc thread - exported in  SFPSAPI.LIB
               server shutdown - exported in  SFPSAPI.LIB
    
Revision History:

    Brijesh Krishnaswami (brijeshk) - 06/16/99 - Created

********************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "srrpc.h"    // header file generated by MIDL compiler
#include "srdefs.h"
#include "utils.h"
#include <dbgtrace.h>

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


#define MIN_RPC_CALLS 1
#define MAX_RPC_CALLS 5


RPC_STATUS RPC_ENTRY SecurityCallBack (RPC_IF_HANDLE hInterface,
                                       handle_t hBinding)
{
    RPC_STATUS status = RPC_S_OK;
    UINT fLocal = FALSE;
    RPC_AUTHZ_HANDLE hPrivs;
    DWORD dwAuthn;

    status = I_RpcBindingIsClientLocal (hBinding, &fLocal);
    if (status != RPC_S_OK || fLocal == FALSE)
    {
        status = ERROR_ACCESS_DENIED;
        goto done;
    }

    status = RpcBindingInqAuthClient (hBinding,
                                     &hPrivs,
                                     NULL,
                                     &dwAuthn,
                                     NULL,
                                     NULL);

    if (status != RPC_S_OK || dwAuthn < RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
    {
        status = ERROR_ACCESS_DENIED;
        goto done;
    }
    
done:
    return status;
}

// RPC Server 
// registers as an rpc server and waits for requests

extern "C" DWORD WINAPI
RpcServerStart()
{   
    RPC_STATUS  status;

    TENTER("RpcServerStart");
    
    status = RpcServerRegisterAuthInfo(L"NT AUTHORITY\\SYSTEM",
                                       RPC_C_AUTHN_WINNT, 
                                       0,
                                       0);

    if (status != RPC_S_OK)
    {
        TRACE(0, "! RpcServerRegisterAuthInfo : %ld", status);
        goto exit;
    }

    // specify to use the local rpc protocol sequence
    status = RpcServerUseProtseqEp(s_cszRPCProtocol,
                                   MAX_RPC_CALLS,
                                   s_cszRPCEndPoint,
                                   NULL);  // Security descriptor
    if (status != 0 && status != RPC_S_DUPLICATE_ENDPOINT) 
    {
        TRACE(0, "! RpcServerUseProtseqEp : %ld", status);
        goto exit;
    }

    // register the srrpc interface
    status = RpcServerRegisterIfEx(srrpc_ServerIfHandle,  // interface to register
                                   NULL,    // MgrTypeUuid
                                   NULL,    // MgrEpv; null means use default
                                   RPC_IF_AUTOLISTEN |  // auto-listen interface
                                   RPC_IF_ALLOW_SECURE_ONLY,
                                   MAX_RPC_CALLS,       // max concurrent calls
                                   SecurityCallBack);   // callback
    if (status) 
    {
        TRACE(0, "! RpcServerRegisterIfEx : %ld", status);    
        goto exit;
    }

    TRACE(0, "Started to listen to RPC calls");

exit:
    TLEAVE();
    return status;
}


// function to shut down the rpc server 

extern "C" DWORD WINAPI
RpcServerShutdown()
{
    RPC_STATUS status;

    TENTER("RpcServerShutdown");
    
    // unregister the server endpoint
    status = RpcServerUnregisterIf(srrpc_ServerIfHandle, NULL, TRUE);
    if (status)
    {
        TRACE(0, "! RpcServerUnregisterIf : %ld", status);    
        goto exit;
    }

exit:
    TLEAVE();
    return status;
}



// functions used by midl compiler to allocate and free memory
void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(SRMemAlloc((DWORD) len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    SRMemFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\client\systemrestore.h ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   SystemRestore.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _SystemRestore_H_
#define _SystemRestore_H_

#define PROVIDER_NAME_SYSTEMRESTORE L"SystemRestore"

// Property name externs -- defined in SystemRestore.cpp
//=================================================

extern const WCHAR* pName ;
extern const WCHAR* pNumber ;
extern const WCHAR* pType ;
extern const WCHAR* pTime ;

class CSystemRestore : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CSystemRestore(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CSystemRestore();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================
        HRESULT CreateRestorePoint(
            CInstance *pInParams,
            CInstance *pOutParams);

        HRESULT Disable(
            CInstance *pInParams,
            CInstance *pOutParams);
            
        HRESULT Enable(
            CInstance *pInParams,
            CInstance *pOutParams);

        HRESULT Restore(
            CInstance *pInParams,
            CInstance *pOutParams);            

		HRESULT GetLastRestoreStatus(
		    CInstance *pInParams,
		    CInstance *pOutParams);
		    
    private:
        // All data members for CSystemRestore should be included here.   

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\srrpc\server\srrpc_s_stub.c ===
#include "srrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\test\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <conio.h>

//
// need to use this with FILE_DISPOSITION_INFORMATION
//

#undef DeleteFile

#include <srapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\test\main.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:

    simple bvt-like test code for SR.SYS.

Author:

    Paul McDaniel (paulmcd)     07-Mar-2000

Revision History:

--*/


#include "precomp.h"


#define NtStatusToWin32Status( Status )                                  \
    ( ( (Status) == STATUS_SUCCESS )                                        \
          ? NO_ERROR                                                        \
          : RtlNtStatusToDosError( Status ) )

ULONG Shutdown = 0;
HANDLE ControlHandle = NULL;


DWORD
WINAPI
NotifyThread(
    LPVOID pParameter
    )
{

    union
    {
    
        SR_NOTIFICATION_RECORD Record;
        UCHAR                  Buffer[1024*4];
        
    } NotifyRecord;

    ULONG       Error;
    ULONG       Length;
    OVERLAPPED  Overlapped;

    ZeroMemory(&Overlapped, sizeof(Overlapped));

    Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    while (Shutdown == 0)
    {

        ResetEvent(Overlapped.hEvent);

        Error = SrWaitForNotification( ControlHandle, 
                                       (PVOID)&NotifyRecord, 
                                       sizeof(NotifyRecord), 
                                       &Overlapped );

        if (Error == ERROR_IO_PENDING)
        {
            if (GetOverlappedResult(ControlHandle, &Overlapped, &Length, TRUE))
            {
                Error = 0;
            }
            else
            {
                Error = GetLastError();
            }
        }

        if (Error != 0)
        {
            printf("\n!SrWaitForNotification failed %d\n", Error);
        }
        else
        {
            printf( "\n-SrWaitForNotification(%ls, %d)\n", 
                    NotifyRecord.Record.VolumeName.Buffer,
                    NotifyRecord.Record.NotificationType );
        }
    }

    CloseHandle(Overlapped.hEvent);

    Shutdown = 2;

    return 0;
}

int __cdecl main(int argc, char ** argv)
{
    ULONG   Error = 0;
    UCHAR   Char;
    ULONG   Number;
    HANDLE  ThreadHandle;

    //
    // Start the monitor process
    //

    printf("started...\n" );


    Error = SrCreateControlHandle(SR_OPTION_OVERLAPPED, &ControlHandle);
    if (Error != 0)
    {
        printf("!SrCreateControlHandle failed %d\n", Error);
        return Error;
    }

    ThreadHandle = CreateThread(NULL, 0, NotifyThread, NULL, 0, NULL);
    CloseHandle(ThreadHandle);

    
    while (Shutdown == 0)
    {

        printf("1=start,2=stop,3=new_restore_point,4=quit: ");
        Char = (UCHAR)_getche();
        printf("\n");

        switch (Char)
        {
        case '1':

            Error = SrStartMonitoring(ControlHandle);
            if (Error != 0)
            {
                printf("!SrStartMonitoring failed %d\n", Error);
            }
            else
            {
                printf("-SrStartMonitoring \n");
            }

            break;

                    
        case '2':

            Error = SrStopMonitoring(ControlHandle);
            if (Error != 0)
            {
                printf("!SrStopMonitoring failed %d\n", Error);
            }
            else
            {
                printf("-SrStopMonitoring \n");
            }

            break;

        case '3':

            Error = SrCreateRestorePoint(ControlHandle, &Number);
            if (Error != 0)
            {
                printf("!SrCreateRestorePoint failed %d\n", Error);
            }
            else
            {
                printf("-SrCreateRestorePoint(%d)\n", Number);
            }

            break;

        case '4':

            printf("quit...\n");
            Shutdown = 1;
            break;
        };

        

    }

    CloseHandle(ControlHandle);

    //
    // wait for our thread to die
    //
    
    while (Shutdown < 2)
        Sleep(0);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\test\srclient\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\test\srtest\main.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:

    simple bvt-like test code for SR.SYS.

Author:

    Paul McDaniel (paulmcd)     07-Mar-2000

Revision History:

--*/


#include "precomp.h"


#define NtStatusToWin32Status( Status )                                  \
    ( ( (Status) == STATUS_SUCCESS )                                        \
          ? NO_ERROR                                                        \
          : RtlNtStatusToDosError( Status ) )

ULONG Shutdown = 0;
HANDLE ControlHandle = NULL;


DWORD
WINAPI
NotifyThread(
    LPVOID pParameter
    )
{

    union
    {
    
        SR_NOTIFICATION_RECORD Record;
        UCHAR                  Buffer[1024*4];
        
    } NotifyRecord;

    ULONG       Error;
    ULONG       Length;
    OVERLAPPED  Overlapped;

    ZeroMemory(&Overlapped, sizeof(Overlapped));

    Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    while (Shutdown == 0)
    {

        ResetEvent(Overlapped.hEvent);

        if (ControlHandle == NULL)
        {
            Sleep(100);
            continue;
        }

        Error = SrWaitForNotification( ControlHandle, 
                                       (PVOID)&NotifyRecord, 
                                       sizeof(NotifyRecord), 
                                       &Overlapped );

        if (Error == ERROR_IO_PENDING)
        {
            if (GetOverlappedResult(ControlHandle, &Overlapped, &Length, TRUE))
            {
                Error = 0;
            }
            else
            {
                Error = GetLastError();
            }
        }

        if (Error != 0)
        {
            printf("\n!SrWaitForNotification failed %d\n", Error);
        }
        else
        {
            printf( "\n-SrWaitForNotification(%ls, %d)\n", 
                    NotifyRecord.Record.VolumeName.Buffer,
                    NotifyRecord.Record.NotificationType );
        }
    }

    CloseHandle(Overlapped.hEvent);

    Shutdown = 2;

    return 0;
}

int __cdecl main(int argc, char ** argv)
{
    ULONG   Error = 0;
    UCHAR   Char;
    ULONG   Number;
    HANDLE  ThreadHandle;

    //
    // Start the monitor process
    //

    printf("started...\n" );


    Error = SrCreateControlHandle(SR_OPTION_OVERLAPPED, &ControlHandle);
    if (Error != 0)
    {
        printf("!SrCreateControlHandle failed %d\n", Error);
        return Error;
    }

    ThreadHandle = CreateThread(NULL, 0, NotifyThread, NULL, 0, NULL);
    CloseHandle(ThreadHandle);

    
    while (Shutdown == 0)
    {

        printf("0=open,1=start,2=stop,3=new_restore_point,4=close,5=quit,6=reload,7=disable: ");
        Char = (UCHAR)_getche();
        printf("\n");

        switch (Char)
        {
        case '0':
            if (ControlHandle != NULL)
            {
                printf("already open!\n");
                break;
            }

            Error = SrCreateControlHandle(SR_OPTION_OVERLAPPED, &ControlHandle);
            if (Error != 0)
            {
                printf("!SrCreateControlHandle failed %d\n", Error);
                return Error;
            }
            break;

        case '1':

            Error = SrStartMonitoring(ControlHandle);
            if (Error != 0)
            {
                printf("!SrStartMonitoring failed %d\n", Error);
            }
            else
            {
                printf("-SrStartMonitoring \n");
            }

            break;

                    
        case '2':

            Error = SrStopMonitoring(ControlHandle);
            if (Error != 0)
            {
                printf("!SrStopMonitoring failed %d\n", Error);
            }
            else
            {
                printf("-SrStopMonitoring \n");
            }

            break;

        case '3':

            Error = SrCreateRestorePoint(ControlHandle, &Number);
            if (Error != 0)
            {
                printf("!SrCreateRestorePoint failed %d\n", Error);
            }
            else
            {
                printf("-SrCreateRestorePoint(%d)\n", Number);
            }

            break;

        case '4':

            if (ControlHandle == NULL)
            {
                printf ("already closed!\n");
                break;
            }

            CloseHandle(ControlHandle);
            ControlHandle = NULL;

            break;

        case '5':

            printf("quit...\n");
            Shutdown = 1;
            break;
            
        case '6':

            Error = SrReloadConfiguration(ControlHandle);
            if (Error != 0)
            {
                printf("!SrReloadConfiguration failed %d\n", Error);
            }
            else
            {
                printf("-SrReloadConfiguration\n");
            }

            break;

        case '7':

            Error = SrDisableVolume(ControlHandle, L"\\??\\D:");
            if (Error != 0)
            {
                printf("!SrDisableVolume failed %d\n", Error);
            }
            else
            {
                printf("-SrDisableVolume\n");
            }

            break;

        };

        

    }

    CloseHandle(ControlHandle);

    //
    // wait for our thread to die
    //
    
    while (Shutdown < 2)
        Sleep(0);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\test\srtest\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <conio.h>

//
// need to use this with FILE_DISPOSITION_INFORMATION
//

#undef DeleteFile

#include <srapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\chglog\chglog.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    chglog.cpp
 *
 *  Abstract:
 *    Tool for enumerating the change log - forward/reverse
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  04/09/2000
 *        created
 *
 *****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "srapi.h"
#include <shellapi.h>
#include "enumlogs.h"
#include "srrpcapi.h"
#include <dbgtrace.h>

struct _EVENT_STR_MAP
{
    DWORD   EventId;
    LPWSTR  pEventStr;
} EventMap[ 13 ] =
{
    {SrEventInvalid ,       L"INVALID    " },
    {SrEventStreamChange,   L"FILE-MODIFY" },
    {SrEventAclChange,      L"ACL-CHANGE " },
    {SrEventAttribChange,   L"ATTR-CHANGE" },
    {SrEventStreamOverwrite,L"FILE-MODIFY" },
    {SrEventFileDelete,     L"FILE-DELETE" },
    {SrEventFileCreate,     L"FILE-CREATE" },
    {SrEventFileRename,     L"FILE-RENAME" },
    {SrEventDirectoryCreate,L"DIR-CREATE " },
    {SrEventDirectoryRename,L"DIR-RENAME " },
    {SrEventDirectoryDelete,L"DIR-DELETE " },
    {SrEventMountCreate,    L"MNT-CREATE " },
    {SrEventMountDelete,    L"MNT-DELETE " }
};

LPWSTR
GetEventString(
    DWORD EventId
    )
{
    LPWSTR pStr = NULL;
    static WCHAR EventStringBuffer[8];

    for( int i=0; i<sizeof(EventMap)/sizeof(_EVENT_STR_MAP);i++)
    {
        if ( EventMap[i].EventId == EventId )
        {
            pStr = EventMap[i].pEventStr;
        }
    }

    if (pStr == NULL)
    {
        pStr = &EventStringBuffer[0];
        wsprintf(pStr, L"0x%X", EventId);
    }

    return pStr;
}


void __cdecl
main()
{
    DWORD       dwTargetRPNum = 0;
    LPWSTR *    argv = NULL;
    int         argc;
    HGLOBAL     hMem = NULL;
    BOOL        fSwitch = TRUE;
    BOOL        fForward = TRUE;
    BOOL        fExtended = FALSE;
    DWORD       dwRc;

    InitAsyncTrace();

    argv = CommandLineToArgvW(GetCommandLine(), &argc);

    if (! argv)
    {
        printf("Error parsing arguments");
        goto done;
    }
    
    if (argc < 2)
    {
        printf("Usage: chglog <drive> <extended=0> <forward=1/0> <RPNum> <Switch=1/0>");
        goto done;
    }
    
    if (argc >= 3)
    {
        fExtended = _wtoi(argv[2]);
    }
    
    if (argc >= 4)
    {
        fForward = _wtoi(argv[3]);
    }

    if (argc >= 5)
    {
        dwTargetRPNum = (DWORD) _wtol(argv[4]);
    }

    if (argc >= 6)
    {
        fSwitch = _wtoi(argv[5]);
    }

    {    
        if (fSwitch)
        {
            dwRc = SRSwitchLog();
            if (ERROR_SUCCESS != dwRc)
            {
                printf("! SRSwitchLog : %ld", dwRc);
                goto done;
            }
        }

        CChangeLogEntryEnum ChangeLog(argv[1], fForward, dwTargetRPNum, fSwitch);
        CChangeLogEntry     cle;
    
        if (ERROR_SUCCESS != ChangeLog.FindFirstChangeLogEntry(cle))
        {
            printf("No change log entries");
            goto done;
        }    

        do 
        {
            if (fExtended)
            {
                printf(
                    "%08I64ld\t%S\tFlags=%08d\tAttr=%08d\tAcl=%S\tProcess=%S\tPath1=%S\tPath2=%S\tTemp=%S\tShortName=%S\n", 
                    cle.GetSequenceNum(), 
                    GetEventString(cle.GetType()),
                    cle.GetFlags(),
                    cle.GetAttributes(), 
                    cle.GetAcl() ? L"Yes" : L"No",
                    cle.GetProcess() ? cle.GetProcess() : L"null",
                    cle.GetPath1() ? cle.GetPath1() : L"null",
                    cle.GetPath2() ? cle.GetPath2() : L"null",
                    cle.GetTemp() ? cle.GetTemp() : L"null",
                    cle.GetShortName() ? cle.GetShortName() : L"null");
            }
            else
            {
                printf(
                    "%08I64d\t%S\t%S\t%S\t%S\t%S\n", 
                    cle.GetSequenceNum(), 
                    GetEventString(cle.GetType()),
                    cle.GetProcess() ? cle.GetProcess() : L"null",                    
                    cle.GetPath1() ? cle.GetPath1() : L"null",
                    cle.GetPath2() ? cle.GetPath2() : L"null",
                    cle.GetTemp() ? cle.GetTemp() : L"null");
            }
                
            dwRc = ChangeLog.FindNextChangeLogEntry(cle);        
                
        }   while (dwRc == ERROR_SUCCESS);

        if (argc == 7 && 0 == lstrcmpi(argv[6], L"lock")) 
            getchar();
            
        ChangeLog.FindClose();
    }

done:
    if (argv) hMem = GlobalHandle(argv);
    if (hMem) GlobalFree(hMem);

    TermAsyncTrace();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\test\srclient\main.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:

    simple bvt-like test code for SR.SYS.

Author:

    Paul McDaniel (paulmcd)     07-Mar-2000

Revision History:

--*/


#include "precomp.h"
#include "stdlib.h"

void __cdecl main(int argc, char **argv)
{
    char    sz[1024];
    HANDLE  TestFile;
    ULONG   Length;
    BOOL    b;
    ULONG   Disposition = 0;
    ULONG   ShareMode = 0;
    ULONG   DesiredAccess = GENERIC_WRITE|GENERIC_READ;

    if (argc < 3)
    {
        printf("usage:\n\tsrclient.exe filename [op] [share_mode] [disposition] \n");
        printf("\t\t0=WriteFile\n\t\t1=MapViewOfFile\n\t\t2=hold_open\n\t\t3=GetFileAttributesEx\n\t\t4=NtLockFile\n");
        return;
    }

    printf("performing %s on %s\n", argv[2], argv[1]);

    if (argv[2][0] == '0')
        Disposition = CREATE_ALWAYS;
    else if (argv[2][0] == '1')
        Disposition = OPEN_ALWAYS;
    else if (argv[2][0] == '2' || argv[2][0] == '4')
    {
        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
        DesiredAccess = GENERIC_READ;
        Disposition = OPEN_EXISTING;
    }
    else if (argv[2][0] == '3')
    {
        WIN32_FILE_ATTRIBUTE_DATA AttribData;

        GetFileAttributesEx(argv[1], GetFileExInfoStandard , &AttribData);

        printf("attribs = 0x%X\n", AttribData.dwFileAttributes);
        return;
    }
    else
    {
        printf("unknown code\n");
        return;
    }

    if (argc >= 4)
    {
        ShareMode = atoi(argv[3]);
    }

    if (argc >= 5)
    {
        Disposition = atoi(argv[4]);
    }

    printf ("share=%d,disposition=%d\n", ShareMode, Disposition);
    
    TestFile = CreateFile( argv[1],
                           DesiredAccess,
                           ShareMode,
                           NULL,
                           Disposition,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );
                    
    if (TestFile == INVALID_HANDLE_VALUE)
    {
        printf("CreateFile failed 0x%X\n", GetLastError());
        return;
    }

    Length = wsprintf(sz, "This is a test file");

    if (argv[2][0] == '1')
    {
        HANDLE FileMapping;
        PVOID pFileMap;
        
        FileMapping = CreateFileMapping( TestFile, 
                                         NULL, 
                                         PAGE_READWRITE, 
                                         0, 
                                         19, 
                                         NULL );

        if (FileMapping == NULL)
        {
            printf("CreateFileMapping failed 0x%X\n", GetLastError());
            return;
        }

        pFileMap = MapViewOfFile(FileMapping, FILE_MAP_WRITE, 0, 0, 19);
        if (pFileMap == NULL)
        {
            printf("MapViewOfFile failed 0x%X\n", GetLastError());
            return;
        }

        CopyMemory(pFileMap, sz, Length);

        if (UnmapViewOfFile(pFileMap) == FALSE)
        {
            printf("UnmapViewOfFile failed 0x%X\n", GetLastError());
            return;
        }

        CloseHandle(FileMapping);
    }
    else if (argv[2][0] == '0')
    {

        b = WriteFile( TestFile,
                       sz,
                       Length,
                       &Length,
                       NULL );


        if (b == FALSE)
        {
            printf("WriteFile failed 0x%X\n", GetLastError());
            return;
        }
    }
    else if (argv[2][0] == '2')
    {
        //
        // wait forever
        //

        printf("holding the file open...[ctl-c to break]\n");
        Sleep(INFINITE);
    }
    else if (argv[2][0] == '4')
    {
        LARGE_INTEGER ByteOffset;
        LARGE_INTEGER Length;
        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;
        
        //
        // lock the first byte of the file
        //

        ByteOffset.QuadPart = 0;
        Length.QuadPart = -1;

        Status = NtLockFile( TestFile, 
                             NULL, 
                             NULL,
                             NULL,  // ApcContext OPTIONAL,
                             &IoStatusBlock, 
                             &ByteOffset,
                             &Length,
                             1,     // Key
                             FALSE, // FailImmediately
                             TRUE );   // Exclusive

        if (NT_SUCCESS(Status) == FALSE)
        {
            printf("NtLockFile failed 0x%X\n", Status);
            return;
        }
        
        //
        // wait forever
        //

        printf("holding the file open locked...[ctl-c to break]\n");
        Sleep(INFINITE);
    }

    printf("success\n");    
    CloseHandle(TestFile);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\flbuild\stubs.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <srconfig.h>
#include <utils.h>
#include <respoint.h>
#include <srapi.h>
#include <evthandler.h>
#include <enumlogs.h>
#include <ntservice.h>

CEventHandler * g_pEventHandler = NULL;
CSRConfig * g_pSRConfig = NULL;
CNTService * g_pSRService = NULL;

DWORD CEventHandler::SRUpdateMonitoredListS (LPWSTR pszXMLFile)
{
    return 0;
}

void CEventHandler::RefreshCurrentRp (BOOL fScanAllDrives)
{
}

void CNTService::LogEvent(WORD wType, DWORD dwID,
                  void * pRawData,
                  DWORD dwDataSize,
                  const WCHAR* pszS1,
                  const WCHAR* pszS2,
                  const WCHAR* pszS3)
{
}

DWORD PatchComputePatch(
    LPCWSTR pszCurrentDir)
{
    return ERROR_SUCCESS;
}

DWORD
PatchGetPatchWindow()
{
    return ERROR_SUCCESS;
}

DWORD 
PatchGetReferenceRpNum(
    DWORD  dwCurrentRp) 
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\fldump\blob.c ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    blob.c
 *
 *  Abstract:
 *    This file contains the implementation for r0 blob functions.
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#define  RING3

#include "common.h"
#include "pathtree.h"

static char * blobTypArr[] = {
    "BLOB_TYPE_CONFIG", 
    "BLOB_TYPE_PATHTREE",  
    "BLOB_TYPE_HASHLIST", 
    "BLOB_TYPE_CONTAINER" 
};

#define PRINT_BLOB_HEADER( pBlob ) \
    printf( "\nBlob: %s, Size: %ld, Version: %ld, Entries: %ld \n",\
    blobTypArr[((BlobHeader *)pBlob)->m_dwBlbType], \
    ((BlobHeader *)pBlob)->m_dwMaxSize, \
    ((BlobHeader *)pBlob)->m_dwVersion, \
    ((BlobHeader *)pBlob)->m_dwEntries) 

#define COMMON_FILE_HANDLE HANDLE

static __inline COMMON_FILE_HANDLE 
COMMON_FILE_OPEN_READ (
    PCHAR szFileName
)
{
    COMMON_FILE_HANDLE handle;

    handle = CreateFile( szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); 

    if( handle != INVALID_HANDLE_VALUE )
         return handle;

    return 0;
}

static __inline COMMON_FILE_HANDLE 
COMMON_FILE_OPEN_WRITE (
    PCHAR szFileName
)
{
    COMMON_FILE_HANDLE handle;

    handle = CreateFile( szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); 

    if( handle != INVALID_HANDLE_VALUE )
         return handle;

    return 0;
}

static __inline VOID 
COMMON_FILE_CLOSE (
    COMMON_FILE_HANDLE fh)
{
    if ( fh )    
         CloseHandle( fh );
}

static __inline DWORD 
COMMON_FILE_READ (
    COMMON_FILE_HANDLE fh,
    DWORD offset,
    VOID *buffer,
    DWORD dwBytes
)
{
    DWORD dwBytesRead = 0;

    ReadFile( fh, buffer, dwBytes, &dwBytesRead, NULL );

    return dwBytesRead;
}

static __inline DWORD 
COMMON_FILE_WRITE (
    COMMON_FILE_HANDLE fh,
    DWORD offset,
    VOID *buffer,
    DWORD dwBytes
)
{
    DWORD dwBytesWrite = 0;

    WriteFile( fh, buffer, dwBytes, &dwBytesWrite, NULL );

    return dwBytesWrite;
}

PBYTE 
CreateBlobFromFile( 
    PCHAR pszBlob );

DWORD 
CreateCfgBlob( 
    PCHAR pszBlob, 
    PCHAR pszTree, 
    PCHAR pszList );

PBYTE 
ReadCfgBlob( 
    PCHAR pszBlob, 
    PBYTE * pTree, 
    PBYTE * pList,
    DWORD * pdwDefaultType);

//
// WriteBlobToFile : Writes the given memory blob into the file.
//

DWORD 
WriteBlobToFile ( 
    PCHAR pszBlob,
    PBYTE pBlob
)
{
    COMMON_FILE_HANDLE fh;
    BlobHeader * pBlobHeader = (BlobHeader *)pBlob;

    fh = COMMON_FILE_OPEN_WRITE( pszBlob )  ;

    if ( fh )
    {
        COMMON_FILE_WRITE( fh, 0, pBlob, pBlobHeader->m_dwMaxSize );
        COMMON_FILE_CLOSE( fh );
        return BLOB_MAXSIZE( pBlob );
    }

    return 0;
}

//
// CreateBlobFromFile: This function reads a given file into memory as
// a blob.
//

PBYTE
CreateBlobFromFile( 
    PCHAR szBlobFile 
    )
{
    BYTE * pBlob = NULL  ;
    COMMON_FILE_HANDLE fh;
    BlobHeader blobHeader;

    fh = COMMON_FILE_OPEN_READ( szBlobFile );

    //
    // TODO : Need to do sanity checking on the dat file.
    // 

    if( fh )
    {
        if( COMMON_FILE_READ( fh, 0, &blobHeader, sizeof(blobHeader) ) )
        {
            pBlob = ALLOCATE( blobHeader.m_dwMaxSize );

#ifdef RING3
            // 
            // BUGBUG : need to reset file pointer
            //

            COMMON_FILE_CLOSE( fh );
            fh = COMMON_FILE_OPEN_READ( szBlobFile );
#endif

            if(pBlob)
            {
                 COMMON_FILE_READ(  fh, 0, pBlob, blobHeader.m_dwMaxSize );
            }
        }

        COMMON_FILE_CLOSE(fh);
    }

    return pBlob;
}

//
// ReadCfgBlob: Reads the given file a returns pointers to the
//    Incl/Excl tree blob and the hashed list of extensions.
//


BYTE * 
ReadCfgBlob( 
    PCHAR pszBlob, 
    PBYTE * pTree, 
    PBYTE * pList,
    DWORD * pdwDefaultType
    )
{
    BYTE * pBlob = NULL;

    if( !pszBlob || !pTree || !pList || !pdwDefaultType )
         return NULL;

    *pTree = *pList = NULL;

    if( pBlob = CreateBlobFromFile( pszBlob ) )
    {
        *pTree = pBlob  + sizeof(BlobHeader);
        *pList = *pTree + BLOB_MAXSIZE( *pTree );

        *pdwDefaultType = TREE_HEADER((*pTree))->m_dwDefault;
    }     

    return pBlob;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\flbuild\flbuild.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    flbuild.cpp

Abstract:

    this file uses filelist.lib to build a dat file from xml file

Author:

    Kanwaljit Marok (kmarok)     01-May-2000

Revision History:

--*/

#include "flstructs.h"
#include "flbuilder.h"

#ifdef _ASSERT
#undef _ASSERT
#endif

#include <dbgtrace.h>

#ifdef THIS_FILE

#undef THIS_FILE

#endif

static char __szTraceSourceFile[] = __FILE__;

#define THIS_FILE __szTraceSourceFile


#define TRACE_FILEID  0
#define FILEID        0

int _cdecl main(int argc, char* argv[])
{
    INT returnCde = 0;

    CFLDatBuilder datbuild;

    InitAsyncTrace();

    if( argc != 3 )
    {
        fprintf(stderr, "usage: %s <in.xml> <out.dat>\n", argv[0]);
        returnCde = 1;
    }
    else
    {
        LPTSTR pFileList, pDatFile;

#ifdef UNICODE

        TCHAR tFileList[MAX_PATH];
        TCHAR tDatFile[MAX_PATH];

        MultiByteToWideChar(
           CP_ACP,
           0,
           argv[1],
           -1,
           tFileList,
           sizeof(tFileList)/sizeof(TCHAR)
           );
          
        MultiByteToWideChar(
           CP_ACP,
           0,
           argv[2],
           -1,
           tDatFile,
           sizeof(tDatFile)/sizeof(TCHAR)
           );
          
        pFileList = tFileList;
        pDatFile  = tDatFile;

#else
        pFileList = argv[1];
        pDatFile  = argv[2];
#endif

       if( !datbuild.BuildTree(pFileList, pDatFile) )
       {
           fprintf(stderr, "Error building dat\n");
           returnCde = 1;
       }
    }

    return returnCde;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\dumpmap\dumpmap.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "restmap.h"
#include "shellapi.h"
#include <stdio.h>
#include <stdlib.h>

struct _EVENT_STR_MAP
{
    DWORD   EventId;
    LPWSTR  pEventStr;
} EventMap[ 12 ] =
{
    {SrEventInvalid ,       L"INVALID    " },
    {SrEventStreamChange,   L"FILE-MODIFY" },
    {SrEventAclChange,      L"ACL-CHANGE " },
    {SrEventAttribChange,   L"ATTR-CHANGE" },
    {SrEventStreamOverwrite,L"FILE-MODIFY" },
    {SrEventFileDelete,     L"FILE-DELETE" },
    {SrEventFileCreate,     L"FILE-CREATE" },
    {SrEventFileRename,     L"FILE-RENAME" },
    {SrEventDirectoryCreate,L"DIR-CREATE " },
    {SrEventDirectoryRename,L"DIR-RENAME " },
    {SrEventDirectoryDelete,L"DIR-DELETE " },
    {SrEventMaximum,        L"INVALID-MAX" }
};

LPWSTR
GetEventString(
    DWORD EventId
    )
{
    LPWSTR pStr = L"NOT-FOUND";

    for( int i=0; i<sizeof(EventMap)/sizeof(_EVENT_STR_MAP);i++)
    {
        if ( EventMap[i].EventId == EventId )
        {
            pStr = EventMap[i].pEventStr;
        }
    }

    return pStr;
}

void
PrintUsage()
{
    printf("Usage: restmap <option>");
    printf("\n                 1 = dumpmap [filename]");
    printf("\n                 2 = createmap <filename> <drive> <RPNum>");
}



void
PrintRestoreMap(LPWSTR pszFileName)
{
    RestoreMapEntry *prme = NULL;
    HANDLE          hFile;
    LPWSTR          pszSrc, pszDest, pszTemp;
    LPBYTE          pbAcl = NULL;
    
    hFile = CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        goto Err;

    while (ERROR_SUCCESS == ReadRestoreMapEntry(hFile, &prme))
    {
        GetPaths(prme, &pszSrc, &pszTemp, &pszDest, &pbAcl);
        printf("\n%S\tAttr=%08d\tAcl=%S\tSrc=%S\tTmp=%S\tDest=%S\tAcl=%S",
                GetEventString(prme->m_dwOperation),
                prme->m_dwAttribute,
                (prme->m_cbAcl > 0) ? L"Yes" : L"No",
                pszSrc,
                pszTemp ? pszTemp : L"",
                pszDest ? pszDest : L"",
                pbAcl ? (prme->m_fAclInline ? L"inline" : (LPWSTR) pbAcl) : L"");
    }    

    FreeRestoreMapEntry(prme);

    CloseHandle(hFile);

Err:
    return;
}



void __cdecl
main()
{
    LPWSTR *    argv = NULL;
    int         argc;
    HGLOBAL     hMem = NULL;
    HANDLE      hFile = NULL;
    int         option;

    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (! argv)
    {
        printf("Error parsing arguments");
        goto done;
    }    
    if (argc < 2)
    {
        PrintUsage();
        goto done;
    }
    
    option = _wtoi(argv[1]);
    switch (option)
    {
    case 1:
        PrintRestoreMap(argv[2]);        
        break;

    case 2:
        if (argc != 5)
        {
            PrintUsage();
            goto done;
        }
        
        hFile = CreateFile(argv[2], GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            printf("CreateRestoreMap...DWORD %ld", CreateRestoreMap(argv[3], _wtoi(argv[4]), hFile));
            CloseHandle(hFile);
        }
        else
            printf("Error creating file");
        break;

    default:
        PrintUsage();
        goto done;
        break;
    }

done:
    if (argv) hMem = GlobalHandle(argv);
    if (hMem) GlobalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\fldump\fldump.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    fldump.c

Abstract:

    this file dumps the contents of the dat file in readable form

Author:

    Kanwaljit Marok (kmarok)     01-May-2000

Revision History:

--*/

#define RING3 

#include "common.h"
#include "pathtree.h"
#include "hashlist.h"

//
// INCLUDE the common  source files from kernel directory
//

#define _PRECOMP_H_ // don't include the sr\kernel precomp header

#include "ptree.c"
#include "hlist.c"
#include "blob.c"
#include "verifyBlob.c"

static char * nodeTypArr[] = {
    "UNKNOWN", 
    "INCLUDE",  
    "EXCLUDE", 
};

//
// GetNodeTypeStr : Returns node type string
//

PCHAR 
GetNodeTypeStr( 
    INT iNodeType 
    )
{
    return nodeTypArr[ iNodeType ];
}

//
// Ring 3 test code routines begin here
//

VOID 
PrintList( 
    PBYTE pList, 
    INT   iNode, 
    INT levelIn 
    )
{
    while ( iNode )
    { 
        ListEntry * node = LIST_NODEPTR(pList, iNode);
        INT  cbChars =  (*(wchar_t*)( pList + node->m_dwData ) - 2)/2;   
        INT  level = levelIn;

        while( level-- )
             printf("   ");

        printf("   - %*.*S (%d, %d, %8.8s)\n",
            cbChars, cbChars,
            pList + node->m_dwData + sizeof(wchar_t),
            iNode,
            *(wchar_t*)( pList + node->m_dwData ),
            GetNodeTypeStr(node->m_dwType));

        iNode = node->m_iNext;
    }
}

//
// This functions formats and prints the list
//

VOID 
PrintListFormatted( 
    PBYTE pList, 
    INT   level 
    )
{
    if( pList )
    {
        INT i;

        for( i=0; i<(INT)LIST_HEADER(pList)->m_iHashBuckets; i++ )
        {
            INT iNode;

            if( (iNode = HASH_BUCKET(pList, i) ) == 0 ) 
                continue;

            PrintList( pList, iNode, level );
        }
    }
}

//
// PrintNode: Prints out a node in proper format depending on level.
//

VOID 
PrintNode(
    PBYTE pTree, 
    INT   iNode, 
    INT   levelIn 
    )
{
    TreeNode * node = TREE_NODEPTR(pTree, iNode);
    INT  cbChars =  (*(wchar_t*)( pTree + node->m_dwData ) - sizeof(wchar_t))/sizeof(wchar_t);   
    INT  level = levelIn;

    while( level-- )
        printf("   ");

    printf("%*.*S (%d, %d, %8.8s, 0x%8.8X)\n",
        cbChars, cbChars,
        pTree + node->m_dwData + sizeof(wchar_t),
        iNode,
        *(wchar_t*)( pTree + node->m_dwData ),
        GetNodeTypeStr(node->m_dwType),
        node->m_dwFlags 
        );

    if( node->m_dwFileList )
        PrintListFormatted( pTree + node->m_dwFileList, levelIn );

}

//
// PrintTreeFormatted: prints out the tree blod in readable form
//

VOID PrintTreeFormatted( 
    PBYTE pTree, 
    INT   iNode, 
    INT  *pLevel )
{
    TreeNode * node = TREE_NODEPTR(pTree, iNode);

    PrintNode( pTree, iNode, *pLevel );

    (*pLevel)++; 

    if(node->m_iSon)
    {   
        TreeNode * son = TREE_NODEPTR(pTree, node->m_iSon);
        INT iSonSibling = son->m_iSibling;
        PrintTreeFormatted(pTree, node->m_iSon, pLevel);

        while(iSonSibling)
        {
            TreeNode * sonSibling = TREE_NODEPTR(pTree, iSonSibling);
            PrintTreeFormatted(pTree, iSonSibling, pLevel);
            iSonSibling = sonSibling->m_iSibling;
        }
    }

    (*pLevel)--;

}


//
// TestLookup : This function tests a sample lookup
//

VOID TestLookup( 
    PBYTE pTree, 
    PBYTE pList 
    )
{
    INT    i = 0;
    INT    iNode  = -1;
    INT    iType  = 0;
    INT    iLevel = 0;
    INT    iDrive = DRIVE_INDEX(L'C');
    BOOL   fFileMatch = FALSE;

    BYTE  pPathTmp[ MAX_PPATH_SIZE ];
    LPWSTR pLookupStr = NULL;
    PUNICODE_STRING pUStr = NULL;


	if ( !pTree )
    {
        goto Exit;
    }

    printf("\n\nTesting some sample lookups in the tree.\n\n\n" );

    pLookupStr = L"\\device\\harddiskVolume1\\Winnt\\system32";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not found .\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    iLevel = iType= 0;

    //
    // Test File match
    //

    pLookupStr = L"\\device\\harddiskVolume1\\Winnt\\system32\\mshtml.tlb";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not Found.\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    iLevel = iType= 0;

    //
    // Test File match
    //

    pLookupStr = L"\\??\\d:\\sr-wstress\\RF_0_7742.dll";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not Found.\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }
    iLevel = iType= 0;

    //
    // Test a wildcard in the path
    //

    pLookupStr = L"\\device\\harddiskVolume1\\wildcards\\kmarok\\xyz";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not Found .\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    //
    // Test a wildcard in the path
    //

    pLookupStr = L"\\device\\harddiskVolume1\\wildcards\\kmarok";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not Found .\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    iLevel = iType= 0;

    //
    // Test a wildcard in the path
    //

    pLookupStr = L"\\device\\harddiskVolume1\\wildcards\\kmarok\\abc";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not Found .\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    iLevel = iType= 0;

    //
    // Test a root level path
    //

    pLookupStr = L"\\device\\harddiskVolume1\\boot.ini"; 

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not found .\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    //
    // test a failure
    //

    iLevel = iType= 0;

    pLookupStr = L"\\device\\harddiskVolume1\\Winnt\\system320";

    if ( ConvertToParsedPath(
            pLookupStr, 
            (USHORT)lstrlenW(pLookupStr), 
            pPathTmp, 
            sizeof(pPathTmp)) )
    {
       printf("Looking up : %S\n\t", pLookupStr);

       if( MatchPrefix( 
               pTree, 
               TREE_ROOT_NODE, 
               ((path_t)pPathTmp)->pp_elements, 
               &iNode, 
               &iLevel, 
               &iType, 
               NULL, 
               &fFileMatch) )
        {
            printf("Found. N:%d L:%d T:%d\n", iNode, iLevel, iType);
        }
        else
        {
            printf("Not found .\n");
        }
    }
    else
    {
        printf( "ConvertToParsedPath Not found\n");
    }

    //
    // Test extension match
    //

    pLookupStr = L"PWERPNT.INI";

    pUStr = (PUNICODE_STRING)pPathTmp;
    pUStr->Buffer = (PWCHAR)(pUStr + 1); 
    pUStr->Length = (USHORT)(lstrlenW(pLookupStr) * sizeof(WCHAR));
    pUStr->MaximumLength = pUStr->Length;
    RtlCopyMemory( pUStr->Buffer, pLookupStr, pUStr->Length );
    pUStr->Buffer[lstrlenW(pLookupStr)] = UNICODE_NULL;

    {
       printf("Looking up : %S\n\t", pLookupStr);

        if( MatchExtension(
                pList, 
                pUStr, 
                &iType, 
                &fFileMatch ) )
        {
            printf("Found. T:%d, HasExtension :%d\n", iType, fFileMatch);
        }
        else
        {
            printf("Not found .\n");
        }
    }

    //
    // Test extension match
    //

    pLookupStr = L"PWERPNT.ini";

    pUStr = (PUNICODE_STRING)pPathTmp;
    pUStr->Buffer = (PWCHAR)(pUStr + 1); 
    pUStr->Length = (USHORT)(lstrlenW(pLookupStr) * sizeof(WCHAR));
    pUStr->MaximumLength = pUStr->Length;
    RtlCopyMemory( pUStr->Buffer, pLookupStr, pUStr->Length );
    pUStr->Buffer[lstrlenW(pLookupStr)] = UNICODE_NULL;

    {
       printf("Looking up : %S\n\t", pLookupStr);

        if( MatchExtension(
                pList, 
                pUStr,
                &iType, 
                &fFileMatch ) )
        {
            printf("Found. T:%d, HasExtension :%d\n", iType, fFileMatch);
        }
        else
        {
            printf("Not found .\n");
        }
    }

    //
    // Test extension match
    //

    pLookupStr = L"PWERPNT";

    pUStr = (PUNICODE_STRING)pPathTmp;
    pUStr->Buffer = (PWCHAR)(pUStr + 1); 
    pUStr->Length = (USHORT)(lstrlenW(pLookupStr) * sizeof(WCHAR));
    pUStr->MaximumLength = pUStr->Length;
    RtlCopyMemory( pUStr->Buffer, pLookupStr, pUStr->Length );
    pUStr->Buffer[lstrlenW(pLookupStr)] = UNICODE_NULL;

    {
       printf("Looking up : %S\n\t", pLookupStr);

        if( MatchExtension(
                pList, 
                pUStr, 
                &iType, 
                &fFileMatch ) )
        {
            printf("Found. T:%d, HasExtension :%d\n", iType, fFileMatch);
        }
        else
        {
            printf("Not found .\n");
        }
    }

Exit:

    return; 
}

//
// Main function
//

int __cdecl 
main( 
    int argc, 
    char * argv[] 
    )
{
    BYTE *pBlob, *pTree=NULL, *pList=NULL;
    BOOL fFound = FALSE;
    PCHAR pszFileName   = "filelist.dat";
    DWORD dwDefaultType = NODE_TYPE_UNKNOWN;

    if( argc !=  1 )
    {
        if( argc >= 2 && !strcmp( argv[1], "-t" ))
        {
            fFound = TRUE;
        }

        if( argc == 2 )
        {
            if( !fFound )
               pszFileName = argv[1];

            goto cont;
        }

        if( argc == 3 && fFound )
        {
            pszFileName = argv[2];
            goto cont;
        }

        printf("USAGE: %s [-t] [filename] \n\n ", argv[0]);
        return 0;
    }

cont:

    if( pBlob = ReadCfgBlob( pszFileName, &pTree, &pList, &dwDefaultType ) )
    {

        if (!VerifyBlob((DWORD_PTR)pBlob)) {

            printf("BLOB validation failed\n");
            return 1;
        }

        PRINT_BLOB_HEADER(pBlob);

        printf("Default NodeType : %s\n", GetNodeTypeStr(dwDefaultType) );

        if( pTree )
        {
            INT level = 0;
            PRINT_BLOB_HEADER ( pTree );
            PrintTreeFormatted( pTree, 0, &level );
        }

        if( pList )
        {
            INT level = 0;
            PRINT_BLOB_HEADER ( pList );
            PrintListFormatted( pList, 0 );
        }
    }
    else
        printf( "Error: Not found to load the %s.\n", pszFileName );

    if (fFound && pTree && pList)
    {
        TestLookup( pTree, pList );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\logdump\logdump.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    logdump.c

Abstract:

    this file implements functrionality to read and dump the sr logs

Author:

    Kanwaljit Marok (kmarok)     01-May-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#include "logfmt.h"
#include "srapi.h"


struct _EVENT_STR_MAP 
{
    DWORD EventId;
    PCHAR pEventStr;
} EventMap[ 13 ] = 
{
    {SrEventInvalid ,       "INVALID    " },
    {SrEventStreamChange,   "FILE-MODIFY" },
    {SrEventAclChange,      "ACL-CHANGE " },
    {SrEventAttribChange,   "ATTR-CHANGE" },
    {SrEventStreamOverwrite,"FILE-MODIFY" },
    {SrEventFileDelete,     "FILE-DELETE" },
    {SrEventFileCreate,     "FILE-CREATE" },
    {SrEventFileRename,     "FILE-RENAME" },
    {SrEventDirectoryCreate,"DIR-CREATE " },
    {SrEventDirectoryRename,"DIR-RENAME " },
    {SrEventDirectoryDelete,"DIR-DELETE " },
    {SrEventMountCreate,    "MNT-CREATE " },
    {SrEventMountDelete,    "MNT-DELETE " }
    
};
    

BYTE Buffer[4096];

PCHAR 
GetEventString( 
    DWORD EventId
    )
{
    PCHAR pStr = NULL;
    static CHAR EventStringBuffer[8];

    for( int i=0; i<sizeof(EventMap)/sizeof(_EVENT_STR_MAP);i++)
    {
        if ( EventMap[i].EventId == EventId )
        {
            pStr = EventMap[i].pEventStr;
        }
    }

    if (pStr == NULL)
    {
        pStr = &EventStringBuffer[0];
        wsprintf(pStr, "0x%X", EventId);
    }

    return pStr;
}

BOOLEAN
ProcessLogEntry(
    BOOLEAN bPrintDebug,
    LPCSTR pszSerNo, 
    LPCSTR pszSize, 
    LPCSTR pszEndSize, 
    LPCSTR pszSeqNo, 
    LPCSTR pszFlags, 
    LPCSTR pszProcess, 
    LPCSTR pszOperation, 
    LPCSTR pszAttr, 
    LPCSTR pszTmpFile, 
    LPCSTR pszPath1,
    LPCSTR pszPath2,
    LPCSTR pszAcl,
    LPCSTR pszShortName,
    LPCSTR pszProcessHandle,
    LPCSTR pszThreadHandle)
{
    BOOLEAN Status = TRUE;

    if( bPrintDebug == FALSE )
    {
	    printf( "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t",
            pszSerNo, 
            pszSize, 
            pszSeqNo, 
            pszOperation, 
            pszAttr,
            pszAcl,
            pszPath1,
            pszShortName);
    }
    else
    {
	    printf( "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t",
            pszSerNo, 
            pszSize, 
            pszSeqNo, 
            pszOperation, 
            pszAttr,
            pszProcess,
            pszProcessHandle,
            pszThreadHandle,
            pszAcl,
            pszPath1,
            pszShortName);
    }
 

    if(pszTmpFile)
    { 
	    printf( "%s\t", pszTmpFile);
    }

    if(pszPath2)
    { 
	    printf( "%s\t", pszPath2);
    }

    printf("\n");

    return Status;
}

#define SR_MAX_PATH ((1000) + sizeof (CHAR)) // Name will always be at most 1000 characters plus a NULL.

BOOLEAN
ReadLogData( 
    BOOLEAN bPrintDebugInfo,
    LPTSTR pszFileName 
    )
{
    BOOLEAN Status = FALSE;
    BOOLEAN bHaveDebugInfo = FALSE;

    HANDLE hFile;
    DWORD  nRead;
    DWORD  cbSize = 0, dwEntries = 0, dwEntriesAdded = 0;
    DWORD  dwSizeLow , dwSizeHigh;

    CHAR szSerNo  [10]; 
    CHAR szSize   [10]; 
    CHAR szEndSize[10]; 
    CHAR szSeqNo  [20]; 
    CHAR szOperation[50]; 
    CHAR szAttr[50]; 
    CHAR szFlags[10]; 
    PCHAR szPath1 = NULL; 
    PCHAR szPath2 = NULL;
    CHAR szTmpFile[MAX_PATH]; 
    CHAR szAcl[MAX_PATH]; 
    CHAR szShortName[MAX_PATH]; 
    CHAR szProcess[32]; 
    CHAR szProcessHandle[16]; 
    CHAR szThreadHandle[16]; 


    BYTE LogHeader[2048];

    PSR_LOG_HEADER pLogHeader = (PSR_LOG_HEADER)LogHeader;

    static INT s_dwEntries = -1;

    szPath1 = (PCHAR) LocalAlloc( LMEM_FIXED, SR_MAX_PATH );
    if (szPath1 == NULL )
  	{
  	  fprintf( stderr, "Insufficient memory\n" );
    }
 	
    szPath2 = (PCHAR) LocalAlloc( LMEM_FIXED, SR_MAX_PATH );
    if (szPath2 == NULL )
  	{
  	  fprintf( stderr, "Insufficient memory\n" );
    }

    hFile = CreateFile( 
                pszFileName, 
                GENERIC_READ, 
                FILE_SHARE_WRITE, 
                NULL,
                OPEN_EXISTING, 
                FILE_ATTRIBUTE_NORMAL, 
                NULL );

    if ( hFile != INVALID_HANDLE_VALUE )
    {
         PBYTE pLoc = NULL;

         dwSizeLow = GetFileSize( hFile, &dwSizeHigh );

         //
         // Read the header size
         //

         ReadFile( 
             hFile, 
             &cbSize, 
             sizeof(DWORD), 
             &nRead, 
             NULL );

         SetFilePointer( hFile, - (INT)sizeof(DWORD), NULL, FILE_CURRENT );

         //
         // Read the whole header entry
         //

         ReadFile( 
             hFile, 
             pLogHeader, 
             cbSize, 
             &nRead, 
             NULL );

         pLoc = (PBYTE)(&pLogHeader->SubRecords); 

         fprintf( stderr,
                  "Header Size: %ld,  Version: %ld,  Tool Version: %ld\n%S\n",
                  pLogHeader->Header.RecordSize, 
                  pLogHeader->LogVersion,
                  SR_LOG_VERSION,
                  (LPWSTR)(pLoc + sizeof(RECORD_HEADER)) );

         if( pLogHeader->LogVersion != SR_LOG_VERSION ||
             pLogHeader->MagicNum   != SR_LOG_MAGIC_NUMBER )
         {
             fprintf( stderr, "Invalid version or Corrupt log\n" );
             CloseHandle(hFile);
             goto End;
         }

         dwSizeLow -= pLogHeader->Header.RecordSize;

         SetFilePointer (hFile, 
                         pLogHeader->Header.RecordSize, 
                         NULL, 
                         FILE_BEGIN);

         //
         // Start reading the log entries
         //

         while( dwSizeLow )
         {
             PSR_LOG_ENTRY pLogEntry = (PSR_LOG_ENTRY)Buffer;

             ZeroMemory(pLogEntry, sizeof(Buffer));

             //
             // Read the size of the entry
             //

             if ( !ReadFile( 
                      hFile, 
                      &pLogEntry->Header.RecordSize, 
                      sizeof(DWORD), 
                      &nRead, 
                      NULL ) )
             {
                 break;
             }

             cbSize = pLogEntry->Header.RecordSize;

             if (cbSize == 0 )
             {
                 //
                 // Zero size indicates end of the log
                 //

                 break;
             }

             SetFilePointer( hFile, - (INT)sizeof(DWORD), NULL, FILE_CURRENT );

             //
             // Read the rest of the entry
             //

             if ( !ReadFile( hFile, 
                      ((PBYTE)pLogEntry), 
                      cbSize,
                      &nRead, 
                      NULL ) )
             {
                 break;
             }

             //
             // Check the magic number
             //
    
             if( pLogEntry->MagicNum != SR_LOG_MAGIC_NUMBER )
             {
                 fprintf(stderr, "Invalid Entry ( Magic num )\n");
                 break;
             }

             //
             // Read the entries in to the buffer
             //

             sprintf( szSerNo    , "%05d"    , dwEntries + 1);

             sprintf( szSize     , "%04d"    , pLogEntry->Header.RecordSize  );
             sprintf( szOperation, "%s"      , GetEventString(
                                                  pLogEntry->EntryType ));

             sprintf( szFlags    , "%08x"    , pLogEntry->EntryFlags );
             sprintf( szSeqNo    , "%010d"   , pLogEntry->SequenceNum);
             sprintf( szAttr     , "%08x"    , pLogEntry->Attributes );
             sprintf( szProcess  , "%12.12s" , pLogEntry->ProcName   );

             //
             // get the first path
             //

             PBYTE pLoc = (PBYTE)&pLogEntry->SubRecords;
             sprintf( szPath1  , "%S" , pLoc + sizeof(RECORD_HEADER) );

             if (pLogEntry->EntryFlags & ENTRYFLAGS_TEMPPATH)
             {
                 pLoc += RECORD_SIZE(pLoc);
                 sprintf( szTmpFile  , "%S" , pLoc + sizeof(RECORD_HEADER) );
             }
             else
             {
                 sprintf( szTmpFile  , "" );
             }

             if (pLogEntry->EntryFlags & ENTRYFLAGS_SECONDPATH)
             {
                 pLoc += RECORD_SIZE(pLoc);
                 sprintf( szPath2  , "%S" , pLoc + sizeof(RECORD_HEADER) );
             }
             else
             {
                 sprintf( szPath2  , "" );
             }

             if (pLogEntry->EntryFlags & ENTRYFLAGS_ACLINFO)
             {
                 ULONG AclInfoSize;

                 pLoc += RECORD_SIZE(pLoc);

                 AclInfoSize = RECORD_SIZE(pLoc);
                 sprintf( szAcl  , "ACL(%04d)%" , AclInfoSize );
             }
             else
             {
                 sprintf( szAcl  , "" );
             }

             if (pLogEntry->EntryFlags & ENTRYFLAGS_DEBUGINFO)
             {
                 bHaveDebugInfo = TRUE;
                 pLoc += RECORD_SIZE(pLoc);
                 sprintf( szProcess  , "%12.12s", 
                          ((PSR_LOG_DEBUG_INFO)pLoc)->ProcessName );

                 sprintf( szProcessHandle,"0x%08X",
                          ((PSR_LOG_DEBUG_INFO)pLoc)->ProcessId );

                 sprintf( szThreadHandle,"0x%08X",
                          ((PSR_LOG_DEBUG_INFO)pLoc)->ThreadId );
             }
             else
             {
                 bHaveDebugInfo = FALSE;
                 sprintf( szProcess  , "" );
                 sprintf( szThreadHandle  , "" );
                 sprintf( szProcessHandle , "" );
             }

             if (pLogEntry->EntryFlags & ENTRYFLAGS_SHORTNAME)
             {
                 pLoc += RECORD_SIZE(pLoc);
                 sprintf( szShortName  , "%S" , pLoc + sizeof(RECORD_HEADER) );
             }
             else
             {
                 sprintf( szShortName  , "" );
             }

             // 
             // read the trailing record size
             //

             sprintf( szEndSize , "%04d", GET_END_SIZE(pLogEntry));

             ProcessLogEntry(
                 bPrintDebugInfo && bHaveDebugInfo,
                 szSerNo, 
                 szSize, 
                 szEndSize, 
                 szSeqNo, 
                 szFlags, 
                 szProcess, 
                 szOperation, 
                 szAttr, 
                 szTmpFile, 
                 szPath1,
                 szPath2,
                 szAcl,
                 szShortName,
                 szProcessHandle,
                 szThreadHandle);

             dwEntries++;

             dwSizeLow -= cbSize;
             cbSize = 0;

         }

         CloseHandle( hFile );
         Status = TRUE;
    }
    else
    {
         fprintf( stderr, "Error opening LogFile %s\n", pszFileName );
    }

End:
    fprintf( stderr, "Number of entries read :%d\n", dwEntries );

    if (szPath1 != NULL)
    	LocalFree( szPath1 );

    if (szPath2 != NULL)
    	LocalFree( szPath2 );

    return Status;
}

INT 
__cdecl 
main( 
   int argc, 
   char *argv[] )
{
    if( argc < 2 || argc > 3 )
    {
        fprintf( stderr, 
                 "USAGE: %s [-d] <LogFile> \n\t -d : debug info\n", 
                 argv[0] );
    }
    else
    {
        int i = 1;
 
        if ( argc == 3 && !strcmp( argv[i], "-d" ) )
        {
             i++;
             ReadLogData(TRUE, argv[i] );
        }
        else
        {
             ReadLogData(FALSE, argv[i] );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\tools\rpctest\rpctest.cpp ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    rpcstest.cpp

Abstract:
    This file is a unit test for the SFP client api
    
Revision History:

    Brijesh Krishnaswami (brijeshk) - 06/29/99 - Created

********************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windows.h>
#include <shellapi.h>
#include <dbgtrace.h>
#include <stdio.h>
#include <stdlib.h>
#include "srrestoreptapi.h"
#include "srrpcapi.h"
#include "utils.h"
#include "srapi.h"
#include "wintrust.h"
#include "softpub.h"
#include "mscat.h"
#include "shlwapi.h"

void 
PrintUsage()
{
    printf("Usage: rpctest <option>");
    printf("\n                1 = EnableSR <volumename>");
    printf("\n                2 = DisableSR <volumename>");
    printf("\n                3 = EnableFIFO");
    printf("\n                4 = DisableFIFO <seqnum>");
    printf("\n                5 = SRSetRestorePoint [Description] [Rptype] [EvtType] [SeqNum]");
    printf("\n                6 = SRRemoveRestorePoint <seqnum>");
    printf("\n                7 = SRUpdateMonitoredList <filepath>");
    printf("\n                8 = SRFifo <volumename> <targetpercent>");
    printf("\n                9 = SRFifo <volumename> <targetpercent> -- fifo atleast one rp");
    printf("\n               10 = SRFifo <volumename> <targetRPNum>  -- include current rp");
    printf("\n               11 = SRFifo <volumename> <targetRPNum>  -- exclude current rp");    
    printf("\n               12 = SRFreeze <volumename>");
    printf("\n               13 = SRCompress <volumename>");
    printf("\n               14 = SRNotify <volumename> <freespace> <direction=1/0>");
    printf("\n               15 = Start/Stop Filter <1/0>");
    printf("\n               16 = ResetSR <volumename>");
    printf("\n               17 = SRUpdateDSSize <volumename> <newsize>");
    printf("\n               18 = SRSwitchLog");  
    printf("\n               19 = AddCatalogToCryptoDB <catfilename> <fullpath>");
    printf("\n               20 = RemoveCatalogFromCryptoDB <catfilename>");    
    printf("\n               21 = SRPrintState -- dump state to %%windir%%\\temp\\sr.txt and debugger");
    printf("\n               22 = TestDriveRestore <oldsystemhivepath>"); 
    printf("\n               25 = SRRegisterSnapshotCallback <dllfullpath>"); 
    printf("\n               26 = SRUnregisterSnapshotCallback <dllfullpath>");     
    printf("\n               27 = EnableSREx <volumename> <fWait>");     
    printf("\n<volumename> must be specified as \"C:\\\" etc.");
}


// this calls the Crypto API to add a catalog to the Crypto DB
 
DWORD 
AddCatalogToCryptoDB(LPCWSTR pszCatName, LPCWSTR pszCatPath)
{
    DWORD       dwErr = ERROR_SUCCESS;
    HCATADMIN   hCatAdmin = NULL;
    HCATINFO    hCatInfo = NULL;
    GUID        DriverVerifyGuid = DRIVER_ACTION_VERIFY;
    
    TraceFunctEnter("AddCatalogToCryptoDB");
    
    if (!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0))
    {
        dwErr = GetLastError();
        ErrorTrace(0, "CryptCATAdminAcquireContext() failed, ec=%d",
                   dwErr);
        goto Err;
    }
                    
    hCatInfo= CryptCATAdminAddCatalog(hCatAdmin,
                                      (LPWSTR) pszCatPath,  // path of the temp cat file
                                      (LPWSTR) pszCatName,           // name of the cat file
                                      0); // No Flags
    if (NULL == hCatInfo)
    {
        dwErr = GetLastError();
        DebugTrace(0, "CryptCATAdminAddCatalog() failed, ec=%d",
                   dwErr);
        goto Err;        
    }
    
    
Err:
    if (NULL != hCatInfo)
    {
        CryptCATAdminReleaseCatalogContext(hCatAdmin,
                                           hCatInfo,
                                           0); // no flags
    }
    if (NULL != hCatAdmin)
    {
        CryptCATAdminReleaseContext(hCatAdmin,
                                    0); // no flags
    }
    
    TraceFunctLeave();
    return dwErr;    
}



// this calls the Crypto API to remove a catalog from the Crypto DB
 
DWORD 
RemoveCatalogFromCryptoDB(LPCWSTR pszCatName)
{
    DWORD       dwErr = ERROR_SUCCESS;
    HCATADMIN   hCatAdmin = NULL;
    HCATINFO    hCatInfo = NULL;
    GUID        DriverVerifyGuid = DRIVER_ACTION_VERIFY;
    
    TraceFunctEnter("RemoveCatalogFromCryptoDB");
    
    if (!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0))
    {
        dwErr = GetLastError();
        ErrorTrace(0, "CryptCATAdminAcquireContext() failed, ec=%d",
                   dwErr);
        goto Err;
    }           
        
    if (FALSE == CryptCATAdminRemoveCatalog(hCatAdmin,
                                            (LPWSTR) pszCatName,
                                            0)) // No Flags
    {
        dwErr = GetLastError();
        DebugTrace(0, "CryptCATAdminRemoveCatalog() failed, ec=%d",
                   dwErr);
        goto Err;        
    }
    
    
Err:
    if (NULL != hCatAdmin)
    {
        CryptCATAdminReleaseContext(hCatAdmin,
                                    0); // no flags
    }
    
    TraceFunctLeave();
    return dwErr;    
}

#define VALIDATE_DWRET(str) \
    if ( dwRet != ERROR_SUCCESS ) \
    { \
        ErrorTrace(0, "failed - %ld", dwRet); \
        goto done; \
    } \



DWORD
FindDriveMapping(HKEY hk, LPBYTE pSig, DWORD dwSig, LPWSTR pszDrive)
{
    DWORD dwIndex = 0;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwType, dwSize = MAX_PATH;
    BYTE  rgbSig[1024];
    DWORD cbSig = sizeof(rgbSig);
    LPCWSTR  cszErr;

    TENTER("FindDriveMapping");
    
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue( hk, 
                                 dwIndex++,
                                 pszDrive,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 rgbSig,
                                 &cbSig )))
    {
        if (0 == wcsncmp(pszDrive, L"\\DosDevice", 10))
        {  
            if (cbSig == dwSig &&
                (0 == memcmp(rgbSig, pSig, cbSig)))
                break;
        }
        dwSize = MAX_PATH;
        cbSig = sizeof(rgbSig);
    }

    TLEAVE();
    return dwRet;
}




DWORD
KeepMountedDevices(HKEY hkMount)
{
    HKEY    hkNew = NULL, hkOld = NULL;
    DWORD   dwIndex = 0;
    WCHAR   szValue[MAX_PATH], szDrive[MAX_PATH];
    BYTE    rgbSig[1024];
    DWORD   cbSig;
    DWORD   dwSize, dwType;
    DWORD   dwRet = ERROR_SUCCESS;
    LPCWSTR cszErr;

    TENTER("KeepMountedDevices");
    
    //
    // open the old and new MountedDevices
    //
    
    dwRet = ::RegOpenKey( hkMount, L"MountedDevices", &hkOld );
    VALIDATE_DWRET("::RegOpenKey");

    dwRet = ::RegOpenKey( HKEY_LOCAL_MACHINE, L"System\\MountedDevices", &hkNew );
    VALIDATE_DWRET("::RegOpenKey");

    //
    // enumerate the old devices 
    // delete volumes that don't exist in the new (i.e. current)
    //

    dwSize = MAX_PATH;
    cbSig = sizeof(rgbSig);
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue( hkOld, 
                                 dwIndex++,
                                 szValue,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 rgbSig,
                                 &cbSig )))
    {        
        if (0 == wcsncmp(szValue, L"\\??\\Volume", 10))
        {
            //
            // this is a Volume -> Signature mapping
            // check if the volume exists in the new 
            //
            
            trace(0, "Old Volume = %S", szValue);

            dwSize = sizeof(rgbSig);
            dwRet = RegQueryValueEx(hkNew, 
                                    szValue,
                                    NULL,
                                    &dwType,
                                    rgbSig,
                                    &dwSize);
            if (ERROR_SUCCESS != dwRet)
            {
                //
                // nope
                // so delete the volume and driveletter mapping from old
                //

                DWORD dwSave = FindDriveMapping(hkOld, rgbSig, cbSig, szDrive);
                dwRet = RegDeleteValue(hkOld, szValue);
                VALIDATE_DWRET("RegDeleteValue");                
                if (dwSave == ERROR_SUCCESS)
                {
                    dwIndex--;   // hack to make RegEnumValueEx work
                    dwRet = RegDeleteValue(hkOld, szDrive);
                    VALIDATE_DWRET("RegDeleteValue");                 
                }   

                trace(0, "Deleted old volume");
            }
        }
        else if (szValue[0] == L'#')
        {
            trace(0, "Old Mountpoint = %S", szValue);            
        }
        else if (0 == wcsncmp(szValue, L"\\DosDevice", 10))
        {            
            trace(0, "Old Drive = %S", szValue);
        }
        else
        {
            trace(0, "Old Unknown = %S", szValue);
        }            

        dwSize = MAX_PATH;
        cbSig = sizeof(rgbSig);
    }
                                 
    if (dwRet != ERROR_NO_MORE_ITEMS)
        VALIDATE_DWRET("::RegEnumValue");



    //
    // now enumerate the current (new) devices 
    //

    dwIndex = 0;
    dwSize = MAX_PATH;
    cbSig = sizeof(rgbSig);    
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue( hkNew, 
                                 dwIndex++,
                                 szValue,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 rgbSig,
                                 &cbSig )))
    {        
        if (0 == wcsncmp(szValue, L"\\??\\Volume", 10))
        {
            //
            // this is a Volume -> Signature mapping
            // copy the new volume to the old 
            //
            
            trace(0, "New Volume = %S", szValue);

            DWORD dwSave = FindDriveMapping(hkOld, rgbSig, cbSig, szDrive);    

            dwRet = RegSetValueEx(hkOld, 
                                  szValue,
                                  NULL,
                                  REG_BINARY,
                                  rgbSig,
                                  cbSig);
            VALIDATE_DWRET("::RegSetValueEx");       

            if (dwSave == ERROR_NO_MORE_ITEMS)
            {
                //
                // there is no driveletter for this volume in the old registry
                // so copy the new one to the old if it exists
                //

                if (ERROR_SUCCESS ==
                    FindDriveMapping(hkNew, rgbSig, cbSig, szDrive))
                {
                    dwRet = RegSetValueEx(hkOld, 
                                      szDrive,
                                      NULL,
                                      REG_BINARY,
                                      rgbSig,
                                      cbSig);
                    VALIDATE_DWRET("::RegSetValueEx");
                    trace(0, "Copied new driveletter %S to old", szDrive);                    
                }
            }
            else
            {
                //
                // preserve the old driveletter
                //

                trace(0, "Preserving old driveletter %S", szDrive);
            }
            
        }
        else if (szValue[0] == L'#')
        {
            //
            // this is a mountpoint specification
            // BUGBUG - mount points should be restored
            // so don't bother about these ?
            //

            trace(0, "New Mountpoint = %S", szValue);
            
        }
        else if (0 == wcsncmp(szValue, L"\\DosDevice", 10))
        {
            //
            // this is a Driveletter -> Signature mapping
            // don't touch these
            //
            
            trace(0, "New Drive = %S", szValue);
        }
        else
        {
            trace(0, "New Unknown = %S", szValue);
        }    
        
        dwSize = MAX_PATH;        
        cbSig = sizeof(rgbSig);        
    }
                                 
    if (dwRet == ERROR_NO_MORE_ITEMS)
        dwRet = ERROR_SUCCESS;
        
    VALIDATE_DWRET("::RegEnumValue");    

done: 
    if (hkOld)
        RegCloseKey(hkOld);

    if (hkNew)
        RegCloseKey(hkNew);
        
    TLEAVE();
    return dwRet;
}



LPCWSTR  GetSysErrStr( )
{
    TraceFunctEnter("GetSysErrStr(DWORD)");
    static WCHAR  szErr[1024+1];

    DWORD dwErr = GetLastError();
    
    ::FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        szErr,
        1024,
        NULL );

    TraceFunctLeave();
    return( szErr );
}


BOOL
CheckPrivilege( LPCWSTR szPriv, BOOL fCheckOnly )
{
    TraceFunctEnter("CheckPrivilege");
    BOOL              fRet = FALSE;
    LPCWSTR           cszErr;
    HANDLE            hToken = NULL;
    LUID              luid;
    TOKEN_PRIVILEGES  tpNew;
    TOKEN_PRIVILEGES  tpOld;
    DWORD             dwRes;

    // Prepare Process Token
    if ( !::OpenProcessToken( ::GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hToken ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::OpenProcessToken failed - %ls", cszErr);
        goto Exit;
    }

    // Get Luid
    if ( !::LookupPrivilegeValue( NULL, szPriv, &luid ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::LookupPrivilegeValue failed - %ls", cszErr);
        goto Exit;
    }

    // Try to enable the privilege
    tpNew.PrivilegeCount           = 1;
    tpNew.Privileges[0].Luid       = luid;
    tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if ( !::AdjustTokenPrivileges( hToken, FALSE, &tpNew, sizeof(tpNew), &tpOld, &dwRes ) )
    {
        cszErr = ::GetSysErrStr();
        ErrorTrace(0, "::AdjustTokenPrivileges(ENABLE) failed - %ls", cszErr);
        goto Exit;
    }

    if ( ::GetLastError() == ERROR_NOT_ALL_ASSIGNED )
    {
        // This means process does not even have the privilege so
        // AdjustTokenPrivilege simply ignored the request.
        ErrorTrace(0, "Privilege '%ls' does not exist, probably user is not an admin.", szPriv);
        goto Exit;
    }

DebugTrace(0, "old=%d", tpOld.Privileges[0].Attributes);

    if ( fCheckOnly )
    {
        // Restore the privilege if it was not enabled
        if ( tpOld.PrivilegeCount > 0 )
        {
            if ( !::AdjustTokenPrivileges( hToken, FALSE, &tpOld, sizeof(tpOld), NULL, NULL ) )
            {
                cszErr = ::GetSysErrStr();
                ErrorTrace(0, "::AdjustTokenPrivileges(RESTORE) failed - %ls", cszErr);
                goto Exit;
            }
        }
    }

    fRet = TRUE;
Exit:
    if ( hToken != NULL )
        ::CloseHandle( hToken );
    return( fRet );
}


BOOL DeleteRegKey(HKEY hkOpenKey,
                  const WCHAR * pszKeyNameToDelete)
{
    TraceFunctEnter("DeleteRegKey");
    BOOL   fRet=FALSE;
    DWORD  dwRet;


     // this recursively deletes the key and all its subkeys
    dwRet = SHDeleteKey( hkOpenKey, // handle to open key
                         pszKeyNameToDelete);  // subkey name

    if (dwRet != ERROR_SUCCESS)
    {
         // key does not exist - this is not an error case.
        DebugTrace(0, "RegDeleteKey of %S failed ec=%d. Not an error.",
                   pszKeyNameToDelete, dwRet);
        goto cleanup;
    }

    DebugTrace(0, "RegDeleteKey of %S succeeded", pszKeyNameToDelete); 
    fRet = TRUE;
    
cleanup:
    TraceFunctLeave();
    return fRet;
}



DWORD PersistRegKeys( HKEY hkMountedHive,
                      const WCHAR * pszKeyNameInHive,
                      HKEY  hkOpenKeyInRegistry,
                      const WCHAR * pszKeyNameInRegistry,
                      const WCHAR * pszKeyBackupFile,
                      WCHAR * pszSnapshotPath)
{
    TraceFunctEnter("PersistRegKeys");
    HKEY   hKey=NULL;
    WCHAR  szDataFile[MAX_PATH];
    LPCWSTR cszErr;    
    DWORD dwRet=ERROR_INTERNAL_ERROR;
    BOOL  fKeySaved;
    DWORD  dwDisposition;
    
    
     // construct the name of the file that stores the backup we will
     // construct the name such that the file will get deleted after
     // the restore.
    wsprintf(szDataFile, L"%s%s", pszSnapshotPath, pszKeyBackupFile);
    
    DeleteFile(szDataFile);      // delete the file if it exists

    
     // first load the DRM key to a file
     // open the DRM key
    dwRet= RegOpenKeyEx(hkOpenKeyInRegistry, // handle to open key
                        pszKeyNameInRegistry, // name of subkey to open
                        0,   // reserved
                        KEY_READ, // security access mask
                        &hKey);   // handle to open key
    
    if (dwRet != ERROR_SUCCESS)
    {
         // key does not exist - this is not an error case.
        DebugTrace(0, "RegOpenKey of %S failed ec=%d", pszKeyNameInRegistry,
                   dwRet);
        fKeySaved = FALSE;
    }
    else
    {
         // key exist
        dwRet = RegSaveKey( hKey, // handle to key
                            szDataFile, // data file
                            NULL);  // SD
        if (dwRet != ERROR_SUCCESS)
        {
             // key does not exist - this is not an error case.
            DebugTrace(0, "RegSaveKey of %S failed ec=%d",
                       pszKeyNameInRegistry, dwRet);
            fKeySaved = FALSE;
        }
        else
        {
            DebugTrace(0, "Current DRM Key %S saved successfully",
                       pszKeyNameInRegistry);
            fKeySaved = TRUE;            
        }
    }


     // close the key 
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }
    
     // now replace the snapshotted DRM key with the new key
    
     // first delete the existing key
    DeleteRegKey(hkMountedHive, pszKeyNameInHive);

     // now check to see if the key existing in the old registry in
     // the first place
    if (fKeySaved == FALSE)
    {
        DebugTrace(0, "Current key %S did not exist. Leaving",
                   pszKeyNameInRegistry);
        goto done;
    }

     // Create the new DRM key
    dwRet = RegCreateKeyEx( hkMountedHive, // handle to open key
                            pszKeyNameInHive, // subkey name
                            0,        // reserved
                            NULL,     // class string
                            REG_OPTION_NON_VOLATILE, // special options
                            KEY_ALL_ACCESS, // desired security access
                            NULL, // inheritance
                            &hKey, // key handle 
                            &dwDisposition); // disposition value buffer
    VALIDATE_DWRET("::RegCreateKeyEx");
    _VERIFY(dwDisposition == REG_CREATED_NEW_KEY);
    dwRet= RegRestoreKey( hKey, // handle to key where restore begins
                          szDataFile, // registry file
                          REG_FORCE_RESTORE|REG_NO_LAZY_FLUSH); // options

    VALIDATE_DWRET("::RegRestoreKey");

    DebugTrace(0, "Successfully kept key %S", pszKeyNameInRegistry);    
    dwRet = ERROR_SUCCESS;
    
done:
    if (hKey)
        RegCloseKey(hKey);
    
    DeleteFile(szDataFile);      // delete the file if it exists    
    TraceFunctLeave();
    return dwRet;
}


LPWSTR
GetNextMszString(LPWSTR pszBuffer)
{
    return pszBuffer + lstrlen(pszBuffer) + 1;
}

DWORD
ValueReplace(HKEY hkOldSystem, HKEY hkNewSystem, LPWSTR pszString)
{
    tenter("ValueReplace");
    
    WCHAR  szBuffer[MAX_PATH];
    BYTE   *pData = NULL;
    DWORD  dwType, dwSize, dwRet = ERROR_SUCCESS;
    LPWSTR pszValue = NULL;
    LPCWSTR cszErr;
    
    // split up the key and value in pszString    
    lstrcpy(szBuffer, pszString);
    pszValue = wcsrchr(szBuffer, L'\\');
    if (! pszValue)
    {   
        trace(0, "No value in %S", pszString);
        goto done;
    }
        
    *pszValue=L'\0';
    pszValue++;
    
    trace(0, "Key=%S, Value=%S", szBuffer, pszValue);

    // get the value size    
    dwRet = SHGetValue(hkNewSystem, szBuffer, pszValue, &dwType, NULL, &dwSize);
    VALIDATE_DWRET("SHGetValue");
    
    pData = (BYTE *) SRMemAlloc(dwSize);
    if (! pData)
    {
        trace(0, "! SRMemAlloc");
        dwRet = ERROR_OUTOFMEMORY;
        goto done;
    }

    // get the value
    dwRet = SHGetValue(hkNewSystem, szBuffer, pszValue, &dwType, pData, &dwSize);       
    VALIDATE_DWRET("SHGetValue");

    // set the value in the old registry
    SHSetValue(hkOldSystem, szBuffer, pszValue, dwType, pData, dwSize);
    VALIDATE_DWRET("SHGetValue");

done:    
    if (pData)
    {
        SRMemFree(pData);
    }
    tleave();
    return dwRet;
}


//
// list of keys in KeysNotToRestore that we should ignore
//
LPWSTR g_rgKeysToRestore[] = {
    L"Installed Services",
    L"Mount Manager",
    L"Pending Rename Operations",
    L"Session Manager" 
    };
int g_nKeysToRestore = 4;


BOOL
IsKeyToBeRestored(LPWSTR pszKey)
{    
    for (int i=0; i < g_nKeysToRestore; i++)
    {
        if (lstrcmpi(g_rgKeysToRestore[i], pszKey) == 0)
            return TRUE;
    }

    return FALSE;
}

BOOL  SRGetRegDword( HKEY hKey, LPCWSTR cszSubKey, LPCWSTR cszValue, DWORD *pdwData )
{
    TraceFunctEnter("SRGetRegDword");
    BOOL   fRet = FALSE;
    DWORD  dwType;
    DWORD  dwRes;
    DWORD  cbData;

    dwType = REG_DWORD;
    cbData = sizeof(DWORD);
    dwRes = ::SHGetValue( hKey, cszSubKey, cszValue, &dwType, pdwData, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        ErrorTrace(0, "::SHGetValue failed - %ld", GetLastError() );
        goto Exit;
    }

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}

void
ChangeCCS(HKEY hkMount, LPWSTR pszString)
{
    tenter("ChangeCCS");
    int    nCS = lstrlen(L"CurrentControlSet");            
    
    if (StrCmpNI(pszString, L"CurrentControlSet", nCS) == 0)
    {
        LPWSTR pszCS = L"ControlSet001";
        DWORD  dwCurrent = 0;       
        
        if (::SRGetRegDword (hkMount, L"Select", L"Current", &dwCurrent) &&
            dwCurrent == 2)
        {
            pszCS[lstrlenW(L"ControlSet00")] = L'2';
        }
        
        WCHAR szTemp[MAX_PATH];

        lstrcpy(szTemp, &(pszString[nCS]));
        wsprintf(pszString, L"%s%s", pszCS, szTemp);
        trace(0, "ChangeCCS: pszString = %S", pszString);
    }
    tleave();
}


DWORD
PreserveKeysNotToRestore(HKEY hkOldSystem, LPWSTR pszSnapshotPath)
{
    HKEY    hkNewSystem = NULL;
    DWORD   dwIndex = 0;
    WCHAR   szName[MAX_PATH], szKey[MAX_PATH];
    BYTE    *pMszString = NULL;
    DWORD   dwSize, dwType, cbValue;
    DWORD   dwRet = ERROR_SUCCESS;
    LPCWSTR cszErr;
    HKEY    hkKNTR = NULL;
    
    TENTER("PreserveKeysNotToRestore");
    
    //
    // open the new system hive
    //   

    dwRet = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"System", 0, KEY_ALL_ACCESS, &hkNewSystem );
    VALIDATE_DWRET("::RegOpenKey");

    //
    // enumerate KeysNotToRestore
    //

    dwRet = ::RegOpenKeyEx( hkNewSystem, 
                          L"CurrentControlSet\\Control\\BackupRestore\\KeysNotToRestore",
                          0, KEY_READ,
                          &hkKNTR );
    VALIDATE_DWRET("::RegOpenKey");
    
    dwSize = MAX_PATH;
    cbValue = 0;
    while (ERROR_SUCCESS == 
           (dwRet = RegEnumValue(hkKNTR, 
                                 dwIndex++,
                                 szName,
                                 &dwSize,
                                 NULL,
                                 &dwType,
                                 NULL,
                                 &cbValue )))
    {        
        trace(0, "Name=%S", szName);
        if (FALSE == IsKeyToBeRestored(szName))
        {                        
            //
            // should preserve the keys specified in this multisz value
            // 

            LPWSTR pszString = NULL;
            
            pMszString = (BYTE *) SRMemAlloc(cbValue);
            if (NULL == pMszString)
            {
                trace(0, "! SRMemAlloc");
                goto done;
            }

            // read the multisz string
            dwRet = RegQueryValueEx(hkKNTR, 
                                    szName,
                                    NULL,
                                    &dwType,
                                    pMszString,
                                    &cbValue);
            VALIDATE_DWRET("RegQueryValueEx");              

            // process each element in the multisz string
            pszString = (LPWSTR) pMszString;
            do
            {
                // stop on null or empty string                
                if (! pszString || ! *pszString)
                    break;
                    
                trace(0, "Key = %S", pszString);

                // replace based on the last character of each key
                // if '\', then the whole key and subkeys are to be replaced in the old registry
                // if '*', it should be merged with the old -- we don't support this and will ignore
                // otherwise, it is a value to be replaced
                
                switch (pszString[lstrlen(pszString)-1])
                {
                    case L'*' :
                        trace(0, "Merge key - ignoring");
                        break;

                    case L'\\':
                        trace(0, "Replacing key");
                        lstrcpy(szKey, pszString);
                        szKey[lstrlen(szKey)-1]=L'\0';
                        ChangeCCS(hkOldSystem, szKey);
                        PersistRegKeys(hkOldSystem, // mounted hive
                                       szKey,   // key name in hive
                                       hkNewSystem, // open key in registry
                                       szKey,   // key name in registry
                                       L"srtemp.dat", // name of backup file 
                                       pszSnapshotPath); // snapshot path
                        break;
                        
                    default:
                        trace(0, "Replacing value");
                        lstrcpy(szKey, pszString);
                        ChangeCCS(hkOldSystem, szKey);
                        ValueReplace(hkOldSystem, hkNewSystem, szKey);
                        break;                        
                }     
            }   while (pszString = GetNextMszString(pszString));

            SRMemFree(pMszString);
        }
        
        dwSize = MAX_PATH;
        cbValue = 0;
    }
                                 

done: 
    if (hkNewSystem)
        RegCloseKey(hkNewSystem);

    if (pMszString)
    {
        SRMemFree(pMszString);
    }

    if (hkKNTR)
    {
        RegCloseKey(hkKNTR);
    }
    
    TLEAVE();
    return dwRet;
}


void _cdecl 
main()
{
    int                 nOption; 
    LPWSTR              pwszFileName = NULL;
    DWORD               dwSize;
    RESTOREPOINTINFO    rpti;
    STATEMGRSTATUS      smgrs;
    LPWSTR *            argv = NULL;
    int                 argc;
    HGLOBAL             hMem = NULL;
    int                 fStart;
    HANDLE              hFilter = NULL;
    DWORD               dwRet;
    HKEY                hkMount = NULL;
    
    InitAsyncTrace();

    TENTER("main");
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);

    if (! argv)
    {
        printf("Error parsing arguments");
        exit(1);
    }
    
    if (argc < 2 || argc > 6)
    {
        PrintUsage();
        goto done;
    }

    nOption = _wtoi(argv[1]);
        
    switch(nOption)
    {
    case 1:        
        printf("EnableSR...DWORD %ld", EnableSR(argc == 3 ? argv[2] : NULL));
        break;
        
    case 2:
        printf("DisableSR...DWORD %ld", DisableSR(argc == 3 ? argv[2] : NULL));
        break;

    case 3:
        printf("EnableFIFO...DWORD %ld", EnableFIFO());
        break;
        
    case 4:        
        if (argc != 3)
        {
           PrintUsage();
           goto done;
        }
        printf("DisableFIFO...DWORD %ld", DisableFIFO(_wtol(argv[2])));
        break;
    
    case 5:
        if (argc < 3)
            lstrcpyn(rpti.szDescription, L"Rpctest", MAX_DESC_W);
        else
            lstrcpyn(rpti.szDescription, argv[2], MAX_DESC_W);
            
        if (argc < 4)
            rpti.dwRestorePtType = APPLICATION_INSTALL;
        else
            rpti.dwRestorePtType = _wtol(argv[3]);      
            
        if (argc < 5)        
            rpti.dwEventType = BEGIN_SYSTEM_CHANGE;
        else
            rpti.dwEventType = _wtol(argv[4]);

        if (argc < 6)        
            rpti.llSequenceNumber = 0;            
        else
            rpti.llSequenceNumber = _wtol(argv[5]);
       
        printf("SRSetRestorePoint...BOOL %d", SRSetRestorePoint(&rpti, &smgrs));
        printf("\nStateMgrStatus.nStatus = %d, StateMgrStatus.llSequenceNumber = %I64d", 
               smgrs.nStatus, smgrs.llSequenceNumber);
        break;

    case 6:        
        if (argc != 3)
        {
           PrintUsage();
           goto done;
        }        
        printf("SRRemoveRestorePoint...DWORD %ld", SRRemoveRestorePoint(_wtol(argv[2])));
        break;               
               
    case 7:
        if (argc != 3)
        {
           PrintUsage();
           goto done;
        }        
        printf("SRUpdateMonitoredList...DWORD %ld", SRUpdateMonitoredList(argv[2]));
        break;

    case 8:
        if (argc != 4)
        {
           PrintUsage();
           goto done;
        }        

        printf("SRFifo...DWORD %ld", SRFifo(argv[2], 0, _wtoi(argv[3]), TRUE, FALSE));
        break;

    case 9:
        if (argc != 4)
        {
           PrintUsage();
           goto done;
        }        

        printf("SRFifo...DWORD %ld", SRFifo(argv[2], 0, _wtoi(argv[3]), TRUE, TRUE));
        break;
        
    case 10:
        if (argc != 4)
        {
           PrintUsage();
           goto done;
        }        

        printf("SRFifo...DWORD %ld", SRFifo(argv[2], _wtoi(argv[3]), 0, TRUE, FALSE));
        break;

    case 11:
        if (argc != 4)
        {
           PrintUsage();
           goto done;
        }        

        printf("SRFifo...DWORD %ld", SRFifo(argv[2], _wtoi(argv[3]), 0, FALSE, FALSE));
        break;

    case 12:
        if (argc != 3)
        {
           PrintUsage();
           goto done;
      