OREGROUND, (WPARAM)bActivate, 0);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   FindSheet
//
//  Synopsis:   Locate the property sheet for the DS object identified by the
//              data object. For use in the dsprop DLL. If found, bring the
//              sheet to the foregroung and set the focus to the sheet.
//
//-----------------------------------------------------------------------------
BOOL
FindSheet(PWSTR pwzObjADsPath)
{
    HWND hNotify = FindSheetNoSetFocus(pwzObjADsPath);

    if (!hNotify)
    {
        return FALSE;
    }

    SendMessage(hNotify, WM_ADSPROP_NOTIFY_SETFOCUS, 0, 0);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   IsSheetAlreadyUp
//
//  Synopsis:   Public, exported function to locate a prop sheet for the DS
//              object identified by the data object. If found, sends a message
//              to the sheet to bring it to the foreground.
//
//-----------------------------------------------------------------------------
extern "C" BOOL
IsSheetAlreadyUp(LPDATAOBJECT pDataObj)
{
    // Get the object's DN from the data object.
    //
    HRESULT hr = S_OK;
    STGMEDIUM sm = {TYMED_NULL, NULL, NULL};
    FORMATETC fmte = {g_cfDsMultiSelectProppages, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    PWSTR pszUniqueID;

    BOOL fFound = FALSE;
    hr = pDataObj->GetData(&fmte, &sm);

    if (FAILED(hr))
    {
      STGMEDIUM smDS = {TYMED_NULL, NULL, NULL};
      FORMATETC fmteDS = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
      LPDSOBJECTNAMES pDsObjectNames;

      hr = pDataObj->GetData(&fmteDS, &smDS);

      if (FAILED(hr))
      {
        return FALSE;
      }

      pDsObjectNames = (LPDSOBJECTNAMES)smDS.hGlobal;

      dspAssert(pDsObjectNames->cItems > 0);

      pszUniqueID = (LPWSTR)ByteOffset(pDsObjectNames,
                                       pDsObjectNames->aObjects[0].offsetName);

      fFound = FindSheet(pszUniqueID);

      ReleaseStgMedium(&smDS);
    }
    else
    {
      pszUniqueID = (PWSTR)sm.hGlobal;
      dspAssert(pszUniqueID != NULL);

      fFound = FindSheet(pszUniqueID);

      ReleaseStgMedium(&sm);

    }

    return fFound;
}

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Method:     CMultiSelectErrorDialog::CMultiSelectErrorDialog
//
//  Synopsis:   Multi-select error message dialog constructor
//
//-----------------------------------------------------------------------------
CMultiSelectErrorDialog::CMultiSelectErrorDialog(HWND hNotifyObj, HWND hParent)
  : m_hWnd(NULL),
    m_hNotifyObj(hNotifyObj),
    m_hParent(hParent),
    m_bModal(FALSE),
    m_bInit(FALSE),
    m_pPageInfoArray(NULL),
    m_nPageCount(0),
    m_pDataObj(NULL)
{

}
    
//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::StaticDlgProc
//
//  Synopsis:   The static dialog proc for displaying errors for multi-select pages
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CMultiSelectErrorDialog::StaticDlgProc(HWND hDlg, 
                                                        UINT uMsg, 
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
  CMultiSelectErrorDialog* dlg = NULL;

  UINT code;
  UINT id;
  switch (uMsg)
  {
    case WM_INITDIALOG:
      dlg = reinterpret_cast<CMultiSelectErrorDialog*>(lParam);
      dspAssert(dlg != NULL);
      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)dlg);
      SetForegroundWindow(hDlg);
      return dlg->OnInitDialog(hDlg);

    case WM_COMMAND:
      code = GET_WM_COMMAND_CMD(wParam, lParam);
      id   = GET_WM_COMMAND_ID(wParam, lParam);
      if (dlg == NULL)
      {
        dlg = reinterpret_cast<CMultiSelectErrorDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));
      }
      switch (id)
      {
        case IDOK:
        case IDCANCEL:
          if (code == BN_CLICKED)
          {
            dlg->OnClose();
          }
          break;
        case IDC_COPY_BUTTON:
          if (code == BN_CLICKED)
          {
            dlg->OnCopyButton();
          }
          break;
        case IDC_PROPERTIES_BUTTON:
          if (code == BN_CLICKED)
          {
            dlg->ShowListViewItemProperties();
          }
          break;
      }
      break;

    case WM_NOTIFY:
      {
        if (dlg == NULL)
        {
          dlg = reinterpret_cast<CMultiSelectErrorDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));
        }
        int idCtrl = (int)wParam;
        LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
        if (idCtrl == IDC_ERROR_LIST)
        {
          switch (pnmh->code)
          {
            case NM_DBLCLK:
              {
                dlg->ListItemActivate(pnmh);
              }
              break;

            case LVN_ITEMCHANGED:
            case NM_CLICK:
              {
                dlg->ListItemClick(pnmh);
              }
              break;
            default:
              break;
          }
        }
        break;
      }

    case WM_HELP:
      {
        LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
        if (!pHelpInfo || pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
        {
          return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
      }
  }
  return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::Init
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
BOOL CMultiSelectErrorDialog::OnInitDialog(HWND hDlg)
{
  dspAssert(m_bInit);
  if (!m_bInit)
  {
    return TRUE;
  }

  m_hWnd = hDlg;

  //
  // Disable the properties button until there is a selection
  //
  EnableWindow(GetDlgItem(m_hWnd, IDC_PROPERTIES_BUTTON), FALSE);

  HRESULT hr = S_OK;
  hr = InitializeListBox(hDlg);
  CHECK_HRESULT(hr, return TRUE;);

  CComPtr<IADsPathname> spPathCracker;

  hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                        IID_IADsPathname, (PVOID *)&spPathCracker);

  CHECK_HRESULT_REPORT(hr, hDlg, return TRUE);

  dspAssert(m_pPageInfoArray != NULL);
  if (m_pPageInfoArray == NULL)
  {
    return TRUE;
  }

  INT iMaxLen = 0;
  SIZE size = {0,0};

  //
  // Load the appropriate list box
  //
  for (UINT pageIdx = 0; pageIdx < m_nPageCount; pageIdx++)
  {
    if (m_pPageInfoArray[pageIdx].m_ApplyStatus == CPageInfo::failed)
    {
      PTSTR ptzCaptionFormat = NULL;
      LoadStringToTchar(IDS_MULTI_FAILURE_CAPTION, &ptzCaptionFormat);

      if (ptzCaptionFormat != NULL)
      {
		//NTRAID#NTBUG9-571996-2002/03/10-jmessec   Buffer Overrun: Can't use wcslen(ptzCaptionFormat) as determination of length of 
		  //string; format could be %20s
        PWSTR pszCaption = new WCHAR[wcslen(ptzCaptionFormat) + wcslen(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetPageTitle()) + 1];
        if (pszCaption != NULL)
        {
          wsprintf(pszCaption, ptzCaptionFormat, m_pPageInfoArray[pageIdx].m_ApplyErrors.GetPageTitle());
          SetWindowText(GetDlgItem(m_hWnd, IDC_ERROR_STATIC), pszCaption);
          delete[] pszCaption;
          pszCaption = NULL;
        }
      }

      for (UINT objectIdx = 0; objectIdx < m_pPageInfoArray[pageIdx].m_ApplyErrors.GetCount(); objectIdx++)
      {
        //
        // Get the objects path and class name
        //
        PWSTR pszObjPath = m_pPageInfoArray[pageIdx].m_ApplyErrors.GetName(objectIdx);
        PWSTR pszObjClass = m_pPageInfoArray[pageIdx].m_ApplyErrors.GetClass(objectIdx);

        //
        // Get the class icon for the object
        //
        int iIcon = g_ClassIconCache.GetClassIconIndex(pszObjClass);
        dspAssert(iIcon != -1);

        //
        // Get the object name from the path
        //
        PWSTR pszLabel = NULL;
        CComBSTR bstr;
        hr = spPathCracker->Set(CComBSTR(pszObjPath),
                                ADS_SETTYPE_FULL);
        CHECK_HRESULT(hr, pszLabel = pszObjPath;);

        if (SUCCEEDED(hr))
        {
          hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
          CHECK_HRESULT(hr, pszLabel = pszObjPath;);
        }

        // CODEWORK 122531 Should we be turning off escaped mode here?

        if (SUCCEEDED(hr))
        {
          hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstr);
          CHECK_HRESULT(hr, pszLabel = pszObjPath;);
        }

        if (SUCCEEDED(hr))
        {
          pszLabel = bstr;
        }
        dspAssert(pszLabel != NULL);

        //
        // Create the list view item
        //
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iSubItem = IDX_NAME_COL;

        lvi.lParam = (LPARAM)pszObjPath;
        lvi.pszText = pszLabel;
        lvi.iItem = objectIdx;

        if (-1 != iIcon)
        {
          lvi.mask |= LVIF_IMAGE;
          lvi.iImage = iIcon;
        }

        //
        // Insert the new item
        //
        int NewIndex = ListView_InsertItem(m_hList, &lvi);
        dspAssert(NewIndex != -1);
        if (NewIndex == -1)
        {
          continue;
        }

        //
        // Format the error message and insert it
        //
        PWSTR ptzMsg = NULL;
        if (FAILED(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx)))
        {
          LoadErrorMessage(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx), 0, &ptzMsg);
          if (!ptzMsg)
          {
             ptzMsg = L""; // make prefix happy.
          }
          //
          // REVIEW_JEFFJON : this is hack to get rid of two extra characters
          //                  at the end of the string
          //
          size_t iLen = wcslen(ptzMsg);
          ptzMsg[iLen - 2] = L'\0';
        }
        else
        {
          ptzMsg = new WCHAR[wcslen(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx)) + 1];
          if (ptzMsg != NULL)
          {
            wcscpy(ptzMsg, m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx));
          }
        }

        if (NULL != ptzMsg)
        {
          ListView_SetItemText(m_hList, NewIndex, IDX_ERROR_COL,
                               ptzMsg);

          INT len = lstrlen(ptzMsg);
          if( len > iMaxLen )
          {
              HDC hdc = GetDC(hDlg);         
              GetTextExtentPoint32(hdc,ptzMsg,lstrlen(ptzMsg),&size);   
              ReleaseDC(hDlg, hdc);
              iMaxLen = len;
          }
          delete[] ptzMsg;
        }
      }
    }
    else if (m_pPageInfoArray[pageIdx].m_ApplyStatus == CPageInfo::success)
    {
      //
      // Insert the page title into the success list box
      //
      SendDlgItemMessage(m_hWnd, IDC_SUCCESS_LISTBOX, LB_ADDSTRING, 0, (LPARAM)m_pPageInfoArray[pageIdx].m_ptzTitle);
    }
    else // apply not tried yet
    {
      //
      // Insert the page title into the not attempted list box
      //
      SendDlgItemMessage(m_hWnd, IDC_NOT_ATTEMPTED_LISTBOX, LB_ADDSTRING, 0, (LPARAM)m_pPageInfoArray[pageIdx].m_ptzTitle);
    }
  }

  //
  // Select the first item in the error list
  //
  LVCOLUMN col;
  col.mask = LVCF_WIDTH;
  col.cx = size.cx;
  ListView_SetColumn(m_hList,1, &col);
  ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);
  ListView_SetItemState(m_hList, 0, LVIS_SELECTED, LVIS_SELECTED);
  return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::InitializeListBox
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
HRESULT CMultiSelectErrorDialog::InitializeListBox(HWND hDlg)
{

  m_hList = GetDlgItem(hDlg, IDC_ERROR_LIST);

  if (m_hList == NULL)
  {
    return HRESULT_FROM_WIN32(GetLastError());
  }

  ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);

  //
  // Set the column headings.
  //
  PTSTR ptsz;
  RECT rect;
  GetClientRect(m_hList, &rect);

  if (!LoadStringToTchar(IDS_COL_TITLE_OBJNAME, &ptsz))
  {
    ReportError(GetLastError(), 0, hDlg);
    return HRESULT_FROM_WIN32(GetLastError());
  }

  LV_COLUMN lvc = {0};
  lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
  lvc.fmt = LVCFMT_LEFT;
  lvc.cx = OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = ptsz;
  lvc.iSubItem = IDX_NAME_COL;

  ListView_InsertColumn(m_hList, IDX_NAME_COL, &lvc);

  delete[] ptsz;

  if (!LoadStringToTchar(IDS_COL_TITLE_ERRORMSG, &ptsz))
  {
    ReportError(GetLastError(), 0, hDlg);
    return HRESULT_FROM_WIN32(GetLastError());
  }

  lvc.cx = rect.right - OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = ptsz;
  lvc.iSubItem = IDX_ERROR_COL;

  ListView_InsertColumn(m_hList, IDX_ERROR_COL, &lvc);

  delete[] ptsz;

  //
  // Assign the imagelist to the listview
  //
  ListView_SetImageList(m_hList, g_ClassIconCache.GetImageList(), LVSIL_SMALL);
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::Init
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
HRESULT CMultiSelectErrorDialog::Init(CPageInfo* pPageInfoArray, 
                                      UINT nPageCount,
                                      IDataObject* pDataObj)
{
  m_nPageCount = nPageCount;
  m_pPageInfoArray = pPageInfoArray;
  m_bInit = TRUE;
  m_pDataObj = pDataObj;
  m_pDataObj->AddRef();

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::OnCopyButton
//
//  Synopsis:   Called when the user presses the Retry button
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::OnCopyButton()
{
  dspAssert(m_bInit);
  if (!m_bInit)
  {
    return;
  }

  dspAssert(m_pPageInfoArray != NULL);
  if (m_pPageInfoArray == NULL)
  {
    return;
  }

  CComPtr<IADsPathname> spPathCracker;
  HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                        IID_IADsPathname, (PVOID *)&spPathCracker);
  CHECK_HRESULT_REPORT(hr, m_hWnd, return);


  if (OpenClipboard(m_hWnd) == 0)
  {
    return;
  }

  if (EmptyClipboard() == 0)
  {
    CloseClipboard();
    return;
  }

  CStrW szClipboardData;
  szClipboardData.Empty();

  for (UINT pageIdx = 0; pageIdx < m_nPageCount; pageIdx++)
  {
    for (UINT objectIdx = 0; objectIdx < m_pPageInfoArray[pageIdx].m_ApplyErrors.GetCount(); objectIdx++)
    {
      //
      // Get the objects path and class name
      //
      PWSTR pszObjPath = m_pPageInfoArray[pageIdx].m_ApplyErrors.GetName(objectIdx);

      //
      // Get the object name from the path
      //
      PWSTR pszLabel = NULL;
      CComBSTR bstr;
      hr = spPathCracker->Set(CComBSTR(pszObjPath),
                              ADS_SETTYPE_FULL);
      CHECK_HRESULT(hr, pszLabel = pszObjPath;);

      if (SUCCEEDED(hr))
      {
        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        CHECK_HRESULT(hr, pszLabel = pszObjPath;);
      }

      // CODEWORK 122531 Should we be turning off escaped mode here?

      if (SUCCEEDED(hr))
      {
        hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstr);
        CHECK_HRESULT(hr, pszLabel = pszObjPath;);
      }

      if (SUCCEEDED(hr))
      {
        pszLabel = bstr;
      }
      dspAssert(pszLabel != NULL);

      //
      // Format the error message and insert it
      //
      PWSTR ptzMsg = NULL;
      if (FAILED(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx)))
      {
        LoadErrorMessage(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx), 0, &ptzMsg);
      }
      else
      {
        ptzMsg = new WCHAR[wcslen(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx)) + 1];
        if (ptzMsg != NULL)
        {
          wcscpy(ptzMsg, m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx));
        }
      }

      if (NULL != ptzMsg)
      {
        szClipboardData += pszLabel;
        szClipboardData += L",";
        szClipboardData += ptzMsg;
        szClipboardData += g_wzCRLF;
        delete [] ptzMsg;
      }
    }
  }

  HGLOBAL hBuffer = NULL;
  DWORD   dwBufferSize;
  HANDLE  hMemClipboard;


  LPTSTR  pszGlobalBuffer = NULL;
  dwBufferSize = (szClipboardData.GetLength() + 1) * sizeof(TCHAR);
      
  hBuffer = GlobalAlloc (GMEM_MOVEABLE, dwBufferSize);
  if (!hBuffer)
  {
     return;
  }

  pszGlobalBuffer = (LPTSTR)GlobalLock (hBuffer);
  if ( NULL == pszGlobalBuffer) 
  {
    // allocation or lock failed so bail out
    GlobalFree (hBuffer);
    return;
  }

  _tcscpy ( pszGlobalBuffer, szClipboardData );
  GlobalUnlock (hBuffer);

  if ( NULL != hBuffer ) 
  {
    hMemClipboard = SetClipboardData (
#if UNICODE
                  CF_UNICODETEXT,     // UNICODE text in the clipboard
#else
                  CF_TEXT,            // ANSI text in the clipboard
#endif
                  hBuffer);
    if (hMemClipboard == NULL) 
    {
      //free memory since it didn't make it to the clipboard
      GlobalFree (hBuffer);
      return;
    }
  } 
  else 
  {
    //free memory since it didn't make it to the clipboard
    GlobalFree (hBuffer);
    return;
  }

  CloseClipboard();
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ListItemClick
//
//  Synopsis:   Invokes a property page for the item that was activated
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::ListItemClick(LPNMHDR)
{
  UINT nSelectedCount = ListView_GetSelectedCount(m_hList);
  if (nSelectedCount == 1)
  {
    EnableWindow(GetDlgItem(m_hWnd, IDC_PROPERTIES_BUTTON), TRUE);
  }
  else
  {
    EnableWindow(GetDlgItem(m_hWnd, IDC_PROPERTIES_BUTTON), FALSE);
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ListItemActivate
//
//  Synopsis:   Invokes a property page for the item that was activated
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::ListItemActivate(LPNMHDR pnmh)
{
  LPNMITEMACTIVATE pActivateHeader = reinterpret_cast<LPNMITEMACTIVATE>(pnmh);
  dspAssert(pActivateHeader != NULL);
  if (pActivateHeader != NULL)
  {
    ShowListViewItemProperties();
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ShowListViewItemProperties()
//
//  Synopsis:   Invokes a secondary sheet for the selected list view item
//
//-----------------------------------------------------------------------------
BOOL CMultiSelectErrorDialog::ShowListViewItemProperties()
{
  BOOL bSuccess = TRUE;

  UINT nSelectCount = ListView_GetSelectedCount(m_hList);
  if (nSelectCount == 1)
  {
    //
    // Get the selected item
    //
    int nSelectedItem = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    if (nSelectedItem != -1)
    {
      //
      // Retrieve the item's path
      //
      LVITEM lvi = {0};
      lvi.iItem = nSelectedItem;
      lvi.mask = LVIF_PARAM;

      if (ListView_GetItem(m_hList, &lvi))
      {
        PWSTR pwzPath = reinterpret_cast<PWSTR>(lvi.lParam);
        if (pwzPath != NULL)
        {
          //
          // Get the DN
          //
          CComPtr<IADsPathname> spPathCracker;
          HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IADsPathname, (PVOID *)&spPathCracker);

          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          hr = spPathCracker->Set(CComBSTR(pwzPath), ADS_SETTYPE_FULL);
          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_ON);
          dspAssert(SUCCEEDED(hr));

          hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          CComBSTR bstrDN;
          hr = spPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          //
          // Invoke the page
          //
          hr = PostADsPropSheet(bstrDN, m_pDataObj, m_hParent, m_hNotifyObj, FALSE);
          if (FAILED(hr))
          {
            bSuccess = FALSE;
          }
        }
        else
        {
          bSuccess = FALSE;
        }
      }
      else
      {
        bSuccess = FALSE;
      }
    }
    else
    {
      bSuccess = FALSE;
    }
  }

  return bSuccess;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::OnClose
//
//  Synopsis:   Closes the modal dialog
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::OnClose()
{
  EndDialog(m_hWnd, 0);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::DoModal
//
//  Synopsis:   Displays the modal dialog
//
//-----------------------------------------------------------------------------
int CMultiSelectErrorDialog::DoModal()
{
  m_bModal = TRUE;
  dspAssert(IsWindow(m_hParent));
  return (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_MULTISELECT_ERROR_DIALOG),
                             m_hParent, StaticDlgProc, (LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ShowWindow
//
//  Synopsis:   Displays the modeless dialog
//
//-----------------------------------------------------------------------------
BOOL CMultiSelectErrorDialog::ShowWindow()
{
  m_bModal = FALSE;
  m_hWnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_MULTISELECT_ERROR_DIALOG),
                             m_hParent, StaticDlgProc, (LPARAM)this);
  return ::ShowWindow(m_hWnd, SW_SHOWNORMAL);
}
#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\user.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       user.cxx
//
//  Contents:   AD user shell property pages
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#include "user.h"
//#include "group.h"
#ifndef UNICODE
#   include <stdio.h>
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CountryCode
//
//  Synopsis:   Handles the Country combo box to get/set the Country-Code
//              (LDAP display name: countryCode) numeric ISO-3166 code.
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox and setting its
//              item data values.
//
//-----------------------------------------------------------------------------
HRESULT
CountryCode(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("CountryCode: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            PDsCountryCode pCountryCode = (PDsCountryCode)pCur;

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->Integer = pCountryCode->wCode;
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CountryName
//
//  Synopsis:   Handles the Country combo box/static control to get/set the
//              Country-Name (LDAP display name: c) 2 character ISO-3166 code.
//
//  Notes:      If the control is read-only, then assume it is a static text
//              control (or a read-only edit control) rather than a combobox.
//              Also, if read-only, then only the fInit should be called.
//
//-----------------------------------------------------------------------------
HRESULT
CountryName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwsz = NULL;
    DWORD dwErr = 0;
    INT_PTR pCur = NULL;
    PDsCountryCode pCountryCode = NULL;
    int iSel = 0, iCur = -1, cxExtent = 0;
#ifdef UNICODE
    CStrW strFirstCode, strLastCode, strCodeLine, strCurName;
#else
    CStr strFirstCode, strLastCode, strCodeLine, strCurName;
#endif
    CStrW str2CharAbrev;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (!pAttrMap->fIsReadOnly && !PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID),
                         FALSE);
            //
            // Remove the accelerator from the label since a disabled control
            // is not reachable.
            //
            CStr strLabel;
            strLabel.LoadString(g_hInstance, IDS_COUNTRY_LABEL_NO_ACCEL);
            SetDlgItemText(pPage->GetHWnd(), IDC_COUNTRY_LABEL, strLabel.GetBuffer(0));
        }
		// fall through...
    case fObjChanged:
      {
        DBG_OUT("CountryName: fInit");
        PTSTR ptzFullName = NULL;
        WORD wCode = 0;
        HDC hDC = NULL;
        unsigned long ulFirstCode, ulLastCode, i;

        strFirstCode.LoadString(g_hInstance, IDS_FIRST_COUNTRY_CODE);
        strLastCode.LoadString(g_hInstance, IDS_LAST_COUNTRY_CODE);

        if (strFirstCode.IsEmpty() || strLastCode.IsEmpty())
        {
            ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        ulFirstCode = _tcstoul(strFirstCode, NULL, 10);
        ulLastCode = _tcstoul(strLastCode, NULL, 10);

        if (!pAttrMap->fIsReadOnly)
        {
            hDC = GetDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
        }

        PWSTR pwzCurCode;

        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            pwzCurCode = pAttrInfo->pADsValues->CaseIgnoreString;
        }
        else
        {
            pwzCurCode = NULL;
        }

        for (i = ulFirstCode; i <= ulLastCode; i++)
        {
            strCodeLine.LoadString(g_hInstance, i);

            if (strCodeLine.IsEmpty())
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!GetALineOfCodes(strCodeLine.GetBuffer(1), &ptzFullName, str2CharAbrev, &wCode))
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!pAttrMap->fIsReadOnly)
            {
                // If not in read-only mode, then we use a combobox from which
                // the user selects the country.
                // Insert the full name into the combobox list.
                //
                SIZE s;
                if (hDC != NULL)
                {
                  GetTextExtentPoint32(hDC, ptzFullName, static_cast<int>(_tcslen(ptzFullName)), &s);

                  if (s.cx > cxExtent)
                  {
                      cxExtent = s.cx;
                  }

                  iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                                 CB_ADDSTRING, 0, (LPARAM)ptzFullName);

                  if (iSel < 0)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }

                  //
                  // Add the name codes as item data.
                  //
                  pCountryCode = new DsCountryCode;

                  CHECK_NULL_REPORT(pCountryCode, pPage->GetHWnd(), return E_OUTOFMEMORY);

                  wcscpy(pCountryCode->pwz2CharAbrev, str2CharAbrev);

                  pCountryCode->wCode = wCode;

                  if (SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                         CB_SETITEMDATA, iSel,
                                         (LPARAM)pCountryCode) == CB_ERR)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }
                }
            }
            //
            // See if the current country matches that saved on the DS object
            // (if one has been saved).
            //
            if (pwzCurCode)
            {
                if (_wcsicmp(pwzCurCode, str2CharAbrev) == 0)
                {
                    iCur = iSel;
                    strCurName = ptzFullName;
                }
            }

            if ((iCur == iSel) && pAttrMap->fIsReadOnly)
            {
                // Read-only mode means that we are using a static text
                // control. Insert the full name into the control.
                //
                SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzFullName);
                break;
            }

            if (pAttrMap->fIsReadOnly)
            {
                iSel++;
            }
        }

        if (!pAttrMap->fIsReadOnly)
        {
          if (hDC != NULL)
          {
            ReleaseDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), hDC);
          }
          SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                             CB_SETHORIZONTALEXTENT, (WPARAM)cxExtent, 0);
          if (iCur >= 0)
          {
            iCur = (int) SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_FINDSTRINGEXACT, 0,
                                      (WPARAM)(LPCTSTR)strCurName);
            dspAssert(iCur != CB_ERR);
            SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                               CB_SETCURSEL, iCur, 0);
          }
        }
        else
        {
          if (iCur < 0)
          {
            // If iCur is still -1, then country code hasn't been set.
            //
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
          }
        }
        break;
      }
    case fApply:
        DBG_OUT("CountryName: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                       CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            pCountryCode = (PDsCountryCode)pCur;

            if (!AllocWStr(pCountryCode->pwz2CharAbrev, &pwsz))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwsz;
        }
        break;

    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fOnDestroy:
        DBG_OUT("CountryName: fOnDestroy");
        iSel = 0;
        do
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur != CB_ERR)
            {
                // Delete the itemdata string.
                //
                delete (PDsCountryCode)pCur;

                iSel++;
            }
        } while (pCur != CB_ERR);
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TextCountry
//
//  Synopsis:   Handles the Country combo box to get/set the Text-Country
//              (LDAP display name: co) 
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox
//
//-----------------------------------------------------------------------------
HRESULT
TextCountry(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("TextCountry: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {   
            LPTSTR ptz = new TCHAR[pAttrMap->nSizeLimit + 1];
            CHECK_NULL_REPORT(ptz, pPage->GetHWnd(), return E_OUTOFMEMORY);

            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETLBTEXT, iSel, (LPARAM) (LPCSTR) ptz );
            if (pCur == LB_ERR)
            {
                delete [] ptz;
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }
            
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            if( pADsValue == NULL )
            {
              ReportError(E_OUTOFMEMORY,0, pPage->GetHWnd()); 
              delete [] ptz;
              return E_OUTOFMEMORY;
            }

            
            if (!TcharToUnicode(ptz, &pADsValue->CaseIgnoreString))
            {
              delete [] ptz;
              delete pADsValue;
              REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
              return E_OUTOFMEMORY;
            }

            delete [] ptz;
    
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            
        }
        break;
    }

    return S_OK;
}

// CountryName helpers:

//+----------------------------------------------------------------------------
//
//  Function:   GetALineOfCodes
//
//  Synopsis:   Parse a line of country codes.
//
//-----------------------------------------------------------------------------
BOOL GetALineOfCodes(PTSTR ptzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode)
{
    //
    // The line is parsed from end to beginning. That way we don't need to
    // dependend on the column widths being fixed.
    //
    // The last token is the numeric code. Read it.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptzCode = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptzCode)
    {
        // try tab char.
        //
        ptzCode = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptzCode || (ptzCode <= ptzLine) || (_tcslen(ptzCode) < 2))
    {
        return FALSE;
    }

    *ptzCode = TEXT('\0');

    ptzCode++;

    int iScanned = _stscanf(ptzCode, TEXT("%u"), pwCode);
    dspAssert(iScanned == 1);

    //
    // The next to last token is the 3 character code. Skip it.
    //
    RemoveTrailingWhitespace(ptzLine);

    size_t nLen = _tcslen(ptzLine);

    if (3 >= nLen)
    {
        return FALSE;
    }

    ptzLine[nLen - 3] = TEXT('\0');

    //
    // The next token (moving toward the front) is the 2 character code.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptz2CharAbrev = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptz2CharAbrev)
    {
        // try tab char.
        //
        ptz2CharAbrev = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptz2CharAbrev || (ptz2CharAbrev <= ptzLine))
    {
        return FALSE;
    }

    *ptz2CharAbrev = TEXT('\0');

    ptz2CharAbrev++;

    if (_tcslen(ptz2CharAbrev) != 2)
    {
        return FALSE;
    }

    str2CharAbrev = ptz2CharAbrev;

    //
    // The first token is the full country name.
    //
    RemoveTrailingWhitespace(ptzLine);

    if (!_tcslen(ptzLine))
    {
        return FALSE;
    }

    *pptzFullName = ptzLine;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrailingWhitespace
//
//  Synopsis:   Trailing white space is replaced by NULLs.
//
//-----------------------------------------------------------------------------
void RemoveTrailingWhitespace(PTSTR ptz)
{
    size_t nLen = _tcslen(ptz);

    while (nLen)
    {
        if (!iswspace(ptz[nLen - 1]))
        {
            return;
        }
        ptz[nLen - 1] = L'\0';
        nLen--;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ManagerEdit
//
//  Synopsis:   Handles the manager edit control.
//
//  Notes:      The page member m_pData stores the pAttrData value whose pVoid
//              element is set to the DN of the manager. The other manager
//              attr functions can then access the manager value and can also
//              read the fWritable element.
//
//-----------------------------------------------------------------------------
HRESULT
ManagerEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwz = NULL;
    PWSTR canonical = NULL;
    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (pAttrInfo && pAttrInfo->dwNumValues > 0)
        {
            if (!AllocWStr(pAttrInfo->pADsValues[0].DNString, &pwz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
            hr = CrackName (pwz, &canonical, GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());
            if (FAILED(hr))
            {
                delete [] pwz;
                return S_FALSE;
            }
            PTSTR ptz, ptzName;
            if (!UnicodeToTchar(canonical, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                delete [] pwz;
                return E_OUTOFMEMORY;
            }
            LocalFreeStringW(&canonical);
            ptzName = _tcschr(ptz, TEXT('\n'));
            dspAssert(ptzName);
            ptzName++;
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzName);
            delete [] ptz;
        }
        pAttrData->pVoid = reinterpret_cast<LPARAM>(pwz);
        ((CDsTableDrivenPage *)pPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        pwz = (PWSTR)reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData)->pVoid;

        if (pwz)
        {
            // make a copy cause CDsTableDrivenPage::OnApply deletes it.
            PWSTR pwzTmp;
            if (!AllocWStr(pwz, &pwzTmp))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
      
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwzTmp;
        }
        else
        {
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        break;

    case fOnDestroy:
        if (reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData)
        {
            PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
            PVOID pVoid = reinterpret_cast<PVOID>(pData->pVoid);
            DO_DEL(pVoid);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   DirectReportsList
//
//  Synopsis:   Handles the User Organisation Direct Reports list.
//
//-----------------------------------------------------------------------------
HRESULT
DirectReportsList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA,
                  DLG_OP DlgOp)
{
  //
  // Multi-select will result in a return at this point
  //
  if (pPage->GetObjPathName() == NULL)
  {
    return S_OK;
  }

  switch (DlgOp)
  {
    case fInit:
      {
        HRESULT hr;
        Smart_PADS_ATTR_INFO spAttrs;
        DWORD cAttrs = 0;
        PWSTR rgpwzAttrNames[] = {pAttrMap->AttrInfo.pszAttrName};
        CComPtr <IDirectoryObject> spGcObj;

        hr = BindToGCcopyOfObj(pPage, pPage->GetObjPathName(), &spGcObj);

        if (SUCCEEDED(hr))
        {
          hr = spGcObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

          if (SUCCEEDED(hr))
          {
            //
            // If the bind to the GC was successful, use those results.
            // Otherwise, use the results of the local object read.
            //
            if (!cAttrs)
            {
              return S_OK;
            }
            pAttrInfo = spAttrs;
          }
        }

        if (!pAttrInfo)
        {
          return S_OK;
        }

        for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
        {
          PWSTR pwzDns;
          hr = CrackName(pAttrInfo->pADsValues[i].DNString, &pwzDns,
                         GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());

          CHECK_HRESULT(hr, return hr);

          PTSTR ptz, ptzName;
          if (!UnicodeToTchar(pwzDns, &ptz))
          {
            LocalFreeStringW(&pwzDns);
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
          }
          LocalFreeStringW(&pwzDns);
          ptzName = _tcschr(ptz, TEXT('\n'));
          dspAssert(ptzName);
          ptzName++;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST, LB_ADDSTRING,
                                               0, (LPARAM)ptzName);
          if (lresult != LB_ERR)
          {
            PWSTR pwzDN = new WCHAR[wcslen(pAttrInfo->pADsValues[i].DNString) + 1];
            if (pwzDN != NULL)
            {
              wcscpy(pwzDN, pAttrInfo->pADsValues[i].DNString);
              SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                 LB_SETITEMDATA, lresult, (LPARAM)pwzDN);
            }
          }
          delete [] ptz;
        }
      }
      break;
    
    case fOnCommand:
      {
        if (lParam == LBN_DBLCLK)
        {
          //
          // Retrieve the current selection
          //
          PWSTR pwzDN = NULL;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                               LB_GETCURSEL, 0, 0);

          if (lresult != LB_ERR)
          {
            //
            // Get the DN associated with the item
            //
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, lresult, 0);
            if (lresult != LB_ERR)
            {
              pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                //
                // Launch the secondary proppages
                //
                PostPropSheet(pwzDN, pPage);
              }
            }
          }
        }
      }
      break;
    
    case fOnDestroy:
      {
        //
        // Must free the memory associated with the list box
        //
        LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                             LB_GETCOUNT, 0, 0);
        if (lresult != LB_ERR)
        {
          for (LRESULT idx = lresult - 1 ; idx >= 0; idx--)
          {
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, idx, 0);
            if (lresult != LB_ERR)
            {
              PWSTR pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                delete [] pwzDN;
              }
            }
          }
        }
      }
      break;

    default:
      break;
  }

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\user.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       user.h
//
//  Contents:   AD user object shell property pages header
//
//  Classes:    CDsUserAcctPage, CDsUsrProfilePage, CDsMembershipPage
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _USER_H_
#define _USER_H_

#include "objlist.h"

BOOL ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, BOOL& fExpanded);

HRESULT CountryName(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CountryCode(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT TextCountry(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerChangeBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                         LPARAM, PATTR_DATA, DLG_OP);

HRESULT MgrPropBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                   LPARAM, PATTR_DATA, DLG_OP);

HRESULT ClearMgrBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT DirectReportsList(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                          LPARAM, PATTR_DATA, DLG_OP);

HRESULT AddReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT RmReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

HRESULT MailAttr(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                 LPARAM, PATTR_DATA, DLG_OP);

HRESULT ShBusAddrBtn(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

// CountryCode helpers:

typedef struct _DsCountryCode {
    WORD  wCode;
    WCHAR pwz2CharAbrev[3];
} DsCountryCode, *PDsCountryCode;

BOOL GetALineOfCodes(PTSTR pwzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode);

void RemoveTrailingWhitespace(PTSTR pwz);

#endif // _USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined (DBG)
   #undef TRACE
   void  DSATrace(LPCWSTR, ...);
   #define TRACE DSATrace


   #undef ASSERT
   #undef VERIFY
   #undef THIS_FILE
   #define THIS_FILE          __FILE__
   BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
   #define ASSERT(f) \
	   do \
	   { \
       BOOL bLame = (f && L"hack so that prefast doesn't bark"); \
  	   if (!(bLame) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
	  	   ::DebugBreak(); \
	   } while (0) \

   #define VERIFY(f)          ASSERT(f)
#else
   #undef ASSERT
   #define ASSERT
   #define TRACE
   #define VERIFY(f)    f
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\dsadminp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsadminp.h
//
//--------------------------------------------------------------------------


//
// CoClass for the choose DC dialog object
//

// {8F2AC965-04A2-11d3-82BD-00C04F68928B}
DEFINE_GUID(CLSID_DsAdminChooseDCObj, 
0x8f2ac965, 0x4a2, 0x11d3, 0x82, 0xbd, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


//
// Interface to access the choose DC dialog object
//

// {A5F06B5F-04A2-11d3-82BD-00C04F68928B}
DEFINE_GUID(IID_IDsAdminChooseDC, 
0xa5f06b5f, 0x4a2, 0x11d3, 0x82, 0xbd, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);



#ifndef _DSADMINP_H
#define _DSADMINP_H



// ----------------------------------------------------------------------------
// 
// Interface: IDsAdminChooseDC
//  
// Implemented by the object CLSID_DsAdminChooseDCObj
//
// Used by: any client needing to invoke the DC selection UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsAdminChooseDC

DECLARE_INTERFACE_(IDsAdminChooseDC, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminChooseDC methods ***
  STDMETHOD(InvokeDialog)(THIS_ /*IN*/  HWND hwndParent,
                                /*IN*/  LPCWSTR lpszTargetDomain,
                                /*IN*/  LPCWSTR lpszTargetDomainController,
                                /*IN*/  ULONG uFlags,
                                /*OUT*/ BSTR* bstrSelectedDC) PURE;
};











/////////////////////////////////////////////////////////////////////
// macros

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)



/////////////////////////////////////////////////////////////////////
// Helper global API's

HRESULT GetAttr(       IN IADs* pIADs, IN WCHAR* wzAttr, OUT PADS_ATTR_INFO* ppAttrs );
HRESULT GetStringAttr( IN IADs* pIADs, IN WCHAR* wzAttr, OUT BSTR* pbstr );
HRESULT GetObjectGUID( IN IADs* pIADs, OUT UUID* pUUID );
HRESULT GetObjectGUID( IN IADs* pIADs, OUT BSTR* pbstrObjectGUID );

HRESULT GetADSIServerName(OUT PWSTR* szServer, IN IUnknown* pUnk);


int cchLoadHrMsg( IN HRESULT hr, OUT PTSTR* pptzSysMsg, IN BOOL TryADsIErrors );
void StringErrorFromHr(HRESULT hr, OUT PWSTR* pszError, BOOL TryADsIErrors = TRUE);


/////////////////////////////////////////////////////////////////////
// FSMO Mainipulation API's

class CDSBasePathsInfo; // fwd decl.

enum FSMO_TYPE
{
  SCHEMA_FSMO,
  RID_POOL_FSMO,
  PDC_FSMO,
  INFRASTUCTURE_FSMO,
  DOMAIN_NAMING_FSMO,
};

HRESULT FindFsmoOwner(IN CDSBasePathsInfo* pCurrentPath,
                      IN FSMO_TYPE fsmoType,
                      OUT CDSBasePathsInfo* pFsmoOwnerPath,
                      OUT PWSTR* pszFsmoOwnerServerName);

HRESULT CheckpointFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo);
HRESULT GracefulFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo, IN FSMO_TYPE fsmoType);
HRESULT ForcedFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo,
                                IN FSMO_TYPE fsmoType);




/////////////////////////////////////////////////////////////////////
// CDSBasePathsInfo

class CDSBasePathsInfo
{
public:
  CDSBasePathsInfo();
  ~CDSBasePathsInfo();

  // initialization functions  
  HRESULT InitFromName(LPCWSTR lpszServerOrDomainName);
  HRESULT InitFromContainer(IADsContainer* pADsContainerObj);
  HRESULT InitFromInfo(CDSBasePathsInfo* pBasePathsInfo);

  // accessor functions
  IADs* GetRootDSE() { return m_spRootDSE;}

  LPCWSTR GetProvider()               { return L"LDAP://";}
  LPCWSTR GetProviderAndServerName()  { return m_szProviderAndServerName;}
  LPCWSTR GetServerName()             { return m_szServerName;}
  LPCWSTR GetDomainName()             { return m_szDomainName;}

  LPCWSTR GetSchemaNamingContext()      { return m_szSchemaNamingContext;}
  LPCWSTR GetConfigNamingContext()      { return m_szConfigNamingContext;}
  LPCWSTR GetDefaultRootNamingContext() {return m_szDefaultNamingContext;}
  LPCWSTR GetRootDomainNamingContext()  {return m_szRootDomainNamingContext;}

  UINT    GetDomainBehaviorVersion()  { return m_nDomainBehaviorVersion; }
  UINT    GetForestBehaviorVersion()  { return m_nForestBehaviorVersion; }
  UINT    GetSchemaVersion()          { return m_nSchemaVersion; }


  // helper functions to compose LDAP paths out of naming contexts
  // NOTE: the caller needs to free the memory allocated for the returned
  //       string by using the operator delete[]
  //
  int ComposeADsIPath(OUT PWSTR* pszPath, IN LPCWSTR lpszNamingContext);

  int GetSchemaPath(OUT PWSTR* s);
  int GetConfigPath(OUT PWSTR* s);
  int GetDefaultRootPath(OUT PWSTR* s);
  int GetRootDomainPath(OUT PWSTR* s);
  int GetRootDSEPath(OUT PWSTR* s);
  int GetAbstractSchemaPath(OUT PWSTR* s);
  int GetPartitionsPath(OUT PWSTR* s);
  int GetSchemaObjectPath(IN LPCWSTR lpszObjClass, OUT PWSTR* s);
  int GetInfrastructureObjectPath(OUT PWSTR* s);

  // display specifiers cache API's
  HRESULT GetDisplaySpecifier(LPCWSTR lpszObjectClass, REFIID riid, void** ppv);
  HICON GetIcon(LPCWSTR lpszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon);
  HRESULT GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                               LPWSTR lpszBuffer, int cchBuffer);
  HRESULT GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                   LPCWSTR lpszAttributeName,
                                   LPWSTR lpszBuffer, int cchBuffer);
  BOOL IsClassContainer(LPCWSTR lpszObjectClass, LPCWSTR lpszADsPath, DWORD dwFlags);
  HRESULT GetClassCreationInfo(LPCWSTR lpszObjectClass, LPDSCLASSCREATIONINFO* ppdscci);
  HRESULT GetAttributeADsType(LPCWSTR lpszAttributeName, ADSTYPE& attrType);

  bool IsInitialized() { return m_bIsInitialized; }

  UINT AddRef() { return ++m_nRefs; }
  UINT Release();

private:
  PWSTR m_szServerName;             // DNS server (DC) name (e.g. "mydc.mycomp.com.")
  PWSTR m_szDomainName;             // DNS domain name (e.g. "mydom.mycomp.com.")
  PWSTR m_szProviderAndServerName;  // LDAP://<server>/

  PWSTR m_szSchemaNamingContext;
  PWSTR m_szConfigNamingContext;
  PWSTR m_szDefaultNamingContext;
  PWSTR m_szRootDomainNamingContext;

  UINT  m_nDomainBehaviorVersion;
  UINT  m_nForestBehaviorVersion;
  UINT  m_nSchemaVersion;

  UINT  m_nRefs;

  CComPtr<IADs>                     m_spRootDSE;  // cached connection
  CComPtr<IDsDisplaySpecifier>      m_spIDsDisplaySpecifier;  // pointer to Display Specifier Cache

  bool  m_bIsInitialized;

  HRESULT _InitHelper();
  void _Reset();
  void _BuildProviderAndServerName();
};

// This is a smart wrapper around the CDSBasePathsInfo class

class CDSSmartBasePathsInfo
{
public:
  CDSSmartBasePathsInfo() : m_ptr(0)
  {
  }

  CDSSmartBasePathsInfo(const CDSSmartBasePathsInfo& rhs) : m_ptr(0)
  {
     Acquire(rhs.m_ptr);
  }

  CDSSmartBasePathsInfo(CDSBasePathsInfo* ptr) : m_ptr(0)
  {
     Acquire(ptr);
  }

  ~CDSSmartBasePathsInfo()
  {
     if (m_ptr)
     {
        m_ptr->Release();
        m_ptr = 0;
     }
  }

  CDSSmartBasePathsInfo& operator=(const CDSSmartBasePathsInfo& rhs)
  {
     Acquire(rhs.m_ptr);
     return *this;
  }

  CDSBasePathsInfo* operator->() const
  {
     return m_ptr;
  }

private:
  
  void Acquire(CDSBasePathsInfo* ptr)
  {
     if (m_ptr)
     {
        m_ptr->Release();
     }

     m_ptr = ptr;
     if (m_ptr)
     {
        m_ptr->AddRef();
     }
  }

  CDSBasePathsInfo* m_ptr;
};

///////////////////////////////////////////////////////////////////////////////
// CDsDisplaySpecOptionsCFHolder
//
// Helper class to cache a DSDISPLAYSPECOPTIONS struct for the 
// corresponding clipboard format

class CDsDisplaySpecOptionsCFHolder
{
public:
  CDsDisplaySpecOptionsCFHolder()
  {
    m_pDsDisplaySpecOptions = NULL;
  }
  ~CDsDisplaySpecOptionsCFHolder()
  {
    if (m_pDsDisplaySpecOptions != NULL)
      GlobalFree(m_pDsDisplaySpecOptions);
  }
  HRESULT Init(CDSBasePathsInfo* pBasePathInfo);
  PDSDISPLAYSPECOPTIONS Get();
private:
  PDSDISPLAYSPECOPTIONS m_pDsDisplaySpecOptions;
};

//////////////////////////////////////////////////////////////////////////
// CToggleTextControlHelper

class CToggleTextControlHelper
{
public:
	CToggleTextControlHelper();
  ~CToggleTextControlHelper();
  BOOL Init(HWND hWnd);
	void SetToggleState(BOOL bFirst);

private:
	HWND m_hWnd;
  WCHAR* m_pTxt1;
  WCHAR* m_pTxt2;
};


#endif //_DSADMINP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\propcfg.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propcfg.cpp
//
//  Contents:   Data object clipboard format for property sheet configuration
//              information.
//
//  History:    30-May-97 EricB - Created
//-----------------------------------------------------------------------------

#ifndef __PROPCFG_H__
#define __PROPCFG_H__


// private message for secondary sheet creation sent to the notify object
#define WM_ADSPROP_SHEET_CREATE       (WM_USER + 1108) 
// private message for retrieving a pointer to an instance of the notify object
// associated with a particular HWND
#define WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ (WM_USER + 1111)

// struct used as WPARAM argument for the secondary sheet creation message
typedef struct _DSA_SEC_PAGE_INFO
{
    HWND    hwndParentSheet;
    DWORD   offsetTitle;                // offset to the sheet title
    DSOBJECTNAMES dsObjectNames;        // single selection DSOBJECTNAMES struct
} DSA_SEC_PAGE_INFO, * PDSA_SEC_PAGE_INFO;


///////////////////////////////////////////////////////////////////////////


// private messages to be sent to DSA 

// message to be posted to DSA hidden window to notify a sheet has closed
// the wParam of the message is a cookie provided in the PROPSHEETCFG struct/CF
#define WM_DSA_SHEET_CLOSE_NOTIFY     (WM_USER + 5) 


// message to be posted to DSA hidden window to create secondary sheet
// the wParam of the message is a PDSA_SEC_PAGE_INFO 
#define WM_DSA_SHEET_CREATE_NOTIFY    (WM_USER + 6) 


#define CFSTR_DS_PROPSHEETCONFIG L"DsPropSheetCfgClipFormat"

#define CFSTR_DS_PARENTHWND L"DsAdminParentHwndClipFormat"

#define CFSTR_DS_SCHEMA_PATH L"DsAdminSchemaPathClipFormat"

#define CFSTR_DS_MULTISELECTPROPPAGE L"DsAdminMultiSelectClipFormat"

#endif // __PROPCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\dscmn.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dscmn.h
//
//  Contents:   Methods exported from DSPROP.DLL for use in DSADMIN.DLL
//
//  History:    19-February-98 JonN created
//
//-----------------------------------------------------------------------------

#ifndef _DSCMN_H_
#define _DSCMN_H_

#include <ADsOpenFlags.h> // GetADsOpenObjectFlags

//
// Illegal characters that cannot be used in the UPN or SAM Account name
//
#define INVALID_ACCOUNT_NAME_CHARS         L"\"/\\[]:|<>+=;,?,*"
#define INVALID_ACCOUNT_NAME_CHARS_WITH_AT L"\"/\\[]:|<>+=;,?,*@"

// This GUID is copied from ds\setup\schema.ini
#define SZ_GUID_CONTROL_UserChangePassword L"ab721a53-1e2f-11d0-9819-00aa0040529b"
extern const GUID GUID_CONTROL_UserChangePassword;
/* add this to your source:
const GUID GUID_CONTROL_UserChangePassword =
    { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};
*/

HRESULT DSPROP_PickComputer(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath, // only the server name is used
	OUT BSTR* pbstrADsPath );
HRESULT DSPROP_PickNTDSDSA(
    IN HWND hwndParent,
    IN LPCWSTR lpcwszRootPath,
    OUT BSTR* pbstrADsPath );
HRESULT DSPROP_DSQuery(
    IN HWND hwndParent,
    IN LPCWSTR lpcwszRootPath,
    IN CLSID* pclsidDefaultForm,
    OUT BSTR* pbstrADsPath );
HRESULT DSPROP_IsFrsObject( IN LPWSTR pszClassName, OUT bool* pfIsFrsObject );
HRESULT DSPROP_RemoveX500LeafElements(
    IN unsigned int nElements,
    IN OUT BSTR* pbstrADsPath );
HRESULT DSPROP_TweakADsPath(
    IN     LPCWSTR       lpcwszInitialADsPath,
    IN     int           iTargetLevelsUp,
    IN     PWCHAR*       ppwszTargetLevelsBack,
    OUT    BSTR*         pbstrResultDN
    );
HRESULT DSPROP_RetrieveRDN(
    IN     LPCWSTR       lpwszDN,
    OUT    BSTR*         pbstrRDN
    );
//HRESULT DSPROP_GetGCSearch(
//    IN  REFIID iid,
//    OUT void** ppvObject
//    );
HRESULT DSPROP_GetGCSearchOnDomain(
    PWSTR pwzDomainDnsName,
    IN  REFIID iid,
    OUT void** ppvObject
    );

typedef enum {
    GET_OBJ_CAN_NAME,
    GET_OBJ_CAN_NAME_EX,
    GET_OBJ_1779_DN,
    GET_OBJ_NT4_NAME,
    GET_DNS_DOMAIN_NAME,
    GET_NT4_DOMAIN_NAME,
    GET_FQDN_DOMAIN_NAME,
    GET_OBJ_UPN
} CRACK_NAME_OPR;

HRESULT CrackName(PWSTR pwzNameIn, PWSTR * ppwzDnsName,
                  CRACK_NAME_OPR Opr, HWND hWnd = NULL);

void MsgBox(UINT MsgID, HWND hWnd);
void MsgBox2(UINT MsgID, UINT InsertID, HWND hWnd);
//
// Error reporting. Note, use MsgBoxX (see above) for non-error messages.
//
void ErrMsg(UINT MsgID, HWND hWnd = NULL);
void ErrMsgParam(UINT MsgID, LPARAM param, HWND hWnd = NULL);

BOOL CheckADsError(HRESULT * phr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line, HWND hwnd = NULL);
#define CHECK_ADS_HR(phr, hwnd) CheckADsError(phr, FALSE, __FILE__, __LINE__, hwnd)
#define CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(phr, hwnd) \
            CheckADsError(phr, TRUE, __FILE__, __LINE__, hwnd)
void ReportError(HRESULT hr, int nStr, HWND hWnd = NULL);
#if defined(DSADMIN)
//+----------------------------------------------------------------------------
//
//  Function:   SuperMsgBox
//
//  Synopsis:   Displays a message obtained from a string resource with
//              the parameters expanded. The error param, dwErr, if
//              non-zero, is converted to a string and becomes the first
//              replaceable param.
//
//              This function includes the functionality of ReportErrorEx in
//              dsadmin\util.cpp *except* it does not have SpecialMessageBox.
//              It also can replace ReportMessageEx by setting dwErr to zero.
//
//  Note: this function is UNICODE-only.
//
//-----------------------------------------------------------------------------
int SuperMsgBox(
    HWND hWnd,          // owning window.
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    int nTitleId,       // string resource ID of the title. If zero, uses IDS_MSG_TITLE.
    UINT ufStyle,       // MessageBox flags.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PSTR szFile,        // use the __FILE__ macro. ignored in retail build.
    int nLine           // use the __LINE__ macro. ignored in retail build.
    );
#endif //defined(DSADMIN)

HRESULT
ModifyNetWareUserPassword(
    IN IADsUser*          pADsUser,
    IN PCWSTR             pwzADsPath,
    IN PCWSTR             pwzNewPassword
);

BOOL CheckGroupUpdate(HRESULT hr, HWND hPage = NULL, BOOL fAdd = TRUE, PWSTR pwzDN = NULL);

#ifndef dspAssert
#define dspAssert ASSERT
#endif

// smartpointer for PADS_ATTR_INFO
class Smart_PADS_ATTR_INFO
{
private:
  PADS_ATTR_INFO m_pAttrs;
public:
  Smart_PADS_ATTR_INFO::Smart_PADS_ATTR_INFO() : m_pAttrs(NULL) {}
  Smart_PADS_ATTR_INFO::~Smart_PADS_ATTR_INFO() { Empty(); }
  operator PADS_ATTR_INFO() const { return m_pAttrs; }
  PADS_ATTR_INFO* operator&() { return &m_pAttrs; }
  PADS_ATTR_INFO operator->() {dspAssert(m_pAttrs); return m_pAttrs;}
  void Empty() 
  {
    if (NULL != m_pAttrs)
    {
      FreeADsMem( m_pAttrs );
      m_pAttrs = NULL;
    }
  }
};

// smartpointer for DsBind handle
void Smart_DsHandle__Empty( HANDLE* phDs );
class Smart_DsHandle
{
private:
  HANDLE m_hDs;
public:
  Smart_DsHandle::Smart_DsHandle() : m_hDs(NULL) {}
  Smart_DsHandle::~Smart_DsHandle() { Empty(); }
  operator HANDLE() const { return m_hDs; }
  HANDLE* operator&() { return &m_hDs; }
  void Empty() { Smart_DsHandle__Empty( &m_hDs ); }
};

class DSPROP_BSTR_BLOCK;
bool  DSPROP_BSTR_BLOCK__SetCount(  DSPROP_BSTR_BLOCK& block, int cItems );
BSTR& DSPROP_BSTR_BLOCK__Reference( DSPROP_BSTR_BLOCK& block, int iItem  );

class DSPROP_BSTR_BLOCK
{
public:
    DSPROP_BSTR_BLOCK()
        : m_cItems( 0 )
        , m_abstrItems( NULL ) {}
    ~DSPROP_BSTR_BLOCK() { Empty(); }

    int QueryCount() const { return m_cItems; }
    const BSTR operator[](int iItem) const
        { return DSPROP_BSTR_BLOCK__Reference(
                const_cast<DSPROP_BSTR_BLOCK&>(*this), iItem ); }
    operator const BSTR*() const { return m_abstrItems; }
    operator LPWSTR*() const { return (LPWSTR*)m_abstrItems; }

    bool SetCount( int cItems )
        { return DSPROP_BSTR_BLOCK__SetCount(  *this, cItems ); }
    bool Set( BSTR cbstrItem, int iItem )
        {
            return (NULL != (
                DSPROP_BSTR_BLOCK__Reference( *this, iItem ) =
                    ::SysAllocString(cbstrItem) ) );
        }

    void Empty() { (void) SetCount(0); }

private:
    int   m_cItems;
    BSTR* m_abstrItems;

friend bool  DSPROP_BSTR_BLOCK__SetCount(  DSPROP_BSTR_BLOCK& block, int cItems );
friend BSTR& DSPROP_BSTR_BLOCK__Reference( DSPROP_BSTR_BLOCK& block, int iItem  );
};

HRESULT DSPROP_ShallowSearch(
    IN OUT DSPROP_BSTR_BLOCK* pbstrBlock,
    IN LPCTSTR lpcwszADsPathDirectory,
    IN LPCTSTR lpcwszTargetDesiredClass,
    IN PADS_ATTR_INFO pAttrInfoExclusions = NULL
    );

// The following functions support duelling listbox capability
HRESULT DSPROP_Duelling_Populate(
    IN HWND hwndListbox,
    IN const DSPROP_BSTR_BLOCK& bstrblock
    );
void DSPROP_Duelling_UpdateButtons(
    HWND hwndDlg,
    int nAnyCtrlid
    );
void DSPROP_Duelling_ButtonClick(
    HWND hwndDlg,
    int nButtonCtrlid
    );
void DSPROP_Duelling_ClearListbox(
    HWND hwndListbox
    );

// JonN 4/8/99: add code to enable horizontal scrolling where appropriate
HRESULT DSPROP_HScrollStringListbox(
    HWND hwndListbox
    );


DWORD DSPROP_CreateHomeDirectory(IN PSID pUserSid, IN LPCWSTR lpszPathName);
BOOL DSPROP_IsValidUNCPath(LPCWSTR lpszPath);

void DSPROP_DomainVersionDlg(PCWSTR pwzDomainPath, PCWSTR pwzDomainDnsName,
                             HWND hWndParent);
void DSPROP_ForestVersionDlg(PCWSTR pwzConfigPath, PCWSTR pwzPartitionsPath,
                             PCWSTR pwzSchemaPath, PCWSTR pwzRootDnsName,
                             HWND hWndParent);


//
// This is a wrapper for ADsOpenObject.  It gives DSAdmin a single point to change
// global flags that are passed to ADsOpenObject without have to search and replace
// all occurrences in the code
// 
inline
HRESULT DSAdminOpenObject(PCWSTR pszPath, 
                          REFIID refIID, 
                          PVOID* ppObject, 
                          BOOL bServer = FALSE)
{
  HRESULT hr = S_OK;
  DWORD dwFlags = ADS_SECURE_AUTHENTICATION;

  if (bServer)
  {
    //
    // If we know we are connecting to a specific server and not domain in general
    // then pass the ADS_SERVER_BIND flag to save ADSI the trouble of figuring it out
    //
    dwFlags |= ADS_SERVER_BIND;
  }

  //
  // Get the security flags for ADsOpenObject using the published inline function
  // so that we can turn off signing/sealing/etc. based on regkeys.
  // For performance reasons we only want to read the regkey once.
  //
  static DWORD retrievedFlags = GetADsOpenObjectFlags();

  dwFlags |= retrievedFlags;

  hr = ADsOpenObject((LPWSTR)pszPath, NULL, NULL, dwFlags, refIID, ppObject);

  return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDsObjectSD
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pszObjectPath] --  LDAP Path of ds object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
HRESULT GetDsObjectSD(LPCWSTR pszObjectPath,
                      PACL* ppDACL,
                      PSECURITY_DESCRIPTOR* ppSecurityDescriptor);


//+---------------------------------------------------------------------------
//
//  Function:   SetDsObjectDacl
//  Synopsis:   Writes the specified DACL to the specified DS object
//
//  Arguments:  [IN  pszObjectPath] --  LDAP Path of ds object
//              [pDACL]             --  pointer to dacl to be set
//
//  Notes:      
//
//----------------------------------------------------------------------------
HRESULT SetDsObjectDacl(LPCWSTR pszObjectPath,
                        PACL pDACL);


#endif // _DSCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\secondaryproppages.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       secondaryProppages.h
//
//--------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
// CSecondaryPagesManager

template <class TCOOKIE> class CSecondaryPagesManager
{
public:
  ~CSecondaryPagesManager()
  {
    ASSERT(m_secondaryPagesCookies.IsEmpty());
  }

  HRESULT CreateSheet(HWND hWndParent, 
                      LPCONSOLE pIConsole, 
                      IUnknown* pUnkComponentData,
                      TCOOKIE* pCookie,
                      IDataObject* pDataObject,
                      LPCWSTR lpszTitle)
  {
    ASSERT(pIConsole != NULL);
    ASSERT(pDataObject != NULL);
    ASSERT(pUnkComponentData != NULL);

	  // get an interface to a sheet provider
	  CComPtr<IPropertySheetProvider> spSheetProvider;
	  HRESULT hr = pIConsole->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
	  ASSERT(SUCCEEDED(hr));
	  ASSERT(spSheetProvider != NULL);

	  // get an interface to a sheet callback
	  CComPtr<IPropertySheetCallback> spSheetCallback;
	  hr = pIConsole->QueryInterface(IID_IPropertySheetCallback,(void**)&spSheetCallback);
	  ASSERT(SUCCEEDED(hr));
	  ASSERT(spSheetCallback != NULL);

	  ASSERT(pDataObject != NULL);

	  // get a sheet
    MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pCookie);
	  hr = spSheetProvider->CreatePropertySheet(lpszTitle, TRUE, cookie, 
                                              pDataObject, 0x0 /*dwOptions*/);
	  ASSERT(SUCCEEDED(hr));

	  hr = spSheetProvider->AddPrimaryPages(pUnkComponentData,
											  FALSE /*bCreateHandle*/,
											  hWndParent,
											  FALSE /* bScopePane*/);

    hr = spSheetProvider->AddExtensionPages();

	  ASSERT(SUCCEEDED(hr));

	  hr = spSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWndParent), 0);
	  ASSERT(SUCCEEDED(hr));

    if (pCookie->IsSheetLocked())
    {
      // we created the sheet correctly,
      // add it to the list of cookies
      m_secondaryPagesCookies.AddTail(pCookie);
    }

	  return hr;
  }

  BOOL IsCookiePresent(TCOOKIE* pCookie)
  {
    return (m_secondaryPagesCookies.Find(pCookie) != NULL);
  }

  template <class CMP> TCOOKIE* FindCookie(CMP compare)
  {
    for (POSITION pos = m_secondaryPagesCookies.GetHeadPosition(); pos != NULL; )
    {
      TCOOKIE* pCookie = m_secondaryPagesCookies.GetNext(pos);
      if (compare(pCookie))
      {
        // found
        return pCookie;
      }
    }
    return NULL;
  }
  void OnSheetClose(TCOOKIE* pCookie)
  {
    // remove from the list of cookies and delete memory
    POSITION pos = m_secondaryPagesCookies.Find(pCookie);
    if (pos != NULL) 
    {
      ASSERT(!pCookie->IsSheetLocked());
      m_secondaryPagesCookies.RemoveAt(pos);
      delete pCookie;
    }
  }

private:
  CList <TCOOKIE *, TCOOKIE*> m_secondaryPagesCookies;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\pcrack.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pcrack.h
//
//  requires iads.h (IADsPathname) and atlbase.h (CComPtr)
//
//--------------------------------------------------------------------------

// pcrack.h : include file for CPathCracker

#ifndef __PCRACK_H__
#define __PCRACK_H__

class CPathCracker
{
public:
  CPathCracker()
  {
    m_hrCreate = Init();
  }
private:

  HRESULT Init()
  {
    HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(m_spIADsPathname));
    return hr;
  }
  
public:
  
  // IADsPathname methods
  virtual /* [id] */ HRESULT STDMETHODCALLTYPE Set( 
      /* [in] */ const BSTR bstrADsPath,
      /* [in] */ long lnSetType) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Set(bstrADsPath, lnSetType); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDisplayType( 
      /* [in] */ long lnDisplayType) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->SetDisplayType(lnDisplayType); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE Retrieve( 
      /* [in] */ long lnFormatType,
      /* [retval][out] */ BSTR __RPC_FAR *pbstrADsPath) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Retrieve(lnFormatType, pbstrADsPath); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNumElements( 
      /* [retval][out] */ long __RPC_FAR *plnNumPathElements)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetNumElements(plnNumPathElements); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetElement( 
      /* [in] */ long lnElementIndex,
      /* [retval][out] */ BSTR __RPC_FAR *pbstrElement)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetElement(lnElementIndex, pbstrElement); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddLeafElement( 
      /* [in] */ BSTR bstrLeafElement)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->AddLeafElement(bstrLeafElement); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE RemoveLeafElement( void)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->RemoveLeafElement(); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyPath( 
      /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppAdsPath)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->CopyPath(ppAdsPath); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEscapedElement( 
      /* [in] */ long lnReserved,
      /* [in] */ const BSTR bstrInStr,
      /* [retval][out] */ BSTR __RPC_FAR *pbstrOutStr)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetEscapedElement(lnReserved, bstrInStr, pbstrOutStr); }

  virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EscapedMode( 
      /* [retval][out] */ long __RPC_FAR *retval)  
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->get_EscapedMode(retval); }

  virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EscapedMode( 
      /* [in] */ long lnEscapedMode) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->put_EscapedMode(lnEscapedMode); }


private:
  CComPtr<IADsPathname> m_spIADsPathname;
  HRESULT m_hrCreate;
};

#endif _PCRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\src\basepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       basePathsInfo.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"


/////////////////////////////////////////////////////////////////////
// CDSBasePathsInfo

CDSBasePathsInfo::CDSBasePathsInfo() : 
  m_nDomainBehaviorVersion(0), 
  m_nForestBehaviorVersion(0),
  m_nSchemaVersion(0),
  m_nRefs(0),
  m_szServerName(0),
  m_szDomainName(0),
  m_szProviderAndServerName(0),
  m_szSchemaNamingContext(0),
  m_szConfigNamingContext(0),
  m_szDefaultNamingContext(0),
  m_szRootDomainNamingContext(0),
  m_bIsInitialized(false)
{
}

CDSBasePathsInfo::~CDSBasePathsInfo()
{
  _Reset();
}

UINT CDSBasePathsInfo::Release()
{
   if (--m_nRefs == 0)
   {
      delete this;
      return 0;
   }

   return m_nRefs;
}

HRESULT CDSBasePathsInfo::InitFromContainer(IADsContainer* pADsContainerObj)
{
  _Reset();
  PWSTR szServer = 0;
  HRESULT hr = GetADSIServerName(OUT &szServer, IN pADsContainerObj);
  if (SUCCEEDED(hr) && szServer)
  {
    hr = InitFromName(szServer);
  }

  if (szServer)
  {
     delete[] szServer;
     szServer = 0;
  }
  m_bIsInitialized = true;
  return hr;
}

HRESULT CDSBasePathsInfo::InitFromInfo(CDSBasePathsInfo* pBasePathsInfo)
{
  if (pBasePathsInfo->m_szServerName)
  {
     if (m_szServerName)
     {
        delete[] m_szServerName;
     }

     m_szServerName = new WCHAR[wcslen(pBasePathsInfo->m_szServerName) + 1];
     ASSERT(m_szServerName);
     if (m_szServerName)
     {
       wcsncpy(m_szServerName, pBasePathsInfo->m_szServerName, wcslen(pBasePathsInfo->m_szServerName) + 1);
     }
  }

  if (pBasePathsInfo->m_szDomainName)
  {
     if (m_szDomainName)
     {
       delete[] m_szDomainName;
     }
     m_szDomainName = new WCHAR[wcslen(pBasePathsInfo->m_szDomainName) + 1];
     ASSERT(m_szDomainName);
     if (m_szDomainName)
     {
       wcsncpy(m_szDomainName ,pBasePathsInfo->m_szDomainName, wcslen(pBasePathsInfo->m_szDomainName) + 1);
     }
  }


  if (pBasePathsInfo->m_szProviderAndServerName)
  {
     if (m_szProviderAndServerName)
     {
       delete[] m_szProviderAndServerName;
     }
     m_szProviderAndServerName = new WCHAR[wcslen(pBasePathsInfo->m_szProviderAndServerName) + 1];
     ASSERT(m_szProviderAndServerName);
     if (m_szProviderAndServerName)
     {
       wcsncpy(m_szProviderAndServerName ,pBasePathsInfo->m_szProviderAndServerName,
               wcslen(pBasePathsInfo->m_szProviderAndServerName) + 1);
     }
  }

  if (pBasePathsInfo->m_szSchemaNamingContext)
  {
     if (m_szSchemaNamingContext)
     {
       delete[] m_szSchemaNamingContext;
     }
     m_szSchemaNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szSchemaNamingContext) + 1];
     ASSERT(m_szSchemaNamingContext);
     if (m_szSchemaNamingContext)
     {
       wcsncpy(m_szSchemaNamingContext, pBasePathsInfo->m_szSchemaNamingContext,
               wcslen(pBasePathsInfo->m_szSchemaNamingContext) + 1);
     }
  }

  if (pBasePathsInfo->m_szConfigNamingContext)
  {
     if (m_szConfigNamingContext)
     {
       delete[] m_szConfigNamingContext;
     }
     m_szConfigNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szConfigNamingContext) + 1];
     ASSERT(m_szConfigNamingContext);
     if (m_szConfigNamingContext)
     {
       wcsncpy(m_szConfigNamingContext, pBasePathsInfo->m_szConfigNamingContext,
               wcslen(pBasePathsInfo->m_szConfigNamingContext) + 1);
     }
  }

  if (pBasePathsInfo->m_szDefaultNamingContext)
  {
     if (m_szDefaultNamingContext)
     {
       delete[] m_szDefaultNamingContext;
     }
     m_szDefaultNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szDefaultNamingContext) + 1];
     ASSERT(m_szDefaultNamingContext);
     if (m_szDefaultNamingContext)
     {
       wcsncpy(m_szDefaultNamingContext, pBasePathsInfo->m_szDefaultNamingContext,
               wcslen(pBasePathsInfo->m_szDefaultNamingContext) + 1);
     }
  }


  if (pBasePathsInfo->m_szRootDomainNamingContext)
  {
    if (m_szRootDomainNamingContext)
    {
      delete[] m_szRootDomainNamingContext;
    }
    m_szRootDomainNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szRootDomainNamingContext) + 1];
    ASSERT(m_szRootDomainNamingContext);
    if (m_szRootDomainNamingContext)
    {
      wcsncpy(m_szRootDomainNamingContext, pBasePathsInfo->m_szRootDomainNamingContext,
              wcslen(pBasePathsInfo->m_szRootDomainNamingContext) + 1);
    }
  }

  m_spRootDSE = pBasePathsInfo->m_spRootDSE;
  m_spIDsDisplaySpecifier = pBasePathsInfo->m_spIDsDisplaySpecifier;
  
  m_nDomainBehaviorVersion = pBasePathsInfo->m_nDomainBehaviorVersion;
  m_nForestBehaviorVersion = pBasePathsInfo->m_nForestBehaviorVersion;
  m_nSchemaVersion = pBasePathsInfo->m_nSchemaVersion;

  _BuildProviderAndServerName();
  m_bIsInitialized = true;
  return S_OK;
}

int CDSBasePathsInfo::ComposeADsIPath(OUT PWSTR* pszPath, IN LPCWSTR lpszNamingContext)
{
  if (!pszPath || !IsInitialized())
  {
     return 0;
  }

  *pszPath = 0;

  PCWSTR pszServer = GetProviderAndServerName();

  if (!lpszNamingContext ||
      !pszServer)
  {
     return 0;
  }

  size_t length = wcslen(pszServer);
  length += wcslen(lpszNamingContext);

  int ret = 0;

  if (length)
  {
    *pszPath = new WCHAR[length + 1];
    ASSERT(*pszPath);

    if (*pszPath)
    {
      wcsncpy(*pszPath, pszServer, length + 1);
      wcsncat(*pszPath, lpszNamingContext, wcslen(lpszNamingContext));

      ret = static_cast<UINT>(wcslen(*pszPath) + 1);
    }
  }
  return ret;
}


HRESULT CDSBasePathsInfo::InitFromName(LPCWSTR lpszServerOrDomainName)
{
  TRACE(L"CDSBasePathsInfo::InitFromName(%s)\n", lpszServerOrDomainName);
  _Reset();

  // try to bind with the info we got
  PWSTR szProviderAndServerOrDomainName = 0;
  if ( (lpszServerOrDomainName == NULL) || (lpszServerOrDomainName[0] == NULL) )
  {
    szProviderAndServerOrDomainName = new WCHAR[wcslen(GetProvider()) + 1];
    if (szProviderAndServerOrDomainName)
    {
      wcsncpy(szProviderAndServerOrDomainName, GetProvider(), wcslen(GetProvider()) + 1);
    }
  }
  else
  {
    //
    // Add one more for the \0 and another for the /
    //
    size_t newStringLength = wcslen(GetProvider()) + wcslen(lpszServerOrDomainName) + 2;
    szProviderAndServerOrDomainName = new WCHAR[newStringLength];
    if (szProviderAndServerOrDomainName)
    {
      ZeroMemory(szProviderAndServerOrDomainName, newStringLength * sizeof(WCHAR));

      wcsncpy(
         szProviderAndServerOrDomainName, 
         GetProvider(), 
         newStringLength);

      wcsncat(
         szProviderAndServerOrDomainName, 
         lpszServerOrDomainName, 
         newStringLength - wcslen(szProviderAndServerOrDomainName));

      wcsncat(
         szProviderAndServerOrDomainName, 
         L"/", 
         newStringLength - wcslen(szProviderAndServerOrDomainName));
    }
  }

  if (!szProviderAndServerOrDomainName || szProviderAndServerOrDomainName[0] == L'\0')
  {
     return E_OUTOFMEMORY;
  }

  HRESULT hr = S_OK;
  VARIANT Schema, Config, Root, Default;

  ::VariantInit(&Schema);
  ::VariantInit(&Config);
  ::VariantInit(&Default);
  ::VariantInit(&Root);

  // get the RootDSE 
  TRACE(L"// get the RootDSE\n");
  PCWSTR pszRootDSE = L"RootDSE";

  size_t rootDSEStringLength = wcslen(szProviderAndServerOrDomainName) + wcslen(pszRootDSE) + 1;
  PWSTR szRootDSEPath = new WCHAR[rootDSEStringLength];
  if (!szRootDSEPath)
  {
    delete[] szProviderAndServerOrDomainName;
    szProviderAndServerOrDomainName = 0;
    
    hr = E_OUTOFMEMORY;
    goto error;
  }

  ZeroMemory(
    szRootDSEPath, 
    rootDSEStringLength * sizeof(WCHAR));

  wcsncpy(
    szRootDSEPath, 
    szProviderAndServerOrDomainName, 
    rootDSEStringLength);

  wcsncat(
    szRootDSEPath, 
    pszRootDSE, 
    rootDSEStringLength - wcslen(szRootDSEPath));

  hr = DSAdminOpenObject((LPWSTR)(LPCWSTR)szRootDSEPath,
                         IID_IADs, 
                         (void **)&m_spRootDSE);
  if (FAILED(hr))
  {
    TRACE(L"Failed to bind to RootDSE: DSAdminOpenObject(%s, ...) returned hr = 0x%x\n", 
            (LPCWSTR)szRootDSEPath, hr);
    goto error;
  }

  // get the schema naming context
  TRACE(L"get the schema naming context\n");
  hr = m_spRootDSE->Get(L"schemaNamingContext", &Schema);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get(schemaNamingContext, &Schema), returned hr = 0x%x\n", hr);
    goto error;
  }


  m_szSchemaNamingContext = new WCHAR[wcslen(Schema.bstrVal) + 1];
  ASSERT(m_szSchemaNamingContext);
  if (m_szSchemaNamingContext)
  {
     wcsncpy(m_szSchemaNamingContext, Schema.bstrVal, wcslen(Schema.bstrVal) + 1);
  }
  else
  {
     hr = E_OUTOFMEMORY;
     goto error;
  }

  // get the configuration naming context
  TRACE(L"// get the configuration naming context\n");
  hr = m_spRootDSE->Get(L"configurationNamingContext",&Config);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get(configurationNamingContext,&Config), returned hr = 0x%x\n", hr);
    goto error;
  }
  m_szConfigNamingContext = new WCHAR[wcslen(Config.bstrVal) + 1];
  ASSERT(m_szConfigNamingContext);
  if (m_szConfigNamingContext)
  {
     wcsncpy(m_szConfigNamingContext, Config.bstrVal, wcslen(Config.bstrVal) + 1);
  }
  else
  {
     hr = E_OUTOFMEMORY;
     goto error;
  }

  // get the default naming context
  TRACE(L"// get the default naming context\n");
  hr = m_spRootDSE->Get (L"defaultNamingContext", &Default);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get (defaultNamingContext, &Default), returned hr = 0x%x\n", hr);
    goto error;
  }
  m_szDefaultNamingContext = new WCHAR[wcslen(Default.bstrVal) + 1];
  ASSERT(m_szDefaultNamingContext);
  if (m_szDefaultNamingContext)
  {
     wcsncpy(m_szDefaultNamingContext, Default.bstrVal, wcslen(Default.bstrVal) + 1);
  }
  else
  {
     hr = E_OUTOFMEMORY;
     goto error;
  }
  TRACE(L"//defaultNamingContext = %s\n", m_szDefaultNamingContext);

  // get the enterprise root domain name
  TRACE(L"// get the root domain naming context\n");
  hr = m_spRootDSE->Get (L"rootDomainNamingContext", &Root);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get (rootDomainNamingContext, &Root), returned hr = 0x%x\n", hr);
    goto error;
  }
  m_szRootDomainNamingContext = new WCHAR[wcslen(Root.bstrVal) + 1];
  ASSERT(m_szRootDomainNamingContext);

  ZeroMemory(m_szRootDomainNamingContext, sizeof(WCHAR) * (wcslen(Root.bstrVal) + 1));
  if (m_szRootDomainNamingContext)
  {
     wcsncpy(m_szRootDomainNamingContext, Root.bstrVal, wcslen(Root.bstrVal) + 1);
  }
  TRACE(L"//rootDomainNamingContext = %s\n", m_szRootDomainNamingContext);

  do
  {
    //
    // retrieve the Domain Version from the domainDNS node
    //
    size_t newStringLengthToo = wcslen(szProviderAndServerOrDomainName) +
                                wcslen(GetDefaultRootNamingContext()) + 1;

    PWSTR szDomainPath = new WCHAR[newStringLengthToo];
    if (!szDomainPath)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    ZeroMemory(szDomainPath, newStringLengthToo);
    wcsncpy(szDomainPath, szProviderAndServerOrDomainName, newStringLengthToo);
    wcsncat(szDomainPath, GetDefaultRootNamingContext(), newStringLengthToo - wcslen(szProviderAndServerOrDomainName));

    CComPtr<IADs> spDomain;
    hr = DSAdminOpenObject(szDomainPath,
                           IID_IADs, 
                           (PVOID*)&spDomain);

    delete[] szDomainPath;
    szDomainPath = 0;

    if (FAILED(hr))
    {
      m_nDomainBehaviorVersion = 0;
      break;
    }

    VARIANT varVer;
    ::VariantInit(&varVer);

    hr = spDomain->GetInfo();

    CComBSTR bstrVer = L"msDS-Behavior-Version";
    hr = spDomain->Get(bstrVer, &varVer);
    if (FAILED(hr))
    {
       // Not an error. Can happen if a Whistler server is administering a Win2k AD.
       //
       TRACE(L"!! No domain behavior version attr.\n");
       hr = S_OK;
       m_nDomainBehaviorVersion = 0;
       break;
    }
    ASSERT(varVer.vt == VT_I4);
    m_nDomainBehaviorVersion = static_cast<UINT>(varVer.lVal);

    ::VariantClear(&varVer);
  } while (FALSE);

  do
  {
    //
    // retrieve the Forest Version from the partitions node
    //
    size_t newStringLengthToo = wcslen(szProviderAndServerOrDomainName) +
                                wcslen(GetConfigNamingContext()) + 1;

    PWSTR strPath = new WCHAR[newStringLengthToo];
    if (!strPath)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    ZeroMemory(strPath, newStringLengthToo);
    wcsncpy(strPath, szProviderAndServerOrDomainName, newStringLengthToo);
    wcsncat(strPath, GetConfigNamingContext(), newStringLengthToo - wcslen(szProviderAndServerOrDomainName));

    CComPtr<IADsPathname> spADsPath;

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&spADsPath);
    if (FAILED(hr))
    {
       break;
    }

    hr = spADsPath->Set(strPath, ADS_SETTYPE_FULL);

    delete[] strPath;
    strPath = 0;

    if (FAILED(hr))
    {
       break;
    }

    hr = spADsPath->SetDisplayType(ADS_DISPLAY_FULL);
    if (FAILED(hr))
    {
       break;
    }

    hr = spADsPath->AddLeafElement(L"CN=Partitions,");
    if (FAILED(hr))
    {
       break;
    }

    CComBSTR bstrPartitions;

    hr = spADsPath->Retrieve(ADS_FORMAT_X500, &bstrPartitions);
    if (FAILED(hr))
    {
       break;
    }

    CComPtr<IADs> spPartitions;

    hr = DSAdminOpenObject((PWSTR)(PCWSTR)bstrPartitions,
                           IID_IADs, 
                           (PVOID *)&spPartitions);
    if (FAILED(hr))
    {
       break;
    }

    VARIANT var;
    ::VariantInit(&var);

    hr = spPartitions->Get(L"msDS-Behavior-Version", &var);

    if (FAILED(hr))
    {
       // Not an error. Can happen if a Whistler server is administering a Win2k AD.
       //
       TRACE(L"!! No forest behavior version attr.\n");
       hr = S_OK;
       m_nForestBehaviorVersion = 0;
       break;
    }
    ASSERT(var.vt == VT_I4);
    m_nForestBehaviorVersion = static_cast<UINT>(var.iVal);

    ::VariantClear(&var);
  } while (FALSE);

  do
  {
    //
    // retrieve the Schema Version from the schema container
    //
    size_t newStringLengthToo = wcslen(szProviderAndServerOrDomainName) +
                                wcslen(GetSchemaNamingContext()) + 1;

    PWSTR strPath = new WCHAR[newStringLengthToo];
    if (!strPath)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    ZeroMemory(strPath, newStringLengthToo);
    wcsncpy(strPath, szProviderAndServerOrDomainName, newStringLengthToo);
    wcsncat(strPath, GetSchemaNamingContext(), newStringLengthToo - wcslen(szProviderAndServerOrDomainName));

    CComPtr<IADs> spSchema;

    hr = DSAdminOpenObject(strPath, 
                           IID_IADs, 
                           (PVOID *)&spSchema);
    if (FAILED(hr))
    {
       break;
    }

    VARIANT var;
    ::VariantInit(&var);

    hr = spSchema->Get(L"objectVersion", &var);

    if (FAILED(hr))
    {
       TRACE(L"!! No objectVersion attr.\n");
       hr = S_OK;
       m_nSchemaVersion = 0;
       break;
    }
    ASSERT(var.vt == VT_I4);
    m_nSchemaVersion = static_cast<UINT>(var.iVal);

    TRACE(L"Schema version = %d\n", m_nSchemaVersion);
    ::VariantClear(&var);
  } while (FALSE);

  {
    // retrieve the DNS DC name we are bound to
    TRACE(L"// retrieve the DNS DC name we are bound to\n");
    size_t newStringLengthToo = wcslen(szProviderAndServerOrDomainName) +
                                wcslen(GetConfigNamingContext()) + 1;

    PWSTR szConfigPath = new WCHAR[newStringLengthToo];
    if (!szConfigPath)
    {
      hr = E_OUTOFMEMORY;
      goto error;
    }

    ZeroMemory(szConfigPath, newStringLengthToo);
    wcsncpy(szConfigPath, szProviderAndServerOrDomainName, newStringLengthToo);
    wcsncat(szConfigPath, GetConfigNamingContext(), newStringLengthToo - wcslen(szProviderAndServerOrDomainName));

   
    CComPtr<IADs> spConfig;
    hr = DSAdminOpenObject(szConfigPath, 
                           IID_IADs, 
                           (void **)&spConfig);
    TRACE(L"DSAdminOpenObject(%s, ...) returned hr = 0x%x\n", (LPCWSTR)szConfigPath, hr);
    
    delete[] szConfigPath;
    szConfigPath = 0;

    if (FAILED(hr))
    {
      goto error;
    }

    PWSTR szServerName = 0;
    hr = GetADSIServerName(&szServerName, spConfig);
    TRACE(L"GetADSIServerName(%s) returned hr = 0x%x\n", szServerName, hr);

    if (FAILED(hr))
    {
      goto error;
    }

    if (!szServerName)
    {
       hr = E_OUTOFMEMORY;
       goto error;
    }

    // The member now owns the memory
    m_szServerName = szServerName;

    // retrieve the DNS domain name
    TRACE(L"// retrieve the DNS domain name\n");

    PCWSTR pszLDAP = L"LDAP://";
    size_t newLDAPStringLength = wcslen(pszLDAP) +
                                 wcslen(m_szServerName) +
                                 1;

    PWSTR sz = new WCHAR[newLDAPStringLength];
    if (sz)
    {
      ZeroMemory(sz, newLDAPStringLength);
      wcsncpy(sz, pszLDAP, newLDAPStringLength);
      wcsncat(sz, m_szServerName, wcslen(m_szServerName) + 1);

    }
    else
    {
       hr = E_OUTOFMEMORY;
       goto error;
    }

    CComPtr<IADs> spX;
    hr = DSAdminOpenObject(sz, 
                           IID_IADs, 
                           (void **)&spX,
                           TRUE);

    TRACE(L"DSAdminOpenObject(%s) DNS domain name, returned hr = 0x%x\n", (LPCWSTR)sz, hr);

    delete[] sz;
    if (FAILED(hr))
    {
      goto error;
    }

    CComBSTR sbstrCanonicalName;
    hr = GetStringAttr( spX, L"canonicalName", &sbstrCanonicalName);
    if (FAILED(hr))
    {
      TRACE(L"Failed GetStringAttr( spX, canonicalName, &sbstrCanonicalName)");
      goto error;
    }
    UINT nLen = ::SysStringLen(sbstrCanonicalName);
    ASSERT(nLen > 1);
    sbstrCanonicalName[nLen-1] = NULL; // remove the "/" at the end

    ASSERT(!m_szDomainName);
    m_szDomainName = new WCHAR[wcslen(sbstrCanonicalName) + 1];
    ASSERT(m_szDomainName);
    if (m_szDomainName)
    {
       wcsncpy(m_szDomainName, sbstrCanonicalName, wcslen(sbstrCanonicalName) + 1);
    }
    else
    {
       hr = E_OUTOFMEMORY;
       goto error;
    }
  }

  // load and set the display specifier cache
  TRACE(L"// load and set the display specifier cache\n");
  if (m_spIDsDisplaySpecifier == NULL)
  {
    hr = ::CoCreateInstance(CLSID_DsDisplaySpecifier,
                            NULL,
						                CLSCTX_INPROC_SERVER,
                            IID_IDsDisplaySpecifier,
                            (void**)&m_spIDsDisplaySpecifier);
    if (FAILED(hr))
    {
      TRACE(_T("Trying to get the display specifier cache failed: %lx.\n"), hr);
      goto error;
    }
  }

  hr = m_spIDsDisplaySpecifier->SetServer(GetServerName(), NULL, NULL, 0x0);
  if (FAILED(hr))
  {
    TRACE(_T("m_spIDsDisplaySpecifier->SetServer(%s) failed, returned hr = 0x%x\n"), GetServerName(), hr);
    goto error;
  }

  if (szProviderAndServerOrDomainName)
  {
    delete[] szProviderAndServerOrDomainName;
    szProviderAndServerOrDomainName = 0;
  }

  if (szRootDSEPath)
  {
    delete[] szRootDSEPath;
    szRootDSEPath = 0;
  }

  ::VariantClear(&Schema);
  ::VariantClear(&Config);
  ::VariantClear(&Default);
  ::VariantClear(&Root);

  TRACE(L"CDSBasePathsInfo::InitFromName() returning on success\n");
  ASSERT(SUCCEEDED(hr)); // if we got here, all is fine
  _BuildProviderAndServerName();
  m_bIsInitialized = true;

  return hr; 

error:

  if (szProviderAndServerOrDomainName)
  {
    delete[] szProviderAndServerOrDomainName;
    szProviderAndServerOrDomainName = 0;
  }

  if (szRootDSEPath)
  {
    delete[] szRootDSEPath;
    szRootDSEPath = 0;
  }

  ::VariantClear(&Schema);
  ::VariantClear(&Config);
  ::VariantClear(&Default);
  ::VariantClear(&Root);

  // failed, we need to reset the object state
  _Reset();
  TRACE(L"CDSBasePathsInfo::InitFromName returning on failure\n");
  return hr;
}

void CDSBasePathsInfo::_Reset()
{

  if (m_szServerName)
  {
    delete[] m_szServerName;
    m_szServerName = 0;
  }

  if (m_szDomainName)
  {
    delete[] m_szDomainName;
    m_szDomainName = 0;
  }

  if (m_szProviderAndServerName)
  {
    delete[] m_szProviderAndServerName;
    m_szProviderAndServerName = 0;
  }

  if (m_szSchemaNamingContext)
  {
    delete[] m_szSchemaNamingContext;
    m_szSchemaNamingContext = 0;
  }

  if (m_szConfigNamingContext)
  {
    delete[] m_szConfigNamingContext;
    m_szConfigNamingContext = 0;
  }

  if (m_szDefaultNamingContext)
  {
    delete[] m_szDefaultNamingContext;
    m_szDefaultNamingContext = 0;
  }

  if (m_szRootDomainNamingContext)
  {
    delete[] m_szRootDomainNamingContext;
    m_szRootDomainNamingContext = 0;
  }

  m_spRootDSE = NULL;
}

void CDSBasePathsInfo::_BuildProviderAndServerName()
{
  if (m_szProviderAndServerName)
  {
    delete[] m_szProviderAndServerName;
    m_szProviderAndServerName = 0;
  }

  if (m_szServerName && wcslen(m_szServerName) > 0)
  {
    size_t newStringLength = wcslen(GetProvider()) + wcslen(m_szServerName) + 2;
    m_szProviderAndServerName = new WCHAR[newStringLength];
    ASSERT(m_szProviderAndServerName);
    if (m_szProviderAndServerName)
    {
      wcsncpy(m_szProviderAndServerName, GetProvider(), newStringLength);
      wcsncat(m_szProviderAndServerName, m_szServerName, wcslen(m_szServerName) + 1);
      wcsncat(m_szProviderAndServerName, L"/", 2);
    }
  }
  else
  {
    PCWSTR pszProvider = GetProvider();
    if (pszProvider)
    {
      m_szProviderAndServerName = new WCHAR[wcslen(pszProvider) + 1];
      ASSERT(m_szProviderAndServerName);
      if (m_szProviderAndServerName)
      {
        wcsncpy(m_szProviderAndServerName, pszProvider, wcslen(pszProvider) + 1);
      }
    }
  }
}
int CDSBasePathsInfo::GetSchemaPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetSchemaNamingContext());
}

int CDSBasePathsInfo::GetConfigPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetConfigNamingContext());
}

int CDSBasePathsInfo::GetDefaultRootPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetDefaultRootNamingContext());
}

int CDSBasePathsInfo::GetRootDomainPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetRootDomainNamingContext());
}

int CDSBasePathsInfo::GetRootDSEPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, L"RootDSE");
}

int CDSBasePathsInfo::GetAbstractSchemaPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, L"Schema");
}

int CDSBasePathsInfo::GetPartitionsPath(OUT PWSTR* s)
{
  int result = 0;

  if (!s || !IsInitialized())
  {
     ASSERT(IsInitialized());
     ASSERT(s);
     return result;
  }

  *s = 0;
  if (!GetConfigNamingContext())
  {
     return result;
  }

  PCWSTR pszPartitionsBase = L"CN=Partitions,";
  size_t newStringSize = wcslen(pszPartitionsBase) + wcslen(GetConfigNamingContext()) + 1;
  PWSTR pszPartitionsPath = new WCHAR[newStringSize];
  if (pszPartitionsPath)
  {
    ZeroMemory(pszPartitionsPath, newStringSize);
    wcsncpy(pszPartitionsPath, pszPartitionsBase, newStringSize);
    wcsncat(pszPartitionsPath, GetConfigNamingContext(), wcslen(GetConfigNamingContext()) + 1);
    
    result = ComposeADsIPath(s, pszPartitionsPath);

    delete[] pszPartitionsPath;
    pszPartitionsPath = 0;
  }

  return result;
}

int CDSBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, OUT PWSTR* s)
{
  if (!s || !IsInitialized())
  {
     ASSERT(IsInitialized());
     ASSERT(s);
     return 0;
  }

  if (!GetProviderAndServerName() ||
      !GetSchemaNamingContext())
  {
     return 0;
  }

  size_t newStringLength = wcslen(GetProviderAndServerName()) +
                           wcslen(lpszObjClass) +
                           wcslen(GetSchemaNamingContext()) +
                           5; // for CN= and extra comma

  int result = 0;
  *s = new WCHAR[newStringLength];

  if (*s)
  {
    ZeroMemory(*s, newStringLength);
    wcsncpy(*s, GetProviderAndServerName(), newStringLength);
    wcsncat(*s, L"CN=", 4);
    wcsncat(*s, lpszObjClass, wcslen(lpszObjClass) + 1);
    wcsncat(*s, L",", 2);
    wcsncat(*s, GetSchemaNamingContext(), wcslen(GetSchemaNamingContext()) + 1);

    result = static_cast<int>(wcslen(*s));
  }
  return result;
}

//----------------------------------------------------
// BUGBUG BUG BUG BUGBUG BUG
// this should actually look in the domain object for
// the list of known, but rename-able objects in the domain
//---------------------------------------------------------
int CDSBasePathsInfo::GetInfrastructureObjectPath(OUT PWSTR* s)
{
  if (!s || !IsInitialized())
  {
    ASSERT(IsInitialized());
    ASSERT(s);
    return 0;
  }

  *s = 0;

  if (!GetProviderAndServerName() ||
      !GetDefaultRootNamingContext())
  {
     return 0;
  }

  PCWSTR pszInfraBase = L"CN=Infrastructure,";
  size_t newStringLength = wcslen(GetProviderAndServerName()) +
                           wcslen(GetDefaultRootNamingContext()) +
                           wcslen(pszInfraBase) +
                           1; // for \0

  int result = 0;
  *s = new WCHAR[newStringLength];

  if (*s)
  {
    ZeroMemory(*s, newStringLength);

    wcsncpy(*s, GetProviderAndServerName(), newStringLength);
    wcsncat(*s, pszInfraBase, wcslen(pszInfraBase));
    wcsncat(*s, GetDefaultRootNamingContext(), wcslen(GetDefaultRootNamingContext()));
    
    result = static_cast<int>(wcslen(*s));
  }

  return result;
}

// display specifiers cache API's
HRESULT CDSBasePathsInfo::GetDisplaySpecifier(LPCWSTR lpszObjectClass, REFIID riid, void** ppv)
{
  if (!m_spIDsDisplaySpecifier)
  {
     // NTRAID#NTBUG9-547241-2002/03/29-JeffJon-Do not assert this
     // because in the case where we are joined to a workgroup this
     // function will be called when m_spIDsDisplaySpecifier has not
     // been initialized.  The caller handles the failure correctly.
    //ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_FAIL;
  }
  return m_spIDsDisplaySpecifier->GetDisplaySpecifier(lpszObjectClass, riid, ppv);
}

HICON CDSBasePathsInfo::GetIcon(LPCWSTR lpszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon)
{
 if (!m_spIDsDisplaySpecifier)
 {
   ASSERT(m_spIDsDisplaySpecifier != NULL);
   return NULL;
 }
 return m_spIDsDisplaySpecifier->GetIcon(lpszObjectClass, dwFlags, cxIcon, cyIcon);
}

HRESULT CDSBasePathsInfo::GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                                               LPWSTR lpszBuffer, int cchBuffer)
{
 if (!m_spIDsDisplaySpecifier)
 {
   ASSERT(m_spIDsDisplaySpecifier != NULL);
   return E_FAIL;
 }
 return m_spIDsDisplaySpecifier->GetFriendlyClassName(lpszObjectClass, 
                            lpszBuffer, cchBuffer);
}

HRESULT CDSBasePathsInfo::GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                                   LPCWSTR lpszAttributeName,
                                                   LPWSTR lpszBuffer, int cchBuffer)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_FAIL;
  }
  return m_spIDsDisplaySpecifier->GetFriendlyAttributeName(lpszObjectClass, 
                                                           lpszAttributeName,
                                                           lpszBuffer, cchBuffer);
}

BOOL CDSBasePathsInfo::IsClassContainer(LPCWSTR lpszObjectClass, LPCWSTR lpszADsPath, DWORD dwFlags)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return FALSE;
  }
  return m_spIDsDisplaySpecifier->IsClassContainer(lpszObjectClass, lpszADsPath, dwFlags);
}

HRESULT CDSBasePathsInfo::GetClassCreationInfo(LPCWSTR lpszObjectClass, LPDSCLASSCREATIONINFO* ppdscci)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_FAIL;
  }
  return m_spIDsDisplaySpecifier->GetClassCreationInfo(lpszObjectClass, ppdscci);
}

// Added 2002/09/11 by ArtM to expose missing functionality.
HRESULT CDSBasePathsInfo::GetAttributeADsType(LPCWSTR lpszAttributeName, ADSTYPE& attrType)
{
  if (!lpszAttributeName)
  {
    ASSERT(NULL != lpszAttributeName);
    return E_INVALIDARG;
  }

  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_UNEXPECTED;
  }

  attrType = m_spIDsDisplaySpecifier->GetAttributeADsType(lpszAttributeName);
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\shluuid.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propuuid.h
//
//  Contents:   guid definitions.
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

DEFINE_GUID(CLSID_SpecialUserInfo,0x717ef4fe,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
//DEFINE_GUID(CLSID_Unused,0x717ef4ff,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsShellUserPropPages,0xf5d121ed,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellContactPropPages,0xf5d121f0,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellGroupPropPages,0xf5d121ee,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellDomainPropPages,0xf5d121ef,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellOUPropPages,0xf2c3faae,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellVolumePropPages,0xf5d121f3,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellComputerPropPages,0xf5d121f4,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\inc\propuuid.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propuuid.h
//
//  Contents:   guid definitions.
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

DEFINE_GUID(CLSID_DsUserPropPages,0x6dfe6485,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsFSPOPropPages,0x6dfe6486,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
//DEFINE_GUID(CLSID_DsMailPropPages,0x6dfe6487,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsTopPropPages,0x6dfe6488,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsGroupPropPages,0x6dfe6489,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsMemberOfPropPages,0x6dfe648a,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsManageableObjPropPages,0x6dfe648b,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsDomainPropPages,0x6dfe648c,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsOuGenPropPage,0x9da6fd63,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsDomainPolicyPropPages,0x6dfe648e,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsLocalPolicyPropPages,0x6dfe648f,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsVolumePropPages,0x6dfe6490,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsIntersitePropPages,0x6dfe6491,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsComputerPropPages,0x6dfe6492,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsPrinterPropPages,0x6dfe6493,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsReplServerPropPages,0x6dfe6494,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsReplSitePropPages,0x717ef4fa,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSettingsPropPages,0x717ef4fb,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplDSAPropPages,0x717ef4fc,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplConnectionPropPages,0x717ef4fd,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteLicenseSettingsPropPages,0x717ef500,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteSettingsPropPages,0x2f280288,0xbb6d,0x11d0,0xb9,0x48,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSubnetPropPages,0x9da6fd62,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);

DEFINE_GUID(CLSID_DsServiceAdminPage,0xc5f1645d,0xc8c9,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsContactPropPages,0xc5f1645c,0xc8c9,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsDomainOuPropPages,0x6dfe648d,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsKeywordsPropPage,0x9da6fd64,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsPhonePropPage,0x9da6fd65,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsAddressPhoneNotesPropPages,0x9da6fd66,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsTrustedDomainPropPages,0x9da6fd67,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);

DEFINE_GUID(CLSID_DsFrsSettings,0x9da6fd68,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsFrsReplicaSet,0x9da6fd69,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsFrsMember,0x9da6fd6a,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);

DEFINE_GUID(CLSID_DsContainerGeneralPage,0x5a96f2d8,0x736e,0x11d1,0xbd,0x0d,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);

DEFINE_GUID(CLSID_DsDefaultGeneralPage,0x6384e23e,0x736d,0x11d1,0xbd,0x0d,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);

DEFINE_GUID(CLSID_DsFrsSubscriber,0x50d3055f,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsFrsSubscriptions,0x50d30560,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteLink,0x50d30561,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteLinkBridge,0x50d30562,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsRpcContainer,0x50d30572,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsDefaultMultiGeneralPage,0x50d30563,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsUserMultiPropPages,0x50d30564,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30565,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30566,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30567,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30568,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30569,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056a,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056b,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056c,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056d,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056e,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056f,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30570,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30571,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\src\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "dbg.h"

#if defined (DBG)

void __cdecl DSATrace(LPCTSTR lpszFormat, ...)
{
   va_list args;
   va_start(args, lpszFormat);

   int nBuf;

   //
   // Might need to deal with some long path names when the OU structure gets really deep.
   // bug #30432
   //
   WCHAR szBuffer[2048];

   nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

   // was there an error? was the expanded string too long?
   ASSERT(nBuf >= 0);
   ::OutputDebugString(szBuffer);

   va_end(args);
}

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
   WCHAR szMessage[_MAX_PATH*2];

   // assume the debugger or auxiliary port
   wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
   lpszFileName, nLine);
   OutputDebugString(szMessage);

   // display the assert
   int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
   MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

   OutputDebugString(L"after message box\n");
   if (nCode == IDIGNORE)
   {
      return FALSE;   // ignore
   }

   if (nCode == IDRETRY)
   {
      return TRUE;    // will cause DebugBreak
   }

   abort();     // should not return 
   return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\src\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef  __PCH_H
#define  __PCH_H

// RTL
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

// ATL
#include <atlbase.h>

#include <shlobj.h>

// ADSI
#include <activeds.h>
#include <iadsp.h>

// Display Specifier stuff
#include <dsclient.h>

// MMC
#include <mmc.h>

#include "dbg.h"
#include "dsadminp.h"
#include "dscmn.h"

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\src\_dsadmin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       _dsadmin.cpp
//
//--------------------------------------------------------------------------


// FILE: _dsadmin.cpp

#include "pch.h"

//
// Common code for reading attributes using IDirectoryObject
// JonN 4/7/98
//

#define BREAK_ON_FAIL if (FAILED(hr)) { break; }
#define BREAK_AND_ASSERT_ON_FAIL if (FAILED(hr)) { ASSERT(FALSE); break; }
#define RETURN_ON_FAIL if (FAILED(hr)) { return hr; }
#define RETURN_AND_ASSERT_ON_FAIL if (FAILED(hr)) { ASSERT(FALSE); return hr; }

// returns E_FAIL if the attribute is not set
HRESULT GetAttr( IN IADs* pIADs, IN WCHAR* wzAttr, OUT PADS_ATTR_INFO* ppAttrs )
{
  ASSERT( NULL != pIADs && NULL != wzAttr && NULL != ppAttrs && NULL == *ppAttrs );

  CComQIPtr<IDirectoryObject,&IID_IDirectoryObject> spIDirectoryObject( pIADs );
  if (!spIDirectoryObject)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  DWORD cAttrs = 0;
  HRESULT hr = spIDirectoryObject->GetObjectAttributes(&wzAttr, 1, ppAttrs, &cAttrs);
  RETURN_ON_FAIL;
  if (   1 != cAttrs
      || NULL == *ppAttrs
      )
  {
    // the attribute is not set
    ASSERT( NULL == *ppAttrs );
    *ppAttrs = NULL; // might leak, but this shouldn't happen
    return E_FAIL;
  }

  return hr;
}

// returns E_FAIL if the attribute is not set
HRESULT GetStringAttr( IN IADs* pIADs, IN WCHAR* wzAttr, OUT BSTR* pbstr )
{
  ASSERT( NULL != pbstr && NULL == *pbstr );

  Smart_PADS_ATTR_INFO spAttrs;
  HRESULT hr = GetAttr( pIADs, wzAttr, &spAttrs );
  RETURN_ON_FAIL; // the attribute might just not exist

  LPWSTR pwz = NULL;
  switch (spAttrs[0].pADsValues[0].dwType)
  {
  case ADSTYPE_DN_STRING:
    pwz = spAttrs[0].pADsValues[0].DNString;
    break;
  case ADSTYPE_CASE_EXACT_STRING:
    pwz = spAttrs[0].pADsValues[0].CaseExactString;
    break;
  case ADSTYPE_CASE_IGNORE_STRING:
    pwz = spAttrs[0].pADsValues[0].CaseIgnoreString;
    break;
  default:
    ASSERT(FALSE);
    return E_FAIL;
  }
  ASSERT( NULL != pwz );

  *pbstr = ::SysAllocString( pwz );
  if (NULL == *pbstr)
  {
    ASSERT(FALSE);
    return E_OUTOFMEMORY;
  }

  return hr;
}

// returns E_FAIL if the attribute is not set
HRESULT GetObjectGUID( IN IADs* pIADs, OUT UUID* pUUID )
{
  ASSERT( NULL != pUUID );

  Smart_PADS_ATTR_INFO spAttrs;
  HRESULT hr = GetAttr( pIADs, L"objectGUID", &spAttrs );
  RETURN_ON_FAIL; // This is an optional parameter according to the schema
  if (   NULL == (PADS_ATTR_INFO)spAttrs
      || NULL == spAttrs[0].pADsValues
      || ADSTYPE_OCTET_STRING != spAttrs[0].pADsValues[0].dwType
      || sizeof(UUID) != spAttrs[0].pADsValues[0].OctetString.dwLength
      || NULL == spAttrs[0].pADsValues[0].OctetString.lpValue
      )
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CopyMemory( pUUID, spAttrs[0].pADsValues[0].OctetString.lpValue, sizeof(UUID) );

  return hr;
}

// returns E_FAIL if the attribute is not set
HRESULT GetObjectGUID( IN IADs* pIADs, OUT BSTR* pbstrObjectGUID )
{
  ASSERT( NULL != pbstrObjectGUID && NULL == *pbstrObjectGUID );

  UUID uuid;
  ::ZeroMemory( &uuid, sizeof(uuid) );
  HRESULT hr = GetObjectGUID( pIADs, &uuid );
  RETURN_ON_FAIL; // This is an optional parameter according to the schema

  WCHAR awch[MAX_PATH];
  ::ZeroMemory( awch, sizeof(awch) );
  hr = ::StringFromGUID2(uuid, awch, MAX_PATH);
  RETURN_AND_ASSERT_ON_FAIL;

  *pbstrObjectGUID = ::SysAllocString( awch );
  if (NULL == *pbstrObjectGUID)
  {
    ASSERT(FALSE);
    return E_OUTOFMEMORY;
  }

  return hr;
}





///////////////////////////////////////////////////////////////////
// Function: GetADSIServerName
//
// Given an Unknown* that supports IADsObjectOptions, it
// returns the server name ADSI is bound to. 

HRESULT GetADSIServerName(OUT PWSTR* szServer, IN IUnknown* pUnk)
{
  CComPtr<IADsObjectOptions> spIADsObjectOptions;
  HRESULT hr = pUnk->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);
  if (FAILED(hr))
    return hr;

  VARIANT var;
  ::VariantInit(&var);

  hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
  if (FAILED(hr))
    return hr;

  ASSERT(var.vt == VT_BSTR);
  BSTR value = V_BSTR(&var);

  if (value)
  {
     *szServer = new WCHAR[wcslen(value) + 1];
     ASSERT(*szServer);
     if (*szServer)
     {
        wcsncpy(*szServer, value, wcslen(value) + 1);
     }
     else
     {
        hr = E_OUTOFMEMORY;
     }
  }

  ::VariantClear(&var);
  return hr;

}



void StringErrorFromHr(HRESULT hr, PWSTR* szError, BOOL bTryADsIErrors)
{
  PWSTR lpsz = NULL;
  int cch = cchLoadHrMsg(hr, &lpsz, bTryADsIErrors);
  if (cch)
  {
    *szError = new WCHAR[wcslen(lpsz) + 1];
    if (*szError)
    {
      wcsncpy(*szError, lpsz, wcslen(lpsz) + 1);
    }
  }
  else
  {
    UINT maxError = 40;
    *szError = new WCHAR[maxError];
    if (*szError)
    {
      ZeroMemory(*szError, sizeof(WCHAR) * maxError);
      wsprintf(*szError, L"Error 0x%x", hr);
    }
  }
  if (lpsz != NULL)
    ::LocalFree(lpsz);
}


///////////////////////////////////////////////////////////////////
// Function: cchLoadHrMsg
//
// Given an HRESULT error code and a flag TryADsIErrors,
// it loads the string for the error. It returns the # of characters returned
// NOTICE: free the returned string using LocalFree.
// 629598-2002/05/28-JonN fixed NTSTATUS handling
int cchLoadHrMsg( IN HRESULT hr, OUT PTSTR* pptzSysMsg, IN BOOL TryADsIErrors )
{
  DWORD dwErrorCode = hr;

  // first check if we have extended ADs errors
  // we need to do this before any API calls overwrite GetLastError
  if ((hr != S_OK) && TryADsIErrors) {
    WCHAR Buf1[256], Buf2[256];
    DWORD status = NO_ERROR;
    HRESULT Localhr = ADsGetLastError (&status,
                                       Buf1, 256, Buf2, 256);
    TRACE(_T("ADsGetLastError returned: %lx, status of %lx, error: %s, name %s\n"),
          Localhr, status, Buf1, Buf2);

    if ((status != ERROR_INVALID_DATA) &&
        (status != 0)) {
      dwErrorCode = status;
    }
  }

  int cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                          NULL, 
                          dwErrorCode,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (PTSTR)pptzSysMsg, 
                          0, 
                          NULL);
  if (cch)
    return cch;

  // try ads errors in activeds.dll
  static HMODULE g_adsMod = 0;
  if (0 == g_adsMod)
  {
    g_adsMod = GetModuleHandle (L"activeds.dll");
  }
  cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
                      g_adsMod, 
                      dwErrorCode,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)pptzSysMsg, 
                      0, 
                      NULL);
  if (cch)
    return cch;

  // Try DOS error codes
  //
  // Since this library is linked by the Win9X version of DSPROP.DLL,
  // we need to jump some hoops to make sure that this function is present.
  typedef ULONG (NTAPI *PFN_RtlNtStatusToDosError)( NTSTATUS );
  HINSTANCE hNtDll = LoadLibraryA("ntdll.dll");
  PFN_RtlNtStatusToDosError pfn = (NULL == hNtDll) ? NULL :
      (PFN_RtlNtStatusToDosError)GetProcAddress(
            hNtDll, "RtlNtStatusToDosError" );
  ULONG ulDosError1 = (NULL == pfn) ? dwErrorCode : (*pfn)(dwErrorCode);
  ULONG ulDosError2 = (NULL == pfn) ? hr : (*pfn)(hr);
  if (NULL != hNtDll)
    FreeLibrary(hNtDll);

  if (ulDosError1 != dwErrorCode)
  {
    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                        NULL,
                        ulDosError1,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)pptzSysMsg, 
                        0, 
                        NULL);
    if (cch)
      return cch;
  }

  if ((DWORD)hr == dwErrorCode)
    return 0;

  cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                      NULL, 
                      hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)pptzSysMsg, 
                      0, 
                      NULL);
  if (cch)
    return cch;

  //try ads errors
  cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
                      g_adsMod, 
                      hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)pptzSysMsg, 
                      0, 
                      NULL);
  if (cch)
    return cch;

  // Try DOS error codes
  if (ulDosError2 != (ULONG)hr)
  {
    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                        NULL, 
                        ulDosError2,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)pptzSysMsg, 
                        0, 
                        NULL);
  }

  return cch;
}


/////////////////////////////////////////////////////////////////////
// FSMO Mainipulation API's



HRESULT _BindToFsmoHolder(IN CDSBasePathsInfo* pPathInfo,
                          IN FSMO_TYPE fsmoType,
                             OUT IADs** ppIADs)
{
  // determine the LDAP path of the object
  PWSTR szPath = 0;
  switch (fsmoType)
  {
  case SCHEMA_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = SCHEMA_FSMO\n");
    pPathInfo->GetSchemaPath(&szPath);
    break;
  case RID_POOL_FSMO:
    {
      TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = RID_POOL_FSMO\n");
      pPathInfo->GetDefaultRootPath(&szPath);
      CComPtr<IADs> spDefaultContainer;
      HRESULT hr = DSAdminOpenObject(szPath,
                                     IID_IADs,
                                     (void **)&spDefaultContainer);

      TRACE(L"_BindToFsmoHolder(): DSAdminOpenObject(%s) returned hr = 0x0%x\n", 
            szPath, hr);

      if (FAILED(hr))
      {
        if (szPath)
        {
          delete[] szPath;
          szPath = 0;
        }
        return hr;
      }

      VARIANT ridManagerRefVariant;
      ::VariantInit(&ridManagerRefVariant);

      hr = spDefaultContainer->Get(L"rIDManagerReference", &ridManagerRefVariant);
      
      TRACE(L"_BindToFsmoHolder(): spDefaultContainer->Get(rIDManagerReference,...) returned hr = 0x0%x\n", 
                 hr);
      
      if (FAILED(hr))
      {
        if (szPath)
        {
          delete[] szPath;
          szPath = 0;
        }
        return hr;
      }

      TRACE(L"ridManagerRefVariant.bstrVal = <%s>\n", ridManagerRefVariant.bstrVal);

      if (szPath)
      {
        delete[] szPath;
        szPath = 0;
      }
      pPathInfo->ComposeADsIPath(&szPath, ridManagerRefVariant.bstrVal);
      ::VariantClear(&ridManagerRefVariant);
    }
    break;
  case PDC_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = PDC_FSMO\n");
    pPathInfo->GetDefaultRootPath(&szPath);
    break;
  case INFRASTUCTURE_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = INFRASTUCTURE_FSMO\n");
    pPathInfo->GetInfrastructureObjectPath(&szPath);
    break;
  case DOMAIN_NAMING_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = DOMAIN_NAMING_FSMO\n");
    pPathInfo->GetPartitionsPath(&szPath);
    break;
  default:
      ASSERT(FALSE);
      return E_INVALIDARG;
  };

  // bind to it
  TRACE(L"_BindToFsmoHolder(): final bind szPath is = <%s>\n", (LPCWSTR)szPath);

  HRESULT hr = E_OUTOFMEMORY;
  if (szPath)
  {
    hr = DSAdminOpenObject(szPath,
                           IID_IADs,
                           (void **)ppIADs);
    TRACE(L"_BindToFsmoHolder(): final DSAdminOpenObject(%s) returned hr = 0x0%x\n", 
          szPath, hr);
  }

  if (szPath)
  {
    delete[] szPath;
    szPath = 0;
  }


  return hr;
}

LPCWSTR _GetDummyProperty(IN FSMO_TYPE fsmoType)
{
  switch (fsmoType)
  {
  case SCHEMA_FSMO:
    return L"becomeSchemaMaster";
    break;
  case RID_POOL_FSMO:
    return L"becomeRIDMaster";
  case PDC_FSMO:
    return L"becomePDC";
    break;
  case INFRASTUCTURE_FSMO:
    return L"becomeInfrastructureMaster";
  case DOMAIN_NAMING_FSMO:
    return L"becomeDomainMaster";
    break;
  };
  return NULL;
}



class CX500LeafElementRemover
{
public:

  HRESULT Bind()
  {
    HRESULT hr = S_OK;
    if (m_spIADsPathname == NULL)
    {
      hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IADsPathname, (PVOID *)&(m_spIADsPathname));
      ASSERT((S_OK == hr) && (m_spIADsPathname != NULL));
    }
    return hr;
  }

  HRESULT RemoveLeafElement(IN LPCWSTR lpszX500DN, OUT CComBSTR& bsX500DN)
  {
    TRACE(L"RemoveLeafElement(%s)\n", lpszX500DN);
    bsX500DN.Empty();
    if (m_spIADsPathname == NULL)
      return E_FAIL;

    HRESULT hr = m_spIADsPathname->Set((LPWSTR)lpszX500DN, ADS_SETTYPE_DN);
    if (FAILED(hr))
    {
      return hr;
    }
    hr = m_spIADsPathname->RemoveLeafElement();
    if (FAILED(hr))
    {
      return hr;
    }
    hr = m_spIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bsX500DN);

    TRACE(L"m_spIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bsX500DN) returned hr = 0x%x, bsX500DN = <%s>\n",
                    hr, bsX500DN);
    return hr;
  }

private:
  CComPtr<IADsPathname> m_spIADsPathname;
};






HRESULT FindFsmoOwner(IN CDSBasePathsInfo* pCurrentPath,
                      IN FSMO_TYPE fsmoType,
                      OUT CDSBasePathsInfo* pFsmoOwnerPath,
                      OUT PWSTR* szFsmoOwnerServerName)
{
  TRACE(L"FindFsmoOwner()\n");

  if (!szFsmoOwnerServerName)
  {
    ASSERT(szFsmoOwnerServerName);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;
  // start with the current path
  pFsmoOwnerPath->InitFromInfo(pCurrentPath);
  
  static const int nMaxReferrals = 10;
  int nIteration = 0;


  // create an instance of the path cracker to remove leaf elements
  CX500LeafElementRemover leafRemover;
  hr = leafRemover.Bind();
  if (FAILED(hr)) 
  {
    return hr;
  }


  // loop searching for referrals
  TRACE(L"loop searching for referrals\n");
  do
  {
    TRACE(L"BEGIN LOOP\n");

    // bind to the object holding the FSMO attribute
    CComPtr<IADs> spIADsFsmo;
    hr = _BindToFsmoHolder(pFsmoOwnerPath, fsmoType, &spIADsFsmo);
    if (FAILED(hr))
      return hr;

    // get the FSMO Role Owner property
    VARIANT fsmoRoleOwnerProperty;
    ::VariantInit(&fsmoRoleOwnerProperty);

    hr = spIADsFsmo->Get(L"fSMORoleOwner", &fsmoRoleOwnerProperty);
    
    TRACE(L"spIADsFsmo->Get(fSMORoleOwner) returned hr = 0x%x\n", hr);
    
    if (FAILED(hr))
      return hr;

    // The result here is in the form, "CN=NTDS Settings,CN=Machine,CN=..."
    // we need to just have "CN=Machine,CN=..."

    CComBSTR bsTemp;
    hr = leafRemover.RemoveLeafElement(IN fsmoRoleOwnerProperty.bstrVal, OUT bsTemp);
    
    TRACE(L"leafRemover.RemoveLeafElement(%s) returned hr = 0x%x\n",  fsmoRoleOwnerProperty.bstrVal, hr);

    ::VariantClear(&fsmoRoleOwnerProperty);

    if (FAILED(hr))
    {
      return hr;
    }

    // bind to the path
    PWSTR szfsmoRoleOwnerPath;
    pFsmoOwnerPath->ComposeADsIPath(&szfsmoRoleOwnerPath, bsTemp);
    CComPtr<IADs> spFsmoRoleOwner;
    hr = DSAdminOpenObject(szfsmoRoleOwnerPath,
                           IID_IADs,
                           (void **)&spFsmoRoleOwner);

    TRACE(L"DSAdminOpenObject(%s) on szfsmoRoleOwnerPath returned hr = 0x%x \n", szfsmoRoleOwnerPath, hr);
    
    if (szfsmoRoleOwnerPath)
    {
       delete[] szfsmoRoleOwnerPath;
       szfsmoRoleOwnerPath = 0;
    }

    if (FAILED(hr))
      return hr;

    // get the DNS host name of the FSMO owner
    VARIANT dNSHostNameProperty;
    ::VariantInit(&dNSHostNameProperty);

    hr = spFsmoRoleOwner->Get(L"dNSHostName", &dNSHostNameProperty);
    TRACE(L"spFsmoRoleOwner->Get(dNSHostName, ...) returned hr = 0x%x\n",  hr);

    if (FAILED(hr))
      return hr;

    if (dNSHostNameProperty.bstrVal)
    {
       *szFsmoOwnerServerName = new WCHAR[wcslen(dNSHostNameProperty.bstrVal) + 1];
       if (!(*szFsmoOwnerServerName))
       {
         ASSERT(*szFsmoOwnerServerName);
         ::VariantClear(&dNSHostNameProperty);
         return E_OUTOFMEMORY;
       }

       wcsncpy(*szFsmoOwnerServerName, dNSHostNameProperty.bstrVal, 
               wcslen(dNSHostNameProperty.bstrVal) + 1);
    }

    // compare with the current server
    TRACE(L"compare szFsmoOwnerServerName = <%s> with pFsmoOwnerPath->GetServerName() = <%s>\n",
                           *szFsmoOwnerServerName, pFsmoOwnerPath->GetServerName());

    if (_wcsicmp(dNSHostNameProperty.bstrVal, pFsmoOwnerPath->GetServerName()) == 0)
    {
      // we are done, found the owner
      TRACE(L"we are done, found the owner\n");

      ::VariantClear(&dNSHostNameProperty);
      break;
    }

    // too many iterations, we have to break out
    if (nIteration >= nMaxReferrals)
    {
      TRACE(L"too many iterations, we have to break out\n");
      hr = E_FAIL;
      ::VariantClear(&dNSHostNameProperty);
      break;
    }

    // we got a referral, try another round
    // by binding to that server to chase the referral
    TRACE(L" we got a referral, try another round\n");
    hr = pFsmoOwnerPath->InitFromName(dNSHostNameProperty.bstrVal);

    ::VariantClear(&dNSHostNameProperty);
    if (FAILED(hr))
      return hr;

    nIteration++;
    TRACE(L"END LOOP\n");
  }
  while (TRUE);

  return hr;
}

HRESULT CheckpointFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo)
{
  // assume we are already bound to the RootDSE
  IADs* pIADsRoot = pPathInfo->GetRootDSE();
  ASSERT(pIADsRoot != NULL);
  if (pIADsRoot == NULL)
    return E_INVALIDARG;

  // try to write the dummy property to cause the transfer

  VARIANT argVar;
  ::VariantInit(&argVar);
  
// need to get the domain SID to pass as an argument
  PWSTR szDomainPath = 0;
  pPathInfo->GetDefaultRootPath(&szDomainPath);
  
  CComPtr<IADs> spDomainObject;
  HRESULT hr = DSAdminOpenObject(szDomainPath,
                                 IID_IADs,
                                 (void **)&spDomainObject);

  if (szDomainPath)
  {
     delete[] szDomainPath;
     szDomainPath = 0;
  }

  if (FAILED(hr))
    return hr;
  
  hr = spDomainObject->Get(L"objectSid", &argVar);
  if (FAILED(hr))
    return hr;
  
  pIADsRoot->GetInfo();
  hr = pIADsRoot->Put(L"becomePdcWithCheckPoint", argVar);

  ::VariantClear(&argVar);
  if (FAILED(hr))
      return hr;
  return pIADsRoot->SetInfo();
}


// tell the target server to assume the FSMO
HRESULT GracefulFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo, IN FSMO_TYPE fsmoType)
{
  // assume we are already bound to the RootDSE
  IADs* pIADsRoot = pPathInfo->GetRootDSE();
  ASSERT(pIADsRoot != NULL);
  if (pIADsRoot == NULL)
    return E_INVALIDARG;

  // try to write the dummy property to cause the transfer

  VARIANT argVar;
  ::VariantInit(&argVar);

  if (fsmoType == PDC_FSMO) 
  {
    // need to get the domain SID to pass as an argument
    PWSTR szDomainPath = 0;
    pPathInfo->GetDefaultRootPath(&szDomainPath);

    CComPtr<IADs> spDomainObject;
    HRESULT hr = DSAdminOpenObject(szDomainPath,
                                   IID_IADs,
                                   (void **)&spDomainObject);

    if (szDomainPath)
    {
       delete[] szDomainPath;
       szDomainPath = 0;
    }

    if (FAILED(hr))
      return hr;

    hr = spDomainObject->Get(L"objectSid", &argVar);
    if (FAILED(hr))
      return hr;
  }
  else
  {
    // dummy value, anything would do
    argVar.vt = VT_I4;
    argVar.lVal = (long)1;
  }
  pIADsRoot->GetInfo();
  HRESULT hr = pIADsRoot->Put((LPWSTR)_GetDummyProperty(fsmoType), argVar);

  ::VariantClear(&argVar);

  if (FAILED(hr))
      return hr;
  return pIADsRoot->SetInfo();
}

HRESULT ForcedFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo,
                                IN FSMO_TYPE fsmoType)
{
  // assume we are already bound to the RootDSE
  IADs* pIADsRoot = pPathInfo->GetRootDSE();
  ASSERT(pIADsRoot != NULL);
  if (pIADsRoot == NULL)
    return E_INVALIDARG;

  VARIANT serverName;
  ::VariantInit(&serverName);

  // this attribute is in the form "CN=Machine,CN=..."
  HRESULT hr = pIADsRoot->Get(L"serverName", &serverName);
  if (FAILED(hr))
    return hr;

  // bind to the object holding the FSMO attribute
  CComPtr<IADs> spIADsFsmo;
  hr = _BindToFsmoHolder(pPathInfo, fsmoType, &spIADsFsmo);
  if (FAILED(hr))
  {
    ::VariantClear(&serverName);
    return hr;
  }

  // rebuild the attribute
  PCWSTR pszBaseSettings = L"CN=NTDS Settings,";
  size_t newStringLength = wcslen(serverName.bstrVal) + wcslen(pszBaseSettings) + 1;
  PWSTR szNewAttr = new WCHAR[newStringLength];
  if (!szNewAttr)
  {
    ::VariantClear(&serverName);
    return E_OUTOFMEMORY;
  }

  ZeroMemory(szNewAttr, wcslen(serverName.bstrVal) + wcslen(pszBaseSettings) + 1);
  wcsncpy(szNewAttr, pszBaseSettings, newStringLength);
  wcsncat(szNewAttr, serverName.bstrVal, wcslen(serverName.bstrVal));

  ::VariantClear(&serverName);

  // set the FSMO Role Owner property
  // this completes the transfer
  VARIANT fsmoRoleOwnerProperty;
  ::VariantInit(&fsmoRoleOwnerProperty);
  fsmoRoleOwnerProperty.bstrVal = szNewAttr;
  fsmoRoleOwnerProperty.vt = VT_BSTR;

  hr = spIADsFsmo->Put(L"fSMORoleOwner", fsmoRoleOwnerProperty);
  if (FAILED(hr))
      return hr;
  return spIADsFsmo->SetInfo();
}









///////////////////////////////////////////////////////////////////////////////
// CDsDisplaySpecOptionsCFHolder

HRESULT CDsDisplaySpecOptionsCFHolder::Init(CDSBasePathsInfo* pBasePathInfo)
{
  ASSERT(pBasePathInfo != NULL);
  // get full path in the form "LDAP://<server>/<config>" 
  PWSTR szConfigPath = 0;
  pBasePathInfo->GetConfigPath(&szConfigPath);
  if (!szConfigPath)
  {
     return E_OUTOFMEMORY;
  }

  DWORD nConfigPathLen = static_cast<DWORD>(wcslen(szConfigPath));

  // get the offset of the config path
  UINT nServerNameLen = static_cast<UINT>(wcslen(pBasePathInfo->GetServerName()));
  UINT nAttribPrefixLen = static_cast<UINT>(wcslen(DS_PROP_ADMIN_PREFIX));

  // allocate memory
  UINT cbStruct = sizeof (DSDISPLAYSPECOPTIONS);
  DWORD dwSize = cbStruct + 
    ((nAttribPrefixLen+1) + (nServerNameLen+1) + (nConfigPathLen+1))*sizeof(WCHAR);
  PDSDISPLAYSPECOPTIONS pNewDsDisplaySpecOptions = (PDSDISPLAYSPECOPTIONS)
                  GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwSize);

  if (pNewDsDisplaySpecOptions == NULL) 
  {
    delete[] szConfigPath;
    szConfigPath = 0;

    return E_OUTOFMEMORY;
  }

  // set data
  pNewDsDisplaySpecOptions->dwSize = sizeof (DSDISPLAYSPECOPTIONS);
  pNewDsDisplaySpecOptions->dwFlags = DSDSOF_HASUSERANDSERVERINFO | DSDSOF_DSAVAILABLE;
//  pNewDsDisplaySpecOptions->dwFlags = DSDSOF_HASUSERANDSERVERINFO;

  // set offsets and copy strings
  pNewDsDisplaySpecOptions->offsetUserName = 0; // not passed
  pNewDsDisplaySpecOptions->offsetPassword = 0; // not passed

  pNewDsDisplaySpecOptions->offsetAttribPrefix = cbStruct;
  wcscpy ((LPWSTR)((BYTE *)pNewDsDisplaySpecOptions + pNewDsDisplaySpecOptions->offsetAttribPrefix), 
                        (LPCWSTR)DS_PROP_ADMIN_PREFIX);

  pNewDsDisplaySpecOptions->offsetServer = 
      pNewDsDisplaySpecOptions->offsetAttribPrefix + (nAttribPrefixLen+1)*sizeof(WCHAR);
  wcscpy ((LPWSTR)((BYTE *)pNewDsDisplaySpecOptions + pNewDsDisplaySpecOptions->offsetServer), 
                        pBasePathInfo->GetServerName());
  

  pNewDsDisplaySpecOptions->offsetServerConfigPath = 
     pNewDsDisplaySpecOptions->offsetServer + (nServerNameLen+1)*sizeof(WCHAR);
  wcscpy ((LPWSTR)((BYTE *)pNewDsDisplaySpecOptions + pNewDsDisplaySpecOptions->offsetServerConfigPath),
          szConfigPath);

  if (szConfigPath)
  {
     delete[] szConfigPath;
     szConfigPath = 0;
  }

  if (m_pDsDisplaySpecOptions != NULL) 
  {
    GlobalFree(m_pDsDisplaySpecOptions);
  }
  m_pDsDisplaySpecOptions = pNewDsDisplaySpecOptions;
  return S_OK;
}

PDSDISPLAYSPECOPTIONS CDsDisplaySpecOptionsCFHolder::Get()
{
  ASSERT(m_pDsDisplaySpecOptions != NULL);
  if (m_pDsDisplaySpecOptions == NULL)
    return NULL;

  PDSDISPLAYSPECOPTIONS pDsDisplaySpecOptions;
  pDsDisplaySpecOptions = (PDSDISPLAYSPECOPTIONS)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                     GlobalSize(m_pDsDisplaySpecOptions));
  if (pDsDisplaySpecOptions == NULL)
  {
    return NULL;
  }
  memcpy(pDsDisplaySpecOptions, m_pDsDisplaySpecOptions, (size_t)GlobalSize(m_pDsDisplaySpecOptions));
  return pDsDisplaySpecOptions;
}

//////////////////////////////////////////////////////////////////////////
// CToggleTextControlHelper


CToggleTextControlHelper::CToggleTextControlHelper()
{
	m_hWnd = 0;
  m_pTxt1 = m_pTxt2 = NULL;
}

CToggleTextControlHelper::~CToggleTextControlHelper()
{
	if (m_pTxt1 != NULL)
		free(m_pTxt1);
}


BOOL CToggleTextControlHelper::Init(HWND hWnd)
{
	ASSERT(m_hWnd == NULL);
	ASSERT(::IsWindow(hWnd));
	m_hWnd = hWnd;

	// get the text out of the window
	int nLen = ::GetWindowTextLength(m_hWnd);
	ASSERT(m_pTxt1 == NULL);
	m_pTxt1 = (WCHAR*)malloc(sizeof(WCHAR)*(nLen+1));
  if (m_pTxt1 == NULL)
    return FALSE;

  ::GetWindowText(m_hWnd, m_pTxt1, nLen+1);
	ASSERT(m_pTxt1 != NULL);

	// look for '\n', change it into '\0'and get a pointer to it
	m_pTxt2 = m_pTxt1;
	while (*m_pTxt2)
	{
		if (*m_pTxt2 == TEXT('\n'))
		{
			*m_pTxt2 = TEXT('\0');
			m_pTxt2++;
      ::SetWindowText(m_hWnd, NULL);
			return TRUE;
		}
		else
			m_pTxt2++;
	}
  m_pTxt2 = m_pTxt1; // failed to find separator
	return FALSE;
}

void CToggleTextControlHelper::SetToggleState(BOOL bFirst)
{
  ASSERT(::IsWindow(m_hWnd));
	::SetWindowText(m_hWnd, bFirst ? m_pTxt1 : m_pTxt2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsadminlib\src\dssec.cpp ===
#include "pch.h"

//
//Functions to replace GetNamedSecurityInfo and SetNamedSecurityInfo
// 

HRESULT
SetSecInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions = 0;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDsObject
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pDsObject] --  DS object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------

HRESULT GetSDForDsObject(IDirectoryObject* pDsObject,
                         PACL* ppDACL,
                         PSECURITY_DESCRIPTOR* ppSD)
{
    if(!pDsObject || !ppSD)
    {
        return E_POINTER;
    }
    
    *ppSD = NULL;
    if(ppDACL)
    {
       *ppDACL = NULL;
    }

    HRESULT hr = S_OK;    
    PADS_ATTR_INFO pSDAttributeInfo = NULL;
            
   do
   {
      WCHAR const c_szSDProperty[]  = L"nTSecurityDescriptor";      
      LPWSTR pszProperty = (LPWSTR)c_szSDProperty;
      
      // Set the SECURITY_INFORMATION mask to DACL_SECURITY_INFORMATION
      hr = SetSecInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
         break;

      DWORD dwAttributesReturned;
   
      // Read the security descriptor attribute
      hr = pDsObject->GetObjectAttributes(&pszProperty,
                                          1,
                                          &pSDAttributeInfo,
                                          &dwAttributesReturned);

      if(SUCCEEDED(hr) && !pSDAttributeInfo)
      {
         hr = E_FAIL;
      }

      if(FAILED(hr))
         break;


      if((ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType) && 
         (ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType))
      {

         *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);
         if (!*ppSD)
         {
               hr = E_OUTOFMEMORY;
               break;
         }

         CopyMemory(*ppSD,
                     pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue,
                     pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);

         if(ppDACL)
         {
               BOOL bDaclPresent,bDaclDeafulted;
               if(!GetSecurityDescriptorDacl(*ppSD,
                                             &bDaclPresent,
                                             ppDACL,
                                             &bDaclDeafulted))
               {
                  DWORD dwErr = GetLastError();
                  hr = HRESULT_FROM_WIN32(dwErr);
                  break;
               }
         }
      }
      else
      {
         hr = E_FAIL;
      }
    }while(0);



    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    if(FAILED(hr))
    {
        if(*ppSD)
        {
            LocalFree(*ppSD);
            *ppSD = NULL;
            if(ppDACL)
                ppDACL = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDsObjectSD
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pszObjectPath] --  LDAP Path of ds object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
HRESULT GetDsObjectSD(LPCWSTR pszObjectPath,
                      PACL* ppDACL,
                      PSECURITY_DESCRIPTOR* ppSecurityDescriptor)
{
    if(!pszObjectPath || !ppSecurityDescriptor)
    {
        return E_POINTER;
    }

    CComPtr<IDirectoryObject> pDsObject;
    HRESULT hr = DSAdminOpenObject(pszObjectPath, IID_IDirectoryObject, (void**)&pDsObject);
    if(SUCCEEDED(hr))
    {
        hr = GetSDForDsObject(pDsObject,ppDACL,ppSecurityDescriptor);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDaclForDsObject
//  Synopsis:   Sets the  the DACL for the specified DS object
//
//  Arguments:  [IN  pDsObject] --  ds object
//              [IN pDACL]     --pointer to dacl to be set
//
//----------------------------------------------------------------------------
HRESULT SetDaclForDsObject(IDirectoryObject* pDsObject,
                           PACL pDACL)
{
    if(!pDsObject || !pDACL)
    {
        return E_POINTER;
    }
                                  
    WCHAR const c_szSDProperty[]  = L"nTSecurityDescriptor";

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pSDCurrent = NULL;
    HRESULT hr = S_OK;

   do
   {
      //Get the current SD for the object
      hr = GetSDForDsObject(pDsObject,NULL,&pSDCurrent);
      if(FAILED(hr))
         break;

      //Get the control for the current security descriptor
      SECURITY_DESCRIPTOR_CONTROL currentControl;
      DWORD dwRevision = 0;
      if(!GetSecurityDescriptorControl(pSDCurrent, &currentControl, &dwRevision))
      {
         DWORD dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(dwErr);
         break;
      }

      //Allocate the buffer for Security Descriptor
      pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + pDACL->AclSize);
      if(!pSD)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      if(!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
      {
         DWORD dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(dwErr);
         break;
      }

      PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pSD;
      //
      // Finally, build the security descriptor
      //
      pISD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ 
         | (currentControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

      if (pDACL->AclSize > 0)
      {
         pISD->Dacl = (PACL)(pISD + 1);
         CopyMemory(pISD->Dacl, pDACL, pDACL->AclSize);
      }

      //We are only setting DACL information
      hr = SetSecInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
         break;

      // Need the total size
      DWORD dwSDLength = GetSecurityDescriptorLength(pSD);

      //
      // If necessary, make a self-relative copy of the security descriptor
      //
      SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
      if(!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
      {
         DWORD dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(dwErr);
         break;
      }

      if (!(sdControl & SE_SELF_RELATIVE))
      {
         PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

         if (psd == NULL ||
               !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
         {
               DWORD dwErr = GetLastError();
               hr = HRESULT_FROM_WIN32(dwErr);
               break;
         }

         // Point to the self-relative copy
         LocalFree(pSD);        
         pSD = psd;
      }
      
      ADSVALUE attributeValue;
      ZeroMemory(&attributeValue, sizeof(ADSVALUE));

      ADS_ATTR_INFO attributeInfo = {0};

      attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeValue.SecurityDescriptor.dwLength = dwSDLength;
      attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

      attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
      attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
      attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeInfo.pADsValues = &attributeValue;
      attributeInfo.dwNumValues = 1;
   
      DWORD dwAttributesModified = 0;

      // Write the security descriptor
      hr = pDsObject->SetObjectAttributes(&attributeInfo,
                                          1,
                                          &dwAttributesModified);

    }while(0);

   if(pSDCurrent)
   {
      LocalFree(pSDCurrent);
   }

   if(pSD)
   {
      LocalFree(pSD);
   }

    return S_OK;

}



HRESULT SetDsObjectDacl(LPCWSTR pszObjectPath,
                        PACL pDACL)
{
    if(!pszObjectPath || !pDACL)
        return E_POINTER;

    CComPtr<IDirectoryObject> pDsObject;

    HRESULT hr = DSAdminOpenObject(pszObjectPath, IID_IDirectoryObject,(void**)&pDsObject);
    if(SUCCEEDED(hr))
    {
        hr = SetDaclForDsObject(pDsObject,pDACL);
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\doinst.cpp ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		doinst.cpp
//
//  History:	Aug. 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#include <windows.h>
#include <setupapi.h>
#include <advpub.h>
#include "resource.h"
#include "dscsetup.h"	
#include "wizard.h"
#include "doinst.h"    


extern	SInstallVariables	g_sInstVar;


// do installation
DWORD DoInstallation(HWND hWnd)
{
  if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS)
  {
    // set the fake progressbar for DCOM and WAB nstall
    g_sInstVar.m_uTimerID = SetTimer(hWnd,
                                     1,
                                     1000,  // 1 seconds
                                     Timer1Proc);

    // do the custom action of NTLMv2
    if(!DoEncSChannel())
    	    g_sInstVar.m_nSetupResult = SETUP_ERROR;

    // stop the fake progressbar
    if(g_sInstVar.m_uTimerID)
        KillTimer(hWnd, g_sInstVar.m_uTimerID);

    // install adsi
    if (!LaunchProcess(STR_INSTALL_ADSI))
    {
      g_sInstVar.m_nSetupResult = SETUP_ERROR;
    }

   	// install dsclient
    if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS)
	    g_sInstVar.m_nSetupResult = LaunchINFInstall(hWnd);

  }

	return g_sInstVar.m_nSetupResult;
}


VOID CALLBACK Timer1Proc(HWND hwnd,     // handle of window for timer messages
                         UINT uMsg,     // WM_TIMER message
                         UINT idEvent,  // timer identifier
                         DWORD dwTime)   // current system time
{
    static int nCount = 0;

    if(nCount > 100)
        nCount = 100;

    // set the fake progressbar 
	SendMessage (g_sInstVar.m_hProgress, PBM_SETPOS, (WPARAM) nCount, 0); 
    
    nCount ++;
}
 

// This routine will do an installation based on those settings 
// using the setupapi.dll
INT LaunchINFInstall( HWND hWnd )
{
  TCHAR	szInfFileName[MAX_PATH + 1];
	TCHAR	szInstallSection[MAX_TITLE];
  BOOL	bResult = FALSE;

  // Context for my call back routine
  HSPFILEQ		hFileQueue;
  HINF			hInf;
	PVOID			pDefaultContext;
 
	//
  // Get inf handle
  // must know where the inf is located 
  // SetupOpenInfFile will only look in windows\inf by default
  //

  // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.  m_szSourcePath may
  // not be NULL terminated and/or it may be larger than the size allocated
  // for szInfFileName

  lstrcpy(szInfFileName, g_sInstVar.m_szSourcePath);

  // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.  m_szSourcePath + STR_DSCLIENT_INF
  // may be larger than szInfFileName

  lstrcat(szInfFileName, STR_DSCLIENT_INF);

  hInf = SetupOpenInfFile(szInfFileName,   // If path,needs full path, else looks in %windir%\inf
						NULL,            // Inf Type, matches Class in [Version] section SetupClass=SAMPLE
						INF_STYLE_WIN4,  // or INF_STYLE_OLDNT
						NULL);           // Line where error occurs if inf is has a problem
						
  if (hInf == INVALID_HANDLE_VALUE) 
	  return SETUP_ERROR;
		
  //
  // Create a Setup file queue and initialize the default Setup
  // queue callback routine.
  //
  hFileQueue = SetupOpenFileQueue();

  if(hFileQueue == INVALID_HANDLE_VALUE) 
	{
		SetupCloseInfFile(hInf);
    return SETUP_ERROR;
	}
    
    // using SetupInitDefaultQueueCallback.    
	SendMessage (g_sInstVar.m_hProgress, PBM_SETPOS, (WPARAM) 0, 0);	
	pDefaultContext = SetupInitDefaultQueueCallbackEx(hWnd,  // HWND of owner window
													NULL,  // HWND of alternate progress dialog which receives 
													0,     // Message sent to above window indicating a progress message
													0,     // DWORD Reserved
													NULL);   // PVOID Reserved
																	
  if(!pDefaultContext)
  {
      // Close the queue and the inf file and return
      SetupCloseFileQueue(hFileQueue);
      SetupCloseInfFile(hInf);
      return SETUP_ERROR;
  }

  // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.  At minimum should
  // use an n version so as not to exceed szInstallSection. szInstallSection
  // was not initialized with zeros

  lstrcpy (szInstallSection, STR_INSTALL_SECTIONNT4);
	//
  // Queue file operations and commit the queue.
  //
	bResult = SetupInstallFilesFromInfSection(hInf,			// HINF that has the directory ids set above
											  NULL,          // layout.inf if you have one, this a convient
											  hFileQueue,     // Queue to add files to
											  szInstallSection,   // SectionName,
											  g_sInstVar.m_szSourcePath,    // Path where the source files are located
											  SP_COPY_NEWER );
	//
  // All the files for each component are now in one queue
  // now we commit it to start the copy ui, this way the
  // user has one long copy progress dialog--and for a big install
  // can go get the cup of coffee 
	if(bResult)
		bResult = SetupCommitFileQueue(hWnd,                    // Owner
										hFileQueue,             // Queue with the file list
										QueueCallbackProc,		// This is our handler, it calls the default for us
										pDefaultContext);       // Pointer to resources allocated with SetupInitDefaultQueueCallback/Ex                 
		
	if (!bResult || (g_sInstVar.m_nSetupResult == SETUP_CANCEL))
	{
		SetupTermDefaultQueueCallback(pDefaultContext);
    SetupCloseFileQueue(hFileQueue);
    SetupCloseInfFile(hInf);

		if(g_sInstVar.m_nSetupResult == SETUP_CANCEL)
			return SETUP_CANCEL;
		else
			return SETUP_ERROR;
	}

  //
  // NOTE: you can do the entire install
  // for a section with this api but in this case
  // we build the file list conditionally and
  // do only out ProductInstall section for registy stuff
  // Also using SPINST_FILES will do the files
  // as above but only one section at a time
  // so the progress bar would keep completing and starting over
  // SPINST_ALL does files, registry and inis
  // 
	bResult = SetupInstallFromInfSection(hWnd,
										hInf,
										szInstallSection,
										SPINST_INIFILES | SPINST_REGISTRY,
										HKEY_LOCAL_MACHINE,
										NULL,	//m_szSourcePath,    // Path where the source files are located
										0,		//SP_COPY_NEWER,
										NULL,	//(PSP_FILE_CALLBACK) QueueCallbackProc, 
										NULL,	//&MyInstallData,
										NULL, 
										NULL);

	//
  // We're done so free the context, close the queue,
  // and release the inf handle
  //
	SetupTermDefaultQueueCallback(pDefaultContext);
  SetupCloseFileQueue(hFileQueue);
  SetupCloseInfFile(hInf);
    	    
  if (g_sInstVar.m_bSysDlls)
  {
    //
 	  // register OCX file
    //
    if(!RegisterOCX())
    {
		  return SETUP_ERROR;
    }
  }

  //
	// The custom registry action after dsclient.inf by Chandana Surlu 
  //
	DoDsclientReg();

	SendMessage (g_sInstVar.m_hProgress, PBM_SETPOS, (WPARAM) 100, 0);
  InstallFinish(FALSE);

  return SETUP_SUCCESS;
}

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
UINT CALLBACK QueueCallbackProc(PVOID   	pDefaultContext,
								UINT	    Notification,
								UINT_PTR	Param1,
								UINT_PTR	Param2)
{
	static INT	snFilesCopied;

	// synchronizing user cancel
	
   // REVIEWED-2002/03/12-JeffJon-We want to allow the exception to propogate
   // out.
   EnterCriticalSection(&g_sInstVar.m_oCriticalSection);
	LeaveCriticalSection(&g_sInstVar.m_oCriticalSection);

	//instaniate dialog first time
    if (g_sInstVar.m_nSetupResult == SETUP_CANCEL)
	{
		SetLastError (ERROR_CANCELLED);
		return FILEOP_ABORT;
	}

    switch (Notification)
    {
	case SPFILENOTIFY_STARTQUEUE:
	case SPFILENOTIFY_ENDQUEUE:
		
		return FILEOP_DOIT;

    case SPFILENOTIFY_STARTCOPY:
	
		// update file name item  
		SetWindowText(g_sInstVar.m_hFileNameItem, 
                      ((PFILEPATHS) Param1)->Target);
		break;

	case SPFILENOTIFY_ENDCOPY:
		
		snFilesCopied++;

		// update dialog file progress with message
		if ((snFilesCopied + 1)>= NUM_FILES_TOTAL)
		{
			SendMessage (g_sInstVar.m_hProgress, 
                         PBM_SETPOS, 
                         (WPARAM) 100,
                         0); 	
		}
		else
		{
			SendMessage (g_sInstVar.m_hProgress, 
                         PBM_SETPOS, 
                         (WPARAM) ((float)snFilesCopied / 
                                (float)NUM_FILES_TOTAL * 100), 
                         0); 
		}

		break;		

 	default:
		break;
	}

	return SetupDefaultQueueCallback(pDefaultContext, 
                                     Notification, 
									 Param1, 
									 Param2);
}

VOID InstallFinish(BOOL nShow)
{
   // ISSUE-2002/03/12-JeffJon-Should call WinExec with
   // the full path to the exe

	if(nShow)
		WinExec("grpconv -o", SW_SHOWNORMAL);
	else
		WinExec("grpconv -o", SW_HIDE);	  
}


// launch Inf file to install this component
BOOL LaunchProcess(LPTSTR lpCommandLine)
{
	BOOL bResult = FALSE;

	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;

	// its console window will be invisible to the user.
	ZeroMemory(&pi,sizeof(PROCESS_INFORMATION));
	ZeroMemory(&si,sizeof(STARTUPINFO));
	si.cb			= sizeof (STARTUPINFO);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;            // HideWindow

   // ISSUE-2002/03/12-JeffJon-Should call CreateProcess with
   // the full path to the exe

   if(CreateProcess(	NULL,					
						lpCommandLine,			
						NULL,					
						NULL,					
						FALSE,				
						0,					
						NULL,				
						NULL,				
						&si,                
						&pi ) )             
	{
		// wait to finish the runing setup process
		WaitForSingleObject(pi.hProcess,INFINITE);
	
		// close process handle
		if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hProcess) ;
		}
		if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hThread) ;
		}

		bResult = TRUE;
	}

	return bResult;
}

// register OCX file
BOOL RegisterOCX()
{
  TCHAR  szSystem[MAX_PATH + 1];
  TCHAR  szTemp[MAX_PATH + 1];
  TCHAR  szCmdline[MAX_PATH + 1];
  BOOL  bSuccess = TRUE;

  if(!GetSystemDirectory(szSystem, MAX_PATH))
      return FALSE;

 
  // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
  // Should consider using the strsafe inline APIs

  wsprintf(szTemp, 
          TEXT("%s%s%s"),
          szSystem,
          STR_REGISTER_REGSVR32_S_EXE,
          szSystem);

  //
  // REVIEW_JEFFJON : we are not going to register it here
  //                  Instead we are going to set the RunOnce regkey
  //                  to register the dlls on reboot
  //

  if (g_sInstVar.m_bWabInst)
  {
    // register dsfolder.dll
    
     // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
    // Should consider using the strsafe inline APIs

    wsprintf(szCmdline, 
            TEXT("%s%s %s%s %s%s %s%s %s%s"),
            szTemp,
            STR_REGISTER_DSFOLDER_DLL,
            szSystem,
            STR_REGISTER_DSUIEXT_DLL,
            szSystem,
            STR_REGISTER_DSQUERY_DLL,
            szSystem,
            STR_REGISTER_CMNQUERY_DLL,
            szSystem,
            STR_REGISTER_DSPROP_DLL);

    ULONG WinError = 0;
    HKEY RunOnceKey = NULL;
    ULONG Size = 0;
	  ULONG Type = REG_SZ;
    DWORD dwDisp = 0;

	  // open reg key
    WinError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
							                RUNONCE_KEY,
							                0,
							                NULL,
							                REG_OPTION_NON_VOLATILE,
							                KEY_ALL_ACCESS,
							                NULL,
							                &RunOnceKey,
							                &dwDisp);

    if (WinError == ERROR_SUCCESS)
    {
  	  UINT BufferSize = strlen(szCmdline);
  	  BufferSize++;
		  WinError = RegSetValueEx( RunOnceKey,
								                REG_DSUI_VALUE,
								                0,
								                Type,
								                (PUCHAR)szCmdline,
								                BufferSize);
      if (WinError != ERROR_SUCCESS && bSuccess)
      {
        bSuccess = FALSE;
      }

      //
      // Run wabinst.exe
      //
      // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
      // Should consider using the strsafe inline APIs

      wsprintf(szCmdline,
               TEXT("%s%s"),
               szSystem,
               STR_RUN_WABINST_EXE);
      if (!LaunchProcess(szCmdline))
      {
        bSuccess = FALSE;
      }
    }
    else
    {
      bSuccess = FALSE;
    }

    if (RunOnceKey)
    {
        RegCloseKey(RunOnceKey);
    }
  }

  return bSuccess;
}        



// The custom registry action after dsclient.inf by Chandana Surlu 
VOID DoDsclientReg()
{
  ULONG WinError = 0;
  HKEY ProvidersKey = NULL;
  ULONG Size = 0;
  ULONG Type = REG_SZ;
	ULONG BufferSize = 0;
  LPSTR StringToBeWritten = NULL;
  DWORD dwDisp;
	BOOL  bSuccess = FALSE;

	// open reg key
  WinError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
						SECURITY_PROVIDERS_KEY,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&ProvidersKey,
						&dwDisp);

  if (WinError != ERROR_SUCCESS)
  {
    if (WinError == ERROR_FILE_NOT_FOUND)
    {
      BufferSize = sizeof(NEGOTIAT);
      StringToBeWritten= (LPSTR) LocalAlloc(0,BufferSize);
      if (StringToBeWritten)
			{
			  // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
           // Should consider using the strsafe inline APIs

           strcpy (StringToBeWritten, NEGOTIAT);

				bSuccess = TRUE;
			}
		}
  }
  else
  {
    WinError = RegQueryValueEx(ProvidersKey,
								 SECURITY_PROVIDERS_VALUE,
								 0,
								 &Type,
								 NULL,
								 &Size);

    if ( WinError == ERROR_SUCCESS) 
    {
      BufferSize = Size + sizeof(COMMA_BLANK) + sizeof(NEGOTIAT);
      StringToBeWritten= (LPSTR) LocalAlloc(0,BufferSize);
      
	    if (StringToBeWritten) 
	    {
	      WinError = RegQueryValueEx(ProvidersKey,
								SECURITY_PROVIDERS_VALUE,
								0,
								&Type,
								(PUCHAR) StringToBeWritten,
								&Size);

				if ( WinError == ERROR_SUCCESS) 
				{
          if (NULL == strstr(StringToBeWritten, NEGOTIAT))
          {
					  // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
                 // Should consider using the strsafe inline APIs

                 strcat (StringToBeWritten, COMMA_BLANK);
					  strcat (StringToBeWritten, NEGOTIAT);

					  bSuccess = TRUE;
          }
				}
			}
    }
    else if (WinError == ERROR_FILE_NOT_FOUND)
    {
      BufferSize = sizeof(NEGOTIAT) + sizeof(CHAR);
      StringToBeWritten= (LPSTR) LocalAlloc(0,BufferSize);
      if (StringToBeWritten) 
			{
				// ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
            // Should consider using the strsafe inline APIs

            strcpy (StringToBeWritten, NEGOTIAT);
				Type = REG_SZ;

				bSuccess = TRUE;
			}
    }
  }

	if(bSuccess)
	{
		BufferSize = strlen(StringToBeWritten);
		BufferSize++;
		WinError = RegSetValueEx( ProvidersKey,
								  SECURITY_PROVIDERS_VALUE,
								  0,
								  Type,
								  (PUCHAR)StringToBeWritten,
								  BufferSize);
	}

  if (ProvidersKey)
  {
    RegCloseKey(ProvidersKey);
  }
  if (StringToBeWritten)
  {
    LocalFree(StringToBeWritten);
  }
}

// The NTLMv2 custom action before dsclient.inf installation.
// Calling encrypted schannel installer to create dynamically a 128 bit secur32.dll
// to replace the old 56 bit secur32.dll. 
BOOL DoEncSChannel()
{
    FPGETENCSCHANNEL fpEncSChannel;
    HINSTANCE  hInst;
    BYTE*  pFileData;
    DWORD  dwSize = 0;
    HANDLE hFile;
    DWORD  dwWritten;
    BOOL   bRet;

    // load "instsec.dll" 

    // ISSUE-2002/03/12-JeffJon-Should call LoadLibrary with
    // the full path to the library since we are running on NT4
    hInst = LoadLibrary(STR_INSTSEC_DLL); 
    if(!hInst) 
        return TRUE;

    // get the pointer of function "GetEncSChannel"
    fpEncSChannel = (FPGETENCSCHANNEL) GetProcAddress(hInst, STR_GETENCSCHANNEL);

    // calling GetEncSChannel to get the file data
    if( !fpEncSChannel ||
        fpEncSChannel(&pFileData, &dwSize) == FALSE ||
        dwSize == 0)
    {
        FreeLibrary( hInst );
        return TRUE;
    }

    // create file - "secur32.dll"

    // REVIEWED-2002/03/12-JeffJon-File permissions are the
    // minimum required
    hFile = CreateFile(
        STR_SECUR32_DLL,        // pointer to name of the file "secur32.dll"
        GENERIC_WRITE,          // access (read-write) mode
        0,                      // share mode
        NULL,                   // pointer to security attributes
        CREATE_ALWAYS,          // how to create
        FILE_ATTRIBUTE_NORMAL,  // file attributes
        NULL                    // handle to file with attributes to copy
        );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        VirtualFree(pFileData, 0, MEM_RELEASE);
        FreeLibrary( hInst );
        return FALSE;
    }

    // write the file data to file "secur32.dll"
    bRet = WriteFile(
        hFile,              // handle to file to write to
        pFileData,          // pointer to data to write to file
        dwSize,             // number of bytes to write
        &dwWritten,         // pointer to number of bytes written
        NULL                // pointer to structure for overlapped I/O
        );

    if(bRet && dwSize != dwWritten)
        bRet = FALSE;

    // clean memory
    VirtualFree(pFileData, 0, MEM_RELEASE);
    CloseHandle( hFile );
    FreeLibrary( hInst );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\dscsetup.cpp ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		dscsetup.cpp
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#include <windows.h>
#include <prsht.h>
#include <setupapi.h>
#include <tchar.h>
#include <stdlib.h>
#include "resource.h"
#include "dscsetup.h"
#include "wizard.h"

#include "doinst.h"


SInstallVariables	g_sInstVar;


// DllMain Entry 
BOOL APIENTRY DllMain( HINSTANCE hInstance, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


// This is an exported function.
DWORD WINAPI DoDscSetup(LPCSTR lpCmdLine)
{
	// initialize the variables of installation
	InitVariables();

	ParseCmdline(const_cast<PSTR>(lpCmdLine));

  //
  // Go through setup if we are installing with anything but
  // the /a flag
  //
  if (g_sInstVar.m_bSysDlls || g_sInstVar.m_bWabInst)
  {
	  // create objects
	  if(!CreateObjects())
          return SETUP_ERROR;

	  // Launch setup wizard
	  if(!DSCSetupWizard()) 
	  {
		  TCHAR		szMessage[MAX_MESSAGE + 1]; 
		  TCHAR		szTitle[MAX_TITLE + 1]; 

		  LoadString(g_sInstVar.m_hInstance, 
                     IDS_ERROR_WIZARD,
                     szMessage, 
                     MAX_MESSAGE);
		  LoadString(g_sInstVar.m_hInstance, 
                     IDS_ERROR_TITLE, 
                     szTitle, 
                     MAX_TITLE);

		  // display a error message - Failure to load Setup Wizard
		  MessageBox(NULL,	
					  szMessage,	// address of text in message box
					  szTitle,	// address of title of message box  
					  MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box

		  g_sInstVar.m_nSetupResult = SETUP_ERROR;
	  }

	  // destroy objects
	  DestroyObjects();

	  if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS &&
             !g_sInstVar.m_bQuietMode
#ifdef MERRILL_LYNCH
             && !g_sInstVar.m_bNoReboot
#endif
             )
	  {
		  // prompt reboot
		  SetupPromptReboot(NULL,		// optional, handle to a file queue
						  NULL,          // parent window of this dialog box
						  FALSE);        // optional, do not prompt user);
	  }
     else if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS &&
             g_sInstVar.m_bQuietMode 
#ifdef MERRILL_LYNCH
             && !g_sInstVar.m_bNoReboot
#endif
             )
     {
         HANDLE htoken = INVALID_HANDLE_VALUE;

         do
         {
            // twiddle our process privileges to enable SE_SHUTDOWN_NAME
            BOOL result = OpenProcessToken(GetCurrentProcess(),
                                          TOKEN_ADJUST_PRIVILEGES,
                                          &htoken);
            if (!result)
            {
               break;
            }

            LUID luid;
            memset(&luid, 0, sizeof(luid));
            result = LookupPrivilegeValue(0, SE_SHUTDOWN_NAME, &luid);
            if (!result)
            {
               break;
            }

            TOKEN_PRIVILEGES privs;
            memset(&privs, 0, sizeof(privs));
            privs.PrivilegeCount = 1;
            privs.Privileges[0].Luid = luid;
            privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // REVIEWED-2002/03/12-JeffJon-This is appropriate usage of
            // this dangerous API to allow for calling ExitWindowsEx

            result = AdjustTokenPrivileges(htoken, 0, &privs, 0, 0, 0);
            if (!result)
            {
               break;
            }

            result = ExitWindowsEx(EWX_REBOOT, 0);
            if (!result)
            {
               break;
            }
         }
         while (0);

         if (htoken != INVALID_HANDLE_VALUE)
         {
            CloseHandle(htoken);
         }

     }
  }
  else
  {
    //
    // Setup was run with the /a flag.  This means we
    // don't want to show the UI and let the adsix86.inf
    // handle the install for us
    //
    if (!LaunchProcess(STR_INSTALL_ADSIWREMOVE))
    {
      g_sInstVar.m_nSetupResult = SETUP_ERROR;
    }
  }
	return g_sInstVar.m_nSetupResult;
}


VOID ParseCmdline(LPSTR lpCmdLine)
{
  PCTSTR ptszTok = _tcstok(lpCmdLine, _T(" "));
  do
  {
    if (ptszTok != NULL)
    {
      if (_tcsicmp(ptszTok, _T("/q")) == 0)
      {
        g_sInstVar.m_bQuietMode = TRUE;
      }

      if (_tcsicmp(ptszTok, _T("/a")) == 0)
      {
        g_sInstVar.m_bWabInst = FALSE;
        g_sInstVar.m_bSysDlls = FALSE;
      }

      if (_tcsicmp(ptszTok, _T("/d")) == 0)
      {
        g_sInstVar.m_bWabInst = FALSE;
      }
#ifdef MERRILL_LYNCH
      if (_tcsicmp(ptszTok, _T("/n")) == 0)
      {
        g_sInstVar.m_bNoReboot = TRUE;
      }
#endif
    }
    ptszTok = _tcstok(NULL, _T(" "));
  } while (ptszTok != NULL);
}


// initialize the variables of installation
VOID InitVariables()
{
	g_sInstVar.m_hInstance = GetModuleHandle(STR_DLL_NAME);
  g_sInstVar.m_hInstallThread = NULL;
	g_sInstVar.m_uTimerID = 0;
  g_sInstVar.m_hBigBoldFont = NULL;
	g_sInstVar.m_hProgress = NULL;
	g_sInstVar.m_hFileNameItem = NULL;

  g_sInstVar.m_bDCOMInstalled = FALSE;

	g_sInstVar.m_bQuietMode = FALSE;
  g_sInstVar.m_bWabInst = TRUE;
  g_sInstVar.m_bSysDlls = TRUE;
#ifdef MERRILL_LYNCH
  g_sInstVar.m_bNoReboot = FALSE;
#endif
	g_sInstVar.m_nSetupResult = SETUP_SUCCESS;

  // get source path
  GetModuleFileName(g_sInstVar.m_hInstance,
                    g_sInstVar.m_szSourcePath, 
                    MAX_PATH);
  *(_tcsrchr(g_sInstVar.m_szSourcePath, CHAR_BACKSLASH) + 1) = TEXT('\0');       // Strip setup.exe off path
}

// start setup wizard
BOOL DSCSetupWizard()
{
	PROPSHEETHEADER psh;
	PROPSHEETPAGE	psPage[SIZE_WIZARD_PAGE];
	int  i = 0;

	//
	// Setup the Welcome page
	//
    i=0;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | PSP_HIDEHEADER;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_WELCOME);
	psPage[i].pfnDlgProc = WelcomeDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);

/* ntbug#337931: remove license page
    //
	// Setup the License Page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | 
                        PSP_USEHEADERTITLE | 
                        PSP_USEHEADERSUBTITLE;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_LICENSE);
	psPage[i].pfnDlgProc = LicenseDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
	psPage[i].pszHeaderTitle = MAKEINTRESOURCE(IDS_HEADERTITLE_LICENSE);
	psPage[i].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_HEADERSUBTITLE_LICENSE);
*/
	//
	// Setup the Select Page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | 
                        PSP_USEHEADERTITLE |
                        PSP_USEHEADERSUBTITLE;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_CONFIRM);
	psPage[i].pfnDlgProc = ConfirmDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
	psPage[i].pszHeaderTitle = MAKEINTRESOURCE(IDS_HEADERTITLE_CONFIRM);
	psPage[i].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_HEADERSUBTITLE_CONFIRM);

	//
	// Setup the Confirm Page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | 
                        PSP_USEHEADERTITLE | 
                        PSP_USEHEADERSUBTITLE;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_INSTALL);
	psPage[i].pfnDlgProc = InstallDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
	psPage[i].pszHeaderTitle = MAKEINTRESOURCE(IDS_HEADERTITLE_INSTALL);
	psPage[i].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_HEADERSUBTITLE_INSTALL);

	//
	// Setup the Completion page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | PSP_HIDEHEADER;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_COMPLETION);
	psPage[i].pfnDlgProc = CompletionDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);

	//
	// Setup the wizard
	//
	ZeroMemory(&psh,sizeof(PROPSHEETHEADER));
	psh.dwSize = sizeof(PROPSHEETHEADER);
	// Windows 98 with 16 color display mode crashes when PSH_STRETCHWATERMARK flag is on.
	psh.dwFlags = PSH_USEICONID | 
                  PSH_PROPSHEETPAGE | 
                  PSH_WIZARD97 |
                  PSH_WATERMARK |
                  PSH_HEADER; // | PSH_STRETCHWATERMARK;
	psh.pszIcon = MAKEINTRESOURCE(IDI_ICON_APP);
	psh.hInstance = g_sInstVar.m_hInstance;
	psh.pszCaption = MAKEINTRESOURCE(IDS_WIZARD_TITLE);;
	psh.nStartPage = 0;
	psh.nPages = SIZE_WIZARD_PAGE;
	psh.ppsp = (LPCPROPSHEETPAGE) psPage;

	//
	// Run the wizard
	//
	if(g_sInstVar.m_bQuietMode)
    {
        if(!CheckDiskSpace())
            return FALSE;

        psh.nStartPage = 2;
    }
	else
		psh.nStartPage = 0;

	if( PropertySheet(&psh) < 0 )	// failure to load wizard
	{
		return FALSE;
	}

	//
	// Because SetWindowLongPtr(hWnd, DWL_MSGRESULT, IDD_COMPLETION) 
    // doesn't work on Win95 (when users click Cancel, the wizard can't
    // be routed to the Completion page), I added the following code to
    // open the Completion page
	//
	if(!g_sInstVar.m_bQuietMode)
	{
		psh.nStartPage = 3;
		if( PropertySheet(&psh) < 0 )	// failure to load wizard
		{
			return FALSE;
		}
	}
	
	return TRUE;
}


// check for DCOM installed
void CheckDCOMInstalled()
{
	HKEY		hSubKey;

	// check if IE 4.0 has been installed
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, 
									  STR_DCOM_REGKEY, 
									  0, 
									  KEY_READ, 
									  &hSubKey)	)
	{
        g_sInstVar.m_bDCOMInstalled = TRUE;
		RegCloseKey(hSubKey);
	}
}

//  gets Disk Free space
DWORD64 SetupGetDiskFreeSpace()
{
    DWORD		dwSectorsPerCluster;
    DWORD		dwBytesPerSector;
    DWORD		dwNumberOfFreeClusters;
    DWORD		dwTotalNumberOfClusters;
    DWORD64  	d64FreeSpace = 0;
    TCHAR		szPathName[MAX_PATH + 1];	        // address of root path 

	if(GetSystemDirectory(szPathName,  // address of buffer for system directory
						  MAX_PATH))       // size of directory buffer);
	{
		if ( szPathName[1] == TEXT(':'))
		{
			// this is a drive letter
			// assume it is of for d:backslash
			szPathName[3] = TEXT('\0');		

			//get free space, GetDiskFreeSpaceEx() don't support in older Win95
			if (GetDiskFreeSpace(szPathName,	        // address of root path 
								 &dwSectorsPerCluster,	    // address of sectors per cluster 
								 &dwBytesPerSector,	        // address of bytes per sector 
								 &dwNumberOfFreeClusters,	// address of number of free clusters  
								 &dwTotalNumberOfClusters)) // address of total number of clusters  
			{
				// calc total  size
				d64FreeSpace = DWORD64(dwSectorsPerCluster)
							  * dwBytesPerSector
							  * dwNumberOfFreeClusters;
			}
		}
	}

	return d64FreeSpace;
}

// check if DSClient has been installed
BOOL CheckDSClientInstalled()
{
	HKEY	hSubKey;
	BOOL	bResult = FALSE;

	// open reg key of DS Client
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
									  STR_DSCLIENT_REGKEY,
									  0, 
									  KEY_ALL_ACCESS, 
									  &hSubKey)	) 
	{
		bResult = TRUE;		
		RegCloseKey(hSubKey);
	}

	return bResult;
}

/* ntbug#337931: remove license page
//  load "License Agreement" text from license file 
BOOL LoadLicenseFile(HWND hDlg)
{
	BOOL    bReturn = FALSE;
	TCHAR	szTitle[MAX_TITLE + 1];
	TCHAR	szTempBuffer[MAX_MESSAGE + 1];
	TCHAR	szLicenseFile[MAX_PATH + 1];
	TCHAR	szReturnTextBuffer[MAX_MESSAGE + 1]; 
    LPTSTR	lpszLicenseText = NULL;
    HANDLE	hFile;
    DWORD	dwNumberOfBytesRead, dwFileSize;

    //
    // Determine where we are installing from
    // and specific the license file there
    //
	lstrcpy(szLicenseFile, g_sInstVar.m_szSourcePath);
	lstrcat(szLicenseFile, STR_LICENSEFILE);	
	
    // Open License file
    hFile = CreateFile(szLicenseFile,       // pointer to name of the file 
                       GENERIC_READ,          // access (read-write) mode 
                       FILE_SHARE_READ,       // share mode 
                       NULL,                  // pointer to security descriptor 
                       OPEN_EXISTING,         // how to create 
                       FILE_ATTRIBUTE_NORMAL, // file attributes 
                       NULL);                 // handle to file with attributes to copy  

    if(INVALID_HANDLE_VALUE != hFile)
    {                
	
		// Read License file into string
		// setup memory, get file size in bytes
		dwFileSize = GetFileSize (hFile, NULL) ;

		if (dwFileSize != 0xFFFFFFFF) 
		{ 		
            // this program is for Win98/95, it will work in MBCS not UNICODE
            // this code is for ANSI US version, license.txt file uses the single byte character set(ANSI)
            // if doing locolization, license.txt file should use the double byte character set(DBCS/MBCS)
			lpszLicenseText = (LPTSTR) calloc (dwFileSize + sizeof(TCHAR), 
                                               sizeof(BYTE));
		}

		if(lpszLicenseText)
		{
			//read file
			if (ReadFile(hFile,    	// handle of file to read 
						  lpszLicenseText,    // address of buffer that receives data  
						  dwFileSize,    	// number of bytes to read 
						  &dwNumberOfBytesRead,    // address of number of bytes read 
						  NULL))                // address of structure for data 
			{
				// display license on dialog
				SetDlgItemText(hDlg, IDC_LICENSE_TEXT, lpszLicenseText);

				bReturn = TRUE;
			}

			// so free the memory
			free(lpszLicenseText);
		}

		//close file handle
		CloseHandle(hFile);
 	}
	
	if(!bReturn)
	{
		// load string
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_TITLE,
                   szTitle, 
                   MAX_TITLE);
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_LICENSEFILE, 
                   szTempBuffer, 
                   MAX_MESSAGE);
		wsprintf(szReturnTextBuffer, 
                 TEXT("%s %s"), 
                 szTempBuffer,
                 szLicenseFile);

		MessageBox(hDlg, 
			szReturnTextBuffer,
			szTitle, 
			MB_OK | MB_TOPMOST | MB_ICONERROR);
	}
      
    return bReturn;
}
*/

// check disk space
BOOL CheckDiskSpace()
{
	BOOL  bResult = TRUE;
	TCHAR  szString[MAX_MESSAGE + MAX_TITLE + 1];
	TCHAR  szTitle[MAX_TITLE + 1];
	TCHAR  szMessage[MAX_MESSAGE + 1];

	if(SIZE_TOTAL*MB_TO_BYTE > SetupGetDiskFreeSpace())
	{
		// load string
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_NODISKSPACE, 
                   szMessage, 
                   MAX_MESSAGE);
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_TITLE, 
                   szTitle, 
                   MAX_TITLE);

      // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.
      // Should consider using the strsafe inline APIs

		wsprintf(szString,
                 TEXT("%s %d MB."), 
                 szMessage, 
                 SIZE_TOTAL); 
            
		MessageBox(NULL,
				szString,
				szTitle, 
				MB_OK | MB_TOPMOST | MB_ICONERROR);

		bResult = FALSE;
	}

	return bResult;
}

// create objects
BOOL CreateObjects()
{
    try
    {
        // initialize the synchronizing object

       // REVIEWED-2002/03/12-JeffJon-The exception is being caught
       // and handled appropriately

       InitializeCriticalSection(&g_sInstVar.m_oCriticalSection);
    }
    catch(...)
    {
        return FALSE;
    }

    // create a 12 pt big font
    CreateBigFont();

    return TRUE;
}

// destroy objects
VOID DestroyObjects()
{
    // wait to finish the runing setup process
    if(g_sInstVar.m_hInstallThread)
    {
        // wait the installation thread to finish
	    WaitForSingleObject(g_sInstVar.m_hInstallThread,INFINITE);
   		CloseHandle(g_sInstVar.m_hInstallThread);
    }

   	// delete the synchronizing object
	DeleteCriticalSection(&g_sInstVar.m_oCriticalSection);

    //Frees up the space used by loading the fonts
    if( g_sInstVar.m_hBigBoldFont ) 
	{
        DeleteObject( g_sInstVar.m_hBigBoldFont );
    }

}

//create a big font for dialog title
VOID CreateBigFont()
{
    NONCLIENTMETRICS ncm;
    LOGFONT BigBoldLogFont;
    HDC hdc;

    // Create the fonts we need based on the dialog font
	ZeroMemory(&ncm,sizeof(NONCLIENTMETRICS));
    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	BigBoldLogFont = ncm.lfMessageFont;
    BigBoldLogFont.lfWeight = FW_BOLD;

	hdc = GetDC(NULL);
    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - 
                                  (GetDeviceCaps(hdc,LOGPIXELSY) * 
                                   SIZE_TITLE_FONT / 
                                   72);

        g_sInstVar.m_hBigBoldFont = CreateFontIndirect(&BigBoldLogFont);

        ReleaseDC(NULL,hdc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_SETUP_SUCCESS_TITLE         1
#define IDS_SETUP_SUCCESS               2
#define IDS_SETUP_CANCEL_TITLE          3
#define IDS_SETUP_CANCEL                4
#define IDS_SETUP_ERROR_TITLE           5
#define IDS_SETUP_ERROR                 6
#define IDS_CANCEL_TITLE                7
#define IDS_CANCEL_MSG                  8
#define IDS_ERROR_TITLE                 9
#define IDS_ERROR_WIN98SP1_MESSAGE      12
#define IDS_ERROR_REGISTEROCX_MESSAGE   13
#define IDS_ERROR_NODISKSPACE           14
#define IDS_ERROR_LICENSEFILE           15
#define IDS_ERROR_WIZARD                16
#define IDS_WIZARD_TITLE                17
#define IDS_HEADERTITLE_LICENSE         18
#define IDS_HEADERSUBTITLE_LICENSE      19
#define IDS_HEADERTITLE_INSTALL         20
#define IDS_HEADERSUBTITLE_INSTALL      21
#define IDS_HEADERTITLE_CONFIRM         22
#define IDS_HEADERSUBTITLE_CONFIRM      23
#define IDS_REINSTALL_MSG               25
#define IDS_WARNING_TITLE               27
#define IDD_LICENSE                     104
#define IDD_WELCOME                     107
#define IDB_HEADER                      127
#define IDD_CONFIRM                     128
#define IDB_MAIN                        132
#define IDD_COMPLETION                  133
#define IDD_INSTALL                     134
#define IDI_ICON_APP                    139
#define IDB_MAINBACKCOLOR               142
#define IDC_LICENSE_TEXT                1010
#define IDC_STATIC			1011
#define IDC_STATIC1                     1012
#define IDC_STATIC2                     1013
#define IDC_STATIC3                     1014
#define IDC_STATIC_WELCOME_TITLE        1035
#define IDC_RADIO_ACCEPTED              1040
#define IDC_RADIO_REJECTED              1041
#define IDC_STATIC_COMPLETION_TITLE     1042
#define IDC_STATIC_COMPLETION           1043
#define IDC_STATIC_CONFIRM_INSTALL      1044
#define IDC_INSTALL_PROGRESS            1045
#define IDC_STATIC_FILENAME             1046

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\doinst.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		doinst.h
//
//  History:	Aug. 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#define		STR_DSCLIENT_INF		        TEXT("dsclient.inf")

#define   STR_INSTALL_SECTIONNT4      TEXT("DSClientNT4")

#define		STR_DSCLIENTINF_REGISTEROCX	TEXT("DsClient.inf,RegisterOCXsection,1,N")
#define   STR_INSTSEC_DLL             TEXT("instsec.dll")
#define   STR_SECUR32_DLL             TEXT("secur32.dll")
#define   STR_GETENCSCHANNEL          "GetEncSChannel"

// define for the custom registry action after dscleint.inf by Chandana Surlu 
#define		SECURITY_PROVIDERS_KEY		  TEXT("System\\CurrentControlSet\\Control\\SecurityProviders")
#define		SECURITY_PROVIDERS_VALUE	  TEXT("SecurityProviders")
#define		COMMA_BLANK					        TEXT(", ")
#define		NEGOTIAT					          TEXT("negotiat.dll")

#define   RUNONCE_KEY                 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define   REG_DSUI_VALUE              TEXT("RegisterDSUI")
#define   REG_WABINST_VALUE           TEXT("RunWABINST")
#define   REG_DSPROP_VALUE            TEXT("RegisterDSPROP")

#define   STR_REGISTER_REGSVR32_SI_EXE   TEXT("\\regsvr32.exe /s /i ")
#define   STR_REGISTER_REGSVR32_S_EXE TEXT("\\regsvr32.exe /s ")
#define   STR_RUN_WABINST_EXE         TEXT("\\wabinst.exe /q /r:n")
#define   STR_REGISTER_DSFOLDER_DLL   TEXT("\\dsfolder.dll")
#define   STR_REGISTER_DSQUERY_DLL    TEXT("\\dsquery.dll")
#define   STR_REGISTER_DSUIEXT_DLL    TEXT("\\dsuiext.dll")
#define   STR_REGISTER_CMNQUERY_DLL   TEXT("\\cmnquery.dll")
#define   STR_REGISTER_DSPROP_DLL     TEXT("\\dsprop.dll")



INT  LaunchINFInstall( HWND hWnd );

VOID CALLBACK Timer1Proc(HWND hwnd,  
                         UINT uMsg,  
                         UINT idEvent, 
                         DWORD dwTime);

UINT CALLBACK QueueCallbackProc(PVOID	    pDefaultContext,
								UINT	    Notification,
								UINT_PTR	Param1,
								UINT_PTR	Param2);

VOID InstallFinish(BOOL nShow);
BOOL LaunchProcess(LPTSTR lpCommandLine);
BOOL RegisterOCX();
VOID DoDsclientReg();
BOOL DoEncSChannel();


// encrypted schannel installer
typedef BOOL (__cdecl *FPGETENCSCHANNEL)(BYTE**, DWORD*);
//BOOL __cdecl GetEncSChannel(BYTE **pData, DWORD *dwDecSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\wizard.cpp ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		wizard.cpp
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------

#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include "resource.h"
#include "dscsetup.h"
#include "doinst.h"
#include "wizard.h"


extern	SInstallVariables	g_sInstVar;


// welcome page DlgProc of wizard
BOOL CALLBACK WelcomeDialogProc(HWND hWnd, 
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
	{
		RECT	rc;

		// set font of title text
		SetWindowFont(GetDlgItem(hWnd, IDC_STATIC_WELCOME_TITLE),
					  g_sInstVar.m_hBigBoldFont,
					  TRUE);

		// Position the dialog
		if (GetWindowRect(GetParent(hWnd), &rc)) 
		{
			SetWindowPos(GetParent(hWnd),
						HWND_TOP,
						(GetSystemMetrics(SM_CXSCREEN) / 2) - 
                            ((rc.right - rc.left) / 2),
						(GetSystemMetrics(SM_CYSCREEN) / 2) - 
                            ((rc.bottom - rc.top) / 2),
						rc.right - rc.left,
						rc.bottom - rc.top,
						SWP_NOOWNERZORDER);
		}

		break;
	}
	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		// user click cancel
		case PSN_QUERYCANCEL:
			
			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
			break;

		case PSN_WIZNEXT:
			break;

		case PSN_SETACTIVE:

			PropSheet_SetWizButtons(GetParent(hWnd), PSWIZB_NEXT);
			break;
		
		default:
			break;
		}
		break;

	default:
		break;
	}

	return bReturn;
}

/* ntbug#337931: remove license page
// License page DlgProc of wizard
BOOL CALLBACK LicenseDialogProc(HWND hWnd,
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;
    HFONT       hLicenseTextFont;

	switch (nMessage) 
	{
	case WM_INITDIALOG:

		if(!CheckDiskSpace() ||			// check disk space
			!LoadLicenseFile(hWnd))		// Load license file
		{
			g_sInstVar.m_nSetupResult = SETUP_ERROR;
			PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);  // close wizard
		}

        // use a ANSI_FIXED_FONT (Couirer) font for EULA to replace the default
		// font - MS Shell Dlg in order to fix the bug in Hebrew Win95
		if(g_sInstVar.m_bWin95)
        {
            hLicenseTextFont = (HFONT) GetStockObject(ANSI_FIXED_FONT);
            if(hLicenseTextFont)
            {
		        SetWindowFont(GetDlgItem(hWnd, IDC_LICENSE_TEXT),
					          hLicenseTextFont,
					          TRUE);
            }
        }

		bReturn = TRUE;
		break;

	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		// user click cancel
		case PSN_QUERYCANCEL:

			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
			break;

		case PSN_WIZNEXT:
			break;

		case PSN_SETACTIVE:
		{
			HWND hButton;
			hButton = GetDlgItem(hWnd, IDC_RADIO_ACCEPTED);
			// get radio button check status
			if( hButton && 
                BST_CHECKED == SendMessage(hButton, BM_GETCHECK, 0, 0L) )
				PropSheet_SetWizButtons(GetParent(hWnd), 
                                        PSWIZB_BACK | PSWIZB_NEXT);
			else
				PropSheet_SetWizButtons(GetParent(hWnd),
                                        PSWIZB_BACK);
			
			break;
		}		
		default:
			break;
		}
		break;

	case WM_COMMAND:	// button click
		{
			HWND hButton;
			hButton = GetDlgItem(hWnd, IDC_RADIO_ACCEPTED);
			// get radio button check status
			if( hButton && BST_CHECKED == 
                SendMessage(hButton, BM_GETCHECK, 0, 0L) )
				PropSheet_SetWizButtons(GetParent(hWnd), 
                                        PSWIZB_BACK | PSWIZB_NEXT);
			else
				PropSheet_SetWizButtons(GetParent(hWnd), 
                                        PSWIZB_BACK);
		}

	default:
		break;
	}
	return bReturn;
}
*/

// Confirm page DlgProc of wizard
BOOL CALLBACK ConfirmDialogProc(HWND hWnd, 
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
		
		if(!CheckDiskSpace())			// check disk space
		{
			g_sInstVar.m_nSetupResult = SETUP_ERROR;
			PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);  // close wizard
		}

        // check if DSClient has been installed
		if(CheckDSClientInstalled())
		{
			// load string and dispaly it in textitem
			TCHAR  szMessage[MAX_MESSAGE + 1];
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_REINSTALL_MSG,
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd,
                           IDC_STATIC_CONFIRM_INSTALL,
                           szMessage);
		}
		break;
		
	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		// user click cancel
		case PSN_QUERYCANCEL:

			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
			break;

		case PSN_WIZNEXT:
			break;

		case PSN_SETACTIVE:
			PropSheet_SetWizButtons(GetParent(hWnd), 
                                    PSWIZB_BACK | PSWIZB_NEXT);
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	return bReturn;
}


// wizard dialog callback function
BOOL CALLBACK InstallDialogProc(HWND hWnd,
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam) 
{
	BOOL			bReturn = FALSE;
	LPNMHDR			lpMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
	{
		DWORD	dwThreadId;

        // get the handle of install progress bar and file name item
		g_sInstVar.m_hProgress = GetDlgItem(hWnd, IDC_INSTALL_PROGRESS);
		g_sInstVar.m_hFileNameItem = GetDlgItem(hWnd, IDC_STATIC_FILENAME);

		// start to do installation
		g_sInstVar.m_hInstallThread = CreateThread(NULL,	
								                    0,		
								                    DoInstallationProc,
								                    hWnd,	
								                    0,		
								                    &dwThreadId); 

    // if CreateThread() failed
    if(!g_sInstVar.m_hInstallThread)
    {
   		g_sInstVar.m_nSetupResult = SETUP_ERROR;
			PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);  // close wizard
    }

		bReturn = TRUE;
		break;		
	}
	case WM_NOTIFY:
	{
		lpMsg = (NMHDR FAR*) lParam;
		switch(lpMsg->code)
		{
		// cancel to do nothing
		case PSN_QUERYCANCEL:
	
			// block
			
         // REVIEWED-2002/03/12-JeffJon-We want to allow the exception
         // to propogate out
         EnterCriticalSection(&g_sInstVar.m_oCriticalSection);
			
			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
		
			// unblock
			LeaveCriticalSection(&g_sInstVar.m_oCriticalSection);
			
			break;

		case PSN_WIZFINISH:
			break;

		case PSN_WIZBACK:
			break;

		case PSN_SETACTIVE:

			PropSheet_SetWizButtons(GetParent(hWnd), 0);
			break;
			
		default:
			break;
		}
	}
	default:
		break;
	}
	
	return bReturn;
}

// Completion page DlgProc of wizard
BOOL CALLBACK CompletionDialogProc(HWND hWnd, 
                                   UINT nMessage,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
	{
		TCHAR		szMessage[MAX_MESSAGE + 1];
		RECT		rc;

		// load string and dispaly it in textitem
		switch (g_sInstVar.m_nSetupResult)
		{
		case SETUP_SUCCESS:
		
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_SUCCESS_TITLE, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION_TITLE, szMessage);
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_SUCCESS, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION, szMessage);
			break;

		case SETUP_CANCEL:
	
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_CANCEL_TITLE,
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION_TITLE, szMessage);
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_CANCEL, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION, szMessage);
			break;
			
		case SETUP_ERROR:
	
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_ERROR_TITLE,
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION_TITLE, szMessage);
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_ERROR, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION, szMessage);
			break;

		default:
			break;
		}
	
		// set font of title text
		SetWindowFont(GetDlgItem(hWnd, IDC_STATIC_COMPLETION_TITLE),
					  g_sInstVar.m_hBigBoldFont,
					  TRUE);
		
		// Position the dialog
		if (GetWindowRect(GetParent(hWnd), &rc)) 
		{
			SetWindowPos(GetParent(hWnd),
						HWND_TOP,
						(GetSystemMetrics(SM_CXSCREEN) / 2) - 
                            ((rc.right - rc.left) / 2),
						(GetSystemMetrics(SM_CYSCREEN) / 2) - 
                            ((rc.bottom - rc.top) / 2),
						rc.right - rc.left,
						rc.bottom - rc.top,
						SWP_NOOWNERZORDER);
		}
		
		break;
	}
	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		case PSN_QUERYCANCEL:
			break;

		case PSN_WIZFINISH:
			break;

		case PSN_SETACTIVE:

			// set wizard button
			PropSheet_SetWizButtons(GetParent(hWnd), PSWIZB_FINISH);
			PropSheet_CancelToClose(GetParent(hWnd));
			break;
		
		default:
			break;
		}

		break;

	default:
		break;
	}

	return bReturn;
}

// ask if you want to cancel the wizard
BOOL ConfirmCancelWizard(HWND hWnd)
{
	TCHAR			szMsg[MAX_MESSAGE + 1];
	TCHAR			szTitle[MAX_TITLE + 1];

	LoadString(g_sInstVar.m_hInstance, IDS_CANCEL_TITLE, szTitle, MAX_TITLE);
	LoadString(g_sInstVar.m_hInstance, IDS_CANCEL_MSG, szMsg, MAX_MESSAGE);

	if (IDYES == MessageBox(hWnd, 
                            szMsg, 
                            szTitle, 
                            MB_YESNO | MB_TOPMOST | MB_ICONQUESTION))
	{
    // kill timer
    if(g_sInstVar.m_uTimerID)
        KillTimer(hWnd, g_sInstVar.m_uTimerID);

    // set m_nSetupResult to SETUP_CANCEL, in order to stop the inatllation
    g_sInstVar.m_nSetupResult = SETUP_CANCEL;
		return TRUE;
	}

	return FALSE;
}

// do installation proc
DWORD WINAPI DoInstallationProc(LPVOID lpVoid)
{
	HWND hWnd = (HWND)lpVoid;

	// do installation
	g_sInstVar.m_nSetupResult = DoInstallation(hWnd);

	// Close install page of the setup wizard
	PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);		

	return g_sInstVar.m_nSetupResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\wizard.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		wizard.h
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------



BOOL CALLBACK WelcomeDialogProc(HWND hWnd, 
								UINT nMessage, 
								WPARAM wParam, 
								LPARAM lParam);
/* ntbug#337931: remove license page

BOOL CALLBACK LicenseDialogProc(HWND hWnd, 
								UINT nMessage, 
								WPARAM wParam, 
								LPARAM lParam);
*/
BOOL CALLBACK ConfirmDialogProc(HWND hWnd, 
							   UINT nMessage, 
							   WPARAM wParam, 
							   LPARAM lParam);

BOOL CALLBACK InstallDialogProc(HWND hWnd, 
								UINT nMessage, 
								WPARAM wParam, 
								LPARAM lParam);

BOOL CALLBACK CompletionDialogProc(HWND hWnd, 
								   UINT nMessage, 
								   WPARAM wParam, 
								   LPARAM lParam);

BOOL ConfirmCancelWizard(HWND hWnd);
DWORD WINAPI DoInstallationProc(LPVOID lpVoid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\setup\dfssetup.c ===
//+-------------------------------------------------------------------------
//
//	File:		DfsSetup.c  
//
// 	Purppose:	This a 16 bits program to install DFS.INF (net driver) 
//
// 	History:	June-1998	Zeyong Xu 	Created.
//
//--------------------------------------------------------------------------                

 
#include <windows.h>
#include <setupx.h>   

   
//
// Install Dfs driver instance on Windows95/98
//
int main( int argc, char *argv[])
{ 
	// initialize buffer
	char szDriverDescription[] = "DFS Services for Microsoft Network Client";  
	char szDriverName[] = "vredir.vxd"; 
	char szDriverPnPID[] = "DFSVREDIR"; 
	char szDriverInfFile[] = "dfs.inf"; 
	char szDriverDeviceSection[] = "DFSVREDIR.ndi";    
	char szNetClass[] = "netclient";
    LPDEVICE_INFO   lpdi = NULL;
    LPDRIVER_NODE   lpdn = NULL;
    int  nRet = 1;

	// if no dfs.inf file is found in commandline, return
	if( argc != 2 || lstrcmp(argv[1],szDriverInfFile) )
		return 0;

    //
    // Create a device info
    //
    if (DiCreateDeviceInfo(&lpdi, NULL, NULL, NULL, NULL, szNetClass, NULL) == OK)
    {
		//
        // Create a driver node
        //
        if (DiCreateDriverNode(&lpdn, 0, INFTYPE_TEXT, 0, szDriverDescription,
                szDriverDescription, NULL, NULL, szDriverInfFile,
                szDriverDeviceSection, NULL) == OK) 
        { 
            LPSTR   szTmp1, szTmp2; 

            //
            // Call the net class installer to install the driver
            //                      
            lpdi->lpSelectedDriver = lpdn;
            lpdi->hwndParent = NULL;
            
            
            // ISSUE-2002/03/12-JeffJon-Bad use of dangerous API.  szDriverDescription may
            // not be NULL terminated and/or it may be larger than the size allocated
            // for szDescription

            lstrcpy(lpdi->szDescription, szDriverDescription);

            szTmp1 = lpdn->lpszHardwareID;
            szTmp2 = lpdn->lpszCompatIDs;
            lpdn->lpszHardwareID = szDriverPnPID;
            lpdn->lpszCompatIDs  = szDriverPnPID;

	        // Calling NDI Class Installer...  
            if(DiCallClassInstaller(DIF_INSTALLDEVICE, lpdi) == OK) 
            {
                //
                // Are we supposed to reboot?
                //     
/*               if (lpdi->Flags & DI_NEEDREBOOT) 
                {
                    gNeedsReboot = TRUE;
                } 
*/                 
                nRet = 0;        // install successful
            }
             
             // change back settings
            lpdn->lpszCompatIDs  = szTmp2;
            lpdn->lpszHardwareID = szTmp1;
            lpdi->lpSelectedDriver = NULL;

            //
            // Destroy the driver node
            //    
            DiDestroyDriverNodeList(lpdn);

        } 
     
        //
        // Destroy the device info
        //
        DiDestroyDeviceInfoList(lpdi);
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\dscsetup\dscsetup.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		dscsetup.h
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#define		MAX_MESSAGE			1024
#define		MAX_TITLE			  64

#define		SETUP_SUCCESS		0
#define		SETUP_ERROR			1
#define		SETUP_CANCEL		2

#define		NUM_FILES_TOTAL	14
#define		SIZE_TOTAL			10
#define   MB_TO_BYTE			1000000
#define		SIZE_TITLE_FONT		12
#define		SIZE_WIZARD_PAGE	4

#define		STR_DSCLIENT_REGKEY		  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\DsClient")
#define		STR_IE_REGKEY			      TEXT("Software\\Microsoft\\Internet Explorer")
#define		STR_VERSION				      TEXT("Version")
#define		STR_IE_VERSION_4  		  TEXT("4")
#define		STR_DCOM_REGKEY			    TEXT("CLSID\\{BDC67890-4FC0-11D0-A805-00AA006D2EA4}\\InstalledVersion")
#define		STR_DLL_NAME			      TEXT("dscsetup.dll")
#define		STR_INSTALL_DCOM95		  TEXT("dcom95.exe /q /r:n")
#define		STR_INSTALL_WAB 		    TEXT("wabinst.exe /q /r:n")
#define   STR_INSTALL_ADSI        TEXT("adsix86.exe /C:\"rundll32 advpack.dll,LaunchINFSection adsix86.inf,RegADSIWithDsclient,,N\"")
#define   STR_INSTALL_ADSIWREMOVE TEXT("adsix86.exe")
#define		CHAR_BACKSLASH			    TEXT('\\')


// define a installation structure
typedef struct _SINSTALLVARIBLES
{
	HINSTANCE	m_hInstance;
  HANDLE    m_hInstallThread;
  UINT      m_uTimerID;
	HWND		  m_hProgress;
	HWND		  m_hFileNameItem;
	HFONT		  m_hBigBoldFont;

  BOOL      m_bDCOMInstalled;
	BOOL      m_bQuietMode;
  BOOL      m_bWabInst;
  BOOL      m_bSysDlls;
#ifdef MERRILL_LYNCH
  BOOL  m_bNoReboot;
#endif
	UINT		  m_nSetupResult;

	TCHAR		  m_szSourcePath[MAX_PATH + 1];

	CRITICAL_SECTION  m_oCriticalSection;

} SInstallVariables;


VOID InitVariables();
VOID ParseCmdline(LPSTR lpCmdLine);
DWORD DoInstallation(HWND hWnd);
VOID CentreWindow(HWND hwnd);
DWORD64 SetupGetDiskFreeSpace();
BOOL CheckDSClientInstalled();
BOOL DSCSetupWizard();
void CheckDCOMInstalled();
BOOL LoadLicenseFile(HWND hDlg);
BOOL CheckDiskSpace();
BOOL CreateObjects();
VOID DestroyObjects();
VOID CreateBigFont();                   

// export function
DWORD WINAPI DoDscSetup(LPCSTR lpCmdLine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_ERROR_TITLE                 1
#define IDS_ERROR_IE_MESSAGE            2
#define IDS_ERROR_OS_MESSAGE            3
#define IDS_ERROR_DSCSETUP_MESSAGE      4
#define IDS_ERROR_LOAD_DSCSETUPDLL      4
#define IDS_ERROR_DLLENTRY              5
#define IDS_ERROR_WIN98SP1_MESSAGE      6
#define IDS_ERROR_ADMINISTRATOR_MESSAGE 7
#define IDS_WARNING_TITLE               9
#define IDI_ICON_APP                    114

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1045
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\commonstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      commonstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   27-Aug-2001    JonN     split from individual commands
//
//--------------------------------------------------------------------------

#ifndef _COMMONSTRINGS_H_
#define _COMMONSTRINGS_H_

//
// Common switches
//
extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_continue;
extern PCWSTR c_sz_arg1_com_description;
extern PCWSTR c_sz_arg1_com_objecttype;
extern PCWSTR c_sz_arg1_com_objectDN;

// Unicode switches
extern PCWSTR c_sz_arg1_com_unicode;
extern PCWSTR c_sz_arg1_com_unicodeinput;
extern PCWSTR c_sz_arg1_com_unicodeoutput;

#endif // _COMMONSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\setup\setup.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		setup.h
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to do an NT4 setup
//																	
//------------------------------------------------------------------


#define		MAX_MESSAGE			512
#define		MAX_TITLE			64

#define		SETUP_SUCCESS		0
#define		SETUP_ERROR			1
#define		SETUP_CANCEL		2

#define		STR_DSCLIENT_REGKEY		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\DsClient")
#define		STR_IE_REGKEY			    TEXT("Software\\Microsoft\\Internet Explorer")
#define		STR_VERSION				    TEXT("Version")
#define		STR_IE_VERSION			  TEXT("4")
#define		STR_DSCSETUP_DLL		  TEXT("dscsetup.dll")
#define		STR_DODSCSETUP        "DoDscSetup"
#define   STR_INSTALL_ADSI      TEXT("adsix86.exe /C:\"rundll32 advpack.dll,LaunchINFSection adsix86.inf,RegADSIWithDsclient,,N\"")


typedef DWORD (WINAPI *FPDODSCSETUP)(LPCSTR);

typedef enum
{
  FullInstall,
  FullInstallQuiet,
  ADSIOnly,
  ADSIOnlyQuiet,
  Wabless,
  WablessQuiet
} DSCCOMMANDLINEPARAMS;

typedef enum
{
  NonNT4,
#ifdef MERRILL_LYNCH
  NT4SP1toSP3,
  NT4SP4toSP5,
#else
  NT4preSP6,
#endif
  NT4SP6
} RETOSVERSION;

typedef enum
{
  PreIE4,
  IE4
} RETIEVERSION;

DSCCOMMANDLINEPARAMS ParseCmdline(LPSTR lpCmdLine);
RETIEVERSION CheckIEVersion();
RETOSVERSION CheckOSVersion();
BOOL CheckAdministrator(HINSTANCE);
BOOL RunADSIOnlySetup(HINSTANCE);

INT  LaunchDscsetup(HINSTANCE hInstance, LPCSTR lpCmdLine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsutil2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsUtil2.h
//
//  Contents:  Utility functions callable by the parser
//
//  History:   28-Apr-2001 JonN     Created
//             
//
//--------------------------------------------------------------------------

#ifndef _DSUTIL2_H_
#define _DSUTIL2_H_

//+--------------------------------------------------------------------------
//
//  Class:      GetEscapedElement
//
//  Purpose:    Calls IADsPathname::GetEscapedElement.  Uses LocalAlloc.
//
//  History:    28-Apr-2001 JonN     Created
//
//---------------------------------------------------------------------------

HRESULT GetEscapedElement( OUT PWSTR* ppszOut, IN PCWSTR pszIn );

#endif //_DSUTIL2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\commonstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      commonstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   27-Aug-2001    JonN     Split from individual commands
//
//--------------------------------------------------------------------------

//
// Common switches
//
PCWSTR c_sz_arg1_com_debug          = L"debug";
PCWSTR c_sz_arg1_com_help           = L"h";
PCWSTR c_sz_arg2_com_help           = L"?";
PCWSTR c_sz_arg1_com_server         = L"s";
PCWSTR c_sz_arg2_com_server         = L"server";
PCWSTR c_sz_arg1_com_domain         = L"d";
PCWSTR c_sz_arg2_com_domain         = L"domain";
PCWSTR c_sz_arg1_com_username       = L"u";
PCWSTR c_sz_arg2_com_username       = L"username";
PCWSTR c_sz_arg1_com_password       = L"p";
PCWSTR c_sz_arg2_com_password       = L"password";
PCWSTR c_sz_arg1_com_quiet          = L"q";
PCWSTR c_sz_arg1_com_continue       = L"C";
PCWSTR c_sz_arg1_com_description    = L"desc";
PCWSTR c_sz_arg1_com_objecttype     = L"objecttype";
PCWSTR c_sz_arg1_com_objectDN       = L"Target object for this command";

// Unicode switches
PCWSTR c_sz_arg1_com_unicode        = L"uc";
PCWSTR c_sz_arg1_com_unicodeinput   = L"uci";
PCWSTR c_sz_arg1_com_unicodeoutput  = L"uco";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsclientnt4\setup\setup\setup.c ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup				
//
//  Purpose:	Check OS and IE version, and launch dscsetup 
//				to installs the Windows NT 4.0 DS Client Files			
//
//  File:		Setup.c
//
//  History:	Aug 1998	Zeyong Xu	Created
//            Jan 2000  Jeff Jones (JeffJon) Modified
//                      - Changes made to make it into an NT4 setup
//																	
//------------------------------------------------------------------


#include <windows.h>
#include <tchar.h>
#include "resource.h"
#include "setup.h"

DSCCOMMANDLINEPARAMS ParseCmdline(LPSTR lpCmdLine)
{
  DSCCOMMANDLINEPARAMS retCommandParams = FullInstall;
  BOOL bQuietMode = FALSE;
  BOOL bWabinst   = TRUE;
  BOOL bSystem    = TRUE;

  PCTSTR ptszTok = _tcstok(lpCmdLine, _T(" "));
  do
  {
    if (ptszTok != NULL)
    {
      if (_tcsicmp(ptszTok, _T("/q")) == 0)
      {
        bQuietMode = TRUE;
      }

      if (_tcsicmp(ptszTok, _T("/a")) == 0)
      {
        bWabinst = FALSE;
        bSystem  = FALSE;
      }

      if (_tcsicmp(ptszTok, _T("/d")) == 0)
      {
        bWabinst = FALSE;
      }
    }
    ptszTok = _tcstok(NULL, _T("  "));
  } while (ptszTok != NULL);

  if (bQuietMode)
  {
    if (bWabinst && bSystem)
    {
      retCommandParams = FullInstallQuiet;
    }
    else if (bSystem && !bWabinst)
    {
      retCommandParams = WablessQuiet;
    }
    else
    {
      retCommandParams = ADSIOnlyQuiet;
    }
  }
  else
  {
    if (bWabinst && bSystem)
    {
      retCommandParams = FullInstall;
    }
    else if (bSystem && !bWabinst)
    {
      retCommandParams = Wabless;
    }
    else
    {
      retCommandParams = ADSIOnly;
    }
  }
  return retCommandParams;
}

// winmain
INT WINAPI WinMain(HINSTANCE hInstance, 
				   HINSTANCE hPrevInstance, 
				   LPSTR lpCmdLine, 
				   INT nCmdShow)
{
  //
  // Parse the commandline for later use
  //
  DSCCOMMANDLINEPARAMS commandParams = ParseCmdline(lpCmdLine);

  // check OS version
  RETOSVERSION retOSVersion = CheckOSVersion();

  TCHAR  szMessage[MAX_MESSAGE + 1];
	TCHAR  szTitle[MAX_TITLE + 1];

  LoadString(hInstance, 
           IDS_ERROR_TITLE, 
           szTitle, 
           MAX_TITLE);

  //
  // Here is the matrix we are shooting for.
  //  A   = ADSI only
  //  D   = System files only
  //  ALL = Wabinst, ADSI, and system files
  //
  //--------------------------------------------
  //                | < IE4      | >= IE4      |
  //----------------+------------+--------------
  //        Other   |    X     	 |    X        |
  //----------------+------------+--------------
  //      < SP6a    |    A       |    A        |
  //----------------+------------+--------------
  //       >=SP6a   |    A       |   A,D, ALL  |
  //--------------------------------------------

  //
  // if we are building the Merrill Lynch version
  // (MERRILL_LYNCH will be defined) we have to 
  // add the following line to the matrix above
  //
  //--------------------------------------------
  //  NO SP to SP3  |    A       |    A        |
  //----------------+------------+--------------
  //  SP4 to > SP6a |   special installed bits |
  //--------------------------------------------
  //

  if (retOSVersion == NonNT4)
  {
		// if not NT4, display error message
		LoadString(hInstance,
               IDS_ERROR_OS_MESSAGE,
               szMessage, 
               MAX_MESSAGE);

    MessageBox(NULL,	// handle of owner window
				szMessage,	// address of text in message box
				szTitle,	// address of title of message box  
				MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box

    return SETUP_ERROR;
  }
#ifdef MERRILL_LYNCH
  else if (retOSVersion == NT4SP1toSP3)
#else
  else if (retOSVersion == NT4preSP6)
#endif
  {
    if (commandParams == ADSIOnly ||
        commandParams == ADSIOnlyQuiet)
    {
      //
      // Check to be sure the user in the Administrators group
      // We have to be able to copy over system files
      //
      if (!CheckAdministrator(hInstance))
      {
        return SETUP_CANCEL;
      }

      return RunADSIOnlySetup(hInstance);
    }
    else
    {
		  LoadString(hInstance,
                 IDS_ERROR_OS_MESSAGE,
                 szMessage, 
                 MAX_MESSAGE);

      MessageBox(NULL,	// handle of owner window
				  szMessage,	// address of text in message box
				  szTitle,	// address of title of message box  
				  MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
      return SETUP_ERROR;
    }
  }
  else  // NT4 SP6a or greater
  {
    RETIEVERSION retIEVersion = CheckIEVersion();
    if (retIEVersion == PreIE4)
    {
      if (commandParams == ADSIOnly ||
          commandParams == ADSIOnlyQuiet)
      {
        //
        // Check to be sure the user in the Administrators group
        // We have to be able to copy over system files
        //
        if (!CheckAdministrator(hInstance))
        {
          return SETUP_CANCEL;
        }

        return RunADSIOnlySetup(hInstance);
      }
      else
      {
		    LoadString(hInstance,
                   IDS_ERROR_IE_MESSAGE,
                   szMessage, 
                   MAX_MESSAGE);

        MessageBox(NULL,	// handle of owner window
				    szMessage,	// address of text in message box
				    szTitle,	// address of title of message box  
				    MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
        return SETUP_ERROR;
      }
    }
  }
  //
  // Check to be sure the user in the Administrators group
  // We have to be able to copy over system files
  //
  if (!CheckAdministrator(hInstance))
  {
    return SETUP_CANCEL;
  }


	return LaunchDscsetup(hInstance,lpCmdLine);
}


// check for IE 4.0 or later version
RETIEVERSION CheckIEVersion()
{
	HKEY		hSubKey;
	DWORD		dwType;
	ULONG		nLen;
	TCHAR		szValue[MAX_TITLE];
  RETIEVERSION retIEVersion = PreIE4;

	// check if IE 4.0 has been installed
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
									  STR_IE_REGKEY, 
									  0, 
									  KEY_READ, 
									  &hSubKey)		)
	{
		nLen = MAX_PATH;
		if (ERROR_SUCCESS == RegQueryValueEx(hSubKey, 
											 STR_VERSION, 
											 NULL, 
											 &dwType, 
											 (LPBYTE) szValue, &nLen)	)
		{
			if((nLen > 0) && (dwType == REG_SZ))
				retIEVersion = (_tcscmp(szValue,STR_IE_VERSION) >= 0) ? IE4 : PreIE4;  // IE 4.0 or later was installed
		}
		RegCloseKey(hSubKey);
	}
	
	return retIEVersion;
}

// check for NT4 Version
RETOSVERSION CheckOSVersion()
{
  RETOSVERSION retOSVersion = NT4SP6;
  BOOL   bGetInfoSucceeded = TRUE;
  OSVERSIONINFOEX  osvi;
  ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

  // get os verion info
  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  if (!GetVersionEx((OSVERSIONINFO*)&osvi))
  {
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bGetInfoSucceeded = GetVersionEx((OSVERSIONINFO*)&osvi);
  }
  else
  {
    bGetInfoSucceeded = TRUE;
  }

  if(bGetInfoSucceeded &&
     osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
     osvi.dwMajorVersion == 4 &&
     osvi.dwOSVersionInfoSize >= sizeof(OSVERSIONINFOEX) &&
     osvi.wServicePackMajor >= 6)  // NT4 SP6
  {
    retOSVersion = NT4SP6;
  }
  else if (bGetInfoSucceeded &&
           osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
           osvi.dwMajorVersion == 4 &&
#ifdef MERRILL_LYNCH
           (osvi.wServicePackMajor >= 4 && osvi.wServicePackMajor < 6))
  {
    retOSVersion = NT4SP4toSP5;
  }
  else if (bGetInfoSucceeded &&
           osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
           osvi.dwMajorVersion == 4 &&
           osvi.wServicePackMajor < 4)
  {
    retOSVersion = NT4SP1toSP3;
#else           
           osvi.dwOSVersionInfoSize == sizeof(OSVERSIONINFO))
  {
    retOSVersion = NT4preSP6;
#endif
  }
  else
  {
    retOSVersion = NonNT4;
  }


  return retOSVersion;
}

//
// check for Administrators group
//
BOOL CheckAdministrator(HINSTANCE hInstance)
{
	BOOL   bReturn = TRUE;
	TCHAR  szMessage[MAX_MESSAGE + 1];
	TCHAR  szTitle[MAX_TITLE + 1];

  do   // false loop
  {
    HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token
    BYTE                      bufTokenGroups[10000]; // token group information
    DWORD                     lenTokenGroups;        // returned length of token group information
    SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                      psidAdministrators;
    PTOKEN_GROUPS             ptgGroups = (PTOKEN_GROUPS) bufTokenGroups;
    DWORD                     iGroup;       // group number index

    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hToken ) )
    {
      bReturn = FALSE;
      break;
    }

    if (!GetTokenInformation( hToken, TokenGroups, bufTokenGroups, sizeof bufTokenGroups, &lenTokenGroups ) )
    {
      bReturn = FALSE;
      break;
    }

    // REVIEWED-2002/03/12-JeffJon-This is valid SID usage
    // for this dangerous API call

    if ( AllocateAndInitializeSid(
        &siaNtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &psidAdministrators ) )
    {
      bReturn = FALSE;

      for ( iGroup = 0; iGroup < ptgGroups->GroupCount; iGroup++ )
      {
         // REVIEWED-2002/03/12-JeffJon-The admin SID is from a trusted source
         // and neither SID is hardcoded

         if ( EqualSid( psidAdministrators, ptgGroups->Groups[iGroup].Sid ) )
         {
            bReturn = TRUE;
            break;
         }
      }

      FreeSid( psidAdministrators );
    }
    else
    {
      bReturn = FALSE;
      break;
    }

    if ( hToken != INVALID_HANDLE_VALUE )
    {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
    }

  } while (FALSE);

  if(!bReturn)
  {
	  LoadString(hInstance, IDS_ERROR_ADMINISTRATOR_MESSAGE, szMessage, MAX_MESSAGE);
   	LoadString(hInstance, IDS_ERROR_TITLE, szTitle, MAX_TITLE);

      MessageBox(NULL,	// handle of owner window
				szMessage,	// address of text in message box
				szTitle,	// address of title of message box  
				MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
	}
		
	return bReturn;
}

//
// Launches a process with the given commandline and
// waits for it to finish.
//
BOOL LaunchProcess(LPTSTR lpCommandLine)
{
	BOOL bResult = FALSE;

	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;

	// its console window will be invisible to the user.
	ZeroMemory(&pi,sizeof(PROCESS_INFORMATION));
	ZeroMemory(&si,sizeof(STARTUPINFO));
	si.cb			= sizeof (STARTUPINFO);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;            // HideWindow

   // ISSUE-2002/03/12-JeffJon-Should call CreateProcess with
   // the full path to the exe

   if(CreateProcess(	NULL,					
						lpCommandLine,			
						NULL,					
						NULL,					
						FALSE,				
						0,					
						NULL,				
						NULL,				
						&si,                
						&pi ) )             
	{
		// wait to finish the runing setup process
		WaitForSingleObject(pi.hProcess,INFINITE);
	
		// close process handle
		if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hProcess) ;
		}
		if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hThread) ;
		}

		bResult = TRUE;
	}

	return bResult;
}

//
// Run the setup for ADSI only
//
int RunADSIOnlySetup(HINSTANCE hInstance)
{
  int iReturn = SETUP_SUCCESS;
  if (!LaunchProcess(STR_INSTALL_ADSI))
  {
    iReturn = SETUP_ERROR;
  }
  return iReturn;
}

// launch Inf file to install this component
INT LaunchDscsetup(HINSTANCE hInstance, LPCSTR lpCmdLine)
{
	INT     nResult = SETUP_ERROR;
	TCHAR	szMessage[MAX_MESSAGE + 1]; 
	TCHAR	szTitle[MAX_TITLE + 1]; 

	FPDODSCSETUP fpDoDscSetup;

   // ISSUE-2002/03/12-JeffJon-Should call LoadLibrary with
   // the full path to the library since we are running on NT4
   HINSTANCE  hInst = LoadLibrary(STR_DSCSETUP_DLL);

	if(hInst) 
	{
		fpDoDscSetup = (FPDODSCSETUP) GetProcAddress(hInst, STR_DODSCSETUP);

		if(fpDoDscSetup)
		{
			// Do dscsetup
			nResult = fpDoDscSetup(lpCmdLine);
		}
    else
    {
      LoadString(hInstance, IDS_ERROR_DLLENTRY, szMessage, MAX_MESSAGE);
      LoadString(hInstance, IDS_ERROR_TITLE, szTitle, MAX_TITLE);

        // display a error message - can't find dscsetup.exe
      MessageBox(NULL,	// handle of owner window
		      szMessage,	// address of text in message box
	        szTitle,	// address of title of message box  
		      MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box

    }

 		FreeLibrary( hInst );
	}
  else
	{
		LoadString(hInstance, IDS_ERROR_LOAD_DSCSETUPDLL, szMessage, MAX_MESSAGE);
		LoadString(hInstance, IDS_ERROR_TITLE, szTitle, MAX_TITLE);

        // display a error message - can't find dscsetup.exe
		MessageBox(NULL,	// handle of owner window
					szMessage,	// address of text in message box
					szTitle,	// address of title of message box  
					MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
	}

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsUtil.cpp
//
//  Contents:  Utility functions for working with Active Directory
//
//  History:   06-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "dsutil.h"
#include "dsutil2.h" // GetEscapedElement
#include "dsutilrc.h"
#include "cstrings.h"
#include "secutil.h"

#include <accctrl.h>       // OBJECTS_AND_SID
#include <aclapi.h>        // GetNamedSecurityInfo etc.
#include <ADsOpenFlags.h>  // GetADsOpenObjectFlags
#include <lmaccess.h>      // UF_*  userAccountControl bits
#include <ntsam.h>         // GROUP_TYPE_*
#include <Dsgetdc.h>
#include <lmapibuf.h>

// Internal use only helper functions 
BOOL TranslateNameXForest(LPCWSTR szDomain, LPCWSTR lpAccountName, 
                          DS_NAME_FORMAT AccountNameFormat, 
                          DS_NAME_FORMAT DesiredNameFormat,
                          LPWSTR *lpTranslatedName);

HRESULT IsBSTRInVariantArray(VARIANT& refvar, CComBSTR& strSearch, 
                             bool& bFound);

HRESULT ValidatePartition(CDSCmdBasePathsInfo& basePathsInfo, 
                          LPCWSTR pszObjectDN);

HRESULT GetAttrFromDN(PCWSTR pszDN,PWSTR pszAttribute,
                     const CDSCmdBasePathsInfo& refBasePathsInfo,
                     const CDSCmdCredentialObject& refCredentialObject,
                     PADS_ATTR_INFO* ppAttrInfo);

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::CDSCmdCredentialObject
//
//  Synopsis:   Constructor for the credential management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdCredentialObject::CDSCmdCredentialObject()
   : m_bUsingCredentials(false)
{
    ZeroMemory(&m_EncryptedPasswordDataBlob,sizeof(DATA_BLOB));
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::~CDSCmdCredentialObject
//
//  Synopsis:   Destructor for the credential management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdCredentialObject::~CDSCmdCredentialObject()
{
   if (m_EncryptedPasswordDataBlob.pbData)
   {
        LocalFree(m_EncryptedPasswordDataBlob.pbData);
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::SetUsername
//
//  Synopsis:   Encodes the passed in string and sets the m_pszPassword
//              member data.
//
//  Arguments:  [pszPassword] : unencoded password
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                                      for the new password
//                        E_POINTER if the string passed in is not valid
//                        S_OK if we succeeded in setting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdCredentialObject::SetUsername(PCWSTR pszUsername)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::SetUsername, hr);

   do // false loop
   {
      //
      // Verify the input parameters
      //
      if (!pszUsername)
      {
         hr = E_POINTER;
         break;
      }

      //
      // Copy the new username
      //
      m_sbstrUsername = pszUsername;
      DEBUG_OUTPUT(FULL_LOGGING, L"Username = %s", pszUsername);
   } while (false);

   return hr;
}

//
// A prime number used to seed the encoding and decoding
//
#define NW_ENCODE_SEED3  0x83


//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::SetPassword
//
//  Synopsis:   Encodes the passed in string and sets the m_pszPassword
//              member data.
//
//  Arguments:  [pszPassword] : unencoded password
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                                      for the new password
//                        S_OK if we succeeded in setting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdCredentialObject::SetPassword(PCWSTR pszPassword)
{

	//Security Review:Rewrite this function as per
	//NTRAID#NTBUG9-571570-2000/11/13-hiteshr
	//Use CryptProtectMemory and SecureZeroMemory

   ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::SetPassword, hr);

	if(!pszPassword)
	{
		return E_POINTER;
	}
	//
    // Free the previously allocated password if there was one
    //
	if (m_EncryptedPasswordDataBlob.pbData) 
	{
        LocalFree(m_EncryptedPasswordDataBlob.pbData);
        ZeroMemory(&m_EncryptedPasswordDataBlob,sizeof(DATA_BLOB));
	}

	hr = EncryptPasswordString(pszPassword,&m_EncryptedPasswordDataBlob);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::SetEncryptedPassword
//
//  Synopsis:   Assign
//
//  Arguments:  [pszPassword] : unencoded password
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                                      for the new password
//                        S_OK if we succeeded in setting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT  CDSCmdCredentialObject::SetEncryptedPassword(DATA_BLOB* pEncryptedPasswordDataBlob)
{

	//Security Review:Rewrite this function as per
	//NTRAID#NTBUG9-571570-2000/11/13-hiteshr
	//Use CryptProtectMemory and SecureZeroMemory

    ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::SetEncryptedPassword, hr);
	if(!pEncryptedPasswordDataBlob)
	{
		return E_POINTER;
	}
	
	//
   // Free the previously allocated password if there was one
   //
	if (m_EncryptedPasswordDataBlob.pbData) 
	{
        LocalFree(m_EncryptedPasswordDataBlob.pbData);
        ZeroMemory(&m_EncryptedPasswordDataBlob,sizeof(DATA_BLOB));
	}

    //Do a deep copy
	m_EncryptedPasswordDataBlob.pbData = (BYTE *)LocalAlloc(LPTR,pEncryptedPasswordDataBlob->cbData);
    if(!m_EncryptedPasswordDataBlob.pbData)
    {
        return E_OUTOFMEMORY;
    }

    m_EncryptedPasswordDataBlob.cbData = pEncryptedPasswordDataBlob->cbData;
    CopyMemory(m_EncryptedPasswordDataBlob.pbData,
               pEncryptedPasswordDataBlob->pbData,
               pEncryptedPasswordDataBlob->cbData);

   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::GetPassword
//
//  Synopsis:   Unencodes the password member and returns a string in the
//              provided buffer with the clear text password.
//
//  Arguments:  [ppszBuffer - IN]   : Gets Cleartext password. Call 
//					 SecureZeroMemory on it when its nolonger required
//
//  Returns:    HRESULT : E_INVALIDARG if the buffer is not valid
//                        E_OUTOFMEMORY if the buffer is too small
//                        E_FAIL if the password has not been set
//                        S_OK if we succeeded in getting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT CDSCmdCredentialObject::GetPassword(PWSTR *ppszBuffer) const
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::GetPassword, hr);

	if (!ppszBuffer) 
	{
		ASSERT(ppszBuffer);
		return E_INVALIDARG;
	}

	//
	// Verify there is a password to retrieve
	//
	if (!m_EncryptedPasswordDataBlob.pbData) 
	{
		DEBUG_OUTPUT(FULL_LOGGING, L"No password has been set");
		return E_FAIL;
	}

	//UnEncode the password
	return DecryptPasswordString(&m_EncryptedPasswordDataBlob,ppszBuffer);
}

////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::CDSCmdBasePathsInfo
//
//  Synopsis:   Constructor for the base paths management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdBasePathsInfo::CDSCmdBasePathsInfo()
   : m_bInitialized(false),
     m_bModeInitialized(false),
     m_bDomainMode(true)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::~CDSCmdBasePathsInfo
//
//  Synopsis:   Destructor for the base paths management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdBasePathsInfo::~CDSCmdBasePathsInfo()
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::InitializeFromName
//
//  Synopsis:   Initializes all the member strings for the well known
//              naming contexts by connecting to the RootDSE of the server or
//              domain that is passed in.
//
//  Arguments:  [refCredentialObject - IN] : a reference to the credential manager
//              [pszServerOrDomain - IN] : a NULL terminated wide character string
//                                         that contains the name of the domain or
//                                         server to connect to
//              [bServerName - IN]       : Specifies whether the name given by 
//                                         pszServerOrDomain is a server name (true)
//                                         or a domain name (false)
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_OUTOFMEMORY if an allocation for one of the strings
//                                      failed
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdBasePathsInfo::InitializeFromName(const CDSCmdCredentialObject& refCredentialObject,
                                                PCWSTR pszServerOrDomain,
                                                bool bServerName)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CDSCmdBasePathsInfo::InitializeFromName, hr);

   do // false loop
   {
      //
      // Check to see if we are already initialized
      //
      if (IsInitialized())
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Base paths info already initialized");
         break;
      }
   
      //
      // Create the path to the RootDSE
      //
      CComBSTR sbstrRootDSE;
      sbstrRootDSE = g_bstrLDAPProvider;
   
      if (pszServerOrDomain)
      {
         sbstrRootDSE += pszServerOrDomain;
         sbstrRootDSE += L"/";
      }
      sbstrRootDSE += g_bstrRootDSE;

      //
      // Now sbstrRootDSE should either be in the form "LDAP://<serverOrDomain>/RootDSE"
      // or "LDAP://RootDSE"
      //

      //
      // Bind to the RootDSE
      //
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrRootDSE,
                           IID_IADs,
                           (void**)&m_spRootDSE,
                           false);
      if (FAILED(hr))
      {
         break;
      }

      if (bServerName)
      {
         m_sbstrServerName = pszServerOrDomain;
      }
      else
      {
         //
         // Get the configuration naming context
         //
         CComVariant var;
         hr = m_spRootDSE->Get(g_bstrConfigNCProperty, &var);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to get the Configuration Naming Context: hr = 0x%x", hr);
            break;
         }
         if (var.vt != VT_BSTR)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"The variant returned from Get(Config) isn't a VT_BSTR!");
            hr = E_FAIL;
            break;
         }
         m_sbstrConfigNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"ConfigNC = %s", m_sbstrConfigNamingContext);

         //
         // Get the server name that we are connected to
         //

         //
         // Create the path to the config naming context
         //
         CComBSTR sbstrConfigPath;
         sbstrConfigPath = g_bstrLDAPProvider;
         if (pszServerOrDomain)
         {
            sbstrConfigPath += pszServerOrDomain;
            sbstrConfigPath += L"/";
         }
         sbstrConfigPath += m_sbstrConfigNamingContext;

         //
         // Bind to the configuration container
         //
         CComPtr<IADsObjectOptions> spIADsObjectOptions;
         hr = DSCmdOpenObject(refCredentialObject,
                              sbstrConfigPath,
                              IID_IADsObjectOptions, 
                              (void**)&spIADsObjectOptions,
                              false);
         if (FAILED(hr))
         {
            break;
         }

         //
         // Retrieve the server name
         //
         var.Clear();
         hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to get the server name: hr = 0x%x", hr);
            break;
         }

         if (var.vt != VT_BSTR)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"The variant returned from GetOption isn't a VT_BSTR!");
            hr = E_FAIL;
            break;
         }

         //
         // Store the server name
         //
         m_sbstrServerName = V_BSTR(&var);
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Server name = %s", m_sbstrServerName);
      }

      //
      // Create the provider plus server name string
      //
      m_sbstrProviderAndServerName = g_bstrLDAPProvider;
      m_sbstrProviderAndServerName += m_sbstrServerName;

      m_sbstrGCProvider = g_bstrGCProvider;

      // Derived by looking at code from \admin\dsadminlib\src\basePathsInfo.cpp
      ComposePathFromDN(L"Schema", m_sbstrAbstractSchemaPath);

      m_bInitialized = true;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetConfigurationNamingContext
//
//  Synopsis:   Returns the the DN of the Configuration container
//
//  Arguments:  
//
//  Returns:    CComBSTR : A copy of the CComBSTR containing the string
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CComBSTR  CDSCmdBasePathsInfo::GetConfigurationNamingContext() const
{ 
   ENTER_FUNCTION(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetConfigurationNamingContext);
   if (IsInitialized() &&
       !m_sbstrConfigNamingContext.Length())
   {
      //
      // Get the configuration naming context
      //
      CComVariant var;
      HRESULT hr = m_spRootDSE->Get(g_bstrConfigNCProperty, &var);
      if (SUCCEEDED(hr) &&
          var.vt == VT_BSTR)
      {
         m_sbstrConfigNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"ConfigNC = %s", m_sbstrConfigNamingContext);
      }
      else
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to retrieve the ConfigNC: hr = 0x%x", hr);
      }
   }
   return m_sbstrConfigNamingContext; 
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetSchemaNamingContext
//
//  Synopsis:   Returns the the DN of the Schema container
//
//  Arguments:  
//
//  Returns:    CComBSTR : A copy of the CComBSTR containing the string
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CComBSTR  CDSCmdBasePathsInfo::GetSchemaNamingContext() const    
{ 
   ENTER_FUNCTION(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetSchemaNamingContext);
   if (IsInitialized() &&
       !m_sbstrSchemaNamingContext.Length())
   {
      //
      // Get the schema naming context
      //
      CComVariant var;
      HRESULT hr = m_spRootDSE->Get(g_bstrSchemaNCProperty, &var);
      if (SUCCEEDED(hr) &&
          var.vt == VT_BSTR)
      {
         m_sbstrSchemaNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"SchemaNC = %s", m_sbstrConfigNamingContext);
      }
      else
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to retrieve the SchemaNC: hr = 0x%x", hr);
      }
   }
   return m_sbstrSchemaNamingContext; 
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetDefaultNamingContext
//
//  Synopsis:   Returns the the DN of the Domain
//
//  Arguments:  
//
//  Returns:    CComBSTR : A copy of the CComBSTR containing the string
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CComBSTR  CDSCmdBasePathsInfo::GetDefaultNamingContext() const    
{ 
   ENTER_FUNCTION(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetDefaultNamingContext);
   if (IsInitialized() &&
       !m_sbstrDefaultNamingContext.Length())
   {
      //
      // Get the schema naming context
      //
      CComVariant var;
      HRESULT hr = m_spRootDSE->Get(g_bstrDefaultNCProperty, &var);
      if (SUCCEEDED(hr) &&
          var.vt == VT_BSTR)
      {
         m_sbstrDefaultNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"DefaultNC = %s", m_sbstrDefaultNamingContext);
      }
      else
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to retrieve the DefaultNC: hr = 0x%x", hr);
      }
   }
   return m_sbstrDefaultNamingContext; 
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetDomainMode
//
//  Synopsis:   Figures out if the domain is in mixed or native mode
//
//  Arguments:  [refCredObject - IN] : reference to the credential manager
//              [bMixedMode - OUT]   : Is the domain in mixed mode?
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI error
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdBasePathsInfo::GetDomainMode(const CDSCmdCredentialObject& refCredObject,
                                           bool& bMixedMode) const    
{ 
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetDomainMode, hr);

   hr = S_OK;

   do // false loop
   {
      if (!m_bModeInitialized)
      {
         //
         // Get the path to the domainDNS node
         //
         CComBSTR sbstrDomainDN;
         sbstrDomainDN = GetDefaultNamingContext();

         CComBSTR sbstrDomainPath;
         ComposePathFromDN(sbstrDomainDN, sbstrDomainPath);

         //
         // Open the domainDNS node
         //
         CComPtr<IADs> spADs;
         hr = DSCmdOpenObject(refCredObject,
                              sbstrDomainPath,
                              IID_IADs,
                              (void**)&spADs,
                              true);
         if (FAILED(hr))
         {
            break;
         }

         CComVariant var;
         hr = spADs->Get(CComBSTR(L"nTMixedDomain"), &var);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Failed to retrieve the domain mode: hr = 0x%x",
                         hr);
            break;
         }

         if (var.vt == VT_I4)
         {
            m_bDomainMode = (var.lVal != 0);
            m_bModeInitialized = true;
         }
         else
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Variant not an VT_I4!");
            m_bDomainMode = true;
            m_bModeInitialized = true;
         }
      }

      bMixedMode = m_bDomainMode;
   } while (false);

   return hr; 
}


//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::ComposePathFromDN
//
//  Synopsis:   Appends the DN to the provider and server name
//
//  Arguments:  [pszDN - IN]    : pointer to a NULL terminated wide character string
//                                that contains the DN of the object to make the ADSI
//                                path to
//              [refsbstrPath - OUT] : reference to a CComBSTR that will take
//                                     the full ADSI path 
//              [nProviderType - OPTIONAL IN] : Option to specify which provider
//                                              to compose the path with
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDSCmdBasePathsInfo::ComposePathFromDN(PCWSTR pszDN, 
                                            CComBSTR& refsbstrPath,
                                            DSCMD_PROVIDER_TYPE nProviderType) const
{
   refsbstrPath.Empty();

   switch (nProviderType)
   {
   case DSCMD_LDAP_PROVIDER :
      refsbstrPath = GetProviderAndServerName();
      break;

   case DSCMD_GC_PROVIDER :
      refsbstrPath = GetGCProvider();
      break;

   default :
      ASSERT(FALSE);
      break;
   }

   refsbstrPath += L"/";
   refsbstrPath += pszDN;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::CPathCracker
//
//  Synopsis:   Constructor for the path cracker IADsPathname wrapper
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CPathCracker::CPathCracker()
{
   m_hrCreate = Init();
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::Init
//
//  Synopsis:   Called by the constructor to create the IADsPathname object
//              and store it in the m_spIADsPathname member
//
//  Arguments:  
//
//  Returns:    HRESULT : the value returned from the CoCreateInstance
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::Init()
{
   //Secuirty Review:Context is inproc, this is fine.
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER,
                                   IID_IADsPathname, 
                                   (void**)&(m_spIADsPathname));
   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetParentDN
//
//  Synopsis:   Simply removes the leaf part of the DN
//
//  Arguments:  [pszDN - IN] : pointer to a NULL terminated wide string that
//                             contains the DN of the child
//              [refsbstrDN - OUT] : reference to a CComBSTR that is to 
//                                   receive the parent DN.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetParentDN(PCWSTR pszDN,
                                  CComBSTR& refsbstrDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetParentDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszDN, ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.RemoveLeafElement();
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &refsbstrDN);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetObjectRDNFromDN
//
//  Synopsis:   Returns the leaf part of the DN
//
//  Arguments:  [pszDN - IN] : pointer to a NULL terminated wide string that
//                             contains the DN of the child
//              [refsbstrRDN - OUT] : reference to a CComBSTR that is to 
//                             receive the leaf RDN.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    25-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetObjectRDNFromDN(PCWSTR pszDN,
                                         CComBSTR& refsbstrRDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetObjectRDNFromDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrRDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszDN, ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &refsbstrRDN);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetObjectNameFromDN
//
//  Synopsis:   Returns the value of the leaf part of the DN
//
//  Arguments:  [pszDN - IN] : pointer to a NULL terminated wide string that
//                             contains the DN of the child
//              [refsbstrRDN - OUT] : reference to a CComBSTR that is to 
//                             receive the leaf Name.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetObjectNameFromDN(PCWSTR pszDN,
                                          CComBSTR& refsbstrRDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetObjectNameFromDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrRDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszDN, ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &refsbstrRDN);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetDNFromPath
//
//  Synopsis:   Returns the DN when given and ADSI path
//
//  Arguments:  [pszPath - IN] : pointer to a NULL terminated wide string that
//                               contains the ADSI path of the object
//              [refsbstrDN - OUT] : reference to a CComBSTR that is to 
//                             receive the DN.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetDNFromPath(PCWSTR pszPath,
                                    CComBSTR& refsbstrDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetDNFromPath, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszPath)
      {
         ASSERT(pszPath);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszPath, ADS_SETTYPE_FULL);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &refsbstrDN);
   } while (false);

   return hr;
}

///////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   DSCmdOpenObject
//
//  Synopsis:   A wrapper around ADsOpenObject
//
//  Arguments:  [refCredentialObject - IN] : a reference to a credential management object
//              [pszPath - IN]           : a pointer to a NULL terminated wide character
//                                         string that contains the ADSI path of the
//                                         object to connect to
//              [refIID - IN]            : the interface ID of the interface to return
//              [ppObject - OUT]         : a pointer which is to receive the interface pointer
//              [bBindToServer - IN]     : true if the path contains a server name,
//                                         false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-Sep-2000   JeffJon   Created
//              01-Apr-2002   JeffJon   Added call to GetADsOpenObjectFlags to
//                                      retrieve the additional security flags
//                                      to pass to ADsOpenObject for signing/sealing.
//
//---------------------------------------------------------------------------
HRESULT DSCmdOpenObject(const CDSCmdCredentialObject& refCredentialObject,
                        PCWSTR pszPath,
                        REFIID refIID,
                        void** ppObject,
                        bool   bBindToServer)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, DSCmdOpenObject, hr);

   do // false loop
   {
      static DWORD additionalFlags = GetADsOpenObjectFlags();
      DWORD dwFlags = ADS_SECURE_AUTHENTICATION | additionalFlags;

      if (!pszPath ||
          !ppObject)
      {
         ASSERT(pszPath);
         ASSERT(ppObject);

         hr = E_INVALIDARG;
         break;
      }

      if (bBindToServer)
      {
         //
         // If we know we are connecting to a specific server and not domain in general
         // then pass the ADS_SERVER_BIND flag to save ADSI the trouble of figuring it out
         //
         dwFlags |= ADS_SERVER_BIND;
         DEBUG_OUTPUT(FULL_LOGGING, L"Using ADS_SERVER_BIND flag");
      }

      if (refCredentialObject.UsingCredentials())
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Using credentials");

         LPWSTR pszPasswordBuffer=NULL;
         hr = refCredentialObject.GetPassword(&pszPasswordBuffer);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(FULL_LOGGING, L"GetPassword failed: hr = 0x%x", hr);
            DEBUG_OUTPUT(FULL_LOGGING, L"Using NULL password.");
            pszPasswordBuffer = 0;
         }

         DEBUG_OUTPUT(FULL_LOGGING, L"Calling ADsOpenObject()");
         DEBUG_OUTPUT(FULL_LOGGING, L"  path = %s", pszPath);

         hr = ADsOpenObject((LPWSTR)pszPath,
                            refCredentialObject.GetUsername(),
                            pszPasswordBuffer,
                            dwFlags,
                            refIID,
                            ppObject);

         //
         // If we failed with E_INVALIDARG and we were using ADS_SERVER_BIND
         // try calling again without the ADS_SERVER_BIND flag.  W2K did not have
         // this flag available until SP1.
         //
         if (hr == E_INVALIDARG &&
             (dwFlags & ADS_SERVER_BIND))
         {
            DEBUG_OUTPUT(FULL_LOGGING, L"ADsOpenObject failed with E_INVALIDARG, trying again without ADS_SERVER_BIND");
            dwFlags &= ~ADS_SERVER_BIND;

            hr = ADsOpenObject((LPWSTR)pszPath,
                               refCredentialObject.GetUsername(),
                               pszPasswordBuffer,
                               dwFlags,
                               refIID,
                               ppObject);
         }

         //
         // Make sure to zero out the password after it is used
         //
			//Security Review:Change with SecureZeroMemory
			//NTRAID#NTBUG9-553640-2002/03/08-hiteshr
			if(pszPasswordBuffer)
			{
				SecureZeroMemory(pszPasswordBuffer, wcslen(pszPasswordBuffer+1)*sizeof(WCHAR)); 
				LocalFree(pszPasswordBuffer);
			}
      }
      else
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Calling ADsOpenObject()");
         DEBUG_OUTPUT(FULL_LOGGING, L"  path = %s", pszPath);

         hr = ADsOpenObject((LPWSTR)pszPath, 
                            NULL, 
                            NULL, 
                            dwFlags, 
                            refIID, 
                            ppObject);
         //
         // If we failed with E_INVALIDARG and we were using ADS_SERVER_BIND
         // try calling again without the ADS_SERVER_BIND flag.  W2K did not have
         // this flag available until SP1.
         //
         if (hr == E_INVALIDARG &&
             (dwFlags & ADS_SERVER_BIND))
         {
            DEBUG_OUTPUT(FULL_LOGGING, L"ADsOpenObject failed with E_INVALIDARG, trying again without ADS_SERVER_BIND");
            dwFlags &= ~ADS_SERVER_BIND;

            hr = ADsOpenObject((LPWSTR)pszPath,
                               NULL,
                               NULL,
                               dwFlags,
                               refIID,
                               ppObject);
         }
      }
      DEBUG_OUTPUT(FULL_LOGGING, L"ADsOpenObject() return hr = 0x%x", hr);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
// Function to be used in the attribute table for evaluating the command line
// strings
//---------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Function:   FillAttrInfoFromObjectEntry
//
//  Synopsis:   Fills the ADS_ATTR_INFO from the attribute table associated
//              with the object entry
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]     : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_OUTOFMEMORY if we failed to allocate space for the value
//                        E_FAIL if we failed to format the value properly
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT FillAttrInfoFromObjectEntry(PCWSTR /*pszDN*/,
                                    const CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    const PDSOBJECTTABLEENTRY pObjectEntry,
                                    const ARG_RECORD& argRecord,
                                    DWORD dwAttributeIdx,
                                    PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, FillAttrInfoFromObjectEntry, hr);

   do // false loop
   {
      //
      // Verify Parameters
      //
      if (!pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);

         hr = E_INVALIDARG;
         break;
      }

      switch (argRecord.fType)
      {
      case ARG_TYPE_INT :
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"argRecord.fType = ARG_TYPE_INT");
            *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

            (*ppAttr)->pADsValues = new ADSVALUE[1];
            if ((*ppAttr)->pADsValues)
            {
                (*ppAttr)->dwNumValues = 1;
                (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
                (*ppAttr)->pADsValues->Integer = argRecord.nValue;
                //
                // Set the attribute dirty
                //
                pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
            }
            break;

      case ARG_TYPE_STR :
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"argRecord.fType = ARG_TYPE_STR");

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

         if (argRecord.strValue && argRecord.strValue[0] != L'\0')
         {
            //
            // REVIEW_JEFFJON : this is being leaked!
            //
            (*ppAttr)->pADsValues = new ADSVALUE[1];
            if ((*ppAttr)->pADsValues)
            {
               (*ppAttr)->dwNumValues = 1;
               (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
               switch ((*ppAttr)->dwADsType)
               {
               case ADSTYPE_DN_STRING :
                  {
                     //
                     // Lets bind to be sure the object exists
                     //
                     CComBSTR sbstrObjPath;
                     refBasePathsInfo.ComposePathFromDN(argRecord.strValue, sbstrObjPath);

                     CComPtr<IADs> spIADs;
                     hr = DSCmdOpenObject(refCredentialObject,
                                          sbstrObjPath,
                                          IID_IADs,
                                          (void**)&spIADs,
                                          true);

                     if (FAILED(hr))
                     {
                        DEBUG_OUTPUT(LEVEL3_LOGGING, L"DN object doesn't exist. %s", argRecord.strValue);
                        break;
                     }

                     (*ppAttr)->pADsValues->DNString = argRecord.strValue;
                     DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_DN_STRING = %s", argRecord.strValue);
                  }
                  break;

               case ADSTYPE_CASE_EXACT_STRING :
                  (*ppAttr)->pADsValues->CaseExactString = argRecord.strValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_EXACT_STRING = %s", argRecord.strValue);
                  break;

               case ADSTYPE_CASE_IGNORE_STRING :
                  (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_IGNORE_STRING = %s", argRecord.strValue);
                  break;

               case ADSTYPE_PRINTABLE_STRING :
                  (*ppAttr)->pADsValues->PrintableString = argRecord.strValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_PRINTABLE_STRING = %s", argRecord.strValue);
                  break;

               default :
                  hr = E_INVALIDARG;
                  break;
               }
               //
               // Set the attribute dirty
               //
               pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
         
            }
            break;
         }
         else
         {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"No value present, changing control code to ADS_ATTR_CLEAR");
            //
            // Clear the attribute
            //
            (*ppAttr)->dwControlCode = ADS_ATTR_CLEAR;
            (*ppAttr)->dwNumValues = 0;

            //
            // Set the attribute dirty
            //
            pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
         }
         break;

      default:
         hr = E_INVALIDARG;
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ResetObjectPassword
//
//  Synopsis:   Resets the password on any object that supports the IADsUser interface
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pszNewPassword - IN] : pointer to the new password to set
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise its an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ResetObjectPassword(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            PCWSTR pszNewPassword)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ResetObjectPassword, hr);

   do // false loop
   {
      if (!pszDN ||
          !pszNewPassword)
      {
         ASSERT(pszDN);
         ASSERT(pszNewPassword);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADsUser interface to the user object
      //
      CComPtr<IADsUser> spUser;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADsUser,
                           (void**)&spUser,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      hr = spUser->SetPassword((BSTR)pszNewPassword);

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ResetUserPassword
//
//  Synopsis:   Resets the user's password
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_FAIL if we failed to format the value properly
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ResetUserPassword(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD /*dwAttributeIdx*/,
                          PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ResetUserPassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr ||
          argRecord.fType != ARG_TYPE_PASSWORD)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
         ASSERT(argRecord.fType == ARG_TYPE_PASSWORD);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Don't create a new index in the array of ADS_ATTR_INFO
      //
      *ppAttr = NULL;
      ASSERT(argRecord.bDefined && argRecord.encryptedDataBlob.pbData);
   
        //Security Review: argRecord.strValue is encrypted and needs to be
		//decrypted before it is passsed to ResetObjectPassword
		//NTRAID#NTBUG9-571544-2002/03/08-hiteshr
		//argRecord.strValue is encrypted password, decrypt it.
		LPWSTR pszDecryptedPassword = NULL;
		hr = DecryptPasswordString(&argRecord.encryptedDataBlob,&pszDecryptedPassword);
		if(FAILED(hr))
		{
			break;
		}

      hr = ResetObjectPassword(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pszDecryptedPassword);

		SecureZeroMemory(pszDecryptedPassword,(wcslen(pszDecryptedPassword)+1)*sizeof(WCHAR));
		LocalFree(pszDecryptedPassword);

      if (FAILED(hr))
      {
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             hr,
                             IDS_FAILED_SET_PASSWORD);
         hr = S_FALSE;
         break;
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   ResetComputerAccount
//
//  Synopsis:   Resets the computer account
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]     : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ResetComputerAccount(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD /*dwAttributeIdx*/,
                             PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ResetComputerAccount, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Don't create a new entry in the ADS_ATTR_INFO array
      //
      *ppAttr = NULL;

      ASSERT(argRecord.bDefined && argRecord.strValue);
   
      //
      // Retrieve the samAccountName from the computer object
      //
      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADsUser interface to the user object
      //
      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(CComBSTR(L"samAccountName"), &var);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(var.vt == VT_BSTR);

      //
      // The new password for the computer account is the first
      // 14 characters of the samAccountName minus the '$'.
      //
      WCHAR pszNewPassword[15];
	  //Security Review:This is fine.
      memset(pszNewPassword, 0, sizeof(WCHAR) * 15);

	  //Security Review:This is fine if var.bstrval will never exceed 14chars, if it
	  //does wcsncpy won't null terminate. I suggest replacing with appropriate strsafe api.
	  //NTRAID#NTBUG9-571780-2002/03/08-hiteshr
      wcsncpy(pszNewPassword, var.bstrVal, 14); //It is always null terminated. yanggao.
      PWSTR pszDollar = wcschr(pszNewPassword, L'$');
      if (pszDollar)
      {
         *pszDollar = L'\0';
      }

      hr = ResetObjectPassword(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pszNewPassword);
      if (FAILED(hr))
      {
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             hr,
                             IDS_FAILED_RESET_COMPUTER);
         hr = S_FALSE;
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadUserAccountControl
//
//  Synopsis:   Reads the userAccountControl attribute from the object specified
//              by the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [plBits - OUT]         : returns the currect userAccountControl bits
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadUserAccountControl(PCWSTR pszDN,
                               const CDSCmdBasePathsInfo& refBasePathsInfo,
                               const CDSCmdCredentialObject& refCredentialObject,
                               long* plBits)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReadUserAccountControl, hr);

   do // false loop
   {
      if (!pszDN ||
          !plBits)
      {
         ASSERT(pszDN);
         ASSERT(plBits);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADsUser interface to the user object
      //
      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(CComBSTR(L"userAccountControl"), &var);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(var.vt == VT_I4);

      *plBits = var.lVal;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   PasswordNotRequired
//
//  Synopsis:   Adds/removes the UF_PASSWD_NOTREQD bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    10-Aug-2001   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT PasswordNotRequired(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, PasswordNotRequired, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Reading user account control from object");
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Using existing userAccountControl from table.");
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (pObjectEntry->pAttributeTable[dwAttributeIdx]->nAttributeID != NULL &&
		  argRecord.bDefined && argRecord.bValue)
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding UF_PASSWD_NOTREQD to the userAccountControl");
         lUserAccountControl |= UF_PASSWD_NOTREQD;
      }
      else
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Removing UF_PASSWD_NOTREQD from the userAccountControl");
         lUserAccountControl &= ~UF_PASSWD_NOTREQD;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisableAccount
//
//  Synopsis:   Disables/Enables the account using the UF_ACCOUNTDISABLE bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT DisableAccount(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, DisableAccount, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Reading user account control from object");
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Using existing userAccountControl from table.");
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (pObjectEntry->pAttributeTable[dwAttributeIdx]->nAttributeID != NULL &&
		  argRecord.bDefined && argRecord.bValue)
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding UF_ACCOUNTDISABLE to the userAccountControl");
         lUserAccountControl |= UF_ACCOUNTDISABLE;
      }
      else
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Removing UF_ACCOUNTDISABLE from the userAccountControl");
         lUserAccountControl &= ~UF_ACCOUNTDISABLE;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetMustChangePwd
//
//  Synopsis:   Sets the pwdLastSet attribute 
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT SetMustChangePwd(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                         const CDSCmdCredentialObject& /*refCredentialObject*/,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetMustChangePwd, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // REVIEW_JEFFJON : this is being leaked!
      //
      (*ppAttr)->pADsValues = new ADSVALUE;
      if ((*ppAttr)->pADsValues)
      {
         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

         if (argRecord.bValue)
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0;
         }
         else
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0xffffffff;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0xffffffff;
         }
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   ChangeMustChangePwd
//
//  Synopsis:   Sets the pwdLastSet attribute 
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ChangeMustChangePwd(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ChangeMustChangePwd, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // We will assume they can change their password unless we discover otherwise
      //
      bool bCanChangePassword = true;
      hr = EvaluateCanChangePasswordAces(pszDN,
                                         refBasePathsInfo,
                                         refCredentialObject,
                                         bCanChangePassword);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"EvaluateCanChangePasswordAces failed: hr = 0x%x",
                      hr);
         ASSERT(false);
      }

      if (!bCanChangePassword && argRecord.bValue)
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"Cannot have must change password and cannot change password");
         DisplayErrorMessage(g_pszDSCommandName, pszDN, S_OK, IDS_MUSTCHPWD_CANCHPWD_CONFLICT);
         *ppAttr = NULL;
         hr = S_FALSE;
         break;
      }
      else
      {
         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
      }

      //
      // REVIEW_JEFFJON : this is being leaked!
      //
      (*ppAttr)->pADsValues = new ADSVALUE;
      if ((*ppAttr)->pADsValues)
      {
         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

         if (argRecord.bValue)
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0;
         }
         else
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0xffffffff;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0xffffffff;
         }
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   PwdNeverExpires
//
//  Synopsis:   Sets the UF_DONT_EXPIRE_PASSWD bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT PwdNeverExpires(PCWSTR pszDN,
                        const CDSCmdBasePathsInfo& refBasePathsInfo,
                        const CDSCmdCredentialObject& refCredentialObject,
                        const PDSOBJECTTABLEENTRY pObjectEntry,
                        const ARG_RECORD& argRecord,
                        DWORD dwAttributeIdx,
                        PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, PwdNeverExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (argRecord.bValue)
      {
         lUserAccountControl |= UF_DONT_EXPIRE_PASSWD;
      }
      else
      {
         lUserAccountControl &= ~UF_DONT_EXPIRE_PASSWD;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReversiblePwd
//
//  Synopsis:   Sets the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ReversiblePwd(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReversiblePwd, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (argRecord.bValue)
      {
         lUserAccountControl |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
      }
      else
      {
         lUserAccountControl &= ~UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   AccountExpires
//
//  Synopsis:   Sets in how many days the account will expire
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
const unsigned long DSCMD_FILETIMES_PER_MILLISECOND = 10000;
const DWORD DSCMD_FILETIMES_PER_SECOND = 1000 * DSCMD_FILETIMES_PER_MILLISECOND;
const DWORD DSCMD_FILETIMES_PER_MINUTE = 60 * DSCMD_FILETIMES_PER_SECOND;
const __int64 DSCMD_FILETIMES_PER_HOUR = 60 * (__int64)DSCMD_FILETIMES_PER_MINUTE;
const __int64 DSCMD_FILETIMES_PER_DAY  = 24 * DSCMD_FILETIMES_PER_HOUR;
const __int64 DSCMD_FILETIMES_PER_MONTH= 30 * DSCMD_FILETIMES_PER_DAY;

HRESULT AccountExpires(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                       const CDSCmdCredentialObject& /*refCredentialObject*/,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, AccountExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // REVIEW_JEFFJON : this is being leaked
      //
      (*ppAttr)->pADsValues = new ADSVALUE;
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
      (*ppAttr)->dwNumValues = 1;

      //
      // Note: the table entry for this attribute is ARG_TYPE_INTSTR but the parser
      // will change it to ARG_TYPE_INT if the value starts with digits.  If not then
      // the parser will change the type to ARG_TYPE_STR
      //
      if (argRecord.fType == ARG_TYPE_INT)
      {
         //
         // Get the system time and then add the number of days until the account expires
         //
         FILETIME currentFT = {0};
         ::GetSystemTimeAsFileTime(&currentFT);

         LARGE_INTEGER liExpires;
         liExpires.LowPart = currentFT.dwLowDateTime;
         liExpires.HighPart = currentFT.dwHighDateTime;

         //
         // If the value passed in is zero then add one to the day because it 
         // is really the start of the next day that the account gets
         // disabled
         //
         __int64 days = argRecord.nValue;
         if (argRecord.nValue == 0)
         {
            days = argRecord.nValue + 1;
         }

         __int64 nanosecs = days * DSCMD_FILETIMES_PER_DAY;
         (*ppAttr)->pADsValues->LargeInteger.QuadPart = liExpires.QuadPart + nanosecs;
      }
      else if (argRecord.fType == ARG_TYPE_STR)
      {
         CComBSTR sbstrStrValue = argRecord.strValue;
         sbstrStrValue.ToLower();

		 //Security Review:This is fine. Right string is fixed length.
         if (0 == _wcsicmp(sbstrStrValue, g_bstrNever))
         {
            //
            // Zero signifies that the account never expires
            //
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0;
         }
         else
         {
            hr = E_INVALIDARG;
            break;
         }
      }

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   EvaluateMustChangePassword
//
//  Synopsis:   Determines whether the user must change their password at next logon
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bMustChangePassword - OUT] : true if the user must change their
//                                            password at next logon, false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateMustChangePassword(PCWSTR pszDN,
                                   const CDSCmdBasePathsInfo& refBasePathsInfo,
                                   const CDSCmdCredentialObject& refCredentialObject,
                                   bool& bMustChangePassword)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, EvaluateMustChangePassword, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      bMustChangePassword = false;

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      static const DWORD dwAttrCount = 1;
      PWSTR pszAttrs[] = { L"pwdLastSet" };
      PADS_ATTR_INFO pAttrInfo = NULL;
      DWORD dwAttrsReturned = 0;

      hr = spDirObject->GetObjectAttributes(pszAttrs,
                                            dwAttrCount,
                                            &pAttrInfo,
                                            &dwAttrsReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"GetObjectAttributes for pwdLastSet failed: hr = 0x%x",
                      hr);
         break;
      }

      if (pAttrInfo && dwAttrsReturned && pAttrInfo->dwNumValues)
      {
         if (pAttrInfo->pADsValues->LargeInteger.HighPart == 0 &&
             pAttrInfo->pADsValues->LargeInteger.LowPart == 0)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"User must change password at next logon");
            bMustChangePassword = true;
         }
      }

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   EvaluateCanChangePasswordAces
//
//  Synopsis:   Looks for explicit entries in the ACL to see if the user can
//              change their password
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bCanChangePassword - OUT] : false if there are explicit entries
//                                           that keep the user from changing their
//                                           password.  true otherwise.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateCanChangePasswordAces(PCWSTR pszDN,
                                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                                      const CDSCmdCredentialObject& refCredentialObject,
                                      bool& bCanChangePassword)
{

	//SECURITY_REVIEW: Impelmentation of this function is not correct and can be improved
	//using authz apis. NTRAID#NTBUG9-571799-2002/03/08-hiteshr
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, EvaluateCanChangePasswordAces, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
      CSimpleAclHolder Dacl;
      hr = DSReadObjectSecurity(spDirObject,
                                &sdControl,
                                &(Dacl.m_pAcl));
      if (FAILED(hr))
      {
         break;
      }

      //
      // Create and Initialize the Self and World SIDs
      //
      CSidHolder selfSid;
      CSidHolder worldSid;

      PSID pSid = NULL;

      SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                               WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
	  //Security Review:this is fine.
      if (!AllocateAndInitializeSid(&NtAuth,
                                    1,
                                    SECURITY_PRINCIPAL_SELF_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
		 DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate self SID: hr = 0x%x", hr);
         break;
      }

      selfSid.Attach(pSid, false);
      pSid = NULL;

	  //Security Review:Should Everyone be replaced by Authenticated Users?
      if (!AllocateAndInitializeSid(&WorldAuth,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
		 DWORD _dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(_dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate world SID: hr = 0x%x", hr);
         break;
      }

      worldSid.Attach(pSid, false);
      pSid = NULL;

      ULONG ulCount = 0, j = 0;
      PEXPLICIT_ACCESS rgEntries = NULL;

      DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);

      if (ERROR_SUCCESS != dwErr)
      {
         hr = HRESULT_FROM_WIN32(dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"GetExplicitEntriesFromAcl failed: hr = 0x%x", hr);
         break;
      }

      //
      // Are these ACEs already present?
      //
      bool bSelfAllowPresent = false;
      bool bWorldAllowPresent = false;
      bool bSelfDenyPresent = false;
      bool bWorldDenyPresent = false;

      //
      // Loop through looking for the can change password ACE for self and world
      //
      for (j = 0; j < ulCount; j++)
      {
         //
         // Look for deny ACEs
         //
         if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
             (rgEntries[j].grfAccessMode == DENY_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
			   //Security Review:This is fine.RHS sid is coming from
			   //AllocateAndInitializeSid while LHS is coming from ACE
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get())) 
               {
                  //
                  // Deny self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny self found at rgEntries[%d]", j);
                  bSelfDenyPresent = true;
                  break;
               }
			   //Security Review:This is fine.RHS sid is coming from
			   //AllocateAndInitializeSid while LHS is coming from ACE
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Deny world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny world found at rgEntries[%d]", j);
                  bWorldDenyPresent = true;
                  break;
               }
            }
         }
         //
         // Look for allow ACEs
         //
         else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == GRANT_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //

            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
			   //Security Review:This is fine.RHS sid is coming from
			   //AllocateAndInitializeSid while LHS is coming from ACE

               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get()))
               {
                  //
                  // Allow self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow self found at rgEntries[%d]", j);
                  bSelfAllowPresent = true;
                  break;
               }
			   //Security Review:This is fine.RHS sid is coming from
			   //AllocateAndInitializeSid while LHS is coming from ACE
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Allow world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow world found at rgEntries[%d]", j);
                  bWorldAllowPresent = true;
                  break;
               }
            }
         }
      }

      if (bSelfDenyPresent || bWorldDenyPresent)
      {
         //
         // There is an explicit deny so we know that the user cannot change password
         //
         bCanChangePassword = false;
      }
      else if ((!bSelfDenyPresent && !bWorldDenyPresent) &&
               (bSelfAllowPresent || bWorldAllowPresent))
      {
         //
         // There is no explicit deny but there are explicit allows so we know that
         // the user can change password
         //
         bCanChangePassword = true;
      }
      else
      {
         //
         // We are not sure because the explicit entries are not telling us for
         // certain so it all depends on inheritence.  Most likely they will
         // be able to change their password unless the admin has changed something
         // higher up or through group membership
         //
         bCanChangePassword = true;
      }
   } while(false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ChangeCanChangePassword
//
//  Synopsis:   Sets or removes the Deny Ace on the can change password ACL
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ChangeCanChangePassword(PCWSTR pszDN,
                                const CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                const PDSOBJECTTABLEENTRY pObjectEntry,
                                const ARG_RECORD& argRecord,
                                DWORD dwAttributeIdx,
                                PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ChangeCanChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = NULL;

      //
      // Read the userAccountControl to make sure we don't have
      // the user must change password bit set
      //
      bool bMustChangePassword = false;
      hr = EvaluateMustChangePassword(pszDN,
                                      refBasePathsInfo,
                                      refCredentialObject,
                                      bMustChangePassword);
      if (FAILED(hr))
      {
         //
         // Lets log it but continue on as if everything was OK
         //
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"EvaluateMustChangePassword failed: hr = 0x%x",
                      hr);
      }

      if (bMustChangePassword && !argRecord.bValue)
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"Cannot have must change password and cannot change password");
         DisplayErrorMessage(g_pszDSCommandName, pszDN, S_OK, IDS_MUSTCHPWD_CANCHPWD_CONFLICT);
         *ppAttr = NULL;
         hr = S_FALSE;
         break;
      }

      hr = SetCanChangePassword(pszDN,
                                refBasePathsInfo,
                                refCredentialObject,
                                pObjectEntry,
                                argRecord,
                                dwAttributeIdx,
                                ppAttr);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetCanChangePassword
//
//  Synopsis:   Sets or removes the Deny Ace on the can change password ACL
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetCanChangePassword(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD /*dwAttributeIdx*/,
                             PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetCanChangePassword, hr);

	//NTRAID#NTBUG9-571818-2000/11/13-hiteshr
    //Why is the ace for everyone required? Isn't ace for Self sufficient.
    //IF needed consider replacing Everyone with Authenticated User.

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = NULL;

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
      CSimpleAclHolder Dacl;
      hr = DSReadObjectSecurity(spDirObject,
                                &sdControl,
                                &(Dacl.m_pAcl));
      if (FAILED(hr))
      {
         break;
      }

      //
      // Create and Initialize the Self and World SIDs
      //
      CSidHolder selfSid;
      CSidHolder worldSid;

      PSID pSid = NULL;

	  //Security Review:Check if Everyone can be replaced with
	  //Authenticated User. NTRAID#NTBUG9-571818-2002/03/11-hiteshr
      SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                               WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
	  //Security Review:This is fine.
      if (!AllocateAndInitializeSid(&NtAuth,
                                    1,
                                    SECURITY_PRINCIPAL_SELF_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate self SID: hr = 0x%x", hr);
         break;
      }

      selfSid.Attach(pSid, false);
      pSid = NULL;
	
	  //Security Review:This is fine.
      if (!AllocateAndInitializeSid(&WorldAuth,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate world SID: hr = 0x%x", hr);
         break;
      }

      worldSid.Attach(pSid, false);
      pSid = NULL;

      ULONG ulCount = 0, j = 0;
      PEXPLICIT_ACCESS rgEntries = NULL;

      DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);

      if (ERROR_SUCCESS != dwErr)
      {
         hr = HRESULT_FROM_WIN32(dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"GetExplicitEntriesFromAcl failed: hr = 0x%x", hr);
         break;
      }

      //
      // At most we will be adding two ACEs hence the +2
      //
      PEXPLICIT_ACCESS rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, sizeof(EXPLICIT_ACCESS)*(ulCount + 2));
      if (!rgNewEntries)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      DEBUG_OUTPUT(FULL_LOGGING, L"GetExplicitEntriesFromAcl return %d entries", ulCount); 

      //
      // Are these ACEs already present?
      //
      bool bSelfAllowPresent = false;
      bool bWorldAllowPresent = false;
      bool bSelfDenyPresent = false;
      bool bWorldDenyPresent = false;

      ULONG ulCurrentEntry = 0;
      //
      // If we are not granting them permission, then put the deny ACE at the top
      //
      OBJECTS_AND_SID rgObjectsAndSid[2]; //NTRAID#NTBUG9-572491-2002/05/24, fix, yanggao
      memset(rgObjectsAndSid, 0, sizeof(rgObjectsAndSid));
      if (!argRecord.bValue)
      {
         //
         // initialize the new entries (DENY ACE's)
         //
		 //Security Review:correct size is passed to memset
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the deny self ACE at rgNewEntries[%d]", ulCurrentEntry);
         rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
         rgNewEntries[ulCurrentEntry].grfAccessMode = DENY_ACCESS;
         rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

         //
         // build the trustee structs for change password
         //
		 //Security Review:NTRAID#NTBUG9-572491-2002/03/11-hiteshr
		 //rgNewEntries[ulCurrentEntry].Trustee.pstrName is set to &(rgObjectsAndSid[0]
		 //which is local to if.
         BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                       &(rgObjectsAndSid[0]),
                                       const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                       NULL, // inherit guid
                                       selfSid.Get());
         ulCurrentEntry++;

         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the deny world ACE at rgNewEntries[%d]", ulCurrentEntry);
         rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
         rgNewEntries[ulCurrentEntry].grfAccessMode = DENY_ACCESS;
         rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

         //
         // build the trustee structs for change password
         //
		 //Security Review:NTRAID#NTBUG9-572491-2002/03/11-hiteshr
		 //rgNewEntries[ulCurrentEntry].Trustee.pstrName is set to &(rgObjectsAndSid[0]
		 //which is local to if.
         BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                       &(rgObjectsAndSid[1]),
                                       const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                       NULL, // inherit guid
                                       worldSid.Get());
         ulCurrentEntry++;
      }

      //
      // Loop through all the ACEs and copy them over to the rgNewEntries unless it is
      // an ACE that we want to remove
      //
      for (j = 0; j < ulCount; j++)
      {
         bool bCopyACE = true;

         //
         // Look for deny ACEs
         //
         if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
             (rgEntries[j].grfAccessMode == DENY_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
			   //Security Review:Both sids are fine.
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get())) 
               {
                  //
                  // Deny self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny self found at rgEntries[%d]", j);
                  bSelfDenyPresent = true;

                  //
                  // Never copy the deny ACE because we added it above for !argRecord.bValue
                  //
                  bCopyACE = false;
               }
			   //Security Review:Both Sids are fine.
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Deny world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny world found at rgEntries[%d]", j);
                  bWorldDenyPresent = true;

                  //
                  // Never copy the deny ACE because we added it above for !argRecord.bValue
                  //
                  bCopyACE = false;
               }
            }
         }
         //
         // Look for allow ACEs
         //
         else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == GRANT_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
			   //Security Review:Both sids are fine.
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get()))
               {
                  //
                  // Allow self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow self found at rgEntries[%d]", j);
                  bSelfAllowPresent = true;
                  if (!argRecord.bValue)
                  {
                     bCopyACE = false;
                  }
               }
			   //Security Review:Both sids are fine.
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Allow world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow world found at rgEntries[%d]", j);
                  bWorldAllowPresent = TRUE;
                  if (!argRecord.bValue)
                  {
                     bCopyACE = false;
                  }
               }
            }
         }

         if (bCopyACE)
         {
            DEBUG_OUTPUT(FULL_LOGGING, 
                          L"Copying entry from rgEntries[%d] to rgNewEntries[%d]",
                          j,
                          ulCurrentEntry);
            rgNewEntries[ulCurrentEntry] = rgEntries[j];
            ulCurrentEntry++;
         }
      }

      //
      // Now add the allow ACEs if they were not present and we are granting user can change pwd
      //
      OBJECTS_AND_SID rgObjectsAndSid1 = {0}; //NTRAID#NTBUG9-572491-2002/05/24, fix, yanggao
      OBJECTS_AND_SID rgObjectsAndSid2 = {0};
      if (argRecord.bValue)
      {
         if (!bSelfAllowPresent)
         {
            //
            // Need to add the grant self ACE
            //
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the grant self ACE at rgNewEntries[%d]", ulCurrentEntry);
            rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulCurrentEntry].grfAccessMode = GRANT_ACCESS;
            rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

			//Security Review:NTRAID#NTBUG9-572491-2002/03/11-hiteshr
		    //rgNewEntries[ulCurrentEntry].Trustee.pstrName is set to &(rgObjectsAndSid)
		    //which is local to if statement.
            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                          &(rgObjectsAndSid1),
                                          const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          selfSid.Get());
            ulCurrentEntry++;
         }

         if (!bWorldAllowPresent)
         {
            //
            // Need to add the grant world ACE
            //
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the grant world ACE at rgNewEntries[%d]", ulCurrentEntry);

            rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulCurrentEntry].grfAccessMode = GRANT_ACCESS;
            rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;
			
			//Security Review:NTRAID#NTBUG9-572491-2002/03/11-hiteshr
		    //rgNewEntries[ulCurrentEntry].Trustee.pstrName is set to &(rgObjectsAndSid)
		    //which is local to if statement.
            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                          &(rgObjectsAndSid2),
                                          const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          worldSid.Get());
            ulCurrentEntry++;
         }
      }

      //
      // We should only have added two ACEs at most
      //
      ASSERT(ulCurrentEntry <= ulCount + 2);

	  //Security Review:NTRAID#NTBUG9-572465-2002/03/11-hiteshr
	  //Check should be if(ulCurrentEntry > ulCount + 2)
	  //if check fails, buffer overrun has occured and only thing safe to do is exit.
      if (ulCurrentEntry > ulCount)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
                      L"We probably ran off the end of the array because ulCurrentEntry(%d) is > ulCount(%d)", 
                      ulCurrentEntry, 
                      ulCount);
      }


      //
      // Now set the entries in the new ACL
      //
      CSimpleAclHolder NewDacl;

      DEBUG_OUTPUT(LEVEL3_LOGGING, L"Calling SetEntriesInAcl for %d entries", ulCurrentEntry);
	  //Security Review:NTRAID#NTBUG9-572491-2002/03/11-hiteshr
	  //See the comments above for rgNewEntries[ulCurrentEntry].
      dwErr = SetEntriesInAcl(ulCurrentEntry, rgNewEntries, NULL, &(NewDacl.m_pAcl));
      if (ERROR_SUCCESS != dwErr)
      {
         hr = HRESULT_FROM_WIN32(dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"SetEntriesInAcl failed: hr = 0x%x", hr);
         break;
      }

      ASSERT(IsValidAcl(NewDacl.m_pAcl));

      //
      // Free the entries
      //
      if (rgNewEntries)
      {
         LocalFree(rgNewEntries);
      }

      if (ulCount && rgEntries)
      {
         LocalFree(rgEntries);
      }

      //
      // Write the new ACL back as a SecurityDescriptor
      //
      hr = DSWriteObjectSecurity(spDirObject,
                                 sdControl,
                                 NewDacl.m_pAcl);
      if (FAILED(hr))
      {
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadGroupType
//
//  Synopsis:   Reads the group type from the group specified by the given DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                        CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [plType - OUT]        : returns the currect group type
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadGroupType(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      long* plType)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReadGroupType, hr);

   do // false loop
   {
      if (!pszDN ||
          !plType)
      {
         ASSERT(pszDN);
         ASSERT(plType);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADs interface to the user object
      //
      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(CComBSTR(L"groupType"), &var);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(var.vt == VT_I4);

      *plType = var.lVal;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetGroupScope
//
//  Synopsis:   Sets the groupType attribute to local/universal/global
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetGroupScope(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupScope, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // Read the current group type
      //
      bool bUseExistingAttrInfo = false;
      long lGroupType = 0;
      if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has not been read, try reading it now");
         hr = ReadGroupType(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            &lGroupType);
         if (FAILED(hr))
         {
            //
            // Just continue on without knowing since we are trying to set it anyway
            //
            hr = S_OK;
            lGroupType = 0;
         }

         //
         // Mark the attribute as read and allocate space for the new value
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
      }
      else
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has been read, just use that one");

         //
         // If the attribute hasn't been set yet create a new value for it
         //
         if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_DIRTY))
         {
            (*ppAttr)->pADsValues = new ADSVALUE;
            if (!(*ppAttr)->pADsValues)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            (*ppAttr)->dwNumValues = 1;
            (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         }

         lGroupType = (*ppAttr)->pADsValues->Integer;
         bUseExistingAttrInfo = true;
      }
      DEBUG_OUTPUT(LEVEL3_LOGGING, L"old grouptype = 0x%x", lGroupType);

      //
      // Remember the security bit
      //
      bool bIsSecurityEnabled = (lGroupType & GROUP_TYPE_SECURITY_ENABLED) != 0;

      //
      // Clear out the old value
      //
      lGroupType = 0;

      //
      // The parser should have already verified that the strValue contains 
      // either 'l', 'g', or 'u'
      //
      CComBSTR sbstrInput;
      sbstrInput = argRecord.strValue;
      sbstrInput.ToLower();

      if (sbstrInput == g_bstrGroupScopeLocal)
      {
         //
         // Local group
         //
         lGroupType = GROUP_TYPE_RESOURCE_GROUP;
      }
      else if (sbstrInput == g_bstrGroupScopeGlobal)
      {
         //
         // Global group
         //
         lGroupType = GROUP_TYPE_ACCOUNT_GROUP;
      }
      else if (sbstrInput == g_bstrGroupScopeUniversal)
      {
         //
         // Universal group
         //
         lGroupType = GROUP_TYPE_UNIVERSAL_GROUP;
      }
      else
      {
         *ppAttr = NULL;
         hr = E_INVALIDARG;
         break;
      }

      //
      // Reset the security bit
      //
      if (bIsSecurityEnabled)
      {
         lGroupType |= GROUP_TYPE_SECURITY_ENABLED;
      }

      //
      // Set the new value in the ADS_ATTR_INFO
      //
      (*ppAttr)->pADsValues->Integer = lGroupType;

      DEBUG_OUTPUT(LEVEL3_LOGGING, L"new grouptype = 0x%x", lGroupType);

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;

      //
      // if the attribute was previously read then we don't need to add another ADS_ATTR_INFO
      // 
      if (bUseExistingAttrInfo)
      {
        *ppAttr = NULL;
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   ChangeGroupScope
//
//  Synopsis:   Sets the groupType attribute to local/universal/global
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ChangeGroupScope(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupScope, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // Check the domain mode
      //
      bool bMixedMode = false;
      hr = refBasePathsInfo.GetDomainMode(refCredentialObject,
                                          bMixedMode);
      if (FAILED(hr))
      {
         *ppAttr = NULL;
         break;
      }

      if (bMixedMode)
      {
         //
         // We don't allow group type to be changed in Mixed Mode
         //
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             E_FAIL,
                             IDS_FAILED_CHANGE_GROUP_DOMAIN_VERSION);
         hr = S_FALSE;
         break;
      }

      hr = SetGroupScope(pszDN,
                         refBasePathsInfo,
                         refCredentialObject,
                         pObjectEntry,
                         argRecord,
                         dwAttributeIdx,
                         ppAttr);

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetGroupSecurity
//
//  Synopsis:   Sets the groupType to be security enabled or disabled
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetGroupSecurity(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupSecurity, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // Read the current group type
      //
      bool bUseExistingAttrInfo = false;
      long lGroupType = 0;
      if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has not been read, try reading it now");
         hr = ReadGroupType(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            &lGroupType);
         if (FAILED(hr))
         {
            //
            // Continue on anyway since we are trying to set this attribute
            //
            hr = S_OK;
            lGroupType = 0;
         }

         //
         // Mark the attribute as read and allocate space for the new value
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
      }
      else
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has been read, just use that one");

         //
         // if the attribute hasn't been marked dirty allocate space for the value
         //
         if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ))
         {
            (*ppAttr)->pADsValues = new ADSVALUE;
            if (!(*ppAttr)->pADsValues)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            (*ppAttr)->dwNumValues = 1;
            (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         }
         lGroupType = (*ppAttr)->pADsValues->Integer;
         bUseExistingAttrInfo = true;
      }
      DEBUG_OUTPUT(LEVEL3_LOGGING, L"old grouptype = 0x%x", lGroupType);

      if (argRecord.bValue)
      {
         lGroupType |= GROUP_TYPE_SECURITY_ENABLED;
      }
      else
      {
         lGroupType &= ~(GROUP_TYPE_SECURITY_ENABLED);
      }

      //
      // Set the new value in the ADS_ATTR_INFO
      //
      (*ppAttr)->pADsValues->Integer = lGroupType;

      DEBUG_OUTPUT(LEVEL3_LOGGING, L"new grouptype = 0x%x", lGroupType);

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;

      //
      // if we are just using the existing ADS_ATTR_INFO don't return a new one
      //
      if (bUseExistingAttrInfo)
      {
        *ppAttr = NULL;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ChangeGroupSecurity
//
//  Synopsis:   Sets the groupType to be security enabled or disabled but
//              checks if we are in native mode first
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ChangeGroupSecurity(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupSecurity, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // Check the domain mode
      //
      bool bMixedMode = false;
      hr = refBasePathsInfo.GetDomainMode(refCredentialObject,
                                          bMixedMode);
      if (FAILED(hr))
      {
         *ppAttr = NULL;
         break;
      }

      if (bMixedMode)
      {
         //
         // We don't allow group type to be changed in Mixed Mode
         //
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             E_FAIL,
                             IDS_FAILED_CHANGE_GROUP_DOMAIN_VERSION);
         hr = S_FALSE;
         break;
      }

      hr = SetGroupSecurity(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            pObjectEntry,
                            argRecord,
                            dwAttributeIdx,
                            ppAttr);

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ModifyGroupMembers
//
//  Synopsis:   Sets the groupType to be security enabled or disabled
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ModifyGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                           const CDSCmdCredentialObject& /*refCredentialObject*/,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD dwAttributeIdx,
                           PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ModifyGroupMembers, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(argRecord.strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         *ppAttr = NULL;
         hr = E_OUTOFMEMORY;
         break;
      }

      (*ppAttr)->pADsValues = new ADSVALUE[nStrings];
      if (!(*ppAttr)->pADsValues)
      {
         *ppAttr = NULL;
         LocalFree(ppszArray);
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = nStrings;

      for (UINT nIdx = 0; nIdx < nStrings; nIdx++)
      {
         if (_wcsicmp(ppszArray[nIdx], pszDN))
         {
            (*ppAttr)->pADsValues[nIdx].dwType = (*ppAttr)->dwADsType;
            (*ppAttr)->pADsValues[nIdx].DNString = ppszArray[nIdx];
         }
         else
         {
            DEBUG_OUTPUT(
               LEVEL3_LOGGING, 
               L"Can't make a group a member of itself!");

            DisplayErrorMessage(
               g_pszDSCommandName,
               pszDN,
               E_FAIL,
               IDS_GROUP_MEMBER_ITSELF);

            // return S_FALSE since we already presented the user with an error message

            hr = S_FALSE;
            break;
         }
      }

      // Break out of the false loop if there was a failure in
      // the for loop above

      if (FAILED(hr))
      {
         break;
      }

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;

      if (ppszArray)
      {
         LocalFree(ppszArray);
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadGroupMembership
//
//  Synopsis:   Reads the group members list
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [ppMembersAttr - OUT] : returns the currect group membership
//                                      this value must be freed using FreeADsMem
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadGroupMembership(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            PADS_ATTR_INFO* ppMembersAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReadGroupMembership, hr);

   do // false loop
   {
      if (!pszDN ||
          !ppMembersAttr)
      {
         ASSERT(pszDN);
         ASSERT(ppMembersAttr);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADs interface to the user object
      //
      CComPtr<IDirectoryObject> spObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      DWORD dwNumReturned = 0;
      PWSTR ppszAttrs[] = { L"member" };
      hr = spObject->GetObjectAttributes(ppszAttrs,
                                         sizeof(ppszAttrs)/sizeof(PWSTR),
                                         ppMembersAttr,
                                         &dwNumReturned);
      if (FAILED(hr))
      {
         break;
      }
   } while (false);
   
   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ShowRemoveFromGroupFailure
//
//  Synopsis:   Displays an error message as a result of failure to remove
//              an object from a group
//
//  Arguments:  [hr - IN]        : failure code
//              [pszDN - IN]     : DN of the group object
//              [pszMember - IN] : DN of the member being removed
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    06-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ShowRemoveFromGroupFailure(HRESULT hrResult,
                                   PCWSTR pszDN,
                                   PCWSTR pszMember)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ShowRemoveFromGroupFailure, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pszMember)
      {
         ASSERT(pszDN);
         ASSERT(pszMember);

         hr = E_INVALIDARG;
         break;
      }

      bool bShowGenericMessage = true;
      CComBSTR sbstrFormatter;
      bool bLoadFormatString = sbstrFormatter.LoadString(::GetModuleHandle(NULL), 
                                                         IDS_ERRMSG_REMOVE_FROM_GROUP);
      if (bLoadFormatString)
      {
		 //Security Review:this is fine.
         size_t messageLength = wcslen(sbstrFormatter) + wcslen(pszMember);
         PWSTR pszMessage = new WCHAR[messageLength + 1];
         if (pszMessage)
         {
			//Security Review:Though care has been taken make sure enough buffer is allocated.
			//I have filed a bug to replace wsprintf with strsafe api.
			//NTRAID#NTBUG9-573053-2002/03/08-hiteshr
            wsprintf(pszMessage, sbstrFormatter, pszMember);
            DisplayErrorMessage(g_pszDSCommandName,
                                pszDN,
                                hrResult,
                                pszMessage);
            bShowGenericMessage = false;
            delete[] pszMessage;
            pszMessage = 0;
         }
      }
      
      if (bShowGenericMessage)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to load the string IDS_ERRMSG_REMOVE_FROM_GROUP from the resource file");
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Using the default message instead");
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             hrResult);
      }
   } while (false);

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   RemoveGroupMembers
//
//  Synopsis:   Removes the specified members from the group
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT RemoveGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD /*dwAttributeIdx*/,
                           PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, RemoveGroupMembers, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // We won't be returning an attribute
      //
      *ppAttr = 0;

      //
      // Parse the members to be removed
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(argRecord.strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         *ppAttr = NULL;
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADs interface to the user object
      //
      CComPtr<IADsGroup> spGroup;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADsGroup,
                           (void**)&spGroup,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      //
      // Remove each of the objects from the group
      //
      for (UINT nStringIdx = 0; nStringIdx < nStrings; nStringIdx++)
      {
         //
         // Convert the member DN into a ADSI path
         //
         CComBSTR sbstrMemberPath;
         refBasePathsInfo.ComposePathFromDN(ppszArray[nStringIdx], sbstrMemberPath);

         //
         // Remove the member
         //
         hr = spGroup->Remove(sbstrMemberPath);
         if (FAILED(hr))
         {
            ShowRemoveFromGroupFailure(hr, pszDN, ppszArray[nStringIdx]);
            hr = S_FALSE;
            break;
         }
      }
      
      if (ppszArray)
      {
         LocalFree(ppszArray);
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   MakeMemberOf
//
//  Synopsis:   Makes the object specified by pszDN a member of the group
//              specified in the argRecord.strValue
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    25-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT MakeMemberOf(PCWSTR pszDN,
                     const CDSCmdBasePathsInfo& refBasePathsInfo,
                     const CDSCmdCredentialObject& refCredentialObject,
                     const PDSOBJECTTABLEENTRY pObjectEntry,
                     const ARG_RECORD& argRecord,
                     DWORD dwAttributeIdx,
                     PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, MakeMemberOf, hr);
   
   PWSTR* ppszArray = NULL;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      //
      // We are going to do all the work here so don't pass back the ADS_ATTR_INFO
      //
      *ppAttr = NULL;

      ADS_ATTR_INFO* pMemberAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      UINT nStrings = 0;
      ParseNullSeparatedString(argRecord.strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to parse null separated string list of groups");
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Create the value
      //
      ADSVALUE MemberValue = { ADSTYPE_DN_STRING, NULL };
      pMemberAttr->pADsValues = &MemberValue;
      pMemberAttr->dwNumValues = 1;
      pMemberAttr->dwControlCode = ADS_ATTR_APPEND;
      pMemberAttr->pADsValues->DNString = (PWSTR)pszDN;

      //
      // For each group in the list add the object to the group
      //
      for (UINT nIdx = 0; nIdx < nStrings; nIdx++)
      {
         PWSTR pszGroupDN = ppszArray[nIdx];
         ASSERT(pszGroupDN);

         CComBSTR sbstrGroupPath;
         refBasePathsInfo.ComposePathFromDN(pszGroupDN, sbstrGroupPath);

         CComPtr<IDirectoryObject> spDirObject;
         hr  = DSCmdOpenObject(refCredentialObject,
                               sbstrGroupPath,
                               IID_IDirectoryObject,
                               (void**)&spDirObject,
                               true);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to open group object: %s", sbstrGroupPath);
            break;
         }

         DWORD dwNumAttrs = 0;
         hr = spDirObject->SetObjectAttributes(pMemberAttr,
                                               1,
                                               &dwNumAttrs);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to set object attributes on group object: %s", sbstrGroupPath);
            break;
         }
      }

   } while (false);

   if (ppszArray)
   {
      LocalFree(ppszArray);
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetIsGC
//
//  Synopsis:   Makes the server object specified by pszDN into a GC or not
//              by modifying the NTDS Settings object contained within
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetIsGC(PCWSTR pszDN,
                const CDSCmdBasePathsInfo& refBasePathsInfo,
                const CDSCmdCredentialObject& refCredentialObject,
                const PDSOBJECTTABLEENTRY pObjectEntry,
                const ARG_RECORD& argRecord,
                DWORD /*dwAttributeIdx*/,
                PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetIsGC, hr);
   
   PADS_ATTR_INFO pAttrInfo = 0;

   // To keep track of who allocated the memory for pAttrInfo

   bool usingADSIMemory = true;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      //
      // We are going to do all the work here so don't pass back the ADS_ATTR_INFO
      //
      *ppAttr = NULL;

      //
      // Get the NTDS Settings object that is contained within the server of the specified DN
      //
      CComBSTR sbstrSettingsDN = L"CN=NTDS Settings,";
      sbstrSettingsDN += pszDN;

      CComBSTR sbstrSettingsPath;
      refBasePathsInfo.ComposePathFromDN(sbstrSettingsDN, sbstrSettingsPath);

      DEBUG_OUTPUT(LEVEL3_LOGGING,
                   L"NTDS Settings path = %s",
                   sbstrSettingsPath);

      CComPtr<IDirectoryObject> spDirectoryObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrSettingsPath,
                           IID_IDirectoryObject,
                           (void**)&spDirectoryObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      PWSTR pszAttrs[] = { L"options" };
      DWORD dwReturned = 0;
      hr = spDirectoryObject->GetObjectAttributes(pszAttrs, 1, &pAttrInfo, &dwReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, 
                      L"Failed to get old options: hr = 0x%x",
                      hr);
         break;
      }
      

      if (dwReturned < 1 ||
          !pAttrInfo)
      {
         // Since we were unable to get the options we have to constuct the
         // value ourselves

         DEBUG_OUTPUT(LEVEL3_LOGGING,
                      L"Get options succeeded but no values were returned.");

         // Make sure we know that we did the allocation ourselves so that the
         // proper cleanup is done

         usingADSIMemory = false;

         pAttrInfo = new ADS_ATTR_INFO;
         
         if (!pAttrInfo)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         
         ZeroMemory(pAttrInfo, sizeof(ADS_ATTR_INFO));

         pAttrInfo->pADsValues = new ADSVALUE;
         
         if (!pAttrInfo->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         ZeroMemory(pAttrInfo->pADsValues, sizeof(ADSVALUE));

         pAttrInfo->dwADsType = ADSTYPE_INTEGER;
         pAttrInfo->pszAttrName = pszAttrs[0];
         pAttrInfo->dwNumValues = 1;
         pAttrInfo->pADsValues->dwType = ADSTYPE_INTEGER;
      }

      if (argRecord.bDefined && 
         argRecord.bValue)
      {
         pAttrInfo->pADsValues->Integer |= SERVER_IS_GC_BIT;
      }
      else
      {
         pAttrInfo->pADsValues->Integer &= ~(SERVER_IS_GC_BIT);
      }

      pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;

      dwReturned = 0;
      hr = spDirectoryObject->SetObjectAttributes(pAttrInfo, 1, &dwReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING,
                      L"Failed to set the new options: hr = 0x%x",
                      hr);
         break;
      }

      ASSERT(dwReturned == 1);
      
   } while (false);

   if (pAttrInfo)
   {
      if (usingADSIMemory)
      {
         FreeADsMem(pAttrInfo);
      }
      else
      {
         if (pAttrInfo->pADsValues)
         {
            delete pAttrInfo->pADsValues;
         }

         delete pAttrInfo;
      }
   }
   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildComputerSAMName
//
//  Synopsis:   If the -samname argument was defined use that, else compute
//              the same name from the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    09-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BuildComputerSAMName(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                             const CDSCmdCredentialObject& /*refCredentialObject*/,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildComputerSAMName, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      (*ppAttr)->pADsValues = new ADSVALUE[1];
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = 1;
      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

      if (!argRecord.bDefined ||
          !argRecord.strValue)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Constructing sAMAccountName for computer");

         //
         // If the object type is group and the sAMAccountName
         // was not specified, construct it from the DN or name
         //
         CONST DWORD computerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
         DWORD Len = computerNameLen;
         WCHAR szDownLevel[computerNameLen];
		 //Security Review:This is fine.
         ZeroMemory(szDownLevel, computerNameLen * sizeof(WCHAR));

         CComBSTR sbstrName;
         hr = CPathCracker::GetObjectNameFromDN(pszDN,
                                                sbstrName);
         if (SUCCEEDED(hr))
         {
            //
            // run through the OEM conversion, just to
            // behave the same way as typing in the OEM
            // edit box
            //
            CComBSTR sbstrOemUnicode;
            _UnicodeToOemConvert(sbstrName, sbstrOemUnicode);

            DEBUG_OUTPUT(LEVEL8_LOGGING,
                         L"OemConverted name: %s",
                         sbstrOemUnicode);

            // run through the DNS validation
            if (!DnsHostnameToComputerName(sbstrOemUnicode, szDownLevel, &Len))
            {
               DWORD err = GetLastError();
               hr = HRESULT_FROM_WIN32(err);

               DEBUG_OUTPUT(LEVEL3_LOGGING, 
                            L"Failed in DnsHostnameToComputerName: GLE = 0x%x",
                            err);

               Len = 0;
            }

            if (Len > 0)
            {
               //
               // Validate the SAM name
               //
               HRESULT hrValidate = ValidateAndModifySAMName(szDownLevel, 
                                                             INVALID_NETBIOS_AND_ACCOUNT_NAME_CHARS_WITH_AT);

               if (FAILED(hrValidate))
               {
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Unable to validate the SamAccountName");
                  ASSERT(SUCCEEDED(hrValidate));
                  break;
               }

               //
               // Change the last character to a $
               //
               if (Len == MAX_COMPUTERNAME_LENGTH)
               {
                  szDownLevel[Len - 1] = L'$';
               }
               else
               {
                  szDownLevel[Len] = L'$';
                  szDownLevel[Len+1] = L'\0';
               }

               //
               // Allocate enough memory for the string in the command args structure
               // REVIEW_JEFFJON : this is being leaked
               //
			   //This is fine.
               (*ppAttr)->pADsValues->CaseIgnoreString = (LPTSTR)LocalAlloc(LPTR, (wcslen(szDownLevel) + 1) * sizeof(WCHAR) );
               if (!(*ppAttr)->pADsValues->CaseIgnoreString)
               {
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate space for (*ppAttr)->pADsValues->CaseIgnoreString");
                  hr = E_OUTOFMEMORY;
                  break;
               }

               //
               // Truncate the name if necessary but copy it to the command args structure
               //
			   //Security Review:_tcsncpy won't null terminate. We are fine here since buffer is
			   //initialized to all zero. Filed a bug for making the code clear here.
			   //NTRAID#NTBUG9-573229-2002/03/08-hiteshr
               _tcsncpy((*ppAttr)->pADsValues->CaseIgnoreString, 
                        szDownLevel, 
                        wcslen(szDownLevel));
            }
         }
      }
      else
      {
         (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildGroupSAMName
//
//  Synopsis:   If the -samname argument was defined use that, else compute
//              the same name from the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    09-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BuildGroupSAMName(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                          const CDSCmdCredentialObject& /*refCredentialObject*/,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD dwAttributeIdx,
                          PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildGroupSAMName, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      (*ppAttr)->pADsValues = new ADSVALUE[1];
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = 1;
      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

      if (!argRecord.bDefined ||
          !argRecord.strValue)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"Constructing sAMAccountName for group");
         static const UINT nSamLength = 256;

         //
         // If the object type is group and the sAMAccountName
         // was not specified, construct it from the DN or name
         //
         CComBSTR sbstrName;
         hr = CPathCracker::GetObjectNameFromDN(pszDN,
                                                sbstrName);
         if (SUCCEEDED(hr))
         {
            UINT nNameLen = sbstrName.Length();

            //
            // Allocate enough memory for the string in the command args structure
            // REVIEW_JEFFJON : this is being leaked
            //
            (*ppAttr)->pADsValues->CaseIgnoreString = (LPTSTR)LocalAlloc(LPTR, (nNameLen+2) * sizeof(WCHAR) );
            if (!(*ppAttr)->pADsValues->CaseIgnoreString)
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to allocate space for (*ppAttr)->pADsValues->CaseIgnoreString");
               hr = E_OUTOFMEMORY;
               break;
            }

            //
            // Truncate the name if necessary but copy it to the command args structure
            //
			//Security Review:_tcsncpy won't null terminate. We are fine here since buffer is
			//initialized to all zero. Filed a bug for making the code clear here.
			//NTRAID#NTBUG9-573229-2002/03/08-hiteshr

            _tcsncpy((*ppAttr)->pADsValues->CaseIgnoreString, 
                     sbstrName, 
                     (nNameLen > nSamLength) ? nSamLength : nNameLen);

         }
      }
      else
      {
         (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildUserSAMName
//
//  Synopsis:   If the -samname argument was defined use that, else compute
//              the same name from the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    09-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BuildUserSAMName(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                         const CDSCmdCredentialObject& /*refCredentialObject*/,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildUserSAMName, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      (*ppAttr)->pADsValues = new ADSVALUE[1];
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = 1;
      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

      if (!argRecord.bDefined ||
          !argRecord.strValue)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"Constructing sAMAccountName for group");
         static const UINT nSamLength = 20;

         //
         // If the object type is group and the sAMAccountName
         // was not specified, construct it from the DN or name
         //
         CComBSTR sbstrName;
         hr = CPathCracker::GetObjectNameFromDN(pszDN,
                                                sbstrName);
         if (SUCCEEDED(hr))
         {
            UINT nNameLen = sbstrName.Length();

            //
            // Allocate enough memory for the string in the command args structure
            // REVIEW_JEFFJON : this is being leaked
            //
            (*ppAttr)->pADsValues->CaseIgnoreString = (LPTSTR)LocalAlloc(LPTR, (nNameLen+2) * sizeof(WCHAR) );
            if (!(*ppAttr)->pADsValues->CaseIgnoreString)
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to allocate space for (*ppAttr)->pADsValues->CaseIgnoreString");
               hr = E_OUTOFMEMORY;
               break;
            }

            //
            // Truncate the name if necessary but copy it to the command args structure
            //
			//Security Review:_tcsncpy won't null terminate. We are fine here since buffer is
			//initialized to all zero. Filed a bug for making the code clear here.
			//NTRAID#NTBUG9-573229-2002/03/08-hiteshr

            _tcsncpy((*ppAttr)->pADsValues->CaseIgnoreString, 
                     sbstrName, 
                     (nNameLen > nSamLength) ? nSamLength : nNameLen);

         }
      }
      else
      {
         (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
      }
   } while (false);

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   SetComputerAccountType
//
//  Synopsis:   Sets the userAccountControl to make the object a workstation
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    05-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetComputerAccountType(PCWSTR pszDN,
                               const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                               const CDSCmdCredentialObject& /*refCredentialObject*/,
                               const PDSOBJECTTABLEENTRY pObjectEntry,
                               const ARG_RECORD& /*argRecord*/,
                               DWORD dwAttributeIdx,
                               PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetComputerAccountType, hr);
   
   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      //
      // Add in the required workstation flags
      //
      lUserAccountControl |= UF_WORKSTATION_TRUST_ACCOUNT | UF_ACCOUNTDISABLE | UF_PASSWD_NOTREQD;

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetErrorMessage
//
//  Synopsis:   Retrieves the error message associated with the HRESULT by 
//              using FormatMessage
//
//  Arguments:  [hr - IN]                 : HRESULT for which the error 
//                                          message is to be retrieved
//              [sbstrErrorMessage - OUT] : Receives the error message
//
//  Returns:    bool : true if the message was formatted properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool GetErrorMessage(HRESULT hr, CComBSTR& sbstrErrorMessage)
{
   ENTER_FUNCTION(MINIMAL_LOGGING, GetErrorMessage);

   HRESULT hrGetLast = S_OK;
   HRESULT hrADSI = S_OK;
   DWORD status = 0;
   PTSTR ptzSysMsg = NULL;

   //
   // first check if we have extended ADs errors
   //
   if (hr != S_OK) 
   {
      WCHAR Buf1[256], Buf2[256];
      hrGetLast = ::ADsGetLastError(&status, Buf1, 256, Buf2, 256);
      if ((hrGetLast == S_OK) && (status != ERROR_INVALID_DATA) && (status != 0)) 
      {
         hrADSI = status;
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
                      L"ADsGetLastError returned hr = 0x%x",
                      hrADSI);

         if (HRESULT_CODE(hrADSI) == ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER)
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Displaying special error message for ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER");
            bool bLoadedMessage = sbstrErrorMessage.LoadString(::GetModuleHandle(NULL),
                                                               IDS_ERRMSG_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER);
            if (bLoadedMessage)
            {
               return true;
            }
         }
      }
   }

   
   //
   // try to get error message for  ADSI HRESULT
   //
   int nChars = 0;
   if(hrADSI != S_OK)
   {

	   //
	   // try the system first
	   //
	   //Security Review:FORMAT_MESSAGE_ALLOCATE_BUFFER is used.API will allocate
	   //correct buffer.
	   nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
								| FORMAT_MESSAGE_FROM_SYSTEM,
								NULL, 
								hrADSI,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
								(PTSTR)&ptzSysMsg, 
								0, 
								NULL);

	   if (nChars == 0) 
	   { 
		  //
		  //try ads errors
		  //
		  static HMODULE g_adsMod = 0;
		  if (0 == g_adsMod)
		  {
			 g_adsMod = GetModuleHandle (L"activeds.dll");
		  }
		   //Security Review:FORMAT_MESSAGE_ALLOCATE_BUFFER is used.API will allocate
		   //correct buffer.
		  nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
								   | FORMAT_MESSAGE_FROM_HMODULE, 
								   g_adsMod, 
								   hrADSI,
								   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
								   (PTSTR)&ptzSysMsg, 
								   0, 
								   NULL);
	   }
   }

   //
   // Try to get error message for hr
   //
   if(nChars == 0)
   {
	   //Security Review:FORMAT_MESSAGE_ALLOCATE_BUFFER is used.API will allocate
	   //correct buffer.
	   nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
								| FORMAT_MESSAGE_FROM_SYSTEM,
								NULL, 
								hr,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
								(PTSTR)&ptzSysMsg, 
								0, 
								NULL);
   }

   if (nChars > 0)
   {
      //
      // Strip off the newline if there is one
      //
      PTSTR ptzTemp = ptzSysMsg;
      while (ptzTemp && *ptzTemp != _T('\0'))
      {
         if (*ptzTemp == _T('\n') || *ptzTemp == _T('\r'))
         {
            *ptzTemp = _T('\0');
         }
         ptzTemp++;
      }
      sbstrErrorMessage = ptzSysMsg;
      ::LocalFree(ptzSysMsg);
   }

   return (nChars > 0);
}


//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [pszMessage - IN]: string of an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//              10-May-2001   JonN      256583 output DSCMD-escaped DN
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         PCWSTR pszMessage)
{
   bool bRet = true;
   CComBSTR sbstrError;
   CComBSTR sbstrFailed;

   bool bGetError = false;
   if (FAILED(hr))
   {
      bGetError = GetErrorMessage(hr, sbstrError);
   }
   bool bLoadFailed = sbstrFailed.LoadString(::GetModuleHandle(NULL), IDS_FAILED);

   // JonN 5/10/01 256583 output DSCMD-escaped DN
   CComBSTR sbstrOutputDN;
   if (pszName && *pszName)
   {
      HRESULT hrToo = GetOutputDN( &sbstrOutputDN, pszName );
      if (FAILED(hrToo))
      {
          ASSERT(FALSE);
      }
      else
      {
         pszName = sbstrOutputDN;
      }
   }

   if (bGetError && bLoadFailed && pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s:%s\r\n", 
                         pszCommand, 
                         sbstrFailed, 
                         pszName, 
                         sbstrError, 
                         pszMessage);
   }
   else if (bGetError && bLoadFailed && pszName && !pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s\r\n",
                         pszCommand,
                         sbstrFailed,
                         pszName,
                         sbstrError);
   }
   else if (bGetError && bLoadFailed && !pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s\r\n",
                         pszCommand,
                         sbstrFailed,
                         sbstrError,
                         pszMessage);
   }
   else if (bGetError && bLoadFailed && !pszName && !pszMessage)
   {
      WriteStandardError(L"%s %s:%s\r\n",
                         pszCommand,
                         sbstrFailed,
                         sbstrError);
   }
   else if (!bGetError && bLoadFailed && !pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s\r\n",
                         pszCommand,
                         sbstrFailed,
                         pszMessage);
   }
   else if (!bGetError && bLoadFailed && pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s\r\n",
                         pszCommand,
                         sbstrFailed,
                         pszName,
                         pszMessage);
   }
   else
   {
      WriteStandardError(L"Error code = 0x%x\r\n", hr);
      bRet = FALSE;
   }

   DisplayUsageHelp(pszCommand);
   return bRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [nStringID - IN] : Resource ID an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         UINT nStringID)
{
   CComBSTR sbstrMessage;

   bool bLoadString = sbstrMessage.LoadString(::GetModuleHandle(NULL), nStringID);
   if (bLoadString)
   {
      return DisplayErrorMessage(pszCommand, pszName, hr, sbstrMessage);
   }
   return DisplayErrorMessage(pszCommand, pszName, hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplaySuccessMessage
//
//  Synopsis:   Displays a success message for the command
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//              10-May-2001   JonN      256583 output DSCMD-escaped DN
//
//---------------------------------------------------------------------------

bool DisplaySuccessMessage(PCWSTR pszCommand,
                           PCWSTR pszName)
{
   //
   // Verify parameters
   //
   if (!pszCommand)
   {
      ASSERT(pszCommand);
      return false;
   }

   CComBSTR sbstrSuccess;
   if (!sbstrSuccess.LoadString(::GetModuleHandle(NULL), IDS_SUCCESS))
   {
      return false;
   }

   CComBSTR sbstrOutputDN;
   if (!pszName)
   {
      WriteStandardOut(L"%s %s\r\n", pszCommand, sbstrSuccess);
   }
   else
   {
      // JonN 5/10/01 256583 output DSCMD-escaped DN
      if (*pszName)
      {
         HRESULT hr = GetOutputDN( &sbstrOutputDN, pszName );
         if (FAILED(hr))
         {
             ASSERT(FALSE);
         }
         else
         {
            pszName = sbstrOutputDN;
         }
      }

      WriteStandardOut(L"%s %s:%s\r\n", pszCommand, sbstrSuccess, pszName);
   }

   return true;
}


//+--------------------------------------------------------------------------
//
//  Function:   WriteStringIDToStandardOut
//
//  Synopsis:   Loads the String Resource and displays on Standardout
//
//  Arguments:  nStringID :	Resource ID	
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   hiteshr Created
//
//---------------------------------------------------------------------------
bool WriteStringIDToStandardOut(UINT nStringID)
{

   CComBSTR sbstrSuccess;
   if (!sbstrSuccess.LoadString(::GetModuleHandle(NULL), nStringID))
   {
      return false;
   }

   WriteStandardOut(sbstrSuccess);
   return true;
}

//+--------------------------------------------------------------------------
//
//  Function:   WriteStringIDToStandardErr
//
//  Synopsis:   Loads the String Resource and displays on StandardErr
//
//  Arguments:  nStringID :	Resource ID	
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    14-June-2001 hiteshr Created
//
//---------------------------------------------------------------------------
bool WriteStringIDToStandardErr(UINT nStringID)
{

   CComBSTR sbstrSuccess;
   if (!sbstrSuccess.LoadString(::GetModuleHandle(NULL), nStringID))
   {
      return false;
   }

   WriteStandardError(sbstrSuccess);
   return true;
}



//+---------------------------------------------------------------------------
//
//  Function:   ExpandUsername
//
//  Synopsis:   If the value in pwzValue contains %username% it gets expanded
//              to be the sAMAccountName
//
//  Arguments:  [pwzValue IN/OUT] : string that may contain %username%
//              [pwzSamName IN]   : the SAM name to substitute
//              [fExpanded OUT]   : whether the value needed to be expanded or not
//
//  Return:     bool : true if the function succeeded, false otherwise
//
//  History     27-Oct-2000   JeffJon  Created
//----------------------------------------------------------------------------
bool ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, bool& fExpanded)
{
  ENTER_FUNCTION(LEVEL5_LOGGING, ExpandUsername);

  PCWSTR pszUserToken = L"$username$";
  //Security Review:This is fine.
  unsigned int TokenLength = static_cast<unsigned int>(wcslen(pszUserToken));

  bool bRet = false;

  do // false loop
  {
     if (!pwzValue)
     {
        ASSERT(pwzValue);
        break;
     }

     //
     // This determines if expansion is needed
     //
     PWSTR pwzTokenStart = wcschr(pwzValue, pszUserToken[0]);
     if (pwzTokenStart)
     {
	   //Security Review:This is fine.
       if ((wcslen(pwzTokenStart) >= TokenLength) &&
           (_wcsnicmp(pwzTokenStart, pszUserToken, TokenLength) == 0))
       {
         fExpanded = true;
       }
       else
       {
         fExpanded = false;
         bRet = true;
         break;
       }
     }
     else
     {
       fExpanded = false;
       bRet = true;
       break;
     }

     //
     // If the samName isn't given return without doing anything
     // This is useful to just determine if expansion is needed or not
     //
     if (!pwzSamName)
     {
       bRet = false;
       break;
     }

     CComBSTR sbstrValue;
     CComBSTR sbstrAfterToken;

     while (pwzTokenStart)
     {
       *pwzTokenStart = L'\0';

       sbstrValue = pwzValue;

       if ((L'\0' != *pwzValue) && !sbstrValue.Length())
       {
         bRet = false;
         break;
       }

       PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

       sbstrAfterToken = pwzAfterToken;

       if ((L'\0' != *pwzAfterToken) && !sbstrAfterToken.Length())
       {
         bRet = false;
         break;
       }

       delete pwzValue;

       sbstrValue += pwzSamName;

       if (!sbstrValue.Length())
       {
         bRet = false;
         break;
       }

       sbstrValue += sbstrAfterToken;

       if (!sbstrValue.Length())
       {
         bRet = false;
         break;
       }

       pwzValue = new WCHAR[sbstrValue.Length() + 1];
       if (!pwzValue)
       {
         bRet = false;
         break;
       }
	   //Security Review:Buffer is correctly allocated above.
       wcscpy(pwzValue, sbstrValue);

       pwzTokenStart = wcschr(pwzValue, pszUserToken[0]);
	   //This is fine.
       if (!(pwzTokenStart &&
             (wcslen(pwzTokenStart) >= TokenLength) &&
             (_wcsnicmp(pwzTokenStart, pszUserToken, TokenLength) == 0)))
       {
         bRet = true;
         break;
       }
     } // while
  } while (false);

  return bRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   FillAttrInfoFromObjectEntryExpandUsername
//
//  Synopsis:   Fills the ADS_ATTR_INFO from the attribute table associated
//              with the object entry and expands values containing %username%
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]     : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_OUTOFMEMORY if we failed to allocate space for the value
//                        E_FAIL if we failed to format the value properly
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT FillAttrInfoFromObjectEntryExpandUsername(PCWSTR pszDN,
                                                  const CDSCmdBasePathsInfo& refBasePathsInfo,
                                                  const CDSCmdCredentialObject& refCredentialObject,
                                                  const PDSOBJECTTABLEENTRY pObjectEntry,
                                                  const ARG_RECORD& argRecord,
                                                  DWORD dwAttributeIdx,
                                                  PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, FillAttrInfoFromObjectEntryExpandUsername, hr);

   do // false loop
   {
      //
      // Verify Parameters
      //
      if (!pObjectEntry ||
          !ppAttr ||
          !pszDN)
      {
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
         ASSERT(pszDN);

         hr = E_INVALIDARG;
         break;
      }

      if (argRecord.strValue && argRecord.strValue[0] != L'\0')
      {
         //
         // REVIEW_JEFFJON : this is being leaked!!!
         //
		 //Security Review:This is fine.
         PWSTR pszValue = new WCHAR[wcslen(argRecord.strValue) + 1];
         if (!pszValue)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
		 //Security Review:Buffer is correctly allocated above.
         wcscpy(pszValue, argRecord.strValue);

         //
         // First check to see if we need to expand %username%
         //
         CComBSTR sbstrSamName;
         bool bExpandNeeded = false;
         ExpandUsername(pszValue, NULL, bExpandNeeded);
         if (bExpandNeeded)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"%username% expansion required.  Retrieving sAMAccountName...");

            //
            // Retrieve the sAMAccountName of the object and then expand the %username%
            //
            CComBSTR sbstrPath;
            refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

            CComPtr<IADs> spADs;
            hr = DSCmdOpenObject(refCredentialObject,
                                 sbstrPath,
                                 IID_IADs,
                                 (void**)&spADs,
                                 true);
            if (FAILED(hr))
            {
               break;
            }

            CComVariant var;
            hr = spADs->Get(CComBSTR(L"sAMAccountName"), &var);
            if (FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, 
                            L"Failed to get sAMAccountName: hr = 0x%x",
                            hr);
               break;
            }

            ASSERT(var.vt == VT_BSTR);
            sbstrSamName = var.bstrVal;

            DEBUG_OUTPUT(LEVEL5_LOGGING,
                         L"sAMAccountName = %w",
                         sbstrSamName);

            //
            // Now expand the username to the sAMAccountName
            //
            if (!ExpandUsername(pszValue, sbstrSamName, bExpandNeeded))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to expand %username%");
               hr = E_OUTOFMEMORY;
               break;
            }
         }

         switch (argRecord.fType)
         {
         case ARG_TYPE_STR :
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"argRecord.fType = ARG_TYPE_STR");

            *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

            //
            // REVIEW_JEFFJON : this is being leaked!
            //
            (*ppAttr)->pADsValues = new ADSVALUE[1];
            if ((*ppAttr)->pADsValues)
            {
               (*ppAttr)->dwNumValues = 1;
               (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
               switch ((*ppAttr)->dwADsType)
               {
               case ADSTYPE_DN_STRING :
                  {
                     //
                     // Lets bind to be sure the object exists
                     //
                     CComBSTR sbstrObjPath;
                     refBasePathsInfo.ComposePathFromDN(pszValue, sbstrObjPath);

                     CComPtr<IADs> spIADs;
                     hr = DSCmdOpenObject(refCredentialObject,
                                          sbstrObjPath,
                                          IID_IADs,
                                          (void**)&spIADs,
                                          true);

                     if (FAILED(hr))
                     {
                        DEBUG_OUTPUT(LEVEL3_LOGGING, L"DN object doesn't exist. %s", pszValue);
                        break;
                     }

                     (*ppAttr)->pADsValues->DNString = pszValue;
                     DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_DN_STRING = %s", pszValue);
                  }
                  break;

               case ADSTYPE_CASE_EXACT_STRING :
                  (*ppAttr)->pADsValues->CaseExactString = pszValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_EXACT_STRING = %s", pszValue);
                  break;

               case ADSTYPE_CASE_IGNORE_STRING :
                  (*ppAttr)->pADsValues->CaseIgnoreString = pszValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_IGNORE_STRING = %s", pszValue);
                  break;

               case ADSTYPE_PRINTABLE_STRING :
                  (*ppAttr)->pADsValues->PrintableString = pszValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_PRINTABLE_STRING = %s", pszValue);
                  break;

               default :
                  hr = E_INVALIDARG;
                  break;
               }
               //
               // Set the attribute dirty
               //
               pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
      
            }
            break;

         default:
            hr = E_INVALIDARG;
            break;
         }
      }
      else
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"No value present, changing control code to ADS_ATTR_CLEAR");
         //
         // Clear the attribute
         //
         (*ppAttr)->dwControlCode = ADS_ATTR_CLEAR;
         (*ppAttr)->dwNumValues = 0;

         //
         // Set the attribute dirty
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
      }

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BindToFSMOHolder
//
//  Synopsis:   Binds to the appropriate object which can be used to find a
//              particular FSMO owner
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if an invalid FSMO type was passed
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BindToFSMOHolder(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                         IN  const CDSCmdCredentialObject& refCredObject,
                         IN  FSMO_TYPE                  fsmoType,
                         OUT CComPtr<IADs>&             refspIADs)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, BindToFSMOHolder, hr);

    refspIADs = 0;
    CComBSTR sbstrDN;

    switch (fsmoType)
    {
        case SCHEMA_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = SCHEMA_FSMO");
            sbstrDN = refBasePathsInfo.GetSchemaNamingContext();
            break;
          }

        case RID_POOL_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = RID_POOL_FSMO");

            sbstrDN = refBasePathsInfo.GetDefaultNamingContext();

            CComBSTR sbstrPath;
            refBasePathsInfo.ComposePathFromDN(sbstrDN, sbstrPath);

            CComPtr<IADs> spIADsDefault;
            hr = DSCmdOpenObject(refCredObject,
                                 sbstrPath,
                                 IID_IADs,
                                 (void**)&spIADsDefault,
                                 true);
            if (FAILED(hr))
            {
                break;
            }

            CComVariant var;
            hr = spIADsDefault->Get(g_bstrIDManagerReference, &var);
            if (FAILED(hr))
            {
                break;
            }

            ASSERT(var.vt == VT_BSTR);
            sbstrDN = var.bstrVal;
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"rIDManagerReference = %s",
                         sbstrDN);

            break;
          }
            
        case PDC_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = PDC_FSMO");

            sbstrDN = refBasePathsInfo.GetDefaultNamingContext();
            break;
          }

        case INFRASTUCTURE_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = INFRASTUCTURE_FSMO");

            sbstrDN = refBasePathsInfo.GetDefaultNamingContext();
            break;
          }

        case DOMAIN_NAMING_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = DOMAIN_NAMING_FSMO");

            sbstrDN = L"CN=Partitions,";
            sbstrDN += refBasePathsInfo.GetConfigurationNamingContext();
            break;
          }
            
        default:
            ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (SUCCEEDED(hr))
    {
        CComBSTR sbstrPath;
        refBasePathsInfo.ComposePathFromDN(sbstrDN, sbstrPath);

        hr = DSCmdOpenObject(refCredObject,
                             sbstrPath,
                             IID_IADs,
                             (void**)&refspIADs,
                             true);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   FindFSMOOwner
//
//  Synopsis:   
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT FindFSMOOwner(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                      IN  const CDSCmdCredentialObject& refCredObject,
                      IN  FSMO_TYPE                  fsmoType,
                      OUT CComBSTR&                  refsbstrServerDN)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, FindFSMOOwner, hr);

    refsbstrServerDN.Empty();

    static const int nMaxReferrals = 10;
    int nIterations = 0;

    //
    // We will start the search with the current server
    //
    CComBSTR sbstrNextServer;
    sbstrNextServer = refBasePathsInfo.GetServerName();

    do
    {
        //
        // Initialize a new base paths info object on each iteration
        //
        CDSCmdBasePathsInfo nextPathsInfo;
        hr = nextPathsInfo.InitializeFromName(refCredObject,
                                              sbstrNextServer,
                                              true);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to initialize the base paths info for %s: hr = 0x%x",
                         sbstrNextServer,
                         hr);
            break;
        }

        //
        // Now bind to the fsmo holder for that server
        //
        CComPtr<IADs> spIADs;
        hr = BindToFSMOHolder(nextPathsInfo,
                              refCredObject,
                              fsmoType,
                              spIADs);
        if (FAILED(hr))
        {
            break;
        }

        //
        // Get the fSMORoleOwner property
        //
        CComVariant fsmoRoleOwnerProperty;
        hr = spIADs->Get(g_bstrFSMORoleOwner, &fsmoRoleOwnerProperty);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to get the fSMORoleOwner: hr = 0x%x",
                         hr);
            break;
        }

        //
        // The result here is in the form, "CN=NTDS Settings,CN=Machine,CN=..."
        // we need to just have "CN=Machine,CN=..."
        //
        CComBSTR sbstrMachineOwner;
        hr = CPathCracker::GetParentDN(fsmoRoleOwnerProperty.bstrVal, sbstrMachineOwner);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to get the parent DN of the FSMORoleOwner: hr = 0x%x",
                         hr);
            break;
        }

        CComBSTR sbstrMachinePath;
        nextPathsInfo.ComposePathFromDN(sbstrMachineOwner, sbstrMachinePath);

        //
        // Bind to the server object so we can get the dnsHostName to compare to the server name
        //
        CComPtr<IADs> spIADsServer;
        hr = DSCmdOpenObject(refCredObject,
                             sbstrMachinePath,
                             IID_IADs,
                             (void**)&spIADsServer,
                             true);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to bind to server object: hr = 0x%x",
                         hr);
            break;
        }

        //
        // Get the DNS host name
        //
        CComVariant varServerName;
        hr = spIADsServer->Get(g_bstrDNSHostName, &varServerName);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to get the dNSHostName: hr = 0x%x",
                         hr);
            break;
        }

        ASSERT(varServerName.vt == VT_BSTR);
        sbstrNextServer = varServerName.bstrVal;

        //
        // If the server name in the dNSHostName attribute matches the current
        // base paths info, then we found the owner
        //
		//Security Review:This is fine.
        if (0 == _wcsicmp(sbstrNextServer, nextPathsInfo.GetServerName()))
        {
            //
            // We found it
            //
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"The role owner is %s",
                         sbstrNextServer);
            refsbstrServerDN = sbstrMachineOwner;
            break;
        }

        ++nIterations;
    } while (nIterations < nMaxReferrals);

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   ValidateAndModifySAMName
//
//  Synopsis:   Looks for any illegal characters in the SamAccountName and
//              converts them to the replacementChar
//
//  Arguments:  [pszSAMName - IN/OUT]  : pointer to a string that contains the SamAccountName
//                                       illegal characters will be replaced
//              [pszInvalidChars - IN] : string containing the illegal characters
//
//  Returns:    HRESULT : S_OK if the name was valid and no characters had to be replaced
//                        S_FALSE if the name contained invalid characters that were replaced
//                        E_INVALIDARG
//
//  History:    21-Feb-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ValidateAndModifySAMName(PWSTR pszSAMName, 
                                 PCWSTR pszInvalidChars)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, ValidateAndModifySAMName, hr);

    static const WCHAR replacementChar = L'_';

    do
    {
        if (!pszSAMName ||
            !pszInvalidChars)
        {
            ASSERT(pszSAMName);
            ASSERT(pszInvalidChars);

            hr = E_INVALIDARG;
            break;
        }

        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"SAM name before: %s",
                     pszSAMName);

		//Security Review:This is fine.pszInvalidChars is Null Terminated.
        for (size_t idx = 0; idx < wcslen(pszInvalidChars); ++idx)
        {
            WCHAR* illegalChar = 0;
            do
            {
                illegalChar = wcschr(pszSAMName, pszInvalidChars[idx]);
                if (illegalChar)
                {
                    *illegalChar = replacementChar;
                    hr = S_FALSE;
                }
            } while (illegalChar);
        }
    } while (false);

    DEBUG_OUTPUT(LEVEL3_LOGGING,
                 L"SAM name after: %s",
                 pszSAMName);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Class:      GetEscapedElement
//
//  Purpose:    Calls IADsPathname::GetEscapedElement.  Uses LocalAlloc.
//
//  History:    28-Apr-2001 JonN     Created
//
//---------------------------------------------------------------------------
HRESULT GetEscapedElement( OUT PWSTR* ppszOut, IN PCWSTR pszIn )
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetEscapedElement, hr);

    CPathCracker pathCracker;
    CComBSTR sbstrIn = pszIn;
    CComBSTR sbstrEscaped;
    if (sbstrIn.Length() > 0) // handle empty path component
    {
        hr = pathCracker.GetEscapedElement(0,
                                           sbstrIn,
                                           &sbstrEscaped);
        if (FAILED(hr))
            return hr;
        else if (!sbstrEscaped)
            return E_FAIL;
    }
    *ppszOut = (LPWSTR)LocalAlloc(LPTR, (sbstrEscaped.Length()+1) * sizeof(WCHAR) );
    if (NULL == *ppszOut)
        return E_OUTOFMEMORY;

	//Security Review:This is fine. Memory is correctly allocted.
    if (sbstrIn.Length() > 0) // handle empty path component
        wcscpy( *ppszOut, sbstrEscaped );

    return hr;

} // GetEscapedElement

//+--------------------------------------------------------------------------
//
//  Class:      GetOutputDN
//
//  Purpose:    Converts an ADSI-escaped DN to one with DSCMD input escaping.
//              This way, the output DN can be piped as input to another
//              DSCMD command.
//
//  History:    08-May-2001 JonN     Created
//
//---------------------------------------------------------------------------
HRESULT GetOutputDN( OUT BSTR* pbstrOut, IN PCWSTR pszIn )
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetOutputDN, hr);

    if (NULL == pszIn || L'\0' == *pszIn)
    {
        *pbstrOut = SysAllocString(L"");
        return (NULL == *pbstrOut) ? E_OUTOFMEMORY : S_OK;
    }

    CPathCracker pathCracker;
    CComBSTR sbstrIn = pszIn;
    hr = pathCracker.Set(sbstrIn, ADS_SETTYPE_DN);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }

    long lnNumPathElements = 0;
    hr = pathCracker.GetNumElements( &lnNumPathElements );
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }
    else if (0 >= lnNumPathElements)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    hr = pathCracker.put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }

    CComBSTR sbstrOut;
    CComBSTR sbstrComma( L"," );
    for (long lnPathElement = 0;
         lnPathElement < lnNumPathElements;
         lnPathElement++)
    {
        CComBSTR sbstrElement;
        hr = pathCracker.GetElement( lnPathElement, &sbstrElement );
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            return hr;
        }

        // re-escape sbstrElement
        // JonN 10/17/01 476225 0x000A -> "\0A"
        //Security Review:This is fine.
        CComBSTR sbstrEscapedElement( (sbstrElement.Length()+1) * 3 );
        ::ZeroMemory( (BSTR)sbstrEscapedElement,
                      (sbstrElement.Length()+1) * 3 * sizeof(WCHAR) );
        LPWSTR pszEscapedElement = sbstrEscapedElement;
        for (LPWSTR pszElement = sbstrElement;
             L'\0' != *pszElement;
             pszElement++)
        {
            if (*pszElement < 0x0020)
            {
                // JonN 9/7/01 CRLF bug
                // JonN 10/17/01 476225 0x000A -> "\0A"
                *(pszEscapedElement++) = L'\\';
                *(pszEscapedElement++) = (*pszElement >= 0x0010) ? L'1' : L'0';
                *(pszEscapedElement++) = L"0123456789ABCDEF"[(*pszElement % 0x0010)];
            }
            else switch (*pszElement)
            {
            case L',':
            case L'\\':
                *(pszEscapedElement++) = L'\\';
                // fall through
            default:
                *(pszEscapedElement++) = *pszElement;
                break;
            }
        }

        if (!!sbstrOut)
            sbstrOut += sbstrComma;
        // cast to avoid CComBSTR::operator+= "bug"
        sbstrOut += (BSTR)sbstrEscapedElement;
    }

    *pbstrOut = sbstrOut.Detach();

    return hr;

} // GetOutputDN

//+--------------------------------------------------------------------------
//
//  Function:   GetQuotedDN
//
//  Purpose:    Takes the give DN and surrounds it with quotes
//
//  Returns:    the quoted DN
//
//  History:    10-Oct-2002 jeffjon Created
//
//---------------------------------------------------------------------------
CComBSTR GetQuotedDN(PWSTR pszDN)
{
   ENTER_FUNCTION(LEVEL3_LOGGING, GetQuotedDN);

   CComBSTR result = L"\"";

   result += pszDN;
   result += L"\"";

   DEBUG_OUTPUT(LEVEL3_LOGGING,
                L"Quoted DN: %s",
                (BSTR)result);

   return result;
}

//+--------------------------------------------------------------------------
//
//  Class:      ValidateDNSyntax
//
//  Purpose:    Validates each string in the null separated list as having
//              DN syntax
//
//  Returns:    The count of valid DNs in the list
//
//  History:    12-Oct-2001 JeffJon    Created
//
//---------------------------------------------------------------------------
UINT ValidateDNSyntax(IN PWSTR* ppszArray, UINT nStrings)
{
   ENTER_FUNCTION(MINIMAL_LOGGING, ValidateDNSyntax);

   if (!ppszArray ||
       nStrings < 1)
   {
      ASSERT(ppszArray);
      ASSERT(nStrings >= 1);

      return 0;
   }

   DEBUG_OUTPUT(LEVEL3_LOGGING,
                L"nStrings = %d",
                nStrings);

   // Use a single path cracker for performance reasons
   CPathCracker pathCracker;
   UINT result = 0;

   for (UINT idx = 0; idx < nStrings; ++idx)
   {
      if (ppszArray[idx])
      {
         HRESULT hr = pathCracker.Set(CComBSTR(ppszArray[idx]), ADS_SETTYPE_DN);
         if (SUCCEEDED(hr))
         {
            ++result;
         }
      }
   }

   DEBUG_OUTPUT(LEVEL3_LOGGING,
                L"result = %d",
                result);
   return result;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsServerGC
//
//  Purpose:    Checks if server is Global Catalog
//
//  Returns:    TRUE if GC else flase
//
//  History:    05-Jan-2002 hiteshr Created
//
//---------------------------------------------------------------------------
BOOL
IsServerGC(LPCWSTR pszServerName,
		   CDSCmdCredentialObject& refCredentialObject)
{	
	if(!pszServerName)
	{
		ASSERT(pszServerName);
		return FALSE;
	}

	HRESULT hr = S_OK;

	//Bind to RootDSE
	CComPtr<IADs> m_spRootDSE;
	CComBSTR bstrRootDSEPath = L"LDAP://";
	bstrRootDSEPath += pszServerName;
	bstrRootDSEPath += L"/RootDSE";

	hr = DSCmdOpenObject(refCredentialObject,
                         bstrRootDSEPath,
                         IID_IADs,
                         (void**)&m_spRootDSE,
                         false);

	if(FAILED(hr))
		return FALSE;
   
	//Read isGlobatCatalogReady attribute
	VARIANT Default;
	VariantInit(&Default);
	hr = m_spRootDSE->Get (CComBSTR(L"isGlobalCatalogReady"), &Default);
	if(FAILED(hr))
		return FALSE;

	BOOL bRet = FALSE;
	
	ASSERT(Default.vt == VT_BSTR);
	
	//Security Review:This is fine.
	if(_wcsicmp(Default.bstrVal,L"TRUE") == 0)
		bRet= TRUE;
	::VariantClear(&Default);

	return bRet;
}
//+--------------------------------------------------------------------------
//
//  Function:   SetAccountEntry
//
//  Synopsis:   Sets acct to make it a SID
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    02-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT SetAccountEntry(PCWSTR ,
                        const CDSCmdBasePathsInfo& refBasePathsInfo,
                        const CDSCmdCredentialObject& refCredentialObject,
                        const PDSOBJECTTABLEENTRY pObjectEntry,
                        const ARG_RECORD& argRecord,
                        DWORD dwAttributeIdx,
                        PADS_ATTR_INFO* ppAttr)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetAccountEntry, hr);
    LPWSTR lpszDN = NULL;

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pObjectEntry ||!ppAttr)
        {
            ASSERT(pObjectEntry);
            ASSERT(ppAttr);
            hr = E_INVALIDARG;
            break;
        }

        // TODO: Need to provide the first param
        hr = ConvertTrusteeToDN(NULL, argRecord.strValue, &lpszDN);
        if(FAILED(hr))
        {
            break;
        }

        PSID pSid = NULL;
        hr = GetDNSid(lpszDN, refBasePathsInfo,
            refCredentialObject, &pSid);
        if(FAILED(hr))
        {
            break;
        }

        //
        // Mark the table entry as read
        //
        pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

        // Allocate the ADSVALUE to the attr array
        *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
        (*ppAttr)->pADsValues = new ADSVALUE;
        if (!(*ppAttr)->pADsValues)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
        (*ppAttr)->dwNumValues = 1;

        ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

        // Set the ADSVALUE fields
        pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->OctetString.dwLength = GetLengthSid(pSid);
        pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->OctetString.lpValue = (LPBYTE) pSid;

    } while (false);

    if(lpszDN)
        LocalFree(lpszDN);

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   TranslateNameXForest
//
//  Synopsis:   Takes an account name and returns its SID
//
//  Arguments:  [szDomain - IN]  : Domain where the account lives or NULL
//
//              [lpAccountName - IN] : Account you want to translate
//
//              [AccountNameFormat - IN]: Name format (can be unknown)
//
//              [DesiredNameFormat - IN]: New name format
//
//              [lpTranslatedName - OUT]: return name buffer 
//                                        (free with LocalFree)
//
//  Returns:    BOOL : TRUE if successful, else FALSE. Call GetLastError for
//              more error info
//
//  History:    19-Aug-2002   ronmart   Created from 
//                          ds\security\gina\gpconsole\gprsop\rsopwizard.cpp
//
//---------------------------------------------------------------------------
BOOL TranslateNameXForest(LPCWSTR szDomain, LPCWSTR lpAccountName, 
                          DS_NAME_FORMAT AccountNameFormat, 
                          DS_NAME_FORMAT DesiredNameFormat,
                          LPWSTR *lpTranslatedName)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, TranslateNameXForest, hr);

    DWORD                   dwErr       = 0;
    PDOMAIN_CONTROLLER_INFO pDCInfo     = NULL;
    BOOL                    bRetry      = FALSE;
    HANDLE                  hDS         = NULL;
    PDS_NAME_RESULT         pResult     = NULL;
    BOOL                    bRet        = FALSE;
    LPWSTR                  szTransName = NULL;


    DEBUG_OUTPUT(FULL_LOGGING, 
        L"TranslateNameXForest: Resolving name <%s> at Domain <%s>",
        lpAccountName, szDomain ? szDomain : L"");

    //
    // get a DC and bind to it. Make sure to force rediscover a DC if the bind fails
    //
    for (;;) 
    {
        dwErr = DsGetDcName( NULL, szDomain ? szDomain : L"", NULL, NULL,
                             DS_GC_SERVER_REQUIRED               |
                             DS_DIRECTORY_SERVICE_REQUIRED       |
                             DS_RETURN_DNS_NAME                  | 
                             (bRetry ? DS_FORCE_REDISCOVERY : 0) |
                             0, &pDCInfo);

        if (dwErr == NO_ERROR) 
        {
            dwErr = DsBind(pDCInfo->DomainControllerName, NULL, &hDS);

            if (dwErr == NO_ERROR)
            {
                break;
            }
            else 
            {
                DEBUG_OUTPUT(FULL_LOGGING, 
                    L"TranslateNameXForest: Failed to bind to DC <%s> with error %d", 
                    pDCInfo->DomainControllerName, dwErr );
                NetApiBufferFree(pDCInfo);
                pDCInfo = NULL;
            }
        }
        else 
        {
            DEBUG_OUTPUT(FULL_LOGGING, 
                L"TranslateNameXForest: Failed to get DC for domain <%s> with error %d", 
                szDomain ? szDomain : L"", dwErr );
        }                                                 

        //
        // Failed to bind to a DC. bail
        //
        if (bRetry)
        {
            goto Exit;
        }

        bRetry = TRUE;                          
    }

    DEBUG_OUTPUT(FULL_LOGGING, L"TranslateNameXForest: DC selected is <%s>", 
        pDCInfo->DomainControllerName );

    //
    // Now crack names with the DC that is bound
    //

    dwErr = DsCrackNames( hDS,
                          DS_NAME_FLAG_TRUST_REFERRAL,
                          AccountNameFormat,
                          DesiredNameFormat,
                          1,
                          &lpAccountName,
                          &pResult);

    if (dwErr != DS_NAME_NO_ERROR) 
    {
        DEBUG_OUTPUT(FULL_LOGGING, 
            L"TranslateNameXForest: Failed to crack names with error %d", dwErr );
        goto Exit;
    }

    if ( pResult->cItems == 0 )
    {
        DEBUG_OUTPUT(FULL_LOGGING, 
            L"TranslateNameXForest: Failed to return enough result items" );
        dwErr = ERROR_INVALID_DATA;
        goto Exit;
    }

    if ( pResult->rItems[0].status == DS_NAME_NO_ERROR ) 
    {
        //
        // In case of no error, return the resolved name
        //
        DWORD dwTransNameLength = 1 + lstrlen(pResult->rItems[0].pName);
        szTransName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwTransNameLength ));

        if (!szTransName) {
            DEBUG_OUTPUT(FULL_LOGGING, 
                L"TranslateNameXForest: Failed to allocate memory for domain" );
            dwErr = GetLastError();
            goto Exit;
        }

        HRESULT hr = StringCchCopy(szTransName, dwTransNameLength, pResult->rItems[0].pName);

        if(FAILED(hr)) 
        {
            if (szTransName)
                LocalFree(szTransName);

            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

       *lpTranslatedName = szTransName;
        szTransName = NULL;
    }
    else if( pResult->rItems[0].status == DS_NAME_ERROR_TRUST_REFERRAL)
    {
        return TranslateNameXForest(pResult->rItems[0].pDomain, 
                          lpAccountName, 
                          AccountNameFormat, 
                          DesiredNameFormat,
                          lpTranslatedName);
    }
    else 
    {
        //
        // remap the error code to win32 error
        //
        DEBUG_OUTPUT(FULL_LOGGING, 
            L"TranslateNameXForest: DsCrackNames failed with error %d", 
            pResult->rItems[0].status );
//        dwErr = MapDsNameError(pResult->rItems[0].status);
        goto Exit;
    }

    bRet = TRUE;

Exit:
   if (pDCInfo)
        NetApiBufferFree(pDCInfo);

    if (hDS)
        DsUnBind(&hDS);

    if (pResult)
        DsFreeNameResult(pResult);

    if(!bRet)
        SetLastError(dwErr);

    return bRet;
}
//+--------------------------------------------------------------------------
//
//  Function:   GetAttrFromDN
//
//  Synopsis:   
//
//  Arguments:  [pszDN - IN]:               DN to query
//              [pszAttribute - IN]:        Attribute to retrieve
//              [refBasePathsInfo - IN]:    LDAP base path
//              [refCredentialObject - IN]: Credentials to use for the query
//              [ppAttrInfo- OUT]:          Result returned. The caller must 
//                                          call FreeADsMem to free the array
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetAttrFromDN(PCWSTR pszDN, PWSTR pszAttribute,
                     const CDSCmdBasePathsInfo& refBasePathsInfo,
                     const CDSCmdCredentialObject& refCredentialObject,
                     PADS_ATTR_INFO* ppAttrInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, GetAttrFromDN, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!pszDN || !pszAttribute)
      {
         hr = E_INVALIDARG;
         break;
      }

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      // Build an attribute array for the requested value
      static const DWORD dwAttrCount = 1;
      PWSTR pszAttrs[] = { pszAttribute };
      DWORD dwAttrsReturned = 0;

      hr = spDirObject->GetObjectAttributes(pszAttrs,
                                            dwAttrCount,
                                            ppAttrInfo,
                                            &dwAttrsReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
             L"GetObjectAttributes for %s failed: hr = 0x%x",
             pszAttribute, hr);
         break;
      }

   } while (false);

   if(FAILED(hr) && *ppAttrInfo)
        FreeADsMem(*ppAttrInfo);

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeToDN
//
//  Synopsis:   Get the DN for an -acct param
//
//  Arguments:  [lpszDomain - IN]:  Domain to query or NULL for local
//              [lpszTrustee - IN]: Acct to resolve
//              [lpszDN - OUT]:     Returns the DN. Use LocalFree when done
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT ConvertTrusteeToDN(LPCWSTR lpszDomain, LPCWSTR lpszTrustee, 
                           LPWSTR* lpszDN)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, ConvertTrusteeToDN, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!lpszTrustee || !lpszDN || *lpszDN != NULL)
      {
         hr = E_INVALIDARG;
         break;
      }
      if(!TranslateNameXForest(lpszDomain, 
                               lpszTrustee, 
                               DS_UNKNOWN_NAME,
                               DS_FQDN_1779_NAME, 
                               lpszDN))
      {
        hr = E_UNEXPECTED;
        break;
      }

   } while (false);

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   GetDNSid
//
//  Synopsis:   Given a DN the objectSid value will be retrieved and returned
//              as a SID
//
//  Arguments:  [lpszDN - IN]:              DN to query
//              [refBasePathsInfo - IN]:    LDAP settings
//              [refCredentialObject - IN]: Credentials to use for the query
//              [pSid - OUT]:               A SID if successful. Call LocalFree
//                                          when done.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetDNSid(LPCWSTR lpszDN,
                 const CDSCmdBasePathsInfo& refBasePathsInfo,
                 const CDSCmdCredentialObject& refCredentialObject,
                 PSID* pSid)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, GetDNSid, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!lpszDN)
      {
         hr = E_INVALIDARG;
         break;
      }

      // Get the objectSid
      PADS_ATTR_INFO pSidAttrInfo = NULL;
      hr = GetAttrFromDN(lpszDN, L"objectSid",
                     refBasePathsInfo,
                     refCredentialObject,
                     &pSidAttrInfo);
      if(FAILED(hr))
      {
          hr = E_UNEXPECTED;
          break;
      }

      // Sids are stored in octet strings so validate the return value
      if(!pSidAttrInfo || pSidAttrInfo->dwADsType != ADSTYPE_OCTET_STRING)
      {
          hr = E_UNEXPECTED;
          break;
      }

      // Validate that we have a valid sid
      if(!IsValidSid(pSidAttrInfo->pADsValues->OctetString.lpValue))
      {
        hr = E_UNEXPECTED;
        break;
      }

      // Alloc the return buffer
      SIZE_T size = GetLengthSid(pSidAttrInfo->pADsValues->OctetString.lpValue);
      *pSid = (PSID) LocalAlloc(LPTR, size);
      if(NULL == *pSid)
      {
          hr = E_OUTOFMEMORY;
          break;
      }

      // Copy the sid to the return buffer
      CopyMemory(*pSid, pSidAttrInfo->pADsValues->OctetString.lpValue, size);

      // Confirm that the copy was successful
      if(!IsValidSid(*pSid))
      {
        ASSERT(FALSE);
        LocalFree(*pSid);
        hr = E_UNEXPECTED;
        break;
      }

      // Free the query result
      FreeADsMem(pSidAttrInfo);

   } while (false);

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   IsBSTRInVariantArray
//
//  Synopsis:   Examines a BSTR variant or a variant array of BSTR's to see
//              if bstrSearch is in refvar
//
//  Arguments:  [refvar - IN]:     A variant that contains either a BSTR or
//                                 an array of BSTR's
//                                 
//              [bstrSearch - IN]: String to look for in refvar
//                                 
//              [bFound - OUT]:    true if bstrSearch is found in refvar,
//                                 else false
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_UNEXPECTED in most failure cases
//                        Anything else is a failure code from call that 
//                        returns a hr
//
//  Note:       This code was derrived from admin\snapin\adsiedit\common.cpp
//
//  History:    05-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT  IsBSTRInVariantArray(VARIANT& refvar, CComBSTR& bstrSearch, 
                              bool& bFound)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, IsBSTRInVariantArray, hr);

    long start = 0;
    long end = 0;
    bFound = false;

    // If a single value comes back
    if ( !(V_VT(&refvar) &  VT_ARRAY)  )
    {
        // and it is not a BSTR then abort
        if ( V_VT(&refvar) != VT_BSTR )
        {
                return E_UNEXPECTED;
        }
        // Is the search string the same as the variant value?
        bFound = (lstrcmpi(bstrSearch, V_BSTR(&refvar)) == 0);
        return hr;
    }

    // Otherwise it is a SafeArray so get the array
    SAFEARRAY *saAttributes = V_ARRAY( &refvar );

    // Verify array returned
    if(NULL == saAttributes)
        return E_UNEXPECTED;

    // Figure out the dimensions of the array.
    hr = SafeArrayGetLBound( saAttributes, 1, &start );
    if( FAILED(hr) )
        return hr;

    hr = SafeArrayGetUBound( saAttributes, 1, &end );
    if( FAILED(hr) )
        return hr;

    // Search the array elements and abort if a match is found
    CComVariant SingleResult;
    for ( long idx = start; (idx <= end) && !bFound; idx++   ) 
    {

        hr = SafeArrayGetElement( saAttributes, &idx, &SingleResult );
        if( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&SingleResult) != VT_BSTR )
        {
            // If not BSTR then go to the next element
            continue; 
        }
        // Is this variant bstr value the same as the search string?
        bFound = (lstrcmpi(bstrSearch, V_BSTR(&SingleResult)) == 0);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidatePartition
//
//  Synopsis:   Confirms that the partion exists in the RootDSE namingContexts
//
//  Arguments:  [basePathsInfo - IN]:    DSAdd's CDSCmdBasePathsInfo object 
//                                       for getting the RootDSE
//              [pszObjectDN - IN]:      Partion to examine
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_UNEXPECTED in most failure cases
//                        E_OUTOFMEMORY if a LocalAlloc fails
//                        Anything else is a failure code from an ADSI call
//
//  History:    12-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT ValidatePartition(CDSCmdBasePathsInfo& basePathsInfo, LPCWSTR pszObjectDN)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, ValidatePartition, hr);

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pszObjectDN || !basePathsInfo.IsInitialized())
        {
            ASSERT(pszObjectDN);
            ASSERT(basePathsInfo.IsInitialized());
            hr = E_INVALIDARG;
            break;
        }
        CComVariant var;
        CComPtr<IADs> spRootDSE = basePathsInfo.GetRootDSE();
        hr = spRootDSE->Get(CComBSTR(L"namingContexts"), &var);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL5_LOGGING, 
                L"Failed to get the namingContexts from the RootDSE: hr = 0x%x",
                hr);
            hr = E_INVALIDARG;
            break;
        }

        // Verify that the partition given really exists
        bool bFound = false;
        CComBSTR str(pszObjectDN);
        hr = IsBSTRInVariantArray(var, str, bFound);
        if(FAILED(hr) || (!bFound))
        {
            DEBUG_OUTPUT(LEVEL5_LOGGING, 
                L"IsBSTRInVariantArray didn't find the partion DN: hr = 0x%x",
                hr);
            hr = E_INVALIDARG;
            break;
        }

    } while(false);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetQuotaContainerDN
//
//  Synopsis:   Takes the partition dn and merges it with the NTDS Quotas 
//              string (from wellKnownObjects GUID)
//
//  Arguments:  [basePathsInfo - IN]:    
//              [credentialObject - IN]: Creditials object used for 
//                                       binding to other objects
//              [lpszPartitionDN - IN]:  The partition to bind to
//              [pszNewDN - OUT]:        The munged quotas DN to return
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_UNEXPECTED in most failure cases
//                        E_OUTOFMEMORY if a LocalAlloc fails
//                        Anything else is a failure code from an ADSI call
//
//  History:    05-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetQuotaContainerDN(IN  CDSCmdBasePathsInfo& basePathsInfo, 
                            IN  const CDSCmdCredentialObject& credentialObject, 
                            IN  LPCWSTR lpszPartitionDN, 
                            OUT PWSTR*  pszNewDN)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, GetQuotaContainerDN, hr);
   
   LPWSTR pszNewObjectDN = NULL;

   do // false loop
   {
        //
        // Verify parameters
        //
        if (!lpszPartitionDN || !basePathsInfo.IsInitialized() || !pszNewDN)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Make sure the partition specified really exists
        hr = ValidatePartition(basePathsInfo, lpszPartitionDN);
        if(FAILED(hr))
        {
            break;
        }

        // Get the abstract schema path from the source domain
        CComBSTR bstrSchemaPath = basePathsInfo.GetAbstractSchemaPath();
        bstrSchemaPath += L"/msDS-QuotaControl";

        //  Bind to the schema definition of the quota control
        CComPtr<IADsClass> spIADsItem;
        hr = DSCmdOpenObject(credentialObject,
                            bstrSchemaPath,
                            IID_IADsClass,
                            (void**)&spIADsItem,
                            false);
        if (FAILED(hr) || (spIADsItem.p == 0))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"DsCmdOpenObject failure - couldn't bind to msDS-QuotaControl: 0x%08x",
                hr);
            break;
        }
        
        // Build the DN to the GUID of "NTDS Quotas"
        CPathCracker pathcracker;
        hr = pathcracker.Set(CComBSTR(lpszPartitionDN), ADS_SETTYPE_DN );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"pathcracker Set.failure: [%s] hr = 0x%08x",
                        lpszPartitionDN, hr);
            hr = E_UNEXPECTED;
            break;
        }

        // Use the wellKnownObject GUID string for NTDS Quotas
        CComBSTR strNTDSQuotasContainer(L"WKGUID=");
        strNTDSQuotasContainer += GUID_NTDS_QUOTAS_CONTAINER_W;
        hr = pathcracker.AddLeafElement( strNTDSQuotasContainer );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"pathcracker.AddLeafElement failure: [WKGUID] hr = 0x%08x",
                        hr);
            hr = E_UNEXPECTED;
            break;
        }

        CComBSTR bstrDN;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &bstrDN );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"pathcracker.Retrieve failure: hr = 0x%08x",
                        hr);
            hr = E_UNEXPECTED;
            break;
        }

        // Alloc a new string to hold bstrDN plus <>
        SIZE_T cbBuf = SysStringByteLen(bstrDN) + (3 * sizeof(WCHAR));
        pszNewObjectDN = (LPWSTR) LocalAlloc(LPTR, cbBuf);

        if(NULL == pszNewObjectDN)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // Build a LDAP string to the well known quota object
        hr = StringCbPrintfW(pszNewObjectDN, cbBuf, L"<%s>", bstrDN.m_str);
        if(FAILED(hr))
        {
            ASSERT(FALSE);
            break;
        }

        // Get a path that accounts for -domain or -server
        CComBSTR sbstrObjectPath;
        basePathsInfo.ComposePathFromDN(pszNewObjectDN, sbstrObjectPath,
            DSCMD_LDAP_PROVIDER);

        // Bind to it
         CComPtr<IADs> spADs;
         hr = DSCmdOpenObject(credentialObject,
                              sbstrObjectPath,
                              IID_IADs,
                              (void**)&spADs,
                              false);

        if (FAILED(hr) || (spADs.p == 0))
        {
            ASSERT( !!spADs );
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"DsCmdOpenObject failure: hr = 0x%08x, %s",
                        bstrDN, hr);
            break;
        }

        // Resolve the GUID into a string (usually CN=NTDS Quotas,<DN>)
        CComVariant var;
        hr = spADs->Get(CComBSTR(L"distinguishedName"), &var);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Failed to retrieve the distinguishedName: hr = 0x%x",
                         hr);
            hr = E_UNEXPECTED;
            break;
        }

        // Convert the variant dn to a bstr
        CComBSTR bstrNewDN(V_BSTR(&var));

        // Alloc the return string to hold the munged name
        *pszNewDN = (PWSTR) LocalAlloc(LPTR, SysStringByteLen(bstrNewDN) 
            + sizeof(WCHAR));

        if(NULL == pszNewDN)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // Copy the resolved DN into the new objectDN string
        lstrcpy(*pszNewDN, bstrNewDN);

   } while (false);

   // cleanup
   if(pszNewObjectDN)
       LocalFree(pszNewObjectDN);

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeToNT4Name
//
//  Synopsis:   Get the DN for an -acct param
//
//  Arguments:  [lpszDomain - IN]:  Domain to query or NULL for local
//              [lpszTrustee - IN]: Acct to resolve
//              [lpszNT4 - OUT]:     Returns the NT4 name. 
//                                  Use LocalFree when done
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT ConvertTrusteeToNT4Name(LPCWSTR lpszDomain, LPCWSTR lpszTrustee, 
                                LPWSTR* lpszNT4)
{
    ENTER_FUNCTION_HR(LEVEL5_LOGGING, ConvertTrusteeToNT4Name, hr);

    do // false loop
    {
        //
        // Validate parameters
        //
        if (!lpszTrustee || !lpszNT4 || *lpszNT4 != NULL)
        {
            hr = E_INVALIDARG;
            break;
        }
        if(!TranslateNameXForest(lpszDomain, 
            lpszTrustee, 
            DS_UNKNOWN_NAME,
            DS_NT4_ACCOUNT_NAME, 
            lpszNT4))
        {
            hr = E_UNEXPECTED;
            break;
        }
        // Replace any backslashes with an underscore
        LPWSTR p = *lpszNT4;
        while(*p++)
        {
            if(*p == L'\\')
                *p = L'_';
        }
    } while (false);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsUtil.h
//
//  Contents:  Utility functions for working with Active Directory
//
//  History:   05-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _DSUTIL_H_
#define _DSUTIL_H_

// Define a symbol for the bit in the options flag on a NTDSDSA object
// that determines if the server is a global catalog

#define SERVER_IS_GC_BIT   0x1
#include <Ntdsapi.h>
#include <Sddl.h>
//+--------------------------------------------------------------------------
//
//  Class:      CDSCmdCredentialObject
//
//  Purpose:    Object for maintaining username and an encrypted password
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDSCmdCredentialObject
{
public :
   //
   // Constructor
   //
	CDSCmdCredentialObject();

   //
   // Destructor
   //
	~CDSCmdCredentialObject();

   //
   // Public accessor methods
   //
	PCWSTR   GetUsername() const { return m_sbstrUsername; }
	HRESULT  SetUsername(PCWSTR pszUsername);

	HRESULT  GetPassword(PWSTR *ppszPassword) const;
	HRESULT  SetPassword(PCWSTR pszPassword);
	HRESULT  SetEncryptedPassword(DATA_BLOB* pEncryptedPasswordDataBlob);

	bool     UsingCredentials() const { return m_bUsingCredentials; }
	void     SetUsingCredentials(const bool bUseCred) { m_bUsingCredentials = bUseCred; }

private :
   //
   // Private data members
   //
	CComBSTR m_sbstrUsername;
	DATA_BLOB m_EncryptedPasswordDataBlob;
	bool     m_bUsingCredentials;
};

typedef enum
{
   DSCMD_LDAP_PROVIDER = 0,
   DSCMD_GC_PROVIDER
}  DSCMD_PROVIDER_TYPE;

//+--------------------------------------------------------------------------
//
//  Class:      CDSCmdBasePathsInfo
//
//  Purpose:    Object for storing and retrieving the paths for the well
//              known naming contexts
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDSCmdBasePathsInfo
{
public:
   //
   // Constructor
   //
   CDSCmdBasePathsInfo();

   //
   // Destructor
   //
   ~CDSCmdBasePathsInfo();

   //
   // Public accessor methods
   //
   HRESULT     InitializeFromName(const CDSCmdCredentialObject& refCredentialObject,
                                 PCWSTR pszServerOrDomain,
                                 bool bServerName = false);
   bool        IsInitialized() const             { return m_bInitialized; }
   CComBSTR    GetProviderAndServerName() const  { return m_sbstrProviderAndServerName; }
   CComBSTR    GetGCProvider() const             { return m_sbstrGCProvider; }
   CComBSTR    GetServerName() const             { return m_sbstrServerName; }
   CComBSTR    GetAbstractSchemaPath() const     { return m_sbstrAbstractSchemaPath; }
   IADs*       GetRootDSE() const                { return m_spRootDSE; }
   CComBSTR    GetConfigurationNamingContext() const;
   CComBSTR    GetSchemaNamingContext() const;
   CComBSTR    GetDefaultNamingContext() const;

   //
   // Other helpful methods
   //
   void        ComposePathFromDN(PCWSTR pszDN, 
                                 CComBSTR& refsbstrPath, 
                                 DSCMD_PROVIDER_TYPE nProviderType = DSCMD_LDAP_PROVIDER) const;

   HRESULT     GetDomainMode(const CDSCmdCredentialObject& refCredObject,
                             bool& bMixedMode) const;

private:
   //
   // Private data members
   //
   bool        m_bInitialized;


   CComBSTR    m_sbstrProviderAndServerName;
   CComBSTR    m_sbstrGCProvider;
   CComBSTR    m_sbstrServerName;
   CComBSTR    m_sbstrAbstractSchemaPath;

   mutable bool        m_bModeInitialized;
   mutable bool        m_bDomainMode;
   mutable CComBSTR    m_sbstrConfigNamingContext;
   mutable CComBSTR    m_sbstrSchemaNamingContext;
   mutable CComBSTR    m_sbstrDefaultNamingContext;

   CComPtr<IADs> m_spRootDSE;
};

//////////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   DSCmdOpenObject
//
//  Synopsis:   A wrapper around ADsOpenObject
//
//  Arguments:  [refCredentialObject - IN] : a reference to a credential management object
//              [pszPath - IN]           : a pointer to a NULL terminated wide character
//                                         string that contains the ADSI path of the
//                                         object to connect to
//              [refIID - IN]            : the interface ID of the interface to return
//              [ppObject - OUT]         : a pointer which is to receive the interface pointer
//              [bBindToServer - IN]     : true if the path contains a server name,
//                                         false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DSCmdOpenObject(const CDSCmdCredentialObject& refCredentialObject,
                        PCWSTR pszPath,
                        REFIID refIID,
                        void** ppObject,
                        bool bBindToServer);

//+--------------------------------------------------------------------------
//
//  Function:   GetErrorMessage
//
//  Synopsis:   Retrieves the error message associated with the HRESULT by 
//              using FormatMessage
//
//  Arguments:  [hr - IN]                 : HRESULT for which the error 
//                                          message is to be retrieved
//              [sbstrErrorMessage - OUT] : Receives the error message
//
//  Returns:    bool : true if the message was formatted properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool GetErrorMessage(HRESULT hr, CComBSTR& sbstrErrorMessage);

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [pszMessage - IN]: string of an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         PCWSTR pszMessage = NULL);

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [nStringID - IN] : Resource ID an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         UINT nStringID);

//+--------------------------------------------------------------------------
//
//  Function:   DisplaySuccessMessage
//
//  Synopsis:   Displays a success message for the command
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplaySuccessMessage(PCWSTR pszCommand,
                           PCWSTR pszName);



//+--------------------------------------------------------------------------
//
//  Function:   WriteStringIDToStandardOut
//
//  Synopsis:   Loads the String Resource and displays on Standardout
//
//  Arguments:  nStringID :	Resource ID	
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   hiteshr Created
//
//---------------------------------------------------------------------------
bool WriteStringIDToStandardOut(UINT nStringID);

//+--------------------------------------------------------------------------
//
//  Function:   WriteStringIDToStandardErr
//
//  Synopsis:   Loads the String Resource and displays on StandardErr
//
//  Arguments:  nStringID :	Resource ID	
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    14-June-2001 hiteshr Created
//
//---------------------------------------------------------------------------
bool WriteStringIDToStandardErr(UINT nStringID);


/////////////////////////////////////////////////////////////////////////////////////////

//
// Forward declarations
//
struct _DSAttributeTableEntry;

//+--------------------------------------------------------------------------
//
//  Struct:     _DSObjectTableEntry
//
//  Purpose:    Definition of a table entry that describes what attributes
//              are exposed on an specific object class
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
typedef struct _DSObjectTableEntry
{
   //
   // The objectClass of the object to be created or modified
   //
   PCWSTR pszObjectClass;

   //
   // The command line string used to determine the object class
   // This is not always identical to pszObjectClass
   //
   PCWSTR pszCommandLineObjectType;

   //
   // The table to merge with the common switches for the parser
   //
   ARG_RECORD* pParserTable;

   //
   // The ID of the Usage help text for this 
   //
   UINT* nUsageID;

   //
   // A count of the number of attributes in the table above
   //
   DWORD dwAttributeCount;

   //
   // A pointer to a table of attributes that can be modified or set on this class
   //
   _DSAttributeTableEntry** pAttributeTable; 

   // Some sort of creation function
} DSOBJECTTABLEENTRY, *PDSOBJECTTABLEENTRY;

//+-------------------------------------------------------------------------
// 
//  Type:      PATTRIBUTEEVALFUNC
//
//  Synopsis:  The definition of a function that prepares the command line
//             string value to be set in the DS.
//
//  Note:      *ppAttr should be set to NULL if this function does not need
//             to create a new unique ADS_ATTR_INFO structure in the array
//             to be set on the object.  For instance, there are many bits
//             in the user account control that are represented by different
//             command line flags but we really only need one entry for the
//             userAccountControl attribute.
//
//  Returns:   S_OK if the pAttr members were successfully set.
//             S_FALSE if the function failed but displayed its own error message. 
//             If the return value is S_FALSE then the function should call
//             SetLastError() with the error code.
//             Otherwise the pAttr info will not be used when making 
//             the modifications to the object and an error will be reported
//
//  History:   08-Sep-2000    JeffJon     Created
//
//---------------------------------------------------------------------------
typedef HRESULT (*PATTRIBUTEEVALFUNC)(PCWSTR pszPath,
                                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                                      const CDSCmdCredentialObject& refCredentialObject,
                                      const PDSOBJECTTABLEENTRY pObjectEntry, 
                                      const ARG_RECORD& argRecord,
                                      DWORD dwAttributeIdx,
                                      PADS_ATTR_INFO* ppAttr);

//+--------------------------------------------------------------------------
//
// Flags for the _DSAttributeDescription and _DSAttributeTableEntry 
// struct dwFlags field
//
//---------------------------------------------------------------------------
#define  DS_ATTRIBUTE_DIRTY         0x00000001
#define  DS_ATTRIBUTE_READ          0x00000002
#define  DS_ATTRIBUTE_ONCREATE      0x00000004
#define  DS_ATTRIBUTE_POSTCREATE    0x00000008
#define  DS_ATTRIBUTE_REQUIRED      0x00000010
#define  DS_ATTRIBUTE_NOT_REUSABLE  0x00000020

//+--------------------------------------------------------------------------
//
//  Struct:     _DSAttributeDescription
//
//  Purpose:    Definition of a table entry that describes an attribute
//              This was split out from _DSAttributeTableEntry so that 
//              more than one entry could point to the same attribute.
//              For instance, the userAccountControl bits are separate
//              command line flags but all use the same attribute.  This
//              way we only need to read the attribute once and set it once.
//
//  History:    13-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
typedef struct _DSAttributeDescription
{
   //
   // The ADS_ATTR_INFO struct that defines how this attribute will be set
   //
   ADS_ATTR_INFO  adsAttrInfo;

   //
   // Flags that are used to determine how and when the attribute can be set,
   // if the adsAttrInfo has been retrieved and/or set.
   // For instance, group membership can only be set after the user object is
   // created
   //
   DWORD          dwFlags;      
} DSATTRIBUTEDESCRIPTION, *PDSATTRIBUTEDESCRIPTION;

//+--------------------------------------------------------------------------
//
//  Struct:     _DSAttributeTableEntry
//
//  Purpose:    Definition of a table entry that describes an attribute
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
typedef struct _DSAttributeTableEntry
{
   //
   // The name of the attribute
   //
   PWSTR          pszName;

   //
   // The unique identifier for this attribute that cooresponds to
   // the command line switch
   //
   UINT           nAttributeID;

   //
   // Flags that represent when this attribute can be set in relation to
   // the objects creation
   //
   DWORD          dwFlags;

   //
   // Pointer to the description of the attribute
   //
   PDSATTRIBUTEDESCRIPTION pAttrDesc;

   //
   // A function that can evaluate the value string passed in and make
   // it ready for setting on the object
   //
   PATTRIBUTEEVALFUNC pEvalFunc;

   //
   // Undefined data that is static and specific for the entry
   //
   void* pVoid;

} DSATTRIBUTETABLEENTRY, *PDSATTRIBUTETABLEENTRY;


//+--------------------------------------------------------------------------
//
//  Function:   ReadGroupType
//
//  Synopsis:   Reads the group type from the group specified by the given DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [plType - OUT]        : returns the currect group type
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadGroupType(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      long* plType);

//+--------------------------------------------------------------------------
// Function to be used in the attribute table for evaluating the command line
// strings
//---------------------------------------------------------------------------

HRESULT FillAttrInfoFromObjectEntry(PCWSTR pszDN,
                                    const CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    const PDSOBJECTTABLEENTRY pObjectEntry,
                                    const ARG_RECORD& argRecord,
                                    DWORD dwAttributeIdx,
                                    PADS_ATTR_INFO* ppAttr);

HRESULT ResetUserPassword(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD dwAttributeIdx,
                          PADS_ATTR_INFO* ppAttr);

HRESULT ResetComputerAccount(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr);

HRESULT PasswordNotRequired(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr);

HRESULT DisableAccount(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr);

HRESULT SetMustChangePwd(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT ChangeMustChangePwd(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr);

HRESULT PwdNeverExpires(PCWSTR pszDN,
                        const CDSCmdBasePathsInfo& refBasePathsInfo,
                        const CDSCmdCredentialObject& refCredentialObject,
                        const PDSOBJECTTABLEENTRY pObjectEntry,
                        const ARG_RECORD& argRecord,
                        DWORD dwAttributeIdx,
                        PADS_ATTR_INFO* ppAttr);

HRESULT ReversiblePwd(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr);

HRESULT AccountExpires(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr);

HRESULT SetCanChangePassword(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr);

HRESULT ChangeCanChangePassword(PCWSTR pszDN,
                                const CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                const PDSOBJECTTABLEENTRY pObjectEntry,
                                const ARG_RECORD& argRecord,
                                DWORD dwAttributeIdx,
                                PADS_ATTR_INFO* ppAttr);

HRESULT SetGroupScope(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr);

HRESULT ChangeGroupScope(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT SetGroupSecurity(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT ChangeGroupSecurity(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr);

HRESULT ModifyGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD dwAttributeIdx,
                           PADS_ATTR_INFO* ppAttr);

HRESULT RemoveGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD dwAttributeIdx,
                           PADS_ATTR_INFO* ppAttr);

HRESULT MakeMemberOf(PCWSTR pszDN,
                     const CDSCmdBasePathsInfo& refBasePathsInfo,
                     const CDSCmdCredentialObject& refCredentialObject,
                     const PDSOBJECTTABLEENTRY pObjectEntry,
                     const ARG_RECORD& argRecord,
                     DWORD dwAttributeIdx,
                     PADS_ATTR_INFO* ppAttr);

HRESULT BuildComputerSAMName(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr);

HRESULT BuildGroupSAMName(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD dwAttributeIdx,
                          PADS_ATTR_INFO* ppAttr);

HRESULT BuildUserSAMName(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT FillAttrInfoFromObjectEntryExpandUsername(PCWSTR pszDN,
                                                  const CDSCmdBasePathsInfo& refBasePathsInfo,
                                                  const CDSCmdCredentialObject& refCredentialObject,
                                                  const PDSOBJECTTABLEENTRY pObjectEntry,
                                                  const ARG_RECORD& argRecord,
                                                  DWORD dwAttributeIdx,
                                                  PADS_ATTR_INFO* ppAttr);

HRESULT SetComputerAccountType(PCWSTR pszDN,
                               const CDSCmdBasePathsInfo& refBasePathsInfo,
                               const CDSCmdCredentialObject& refCredentialObject,
                               const PDSOBJECTTABLEENTRY pObjectEntry,
                               const ARG_RECORD& argRecord,
                               DWORD dwAttributeIdx,
                               PADS_ATTR_INFO* ppAttr);

HRESULT SetIsGC(PCWSTR pszDN,
                const CDSCmdBasePathsInfo& refBasePathsInfo,
                const CDSCmdCredentialObject& refCredentialObject,
                const PDSOBJECTTABLEENTRY pObjectEntry,
                const ARG_RECORD& argRecord,
                DWORD dwAttributeIdx,
                PADS_ATTR_INFO* ppAttr);


HRESULT SetAccountEntry(PCWSTR pszDN,
                        const CDSCmdBasePathsInfo& refBasePathsInfo,
                        const CDSCmdCredentialObject& refCredentialObject,
                        const PDSOBJECTTABLEENTRY pObjectEntry,
                        const ARG_RECORD& argRecord,
                        DWORD dwAttributeIdx,
                        PADS_ATTR_INFO* ppAttr);


//+--------------------------------------------------------------------------
//
//  Function:   EvaluateMustChangePassword
//
//  Synopsis:   
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bMustChangePassword - OUT] : true if the user must change their
//                                            password at next logon, false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateMustChangePassword(PCWSTR pszDN,
                                   const CDSCmdBasePathsInfo& refBasePathsInfo,
                                   const CDSCmdCredentialObject& refCredentialObject,
                                   bool& bMustChangePassword);


//+--------------------------------------------------------------------------
//
//  Function:   EvaluateCanChangePasswordAces
//
//  Synopsis:   Looks for explicit entries in the ACL to see if the user can
//              change their password
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bCanChangePassword - OUT] : false if there are explicit entries
//                                           that keep the user from changing their
//                                           password.  true otherwise.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateCanChangePasswordAces(PCWSTR pszDN,
                                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                                      const CDSCmdCredentialObject& refCredentialObject,
                                      bool& bCanChangePassword);

//+--------------------------------------------------------------------------
//
//  Enumeration:  FSMO_TYPE
//
//  Synopsis:     The types of FSMO owners
//
//---------------------------------------------------------------------------
enum FSMO_TYPE
{
  SCHEMA_FSMO,
  RID_POOL_FSMO,
  PDC_FSMO,
  INFRASTUCTURE_FSMO,
  DOMAIN_NAMING_FSMO,
};

//+--------------------------------------------------------------------------
//
//  Function:   BindToFSMOHolder
//
//  Synopsis:   Binds to the appropriate object which can be used to find a
//              particular FSMO owner
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BindToFSMOHolder(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                         IN  const CDSCmdCredentialObject& refCredObject,
                         IN  FSMO_TYPE                  fsmoType,
                         OUT CComPtr<IADs>&             refspIADs);

//+--------------------------------------------------------------------------
//
//  Function:   FindFSMOOwner
//
//  Synopsis:   
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT FindFSMOOwner(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                      IN  const CDSCmdCredentialObject& refCredObject,
                      IN  FSMO_TYPE                  fsmoType,
                      OUT CComBSTR&                  refsbstrServer);


//+--------------------------------------------------------------------------
//
//  Function:   ValidateAndModifySAMName
//
//  Synopsis:   Looks for any illegal characters in the SamAccountName and
//              converts them to the replacementChar
//
//  Arguments:  [pszSAMName - IN/OUT]  : pointer to a string that contains the SamAccountName
//                                       illegal characters will be replaced
//              [pszInvalidChars - IN] : string containing the illegal characters
//
//  Returns:    HRESULT : S_OK if the name was valid and no characters had to be replaced
//                        S_FALSE if the name contained invalid characters that were replaced
//                        E_INVALIDARG
//
//  History:    21-Feb-2001   JeffJon   Created
//
//---------------------------------------------------------------------------

#define INVALID_NETBIOS_AND_ACCOUNT_NAME_CHARS_WITH_AT ILLEGAL_FAT_CHARS L".@"

HRESULT ValidateAndModifySAMName(PWSTR pszSAMName, 
                                 PCWSTR pszInvalidChars);

//+--------------------------------------------------------------------------
//
//  Class:      GetOutputDN
//
//  Purpose:    Converts an ADSI-escaped DN to one with DSCMD input escaping.
//              This way, the output DN can be piped as input to another
//              DSCMD command.
//
//  History:    08-May-2001 JonN     Created
//
//---------------------------------------------------------------------------
HRESULT GetOutputDN( OUT BSTR* pbstrOut, IN PCWSTR pszIn );

//+--------------------------------------------------------------------------
//
//  Class:      ValidateDNSyntax
//
//  Purpose:    Validates each string in the null separated list as having
//              DN syntax
//
//  Returns:    The count of valid DNs in the list
//
//  History:    12-Oct-2001 JeffJon    Created
//
//---------------------------------------------------------------------------
UINT ValidateDNSyntax(IN PWSTR* ppszArray, UINT nStrings);

//+--------------------------------------------------------------------------
//
//  Function:   IsServerGC
//
//  Purpose:    Checks if server is Global Catalog
//
//  Returns:    TRUE if GC else flase
//
//  History:    05-Jan-2002 hiteshr Created
//
//---------------------------------------------------------------------------
BOOL
IsServerGC(LPCWSTR pszServerName,
		   CDSCmdCredentialObject& refCredentialObject);

//+--------------------------------------------------------------------------
//
//  Function:   GetQuotedDN
//
//  Purpose:    Takes the give DN and surrounds it with quotes
//
//  Returns:    the quoted DN
//
//  History:    10-Oct-2002 jeffjon Created
//
//---------------------------------------------------------------------------
CComBSTR GetQuotedDN(PWSTR pszDN);

//+--------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeToDN
//
//  Synopsis:   Get the DN for an -acct param
//
//  Arguments:  [lpszDomain - IN]:  Domain to query or NULL for local
//              [lpszTrustee - IN]: Acct to resolve
//              [lpszDN - OUT]:     Returns the DN. Use LocalFree when done
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT ConvertTrusteeToDN(LPCWSTR lpszDomain, LPCWSTR lpszTrustee, 
                           LPWSTR* lpszDN);
//+--------------------------------------------------------------------------
//
//  Function:   GetDNSid
//
//  Synopsis:   Given a DN the objecSid value will be retrieved and returned
//              as a SID
//
//  Arguments:  [lpszDN - IN]:              DN to query
//              [refBasePathsInfo - IN]:    LDAP settings
//              [refCredentialObject - IN]: Credentials to use for the query
//              [pSid - OUT]:               A SID if successful. Call LocalFree
//                                          when done.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetDNSid(LPCTSTR lpszDN,
                 const CDSCmdBasePathsInfo& refBasePathsInfo,
                 const CDSCmdCredentialObject& refCredentialObject,
                 PSID* pSid);
//+--------------------------------------------------------------------------
//
//  Function:   GetQuotaContainerDN
//
//  Synopsis:   Takes the partition dn and merges it with the NTDS Quotas 
//              string (from wellKnownObjects GUID)
//
//  Arguments:  [basePathsInfo - IN]:    
//              [credentialObject - IN]: Creditials object used for 
//                                       binding to other objects
//              [lpszPartitionDN - IN]:  The partition to bind to
//              [pszNewDN - OUT]:        The munged quotas DN to return
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_UNEXPECTED in most failure cases
//                        E_OUTOFMEMORY if a LocalAlloc fails
//                        Anything else is a failure code from an ADSI call
//
//  History:    05-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetQuotaContainerDN(IN  CDSCmdBasePathsInfo& basePathsInfo, 
                            IN  const CDSCmdCredentialObject& credentialObject, 
                            IN  LPCWSTR lpszPartitionDN, 
                            OUT PWSTR*  pszNewDN);
//+--------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeToNT4Name
//
//  Synopsis:   Get the DN for an -acct param
//
//  Arguments:  [lpszDomain - IN]:  Domain to query or NULL for local
//              [lpszTrustee - IN]: Acct to resolve
//              [lpszNT4 - OUT]:     Returns the NT4 name. 
//                                  Use LocalFree when done
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG for invalid input
//                        Anything else is a failure code from an ADSI call
//
//  History:    20-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT ConvertTrusteeToNT4Name(LPCWSTR lpszDomain, LPCWSTR lpszTrustee, 
                                LPWSTR* lpszNT4);

#endif //_DSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsutilrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dsutil.rc
//
#define IDS_SUCCESS                     200
#define IDS_FAILED                      201
#define IDS_FAILED_SET_PASSWORD         202
#define IDS_FAILED_SET_NW_PASSWORD      203
#define IDS_FAILED_RESET_COMPUTER       204
#define IDS_YES                         205
#define IDS_NO                          206
#define IDS_ADMIN_PASSWORD_PROMPT       207
#define IDS_USER_PASSWORD_PROMPT        208
#define IDS_FAILED_CHANGE_GROUP_DOMAIN_VERSION 209
#define IDS_MUSTCHPWD_CANCHPWD_CONFLICT 210
#define IDS_ERRMSG_REMOVE_FROM_GROUP    211
#define IDS_ERRMSG_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER 212
#define IDS_APP_BASIC_GROUP             213
#define IDS_APP_QUERY_GROUP             214
#define IDS_USER_PASSWORD_CONFIRM       215
#define IDS_ERROR_PASSWORD_MISSMATCH    216
#define IDS_NO_SERVER_AND_DOMAIN        217
#define IDS_ERROR_LONG_PASSWORD         218
#define IDS_GROUP_MEMBER_ITSELF         219

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parserutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      parserutil.h
//
//  Contents:  Helpful functions for manipulating and validating 
//             generic command line arguments
//
//  History:   07-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _PARSERUTIL_H_
#define _PARSERUTIL_H_

//
// Common switches
//
typedef enum COMMON_COMMAND_ENUM
{
   eCommUnicodeAll,
   eCommUnicodeInput,
   eCommUnicodeOutput,

#ifdef DBG
   eCommDebug,
#endif

   eCommHelp,
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommQuiet,
   eCommLast = eCommQuiet
};

#define UNICODE_COMMANDS                  \
   0,(LPWSTR)c_sz_arg1_com_unicode,       \
   0,NULL,                                \
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,      \
   (CMD_TYPE)FALSE,                       \
   0,  NULL,                              \
                                          \
   0,(LPWSTR)c_sz_arg1_com_unicodeinput,  \
   0,NULL,                                \
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,      \
   (CMD_TYPE)FALSE,                       \
   0,  NULL,                              \
                                          \
   0,(LPWSTR)c_sz_arg1_com_unicodeoutput, \
   0,NULL,                                \
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,      \
   (CMD_TYPE)FALSE,                       \
   0,  NULL,

#ifdef DBG
#define DEBUG_COMMAND                                   \
   0,(LPWSTR)c_sz_arg1_com_debug,                       \
   ID_ARG2_NULL,NULL,                                   \
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,   \
   (CMD_TYPE)0,                                         \
   0,  NULL,
#else
#define DEBUG_COMMAND
#endif

#define COMMON_COMMANDS                 \
                                        \
   UNICODE_COMMANDS                     \
                                        \
   DEBUG_COMMAND                        \
                                        \
   0,(LPWSTR)c_sz_arg1_com_help,        \
   0,(LPWSTR)c_sz_arg2_com_help,        \
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,    \
   (CMD_TYPE)FALSE,                     \
   0,  NULL,                            \
                                        \
   0,(LPWSTR)c_sz_arg1_com_server,      \
   0,(LPWSTR)c_sz_arg2_com_server,      \
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,     \
   NULL,                                \
   0,  NULL,                            \
                                        \
   0,(LPWSTR)c_sz_arg1_com_domain,      \
   0,(LPWSTR)c_sz_arg2_com_domain,      \
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,     \
   NULL,                                \
   0,  NULL,                            \
                                        \
   0,(LPWSTR)c_sz_arg1_com_username,    \
   0,(LPWSTR)c_sz_arg2_com_username,    \
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,     \
   NULL,                                \
   0,  NULL,                            \
                                        \
   0,(LPWSTR)c_sz_arg1_com_password,    \
   0,(LPWSTR)c_sz_arg2_com_password,    \
   ARG_TYPE_PASSWORD, ARG_FLAG_OPTIONAL,     \
   (CMD_TYPE)_T(""),                    \
   0,  ValidateAdminPassword,           \
                                        \
   0,(LPWSTR)c_sz_arg1_com_quiet,       \
   ID_ARG2_NULL,NULL,                   \
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,    \
   (CMD_TYPE)_T(""),                    \
   0,  NULL,



HRESULT MergeArgCommand(PARG_RECORD pCommand1, 
                        PARG_RECORD pCommand2, 
                        PARG_RECORD *ppOutCommand);

DWORD GetPasswdStr(LPTSTR  buf,
                   DWORD   buflen,
                   PDWORD  len);
DWORD ValidateAdminPassword(PVOID pArg);
DWORD ValidateUserPassword(PVOID pArg);
DWORD ValidateYesNo(PVOID pArg);
DWORD ValidateGroupScope(PVOID pArg);
DWORD ValidateNever(PVOID pArg);

//+--------------------------------------------------------------------------
//
//  Function:   ParseNullSeparatedString
//
//  Synopsis:   Parses a '\0' separated list that ends in "\0\0" into a string
//              array
//
//  Arguments:  [psz - IN]     : '\0' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseNullSeparatedString(PTSTR psz,
								      PTSTR** ppszArr,
								      UINT* pnArrEntries);

//+--------------------------------------------------------------------------
//
//  Function:   ParseSemicolonSeparatedString
//
//  Synopsis:   Parses a ';' separated list 
//
//  Arguments:  [psz - IN]     : ';' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseSemicolonSeparatedString(PTSTR psz,
                                   PTSTR** ppszArr,
                                   UINT* pnArrEntries);


#endif // _PARSERUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parserutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      parserutil.cpp
//
//  Contents:  Helpful functions for manipulating and validating 
//             generic command line arguments
//
//  History:   07-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "iostream.h"
#include "cstrings.h"
#include "commonstrings.h"

//+--------------------------------------------------------------------------
//
//  Function:   GetPasswdStr
//
//  Synopsis:   Reads a password string from stdin without echoing the keystrokes
//
//  Arguments:  [buf - OUT]    : buffer to put string in
//              [buflen - IN]  : size of the buffer
//              [&len - OUT]   : length of the string placed into the buffer
//
//  Returns:    DWORD : 0 or ERROR_INSUFFICIENT_BUFFER if user typed too much.
//                      Buffer contents are only valid on 0 return.
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#define CR              0xD
#define BACKSPACE       0x8

DWORD GetPasswdStr(LPTSTR  buf,
                   DWORD   buflen,
                   PDWORD  len)
{
    TCHAR	ch;
    TCHAR	*bufPtr = buf;
    DWORD	c;
    int		err;
    DWORD   mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;               /* GP fault probe (a la API's) */
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) 
    {
		//Security Review:Correct buffer len is passed.
	    err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
	    if (!err || c != 1)
	        ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) 
        {  /* back up one or two */
           /*
           * IF bufPtr == buf then the next two lines are
           * a no op.
           */
           if (bufPtr != buf) 
           {
                    bufPtr--;
                    (*len)--;
           }
        }
        else 
        {
                *bufPtr = ch;

                if (*len < buflen) 
                    bufPtr++ ;                   /* don't overflow buf */
                (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = TEXT('\0');         /* null terminate the string */
    putwchar(TEXT('\n'));

    return ((*len <= buflen) ? 0 : ERROR_INSUFFICIENT_BUFFER);
}


//+--------------------------------------------------------------------------
//
//  Function:   ValidatePassword
//
//  Synopsis:   Password validation function called by parser
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : ERROR_INVALID_PARAMETER if the argument record or
//                          the value it contains is not valid
//                      ERROR_NOT_ENOUGH_MEMORY
//                      ERROR_SUCCESS if everything succeeded and it is a
//                          valid password
//                      Otherwise it is an error condition returned from
//                          GetPasswdStr
//
//  History:    07-Sep-2000   JeffJon   Created
//				03-27-2002    hiteshr changed the function	
//				//NTRAID#NTBUG9-571544-2000/11/13-hiteshr
//---------------------------------------------------------------------------
DWORD ValidatePassword(PVOID pArg, 
							  UINT IdStr,
							  UINT IdPromptConfirm)
{	
   
	PARG_RECORD pRec = (PARG_RECORD)pArg;
	if(!pRec || !pRec->strValue)
	{
        return ERROR_INVALID_PARAMETER;
	}


	//Validate the length of password. Password length must be 
	//less than MAX_PASSWORD_LENGTH	
	size_t cchInputPassword = 0;
	HRESULT hr = StringCchLength(pRec->strValue,
										  MAX_PASSWORD_LENGTH,
										  &cchInputPassword);

	if(FAILED(hr))
	{
		DisplayErrorMessage(g_pszDSCommandName,NULL,E_INVALIDARG,IDS_ERROR_LONG_PASSWORD);
		return VLDFN_ERROR_NO_ERROR;
	}
	
	//If Password is *, store encrypted password
	if(wcscmp(pRec->strValue, L"*") != 0 )
	{
		DATA_BLOB EncryptedPasswordDataBlob;
		hr = EncryptPasswordString(pRec->strValue, &EncryptedPasswordDataBlob);
		
		//Clear the cleartext password
		SecureZeroMemory(pRec->strValue,cchInputPassword*sizeof(WCHAR));
		
		if(SUCCEEDED(hr))
		{
			LocalFree(pRec->strValue);
			pRec->encryptedDataBlob = EncryptedPasswordDataBlob;
			return ERROR_SUCCESS;
		}

		return 	hr;	
	}

	//User entered * in commandline. Prompt for password.
	CComBSTR sbstrPrompt;
	if(sbstrPrompt.LoadString(::GetModuleHandle(NULL),IdStr))
	{
		DisplayOutput(sbstrPrompt);
	}
	else
		DisplayOutput(L"Enter Password\n");    
	
	WCHAR buffer[MAX_PASSWORD_LENGTH];
	DWORD len = 0;
	DWORD dwErr = GetPasswdStr(buffer,MAX_PASSWORD_LENGTH,&len);
	if(dwErr != ERROR_SUCCESS)
		return dwErr;

	if(IdPromptConfirm)
	{
		  if(sbstrPrompt.LoadString(::GetModuleHandle(NULL),IdPromptConfirm))
		  {
			   DisplayOutput(sbstrPrompt);
		  }
		  else
            DisplayOutput(L"Confirm Password\n");    

		 WCHAR buffer1[MAX_PASSWORD_LENGTH];
		 DWORD len1 = 0;
		 dwErr = GetPasswdStr(buffer1,MAX_PASSWORD_LENGTH,&len1);
		 if(dwErr != ERROR_SUCCESS)
			  return dwErr;

		//Security Review:This is fine.
		if(wcscmp(buffer,buffer1) != 0)
		{
			SecureZeroMemory(buffer,sizeof(buffer));
			SecureZeroMemory(buffer1,sizeof(buffer1));
			CComBSTR sbstrError;
			sbstrError.LoadString(::GetModuleHandle(NULL),IDS_ERROR_PASSWORD_MISSMATCH);

			DisplayErrorMessage(g_pszDSCommandName,NULL,S_OK,sbstrError);
			//Security Review:SecureZeroMemory buffer and buffer1 before returning
			return VLDFN_ERROR_NO_ERROR;
		}      

		//Two passwords are same. Clear the buffer1
		SecureZeroMemory(buffer1,sizeof(buffer1));
	 }	 
    
	//CryptProtectMemory strValue
    DATA_BLOB  EncryptedPasswordDataBlob;
	hr = EncryptPasswordString(buffer, &EncryptedPasswordDataBlob);
	//Clear the cleartext password in buffer
	SecureZeroMemory(buffer,sizeof(buffer));	
			
	if(SUCCEEDED(hr))
	{
		LocalFree(pRec->strValue);
		pRec->encryptedDataBlob = EncryptedPasswordDataBlob;
		return ERROR_SUCCESS;
	}

	return hr;		
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateAdminPassword
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : ERROR_INVALID_PARAMETER if the argument record or
//                          the value it contains is not valid
//                      ERROR_SUCCESS if everything succeeded and it is a
//                          valid password
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------
DWORD ValidateAdminPassword(PVOID pArg)
{
    return ValidatePassword(pArg,IDS_ADMIN_PASSWORD_PROMPT,0);
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateUserPassword
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------
DWORD ValidateUserPassword(PVOID pArg)
{
    return ValidatePassword(pArg, IDS_USER_PASSWORD_PROMPT,IDS_USER_PASSWORD_CONFIRM);
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateYesNo
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------

DWORD ValidateYesNo(PVOID pArg)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;

    CComBSTR sbstrInput;

    sbstrInput = pRec->strValue;
    sbstrInput.ToLower();
    if( sbstrInput == g_bstrYes )
    {
        LocalFree(pRec->strValue);
        pRec->bValue = TRUE;
    }
    else if( sbstrInput == g_bstrNo )
    {
        LocalFree(pRec->strValue);
        pRec->bValue = FALSE;
    }
    else
        return ERROR_INVALID_PARAMETER;

    //
    // Have to set this to bool or else
    // FreeCmd will try to free the string
    // which AVs when the bool is true
    //
    pRec->fType = ARG_TYPE_BOOL;
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateNever
//
//  Synopsis:   Password validation function called by parser for Admin
//              Verifies the value contains digits or "NEVER"
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   JeffJon Created
//
//---------------------------------------------------------------------------

DWORD ValidateNever(PVOID pArg)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec)
        return ERROR_INVALID_PARAMETER;

    if (pRec->fType == ARG_TYPE_STR)
    {
       CComBSTR sbstrInput;
       sbstrInput = pRec->strValue;
	   //Security Review:This is fine, though we don't need 
	   //to copy it sbstrInput. A direct comparison should be
	   //good enough.
       if( _wcsicmp(sbstrInput, g_bstrNever) )
       {
          return ERROR_INVALID_PARAMETER;
       }
    }
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateGroupScope
//
//  Synopsis:   Makes sure that the value following the -scope switch is one
//              of (l/g/u)
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    18-Sep-2000   JeffJon Created
//
//---------------------------------------------------------------------------

DWORD ValidateGroupScope(PVOID pArg)
{
    DWORD dwReturn = ERROR_SUCCESS;
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;

    CComBSTR sbstrInput;
    sbstrInput = pRec->strValue;
    sbstrInput.ToLower();
    if(sbstrInput == _T("l") ||
       sbstrInput == _T("g") ||
       sbstrInput == _T("u"))
    {
        dwReturn = ERROR_SUCCESS;
    }
    else
    {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    return dwReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   MergeArgCommand
//
//  Synopsis:   Combines two ARG_RECORD arrays into a single
//
//  Arguments:  [pCommand1 - IN]     : first ARG_RECORD array to merge
//              [pCommand2 - IN]     : second ARG_RECORD array to merge
//              [ppOutCommand - OUT] : the array that results from the merge
//
//  Returns:    HRESULT : S_OK on success
//                        E_OUTOFMEMORY if failed to allocate memory for new array
//
//  History:    08-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT MergeArgCommand(PARG_RECORD pCommand1, 
                        PARG_RECORD pCommand2, 
                        PARG_RECORD *ppOutCommand)
{
   HRESULT hr = S_OK;

   //
   // Verify parameters
   //
   if (!pCommand1 && !pCommand2)
   {
      return E_INVALIDARG;
   }

   LONG nSize1 = 0;
   LONG nSize2 = 0;

   UINT i = 0;

   if (NULL != pCommand1)
   {
      for(i=0; pCommand1[i].fType != ARG_TYPE_LAST ;i++)
      {
         ++nSize1;
      }
   }
   if (NULL != pCommand2)
   {
      for(i=0; pCommand2[i].fType != ARG_TYPE_LAST ;i++)
      {
         ++nSize2;
      }
   }

   *ppOutCommand = (PARG_RECORD)LocalAlloc(LPTR, sizeof(ARG_RECORD)*(nSize1+nSize2+1));
   if(!*ppOutCommand)
   {
      return E_OUTOFMEMORY;
   }

   if (NULL != pCommand1)
   {
      //Security Review:This is fine.
	   memcpy(*ppOutCommand,pCommand1,sizeof(ARG_RECORD)*(nSize1+1));
   }
   if (NULL != pCommand2)
   {
	 //Security Review:This is fine. 
      memcpy((*ppOutCommand+nSize1),pCommand2,sizeof(ARG_RECORD)*(nSize2+1));
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseStringByChar
//
//  Synopsis:   Parses a string into elements separated by the given character
//
//  Arguments:  [psz - IN]     : string to be parsed
//              [tchar - IN]   : character that is to be used as the separator
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    18-Sep-2000   JeffJon   Created
//              14-Apr-2001   JeffJon   Modified to separate on a generic character
//
//---------------------------------------------------------------------------

void ParseStringByChar(PTSTR psz,
                       TCHAR tchar,
							  PTSTR** ppszArr,
							  UINT* pnArrEntries)
{
   //
   // Verify parameters
   //
   if (!psz ||
       !ppszArr ||
       !pnArrEntries)
   {
      ASSERT(psz);
      ASSERT(ppszArr);
      ASSERT(pnArrEntries);

      return;
   }

   //
   // Count the number of strings
   //
   UINT nCount = 0;
   PTSTR pszTemp = psz;
   while (true)
   {
      if (pszTemp[0] == tchar && 
          pszTemp[1] == tchar)
      {
         nCount++;
         break;
      }
      else if (pszTemp[0] == tchar &&
               pszTemp[1] != tchar)
      {
         nCount++;
         pszTemp++;
      }
      else
      {
         pszTemp++;
      }
   }

   *pnArrEntries = nCount;

   //
   // Allocate the array
   //
   *ppszArr = (PTSTR*)LocalAlloc(LPTR, nCount * sizeof(PTSTR));
   if (*ppszArr)
   {
      //
      // Copy the string pointers into the array
      //
      UINT nIdx = 0;
      pszTemp = psz;
      (*ppszArr)[nIdx] = pszTemp;
      nIdx++;

      while (true)
      {
         if (pszTemp[0] == tchar && 
             pszTemp[1] == tchar)
         {
            break;
         }
         else if (pszTemp[0] == tchar &&
                  pszTemp[1] != tchar)
         {
            (*ppszArr)[nIdx] = &(pszTemp[1]);
            nIdx++;
            pszTemp++;
         }
         else
         {
            pszTemp++;
         }
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseNullSeparatedString
//
//  Synopsis:   Parses a '\0' separated list that ends in "\0\0" into a string
//              array
//
//  Arguments:  [psz - IN]     : '\0' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseNullSeparatedString(PTSTR psz,
                              PTSTR** ppszArr,
                              UINT* pnArrEntries)
{
   ParseStringByChar(psz,
                     L'\0',
                     ppszArr,
                     pnArrEntries);
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseSemicolonSeparatedString
//
//  Synopsis:   Parses a ';' separated list 
//
//  Arguments:  [psz - IN]     : ';' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseSemicolonSeparatedString(PTSTR psz,
                                   PTSTR** ppszArr,
                                   UINT* pnArrEntries)
{
   ParseStringByChar(psz,
                     L';',
                     ppszArr,
                     pnArrEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      pch.h
//
//  Contents:  Precompiled header for this project
//
//  History:   06-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

//
// System includes
//
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <stdio.h>

#include <atlbase.h>

//
// ILLEGAL_FAT_CHARS
//
#include <validc.h>


//
// ADSI headers
//
#include <iads.h>
#include <activeds.h>

//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

//
//Crypto APIS
//
#include "wincrypt.h"
//
// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.
//
#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

//
// Parser header file
//
#include "varg.h"

#include "strings.h"
#include "parserutil.h"
#include "pcrack.h"
#include "util.h"

#include "dsutil.h"
#include "dsutilrc.h"


//
// Some global defines
//
#define MAX_PASSWORD_LENGTH 256 + 1   // including the NULL terminator
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\query.cpp ===
#include "pch.h"
#include "query.h"


CDSSearch::CDSSearch()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_ppszAttr = NULL;
  m_CountAttr = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}


void CDSSearch::_Reset()
{
  if (m_pObj != NULL) 
  {
    if (m_SearchHandle) 
    {
      m_pObj->CloseSearchHandle (m_SearchHandle);
      m_SearchHandle = NULL;
    }
    m_pObj->Release();
    m_pObj = NULL;
  }

  if (m_pwszFilter)
  {
     delete[] m_pwszFilter;
     m_pwszFilter = NULL;
  }
}

CDSSearch::~CDSSearch()
{
  _Reset();
}


HRESULT CDSSearch::Init(IDirectorySearch * pObj)
{
  HRESULT            hr = S_OK;
  _Reset();
  m_pObj = pObj;
  pObj->AddRef();
  m_bInitialized = TRUE;
  m_scope = ADS_SCOPE_ONELEVEL;  
  return hr;
}

HRESULT CDSSearch::Init(PCWSTR pszPath,
                        const CDSCmdCredentialObject& refCredObject)
{
  ENTER_FUNCTION_HR(FULL_LOGGING, CDSSearch::Init, hr);

  do // false loop
  {
    //
    // Verify parameters
    //
    if (!pszPath)
    {
      ASSERT(pszPath);
      hr = E_INVALIDARG;
      break;
    }

    CComPtr<IDirectorySearch> spDirSearch;
    hr = DSCmdOpenObject(refCredObject,
                         pszPath,
                         IID_IDirectorySearch,
                         (void**)&spDirSearch,
                         true);
    if (FAILED(hr))
    {
      break;
    }

    hr = Init(spDirSearch);
  } while (false);
  
  return hr;
}


HRESULT CDSSearch::SetAttributeList (LPTSTR *ppszAttribs, INT cAttrs)
{
  m_ppszAttr = ppszAttribs;
  m_CountAttr = cAttrs;
  return S_OK;
}

HRESULT CDSSearch::SetSearchScope (ADS_SCOPEENUM scope)
{
  if (m_bInitialized) {
    m_scope = scope;
  }
  return S_OK;
}

const int NUM_PREFS = 5;
HRESULT _SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope, BOOL bAttrOnly)
{
  if (NULL == piSearch)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  int cPref = 4;

  ADS_SEARCHPREF_INFO aSearchPref[5];
  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
  aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
  aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[3].vValue.Integer = scope;
  if(bAttrOnly)
  {	
    aSearchPref[4].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
	aSearchPref[4].vValue.dwType = ADSTYPE_BOOLEAN;
	aSearchPref[4].vValue.Integer = TRUE;
	++cPref;
  }

  return piSearch->SetSearchPreference (aSearchPref, cPref);
}


HRESULT CDSSearch::DoQuery(BOOL bAttrOnly)
{
  if (!m_bInitialized)
    return E_ADS_BAD_PATHNAME;

  HRESULT hr = _SetSearchPreference(m_pObj, m_scope, bAttrOnly);

  if (SUCCEEDED(hr)) {
    hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                m_ppszAttr,
                                m_CountAttr,
                                &m_SearchHandle);
  }

  return hr;
}

HRESULT
CDSSearch::GetNextRow()
{
  DWORD status = ERROR_MORE_DATA;
  HRESULT hr = S_OK;
  HRESULT hr2 = S_OK;
  WCHAR Buffer1[512], Buffer2[512];
  if (!m_bInitialized) {
    return E_ADS_BAD_PATHNAME;
  }
  while (status == ERROR_MORE_DATA ) {
    hr = m_pObj->GetNextRow (m_SearchHandle);
    if (hr == S_ADS_NOMORE_ROWS) {
      hr2 = ADsGetLastError(&status, Buffer1, 512,
                      Buffer2, 512);
      ASSERT(SUCCEEDED(hr2));
    } else {
      status = 0;
    }
  }
  return hr;
}

HRESULT
CDSSearch::GetColumn(LPWSTR Attribute,
                     PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) {
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT 
CDSSearch::GetNextColumnName(LPWSTR *ppszColumnName)
{  
  if (m_bInitialized) {
    return m_pObj->GetNextColumnName(m_SearchHandle,
                                     ppszColumnName);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\pcrack.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       pcrack.h
//
//  requires iads.h (IADsPathname) and atlbase.h (CComPtr)
//
//--------------------------------------------------------------------------

// pcrack.h : include file for CPathCracker

#ifndef __PCRACK_H__
#define __PCRACK_H__

//+--------------------------------------------------------------------------
//
//  Class:      CPathCracker
//
//  Purpose:    A wrapper around the IADsPathname interface with additional
//              methods for manipulating paths.
//              The constructor creates the object and the destructor releases it.
//              This object is meant to be created on the stack and then it
//              is cleaned up when it goes out of scope
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CPathCracker
{
public:
   //
   // Constructor
   //
   CPathCracker();

   //
   // IADsPathname methods
   //
   virtual /* [id] */ HRESULT STDMETHODCALLTYPE Set( 
                        /* [in] */ const BSTR bstrADsPath,
                        /* [in] */ long lnSetType) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Set(bstrADsPath, lnSetType); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDisplayType( 
                        /* [in] */ long lnDisplayType) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->SetDisplayType(lnDisplayType); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE Retrieve( 
                        /* [in] */ long lnFormatType,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrADsPath) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Retrieve(lnFormatType, pbstrADsPath); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNumElements( 
                        /* [retval][out] */ long __RPC_FAR *plnNumPathElements)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetNumElements(plnNumPathElements); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetElement( 
                        /* [in] */ long lnElementIndex,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrElement)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetElement(lnElementIndex, pbstrElement); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddLeafElement( 
                        /* [in] */ BSTR bstrLeafElement)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->AddLeafElement(bstrLeafElement); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE RemoveLeafElement( void)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->RemoveLeafElement(); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyPath( 
                        /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppAdsPath)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->CopyPath(ppAdsPath); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEscapedElement( 
                        /* [in] */ long lnReserved,
                        /* [in] */ const BSTR bstrInStr,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrOutStr)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetEscapedElement(lnReserved, bstrInStr, pbstrOutStr); }

   virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EscapedMode( 
                        /* [retval][out] */ long __RPC_FAR *retval)  
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->get_EscapedMode(retval); }

   virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EscapedMode( 
                           /* [in] */ long lnEscapedMode) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->put_EscapedMode(lnEscapedMode); }

   //
   // Other helpful path manglers
   //
   static HRESULT GetParentDN(PCWSTR pszDN,
                              CComBSTR& refsbstrDN);
   static HRESULT GetObjectRDNFromDN(PCWSTR pszDN,
                                     CComBSTR& refsbstrRDN);
   static HRESULT GetObjectNameFromDN(PCWSTR pszDN,
                                      CComBSTR& refsbstrName);
   static HRESULT GetDNFromPath(PCWSTR pszPath,
                                CComBSTR& refsbstrDN);

private:
   //
   // Private member function
   //
   HRESULT Init();

   //
   // Private member data
   //
   CComPtr<IADsPathname> m_spIADsPathname;
   HRESULT m_hrCreate;
};

#endif _PCRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSQuery.h
//
//  Contents:  Query object for DS snapin
//
//  History:   04-dec-96 jimharr    Created
//
//--------------------------------------------------------------------------


#ifndef __QUERY_H__
#define __QUERY_H__

#define QUERY_PAGESIZE 50

//
// CDSSearch
//
class CDSSearch
{
public:
  CDSSearch();
  ~CDSSearch();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(PCWSTR pszPath, const CDSCmdCredentialObject& refCredObject);
  HRESULT DoQuery(BOOL bAttrOnly = FALSE);
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
  {
    return m_pObj->FreeColumn(pColumnData);
  };
  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);  
  HRESULT SetSearchScope (ADS_SCOPEENUM scope);
  HRESULT SetFilterString (LPWSTR pszFilter) 
  {
    if (!pszFilter)
    {
       return E_INVALIDARG;
    }

    if (m_pwszFilter)
    {
       delete[] m_pwszFilter;
       m_pwszFilter = NULL;
    }
	//Security Review:This is fine.
    m_pwszFilter = new WCHAR[wcslen(pszFilter) + 1];
    if (!m_pwszFilter)
    {
       return E_OUTOFMEMORY;
    }

	//Security Review:Correct buffer is allocated above.
    wcscpy(m_pwszFilter, pszFilter);
    return S_OK;
  };
  HRESULT GetNextColumnName(LPWSTR *ppszColumnName);
  VOID FreeColumnName(LPWSTR pszColumnName)
  {
    FreeADsMem(pszColumnName);

  }    

  //Attributes
public:
  IDirectorySearch   * m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR             m_pwszFilter;
  LPWSTR *           m_ppszAttr;
  DWORD              m_CountAttr;
  ADS_SCOPEENUM      m_scope;

private:
  void _Reset();
  BOOL m_bInitialized;  
};
        


#endif //__DSQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\secutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:      SecUtil.h
//
//  Contents:  Utility functions for working with the security APIs
//
//  History:   15-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _SECUTIL_H_
#define _SECUTIL_H_

extern const GUID GUID_CONTROL_UserChangePassword;

//+--------------------------------------------------------------------------
//
//  Class:      CSimpleSecurityDescriptorHolder
//
//  Purpose:    Smart wrapper for a SecurityDescriptor
//
//  History:    15-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CSimpleSecurityDescriptorHolder
{
public:
   //
   // Constructor and Destructor
   //
   CSimpleSecurityDescriptorHolder();
   ~CSimpleSecurityDescriptorHolder();

   //
   // Public member data
   //
   PSECURITY_DESCRIPTOR m_pSD;
private:
   CSimpleSecurityDescriptorHolder(const CSimpleSecurityDescriptorHolder&) {}
   CSimpleSecurityDescriptorHolder& operator=(const CSimpleSecurityDescriptorHolder&) {}
};


//+--------------------------------------------------------------------------
//
//  Class:      CSimpleAclHolder
//
//  Purpose:    Smart wrapper for a ACL
//
//  History:    15-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CSimpleAclHolder
{
public:
  CSimpleAclHolder()
  {
    m_pAcl = NULL;
  }
  ~CSimpleAclHolder()
  {
    if (m_pAcl != NULL)
      ::LocalFree(m_pAcl);
  }

  PACL m_pAcl;
};

//+--------------------------------------------------------------------------
//
//  Class:      CSidHolder
//
//  Purpose:    Smart wrapper for a SID
//
//  History:    15-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CSidHolder
{
public:
   //
   // Constructor and Destructor
   //
   CSidHolder();
   ~CSidHolder();

   //
   // Public methods
   //
   PSID Get();
   bool Copy(PSID p);
   void Attach(PSID p, bool bLocalAlloc);
   void Clear();

private:
   //
   // Private methods
   //
   void _Init();
   void _Free();
   bool _Copy(PSID p);

   //
   // Private member data
   //
   PSID m_pSID;
   bool m_bLocalAlloc;
};

//
//Function for reading and writing acl
//
HRESULT
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl);

HRESULT 
DSWriteObjectSecurity(IN IDirectoryObject *pDsObject,
                      IN SECURITY_DESCRIPTOR_CONTROL sdControl,
                      PACL pDacl);


#endif //_SECUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\secutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      SecUtil.cpp
//
//  Contents:  Utility functions for working with security APIs
//
//  History:   15-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "secutil.h"

extern const GUID GUID_CONTROL_UserChangePassword =
    { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};

//+--------------------------------------------------------------------------
//
//  Member:     CSimpleSecurityDescriptorHolder::CSimpleSecurityDescriptorHolder
//
//  Synopsis:   Constructor for the smart security descriptor
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSimpleSecurityDescriptorHolder::CSimpleSecurityDescriptorHolder()
{
   m_pSD = NULL;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSimpleSecurityDescriptorHolder::~CSimpleSecurityDescriptorHolder
//
//  Synopsis:   Destructor for the smart security descriptor
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSimpleSecurityDescriptorHolder::~CSimpleSecurityDescriptorHolder()
{
   if (m_pSD != NULL)
   {
      ::LocalFree(m_pSD);
      m_pSD = NULL;
   }
}


////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::CSidHolder
//
//  Synopsis:   Constructor : initializes the member data
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSidHolder::CSidHolder()
{
   _Init();
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::~CSidHolder
//
//  Synopsis:   Destructor : Frees all data associated with the wrapped SID
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSidHolder::~CSidHolder()
{
   _Free();
}
  
//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Get
//
//  Synopsis:   Public accessor to the SID being wrapped
//
//  Arguments:  
//
//  Returns:    PSID : pointer to the SID being wrapped.  NULL if the class
//                     is not currently wrapping a SID
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
PSID CSidHolder::Get()
{
   return m_pSID;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Copy
//
//  Synopsis:   Frees the memory associated with the currently wrapped SID
//              and then copies the new SID
//
//  Arguments:  [p - IN] : SID to be copied
//
//  Returns:    bool : true if the copy was successful, false otherwise
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
bool CSidHolder::Copy(PSID p)
{
   _Free();
   return _Copy(p);
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Attach
//
//  Synopsis:   Attaches the SID to the wrapper
//
//  Arguments:  [p - IN] : SID to be wrapped by this class
//              [bLocalAlloc - OUT] : tells whether the SID should be freed
//                                    with LocalFree
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::Attach(PSID p, bool bLocalAlloc)
{
   _Free();
   m_pSID = p;
   m_bLocalAlloc = bLocalAlloc;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Clear
//
//  Synopsis:   Frees the memory associated with the SID being wrapped
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::Clear()
{
   _Free();
}


//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::_Init
//
//  Synopsis:   Initializes the member data to default values
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::_Init()
{
   m_pSID = NULL;
   m_bLocalAlloc = TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::_Free
//
//  Synopsis:   Frees the memory associated with the SID being wrapped
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::_Free()
{
   if (m_pSID != NULL)
   {
      if (m_bLocalAlloc)
      {
         ::LocalFree(m_pSID);
      }
      else
      {
         ::FreeSid(m_pSID);
         _Init();
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::_Copy
//
//  Synopsis:   Makes a copy of the SID being wrapped
//
//  Arguments:  [p - OUT] : destination of the SID being copied
//
//  Returns:    bool : true if SID was copied successfully
//                     false if there was a failure
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
bool CSidHolder::_Copy(PSID p)
{
   if ( (p == NULL) || !::IsValidSid(p) )
   {
      return false;
   }

   DWORD dwLen = ::GetLengthSid(p);
   PSID pNew = ::LocalAlloc(LPTR, dwLen);
   if (pNew == NULL)
   {
      return false;
      }

   //Security Review:This is fine. Buffer is correctly allocated.
   if (!::CopySid(dwLen, pNew, p))
   {
      ::LocalFree(pNew);
      return false;
   }
   m_bLocalAlloc = TRUE;
   m_pSID = pNew;

   ASSERT(dwLen == ::GetLengthSid(m_pSID));
   ASSERT(memcmp(p, m_pSID, dwLen) == 0);
   return true;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoMask
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  punk]          --  IUnknown from IDirectoryObject
//              [IN  si]            --  SecurityInformation
////  History:  25-Dec-2000         --  Hiteshr Created
//----------------------------------------------------------------------------
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";


//+---------------------------------------------------------------------------
//
//  Function:   DSReadObjectSecurity
//
//  Synopsis:   Reads the Dacl from the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [psdControl]        -- Control Setting for SD
//                                     They can be returned when calling
//                                      DSWriteObjectSecurity                 
//              [OUT ppDacl]        --  DACL returned here
//              
//
//  History     25-Oct-2000         -- hiteshr created
//
//  Notes:  If Object Doesn't have DACL, function will succeed but *ppDacl will
//          be NULL. 
//          Caller must free *ppDacl, if not NULL, by calling LocalFree
//
//----------------------------------------------------------------------------
HRESULT 
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DSReadObjectSecurity, hr);

   PADS_ATTR_INFO pSDAttributeInfo = NULL;

   do // false loop
   {
      LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
      DWORD dwAttributesReturned;
      PSECURITY_DESCRIPTOR pSD = NULL;
      PACL pAcl = NULL;

      if(!pDsObject || !ppDacl)
      {
         ASSERT(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      *ppDacl = NULL;

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }

      //
      // Read the security descriptor
      //
      hr = pDsObject->GetObjectAttributes(&pszSDProperty,
                                         1,
                                         &pSDAttributeInfo,
                                         &dwAttributesReturned);
      if (SUCCEEDED(hr) && !pSDAttributeInfo)    
         hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege

      if(FAILED(hr))
      {
         break;
      }                

      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

      pSD = (PSECURITY_DESCRIPTOR)pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue;

      ASSERT(IsValidSecurityDescriptor(pSD));


      //
      //Get the security descriptor control
      //
      if(psdControl)
      {
         DWORD dwRevision;
         if(!GetSecurityDescriptorControl(pSD, psdControl, &dwRevision))
         {
             DWORD _dwErr = GetLastError();	     
			 hr = HRESULT_FROM_WIN32( _dwErr );
             break;
         }
      }

      //
      //Get pointer to DACL
      //
      BOOL bDaclPresent, bDaclDefaulted;
      if(!GetSecurityDescriptorDacl(pSD, 
                                   &bDaclPresent,
                                   &pAcl,
                                   &bDaclDefaulted))
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         break;
      }

      if(!bDaclPresent ||
         !pAcl)
      {
         break;
      }

      ASSERT(IsValidAcl(pAcl));

      //
      //Make a copy of the DACL
      //
      *ppDacl = (PACL)LocalAlloc(LPTR,pAcl->AclSize);
      if(!*ppDacl)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
	  //Security Review:This is fine. Memory is correctly allocted above.
      CopyMemory(*ppDacl,pAcl,pAcl->AclSize);

    }while(0);


    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DSWriteObjectSecurity
//
//  Synopsis:   Writes the Dacl to the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [sdControl]         -- control for security descriptor
//              [IN  pDacl]         --  The DACL to be written
//
//  History     25-Oct-2000         -- hiteshr created
//----------------------------------------------------------------------------
HRESULT 
DSWriteObjectSecurity(IN IDirectoryObject *pDsObject,
                      IN SECURITY_DESCRIPTOR_CONTROL sdControl,
                      PACL pDacl)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DSWriteObjectSecurity, hr);

   PISECURITY_DESCRIPTOR pSD = NULL;
   PSECURITY_DESCRIPTOR psd = NULL;

   do // false loop
   {
      ADSVALUE attributeValue;
      ADS_ATTR_INFO attributeInfo;
      DWORD dwAttributesModified;
      DWORD dwSDLength;

      if(!pDsObject || !pDacl)
      {
         ASSERT(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      ASSERT(IsValidAcl(pDacl));

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"SetSecurityInfoMask failed: hr = 0x%x",
                      hr);
         break;
      }


      //
      //Build the Security Descriptor
      //
      pSD = (PISECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
      if (pSD == NULL)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to allocate memory for Security Descriptor");
         hr = E_OUTOFMEMORY;
         break;
      }
        
      //Security Review:This is fine.
	  InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

      //
      // Finally, build the security descriptor
      //
      pSD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ
                     | (sdControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

      if(pDacl->AclSize)
      {
         pSD->Dacl = pDacl;
      }

      //
      // Need the total size
      //
      dwSDLength = GetSecurityDescriptorLength(pSD);

      //
      // If necessary, make a self-relative copy of the security descriptor
      //
      psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

      if (psd == NULL ||
          !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"MakeSelfRelativeSD failed: hr = 0x%x",
                      hr);
         break;
      }


      attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeValue.SecurityDescriptor.dwLength = dwSDLength;
      attributeValue.SecurityDescriptor.lpValue = (LPBYTE)psd;

      attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
      attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
      attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeInfo.pADsValues = &attributeValue;
      attributeInfo.dwNumValues = 1;

      // Write the security descriptor
      hr = pDsObject->SetObjectAttributes(&attributeInfo,
                                         1,
                                         &dwAttributesModified);
   } while (false);
    
   if (psd != NULL)
   {
      LocalFree(psd);
   }

   if(pSD != NULL)
   {
      LocalFree(pSD);
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.inc

!ENDIF

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE=..\pch.h

!IF !defined(DISPLAY_BASEDIR)
DISPLAY_BASEDIR = $(PROJECT_ROOT)\display
!ENDIF

INCLUDES= $(O);                        \
          ..;                          \
          ..\parser;                   \
          $(BASE_INC_PATH);            \
          $(DISPLAY_BASEDIR)\inc;      \
          $(DISPLAY_BASEDIR)\proppage; \
          $(PROJECT_ROOT)\dsadminlib\inc; 

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

# so will be built unicode
C_DEFINES=-DUNICODE -D_UNICODE 

MSC_WARNING_LEVEL= /W4

USE_ATL=1
ATL_VER=30
USE_IOSTREAM=1

LINKLIBS=\
    ..\parser\$(O)\parser.lib

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\ntdll.lib       \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\activeds.lib    \
    $(SDK_LIB_PATH)\adsiid.lib      \
    $(SDK_LIB_PATH)\dsprop.lib      \
    $(SDK_LIB_PATH)\secur32.lib     \
    $(SDK_LIB_PATH)\crypt32.lib     \
    $(SDK_LIB_PATH)\Ntdsapi.lib     \
    $(SDK_LIB_PATH)\Netapi32.lib    \
    $(SHELL_LIB_PATH)\comctlp.lib   \
    $(PROJECT_ROOT)\dsadminlib\src\$(O)\dsadminp.lib

SOURCES= \
    ..\parserutil.cpp \
    ..\secutil.cpp    \
    ..\util.cpp       \
    ..\query.cpp      \
    ..\dsutil.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      strings.h
//
//  Contents:  Global strings that will be needed throughout this project
//
//  History:   06-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _STRINGS_H_
#define _STRINGS_H_

static const BSTR g_bstrLDAPProvider         = L"LDAP://";
static const BSTR g_bstrGCProvider           = L"GC://";
static const BSTR g_bstrRootDSE              = L"RootDSE";
static const BSTR g_bstrDefaultNCProperty    = L"defaultNamingContext";
static const BSTR g_bstrSchemaNCProperty     = L"schemaNamingContext";
static const BSTR g_bstrConfigNCProperty     = L"configurationNamingContext";

static const BSTR g_bstrGroupScopeLocal      = L"l";
static const BSTR g_bstrGroupScopeUniversal  = L"u";
static const BSTR g_bstrGroupScopeGlobal     = L"g";

static const BSTR g_bstrNever                = L"NEVER";
static const BSTR g_bstrYes                  = L"yes";
static const BSTR g_bstrNo                   = L"no";

// Other attributes
static const BSTR g_bstrIDManagerReference   = L"rIDManagerReference";
static const BSTR g_bstrFSMORoleOwner        = L"fSMORoleOwner";
static const BSTR g_bstrDNSHostName          = L"dNSHostName";


#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      Util.cpp
//
//  Contents:  Generic utility functions and classes for dscmd
//
//  History:   01-Oct-2000 JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "util.h"

#ifdef DBG

//
// Globals
//
CDebugSpew  DebugSpew;

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::EnterFunction
//
//  Synopsis:   Outputs "Enter " followed by the function name (or any passed
//              in string) and then calls Indent so that any output is indented
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                   be spewed
//              [pszFunction - IN] : a string to output to the console which
//                                   is proceeded by "Entering "
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::EnterFunction(UINT nDebugLevel, PCWSTR pszFunction)
{
   //
   // Verify input parameter
   //
   if (!pszFunction)
   {
      ASSERT(pszFunction);
      return;
   }

   CComBSTR sbstrOutput(L"Entering ");
   sbstrOutput += pszFunction;

   //
   // Output the debug spew
   //
   Output(nDebugLevel, sbstrOutput);

   //
   // Indent
   //
   Indent();
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::LeaveFunction
//
//  Synopsis:   Outputs "Exit " followed by the function name (or any passed
//              in string) and then calls Outdent
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                   be spewed
//              [pszFunction - IN] : a string to output to the console which
//                                   is proceeded by "Leaving "
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::LeaveFunction(UINT nDebugLevel, PCWSTR pszFunction)
{
   //
   // Verify input parameter
   //
   if (!pszFunction)
   {
      ASSERT(pszFunction);
      return;
   }

   //
   // Outdent
   //
   Outdent();

   CComBSTR sbstrOutput(L"Leaving ");
   sbstrOutput += pszFunction;

   //
   // Output the debug spew
   //
   Output(nDebugLevel, sbstrOutput);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::LeaveFunctionHr
//
//  Synopsis:   Outputs "Exit " followed by the function name (or any passed
//              in string), the HRESULT return value, and then calls Outdent
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                   be spewed
//              [pszFunction - IN] : a string to output to the console which
//                                   is proceeded by "Leaving "
//              [hr - IN]          : the HRESULT result value that is being
//                                   returned by the function
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::LeaveFunctionHr(UINT nDebugLevel, PCWSTR pszFunction, HRESULT hr)
{
   //
   // Verify input parameter
   //
   if (!pszFunction)
   {
      ASSERT(pszFunction);
      return;
   }

   //
   // Outdent
   //
   Outdent();

   CComBSTR sbstrOutput(L"Leaving ");
   sbstrOutput += pszFunction;

   //
   // Append the return value
   //
   WCHAR pszReturn[30];
   //Security Review:Enough buffer is provided.
   wsprintf(pszReturn, L" returning 0x%x", hr);

   sbstrOutput += pszReturn;

   //
   // Output the debug spew
   //
   Output(nDebugLevel, sbstrOutput);
}

//+--------------------------------------------------------------------------
//
//  Member:     OsName
//
//  Synopsis:   Returns a readable string of the platform
//
//  Arguments:  [refInfo IN] : reference the OS version info structure
//                             retrieved from GetVersionEx()
//
//  Returns:    PWSTR : returns a pointer to static text describing the
//                      platform.  The returned string does not have to 
//                      be freed.
//
//  History:    20-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
PWSTR OsName(const OSVERSIONINFO& refInfo)
{
   switch (refInfo.dwPlatformId)
   {
      case VER_PLATFORM_WIN32s:
      {
         return L"Win32s on Windows 3.1";
      }
      case VER_PLATFORM_WIN32_WINDOWS:
      {
         switch (refInfo.dwMinorVersion)
         {
            case 0:
            {
               return L"Windows 95";
            }
            case 1:
            {
               return L"Windows 98";
            }
            default:
            {
               return L"Windows 9X";
            }
         }
      }
      case VER_PLATFORM_WIN32_NT:
      {
         return L"Windows NT";
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }
   return L"Some Unknown Windows Version";
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::SpewHeader
//
//  Synopsis:   Outputs debug information like command line and build info
//
//  Arguments:  
//
//  Returns:    
//
//  History:    20-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::SpewHeader()
{
   //
   // First output the command line
   //
   PWSTR pszCommandLine = GetCommandLine();
   if (pszCommandLine)
   {
      Output(MINIMAL_LOGGING,
             L"Command line: %s",
             GetCommandLine());
   }

   //
   // Output the module being used
   //
   do // false loop
   {
      //
      // Get the file path
      //
      WCHAR pszFileName[MAX_PATH + 1];
      ::ZeroMemory(pszFileName, sizeof(pszFileName));

	  //Security Review:If the path is MAX_PATH long, API will return MAX_PATH and won't
	  //NULL terminate, but we are fine since we allocated buffer of size MAX_PATH + 1
	  //and set it to Zero
      if (::GetModuleFileNameW(::GetModuleHandle(NULL), pszFileName, MAX_PATH) == 0)
      {
         break;
      }

      Output(MINIMAL_LOGGING,
             L"Module: %s",
             pszFileName);

      //
      // get the file attributes
      //
      WIN32_FILE_ATTRIBUTE_DATA attr;
      ::ZeroMemory(&attr, sizeof(attr));

      if (::GetFileAttributesEx(pszFileName, GetFileExInfoStandard, &attr) == 0)
      {
         break;
      }

      //
      // convert the filetime to a system time
      //
      FILETIME localtime;
      ::FileTimeToLocalFileTime(&attr.ftLastWriteTime, &localtime);
      SYSTEMTIME systime;
      ::FileTimeToSystemTime(&localtime, &systime);

      //
      // output the timestamp
      //
      Output(MINIMAL_LOGGING,
             L"Timestamp: %2d/%2d/%4d %2d:%2d:%d.%d",
             systime.wMonth,
             systime.wDay,
             systime.wYear,
             systime.wHour,
             systime.wMinute,
             systime.wSecond,
             systime.wMilliseconds);
   } while (false);

   //
   // Get the system info
   //
   OSVERSIONINFO info;
   info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

   BOOL success = ::GetVersionEx(&info);
   ASSERT(success);

   //
   // Get the Whistler build lab version
   //
   CComBSTR sbstrLabInfo;

   do // false loop
   { 
      HKEY key = 0;
      LONG err = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                                0,
                                KEY_READ,
                                &key);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      WCHAR buf[MAX_PATH + 1];
      ::ZeroMemory(buf, sizeof(buf));

      DWORD type = 0;
      DWORD bufSize = sizeof(WCHAR)*MAX_PATH;
      //NTRAID#NTBUG9-573572-2002/05/24, yanggao, bufSize is the size in bytes according to RegQueryValueEx.
      //In order to terminate the returned value, give it value sizeof(WCHAR)*MAX_PATH.

	  //Security Review: when buffers match the exact length of data 
	  //value data is not null terminated.
	  //NTRAID#NTBUG9-573572-2002/03/12-hiteshr
      err = ::RegQueryValueEx(key,
                              L"BuildLab",
                              0,
                              &type,
                              reinterpret_cast<BYTE*>(buf),
                              &bufSize);
      if (err != ERROR_SUCCESS)
      {
         break;
      }
   
      sbstrLabInfo = buf;
   } while (false);

   Output(MINIMAL_LOGGING,
          L"Build: %s %d.%d build %d %s (BuildLab:%s)",
          OsName(info),
          info.dwMajorVersion,
          info.dwMinorVersion,
          info.dwBuildNumber,
          info.szCSDVersion,
          sbstrLabInfo);

   //
   // Output a blank line to separate the header from the rest of the output
   //
   Output(MINIMAL_LOGGING,
          L"\r\n");
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::Output
//
//  Synopsis:   Outputs the passed in string to stdout proceeded by the number
//              of spaces specified by GetIndent()
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                 be spewed
//              [pszOutput - IN] : a format string to output to the console
//              [... - IN]       : a variable argument list to be formatted
//                                 into pszOutput similar to wprintf
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::Output(UINT nDebugLevel, PCWSTR pszOutput, ...)
{
   if (nDebugLevel <= GetDebugLevel())
   {
      //
      // Verify parameters
      //
      if (!pszOutput)
      {
         ASSERT(pszOutput);
         return;
      }

      va_list args;
      va_start(args, pszOutput);

      WCHAR szBuffer[1024];

	  //Security Review:Check for the return value of function and also
	  //consider replacing it with strsafe api.
	  //NTRAID#NTBUG9-573602-2002/03/12-hiteshr
      if(FAILED(StringCchVPrintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), pszOutput, args)))
          return;

      CComBSTR sbstrOutput;

      //
      // Insert the spaces for the indent
      //
      for (UINT nCount = 0; nCount < GetIndent(); nCount++)
      {
         sbstrOutput += L" ";
      }

      //
      // Append the output string
      //
      sbstrOutput += szBuffer;

      //
      // Output the results
      //
      WriteStandardOut(L"%s\r\n", sbstrOutput);

      va_end(args);
   }
}

#endif // DBG

//+--------------------------------------------------------------------------
//
//  Macro:      MyA2WHelper
//
//  Synopsis:   Converts a string from Ansi to Unicode in the OEM codepage
//
//  Arguments:  [lpa - IN] : Ansi string to be converted
//              [acp - IN] : the codepage to use
//
//  Returns:    PWSTR : the Unicode string in the OEM codepage. Caller
//                      must free the returned pointer using delete[]
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
inline PWSTR WINAPI MyA2WHelper(LPCSTR lpa, UINT acp)
{
   ASSERT(lpa != NULL);

   // Use MultiByteToWideChar without a buffer to find out the required
   // size

   PWSTR wideString = 0;

   int result = MultiByteToWideChar(acp, 0, lpa, -1, 0, 0);
   if (result)
   {
      wideString = new WCHAR[result];
      if (wideString)
      {
         result = MultiByteToWideChar(acp, 0, lpa, -1, wideString, result);
      }
   }
   return wideString;
}

//+--------------------------------------------------------------------------
//
//  Function:   _UnicodeToOemConvert
//
//  Synopsis:   takes the passed in string (pszUnicode) and converts it to
//              the OEM code page
//
//  Arguments:  [pszUnicode - IN] : the string to be converted
//              [sbstrOemUnicode - OUT] : the converted string
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void _UnicodeToOemConvert(PCWSTR pszUnicode, CComBSTR& sbstrOemUnicode)
{
  
  if (!pszUnicode)
  {
     ASSERT(pszUnicode);
     return;
  }

  // Use WideCharToMultiByte without a buffer to find out
  // the required size

  int result = 
     WideCharToMultiByte(
        CP_OEMCP, 
        0, 
        pszUnicode, 
        -1, 
        0, 
        0,
        0,
        0);

  if (result)
  {
     // Now allocate and convert the string

     PSTR pszOemAnsi = new CHAR[result];
     if (pszOemAnsi)
     {
        ZeroMemory(pszOemAnsi, result * sizeof(CHAR));

        result = 
           WideCharToMultiByte(
              CP_OEMCP, 
              0, 
              pszUnicode, 
              -1, 
              pszOemAnsi, 
              result * sizeof(CHAR), 
              0, 
              0);

        ASSERT(result);

        //
        // convert it back to WCHAR on OEM CP
        //
        PWSTR oemUnicode = MyA2WHelper(pszOemAnsi, CP_OEMCP);
        if (oemUnicode)
        {
           sbstrOemUnicode = oemUnicode;
           delete[] oemUnicode;
           oemUnicode = 0;
        }
        delete[] pszOemAnsi;
        pszOemAnsi = 0;
     }
  }
}


//+--------------------------------------------------------------------------
//
//  Function:   SpewAttrs(ADS_ATTR_INFO* pCreateAttrs, DWORD dwNumAttrs);
//
//  Synopsis:   Uses the DEBUG_OUTPUT macro to output the attributes and the
//              values specified
//
//  Arguments:  [pAttrs - IN] : The ADS_ATTR_INFO
//              [dwNumAttrs - IN] : The number of attributes in pAttrs
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#ifdef DBG
void SpewAttrs(ADS_ATTR_INFO* pAttrs, DWORD dwNumAttrs)
{
   for (DWORD dwAttrIdx = 0; dwAttrIdx < dwNumAttrs; dwAttrIdx++)
   {
      if (pAttrs[dwAttrIdx].dwADsType == ADSTYPE_DN_STRING           ||
          pAttrs[dwAttrIdx].dwADsType == ADSTYPE_CASE_EXACT_STRING   ||
          pAttrs[dwAttrIdx].dwADsType == ADSTYPE_CASE_IGNORE_STRING  ||
          pAttrs[dwAttrIdx].dwADsType == ADSTYPE_PRINTABLE_STRING)
      {
         for (DWORD dwValueIdx = 0; dwValueIdx < pAttrs[dwAttrIdx].dwNumValues; dwValueIdx++)
         {
            if (pAttrs[dwAttrIdx].pADsValues[dwValueIdx].CaseIgnoreString)
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"   %s = %s", 
                            pAttrs[dwAttrIdx].pszAttrName, 
                            pAttrs[dwAttrIdx].pADsValues[dwValueIdx].CaseIgnoreString);
            }
            else
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"   %s = value being cleared", 
                            pAttrs[dwAttrIdx].pszAttrName);
            }
         }
      }
   }
}

#endif // DBG

//+--------------------------------------------------------------------------
//
//  Function:   litow
//
//  Synopsis:   
//
//  Arguments:  [li - IN] :  reference to large integer to be converted to string
//              [sResult - OUT] : Gets the output string
//  Returns:    void
//
//  History:    25-Sep-2000   hiteshr   Created
//              Copied from dsadmin code base, changed work with CComBSTR
//---------------------------------------------------------------------------

void litow(LARGE_INTEGER& li, CComBSTR& sResult)
{
	LARGE_INTEGER n;
	n.QuadPart = li.QuadPart;
	
	if (n.QuadPart == 0)
	{
		sResult = L"0";
	}
	else
	{
		CComBSTR sNeg;
		sResult = L"";
		if (n.QuadPart < 0)
		{
			sNeg = CComBSTR(L'-');
			n.QuadPart *= -1;
		}
		while (n.QuadPart > 0)
		{
			WCHAR ch[2];
			ch[0] = static_cast<WCHAR>(L'0' + static_cast<WCHAR>(n.QuadPart % 10));
			ch[1] = L'\0';
			sResult += ch;
			n.QuadPart = n.QuadPart / 10;
		}
		sResult += sNeg;
	}
	
	//Reverse the string
	//Security Review:256 is good enough for largest LARGE_INTEGER.
	//But since limit of string is known, a good case for using strsafe api.
	//NTRAID#NTBUG9-577081-2002/03/12-hiteshr
	WCHAR szTemp[256];  
	if(SUCCEEDED(StringCchCopy(szTemp, 256, sResult)))
	{
		LPWSTR pStart,pEnd;
		pStart = szTemp;
		//Security Review Done.
		pEnd = pStart + wcslen(pStart) -1;
		while(pStart < pEnd)
		{
			WCHAR ch = *pStart;
			*pStart++ = *pEnd;
			*pEnd-- = ch;
		}
		
		sResult = szTemp;
	}	
}



//+--------------------------------------------------------------------------
//
//  Function:   EncryptPasswordString
//
//  Synopsis:Encrypts a password.
//
//  Arguments:[pszPassword - IN] :  Input Password. Input password must be 
//					 smaller than MAX_PASSWORD_LENGTH chars in length. Function
//					 doesnot modify this string.
//              
//				  [pEncryptedDataBlob - OUT] : Gets the output encrypted 
//					datablob. 
//  Returns:    HRESULT
//
//  History:    27-March-2002   hiteshr   Created
//---------------------------------------------------------------------------
HRESULT
EncryptPasswordString(IN LPCWSTR pszPassword,
					  OUT DATA_BLOB *pEncryptedDataBlob)
{

	if(!pszPassword || !pEncryptedDataBlob)
	{
		ASSERT(pszPassword);
		ASSERT(pEncryptedDataBlob);
		return E_POINTER;
	}

	HRESULT hr = S_OK;
	do
	{
	
		//Vaidate the length of input password. MAX_PASSWORD_LENGTH includes terminating
		//NULL character.
        size_t len = 0;
		hr = StringCchLength(pszPassword,
							 MAX_PASSWORD_LENGTH,
							 &len);
		if(FAILED(hr))
		{
			hr = E_INVALIDARG;
			break;
		}

    
        DATA_BLOB inDataBlob;
        
        inDataBlob.pbData = (BYTE*)pszPassword;
        inDataBlob.cbData = (DWORD)(len + 1)*sizeof(WCHAR);

		//Encrypt data 
		if(!CryptProtectData(&inDataBlob,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             CRYPTPROTECT_UI_FORBIDDEN,
                             pEncryptedDataBlob))
        {
            pEncryptedDataBlob->pbData = NULL;
			DWORD dwErr = GetLastError();
			hr = HRESULT_FROM_WIN32(dwErr);
			break;
		}

	}while(0);

	return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DecryptPasswordString
//
//  Synopsis:   Decrypt encrypted password data. 
//
//  Arguments:  [pEncryptedDataBlob- IN] :  Input encrypted password data. 
//              [ppszPassword - OUT] :Gets the output decrypted password. 
//              This must be freed using LocalFree                
//  Returns:    HRESULT
//
//  History:    27-March-2002   hiteshr   Created
//---------------------------------------------------------------------------
HRESULT
DecryptPasswordString(IN const DATA_BLOB* pEncryptedDataBlob,
					  OUT LPWSTR *ppszPassword)
{
    if(!pEncryptedDataBlob || !ppszPassword)
	{
		ASSERT(pEncryptedDataBlob);
		ASSERT(ppszPassword);
		return E_POINTER;
	}

	HRESULT hr = S_OK;
	do
	{

        DATA_BLOB decryptedDataBlob;
		if(!CryptUnprotectData((DATA_BLOB*)pEncryptedDataBlob,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               CRYPTPROTECT_UI_FORBIDDEN,
                               &decryptedDataBlob))
		{
			DWORD dwErr = GetLastError();
			hr = HRESULT_FROM_WIN32(dwErr);
			break;
		}

        *ppszPassword = (LPWSTR)decryptedDataBlob.pbData;
	}while(0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsadd\addtable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      addtable.h
//
//  Contents:  Declares a table which contains the classes which can be
//             created through dsadd.exe
//
//  History:   22-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _ADDTABLE_H_
#define _ADDTABLE_H_

typedef enum DSADD_COMMAND_ENUM
{
   eCommContinue = eCommLast+1,
   eCommObjectType,
   eCommDescription,
   eTerminator,

   //
   // User and Contact switches
   //
   eUserObjectDNorName = eTerminator,
   eUserSam,
   eUserUpn,
   eUserFn,
   eUserMi,
   eUserLn,
   eUserDisplay,
   eUserEmpID,
   eUserPwd,
   eUserMemberOf,
   eUserOffice,
   eUserTel,
   eUserEmail,
   eUserHometel,
   eUserPager,
   eUserMobile,
   eUserFax,
   eUserIPPhone,
   eUserWebPage,
   eUserTitle,
   eUserDept,
   eUserCompany,
   eUserManager,
   eUserHomeDir,
   eUserHomeDrive,
   eUserProfilePath,
   eUserScriptPath,
   eUserMustchpwd,
   eUserCanchpwd,
   eUserReversiblePwd,
   eUserPwdneverexpires,
   eUserAcctexpires,
   eUserPwdNotReqd,
   eUserDisabled,

   //
   // Contact switches
   //
   eContactObjectDNorName = eTerminator,
   eContactFn,
   eContactMi,
   eContactLn,
   eContactDisplay,
   eContactOffice,
   eContactTel,
   eContactEmail,
   eContactHometel,
   eContactIPPhone,
   eContactPager,
   eContactMobile,
   eContactFax,
   eContactTitle,
   eContactDept,
   eContactCompany,

   //
   // Computer switches
   //
   eComputerObjectDNorName = eTerminator,
   eComputerSamname,
   eComputerLocation,
   eComputerMemberOf,

   //
   // Group switches
   //
   eGroupObjectDNorName = eTerminator,
   eGroupSamname,
   eGroupSecgrp,
   eGroupScope,
   eGroupMemberOf,
   eGroupMembers,

   //
   // OU switches
   //
   eOUObjectDNorName = eTerminator,

   //
   // Subnet switches
   //
   eSubnetObjectDNorName = eTerminator,
   eSubnetSite,

   //
   // Site switches
   // 
   eSiteObjectDNorName = eTerminator,
   eSiteAutotopology,

   //
   // Site Link switches
   //
   eSLinkObjectDNorName = eTerminator,
   eSLinkIp,
   eSLinkSmtp,
   eSLinkAddsite,
   eSLinkRmsite,
   eSLinkCost,
   eSLinkRepint,
   eSLinkAutobacksync,
   eSLinkNotify,

   //
   // Site Link Bridge switches
   //
   eSLinkBrObjectDNorName = eTerminator,
   eSLinkBrIp,
   eSLinkBrSmtp,
   eSLinkBrAddslink,
   eSLinkBrRmslink,

   //
   // Replication Connection switches
   // 
   eConnObjectDNorName = eTerminator,
   eConnTransport,
   eConnEnabled,
   eConnManual,
   eConnAutobacksync,
   eConnNotify,

   //
   // Server switches
   //
   eServerObjectDNorName = eTerminator,
   eServerAutotopology,

   //
   // Quota switches
   //
   eQuotaPart = eTerminator,
   eQuotaRDN,
   eQuotaAcct,
   eQuotaQlimit,
};

//
// The parser table
//
extern ARG_RECORD DSADD_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSOBJECTTABLEENTRY g_DSObjectTable[];

//
//Usage Tables
//
extern UINT USAGE_DSADD[];
extern UINT USAGE_DSADD_OU[];
extern UINT USAGE_DSADD_USER[];
extern UINT USAGE_DSADD_CONTACT[];
extern UINT USAGE_DSADD_COMPUTER[];
extern UINT USAGE_DSADD_GROUP[];
extern UINT USAGE_DSADD_QUOTA[];

#endif //_ADDTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsadd\addtable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      addtable.cpp
//
//  Contents:  Defines a table which contains the classes which can be
//             created through dsadd.exe
//
//  History:   22-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "addtable.h"
#include "usage.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSADD_COMMON_COMMANDS[] = 
{

   COMMON_COMMANDS

   //
   // c  Continue
   //
   0,(PWSTR)c_sz_arg1_com_continue,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0, NULL,

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN,  
   0,    
   0,  NULL,

   //
   // description
   //
   0, (PWSTR)c_sz_arg1_com_description,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSADD_USER_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

   //
   // samid  sAMAccountName
   //
   0, (PWSTR)g_pszArg1UserSAM,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // upn
   //
   0, (PWSTR)g_pszArg1UserUPN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // empid  Employee ID
   //
   0, (PWSTR)g_pszArg1UserEmpID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pwd Password
   //
   0, (PWSTR)g_pszArg1UserPassword, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_PASSWORD, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateUserPassword,

   //
   // memberOf MemberOf
   //
   0, (PWSTR)g_pszArg1UserMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0, NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // iptel IP Telephone
   //
   0, (PWSTR)g_pszArg1UserIPTel, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // webpg  Web Page
   //
   0, (PWSTR)g_pszArg1UserWebPage, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mgr Manager
   //
   0, (PWSTR)g_pszArg1UserManager, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // hmdir  Home Directory
   //
   0, (PWSTR)g_pszArg1UserHomeDirectory, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hmdrv  Home Drive
   //
   0, (PWSTR)g_pszArg1UserHomeDrive, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // profile Profile path
   //
   0, (PWSTR)g_pszArg1UserProfilePath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // loscr Script path
   //
   0, (PWSTR)g_pszArg1UserScriptPath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mustchpwd Must Change Password at next logon
   //
   0, (PWSTR)g_pszArg1UserMustChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,

   //
   // canchpwd Can Change Password
   //
   0, (PWSTR)g_pszArg1UserCanChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,
   
   //
   // reversiblepwd  Password stored with reversible encryption
   //
   0, (PWSTR)g_pszArg1UserReversiblePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,

   //
   // pwdneverexpires Password never expires
   //
   0, (PWSTR)g_pszArg1UserPwdNeverExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,
 
   //
   // acctexpires Account Expires
   //
   0, (PWSTR)g_pszArg1UserAccountExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_INTSTR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateNever,
  
   //
   // Password Not Required - There is actually
   // no switch for this but the table entry is
   // required so that we can set this value
   // to a default
   //
   0, 0, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  0,

   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1UserDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,

   ARG_TERMINATOR
};

ARG_RECORD DSADD_COMPUTER_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

   //
   // samname
   //
   0, (PWSTR)g_pszArg1ComputerSAMName,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // loc Location
   //
   0, (PWSTR)g_pszArg1ComputerLocation,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // disabled
   //
   0, (PWSTR)g_pszArg1ComputerMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSADD_OU_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSADD_GROUP_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

   //
   // samname
   //
   0, (PWSTR)g_pszArg1GroupSAMName,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // secgrp Security enabled
   //
   0, (PWSTR)g_pszArg1GroupSec,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateYesNo,

   //
   // scope Group scope (local/global/universal)
   //
   0, (PWSTR)g_pszArg1GroupScope,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateGroupScope,

   //
   // memberof  MemberOf
   //
   0, (PWSTR)g_pszArg1GroupMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0,  NULL,

   //
   // members  Members of the group
   //
   0, (PWSTR)g_pszArg1GroupMembers,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSADD_CONTACT_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // iptel IP Telephone
   //
   0, (PWSTR)g_pszArg1UserIPTel, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSADD_QUOTA_COMMANDS[]=
{
   //
   // partitionDN
   //
   0,(PWSTR)g_pszArg1QuotaPart, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //
    // rdn
    //
    0, (PWSTR)g_pszArg1QuotaRDN,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0, NULL,

    //
    // acct
    //
    0, (PWSTR)g_pszArg1QuotaAcct,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_REQUIRED,
    0,
    0, NULL,

    //
    // qlimit
    //
    0, (PWSTR)g_pszArg1QuotaQLimit,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_INT, ARG_FLAG_REQUIRED,
    0,
    0, NULL,

   ARG_TERMINATOR
};

/*
ARG_RECORD DSADD_SUBNET_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //name_or_objectdn
    IDS_ARG1_SUBNET_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SUBNET_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SUBNET_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //site
    IDS_ARG1_SUBNET_SITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_SITE_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //name_or_objectdn
    IDS_ARG1_SITE_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
        ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SITE_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SITE_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autotopology
    IDS_ARG1_SITE_AUTOTOPOLOGY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_SLINK_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //name_or_objectdn
    IDS_ARG1_SLINK_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINK_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINK_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINK_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addsite
    IDS_ARG1_SLINK_ADDSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmsite
    IDS_ARG1_SLINK_RMSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //cost
    IDS_ARG1_SLINK_COST, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //repint
    IDS_ARG1_SLINK_REPINT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINK_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_SLINK_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_SLINK_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_SLINKBR_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //name_or_objectdn
    IDS_ARG1_SLINKBR_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINKBR_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINKBR_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINKBR_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addslink
    IDS_ARG1_SLINKBR_ADDSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmslink
    IDS_ARG1_SLINKBR_RMSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINKBR_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_CONN_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //name_or_objectdn
    IDS_ARG1_CONN_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //transport
    IDS_ARG1_CONN_TRANSPORT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //enabled
    IDS_ARG1_CONN_ENABLED, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_CONN_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //manual
    IDS_ARG1_CONN_MANUAL, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_CONN_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_CONN_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};

ARG_RECORD DSADD_SERVER_COMMANDS[]=
{
   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN|ARG_FLAG_STDIN,
   0,    
   0,  NULL,

    //name_or_objectdn
    IDS_ARG1_SERVER_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SERVER_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SERVER_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autotopology
    IDS_ARG1_SERVER_AUTOTOPOLOGY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


*/

//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------

//
// Description
//
DSATTRIBUTEDESCRIPTION description =
{
   {
      L"description",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY descriptionEntry =
{
   L"description",
   eCommDescription,
   DS_ATTRIBUTE_ONCREATE,
   &description,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// UPN
//
DSATTRIBUTEDESCRIPTION upn =
{
   {
      L"userPrincipalName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY upnUserEntry =
{
   L"userPrincipalName",
   eUserUpn,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &upn,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// First name
//
DSATTRIBUTEDESCRIPTION firstName =
{
   {
      L"givenName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY firstNameUserEntry =
{
   L"givenName",
   eUserFn,
   DS_ATTRIBUTE_ONCREATE,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY firstNameContactEntry =
{
   L"givenName",
   eContactFn,
   DS_ATTRIBUTE_ONCREATE,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Middle Initial
//
DSATTRIBUTEDESCRIPTION middleInitial =
{
   {
      L"initials",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY middleInitialUserEntry =
{
   L"initials",
   eUserMi,
   DS_ATTRIBUTE_ONCREATE,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY middleInitialContactEntry =
{
   L"initials",
   eContactMi,
   DS_ATTRIBUTE_ONCREATE,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Last name
//
DSATTRIBUTEDESCRIPTION lastName =
{
   {
      L"sn",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY lastNameUserEntry =
{
   L"sn",
   eUserLn,
   DS_ATTRIBUTE_ONCREATE,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY lastNameContactEntry =
{
   L"sn",
   eContactLn,
   DS_ATTRIBUTE_ONCREATE,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Display name
//
DSATTRIBUTEDESCRIPTION displayName =
{
   {
      L"displayName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY displayNameUserEntry =
{
   L"displayName",
   eUserDisplay,
   DS_ATTRIBUTE_ONCREATE,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY displayNameContactEntry =
{
   L"displayName",
   eContactDisplay,
   DS_ATTRIBUTE_ONCREATE,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Employee ID
//
DSATTRIBUTEDESCRIPTION employeeID =
{
   {
      L"employeeID",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY employeeIDUserEntry =
{
   L"employeeID",
   eUserEmpID,
   DS_ATTRIBUTE_ONCREATE,
   &employeeID,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Password
//
DSATTRIBUTEDESCRIPTION password =
{
   {
      NULL,
      ADS_ATTR_UPDATE,
      ADSTYPE_INVALID,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY passwordUserEntry =
{
   L"password",
   eUserPwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &password,
   ResetUserPassword,
   NULL
};

//
// Office
//
DSATTRIBUTEDESCRIPTION office =
{
   {
      L"physicalDeliveryOfficeName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY officeUserEntry =
{
   L"physicalDeliveryOfficeName",
   eUserOffice,
   DS_ATTRIBUTE_ONCREATE,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY officeContactEntry =
{
   L"physicalDeliveryOfficeName",
   eContactOffice,
   DS_ATTRIBUTE_ONCREATE,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Telephone
//
DSATTRIBUTEDESCRIPTION telephone =
{
   {
      L"telephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY telephoneUserEntry =
{
   L"telephoneNumber",
   eUserTel,
   DS_ATTRIBUTE_ONCREATE,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY telephoneContactEntry =
{
   L"telephoneNumber",
   eContactTel,
   DS_ATTRIBUTE_ONCREATE,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Email
//
DSATTRIBUTEDESCRIPTION email =
{
   {
      L"mail",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY emailUserEntry =
{
   L"mail",
   eUserEmail,
   DS_ATTRIBUTE_ONCREATE,
   &email,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY emailContactEntry =
{
   L"mail",
   eContactEmail,
   DS_ATTRIBUTE_ONCREATE,
   &email,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Telephone
//
DSATTRIBUTEDESCRIPTION homeTelephone =
{
   {
      L"homePhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeTelephoneUserEntry =
{
   L"homePhone",
   eUserHometel,
   DS_ATTRIBUTE_ONCREATE,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY homeTelephoneContactEntry =
{
   L"homePhone",
   eContactHometel,
   DS_ATTRIBUTE_ONCREATE,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Pager
//
DSATTRIBUTEDESCRIPTION pager =
{
   {
      L"pager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY pagerUserEntry =
{
   L"pager",
   eUserPager,
   DS_ATTRIBUTE_ONCREATE,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY pagerContactEntry =
{
   L"pager",
   eContactPager,
   DS_ATTRIBUTE_ONCREATE,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Mobile phone
//
DSATTRIBUTEDESCRIPTION mobile =
{
   {
      L"mobile",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY mobileUserEntry =
{
   L"mobile",
   eUserMobile,
   DS_ATTRIBUTE_ONCREATE,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY mobileContactEntry =
{
   L"mobile",
   eContactMobile,
   DS_ATTRIBUTE_ONCREATE,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Fax
//
DSATTRIBUTEDESCRIPTION fax =
{
   {
      L"facsimileTelephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY faxUserEntry =
{
   L"facsimileTelephoneNumber",
   eUserFax,
   DS_ATTRIBUTE_ONCREATE,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY faxContactEntry =
{
   L"facsimileTelephoneNumber",
   eContactFax,
   DS_ATTRIBUTE_ONCREATE,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Title
//
DSATTRIBUTEDESCRIPTION title =
{
   {
      L"title",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY titleUserEntry =
{
   L"title",
   eUserTitle,
   DS_ATTRIBUTE_ONCREATE,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY titleContactEntry =
{
   L"title",
   eContactTitle,
   DS_ATTRIBUTE_ONCREATE,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Department
//
DSATTRIBUTEDESCRIPTION department =
{
   {
      L"department",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY departmentUserEntry =
{
   L"department",
   eUserDept,
   DS_ATTRIBUTE_ONCREATE,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY departmentContactEntry =
{
   L"department",
   eContactDept,
   DS_ATTRIBUTE_ONCREATE,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Company
//
DSATTRIBUTEDESCRIPTION company =
{
   {
      L"company",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY companyUserEntry =
{
   L"company",
   eUserCompany,
   DS_ATTRIBUTE_ONCREATE,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY companyContactEntry =
{
   L"company",
   eContactCompany,
   DS_ATTRIBUTE_ONCREATE,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Web Page
//
DSATTRIBUTEDESCRIPTION webPage =
{
   {
      L"wwwHomePage",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY webPageUserEntry =
{
   L"wwwHomePage",
   eUserWebPage,
   DS_ATTRIBUTE_ONCREATE,
   &webPage,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// IP Phone
//
DSATTRIBUTEDESCRIPTION ipPhone =
{
   {
      L"ipPhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY ipPhoneUserEntry =
{
   L"ipPhone",
   eUserIPPhone,
   DS_ATTRIBUTE_ONCREATE,
   &ipPhone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY ipPhoneContactEntry =
{
   L"ipPhone",
   eContactIPPhone,
   DS_ATTRIBUTE_ONCREATE,
   &ipPhone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Script Path
//
DSATTRIBUTEDESCRIPTION scriptPath =
{
   {
      L"scriptPath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY scriptPathUserEntry =
{
   L"scriptPath",
   eUserScriptPath,
   DS_ATTRIBUTE_ONCREATE,
   &scriptPath,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Directory
//
DSATTRIBUTEDESCRIPTION homeDirectory =
{
   {
      L"homeDirectory",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDirectoryUserEntry =
{
   L"homeDirectory",
   eUserHomeDir,
   DS_ATTRIBUTE_ONCREATE,
   &homeDirectory,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Drive
//
DSATTRIBUTEDESCRIPTION homeDrive =
{
   {
      L"homeDrive",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDriveUserEntry =
{
   L"homeDrive",
   eUserHomeDrive,
   DS_ATTRIBUTE_ONCREATE,
   &homeDrive,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Profile Path
//
DSATTRIBUTEDESCRIPTION profilePath =
{
   {
      L"profilePath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY profilePathUserEntry =
{
   L"profilePath",
   eUserProfilePath,
   DS_ATTRIBUTE_ONCREATE,
   &profilePath,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// pwdLastSet
//
DSATTRIBUTEDESCRIPTION pwdLastSet =
{
   {
      L"pwdLastSet",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};
DSATTRIBUTETABLEENTRY mustChangePwdUserEntry =
{
   L"pwdLastSet",
   eUserMustchpwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &pwdLastSet,
   SetMustChangePwd,
   NULL
};

//
// accountExpires
//
DSATTRIBUTEDESCRIPTION accountExpires =
{
   {
      L"accountExpires",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY accountExpiresUserEntry =
{
   L"accountExpires",
   eUserAcctexpires,
   DS_ATTRIBUTE_ONCREATE,
   &accountExpires,
   AccountExpires,
   NULL
};

//
// user account control 
//
DSATTRIBUTEDESCRIPTION userAccountControl =
{
   {
      L"userAccountControl",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY pwdNotReqdUserEntry =
{
   L"userAccountControl",
   eUserPwdNotReqd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   PasswordNotRequired,
   NULL
};

DSATTRIBUTETABLEENTRY disableUserEntry =
{
   L"userAccountControl",
   eUserDisabled,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   DisableAccount,
   NULL
};

DSATTRIBUTETABLEENTRY pwdNeverExpiresUserEntry =
{
   L"userAccountControl",
   eUserPwdneverexpires,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   PwdNeverExpires,
   NULL
};

DSATTRIBUTETABLEENTRY reverisblePwdUserEntry =
{
   L"userAccountControl",
   eUserReversiblePwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   ReversiblePwd,
   NULL
};

DSATTRIBUTETABLEENTRY accountTypeComputerEntry =
{
   L"userAccountControl",
   0,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   SetComputerAccountType,
   0
};

DSATTRIBUTETABLEENTRY disableComputerEntry =
{
   L"userAccountControl",
   NULL,				// does not have a cooresponding command line switch
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   DisableAccount,
   NULL
};

//
// SAM Account Name
//
DSATTRIBUTEDESCRIPTION samAccountName =
{
   {
      L"sAMAccountName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY samNameGroupEntry =
{
   L"sAMAccountName",
   eGroupSamname,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &samAccountName,
   BuildGroupSAMName,
   NULL
};

DSATTRIBUTETABLEENTRY samNameUserEntry =
{
   L"sAMAccountName",
   eUserSam,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &samAccountName,
   BuildUserSAMName,
   NULL
};

DSATTRIBUTETABLEENTRY samNameComputerEntry =
{
   L"sAMAccountName",
   eComputerSamname,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &samAccountName,
   BuildComputerSAMName,
   NULL
};

//
// Manager
//
DSATTRIBUTEDESCRIPTION manager =
{
   {
      L"manager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY managerUserEntry =
{
   L"manager",
   eUserManager,
   DS_ATTRIBUTE_ONCREATE,
   &manager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Group Type
//
DSATTRIBUTEDESCRIPTION groupType =
{
   {
      L"groupType",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupScopeTypeEntry =
{
   L"groupType",
   eGroupScope,
   DS_ATTRIBUTE_ONCREATE,
   &groupType,
   SetGroupScope,
   NULL
};

DSATTRIBUTETABLEENTRY groupSecurityTypeEntry =
{
   L"groupType",
   eGroupSecgrp,
   DS_ATTRIBUTE_ONCREATE,
   &groupType,
   SetGroupSecurity,
   NULL
};

//
// Add Group Members
//
DSATTRIBUTEDESCRIPTION groupMembers =
{
   {
      L"member",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY membersGroupEntry =
{
   L"member",
   eGroupMembers,
   DS_ATTRIBUTE_POSTCREATE,
   &groupMembers,
   ModifyGroupMembers,
   NULL
};

//
// Add object to another group
//
DSATTRIBUTETABLEENTRY memberOfUserEntry =
{
   L"member",
   eUserMemberOf,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &groupMembers,
   MakeMemberOf,
   NULL
};

DSATTRIBUTETABLEENTRY memberOfComputerEntry =
{
   L"member",
   eComputerMemberOf,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &groupMembers,
   MakeMemberOf,
   NULL
};

DSATTRIBUTETABLEENTRY memberOfGroupEntry =
{
   L"member",
   eGroupMemberOf,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &groupMembers,
   MakeMemberOf,
   NULL
};

//
// User Can Change Password
//
DSATTRIBUTETABLEENTRY canChangePwdUserEntry =
{
   NULL,
   eUserCanchpwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   NULL,
   SetCanChangePassword,
   NULL
};

//
// Location
//
DSATTRIBUTEDESCRIPTION location =
{
   {
      L"location",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY locationComputerEntry =
{
   L"location",
   eComputerLocation,
   DS_ATTRIBUTE_ONCREATE,
   &location,
   FillAttrInfoFromObjectEntry,
   NULL
};

////
//// rdn
////
//DSATTRIBUTEDESCRIPTION rdn =
//{
//   {
//      L"cn",
//      ADS_ATTR_UPDATE,
//      ADSTYPE_CASE_IGNORE_STRING,
//      NULL,
//      0
//   },
//   0
//};
//
//DSATTRIBUTETABLEENTRY rdnQuotaEntry =
//{
//   L"rdn",
//   eQuotaRDN,
//   DS_ATTRIBUTE_ONCREATE,
//   &rdn,
//   FillAttrInfoFromObjectEntry,
//   NULL
//};

//
// acct
//
DSATTRIBUTEDESCRIPTION acct =
{
   {
      L"msDS-QuotaTrustee",
      ADS_ATTR_UPDATE,
      ADSTYPE_OCTET_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY acctQuotaEntry =
{
   L"acct",
   eQuotaAcct,
   DS_ATTRIBUTE_ONCREATE,
   &acct,
   SetAccountEntry,
   NULL
};

//
// qlimit
//
DSATTRIBUTEDESCRIPTION qlimit =
{
   {
      L"msDS-QuotaAmount",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY qlimitQuotaEntry =
{
   L"qlimit",
   eQuotaQlimit,
   DS_ATTRIBUTE_ONCREATE,
   &qlimit,
   FillAttrInfoFromObjectEntry,
   NULL
};

//+-------------------------------------------------------------------------
// Objects
//--------------------------------------------------------------------------

//
// Organizational Unit
//

PDSATTRIBUTETABLEENTRY OUAttributeTable[] =
{
   &descriptionEntry
};

DSOBJECTTABLEENTRY g_OUObjectEntry = 
{
   L"organizationalUnit",
   g_pszOU,
   DSADD_OU_COMMANDS,
   USAGE_DSADD_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable
};


//
// User
//

PDSATTRIBUTETABLEENTRY UserAttributeTable[] =
{
   &descriptionEntry,
   &samNameUserEntry,
   &upnUserEntry,
   &firstNameUserEntry,
   &middleInitialUserEntry,
   &lastNameUserEntry,
   &displayNameUserEntry,
   &employeeIDUserEntry,
   &passwordUserEntry,
   &memberOfUserEntry,
   &officeUserEntry,
   &telephoneUserEntry,
   &emailUserEntry,
   &homeTelephoneUserEntry,
   &pagerUserEntry,
   &mobileUserEntry,
   &faxUserEntry,
   &ipPhoneUserEntry,
   &webPageUserEntry,
   &titleUserEntry,
   &departmentUserEntry,
   &companyUserEntry,
   &managerUserEntry,
   &homeDirectoryUserEntry,
   &homeDriveUserEntry,
   &profilePathUserEntry,
   &scriptPathUserEntry,
   &canChangePwdUserEntry,
   &mustChangePwdUserEntry,
   &reverisblePwdUserEntry,
   &pwdNeverExpiresUserEntry,
   &accountExpiresUserEntry,
   &pwdNotReqdUserEntry,
   &disableUserEntry,
};

DSOBJECTTABLEENTRY g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSADD_USER_COMMANDS,
   USAGE_DSADD_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable
};

//
// Contact
//

PDSATTRIBUTETABLEENTRY ContactAttributeTable[] =
{
   &descriptionEntry,
   &firstNameContactEntry,
   &middleInitialContactEntry,
   &lastNameContactEntry,
   &displayNameContactEntry,
   &officeContactEntry,
   &telephoneContactEntry,
   &emailContactEntry,
   &homeTelephoneContactEntry,
   &ipPhoneContactEntry,
   &pagerContactEntry,
   &mobileContactEntry,
   &faxContactEntry,
   &titleContactEntry,
   &departmentContactEntry,
   &companyContactEntry
};

DSOBJECTTABLEENTRY g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSADD_CONTACT_COMMANDS,
   USAGE_DSADD_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable
};

//
// Computer
//

PDSATTRIBUTETABLEENTRY ComputerAttributeTable[] =
{
   &descriptionEntry,
   &samNameComputerEntry,
   &locationComputerEntry,
   &memberOfComputerEntry,
   &accountTypeComputerEntry,
   &disableComputerEntry
};

DSOBJECTTABLEENTRY g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSADD_COMPUTER_COMMANDS,
   USAGE_DSADD_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable
};

//
// Group
//
PDSATTRIBUTETABLEENTRY GroupAttributeTable[] =
{
   &descriptionEntry,
   &samNameGroupEntry,
   &groupScopeTypeEntry,
   &groupSecurityTypeEntry,
   &memberOfGroupEntry,
   &membersGroupEntry,
};

DSOBJECTTABLEENTRY g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSADD_GROUP_COMMANDS,
   USAGE_DSADD_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable
};

//
// Quota
//

PDSATTRIBUTETABLEENTRY QuotaAttributeTable[] =
{
   &descriptionEntry,
   &acctQuotaEntry,
   &qlimitQuotaEntry
};

DSOBJECTTABLEENTRY g_QuotaObjectEntry = 
{
   L"msDS-QuotaControl",
   g_pszQuota,
   DSADD_QUOTA_COMMANDS,
   USAGE_DSADD_QUOTA,
   sizeof(QuotaAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   QuotaAttributeTable
};

//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSOBJECTTABLEENTRY g_DSObjectTable[] =
{
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ContactObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_QuotaObjectEntry,
   NULL
};

//
//Usage Tables
//
UINT USAGE_DSADD[] = 
{
	USAGE_DSADD_DESCRIPTION,
	USAGE_DSADD_REMARKS,
	USAGE_DSADD_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSADD_OU[] = 
{
	USAGE_DSADD_OU_DESCRIPTION,
	USAGE_DSADD_OU_SYNTAX,
	USAGE_DSADD_OU_PARAMETERS,
	USAGE_DSADD_OU_REMARKS,
	USAGE_DSADD_OU_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSADD_USER[] = 
{
	USAGE_DSADD_USER_DESCRIPTION,
	USAGE_DSADD_USER_SYNTAX,
	USAGE_DSADD_USER_PARAMETERS,
	USAGE_DSADD_USER_REMARKS,
	USAGE_DSADD_USER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSADD_CONTACT[] = 
{
	USAGE_DSADD_CONTACT_DESCRIPTION,
	USAGE_DSADD_CONTACT_SYNTAX,
	USAGE_DSADD_CONTACT_REMARKS,
	USAGE_DSADD_CONTACT_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSADD_COMPUTER[] = 
{
	USAGE_DSADD_COMPUTER_DESCRIPTION,
	USAGE_DSADD_COMPUTER_SYNTAX,
	USAGE_DSADD_COMPUTER_PARAMETERS,
	USAGE_DSADD_COMPUTER_REMARKS,
	USAGE_DSADD_COMPUTER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSADD_GROUP[] = 
{
	USAGE_DSADD_GROUP_DESCRIPTION,
	USAGE_DSADD_GROUP_SYNTAX,
	USAGE_DSADD_GROUP_PARAMETERS,
	USAGE_DSADD_GROUP_REMARKS,
	USAGE_DSADD_GROUP_SEE_ALSO,
	USAGE_END,
};

UINT USAGE_DSADD_QUOTA[] = 
{
	USAGE_DSADD_QUOTA_DESCRIPTION,
	USAGE_DSADD_QUOTA_SYNTAX,
	USAGE_DSADD_QUOTA_PARAMETERS,
	USAGE_DSADD_QUOTA_REMARKS,
	USAGE_DSADD_QUOTA_SEE_ALSO,
	USAGE_END,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      Util.h
//
//  Contents:  Generic utility functions and classes for dscmd
//
//  History:   01-Oct-2000 JeffJon  Created
//             
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

#ifdef DBG

//+--------------------------------------------------------------------------
//
//  Class:      CDebugSpew
//
//  Purpose:    Signifies whether to spew debug output on checked builds or not
//
//  History:    01-Oct-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDebugSpew
{
public:
   //
   // Constructor/Destructor
   //
   CDebugSpew()
      : m_nDebugLevel(0),
        m_nIndent(0)
   {}

   ~CDebugSpew() {}

   //
   // Public data accessors
   //
   void SetDebugLevel(UINT nDebugLevel) { m_nDebugLevel = nDebugLevel; }
   UINT GetDebugLevel() { return m_nDebugLevel; }
   bool IsDebugEnabled() const { return (m_nDebugLevel > 0); }

   void SpewHeader();

   void EnterFunction(UINT nLevel, PCWSTR pszFunction);
   void LeaveFunction(UINT nLevel, PCWSTR pszFunction);
   void LeaveFunctionHr(UINT nLevel, PCWSTR pszFunction, HRESULT hr);
   void Output(UINT nLevel, PCWSTR pszOutput, ...);

private:
   //
   // Private data accessors
   //
   void Indent() { m_nIndent += TAB; }
   void Outdent() { (m_nIndent >= TAB) ? m_nIndent -= TAB : m_nIndent = 0; }
   UINT GetIndent() { return m_nIndent; }

   //
   // Private data
   //

   //
   // This should always be in the range of 0 - 10 where zero is no debug output
   // and 10 is complete output
   //
   UINT m_nDebugLevel;
   UINT m_nIndent;

   static const UINT TAB = 3;
};

//
// Globals
//
extern CDebugSpew  DebugSpew;


//+--------------------------------------------------------------------------
//
//  Class:      CFunctionSpew
//
//  Purpose:    Object which outputs the "Enter function" debug spew on creation
//              and outputs the "Leave function" debug spew on destruction
//
//  History:    07-Dec-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CFunctionSpew
{
public:
  //
  // Constructor/Destructor
  //
  CFunctionSpew(UINT   nDebugLevel,
               PCWSTR pszFunctionName)
     : m_nDebugLevel(nDebugLevel),
       m_pszFunctionName(pszFunctionName),
       m_bLeaveAlreadyWritten(false)
  {
    ASSERT(pszFunctionName);
    DebugSpew.EnterFunction(nDebugLevel, pszFunctionName);
  }

  virtual ~CFunctionSpew()
  {
     if (!IsLeaveAlreadyWritten())
     {
       DebugSpew.LeaveFunction(GetDebugLevel(), GetFunctionName());
     }
  }

protected:
  PCWSTR    GetFunctionName()       { return m_pszFunctionName; }
  UINT      GetDebugLevel()         { return m_nDebugLevel; }
  bool      IsLeaveAlreadyWritten() { return m_bLeaveAlreadyWritten; }
  void      SetLeaveAlreadyWritten(){ m_bLeaveAlreadyWritten = true; }

private:
  PCWSTR    m_pszFunctionName;
  UINT      m_nDebugLevel;
  bool      m_bLeaveAlreadyWritten;
};

//+--------------------------------------------------------------------------
//
//  Class:      CFunctionSpewHR
//
//  Purpose:    Object which outputs the "Enter function" debug spew on creation
//              and outputs the "Leave function" with the HRESULT return value
//              on destruction
//
//  History:    07-Dec-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CFunctionSpewHR : public CFunctionSpew
{
public:
  //
  // Constructor/Destructor
  //
  CFunctionSpewHR(UINT     nDebugLevel,
                 PCWSTR   pszFunctionName,
                 HRESULT& refHR)
     : m_refHR(refHR),
       CFunctionSpew(nDebugLevel, pszFunctionName)
  {
  }

  virtual ~CFunctionSpewHR()
  {
    DebugSpew.LeaveFunctionHr(GetDebugLevel(), GetFunctionName(), m_refHR);
    SetLeaveAlreadyWritten();
  }

private:
  HRESULT&  m_refHR;
};


//
// Helper macros for use with CDebugSpew
//
   #define ENABLE_DEBUG_OUTPUT(level)           DebugSpew.SetDebugLevel((level)); \
                                                DebugSpew.SpewHeader();
   #define DISABLE_DEBUG_OUTPUT()               DebugSpew.SetDebugLevel(0);
   #define ENTER_FUNCTION(level, func)          CFunctionSpew functionSpewObject((level), TEXT(#func));
   #define ENTER_FUNCTION_HR(level, func, hr)   HRESULT (hr) = S_OK; \
                                                CFunctionSpewHR functionSpewObject((level), TEXT(#func), (hr));
   #define LEAVE_FUNCTION(level, func)          DebugSpew.LeaveFunction((level), TEXT(#func));
   #define LEAVE_FUNCTION_HR(level, func, hr)   DebugSpew.LeaveFunctionHr((level), TEXT(#func), (hr));
   #define DEBUG_OUTPUT                         DebugSpew.Output
#else
   #define ENABLE_DEBUG_OUTPUT(level)
   #define DISABLE_DEBUG_OUTPUT()
   #define ENTER_FUNCTION(level, func)
   #define ENTER_FUNCTION_HR(level, func, hr)   HRESULT (hr) = S_OK;
   #define LEAVE_FUNCTION(level, func)
   #define LEAVE_FUNCTION_HR(level, func, hr)
   #define DEBUG_OUTPUT
#endif // DBG

//
// Debug log levels - NOTE these can be given more meaningful names as needed
//
enum
{
   NO_DEBUG_LOGGING = 0,
   MINIMAL_LOGGING,
   LEVEL2_LOGGING,
   LEVEL3_LOGGING,
   LEVEL4_LOGGING,
   LEVEL5_LOGGING,
   LEVEL6_LOGGING,
   LEVEL7_LOGGING,
   LEVEL8_LOGGING,
   LEVEL9_LOGGING,
   FULL_LOGGING
};

//+--------------------------------------------------------------------------
//
//  Function:   _UnicodeToOemConvert
//
//  Synopsis:   takes the passed in string (pszUnicode) and converts it to
//              the OEM code page
//
//  Arguments:  [pszUnicode - IN] : the string to be converted
//              [sbstrOemUnicode - OUT] : the converted string
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void _UnicodeToOemConvert(PCWSTR pszUnicode, CComBSTR& sbstrOemUnicode);

//+--------------------------------------------------------------------------
//
//  Function:   SpewAttrs(ADS_ATTR_INFO* pCreateAttrs, DWORD dwNumAttrs);
//
//  Synopsis:   Uses the DEBUG_OUTPUT macro to output the attributes and the
//              values specified
//
//  Arguments:  [pAttrs - IN] : The ADS_ATTR_INFO
//              [dwNumAttrs - IN] : The number of attributes in pAttrs
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#ifdef DBG
void SpewAttrs(ADS_ATTR_INFO* pAttrs, DWORD dwNumAttrs);
#endif // DBG


//+--------------------------------------------------------------------------
//
//  Function:   litow
//
//  Synopsis:   
//
//  Arguments:  [li - IN] :  reference to large integer to be converted to string
//              [sResult - OUT] : Gets the output string
//  Returns:    void
//
//  History:    25-Sep-2000   hiteshr   Created
//              Copied from dsadmin code base, changed work with CComBSTR
//---------------------------------------------------------------------------

void litow(LARGE_INTEGER& li, CComBSTR& sResult);

//+--------------------------------------------------------------------------
//
//  Class:      CManagedStringEntry
//
//  Synopsis:   My own string list entry since we are not using MFC
//
//  History:    25-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
class CManagedStringEntry
{
public:
   //
   // Constructor
   //
   CManagedStringEntry(PCWSTR pszValue) : pNext(NULL), sbstrValue(pszValue) {}

   CComBSTR sbstrValue;
   CManagedStringEntry* pNext;
};

//+--------------------------------------------------------------------------
//
//  Class:      CManagedStringList
//
//  Synopsis:   My own string list since we are not using MFC
//
//  History:    25-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
class CManagedStringList
{
public:
   //
   // Constructor
   //
   CManagedStringList() : m_pHead(NULL), m_pTail(NULL), m_nCount(0) {}

   //
   // Destructor
   //
   ~CManagedStringList()
   {
      DeleteAll();
   }

   void DeleteAll()
   {
      CManagedStringEntry* pEntry = m_pHead;
      while (pEntry != NULL)
      {
         CManagedStringEntry* pTempEntry = pEntry;
         pEntry = pEntry->pNext;
         delete pTempEntry;
      }
      m_nCount = 0;
   }

   void Add(PCWSTR pszValue)
   {
      if (!m_pHead)
      {
         m_pHead = new CManagedStringEntry(pszValue);
         m_pTail = m_pHead;
         m_nCount++;
      }
      else
      {
         ASSERT(m_pTail);
         m_pTail->pNext = new CManagedStringEntry(pszValue);
         if (m_pTail->pNext)
         {
            m_pTail = m_pTail->pNext;
            m_nCount++;
         }
      }
   }

   bool Contains(PCWSTR pszValue)
   {
      bool bRet = false;
      for (CManagedStringEntry* pEntry = m_pHead; pEntry; pEntry = pEntry->pNext)
      {
		 //Security Review:This is fine.
         if (_wcsicmp(pEntry->sbstrValue, pszValue) == 0)
         {
            bRet = true;
            break;
         }
      }
      return bRet;
   }

   UINT GetCount()
   {
      return m_nCount;
   }

   CManagedStringEntry* Pop()
   {
      CManagedStringEntry* ret = m_pHead;
      if (m_pHead)
      {
         m_pHead = m_pHead->pNext;
         ret->pNext = 0;
      }
      return ret;
   }
     
private:
   CManagedStringEntry* m_pHead;
   CManagedStringEntry* m_pTail;

   UINT m_nCount;
};

//+--------------------------------------------------------------------------
//
//  Function:   EncryptPasswordString
//
//  Synopsis:Encrypts a password.
//
//  Arguments:[pszPassword - IN] :  Input Password. Input password must be 
//					 smaller than MAX_PASSWORD_LENGTH chars in length. Function
//					 doesnot modify this string.
//              
//				  [pEncryptedDataBlob - OUT] : Gets the output encrypted 
//					datablob. 
//  Returns:    HRESULT
//
//  History:    27-March-2002   hiteshr   Created
//---------------------------------------------------------------------------
HRESULT
EncryptPasswordString(IN LPCWSTR pszPassword,
					  OUT DATA_BLOB *pEncryptedDataBlob);


//+--------------------------------------------------------------------------
//
//  Function:   DecryptPasswordString
//
//  Synopsis:   Decrypt encrypted password data. 
//
//  Arguments:  [pEncryptedDataBlob- IN] :  Input encrypted password data. 
//              [ppszPassword - OUT] :Gets the output decrypted password. 
//              This must be freed using LocalFree                
//  Returns:    HRESULT
//
//  History:    27-March-2002   hiteshr   Created
//---------------------------------------------------------------------------
HRESULT
DecryptPasswordString(IN const DATA_BLOB* pEncryptedDataBlob,
					  OUT LPWSTR *ppszPassword);
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsadd\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   22-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "commonstrings.cpp"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsadd";

//
// Object types as are typed on the command line
//
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszQuota                   = L"quota";

//
// User and Contact switches
//
PCWSTR g_pszArg1UserSAM             = L"samid";
PCWSTR g_pszArg1UserUPN             = L"upn"; 
PCWSTR g_pszArg1UserFirstName       = L"fn";
PCWSTR g_pszArg1UserMiddleInitial   = L"mi";
PCWSTR g_pszArg1UserLastName        = L"ln";
PCWSTR g_pszArg1UserDisplayName     = L"display";
PCWSTR g_pszArg1UserEmpID           = L"empid";
PCWSTR g_pszArg1UserPassword        = L"pwd";
PCWSTR g_pszArg1UserMemberOf        = L"memberof";
PCWSTR g_pszArg1UserOffice          = L"office";
PCWSTR g_pszArg1UserTelephone       = L"tel"; 
PCWSTR g_pszArg1UserEmail           = L"email";
PCWSTR g_pszArg1UserHomeTelephone   = L"hometel";
PCWSTR g_pszArg1UserPagerNumber     = L"pager"; 
PCWSTR g_pszArg1UserMobileNumber    = L"mobile"; 
PCWSTR g_pszArg1UserFaxNumber       = L"fax";
PCWSTR g_pszArg1UserIPTel           = L"iptel";
PCWSTR g_pszArg1UserWebPage         = L"webpg";
PCWSTR g_pszArg1UserTitle           = L"title";
PCWSTR g_pszArg1UserDepartment      = L"dept"; 
PCWSTR g_pszArg1UserCompany         = L"company";
PCWSTR g_pszArg1UserManager         = L"mgr";
PCWSTR g_pszArg1UserHomeDirectory   = L"hmdir";
PCWSTR g_pszArg1UserHomeDrive       = L"hmdrv";
PCWSTR g_pszArg1UserProfilePath     = L"profile";
PCWSTR g_pszArg1UserScriptPath      = L"loscr";
PCWSTR g_pszArg1UserMustChangePwd   = L"mustchpwd";
PCWSTR g_pszArg1UserCanChangePwd    = L"canchpwd";
PCWSTR g_pszArg1UserReversiblePwd   = L"reversiblepwd";
PCWSTR g_pszArg1UserPwdNeverExpires = L"pwdneverexpires";
PCWSTR g_pszArg1UserAccountExpires  = L"acctexpires";
PCWSTR g_pszArg1UserDisableAccount  = L"disabled";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerSAMName     = L"samid";
PCWSTR g_pszArg1ComputerLocation    = L"loc";
PCWSTR g_pszArg1ComputerMemberOf    = L"memberof";

//
// Group switches
//
PCWSTR g_pszArg1GroupSAMName        = L"samid";
PCWSTR g_pszArg1GroupSec            = L"secgrp";
PCWSTR g_pszArg1GroupScope          = L"scope";
PCWSTR g_pszArg1GroupMemberOf       = L"memberof";
PCWSTR g_pszArg1GroupMembers        = L"members";

//
// Quota switches
//
PCWSTR g_pszArg1QuotaPart        = L"part";
PCWSTR g_pszArg1QuotaRDN         = L"rdn";
PCWSTR g_pszArg1QuotaAcct        = L"acct";
PCWSTR g_pszArg1QuotaQLimit      = L"qlimit";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsadd\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   22-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

#include "commonstrings.h"

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;
extern PCWSTR g_pszQuota;

//
// User and contact switches
//
extern PCWSTR g_pszArg1UserSAM;
extern PCWSTR g_pszArg1UserUPN; 
extern PCWSTR g_pszArg1UserFirstName;
extern PCWSTR g_pszArg1UserMiddleInitial;
extern PCWSTR g_pszArg1UserLastName;
extern PCWSTR g_pszArg1UserDisplayName;
extern PCWSTR g_pszArg1UserEmpID;
extern PCWSTR g_pszArg1UserPassword;
extern PCWSTR g_pszArg1UserMemberOf;
extern PCWSTR g_pszArg1UserOffice;
extern PCWSTR g_pszArg1UserTelephone;
extern PCWSTR g_pszArg1UserEmail;
extern PCWSTR g_pszArg1UserHomeTelephone;
extern PCWSTR g_pszArg1UserPagerNumber;
extern PCWSTR g_pszArg1UserMobileNumber;
extern PCWSTR g_pszArg1UserFaxNumber;
extern PCWSTR g_pszArg1UserIPTel;
extern PCWSTR g_pszArg1UserWebPage;
extern PCWSTR g_pszArg1UserTitle;
extern PCWSTR g_pszArg1UserDepartment;
extern PCWSTR g_pszArg1UserCompany;
extern PCWSTR g_pszArg1UserManager;
extern PCWSTR g_pszArg1UserHomeDirectory;
extern PCWSTR g_pszArg1UserHomeDrive;
extern PCWSTR g_pszArg1UserProfilePath;
extern PCWSTR g_pszArg1UserScriptPath;
extern PCWSTR g_pszArg1UserMustChangePwd;
extern PCWSTR g_pszArg1UserCanChangePwd;
extern PCWSTR g_pszArg1UserReversiblePwd;
extern PCWSTR g_pszArg1UserPwdNeverExpires;
extern PCWSTR g_pszArg1UserDisableAccount;
extern PCWSTR g_pszArg1UserAccountExpires;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerSAMName;
extern PCWSTR g_pszArg1ComputerLocation;
extern PCWSTR g_pszArg1ComputerMemberOf;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupSAMName;
extern PCWSTR g_pszArg1GroupSec;
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupMemberOf;
extern PCWSTR g_pszArg1GroupMembers;

//
// Quota switches
//
extern PCWSTR g_pszArg1QuotaPart;
extern PCWSTR g_pszArg1QuotaRDN;
extern PCWSTR g_pszArg1QuotaAcct;
extern PCWSTR g_pszArg1QuotaQLimit;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsadd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsadd.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_POST_CREATE_FAILURE         101
#define IDS_MSG_DUPLICATE_NAME_ERROR_COMPUTER 102
#define IDS_MSG_DUPLICATE_NAME_ERROR_GROUP 103
#define IDS_MSG_INVALID_PARTITION_ERROR 104
#define IDS_MSG_MULTIPLE_PARTITIONS_ERROR 105
#define IDS_MSG_INVALID_ACCT_ERROR 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsadd\dsadd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsAdd.cpp
//
//  Contents:  Defines the main function and parser tables for the DSAdd
//             command line utility
//
//  History:   22-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "addtable.h"
#include "resource.h"
#include "query.h"
//
// Function Declarations
//
HRESULT DoAddValidation(PARG_RECORD pCommandArgs, BOOL& bErrorShown);

HRESULT DoAdd(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry,
              DSADD_COMMAND_ENUM eObjectDNorName);

HRESULT CreateQuotaName(IN  CDSCmdBasePathsInfo& basePathsInfo, 
                IN  CDSCmdCredentialObject& credentialObject, 
                IN  LPCWSTR lpszRDN, 
                OUT CComBSTR& bstrRDN);

HRESULT DoQuotaValidation(IN  PARG_RECORD pCommandArgs, 
                          IN  PDSOBJECTTABLEENTRY pObjectEntry,
                          IN  CDSCmdBasePathsInfo& basePathsInfo, 
                          IN  CDSCmdCredentialObject& credentialObject,
                          IN  LPCWSTR lpszPartitionDN, 
                          OUT PWSTR* pszNewQuotaDN);

HRESULT GetObjectDNIndex(PDSOBJECTTABLEENTRY pObjectEntry, 
                         int& nCommandEnum);

HRESULT IsQuotaAcctPresent( IN  LPWSTR lpszTrusteeDN, 
                            IN  PCWSTR pszSearchRootPath,
                            IN  CDSCmdBasePathsInfo& basePathsInfo, 
                            IN  const CDSCmdCredentialObject& refCredObject,
                            OUT bool& bFound);


int __cdecl _tmain( VOID )
{

   int argc;
   LPTOKEN pToken = NULL;
   HRESULT hr = S_OK;

   //
   // Initialize COM
   //
   hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
   if (FAILED(hr))
   {
      DisplayErrorMessage(g_pszDSCommandName, 
                          NULL,
                          hr);
      return hr;
   }

   if( !GetCommandInput(&argc,&pToken) )
   {
      PARG_RECORD pNewCommandArgs = 0;

      //
      // False loop
      //
      do
      {
         if(argc == 1)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSADD,TRUE);
            hr = E_INVALIDARG;
            break;
         }
            if(argc == 2)           
            {
               if(IsTokenHelpSwitch(pToken + 1))
                {
                    hr = S_OK;
                    DisplayMessage(USAGE_DSADD,TRUE);
                    break;
                }
         }


         //
         // Find which object table entry to use from
         // the second command line argument
         //
         PDSOBJECTTABLEENTRY pObjectEntry = NULL;
         UINT idx = 0;
         while (true)
         {
            pObjectEntry = g_DSObjectTable[idx];
            if (!pObjectEntry)
            {
               break;
            }

            PWSTR pszObjectType = (pToken+1)->GetToken();
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
               break;
            }
            idx++;
         }

         if (!pObjectEntry)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSADD);
            hr = E_INVALIDARG;
            break;
         }

         //
         // Now that we have the correct table entry, merge the command line table
         // for this object with the common commands
         //
         hr = MergeArgCommand(DSADD_COMMON_COMMANDS, 
                              pObjectEntry->pParserTable, 
                              &pNewCommandArgs);
         if (FAILED(hr))
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayErrorMessage(g_pszDSCommandName, L"", hr);
            break;
         }

         if (!pNewCommandArgs)
         {
            //
            // Display the usage text and then break out of the false loop
            //
            DisplayMessage(pObjectEntry->nUsageID);
            hr = E_FAIL;
            break;
         }

         PARSE_ERROR Error;
         if(!ParseCmd(g_pszDSCommandName,
                      pNewCommandArgs,
                      argc-1, 
                      pToken+1,
                      pObjectEntry->nUsageID, 
                      &Error,
                      TRUE))
         {
            //ParseCmd did not display any error. Error should
            //be handled here. Check DisplayParseError for the
            //cases where Error is not shown by ParseCmd
            if(!Error.MessageShown)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                break;
            }
            
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                break;            
            }

            hr = E_INVALIDARG;
            break;
         }
         else
         {
            //
            // Check to see if we are doing debug spew
            //
#ifdef DBG
            bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                              pNewCommandArgs[eCommDebug].nValue;
            if (bDebugging)
            {
               ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
            }
#else
            DISABLE_DEBUG_OUTPUT();
#endif
            // Get the Command Enum value based on the object type to
            // deal with the -part switch for quotas which doesn't
            // use the common object dn
            int nCommandEnum = -1;
            if (FAILED(GetObjectDNIndex(pObjectEntry, nCommandEnum)) 
                || (nCommandEnum == -1))
            {
                // An object type is missing in GetObjectDNIndex
                if(!Error.MessageShown)
                {
                    hr = E_INVALIDARG;
                    DisplayErrorMessage(g_pszDSCommandName, 
                                        NULL,
                                        hr);

                    break;
                }
            }

            DSADD_COMMAND_ENUM eObjectDNorName = (DSADD_COMMAND_ENUM) nCommandEnum;
            //
            // Be sure that mutually exclusive and dependent switches are correct
            //
            BOOL bErrorShown = FALSE;
            hr = DoAddValidation(pNewCommandArgs, bErrorShown);
            if (FAILED(hr))
            {
               if (!bErrorShown)
               {
                  DisplayErrorMessage(g_pszDSCommandName, 
                                      pNewCommandArgs[eObjectDNorName].strValue,
                                      hr);
               }
               break;
            }

            //
            // Command line parsing succeeded
            //
            hr = DoAdd(pNewCommandArgs, pObjectEntry, eObjectDNorName);
         }

      } while (false);

      //
      // Free the memory associated with the command values
      //
      if (pNewCommandArgs)
      {
         FreeCmd(pNewCommandArgs);
      }

      //
      // Free the tokens
      //
      if (pToken)
      {
         delete[] pToken;
         pToken = 0;
      }
   }

   //
   // Uninitialize COM
   //
   ::CoUninitialize();

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoGroupValidation
//
//  Synopsis:   Checks to be sure that command line switches for a group that 
//              are mutually exclusive are not both present and those that 
//              are dependent are both present
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoGroupValidation(PARG_RECORD pCommandArgs)
{
   HRESULT hr = S_OK;

   do // false loop
   {
      //
      // Set the group scope to default (global) if not given
      //
      if (!pCommandArgs[eGroupScope].bDefined ||
          !pCommandArgs[eGroupScope].strValue)
      {
         size_t nScopeLen = _tcslen(g_bstrGroupScopeGlobal);
         pCommandArgs[eGroupScope].strValue = (LPWSTR)LocalAlloc(LPTR, (nScopeLen+2) * sizeof(WCHAR) );
         if (!pCommandArgs[eGroupScope].strValue)
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to allocate space for pCommandArgs[eGroupScope].strValue");
            hr = E_OUTOFMEMORY;
            break;
         }

         _tcscpy(pCommandArgs[eGroupScope].strValue, g_bstrGroupScopeGlobal);
         pCommandArgs[eGroupScope].bDefined = TRUE;
      }

      //
      // Set the group security to default (yes) if not given
      //
      if (!pCommandArgs[eGroupSecgrp].bDefined)
      {
         pCommandArgs[eGroupSecgrp].bValue = TRUE;
         pCommandArgs[eGroupSecgrp].bDefined = TRUE;

         //
         // Need to change the type to bool so that FreeCmd doesn't
         // try to free the string when the value is true
         //
         pCommandArgs[eGroupSecgrp].fType = ARG_TYPE_BOOL;
      }

   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoAddValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both presetn
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [bErrorShown - OUT] : set to true if an error was shown
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    22-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoAddValidation(PARG_RECORD pCommandArgs, BOOL& bErrorShown)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoAddValidation, hr);

   do // false loop
   {
      // Check to be sure the server and domain switches
      // are mutually exclusive

      if (pCommandArgs[eCommServer].bDefined &&
          pCommandArgs[eCommDomain].bDefined)
      {
         hr = E_INVALIDARG;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr, IDS_NO_SERVER_AND_DOMAIN);
         bErrorShown = TRUE;
         break;
      }

      //
      // Check the user switches
      //
      PWSTR pszObjectType = NULL;
      if (!pCommandArgs[eCommObjectType].bDefined &&
          !pCommandArgs[eCommObjectType].strValue)
      {
         hr = E_INVALIDARG;
         break;
      }

      pszObjectType = pCommandArgs[eCommObjectType].strValue;
      if (0 == _wcsicmp(g_pszUser, pszObjectType))
      {
         // 
         // Set the default for user must change password if the value wasn't specified
         //
         if (!pCommandArgs[eUserMustchpwd].bDefined)
         {
            pCommandArgs[eUserMustchpwd].bDefined = TRUE;
            pCommandArgs[eUserMustchpwd].bValue = FALSE;
         }

         //
         // Can't have user must change password if user can change password is no
         //
         if ((pCommandArgs[eUserMustchpwd].bDefined &&
              pCommandArgs[eUserMustchpwd].bValue) &&
             (pCommandArgs[eUserCanchpwd].bDefined &&
              !pCommandArgs[eUserCanchpwd].bValue))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"User must change password and user can change password = false was supplied");
            hr = E_INVALIDARG;
            break;
         }

         // Before checking the password check to see if the user defined the -disabled switch.
         // If not, then set the -disabled value to TRUE if password is not defined and FALSE if
         // the password was defined

         if (!pCommandArgs[eUserDisabled].bDefined)
         {
            if (pCommandArgs[eUserPwd].bDefined)
            {
               pCommandArgs[eUserDisabled].bValue = FALSE;
            }
            else
            {
               pCommandArgs[eUserDisabled].bValue = TRUE;
            }
            pCommandArgs[eUserDisabled].bDefined = TRUE;

            // NTRAID#NTBUG9-707037-2002/09/24-ronmart-The following
            // is required to avoid an AV in FreeCmd which will
            // think this flag is a string (because that is how it
            // is defined in addtable.cpp) and therefore try to call
            // LocalFree on a NULL pointer.
            pCommandArgs[eUserDisabled].fType= ARG_TYPE_BOOL;
         }

         if (!pCommandArgs[eUserPwd].bDefined)
         {
            pCommandArgs[eUserPwd].bDefined = TRUE;

            // This must be allocated with LocalAlloc so that FreeCmd doesn't assert
            // Passwords in ARGRECORD should be in encrypted format.

            WCHAR szTemp[] = L"";
            hr = EncryptPasswordString(szTemp,&(pCommandArgs[eUserPwd].encryptedDataBlob));
            if(FAILED(hr))
               break;
         }

         // Always define Password Not Required to be false so that we unset the bit
         
         pCommandArgs[eUserPwdNotReqd].bDefined = TRUE;
         pCommandArgs[eUserPwdNotReqd].bValue = FALSE;
      }
      else if (0 == _wcsicmp(g_pszGroup, pszObjectType))
      {
         hr = DoGroupValidation(pCommandArgs);
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoQuotaValidation
//
//  Synopsis:   Validates input and fixes up the objectDN (via
//              GetQuotaContainerDN) to make sure DoAdd has a valid quota DN
//
//  Arguments:  [pCommandArgs - IN] :    the command line argument structure
//                                       used to retrieve the values for each
//                                       switch
//              [pObjectEntry - IN] :    pointer to the object table entry for
//                                       the object type that will be modified
//              [basePathsInfo - IN]:    DSAdd's CDSCmdBasePathsInfo object 
//                                       for getting the RootDSE and Schema
//              [credentialObject - IN]: DSAdd's creditials object used for 
//                                       binding to other objects
//              [lpszPartitionDN - IN]:  The -part DN
//              [pszNewQuotaDN - OUT]:   Return the munged new quota dn
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_UNEXPECTED in most failure cases
//                        E_OUTOFMEMORY if a LocalAlloc fails
//                        Anything else is a failure code from an ADSI call
//
//  History:    12-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT DoQuotaValidation(IN  PARG_RECORD pCommandArgs, 
                          IN  PDSOBJECTTABLEENTRY pObjectEntry,
                          IN  CDSCmdBasePathsInfo& basePathsInfo, 
                          IN  CDSCmdCredentialObject& credentialObject,
                          IN  LPCWSTR lpszPartitionDN, 
                          OUT PWSTR* pszNewQuotaDN)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoQuotaValidation, hr);

   LPWSTR lpszTrusteeDN = NULL;
   PWSTR  pszQuotaDN = NULL;

   do // false loop
    {
        //
        // Verify parameters
        //
        if (!pCommandArgs || !pObjectEntry || !lpszPartitionDN ||
            !basePathsInfo.IsInitialized())
        {
            ASSERT(pCommandArgs);
            ASSERT(pObjectEntry);
            ASSERT(lpszPartitionDN);
            ASSERT(basePathsInfo.IsInitialized());
            hr = E_INVALIDARG;
            break;
        }

        // Convert pCommandArgs[eQuotaAcct] into a DN
        hr = ConvertTrusteeToDN(NULL, 
                        pCommandArgs[eQuotaAcct].strValue, 
                        &lpszTrusteeDN);
        if(FAILED(hr))
        {
            // 702224 - If the acct doesn't exist or has been deleted then 
            // give the user a clue as to what went wrong. - ronmart
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 0, hr, IDS_MSG_INVALID_ACCT_ERROR);
            break;
        }

        // If RDN not provided, then come up with a reasonable default
        // (NT4 name is the default for now)
        if (!pCommandArgs[eQuotaRDN].bDefined)
        {

            LPWSTR lpszNT4 = NULL;
            hr = ConvertTrusteeToNT4Name(NULL, 
                pCommandArgs[eQuotaAcct].strValue, &lpszNT4);
            if(FAILED(hr))
            {
                hr = E_UNEXPECTED;
                break;
            }
            // strValue is null, so set it to the new NT4 name
            // The parser will free this memory
            pCommandArgs[eQuotaRDN].strValue = lpszNT4;

            // Mark as defined now that we've assigned it
            pCommandArgs[eQuotaRDN].bDefined = TRUE;
        }

        // Verify partition DN is actually a partition then 
        // munge the partition and account name into objectDN.
        hr = GetQuotaContainerDN(basePathsInfo, 
                                 credentialObject,
                                 lpszPartitionDN, 
                                 &pszQuotaDN);
        if (FAILED(hr))
        {
            break;
        }

        CComBSTR bstrQuotaDN(pszQuotaDN);

        // See if this user has created a quota in this partition already
        bool bFound = false;
        CComBSTR sbstrSearchPath;
        basePathsInfo.ComposePathFromDN(bstrQuotaDN, sbstrSearchPath,
            DSCMD_LDAP_PROVIDER);

        hr = IsQuotaAcctPresent(lpszTrusteeDN, sbstrSearchPath, 
                                basePathsInfo, credentialObject, bFound);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"IsQuotaAcctPresent failed [%s] hr = 0x%08x",
                        bstrQuotaDN, hr);
            hr = E_UNEXPECTED;
            break;
        }

        if(bFound)
        {
            // TODO: Should spew a clear message to the user
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"Quota already exists for [%s]", lpszTrusteeDN);
            hr = E_INVALIDARG;
            break;
        }

        // Add the resolved quota DN to pathcracker for merge with the RDN
        CPathCracker pathcracker;
        hr = pathcracker.Set( bstrQuotaDN, ADS_SETTYPE_DN );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"pathcracker Set.failure: [%s] hr = 0x%08x",
                        bstrQuotaDN, hr);
            hr = E_UNEXPECTED;
            break;
        }

        CComBSTR bstrRDN;
        hr = CreateQuotaName(basePathsInfo, credentialObject, 
                pCommandArgs[eQuotaRDN].strValue, bstrRDN);

        if(FAILED(hr))
        {
            break;
        }

        hr = pathcracker.AddLeafElement( bstrRDN );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"pathcracker.AddLeafElement failure: [%s] hr = 0x%08x",
                        bstrRDN, hr);
            hr = E_UNEXPECTED;
            break;
        }

        // Get the new resolved DN in the format of <RDN>,CN=NTDS Quotas,<Partition DN>
        CComBSTR bstrNewDN;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &bstrNewDN );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"pathcracker.Retrieve failure: hr = 0x%08x",
                        hr);
            hr = E_UNEXPECTED;
            break;
        }

        // Alloc the return string to hold the munged name
        *pszNewQuotaDN = (PWSTR) LocalAlloc(LPTR, SysStringByteLen(bstrNewDN) 
            + sizeof(WCHAR));

        if(NULL == *pszNewQuotaDN)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // Copy the resolved DN into the new objectDN string
        lstrcpy(*pszNewQuotaDN, bstrNewDN);

    } while(false);

    if(pszQuotaDN)
        LocalFree(pszQuotaDN);

    if(lpszTrusteeDN)
        LocalFree(lpszTrusteeDN);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoAdd
//
//  Synopsis:   Finds the appropriate object in the object table and fills in
//              the attribute values and then creates the object
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    22-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoAdd(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry, 
              DSADD_COMMAND_ENUM eObjectDNorName)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoAdd, hr);
   
   PADS_ATTR_INFO pCreateAttrs = NULL;
   PADS_ATTR_INFO pPostCreateAttrs = NULL;

   do // false loop
   {
      if (!pCommandArgs || !pObjectEntry)
      {
         ASSERT(pCommandArgs && pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }


      CDSCmdCredentialObject credentialObject;
      if (pCommandArgs[eCommUserName].bDefined)
      {
         credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      if (pCommandArgs[eCommPassword].bDefined)
      {
         credentialObject.SetEncryptedPassword(&pCommandArgs[eCommPassword].encryptedDataBlob);
         credentialObject.SetUsingCredentials(true);
      }

      //
      // Initialize the base paths info from the command line args
      // 
      CDSCmdBasePathsInfo basePathsInfo;
      if (pCommandArgs[eCommServer].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommServer].strValue,
                                               true);
      }
      else if (pCommandArgs[eCommDomain].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommDomain].strValue,
                                               false);
      }
      else
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
      }

      if (FAILED(hr))
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
         break;
      }

      //
      // The DNs or Names should be given as a \0 separated list
      // So parse it and loop through each object
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(pCommandArgs[eObjectDNorName].strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         //
         // Display the usage text and then fail
         //
         hr = E_INVALIDARG;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr);
         break;
      }

      // If quota object then look at first DN and munge it
      if(0 == lstrcmpi(pObjectEntry->pszCommandLineObjectType, g_pszQuota))
      {
          // Multiple DN's not supported for dsadd quota at this time, so err
            if(nStrings > 1)
            {
                CComBSTR sbstrErrMsg;
                sbstrErrMsg.LoadString(::GetModuleHandle(NULL),
                                        IDS_MSG_MULTIPLE_PARTITIONS_ERROR);

                hr = E_INVALIDARG;

                // Display an error
                DisplayErrorMessage(g_pszDSCommandName,
                                    NULL,
                                    hr,
                                    sbstrErrMsg);
                break;
            }

            PWSTR pszNewDN = NULL;
            hr = DoQuotaValidation(pCommandArgs, pObjectEntry, basePathsInfo, 
                credentialObject, ppszArray[0], &pszNewDN);

            if(FAILED(hr))
                break;

            // Replace the first element in the array with the new DN
            ppszArray[0] = pszNewDN;            
      }

      // Make sure all the DNs actually have DN syntax

      bool bContinue = pCommandArgs[eCommContinue].bDefined &&
                       pCommandArgs[eCommContinue].bValue;

      UINT nValidDNs = ValidateDNSyntax(ppszArray, nStrings);
      if (nValidDNs < nStrings && !bContinue)
      {
         hr = E_ADS_BAD_PATHNAME;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr);
         break;
      }

      DWORD dwCount = pObjectEntry->dwAttributeCount; 

      //
      // Allocate the creation ADS_ATTR_INFO
      // Add an extra attribute for the object class
      //
      pCreateAttrs = new ADS_ATTR_INFO[dwCount + 1];

      if (!pCreateAttrs)
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, E_OUTOFMEMORY);
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Allocate the post create ADS_ATTR_INFO
      //
      pPostCreateAttrs = new ADS_ATTR_INFO[dwCount];
      if (!pPostCreateAttrs)
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, E_OUTOFMEMORY);
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Loop through each of the objects
      //
      for (UINT nNameIdx = 0; nNameIdx < nStrings; nNameIdx++)
      {
         do // false loop
         {
            //
            // Get the objects DN
            //
            PWSTR pszObjectDN = ppszArray[nNameIdx];
            if (!pszObjectDN)
            {
               //
               // Display an error message and then fail
               //
               hr = E_INVALIDARG;
               DisplayErrorMessage(g_pszDSCommandName, 0, hr);
               break; // this breaks out of the false loop
            }
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Object DN = %s", pszObjectDN);

            CComBSTR sbstrObjectPath;
            basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);

            //
            // Now that we have the table entry loop through the other command line
            // args and see which ones can be applied
            //
            DWORD dwCreateAttributeCount = 0;

            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Starting processing DS_ATTRIBUTE_ONCREATE attributes");

            for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
            {
               ASSERT(pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc);

               UINT nAttributeIdx = pObjectEntry->pAttributeTable[dwIdx]->nAttributeID;

               if (pCommandArgs[nAttributeIdx].bDefined ||
                   pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_REQUIRED)
               {
                  //
                  // Call the evaluation function to get the appropriate ADS_ATTR_INFO set
                  // if this attribute entry has the DS_ATTRIBUTE_ONCREATE flag set
                  //
                  if ((pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_ONCREATE) &&
                      (!(pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_DIRTY) ||
                       pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE))
                  {
                     PADS_ATTR_INFO pNewAttr = NULL;
                     hr = pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc(pszObjectDN,
                                                                          basePathsInfo,
                                                                          credentialObject,
                                                                          pObjectEntry, 
                                                                          pCommandArgs[nAttributeIdx],
                                                                          dwIdx, 
                                                                          &pNewAttr);

                     DEBUG_OUTPUT(MINIMAL_LOGGING, L"pEvalFunc returned hr = 0x%x", hr);
                     if (SUCCEEDED(hr) && hr != S_FALSE)
                     {
                        if (pNewAttr)
                        {
                           pCreateAttrs[dwCreateAttributeCount] = *pNewAttr;
                           dwCreateAttributeCount++;
                        }
                     }
                     else
                     {
                        //
                        // Don't show an error if the eval function returned S_FALSE
                        //
                        if (hr != S_FALSE)
                        {
                           //
                           // Display an error
                           //
                           DisplayErrorMessage(g_pszDSCommandName,
                                               pszObjectDN,
                                               hr);
                        }
            
                        if (hr == S_FALSE)
                        {
                           //
                           // Return a generic error code so that we don't print the success message
                           //
                           hr = E_FAIL;
                        }
                        break; // this breaks out of the attribute loop   
                     }
                  }
               }
            } // Attribute for loop

            //
            // The IDispatch interface of the new object
            //
            CComPtr<IDispatch> spDispatch;

            if (SUCCEEDED(hr))
            {
               //
               // Now that we have the attributes ready, lets create the object
               //

               //
               // Get the parent path of the new object
               //
               CComBSTR sbstrParentDN;
               hr = CPathCracker::GetParentDN(pszObjectDN, sbstrParentDN);
               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               CComBSTR sbstrParentPath;
               basePathsInfo.ComposePathFromDN(sbstrParentDN, sbstrParentPath);

               //
               // Open the parent of the new object
               //
               CComPtr<IDirectoryObject> spDirObject;
               hr = DSCmdOpenObject(credentialObject,
                                    sbstrParentPath,
                                    IID_IDirectoryObject,
                                    (void**)&spDirObject,
                                    true);

               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               //
               // Get the name of the new object
               //
               CComBSTR sbstrObjectName;
               hr = CPathCracker::GetObjectRDNFromDN(pszObjectDN, sbstrObjectName);
               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               //
               // Add the object class to the attributes before creating the object
               //
               PADSVALUE pADsObjectClassValue = new ADSVALUE;
               if (!pADsObjectClassValue)
               {
                  hr = E_OUTOFMEMORY;
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               pADsObjectClassValue->dwType = ADSTYPE_CASE_IGNORE_STRING;
               pADsObjectClassValue->CaseIgnoreString = (PWSTR)pObjectEntry->pszObjectClass;

               DEBUG_OUTPUT(MINIMAL_LOGGING, L"New object name = %s", pObjectEntry->pszObjectClass);

               ADS_ATTR_INFO adsClassAttrInfo =
                  { 
                     L"objectClass",
                     ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING,
                     pADsObjectClassValue,
                     1
                  };

               pCreateAttrs[dwCreateAttributeCount] = adsClassAttrInfo;
               dwCreateAttributeCount++;

      #ifdef DBG
               DEBUG_OUTPUT(FULL_LOGGING, L"Creation Attributes:");
               SpewAttrs(pCreateAttrs, dwCreateAttributeCount);
      #endif
         
               hr = spDirObject->CreateDSObject(sbstrObjectName,
                                                pCreateAttrs, 
                                                dwCreateAttributeCount,
                                                &spDispatch);

               DEBUG_OUTPUT(MINIMAL_LOGGING, L"CreateDSObject returned hr = 0x%x", hr);

               if (FAILED(hr))
               {
                  CComBSTR sbstrDuplicateErrorMessage;

                  if (ERROR_OBJECT_ALREADY_EXISTS == HRESULT_CODE(hr))
                  {
                     if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszComputer) == 0)
                     {
                        sbstrDuplicateErrorMessage.LoadString(::GetModuleHandle(NULL), 
                                                              IDS_MSG_DUPLICATE_NAME_ERROR_COMPUTER);
                     }

                     if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszGroup) == 0)
                     {
                        sbstrDuplicateErrorMessage.LoadString(::GetModuleHandle(NULL), 
                                                              IDS_MSG_DUPLICATE_NAME_ERROR_GROUP);
                     }
                  }

                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr,
                                      sbstrDuplicateErrorMessage);

                  if (pADsObjectClassValue)
                  {
                     delete pADsObjectClassValue;
                     pADsObjectClassValue = NULL;
                  }
                  break; // this breaks out of the false loop
               }

               if (pADsObjectClassValue)
               {
                  delete pADsObjectClassValue;
                  pADsObjectClassValue = NULL;
               }
            }

            if (SUCCEEDED(hr))
            {
               //
               // Now that we have created the object, set the attributes that are 
               // marked for Post Create
               //
               DWORD dwPostCreateAttributeCount = 0;
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Starting processing DS_ATTRIBUTE_POSTCREATE attributes");
               for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
               {
                  ASSERT(pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc);

                  UINT nAttributeIdx = pObjectEntry->pAttributeTable[dwIdx]->nAttributeID;

               if (pCommandArgs[nAttributeIdx].bDefined ||
                   pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_REQUIRED)
                  {
                     //
                     // Call the evaluation function to get the appropriate ADS_ATTR_INFO set
                     // if this attribute entry has the DS_ATTRIBUTE_POSTCREATE flag set
                     //
                     if ((pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_POSTCREATE) &&
                         (!(pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_DIRTY) ||
                          pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE))
                     {
                        PADS_ATTR_INFO pNewAttr = NULL;
                        hr = pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc(pszObjectDN,
                                                                             basePathsInfo,
                                                                             credentialObject,
                                                                             pObjectEntry, 
                                                                             pCommandArgs[nAttributeIdx],
                                                                             dwIdx, 
                                                                             &pNewAttr);

                        DEBUG_OUTPUT(MINIMAL_LOGGING, L"pEvalFunc returned hr = 0x%x", hr);
                        if (SUCCEEDED(hr) && hr != S_FALSE)
                        {
                           if (pNewAttr)
                           {
                              pPostCreateAttrs[dwPostCreateAttributeCount] = *pNewAttr;
                              dwPostCreateAttributeCount++;
                           }
                        }
                        else
                        {
                           //
                           // Don't show an error if the eval function returned S_FALSE
                           //
                           if (hr != S_FALSE)
                           {
                              //
                              // Load the post create message
                              //
                              CComBSTR sbstrPostCreateMessage;
                              sbstrPostCreateMessage.LoadString(::GetModuleHandle(NULL),
                                                                IDS_POST_CREATE_FAILURE);

                              //
                              // Display an error
                              //
                              DisplayErrorMessage(g_pszDSCommandName,
                                                  pszObjectDN,
                                                  hr,
                                                  sbstrPostCreateMessage);
                           }
         
                           if (hr == S_FALSE)
                           {
                              //
                              // Return a generic error code so that we don't print the success message
                              //
                              hr = E_FAIL;
                           }
                           break; // attribute table loop        
                        }
                     }
                  }
               } // Attribute table for loop

               //
               // Now set the attributes if necessary
               //
               if (SUCCEEDED(hr) && dwPostCreateAttributeCount > 0)
               {
                  //
                  // Now that we have the attributes ready, lets set them in the DS
                  //
                  CComPtr<IDirectoryObject> spNewDirObject;
                  hr = spDispatch->QueryInterface(IID_IDirectoryObject, (void**)&spNewDirObject);
                  if (FAILED(hr))
                  {
                     //
                     // Display error message and return
                     //
                     DEBUG_OUTPUT(MINIMAL_LOGGING, L"QI for IDirectoryObject failed: hr = 0x%x", hr);
                     DisplayErrorMessage(g_pszDSCommandName,
                                         pszObjectDN,
                                         hr);
                     break; // this breaks out of the false loop
                  }

                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"Setting %d attributes", dwPostCreateAttributeCount);
      #ifdef DBG
                  DEBUG_OUTPUT(FULL_LOGGING, L"Post Creation Attributes:");
                  SpewAttrs(pPostCreateAttrs, dwPostCreateAttributeCount);
      #endif

                  DWORD dwAttrsModified = 0;
                  hr = spNewDirObject->SetObjectAttributes(pPostCreateAttrs, 
                                                           dwPostCreateAttributeCount,
                                                           &dwAttrsModified);

                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"SetObjectAttributes returned hr = 0x%x", hr);
                  if (FAILED(hr))
                  {
                     //
                     // Display error message and return
                     //
                     DisplayErrorMessage(g_pszDSCommandName,
                                         pszObjectDN,
                                         hr);
                     break; // this breaks out of the false loop
                  }
               }
            }
         } while (false);

         //
         // Loop through the attributes again, clearing any values for 
         // attribute entries that are marked DS_ATTRIBUTE_NOT_REUSABLE
         //
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Cleaning up memory and flags for object %d", nNameIdx);
         for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
         {
            if (pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE)
            {
               if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc &&
                   ((pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ) ||
                    (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_DIRTY)))
               {
                  //
                  // Cleanup the memory associated with the value
                  //
                  if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues)
                  {
                     delete[] pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues;
                     pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues = NULL;
                  }

                  //
                  // Cleanup the flags so that the attribute will be read for the next object
                  //
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_READ);
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_DIRTY);

                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Flags for attribute %s = %d",
                               pObjectEntry->pAttributeTable[dwIdx]->pszName,
                               pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags);
               }
            }
         }

         //
         // Break if the continue flag is not specified
         //
         if (FAILED(hr) && !pCommandArgs[eCommContinue].bDefined)
         {
            break; // this breaks out of the name for loop
         }

         //
         // Display the success message
         //
         if (SUCCEEDED(hr) && !pCommandArgs[eCommQuiet].bDefined)
         {
            DisplaySuccessMessage(g_pszDSCommandName, 
                                  pCommandArgs[eObjectDNorName].strValue);
         }
      } // Names for loop

   } while (false);

   //
   // Cleanup
   //
   if (pCreateAttrs)
   {
      delete[] pCreateAttrs;
      pCreateAttrs = NULL;
   }

   if (pPostCreateAttrs)
   {
      delete[] pPostCreateAttrs;
      pPostCreateAttrs = NULL;
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetObjectDNIndex
//
//  Synopsis:   Performs a lookup to determine which enum value is holding
//              the objectDN. This was necessary for -part support for
//              quotas.
//
//  Arguments:  [pObjectEntry IN]   : ObjectEntry from the parser
//              [nCommandEnum OUT]  : Enum value of the object, else -1
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//
//  Remarks:    
//              
//
//  History:    19-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT GetObjectDNIndex(PDSOBJECTTABLEENTRY pObjectEntry, int& nCommandEnum)
{
    HRESULT hr = S_OK;

    do // false loop
    {
        // Init nCommandEnum to an error value by default
        nCommandEnum = -1;

        if(NULL == pObjectEntry)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Get a pointer to the object class for readability
        PCWSTR pszCommandLineObjectType = pObjectEntry->pszCommandLineObjectType;

        // Now compare each object type against the specified
        // object class to see what the enum index is
        if(0 == lstrcmpi(pszCommandLineObjectType, g_pszUser))
        {
            nCommandEnum = eUserObjectDNorName;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszComputer))
        {
            nCommandEnum = eComputerObjectDNorName;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszGroup))
        {
            nCommandEnum = eGroupObjectDNorName;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszOU))
        {
            nCommandEnum = eOUObjectDNorName;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszQuota))
        {
            nCommandEnum = eQuotaPart;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszContact))
        {
            nCommandEnum = eContactObjectDNorName;
            break;
        }
        else
        {
            hr = E_FAIL;
            // If you get here, then you've added a new object
            // to cstrings.* without adding it to the 
            // if statement. This should only happen
            // when testing a new object for the first time
            // without a corresponding check above.
            ASSERT(FALSE);
            break;
        }
    } while(false);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsQuotaAcctPresent
//
//  Synopsis:   Does a search from the passed in path looking for quotas
//              on the given trustee and returns the result in bFound
//
//  Arguments:  [lpszTrusteeDN IN]      : DN of the trustee to search the
//                                        partition for (using sid string)
//              [pszSearchRootPath IN]  : the path to the root of the search
//              [basePathsInfo - IN]    : ldap settings
//              [refCredObject IN]      : reference to the credential object
//              [bFound OUT]            : Search result (true if found)
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  Remarks:    
//              
//
//  History:    19-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT IsQuotaAcctPresent( IN  LPWSTR lpszTrusteeDN, 
                            IN  PCWSTR pszSearchRootPath,
                            IN  CDSCmdBasePathsInfo& basePathsInfo, 
                            IN  const CDSCmdCredentialObject& refCredObject,
                            OUT bool& bFound)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, IsQuotaAcctPresent, hr);
    PSID pSid = NULL;
    LPWSTR pszSid = NULL;

    if(!lpszTrusteeDN || !pszSearchRootPath)
    {
        hr = E_INVALIDARG;
        return hr;
    }

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pszSearchRootPath || !pszSearchRootPath)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Get the SID
        hr = GetDNSid(lpszTrusteeDN,
                 basePathsInfo,
                 refCredObject,
                 &pSid);
        if(FAILED(hr))
        {
            hr = E_FAIL;
            break;
        }
     
        // Convert the sid to a string
        if(!ConvertSidToStringSid(pSid, &pszSid))
        {
            hr = E_FAIL;
            break;
        }

        //
        // Search 
        //
        CDSSearch searchObj;
        hr = searchObj.Init(pszSearchRootPath,
                              refCredObject);
        if(FAILED(hr))
        {
          break;
        }

        //
        // Prepare the search object
        //
        PWSTR ppszAttrs[] = { L"distinguishedName" };
        DWORD dwAttrCount = sizeof(ppszAttrs)/sizeof(PWSTR);
        CComBSTR bstrFilter = L"(&(objectCategory=msDS-QuotaControl)(|(msDS-QuotaTrustee=";
        bstrFilter += pszSid;
        bstrFilter += ")))";

        searchObj.SetFilterString(bstrFilter);
        searchObj.SetSearchScope(ADS_SCOPE_SUBTREE);
        searchObj.SetAttributeList(ppszAttrs, dwAttrCount);
        
        hr = searchObj.DoQuery();
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to search for users: hr = 0x%x",
                         hr);
            break;
        }

        // Get the first row (will will return S_OK even if no results returned)
        hr = searchObj.GetNextRow();
        if (FAILED(hr))
        {
            bFound = false;
            break;
        }

        // If rows then it exists, else
        // not found
        bFound = (hr != S_ADS_NOMORE_ROWS);

    } while (false);

    if(pSid)
        LocalFree(pSid);

    if(pszSid)
        LocalFree(pszSid);

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   CreateQuotaName
//
//  Synopsis:   Creates a RDN value using the quota control naming context
//
//  Arguments:  [basePathsInfo - IN]     :
//              [credentialObject - IN]  :
//              [lpszRDN - IN]           : The name of the quota object
//              [bstrRDN - OUT]          : If successful a RDN to use
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    22-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT CreateQuotaName(IN  CDSCmdBasePathsInfo& basePathsInfo, 
                IN  CDSCmdCredentialObject& credentialObject, 
                IN  LPCWSTR lpszRDN, 
                OUT CComBSTR& bstrRDN)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, CreateQuotaName, hr);

   do // false loop
   {
       if (!basePathsInfo.IsInitialized(), !lpszRDN)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Get the abstract schema path from the source domain
        CComBSTR bstrSchemaPath = basePathsInfo.GetAbstractSchemaPath();
        bstrSchemaPath += L"/msDS-QuotaControl";

        //  Bind to the quota control
        CComPtr<IADsClass> spIADsItem;
        hr = DSCmdOpenObject(credentialObject,
                            bstrSchemaPath,
                            IID_IADsClass,
                            (void**)&spIADsItem,
                            false);

        if (FAILED(hr) || (spIADsItem.p == 0))
        {
            ASSERT( !!spIADsItem );
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"DsCmdOpenObject failure - couldn't bind to msDS-QuotaControl: 0x%08x",
                hr);
            break;
        }
        
        // Get the naming properties of the quota control (usually cn)
        CComVariant varNamingProperties;
        hr = spIADsItem->get_NamingProperties(&varNamingProperties);
        if (FAILED(hr) || (V_VT(&varNamingProperties) != VT_BSTR ))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                        L"get_NamingProperties failure: hr = 0x%08x",
                        hr);
            hr = E_UNEXPECTED;
            break;
        }

        // Build the <naming property>=<rdn> string
        bstrRDN = V_BSTR(&varNamingProperties);
        bstrRDN += L"=";
        bstrRDN += lpszRDN;

   }while(false);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the dsget
//
//  History:   13-Oct-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

#include "commonstrings.h"

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;   
extern PCWSTR g_pszServer;
extern PCWSTR g_pszSite;
extern PCWSTR g_pszSubnet;
extern PCWSTR g_pszPartition;
extern PCWSTR g_pszQuota;

extern PCWSTR c_sz_arg1_com_listformat;
extern PCWSTR c_sz_arg1_com_description;

//
// User switches
//
extern PCWSTR g_pszArg1UserDN;
extern PCWSTR g_pszArg1UserSID;
extern PCWSTR g_pszArg1UserSAMID;
extern PCWSTR g_pszArg1UserUPN;
extern PCWSTR g_pszArg1UserFirstName;
extern PCWSTR g_pszArg1UserMiddleInitial;
extern PCWSTR g_pszArg1UserLastName;
extern PCWSTR g_pszArg1UserDisplayName;
extern PCWSTR g_pszArg1UserEmployeeID;
extern PCWSTR g_pszArg1UserOffice;
extern PCWSTR g_pszArg1UserTelephone;
extern PCWSTR g_pszArg1UserEmail;
extern PCWSTR g_pszArg1UserHomeTelephone;
extern PCWSTR g_pszArg1UserPagerNumber;
extern PCWSTR g_pszArg1UserMobileNumber;
extern PCWSTR g_pszArg1UserFaxNumber;
extern PCWSTR g_pszArg1UserIPTel;
extern PCWSTR g_pszArg1UserWebPage;
extern PCWSTR g_pszArg1UserTitle;
extern PCWSTR g_pszArg1UserDepartment;
extern PCWSTR g_pszArg1UserCompany;
extern PCWSTR g_pszArg1UserManager;
extern PCWSTR g_pszArg1UserHomeDirectory;
extern PCWSTR g_pszArg1UserHomeDrive;
extern PCWSTR g_pszArg1UserProfile;
extern PCWSTR g_pszArg1UserLogonScript;
extern PCWSTR g_pszArg1UserMustChangePwd;
extern PCWSTR g_pszArg1UserCanChangePwd;
extern PCWSTR g_pszArg1UserPwdNeverExpires;
extern PCWSTR g_pszArg1UserReversiblePwd;
extern PCWSTR g_pszArg1UserDisableAccount;
extern PCWSTR g_pszArg1UserAcctExpires;
extern PCWSTR g_pszArg1UserMemberOf;
extern PCWSTR g_pszArg1UserExpand;
extern PCWSTR g_pszArg1UserPart;
extern PCWSTR g_pszArg1UserQLimit;
extern PCWSTR g_pszArg1UserQuotaUsed;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerSID;
extern PCWSTR g_pszArg1ComputerSAMID;
extern PCWSTR g_pszArg1ComputerLoc;
extern PCWSTR g_pszArg1ComputerDisableAccount;
extern PCWSTR g_pszArg1ComputerMemberOf;
extern PCWSTR g_pszArg1ComputerExpand;
extern PCWSTR g_pszArg1ComputerPart;   
extern PCWSTR g_pszArg1ComputerQLimit;   
extern PCWSTR g_pszArg1ComputerQuotaUsed;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupSID;
extern PCWSTR g_pszArg1GroupSamid;
extern PCWSTR g_pszArg1GroupSecGrp;
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupMemberOf;
extern PCWSTR g_pszArg1GroupMembers;
extern PCWSTR g_pszArg1GroupExpand;
extern PCWSTR g_pszArg1GroupPart;    
extern PCWSTR g_pszArg1GroupQLimit;
extern PCWSTR g_pszArg1GroupQuotaUsed;
 
//
// Ou switches
//
// ** only uses common switches **

//
// Server switches
//
extern PCWSTR g_pszArg1ServerDnsName;
extern PCWSTR g_pszArg1ServerSite;
extern PCWSTR g_pszArg1ServerIsGC;
extern PCWSTR g_pszArg1ServerTopObjOwner;
extern PCWSTR g_pszArg1ServerPart;

//
// Site switches
//
extern PCWSTR g_pszArg1SiteAutotopology;
extern PCWSTR g_pszArg1SiteCacheGroups;
extern PCWSTR g_pszArg1SitePrefGCSite;

//
// Subnet switches
//
extern PCWSTR g_pszArg1SubnetLocation;
extern PCWSTR g_pszArg1SubnetSite;

//
// Partition switches
//
extern PCWSTR g_pszArg1PartitionQDefault;        
extern PCWSTR g_pszArg1PartitionQTombstoneWeight;
extern PCWSTR g_pszArg1PartitionTopObjOwner;     

//
// Quota switches
//
extern PCWSTR g_pszArg1QuotaAcct;  
extern PCWSTR g_pszArg1QuotaQLimit;

//
// Values
//
extern PCWSTR g_pszYes;
extern PCWSTR g_pszNo;
extern PCWSTR g_pszNotConfigured;
extern PCWSTR g_pszNever;

//
// 702724 ronmart 2002/09/18 Range qualifier
//
extern PCWSTR g_pszRange;

// NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit -qused 
//                                         not returning values 
extern PCWSTR g_pszAttrmsDSQuotaEffective;
extern PCWSTR g_pszAttrmsDSQuotaUsed;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\display.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      display.cpp
//
//  Contents:  Defines the functions used to convert values to strings
//             for display purposes
//
//  History:   17-Oct-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include <pch.h>

#include "cstrings.h"
#include "gettable.h"
#include "display.h"
#include "output.h"
#include "query.h"
#include "resource.h"

#include <lmaccess.h>   // UF_* for userAccountControl flags
#include <ntsam.h>      // GROUP_TYPE_*
#include <ntdsapi.h>    // NTDSSETTINGS_OPT_*
#include <msxml.h>      // For XML_GetNodeText and GetTopObjectUsage
//
// Almost all of these functions are of type PGETDISPLAYSTRINGFUNC as defined in
// gettable.h
//

#ifdef ADS_OPTION_QUOTA
#pragma message("ADS_OPTION_QUOTA is now defined, so display.cpp needs to be updated to support it")
#pragma warning(error : 1);
#else
#pragma message("ADS_OPTION_QUOTA is not defined, so using 5 instead")
//
// until the global definition is published, define it on my own so I'm not blocked
//
#define ADS_OPTION_QUOTA 5
#endif

//+--------------------------------------------------------------------------
//
//  Function:   XML_GetNodeText
//
//  Synopsis:   This code was taken from admin\snapin\dsadmin\xmlutil.cpp
//              on 8/29/02. Given an XML node of type NODE_TEXT, it
//              returns its value into a CComBSTR
//
//  Arguments:  [pXDN - IN]:     The node to extract the text value from
//              [refBstr - OUT]: The node text if successful, else unchanged
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Anything else is a failure code from XML 
//                        or E_INVALIDARG
//
//  History:    29-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT XML_GetNodeText(IN IXMLDOMNode* pXDN, OUT CComBSTR& refBstr)
{
    ENTER_FUNCTION_HR(LEVEL5_LOGGING, XML_GetNodeText, hr);

    ASSERT(pXDN != NULL);

    // assume the given node has a child node
    CComPtr<IXMLDOMNode> spName;
    hr = pXDN->get_firstChild(&spName);
    if (FAILED(hr))
    {
        // unexpected failure
        return hr;
    }
    // if no children, the api returns S_FALSE
    if (spName == NULL)
    {
        return hr;
    }

    // got now a valid pointer,
    // check if this is the valid node type
    DOMNodeType nodeType = NODE_INVALID;
    hr = spName->get_nodeType(&nodeType);
    ASSERT(hr == S_OK);
    ASSERT(nodeType == NODE_TEXT);
    if (nodeType != NODE_TEXT)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    // it is of type text
    // retrieve the node value into a variant
    CComVariant val;
    hr = pXDN->get_nodeTypedValue(&val);
    if (FAILED(hr))
    {
        // unexpected failure
        ASSERT(FALSE);
        return hr;
    }

    if (val.vt != VT_BSTR)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    // got the text value
    refBstr = val.bstrVal;

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   GetNT4NameOrSidString
//
//  Synopsis:   Called by GetTopObjectUsage on failure, this first does
//              a LookupAccountSid and tries to get the NT4 style name.
//              If that succeeds, then it tries to get the DN using that.
//              If no DN is returned, then the NT4 style name (if it exists) 
//              or the SID string will be returned.
//
//  Arguments:  [bstrSid - IN]: Sid string to resolve
//              [lpszDN - OUT]: Returns the DN, NT4 name or Sid string. 
//                              Use LocalFree when done.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    11-Oct-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetNT4NameOrSidString(IN CComBSTR& bstrSid, OUT LPWSTR* lpszDN)
{
 
    ENTER_FUNCTION_HR(LEVEL5_LOGGING, GetNT4NameOrSidString, hr);
    LPWSTR lpszName = NULL;
    LPWSTR lpszDomain = NULL;
    PSID pSid = NULL;

    do
    {
        //
        // Verify parameters
        //
        if (!lpszDN)
        {
            hr = E_INVALIDARG;
            break;
        }
        // Convert the Sid String to a Sid so we can lookup the account
        if(!ConvertStringSidToSid(bstrSid, &pSid))
        {
            hr = E_FAIL;
            ASSERT(FALSE);
            break;
        }

        DWORD cchName = 0;
        DWORD cchDomainName = 0;
        SID_NAME_USE sUse = SidTypeInvalid;

        // Call once to get the buffer sizes
        if(!LookupAccountSid(NULL,
            pSid, 
            lpszName, 
            &cchName, 
            lpszDomain, 
            &cchDomainName, 
            &sUse))
        {
            // If it fails, then deleted account so return
            // the sid string
            DWORD cchBufSize = SysStringLen(bstrSid) + 1;

            // Alloc the return buffer
            *lpszDN = (LPWSTR) LocalAlloc(LPTR,
                                cchBufSize * sizeof(WCHAR));

            if(NULL == *lpszDN)
            {
                ASSERT(FALSE);
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = StringCchCopy(*lpszDN, cchName, bstrSid.m_str);
        }

        if(cchName < 1 || cchDomainName < 1)
        {
            ASSERT(FALSE);
            E_UNEXPECTED;
            break;
        }

        lpszName = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
            cchName * sizeof(WCHAR));
        if(NULL == lpszName)
        {
            ASSERT(FALSE);
            E_OUTOFMEMORY;
            break;
        }

        lpszDomain = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
            cchDomainName * sizeof(WCHAR));
        if(NULL == lpszDomain)
        {
            ASSERT(FALSE);
            E_OUTOFMEMORY;
            break;
        }

        // Get the name
        if(!LookupAccountSid(NULL,
            pSid, 
            lpszName, 
            &cchName, 
            lpszDomain, 
            &cchDomainName, 
            &sUse))
        {
            ASSERT(FALSE);
            E_FAIL;
            break;
        }

        // Grow the buffer to hold both the domain and name
        DWORD chBufSize = (cchName + cchDomainName + 2);
        LPWSTR lpszNew = (LPWSTR) HeapReAlloc(GetProcessHeap(), 0, 
            lpszDomain, chBufSize * sizeof(WCHAR));
        if (NULL == lpszNew)
        {
            ASSERT(FALSE);
            hr = E_OUTOFMEMORY;
            break;
        }

        lpszDomain = lpszNew;

        // Merge the domain & account name
        hr = StringCchCat(lpszDomain, chBufSize, L"\\");
        if (FAILED(hr))
        {
            break;
        }

        hr = StringCchCat(lpszDomain, chBufSize, lpszName);
        if (FAILED(hr))
        {
            break;
        }
        
        // Try one more time to get the DN
        hr = ConvertTrusteeToDN(NULL, lpszDomain, lpszDN);

        // If this failed, then return the NT4 name
        if (FAILED(hr))
        {
            // Alloc the return buffer
            *lpszDN = (LPWSTR) LocalAlloc(LPTR,
                                chBufSize * sizeof(WCHAR));

            if(NULL == *lpszDN)
            {
                ASSERT(FALSE);
                hr = E_OUTOFMEMORY;
                break;
            }

            // Return the NT4 name 
            hr = StringCchCopy(*lpszDN, chBufSize, lpszDomain);

            // If we still fail, then give up and abort
            if(FAILED(hr))
            {
                ASSERT(FALSE);
                LocalFree(*lpszDN);
                *lpszDN = NULL;
                break;
            }
        }

    } while (0);

    if(pSid)
        LocalFree(pSid);

    if(lpszName)
        HeapFree(GetProcessHeap(), 0, lpszName);

    if(lpszDomain)
        HeapFree(GetProcessHeap(), 0, lpszDomain);

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   GetTopObjectUsage
//
//  Synopsis:   This code takes the XML block returned from a 
//              msDS-TopQuotaUsage attribute and extracts the trustee name
//              DN and the quotaUsed value
//
//  Arguments:  [pXDN - IN]:      The node to extract the text value from
//              [lpszDomain - IN]:Domain to query or NULL for local
//              [lpszDN - OUT]:   Returns the DN. Use LocalFree when done
//              [refBstr - OUT]:  The node text if successful, else unchanged
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Anything else is a failure code from XML 
//                        or E_INVALIDARG
//
//  History:    29-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT GetTopObjectUsage(IN CComBSTR& bstrXML, IN LPCWSTR lpszDomain, 
                          OUT LPWSTR* lpszDN, OUT CComBSTR& bstrQuotaUsed)
{
    ENTER_FUNCTION_HR(LEVEL5_LOGGING, GetTopObjectUsage, hr);

    // Create an XML document
    CComPtr<IXMLDOMDocument> pXMLDoc;
    hr = pXMLDoc.CoCreateInstance(CLSID_DOMDocument);

    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
            L"CoCreateInstance(CLSID_DOMDocument) failed: hr = 0x%x",
            hr);
        return hr;
    }

    do
    {
        //
        // Verify parameters
        //
        if (!lpszDN)
        {
            hr = E_INVALIDARG;
            break;
        }
        // Load the XML text
        VARIANT_BOOL isSuccessful;
        hr = pXMLDoc->loadXML(bstrXML, &isSuccessful);
        // If it failed for any reason, then abort
        if (FAILED(hr) || (isSuccessful == FALSE))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"loadXML failed: hr = 0x%x",
                hr);
            break;
        }
        // Get the SID string node
        CComPtr<IXMLDOMNode> pSidNode;
        hr = pXMLDoc->selectSingleNode(CComBSTR(L"MS_DS_TOP_QUOTA_USAGE/ownerSID"), &pSidNode);
        if (FAILED (hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"selectSingleNode('MS_DS_TOP_QUOTA_USAGE/ownerSID') failed: hr = 0x%x",
                hr);
            break;
        }

        // Extract the sid string
        CComBSTR bstrSID;
        hr = XML_GetNodeText(pSidNode, bstrSID);
        if(FAILED(hr))
        {
            break;
        }

        // Convert the sid string into a DN (into the return buffer)
        hr = ConvertTrusteeToDN(lpszDomain, bstrSID, lpszDN);
        if (FAILED (hr))
        {
           // If we couldn't get the DN then get the NT4 name
           // from the string sid and try again to get either the
           // DN, the NT4 name or last resort return the sid string
           hr = GetNT4NameOrSidString(bstrSID, lpszDN);
           if(FAILED(hr))
           {
               ASSERT(FALSE);
               break;
           }
         }

        // Get the quotaUsed node
        CComPtr<IXMLDOMNode> pQuotaUsedNode;
        hr = pXMLDoc->selectSingleNode(CComBSTR(L"MS_DS_TOP_QUOTA_USAGE/quotaUsed"), &pQuotaUsedNode);
        if (FAILED (hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"selectSingleNode('MS_DS_TOP_QUOTA_USAGE/quotaUsed') failed: hr = 0x%x",
                hr);
            break;
        }

        // Extract the value as text (into the return buffer)
        hr = XML_GetNodeText(pQuotaUsedNode, bstrQuotaUsed);
        if (FAILED(hr))
        {
            return hr;
        }
    } while (0);

    return hr;
}

HRESULT DisplayTopObjOwner(PCWSTR /*pszDN*/,//pszDN will be the dn of the server (from config) or the partition dn
                                CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                const CDSCmdCredentialObject& /*refCredentialObject*/,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, DisplayTopObjOwner, hr);

    LPWSTR lpszDN = NULL;

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pEntry ||
            !pRecord ||
            !pAttrInfo ||
            !pDisplayInfo)
        {
            hr = E_INVALIDARG;
            break;
        }
        // These callback functions weren't designed for the headers
        // to be changed, so two values must be stuck in one column entry
        // Since this is always going to be a one column table, this should
        // be acceptable
        pDisplayInfo->AddValue(L"Account DN\tObjects Owned");

        // If values returned in dsget's GetObjectAttributes
        if (pAttrInfo && pAttrInfo->pADsValues)
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                L"Examining %d values:",
                pAttrInfo->dwNumValues);

            // For each of the values found in dsget's GetObjectAttributes
            for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; dwIdx++)
            {
                WCHAR* pBuffer = 0;

                // The top object usage will be a single XML string
                hr = GetStringFromADs(&(pAttrInfo->pADsValues[dwIdx]),
                    pAttrInfo->dwADsType,
                    &pBuffer, 
                    pAttrInfo->pszAttrName);

                // If we got it then parse it
                if (SUCCEEDED(hr))
                {
                    // Extract the trustee name and quota value
                    CComBSTR bstrXML(pBuffer);
                    CComBSTR bstrQuotaUsed;

                    delete[] pBuffer;
                    pBuffer = NULL;

                    hr = GetTopObjectUsage(bstrXML, NULL, &lpszDN, bstrQuotaUsed);
                    if (FAILED(hr) || (hr == S_FALSE))
                    {
                        if(hr == S_FALSE)
                            continue; // skip failures due to invalid sid bug in AD
                        else
                            break; // FAIL if not the known invalid sid
                    }

                    // How big are the return strings plus the tab char
                    size_t size = (lstrlen(lpszDN) + 
                                   bstrQuotaUsed.Length()+2) * 
                                   sizeof(WCHAR);

                    // Create a buffer to hold the value to display
                    PWSTR pszValue = (PWSTR) LocalAlloc(LPTR, size);
                    if(NULL == pszValue)
                    {
                        LocalFree(lpszDN);
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    // Format the two columns
                    hr = StringCbPrintf(pszValue, size, L"%s\t%s", 
                                        lpszDN, bstrQuotaUsed.m_str);

                    // Done with this now (if FAILED(hr)), so free it
                    LocalFree(lpszDN);
                    lpszDN = NULL;

                    // If the format failed
                    if(FAILED(hr))
                    {
                        break;
                    }

                    // Add the string to display
                    hr = pDisplayInfo->AddValue(pszValue);
                }
            }
        }
    } while (false);

    if(lpszDN != NULL)
        LocalFree(lpszDN);

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   AddValuesToDisplayInfo
//
//  Synopsis:   Adds the values a variant array of BSTR's (or single BSTR)
//              to the displayInfo
//
//  Arguments:  [refvar - IN]:     A variant that contains either a BSTR or
//                                 an array of BSTR's
//                                 
//              [pDisplayInfo - IN]: Display object to add to 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_UNEXPECTED in most failure cases
//                        Anything else is a failure code from call that 
//                        returns a hr
//
//  Note:       This code was derrived from admin\snapin\adsiedit\common.cpp
//
//  History:    29-Aug-2002   RonMart   Created
//
//---------------------------------------------------------------------------
HRESULT AddValuesToDisplayInfo(VARIANT& refvar, PDSGET_DISPLAY_INFO pDisplayInfo)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, AddValuesToDisplayInfo, hr);

    long start = 0;
    long end = 0;

    // If a single value comes back
    if ( !(V_VT(&refvar) &  VT_ARRAY)  )
    {
        // and it is not a BSTR then abort
        if ( V_VT(&refvar) != VT_BSTR )
        {
            return E_UNEXPECTED;
        }
        // Add the value to the displayInfo 
        return pDisplayInfo->AddValue(V_BSTR(&refvar));
    }

    // Otherwise it is a SafeArray so get the array
    SAFEARRAY *saAttributes = V_ARRAY( &refvar );

    // Verify array returned
    if(NULL == saAttributes)
        return E_UNEXPECTED;

    // Figure out the dimensions of the array.
    hr = SafeArrayGetLBound( saAttributes, 1, &start );
    if( FAILED(hr) )
        return hr;

    hr = SafeArrayGetUBound( saAttributes, 1, &end );
    if( FAILED(hr) )
        return hr;

    // Search the array elements and abort if a match is found
    CComVariant SingleResult;
    for ( long idx = start; (idx <= end); idx++   ) 
    {

        hr = SafeArrayGetElement( saAttributes, &idx, &SingleResult );
        if( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&SingleResult) != VT_BSTR )
        {
            // If not BSTR then go to the next element
            continue; 
        }
        // Add the value to the displayInfo 
        hr = pDisplayInfo->AddValue(V_BSTR(&SingleResult));
        if( FAILED(hr) )
        {
            return hr;
        }
    }
    return hr;
}

HRESULT DisplayPartitions(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* /*pEntry*/,
                            ARG_RECORD* /*pRecord*/,
                            PADS_ATTR_INFO /*pAttrInfo*/,
                            CComPtr<IDirectoryObject>& /*spDirObject*/,
                            PDSGET_DISPLAY_INFO pDisplayInfo)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, DisplayPartitions, hr);
    do // false loop
    {
        // Verify parameters
        if (!pszDN ||
            !pDisplayInfo)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Compose the path to the NTDS settings object from the server DN
        CComBSTR sbstrNTDSSettingsDN;
        sbstrNTDSSettingsDN = L"CN=NTDS Settings,";
        sbstrNTDSSettingsDN += pszDN;

        CComBSTR sbstrNTDSSettingsPath;
        refBasePathsInfo.ComposePathFromDN(sbstrNTDSSettingsDN, sbstrNTDSSettingsPath);

        // Bind to it
        CComPtr<IADs> spADs;
        hr = DSCmdOpenObject(refCredentialObject,
            sbstrNTDSSettingsPath,
            IID_IADs,
            (void**)&spADs,
            true);

        if (FAILED(hr))
        {
            break;
        }

        // Get the partitions bstr array (per Brett Shirley)
        // 705146 ronmart 2002/09/18 .NET Server domains use msDS-hasMasterNCs
        CComVariant var;
        hr = spADs->Get(CComBSTR(L"msDS-hasMasterNCs"), &var);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL5_LOGGING,
                L"Failed to get msDS-hasMasterNCs: hr = 0x%x",
                hr);

            // 705146 ronmart 2002/09/18 W2k Server domains use hasMasterNCs
            hr = spADs->Get(CComBSTR(L"hasMasterNCs"), &var);
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL5_LOGGING,
                L"Failed to get hasMasterNCs: hr = 0x%x",
                hr);
                break;
            }
        }
        
        // Add the array values to the displayInfo
        hr = AddValuesToDisplayInfo(var, pDisplayInfo);
        
        if (FAILED(hr))
        {
            break;
        }
    } while (false);

    return hr;
}

HRESULT DisplayQuotaInfoFunc(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO /*pAttrInfo*/,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
    ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayQuotaInfoFunc, hr);

    LPWSTR lpszSid = NULL;
    PWSTR  pszPartitionDN = NULL;
    PSID   pSid = NULL;

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pEntry ||
            !pRecord ||
            !pDisplayInfo ||
            !pszDN)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Get a pointer to the object entry for readability
        PCWSTR pszCommandLineObjectType = pEntry->pszCommandLineObjectType;

        // NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit -qused 
        //                                         not returning values 
        PCWSTR pszAttrName = NULL;

        DSGET_COMMAND_ENUM ePart;

        if(0 == _wcsicmp(pszCommandLineObjectType, g_pszUser))
        {
            ePart = eUserPart;

            // NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit
            //                                      -qused not returning values 
            if(0 == _wcsicmp(pDisplayInfo->GetDisplayName(), g_pszArg1UserQLimit))
            {
                pszAttrName = g_pszAttrmsDSQuotaEffective;
            }
            else if(0 == _wcsicmp(pDisplayInfo->GetDisplayName(), g_pszArg1UserQuotaUsed))
            {
                pszAttrName = g_pszAttrmsDSQuotaUsed;
            }
            else
            {
                hr = E_INVALIDARG;
                DEBUG_OUTPUT(FULL_LOGGING, 
                    L"Unable to determine quota attribute name.");
                break;
            }
        }
        else if(0 == _wcsicmp(pszCommandLineObjectType, g_pszGroup))
        {
            ePart = eGroupPart;

            // NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit
            //                                      -qused not returning values 
            if(0 == _wcsicmp(pDisplayInfo->GetDisplayName(), g_pszArg1GroupQLimit))
            {
                pszAttrName = g_pszAttrmsDSQuotaEffective;
            }
            else if(0 == _wcsicmp(pDisplayInfo->GetDisplayName(), g_pszArg1GroupQuotaUsed))
            {
                pszAttrName = g_pszAttrmsDSQuotaUsed;
            }
            else
            {
                hr = E_INVALIDARG;
                DEBUG_OUTPUT(FULL_LOGGING, 
                    L"Unable to determine quota attribute name.");
                break;
            }


        }
        else if(0 == _wcsicmp(pszCommandLineObjectType, g_pszComputer))
        {
            ePart = eComputerPart;

            // NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit
            //                                      -qused not returning values 
            if(0 == _wcsicmp(pDisplayInfo->GetDisplayName(), g_pszArg1ComputerQLimit))
            {
                pszAttrName = g_pszAttrmsDSQuotaEffective;
            }
            else if(0 == _wcsicmp(pDisplayInfo->GetDisplayName(), g_pszArg1ComputerQuotaUsed))
            {
                pszAttrName = g_pszAttrmsDSQuotaUsed;
            }
            else
            {
                hr = E_INVALIDARG;
                DEBUG_OUTPUT(FULL_LOGGING, 
                    L"Unable to determine quota attribute name.");
                break;
            }

        }
        else
        {
            hr = E_INVALIDARG;
            // TODO: This may cause a duplicate error message
            DisplayErrorMessage(g_pszDSCommandName,
                pszDN,
                hr,
                IDS_ERRMSG_PART_MISSING);
            break;
        }

        // Validate the partition and get the quotas container DN
        hr = GetQuotaContainerDN(refBasePathsInfo, refCredentialObject, 
            pRecord[ePart].strValue, &pszPartitionDN);

        if(FAILED(hr))
        {
            // TODO: This may cause a duplicate error message
            DisplayErrorMessage(g_pszDSCommandName,
                pRecord[ePart].strValue,
                hr,
                IDS_ERRMSG_INVALID_PART);
            break;
        }

        // Get a path that accounts for -domain or -server
        CComBSTR sbstrObjectPath;
        refBasePathsInfo.ComposePathFromDN(pszPartitionDN, sbstrObjectPath,
            DSCMD_LDAP_PROVIDER);

        // Build a variant array of the value to look up
        CComVariant varArrayQuotaParams;
        LPWSTR pszAttrs[] = { (LPWSTR) pszAttrName };
        DWORD dwNumber = 1;
        hr = ADsBuildVarArrayStr( pszAttrs, dwNumber, &varArrayQuotaParams );
        if(FAILED(hr))
        {
            break;
        }

        CComPtr<IADs> spADsContainer;
        CComPtr<IADsObjectOptions> spADsObjectOptions;

        // Get the SID from the DN
        hr = GetDNSid(pszDN,
            refBasePathsInfo,
            refCredentialObject,
            &pSid);

        if(FAILED(hr))
        {
            break;
        }

        if(!ConvertSidToStringSid(pSid, &lpszSid))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"ConvertSidToStringSid failure: GetLastError = 0x%08x, %s", 
                GetLastError());
            break;
        }

        // Bind to the quotas container for the given partition
        hr = DSCmdOpenObject(refCredentialObject,
            sbstrObjectPath,
            IID_IADs,
            (void**)&spADsContainer,
            false);

        if (FAILED(hr) || (spADsContainer.p == 0))
        {
            ASSERT( !!spADsContainer );
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"DsCmdOpenObject failure: hr = 0x%08x, %s", hr);
            break;
        }

        // Get a object options pointer
        hr = spADsContainer->QueryInterface(IID_IADsObjectOptions,
            (void**)&spADsObjectOptions);

        if (FAILED(hr) || (spADsObjectOptions.p == 0))
        {
            ASSERT( !!spADsObjectOptions );
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"QI for IID_IADsObjectOptions failed: hr = 0x%08x, %s",
                hr);
            break;
        }

        // Quota values are obtained by setting the ADS_OPTION_QUOTA value
        // to the SID string of the trustee who you want to inquire about
        // and then calling GetInfoEx to update the property cache with
        // the computed values
        CComVariant vntSID(lpszSid);
        hr = spADsObjectOptions->SetOption(ADS_OPTION_QUOTA, vntSID);
        if(FAILED(hr)) 
        { 
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"SetOption(ADS_OPTION_QUOTA,sid) failure: hr = 0x%08x", hr);
            break; 
        }

        // Done with the sid string, so free it
        LocalFree(lpszSid);
        lpszSid= NULL;

        // Update the property cache
        hr = spADsContainer->GetInfoEx(varArrayQuotaParams, 0);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"GetInfoEx failure: hr = 0x%08x", hr);
            break;
        }

        // Get the requested attribute from the quota container
        CComVariant var;
        hr = spADsContainer->Get(CComBSTR(pszAttrName), &var);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"Failed to retrieve %s: hr = 0x%x", 
                pszAttrName, hr);
            hr = E_UNEXPECTED;
            break;
        }
        // Add the value to the display info
        var.ChangeType(VT_BSTR);
        hr = pDisplayInfo->AddValue(V_BSTR(&var));
        if (FAILED(hr))
        {
            break;
        }

    } while (false);

    if(pSid)
        LocalFree(pSid);

    if(pszPartitionDN)
        LocalFree(pszPartitionDN);

    if(lpszSid)
        LocalFree(lpszSid);

    return hr;
}


HRESULT DisplayUserFromSidFunc(PCWSTR /*pszDN*/,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& /*refCredentialObject*/,
                                _DSGetObjectTableEntry* /*pEntry*/,
                                ARG_RECORD* /*pRecord*/,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
    ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayUserFromSidFunc, hr);

    LPWSTR lpszName = NULL;
    LPWSTR lpszDomain = NULL;

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pAttrInfo ||
            !pDisplayInfo)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (pAttrInfo && pAttrInfo->pADsValues)
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                L"Adding %d values:",
                pAttrInfo->dwNumValues);

            DWORD dwValuesAdded = 0;
            for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; dwIdx++)
            {
                DWORD cchName = 0;
                DWORD cchDomainName = 0;
                SID_NAME_USE sUse = SidTypeInvalid;

                if(pAttrInfo->dwADsType != ADSTYPE_OCTET_STRING)
                {
                    // Wrong attribute requested in gettable.cpp
                    hr = E_INVALIDARG;
                    break;
                }

                // Call once to get the buffer sizes
                LookupAccountSid(refBasePathsInfo.GetServerName(),
                    (PSID)pAttrInfo->pADsValues[dwIdx].OctetString.lpValue, 
                    lpszName, 
                    &cchName, 
                    lpszDomain, 
                    &cchDomainName, 
                    &sUse);

                if(cchName < 1 || cchDomainName < 1)
                {
                    E_UNEXPECTED;
                    break;
                }

                lpszName = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                    cchName * sizeof(WCHAR));
                if(NULL == lpszName)
                {
                    E_OUTOFMEMORY;
                    break;
                }

                lpszDomain = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                    cchDomainName * sizeof(WCHAR));
                if(NULL == lpszDomain)
                {
                    E_OUTOFMEMORY;
                    break;
                }

                // Get the SAM name
                if(!LookupAccountSid(refBasePathsInfo.GetServerName(),
                    (PSID)pAttrInfo->pADsValues[dwIdx].OctetString.lpValue, 
                    lpszName, 
                    &cchName, 
                    lpszDomain, 
                    &cchDomainName, 
                    &sUse))
                {
                    E_FAIL;
                    break;
                }

                DWORD chBufSize = (cchName + cchDomainName + 2);
                LPWSTR lpszNew = (LPWSTR) HeapReAlloc(GetProcessHeap(), 0, 
                    lpszDomain, chBufSize * sizeof(WCHAR));
                if (NULL == lpszNew)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                lpszDomain = lpszNew;


                // Merge the domain & account name and add the value
                // to the display info
                hr = StringCchCat(lpszDomain, chBufSize, L"\\");
                if (FAILED(hr))
                {
                    break;
                }

                hr = StringCchCat(lpszDomain, chBufSize, lpszName);
                if (FAILED(hr))
                {
                    break;
                }

                hr = pDisplayInfo->AddValue(lpszDomain);
                if (FAILED(hr))
                {
                    break;
                }

                // Release and reset everything for the next iteration
                HeapFree(GetProcessHeap(), 0, lpszName);
                HeapFree(GetProcessHeap(), 0, lpszDomain);

                lpszName = NULL;
                lpszDomain = NULL;
                cchName = 0;
                cchDomainName = 0;
                sUse = SidTypeInvalid;

                dwValuesAdded++;

            }
        }
    } while (false);

    if(lpszName)
        HeapFree(GetProcessHeap(), 0, lpszName);

    if(lpszDomain)
        HeapFree(GetProcessHeap(), 0, lpszDomain);

    return hr;
}

HRESULT CommonDisplayStringFunc(PCWSTR /*pszDN*/,
                                CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                const CDSCmdCredentialObject& /*refCredentialObject*/,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CommonDisplayStringFunc, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo && pAttrInfo->pADsValues)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);


         DWORD dwValuesAdded = 0;
         for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; dwIdx++)
         {
            WCHAR* pBuffer = 0;

            hr = GetStringFromADs(&(pAttrInfo->pADsValues[dwIdx]),
                                  pAttrInfo->dwADsType,
                                  &pBuffer, 
                                  pAttrInfo->pszAttrName);
            if (SUCCEEDED(hr))
            {
               hr = pDisplayInfo->AddValue(pBuffer);
               if (FAILED(hr))
               {
                  delete[] pBuffer;
                  pBuffer = NULL;
                  break;
               }
               delete[] pBuffer;
               pBuffer = NULL;

               dwValuesAdded++;
            }
         }
      }

   } while (false);

   return hr;
}


HRESULT DisplayCanChangePassword(PCWSTR pszDN,
                                 CDSCmdBasePathsInfo& refBasePathsInfo,
                                 const CDSCmdCredentialObject& refCredentialObject,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pRecord,
                                 PADS_ATTR_INFO /*pAttrInfo*/,
                                 CComPtr<IDirectoryObject>& /*spDirObject*/,
                                 PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayCanChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      bool bCanChangePassword = false;
      hr = EvaluateCanChangePasswordAces(pszDN,
                                         refBasePathsInfo,
                                         refCredentialObject,
                                         bCanChangePassword);
      if (FAILED(hr))
      {
         break;
      }

      DEBUG_OUTPUT(LEVEL8_LOGGING, 
                   L"Can change password: %s", 
                   bCanChangePassword ? g_pszYes : g_pszNo);

      hr = pDisplayInfo->AddValue(bCanChangePassword ? g_pszYes : g_pszNo);

   } while (false);

   return hr;
}

HRESULT DisplayMustChangePassword(PCWSTR /*pszDN*/,
                                  CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                  const CDSCmdCredentialObject& /*refCredentialObject*/,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& /*spDirObject*/,
                                  PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayMustChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_LARGE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bMustChangePassword = false;

         if (pAttrInfo->pADsValues->LargeInteger.HighPart == 0 &&
             pAttrInfo->pADsValues->LargeInteger.LowPart  == 0)
         {
            bMustChangePassword = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Must change password: %s", 
                      bMustChangePassword ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bMustChangePassword ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}


HRESULT DisplayAccountDisabled(PCWSTR /*pszDN*/,
                               CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                               const CDSCmdCredentialObject& /*refCredentialObject*/,
                               _DSGetObjectTableEntry* pEntry,
                               ARG_RECORD* pRecord,
                               PADS_ATTR_INFO pAttrInfo,
                               CComPtr<IDirectoryObject>& /*spDirObject*/,
                               PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayAccountDisabled, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bAccountDisabled = false;

         if (pAttrInfo->pADsValues->Integer & UF_ACCOUNTDISABLE)
         {
            bAccountDisabled = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Account disabled: %s", 
                      bAccountDisabled ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bAccountDisabled ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}

HRESULT DisplayPasswordNeverExpires(PCWSTR /*pszDN*/,
                                    CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                    const CDSCmdCredentialObject& /*refCredentialObject*/,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& /*spDirObject*/,
                                    PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayPasswordNeverExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bPwdNeverExpires = false;

         if (pAttrInfo->pADsValues->Integer & UF_DONT_EXPIRE_PASSWD)
         {
            bPwdNeverExpires = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Password never expires: %s", 
                      bPwdNeverExpires ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bPwdNeverExpires ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}


HRESULT DisplayReversiblePassword(PCWSTR /*pszDN*/,
                                  CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                  const CDSCmdCredentialObject& /*refCredentialObject*/,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& /*spDirObject*/,
                                  PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayReversiblePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bReversiblePwd = false;

         if (pAttrInfo->pADsValues->Integer & UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED)
         {
            bReversiblePwd = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Password store with reversible encryption: %s", 
                      bReversiblePwd ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bReversiblePwd ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}

// Constants

const unsigned long DSCMD_FILETIMES_PER_MILLISECOND = 10000;
const DWORD DSCMD_FILETIMES_PER_SECOND = 1000 * DSCMD_FILETIMES_PER_MILLISECOND;
const DWORD DSCMD_FILETIMES_PER_MINUTE = 60 * DSCMD_FILETIMES_PER_SECOND;
const __int64 DSCMD_FILETIMES_PER_HOUR = 60 * (__int64)DSCMD_FILETIMES_PER_MINUTE;
const __int64 DSCMD_FILETIMES_PER_DAY  = 24 * DSCMD_FILETIMES_PER_HOUR;
const __int64 DSCMD_FILETIMES_PER_MONTH= 30 * DSCMD_FILETIMES_PER_DAY;

HRESULT DisplayAccountExpires(PCWSTR /*pszDN*/,
                              CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                              const CDSCmdCredentialObject& /*refCredentialObject*/,
                              _DSGetObjectTableEntry* pEntry,
                              ARG_RECORD* pRecord,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& /*spDirObject*/,
                              PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayAccountExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo && pAttrInfo->pADsValues)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);


         DWORD dwValuesAdded = 0;
         for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; dwIdx++)
         {
            WCHAR* pBuffer = new WCHAR[MAXSTR+1];
            if (!pBuffer)
            {
               hr = E_OUTOFMEMORY;
               break;
            }
            ZeroMemory(pBuffer, (MAXSTR+1) * sizeof(WCHAR));
            if (pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart == 0 ||
                pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart == -1 ||
                pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart == 0x7FFFFFFFFFFFFFFF)
            {
			   //Security Review: if g_pszNever is greater or equal to MAXSTR,
			   //buffer is not null terminated.Bug 574385
               wcsncpy(pBuffer, g_pszNever, MAXSTR); //Change pBuffer size to MAXSTR+1, yanggao
               hr = pDisplayInfo->AddValue(pBuffer);
               if (FAILED(hr))
               {
                  delete[] pBuffer;
                  pBuffer = NULL;
                  break;
               }
               dwValuesAdded++;
            }
            else
            {
               FILETIME ftGMT;     // GMT filetime
               FILETIME ftLocal;   // Local filetime
               SYSTEMTIME st;
               SYSTEMTIME stGMT;

               ZeroMemory(&ftGMT, sizeof(FILETIME));
               ZeroMemory(&ftLocal, sizeof(FILETIME));
               ZeroMemory(&st, sizeof(SYSTEMTIME));
               ZeroMemory(&stGMT, sizeof(SYSTEMTIME));

               //Get Local Time in SYSTEMTIME format
               ftGMT.dwLowDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.LowPart;
               ftGMT.dwHighDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.HighPart;
               FileTimeToSystemTime(&ftGMT, &stGMT);
               SystemTimeToTzSpecificLocalTime(NULL, &stGMT,&st);

               //For Display Purpose reduce one day
               SystemTimeToFileTime(&st, &ftLocal );
               pAttrInfo->pADsValues[dwIdx].LargeInteger.LowPart = ftLocal.dwLowDateTime;
               pAttrInfo->pADsValues[dwIdx].LargeInteger.HighPart = ftLocal.dwHighDateTime;
               pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart -= DSCMD_FILETIMES_PER_DAY;
               ftLocal.dwLowDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.LowPart;
               ftLocal.dwHighDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.HighPart;
               FileTimeToSystemTime(&ftLocal, &st);

               // Format the string with respect to locale
               if (!GetDateFormat(LOCALE_USER_DEFAULT, 0 , 
                                  &st, NULL, 
                                  pBuffer, MAXSTR))
               {
                  hr = GetLastError();
                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Failed to locale string for date: hr = 0x%x",
                               hr);
               }
               else
               {
                  hr = pDisplayInfo->AddValue(pBuffer);
                  if (FAILED(hr))
                  {
                     delete[] pBuffer;
                     pBuffer = NULL;
                     break;
                  }
                  dwValuesAdded++;
               }
            }
            delete[] pBuffer;
            pBuffer = NULL;

         }
      }

   } while (false);

   return hr;
}

HRESULT DisplayGroupScope(PCWSTR /*pszDN*/,
                          CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                          const CDSCmdCredentialObject& /*refCredentialObject*/,
                          _DSGetObjectTableEntry* pEntry,
                          ARG_RECORD* pRecord,
                          PADS_ATTR_INFO pAttrInfo,
                          CComPtr<IDirectoryObject>& /*spDirObject*/,
                          PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupScope, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_RESOURCE_GROUP)
         {
            //
            // Display Domain Local
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: domain local");

            hr = pDisplayInfo->AddValue(L"domain local");
         }
         else if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_ACCOUNT_GROUP)
         {
            //
            // Display Global
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: global");

            hr = pDisplayInfo->AddValue(L"global");
         }
         else if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_UNIVERSAL_GROUP)
         {
            //
            // Display Universal
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: universal");

            hr = pDisplayInfo->AddValue(L"universal");
         }
         else if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_APP_BASIC_GROUP)
         {
            //
            // AZ basic group
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING,
                         L"Group scope: app basic group");

            CComBSTR sbstrBasicGroup;
            bool result = sbstrBasicGroup.LoadString(::GetModuleHandle(NULL), IDS_APP_BASIC_GROUP);
            ASSERT(result);

            hr = pDisplayInfo->AddValue(sbstrBasicGroup);
         }
         else if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_APP_QUERY_GROUP)
         {
            //
            // AZ basic group
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING,
                         L"Group scope: app query group");

            CComBSTR sbstrQueryGroup;
            bool result = sbstrQueryGroup.LoadString(::GetModuleHandle(NULL), IDS_APP_QUERY_GROUP);
            ASSERT(result);

            hr = pDisplayInfo->AddValue(sbstrQueryGroup);
         }
         else
         {
            //
            // Unknown group type???
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: unknown???");

            hr = pDisplayInfo->AddValue(L"unknown");
         }

      }

   } while (false);

   return hr;
}

HRESULT DisplayGroupSecurityEnabled(PCWSTR /*pszDN*/,
                                    CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                    const CDSCmdCredentialObject& /*refCredentialObject*/,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& /*spDirObject*/,
                                    PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupSecurityEnabled, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d value:",
                      1);

         bool bSecurityEnabled = false;

         if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_SECURITY_ENABLED)
         {
            bSecurityEnabled = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Group security enabled: %s", 
                      bSecurityEnabled ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bSecurityEnabled ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ConvertRIDtoDN
//
//  Synopsis:   Finds the DN for the group associated with the primary group ID
//
//  Arguments:  [pObjSID IN]           : SID of the object in question
//              [priGroupRID IN]       : primary group ID of the group to be found
//              [refBasePathsInfo IN]  : reference to base paths info
//              [refCredObject IN]     : reference to the credential manager object
//              [refsbstrdN OUT]       : DN of the group
//
//  Returns:    S_OK if everthing succeeds and a group was found
//              S_FALSE if everthing succeeds but no group was found
//              E_INVALIDARG is an argument is incorrect
//              Anything else was a result of a failed ADSI call
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ConvertRIDtoDN(PSID pObjSID,
                       DWORD priGroupRID, 
                       CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredObject,
                       CComBSTR& refsbstrDN)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, ConvertRIDtoDN, hr);

   //
   // This needs to be cleaned up no matter how we exit the false loop
   //
   PWSTR pszSearchFilter = NULL;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pObjSID ||
          !priGroupRID)
      {
         ASSERT(pObjSID);
         ASSERT(priGroupRID);
         hr = E_INVALIDARG;
         break;
      }

      UCHAR * psaCount, i;
      PSID pSID = NULL;
      PSID_IDENTIFIER_AUTHORITY psia;
      DWORD rgRid[8];

      psaCount = GetSidSubAuthorityCount(pObjSID);

      if (psaCount == NULL)
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
                      L"GetSidSubAuthorityCount failed: hr = 0x%x",
                      hr);
         break;
      }

      if (*psaCount > 8)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"The count returned from GetSidSubAuthorityCount was too high: %d",
                      *psaCount);
         hr = E_FAIL;
         break;
      }

      for (i = 0; i < (*psaCount - 1); i++)
      {
         PDWORD pRid = GetSidSubAuthority(pObjSID, (DWORD)i);
         if (pRid == NULL)
         {
            DWORD _dwErr = GetLastError();	     
            hr = HRESULT_FROM_WIN32( _dwErr );
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"GetSidSubAuthority for index %i failed: hr = 0x%x",
                         i,
                         hr);
            break;
         }
         rgRid[i] = *pRid;
      }

      if (FAILED(hr))
      {
         break;
      }

      rgRid[*psaCount - 1] = priGroupRID;
      for (i = *psaCount; i < 8; i++)
      {
         rgRid[i] = 0;
      }

      psia = GetSidIdentifierAuthority(pObjSID);
      if (psia == NULL)
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"GetSidIdentifierAuthority failed: hr = 0x%x",
                      hr);
         break; 
      }

	  //Security Review:This is fine.
      if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                               rgRid[2], rgRid[3], rgRid[4],
                               rgRid[5], rgRid[6], rgRid[7], &pSID))
      {
         DWORD _dwErr = GetLastError();	     
         hr = HRESULT_FROM_WIN32( _dwErr );
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"AllocateAndInitializeSid failed: hr = 0x%x",
                      hr);
         break;
      }

      PWSTR rgpwzAttrNames[] = { L"ADsPath" };
      const WCHAR wzSearchFormat[] = L"(&(objectCategory=group)(objectSid=%1))";
      PWSTR pwzSID;

      hr = ADsEncodeBinaryData((PBYTE)pSID, GetLengthSid(pSID), &pwzSID);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"ADsEncodeBinaryData failed: hr = 0x%x",
                      hr);
         break;
      }

      PVOID apv[1] = { pwzSID };

      // generate the filter
      DWORD characterCount = 
         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_STRING
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       wzSearchFormat,
                       0,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (PTSTR)&pszSearchFilter, 
                       0, 
                       (va_list*)apv);

      FreeADsMem(pwzSID);

      if (!characterCount)
      {
         DWORD error = ::GetLastError();
         hr = HRESULT_FROM_WIN32(error);
 
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"FormatMessage failed to build filter string: hr = 0x%x",
                      hr);
         break;
      }

      DEBUG_OUTPUT(FULL_LOGGING,
                   L"Query filter = %s",
                   pszSearchFilter);
      //
      // Get the domain path
      //
      CComBSTR sbstrDomainDN;
      sbstrDomainDN = refBasePathsInfo.GetDefaultNamingContext();

      CComBSTR sbstrDomainPath;
      refBasePathsInfo.ComposePathFromDN(sbstrDomainDN, sbstrDomainPath);

      //
      // Get an IDirectorySearch interface to the domain
      //
      CComPtr<IDirectorySearch> spDirSearch;
      hr = DSCmdOpenObject(refCredObject,
                           sbstrDomainPath,
                           IID_IDirectorySearch,
                           (void**)&spDirSearch,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CDSSearch Search;
      hr = Search.Init(spDirSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to initialize the search object: hr = 0x%x",
                      hr);
         break;
      }

      Search.SetFilterString(pszSearchFilter);

      Search.SetAttributeList(rgpwzAttrNames, 1);
      Search.SetSearchScope(ADS_SCOPE_SUBTREE);

      hr = Search.DoQuery();
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to run search: hr = 0x%x",
                      hr);
         break;
      }

      hr = Search.GetNextRow();
      if (hr == S_ADS_NOMORE_ROWS)
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"No group was found with primaryGroupID = %d",
                      priGroupRID);
         //
         // No object has a matching RID, the primary group must have been
         // deleted. Return S_FALSE to denote this condition.
         //
         hr = S_FALSE;
         break;
      }

      if (FAILED(hr))
      {
         break;
      }

      ADS_SEARCH_COLUMN Column;
      hr = Search.GetColumn(L"ADsPath", &Column);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to get the path column: hr = 0x%x",
                      hr);
         break;
      }

      if (!Column.pADsValues->CaseIgnoreString)
      {
         hr = E_FAIL;
         break;
      }

      refsbstrDN = Column.pADsValues->CaseIgnoreString;
      Search.FreeColumn(&Column);
   } while (false);

   //
   // Cleanup
   //
   if (pszSearchFilter)
   {
      LocalFree(pszSearchFilter);
      pszSearchFilter = NULL;
   }

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   AddMembershipValues
//
//  Synopsis:   Retrieves the DNs of the objects to which the current object
//              is a member
//
//  Arguments:  [pszDN IN]                : DN of object to retrieve member of
//              [refBasePathsInfo IN]     : reference to Base paths info object
//              [refCredentialObject IN]  : reference to Credential management object
//              [pDisplayInfo IN/OUT]     : Pointer to display info for this attribute
//              [bMemberOf IN]            : Should we look for memberOf or members
//              [bRecurse IN]             : Should we find the membership for each object returned
//
//  Returns:    S_OK if everthing succeeds
//              E_INVALIDARG is an argument is incorrect
//              Anything else was a result of a failed ADSI call
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT AddMembershipValues(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            PDSGET_DISPLAY_INFO pDisplayInfo,
                            bool bMemberOf = true,
                            bool bRecurse = false)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, AddMembershipValues, hr);

   //
   // These are declared here so that we can free them if we break out of the false loop
   //
   PADS_ATTR_INFO pAttrInfo = NULL;
   PADS_ATTR_INFO pGCAttrInfo = NULL;
   PSID pObjSID = NULL;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      CManagedStringList groupsDisplayed;
      CManagedStringList membersToDisplay;

      membersToDisplay.Add(pszDN);

      CManagedStringEntry* pCurrent = membersToDisplay.Pop();
      while (pCurrent)
      {
         //
         // We have to open the object
         //

         CComPtr<IDirectoryObject> spDirObject;
         CComBSTR sbstrPath;
         refBasePathsInfo.ComposePathFromDN(pCurrent->sbstrValue, sbstrPath);

         hr = DSCmdOpenObject(refCredentialObject,
                              sbstrPath,
                              IID_IDirectoryObject,
                              (void**)&spDirObject,
                              true);
         if (FAILED(hr))
         {
            if (pCurrent)
            {
               delete pCurrent;
               pCurrent = 0;
            }
            pCurrent = membersToDisplay.Pop();
            continue;
         }

         CComBSTR sbstrClass;
         CComPtr<IADs> spIADs;
         hr = spDirObject->QueryInterface(IID_IADs, (void**)&spIADs);
         if (FAILED(hr))
         {
            if (pCurrent)
            {
               delete pCurrent;
               pCurrent = 0;
            }
            pCurrent = membersToDisplay.Pop();
            continue;
         }
      
         hr = spIADs->get_Class(&sbstrClass);
         if (FAILED(hr))
         {
            if (pCurrent)
            {
               delete pCurrent;
               pCurrent = 0;
            }
            pCurrent = membersToDisplay.Pop();
            continue;
         }

         //
         // Read the memberOf attribute and any attributes we need for that specific class
         //
		 //This is fine. Both are null terminated.
         if (_wcsicmp(sbstrClass, g_pszUser) == 0 ||
             _wcsicmp(sbstrClass, g_pszComputer) == 0)
         {
            if (!bMemberOf)
            {
               // Don't want to show memberOf info if we are looking for members

               if (pCurrent)
               {
                  delete pCurrent;
                  pCurrent = 0;
               }
               pCurrent = membersToDisplay.Pop();
               continue;
            }

            DEBUG_OUTPUT(FULL_LOGGING, L"Displaying membership for a user or computer");

            static const DWORD dwAttrCount = 3;
            PWSTR ppszAttrNames[] = { L"memberOf", L"primaryGroupID", L"objectSID" };
            DWORD dwAttrsReturned = 0;

            hr = spDirObject->GetObjectAttributes(ppszAttrNames,
                                                  dwAttrCount,
                                                  &pAttrInfo,
                                                  &dwAttrsReturned);
            if (FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING,
                            L"GetObjectAttributes failed for class %s: hr = 0x%x",
                            sbstrClass,
                            hr);

               if (pCurrent)
               {
                  delete pCurrent;
                  pCurrent = 0;
               }
               pCurrent = membersToDisplay.Pop();
               continue;
            }

            if (pAttrInfo && dwAttrsReturned)
            {
               DWORD priGroupRID = 0;

               //
               // For each attribute returned do the appropriate thing
               //
               for (DWORD dwIdx = 0; dwIdx < dwAttrsReturned; dwIdx++)
               {
				  //Security Review:This is fine.
                  if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"memberOf") == 0)
                  {
                     //
                     // Add each value and recurse if necessary
                     //
                     for (DWORD dwValueIdx = 0; dwValueIdx < pAttrInfo[dwIdx].dwNumValues; dwValueIdx++)
                     {
                        if (pAttrInfo[dwIdx].pADsValues &&
                            pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString)
                        {
                           if (!groupsDisplayed.Contains(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString))
                           {
                              DEBUG_OUTPUT(LEVEL8_LOGGING, 
                                           L"Adding group to display: %s",
                                           pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString);

                              groupsDisplayed.Add(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString);
                              hr = pDisplayInfo->AddValue(GetQuotedDN(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString));
                              if (FAILED(hr))
                              {
                                 break; // value for loop
                              }
                        
                              if (bRecurse)
                              {
                                 DEBUG_OUTPUT(LEVEL8_LOGGING,
                                              L"Adding group for recursion: %s",
                                              pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString);

                                 membersToDisplay.Add(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString);
                              }
                           }
                        }
                     }

                     if (FAILED(hr))
                     {
                        break; // attrs for loop
                     }
                  }
				  //Security Review:Both are null terminated.
                  else if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"primaryGroupID") == 0)
                  {
                     if (pAttrInfo[dwIdx].pADsValues)
                     {
                        priGroupRID = pAttrInfo[dwIdx].pADsValues->Integer;
                     }
                  }
				  //Security Review:Both are null terminated.
                  else if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"objectSID") == 0)
                  {
                     pObjSID = new BYTE[pAttrInfo[dwIdx].pADsValues->OctetString.dwLength];
                     if (!pObjSID)
                     {
                        hr = E_OUTOFMEMORY;
                        break; // attrs for loop
                     }
					 //Security Review:This is fine.
                     memcpy(pObjSID, pAttrInfo[dwIdx].pADsValues->OctetString.lpValue,
                            pAttrInfo[dwIdx].pADsValues->OctetString.dwLength);
                  }

               } // attrs for loop

               //
               // if we were able to retrieve the SID and the primaryGroupID,
               // then convert that into the DN of the group
               //
               if (pObjSID &&
                   priGroupRID)
               {
                  CComBSTR sbstrPath;
                  hr = ConvertRIDtoDN(pObjSID,
                                      priGroupRID, 
                                      refBasePathsInfo,
                                      refCredentialObject,
                                      sbstrPath);
                  if (SUCCEEDED(hr) &&
                      hr != S_FALSE)
                  {
                     CComBSTR sbstrDN;

                     hr = CPathCracker::GetDNFromPath(sbstrPath, sbstrDN);
                     if (SUCCEEDED(hr))
                     {
                        if (!groupsDisplayed.Contains(sbstrDN))
                        {
                           groupsDisplayed.Add(sbstrDN);
                           hr = pDisplayInfo->AddValue(GetQuotedDN(sbstrDN));
                           if (SUCCEEDED(hr) && bRecurse)
                           {
                              membersToDisplay.Add(sbstrDN);
                           }
                        }
                     }
                  }

                  if (pObjSID)
                  {
                     delete[] pObjSID;
                     pObjSID = 0;
                  }
               }
            }
            if (pAttrInfo)
            {
               FreeADsMem(pAttrInfo);
               pAttrInfo = NULL;
            }

            if (FAILED(hr))
            {
               if (pCurrent)
               {
                  delete pCurrent;
                  pCurrent = 0;
               }
               pCurrent = membersToDisplay.Pop();
               continue; // while loop
            }
         }
		 //Security Review:Both are null terminated.
         else if (_wcsicmp(sbstrClass, g_pszGroup) == 0)
         {
            long lGroupType = 0;
            hr = ReadGroupType(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               &lGroupType);
            if (FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING,
                            L"Could not read group type: hr = 0x%x",
                            hr);

               // Continue on even if we failed to read the group type
               // The worst thing we do is query the GC for memberOf
            }

            //
            // All we want to do is get the memberOf attribute
            //
            DWORD dwAttrCount = 1;
            PWSTR ppszAttrNames[1];
            ppszAttrNames[0] = (bMemberOf) ? L"memberOf" : L"member";

            DWORD dwGCAttrsReturned = 0;
            if (!(lGroupType & GROUP_TYPE_RESOURCE_GROUP))
            {
               //
               // We also have to get its memberOf attribute from the GC if its not a local group
               //
               CComBSTR sbstrGCPath;
               refBasePathsInfo.ComposePathFromDN(pszDN,
                                                  sbstrGCPath,
                                                  DSCMD_GC_PROVIDER);
            
               //
               // Note: we will continue on as long as we succeed
               //
               CComPtr<IDirectoryObject> spGCDirObject;
               hr = DSCmdOpenObject(refCredentialObject,
                                    sbstrGCPath,
                                    IID_IDirectoryObject,
                                    (void**)&spGCDirObject,
                                    false);
               if (SUCCEEDED(hr))
               {
                  //
                  // Now get the memberOf attribute
                  //
                  hr = spGCDirObject->GetObjectAttributes(ppszAttrNames,
                                                          dwAttrCount,
                                                          &pGCAttrInfo,
                                                          &dwGCAttrsReturned);
                  if (FAILED(hr))
                  {
                     DEBUG_OUTPUT(LEVEL3_LOGGING,
                                  L"Could not retrieve memberOf attribute from GC: hr = 0x%x",
                                  hr);
                     hr = S_OK;
                  }
               }
               else
               {
                  DEBUG_OUTPUT(LEVEL3_LOGGING,
                               L"Could not bind to object in GC: hr = 0x%x",
                               hr);
                  hr = S_OK;
               }
            }

            DWORD dwAttrsReturned = 0;

            hr = spDirObject->GetObjectAttributes(ppszAttrNames,
                                                  dwAttrCount,
                                                  &pAttrInfo,
                                                  &dwAttrsReturned);
            if (FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING,
                            L"GetObjectAttributes failed for class %s: hr = 0x%x",
                            sbstrClass,
                            hr);

               if (pCurrent)
               {
                  delete pCurrent;
                  pCurrent = 0;
               }
               pCurrent = membersToDisplay.Pop();
               continue;
            }

            if (pAttrInfo && dwAttrsReturned)
            {
               bool bFirstPass = true;

               ASSERT(pAttrInfo);
               ASSERT(pAttrInfo->dwNumValues);
               ASSERT(dwAttrsReturned == 1);

               //
               // Add each value and recurse if necessary
               //
               for (DWORD dwValueIdx = 0; dwValueIdx < pAttrInfo->dwNumValues; dwValueIdx++)
               {
                  bool bExistsInGCList = false;

                  if (pAttrInfo->pADsValues &&
                      pAttrInfo->pADsValues[dwValueIdx].DNString)
                  {
                     if (pGCAttrInfo && dwGCAttrsReturned)
                     {
                        //
                        // Only add if it wasn't in the GC list
                        //
                        for (DWORD dwGCValueIdx = 0; dwGCValueIdx < pGCAttrInfo->dwNumValues; dwGCValueIdx++)
                        {
                           if (_wcsicmp(pAttrInfo->pADsValues[dwValueIdx].DNString,
                                        pGCAttrInfo->pADsValues[dwGCValueIdx].DNString) == 0)
                           {
                              bExistsInGCList = true;
                              if (!bFirstPass)
                              {
                                 break; // gc value for
                              }
                           }

                           //
                           // Add all the GC values on the first pass and recurse if necessary
                           //
                           if (bFirstPass)
                           {
                              if (!groupsDisplayed.Contains(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString))
                              {
                                 groupsDisplayed.Add(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString);
                                 hr = pDisplayInfo->AddValue(GetQuotedDN(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString));
                           
                                 //
                                 // We will ignore failures with the GC list
                                 //

                                 if (bRecurse)
                                 {
                                    membersToDisplay.Add(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString);
                                 } 
                              }
                           }
                        }

                        bFirstPass = false;

                        FreeADsMem(pGCAttrInfo);
                        pGCAttrInfo = 0;
                     }

                     //
                     // If it doesn't exist in the GC list then add it.
                     //
                     if (!bExistsInGCList)
                     {
                        if (!groupsDisplayed.Contains(pAttrInfo->pADsValues[dwValueIdx].DNString))
                        {
                           groupsDisplayed.Add(pAttrInfo->pADsValues[dwValueIdx].DNString);
                           hr = pDisplayInfo->AddValue(GetQuotedDN(pAttrInfo->pADsValues[dwValueIdx].DNString));
                           if (FAILED(hr))
                           {
                              break; // value for loop
                           }
               
                           if (bRecurse)
                           {
                              membersToDisplay.Add(pAttrInfo->pADsValues[dwValueIdx].DNString);
                           }
                        }
                     }
                  }
               } // value for loop

               FreeADsMem(pAttrInfo);
               pAttrInfo = 0;

               if (FAILED(hr))
               {
                  if (pCurrent)
                  {
                     delete pCurrent;
                     pCurrent = 0;
                  }
                  pCurrent = membersToDisplay.Pop();
                  continue; // while loop
               }

            }

         }
         else
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Unknown class type: %s", sbstrClass);
            ASSERT(false);
            hr = E_INVALIDARG;
            break;
         }

         delete pCurrent;
         pCurrent = membersToDisplay.Pop();
      }

      if (pCurrent)
      {
         delete pCurrent;
         pCurrent = 0;
      }
   } while (false);


   return hr;
}

HRESULT DisplayGroupMembers(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* /*pEntry*/,
                            ARG_RECORD* pCommandArgs,
                            PADS_ATTR_INFO /*pAttrInfo*/,
                            CComPtr<IDirectoryObject>& /*spDirObject*/,
                            PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupMembers, hr);
   
   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      hr = AddMembershipValues(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pDisplayInfo,
                               false,
                               (pCommandArgs[eGroupExpand].bDefined != 0));

   } while (false);

   return hr;
}

HRESULT DisplayUserMemberOf(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* /*pEntry*/,
                            ARG_RECORD* pCommandArgs,
                            PADS_ATTR_INFO /*pAttrInfo*/,
                            CComPtr<IDirectoryObject>& /*spDirObject*/,
                            PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayUserMemberOf, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      hr = AddMembershipValues(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pDisplayInfo,
                               true,
                               (pCommandArgs[eUserExpand].bDefined != 0));

   } while (false);

   return hr;
}

HRESULT DisplayComputerMemberOf(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* /*pEntry*/,
                                ARG_RECORD* pCommandArgs,
                                PADS_ATTR_INFO /*pAttrInfo*/,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayComputerMemberOf, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      hr = AddMembershipValues(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pDisplayInfo,
                               true,
                               (pCommandArgs[eComputerExpand].bDefined != 0));
   } while (false);

   return hr;
}

HRESULT DisplayGroupMemberOf(PCWSTR pszDN,
                             CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             _DSGetObjectTableEntry* /*pEntry*/,
                             ARG_RECORD* pCommandArgs,
                             PADS_ATTR_INFO /*pAttrInfo*/,
                             CComPtr<IDirectoryObject>& /*spDirObject*/,
                             PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupMemberOf, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      hr = AddMembershipValues(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pDisplayInfo,
                               true,
                               (pCommandArgs[eGroupExpand].bDefined != 0));
   } while (false);

   return hr;
}

HRESULT DisplayGrandparentRDN(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                              const CDSCmdCredentialObject& /*refCredentialObject*/,
                              _DSGetObjectTableEntry* /*pEntry*/,
                              ARG_RECORD* /*pCommandArgs*/,
                              PADS_ATTR_INFO /*pAttrInfo*/,
                              CComPtr<IDirectoryObject>& /*spDirObject*/,
                              PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGrandparentRDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      CComBSTR sbstrSiteName;

      CPathCracker pathCracker;
      hr = pathCracker.Set(CComBSTR(pszDN), ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"IADsPathname::Set failed: hr = 0x%x",
                      hr);
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"IADsPathname::SetDisplayType failed: hr = 0x%x",
                      hr);
         break;
      }

      hr = pathCracker.GetElement(2, &sbstrSiteName);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"IADsPathname::GetElement failed: hr = 0x%x",
                      hr);
         break;
      }

      hr = pDisplayInfo->AddValue(sbstrSiteName);
   } while (false);

   return hr;
}


HRESULT DisplayObjectAttributeAsRDN(PCWSTR /*pszDN*/,
                                    CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                    const CDSCmdCredentialObject& /*refCredentialObject*/,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& /*spDirObject*/,
                                    PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayObjectAttributeAsRDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo && pAttrInfo->pADsValues)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);


         ASSERT(pAttrInfo->dwADsType == ADSTYPE_DN_STRING);

         // Add only the RDN value of the attribute to the output

         CPathCracker pathCracker;
         hr = pathCracker.Set(CComBSTR(pAttrInfo->pADsValues->DNString), ADS_SETTYPE_DN);
         if (SUCCEEDED(hr))
         {
            hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            ASSERT(SUCCEEDED(hr));

            CComBSTR sbstrRDN;
            hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &sbstrRDN);
            if (SUCCEEDED(hr))
            {
               hr = pDisplayInfo->AddValue(sbstrRDN);
            }
         }
      }

   } while (false);

   return hr;
}







HRESULT IsServerGCDisplay(PCWSTR pszDN,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          _DSGetObjectTableEntry* /*pEntry*/,
                          ARG_RECORD* /*pCommandArgs*/,
                          PADS_ATTR_INFO /*pAttrInfo*/,
                          CComPtr<IDirectoryObject>& /*spDirObject*/,
                          PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, IsServerGCDisplay, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Compose the path to the NTDS settings object from the server DN
      //
      CComBSTR sbstrNTDSSettingsDN;
      sbstrNTDSSettingsDN = L"CN=NTDS Settings,";
      sbstrNTDSSettingsDN += pszDN;

      CComBSTR sbstrNTDSSettingsPath;
      refBasePathsInfo.ComposePathFromDN(sbstrNTDSSettingsDN, sbstrNTDSSettingsPath);

      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrNTDSSettingsPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);

      if (FAILED(hr))
      {
         break;
      }

      bool bGC = false;

      CComVariant var;
      hr = spADs->Get(CComBSTR(L"options"), &var);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"Failed to get the options: hr = 0x%x",
                      hr);
      }
      else
      {
         ASSERT(var.vt == VT_I4);

         if (var.lVal & SERVER_IS_GC_BIT)
         {
            bGC = true;
         }
      }
      
      DEBUG_OUTPUT(LEVEL8_LOGGING,
                   L"Server is GC: %s",
                   bGC ? g_pszYes : g_pszNo);

      hr = pDisplayInfo->AddValue(bGC ? g_pszYes : g_pszNo);

   } while (false);

   return hr;
}

HRESULT FindSiteSettingsOptions(IDirectoryObject* pDirectoryObj,
                                DWORD& refOptions)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, FindSiteSettingsOptions, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pDirectoryObj)
      {
         ASSERT(pDirectoryObj);
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IDirectorySearch> spSearch;
      hr = pDirectoryObj->QueryInterface(IID_IDirectorySearch, (void**)&spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"QI for IDirectorySearch failed: hr = 0x%x",
                      hr);
         break;
      }

      CDSSearch Search;
      hr = Search.Init(spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"CDSSearch::Init failed: hr = 0x%x",
                      hr);
         break;
      }

      PWSTR pszSearchFilter = L"(objectClass=nTDSSiteSettings)";
      Search.SetFilterString(pszSearchFilter);

      PWSTR rgpwzAttrNames[] = { L"options" };
      Search.SetAttributeList(rgpwzAttrNames, 1);
      Search.SetSearchScope(ADS_SCOPE_ONELEVEL);

      hr = Search.DoQuery();
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to run search: hr = 0x%x",
                      hr);
         break;
      }

      hr = Search.GetNextRow();
      if (hr == S_ADS_NOMORE_ROWS)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"No rows found!");
         hr = E_FAIL;
         break;
      }

      ADS_SEARCH_COLUMN Column;
      hr = Search.GetColumn(L"options", &Column);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to get the options column: hr = 0x%x",
                      hr);
         break;
      }

      if (Column.dwADsType != ADSTYPE_INTEGER ||
          Column.dwNumValues == 0 ||
          !Column.pADsValues)
      {
         Search.FreeColumn(&Column);
         hr = E_FAIL;
         break;
      }

      refOptions = Column.pADsValues->Integer;

      Search.FreeColumn(&Column);
   } while (false);

   return hr;
}

HRESULT IsAutotopologyEnabledSite(PCWSTR /*pszDN*/,
                                  CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                  const CDSCmdCredentialObject& /*refCredentialObject*/,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pCommandArgs,
                                  PADS_ATTR_INFO /*pAttrInfo*/,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, IsAutotopologyEnabledSite, hr);

   bool bAutoTopDisabled = false;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Get the options attribute from the nTDSSiteSettings object under the site object
      //
      DWORD dwOptions = 0;
      hr = FindSiteSettingsOptions(spDirObject,
                                   dwOptions);
      if (FAILED(hr))
      {
         break;
      }

      //
      // See if the intersite autotopology is disabled
      //
      if (dwOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED)
      {
         bAutoTopDisabled = true;
      }

   } while (false);

   //
   // Add the value for display
   //
   DEBUG_OUTPUT(LEVEL8_LOGGING,
                L"Autotopology: %s",
                bAutoTopDisabled ? g_pszNo : g_pszYes);

   pDisplayInfo->AddValue(bAutoTopDisabled ? g_pszNo : g_pszYes);

   return hr;
}

HRESULT IsCacheGroupsEnabledSite(PCWSTR /*pszDN*/,
                                 CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                 const CDSCmdCredentialObject& /*refCredentialObject*/,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pCommandArgs,
                                 PADS_ATTR_INFO /*pAttrInfo*/,
                                 CComPtr<IDirectoryObject>& spDirObject,
                                 PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, IsCacheGroupsEnabledSite, hr);

   bool bCacheGroupsEnabled = false;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Get the options attribute from the nTDSSiteSettings object under the site object
      //
      DWORD dwOptions = 0;
      hr = FindSiteSettingsOptions(spDirObject,
                                   dwOptions);
      if (FAILED(hr))
      {
         break;
      }

      //
      // See if groups caching is enabled
      //
      if (dwOptions & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED)
      {
         bCacheGroupsEnabled = true;
      }

   } while (false);

   //
   // Add the value for display
   //
   DEBUG_OUTPUT(LEVEL8_LOGGING,
                L"Cache groups enabled: %s",
                bCacheGroupsEnabled ? g_pszYes : g_pszNo);

   pDisplayInfo->AddValue(bCacheGroupsEnabled ? g_pszYes : g_pszNo);
  
   return hr;
}

HRESULT FindSiteSettingsPreferredGCSite(IDirectoryObject* pDirectoryObj,
                                        CComBSTR& refsbstrGC)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, FindSiteSettingsPreferredGCSite, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pDirectoryObj)
      {
         ASSERT(pDirectoryObj);
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IDirectorySearch> spSearch;
      hr = pDirectoryObj->QueryInterface(IID_IDirectorySearch, (void**)&spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"QI for IDirectorySearch failed: hr = 0x%x",
                      hr);
         break;
      }

      CDSSearch Search;
      hr = Search.Init(spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"CDSSearch::Init failed: hr = 0x%x",
                      hr);
         break;
      }

      PWSTR pszSearchFilter = L"(objectClass=nTDSSiteSettings)";
      Search.SetFilterString(pszSearchFilter);

      PWSTR rgpwzAttrNames[] = { L"msDS-Preferred-GC-Site" };
      Search.SetAttributeList(rgpwzAttrNames, 1);
      Search.SetSearchScope(ADS_SCOPE_ONELEVEL);

      hr = Search.DoQuery();
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to run search: hr = 0x%x",
                      hr);
         break;
      }

      hr = Search.GetNextRow();
      if (hr == S_ADS_NOMORE_ROWS)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"No rows found!");
         hr = E_FAIL;
         break;
      }

      ADS_SEARCH_COLUMN Column;
      hr = Search.GetColumn(L"msDS-Preferred-GC-Site", &Column);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to get the msDS-Preferred-GC-Site column: hr = 0x%x",
                      hr);
         break;
      }

      if (Column.dwADsType != ADSTYPE_DN_STRING ||
          Column.dwNumValues == 0 ||
          !Column.pADsValues)
      {
         Search.FreeColumn(&Column);
         hr = E_FAIL;
         break;
      }

      refsbstrGC = Column.pADsValues->DNString;

      Search.FreeColumn(&Column);
   } while (false);

   return hr;
}

HRESULT DisplayPreferredGC(PCWSTR /*pszDN*/,
                           CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                           const CDSCmdCredentialObject& /*refCredentialObject*/,
                           _DSGetObjectTableEntry* pEntry,
                           ARG_RECORD* pCommandArgs,
                           PADS_ATTR_INFO /*pAttrInfo*/,
                           CComPtr<IDirectoryObject>& spDirObject,
                           PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayPreferredGC, hr);

   CComBSTR sbstrGC;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Get the msDS-Preferred-GC-Site attribute from the nTDSSiteSettings 
      // object under the site object
      //
      hr = FindSiteSettingsPreferredGCSite(spDirObject,
                                           sbstrGC);
      if (FAILED(hr))
      {
         break;
      }

   } while (false);

   //
   // Add the value for display
   //
   DEBUG_OUTPUT(LEVEL8_LOGGING,
                L"Preferred GC Site: %s",
                (!sbstrGC) ? g_pszNotConfigured : sbstrGC);

   pDisplayInfo->AddValue((!sbstrGC) ? g_pszNotConfigured : sbstrGC);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\dsget.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsget.cpp
//
//  Contents:  Defines the main function    DSGET
//             command line utility
//
//  History:   13-Oct-2000 JeffJon Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "gettable.h"
#include "query.h"
#include "resource.h"
#include "output.h"


//
// Forward Function Declarations
//
HRESULT DoGetValidation(PARG_RECORD pCommandArgs,
                        PDSGetObjectTableEntry pObjectEntry,
                        BOOL& bErrorShown);

HRESULT DoGet(PARG_RECORD pCommandArgs, 
              PDSGetObjectTableEntry pObjectEntry);

HRESULT GetAttributesToFetch(IN PARG_RECORD pCommandArgs,
                             IN PDSGetObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount);
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount);

HRESULT SetRange(IN  LPCWSTR pszAttrName, 
                 IN  DWORD   dwRangeUBound, 
                 OUT LPWSTR* pszAttrs);

// NTRAID#NTBUG9-717576-2002/10/10-JeffJon
// set this global so that we don't show the success message
// when displaying members of a group or memberof or manager

bool bDontDisplaySuccess = false;

//
//Main Function
//
int __cdecl _tmain( VOID )
{

    int argc = 0;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    PARG_RECORD pNewCommandArgs = 0;

    //
    // False loop
    //
    do
    {
        //
        // Initialize COM
        //
        hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
            break;

        //Get CommandLine Input
        DWORD _dwErr = GetCommandInput(&argc,&pToken);
        hr = HRESULT_FROM_WIN32(_dwErr);
        if(FAILED(hr))
            break;


    
        if(argc == 1)
        {
            //
            //  Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSGET,TRUE);
            hr = E_INVALIDARG;
            break;
        }
          
          if(argc == 2)         
          {
               if(IsTokenHelpSwitch(pToken + 1))
                {
                    hr = S_OK;
                    DisplayMessage(USAGE_DSGET,TRUE);
                    break;
                }
        }

        //
        // Find which object table entry to use from
        // the second command line argument
        //
        PDSGetObjectTableEntry pObjectEntry = NULL;
        UINT idx = 0;
        PWSTR pszObjectType = (pToken+1)->GetToken();
        while (true)
        {
            pObjectEntry = g_DSObjectTable[idx++];
            if (!pObjectEntry)
            {
                break;
            }
            //Security Review:Both are null terminated.
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
                break;
            }
        }

        if (!pObjectEntry)
        {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSGET);
            hr = E_INVALIDARG;
            break;
        }

        //
        // Now that we have the correct table entry, merge the command line table
        // for this object with the common commands
        //
        hr = MergeArgCommand(DSGET_COMMON_COMMANDS, 
                             pObjectEntry->pParserTable, 
                             &pNewCommandArgs);
        if (FAILED(hr))
            break;
        

        //
        //Parse the Input
        //
        PARSE_ERROR Error;
        if(!ParseCmd(g_pszDSCommandName,
                     pNewCommandArgs,
                     argc-1, 
                     pToken+1,
                     pObjectEntry->nUsageID, 
                     &Error,
                     TRUE))
        {
            //ParseCmd did not display any error. Error should
            //be handled here. Check DisplayParseError for the
            //cases where Error is not shown by ParseCmd
            if(!Error.MessageShown)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                break;
            }
            
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                break;            
            }

            hr = E_INVALIDARG;
            break;
        }

         //
         // Check to see if we are doing debug spew
         //
#ifdef DBG
         bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                           pNewCommandArgs[eCommDebug].nValue;
         if (bDebugging)
         {
            ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
         }
#else
         DISABLE_DEBUG_OUTPUT();
#endif
        //
        // Do extra validation like switch dependency check etc.
        //
        BOOL bErrorShown = FALSE;
        hr = DoGetValidation(pNewCommandArgs,
                             pObjectEntry,
                             bErrorShown);
        if (FAILED(hr))
        {
            if (!bErrorShown)
            {
               DisplayErrorMessage(g_pszDSCommandName, 0, hr);
            }
            break;
        }

        //
        // Command line parsing succeeded
        //
        hr = DoGet(pNewCommandArgs, 
                   pObjectEntry);
        if(FAILED(hr))
            break;
         

    } while (false);    //False Loop

    //
    //Do the CleanUp
    //

    //
    // Free the memory associated with the command values
    //
    if (pNewCommandArgs)
    {
      FreeCmd(pNewCommandArgs);
    }

    //
    // Free the tokens
    //
    if (pToken)
    {
        delete[] pToken;
        pToken = 0;
    }
   

    //
    //Display Failure or Success Message
    //
    // NTRAID#NTBUG9-717576-2002/10/10-JeffJon
    // don't show the success message when displaying members 
    // of a group or memberof
   
    if(SUCCEEDED(hr) && !bDontDisplaySuccess)
    {
        DisplaySuccessMessage(g_pszDSCommandName,
                              NULL);
    }

    //
    // Uninitialize COM
    //
    CoUninitialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoGetValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both present, and other validations which cannot be done by parser.
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be queryied
//              [bErrorShown - OUT] : this is set to true if the error is
//                                    displayed within this function
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    13-Oct-2000   JeffJon  Created
//              15-Jan-2002   JeffJon  Added the bErrorShown out parameter
//                                     and a special error message for server/domain
//
//---------------------------------------------------------------------------
HRESULT DoGetValidation(IN PARG_RECORD pCommandArgs,
                        IN PDSGetObjectTableEntry pObjectEntry,
                        OUT BOOL& bErrorShown)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoGetValidation, hr);

   do // false loop
   {
      if (!pCommandArgs || 
          !pObjectEntry)
      {
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      // Check to be sure the server and domain switches
      // are mutually exclusive

      if (pCommandArgs[eCommServer].bDefined &&
          pCommandArgs[eCommDomain].bDefined)
      {
         hr = E_INVALIDARG;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr, IDS_NO_SERVER_AND_DOMAIN);
         bErrorShown = TRUE;
         break;
      }

      //
      // Check the object type specific switches
      //
      PWSTR pszObjectType = NULL;
      if (!pCommandArgs[eCommObjectType].bDefined &&
          !pCommandArgs[eCommObjectType].strValue)
      {
         hr = E_INVALIDARG;
         break;
      }

      pszObjectType = pCommandArgs[eCommObjectType].strValue;

      UINT nMemberOfIdx = 0;
      UINT nExpandIdx = 0;
      UINT nIdxLast = 0;
      UINT nMembersIdx = 0;
      bool bMembersDefined = false;
      bool bMemberOfDefined = false;
      UINT nPartIdx = 0;
      bool bServerPartDefined = false;
      bool bPartitionTopObjDefined = false;
      bool bServerTopObjDefined = false;

      //Security Review:Both are null terminated.
      if (0 == _wcsicmp(g_pszUser, pszObjectType) )
      {
         nMemberOfIdx = eUserMemberOf;
         nExpandIdx = eUserExpand;
         nIdxLast = eUserLast;

         if (pCommandArgs[eUserMemberOf].bDefined)
         {
            bMemberOfDefined = true;
         }
         //
         // If nothing is defined, then define DN, SAMAccountName, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eUserLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eUserSamID].bDefined = TRUE;
            pCommandArgs[eUserSamID].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }

         if (pCommandArgs[eUserManager].bDefined)
         {
            bDontDisplaySuccess = true;
         }
      }
      //Security Review:Both are null terminated.
      else if (0 == _wcsicmp(g_pszComputer, pszObjectType) )
      {
         nMemberOfIdx = eComputerMemberOf;
         nExpandIdx = eComputerExpand;
         nIdxLast = eComputerLast;

         if (pCommandArgs[eComputerMemberOf].bDefined)
         {
            bMemberOfDefined = true;
         }

         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eComputerLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      // Both are null terminated.
      else if (0 == _wcsicmp(g_pszPartition, pszObjectType) )
      {
          if (pCommandArgs[ePartitionTopObjOwner].bDefined)
          {
            nPartIdx = ePartitionTopObjOwner;
            nIdxLast = ePartitionLast;
            bPartitionTopObjDefined = true;
          }
      }
      // Both are null terminated.
      else if (0 == _wcsicmp(g_pszServer, pszObjectType) )
      {
          if (pCommandArgs[eServerPart].bDefined)
          {
              nPartIdx = eServerPart;
              nIdxLast = eServerLast;
              bServerPartDefined = true;
          }
          else if(pCommandArgs[eServerTopObjOwner].bDefined)
          {
              nPartIdx = eServerTopObjOwner;
              nIdxLast = eServerLast;
              bServerTopObjDefined = true;
          }
      }
      //Security Review:Both are null terminated.
      else if (0 == _wcsicmp(g_pszGroup, pszObjectType) )
      {
         nMemberOfIdx = eGroupMemberOf;
         nExpandIdx = eGroupExpand;
         nIdxLast = eGroupLast;
         nMembersIdx = eGroupMembers;

         if (pCommandArgs[eGroupMemberOf].bDefined)
         {
            bMemberOfDefined = true;
         }

         if (pCommandArgs[eGroupMembers].bDefined)
         {
            bMembersDefined = true;
         }
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eGroupLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      //Security Review:Both are null terminated.
      else if (0 == _wcsicmp(g_pszOU, pszObjectType))
      {
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eCommDescription; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      //Security Review:Both are null terminated.
      else if(0 == _wcsicmp(g_pszContact, pszObjectType))
      {
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eContactLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      //Security Review:Both are null terminated.
      else if(0 == _wcsicmp(g_pszServer, pszObjectType))
      {
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eServerLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eServerDnsName].bDefined = TRUE;
            pCommandArgs[eServerDnsName].bValue = TRUE;
         }
      }
      //Security Review:Both are null terminated.
      else if(0 == _wcsicmp(g_pszSite, pszObjectType))
      {
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eSiteLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      //Security Review:Both are null terminated.
      else if(0 == _wcsicmp(g_pszSubnet, pszObjectType))
      {
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eSubnetLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
            pCommandArgs[eSubnetSite].bDefined = TRUE;
            pCommandArgs[eSubnetSite].bValue = TRUE;
         }
      }

      //
      // if the -members or the -memberof switch is defined
      //
      if (bMemberOfDefined ||
          bMembersDefined)
      {
         // NTRAID#NTBUG9-717576-2002/10/10-JeffJon
         // set this global so that we don't show the success message
         // when displaying members of a group or memberof

         bDontDisplaySuccess = true;

         // 476206-2002/04/23-JonN
         if (bMemberOfDefined && bMembersDefined)
         {
            hr = E_INVALIDARG;
            break;
         }

         //
         // If either the -members or -memberof switch is defined,
         // no other switches may be defined
         //
         for (UINT nIdx = eCommDN; nIdx < nIdxLast; nIdx++)
         {
            // 476206-2002/04/23-JonN
            if (pCommandArgs[nIdx].bDefined &&
                  nIdx != nMemberOfIdx &&
                  nIdx != nMembersIdx &&
                  nIdx != nExpandIdx)
            {
               hr = E_INVALIDARG;
               break;
            }
         }

         //
         // MemberOf should always be seen in list view
         //
         pCommandArgs[eCommList].bDefined = TRUE;
         pCommandArgs[eCommList].bValue = TRUE;
      }
      //
      // if the [server -part], [partition -topobjowner]
      // or [server -topobjowner] switch is defined
      //
      if (bServerPartDefined || bPartitionTopObjDefined || bServerTopObjDefined)
      {
         // Server and Partition are mutually exclusive objects types so
         // the parser will ensure that these two flags can never be true
         // at the same time. The following check ensures that both values
         // weren't passed at the same time
         if (bServerPartDefined && bServerTopObjDefined)
         {
             DEBUG_OUTPUT(MINIMAL_LOGGING, 
                 L"Server -part and server -topobjowner can not be defined at the same time");
             hr = E_INVALIDARG;
             break;
         }
         // If one of these switches is defined, 
         // then no other switches may be defined
         for (UINT nIdx = eCommDN; nIdx < nIdxLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined && nIdx != nPartIdx)
            {
               hr = E_INVALIDARG;
               break;
            }
         }

         //
         // should always be seen in a list view
         //
         pCommandArgs[eCommList].bDefined = TRUE;
         pCommandArgs[eCommList].bValue = TRUE;
      }

   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoGet
//
//  Synopsis:   Does the get
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    13-Oct-2000   JeffJon  Created
//
//---------------------------------------------------------------------------
HRESULT DoGet(PARG_RECORD pCommandArgs, 
              PDSGetObjectTableEntry pObjectEntry)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoGet, hr);

   PWSTR pszPartitionDN = NULL;

   do // false loop
   {
      if (!pCommandArgs || 
          !pObjectEntry)
      {
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      //
      // The DNs or Names should be given as a \0 separated list
      // So parse it and loop through each object
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(pCommandArgs[eCommObjectDNorName].strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         //
         // Display an error message and then fail
         //
         hr = E_INVALIDARG;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr);
         break;
      }

      // Make sure all the DNs actually have DN syntax

      bool bContinue = pCommandArgs[eCommContinue].bDefined &&
                       pCommandArgs[eCommContinue].bValue;

      UINT nValidDNs = ValidateDNSyntax(ppszArray, nStrings);
      if (nValidDNs < nStrings && !bContinue)
      {
         hr = E_ADS_BAD_PATHNAME;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr);
         break;
      }

      CDSCmdCredentialObject credentialObject;
      if (pCommandArgs[eCommUserName].bDefined)
      {
         credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      if (pCommandArgs[eCommPassword].bDefined)
      {
        //Security Review:pCommandArgs[eCommPassword].strValue is encrypted.
        //Decrypt pCommandArgs[eCommPassword].strValue  and then pass it to the
        //credentialObject.SetPassword. 
        //See NTRAID#NTBUG9-571544-2000/11/13-hiteshr

        credentialObject.SetEncryptedPassword(&pCommandArgs[eCommPassword].encryptedDataBlob);
         credentialObject.SetUsingCredentials(true);
      }

      //
      // Initialize the base paths info from the command line args
      // 
      CDSCmdBasePathsInfo basePathsInfo;
      if (pCommandArgs[eCommServer].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommServer].strValue,
                                               true);
      }
      else if (pCommandArgs[eCommDomain].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommDomain].strValue,
                                               false);
      }
      else
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
      }

      if (FAILED(hr))
      {
         break;
      }

      //
      // Create the formatting object and initialize it
      //
      CFormatInfo formatInfo;
      hr = formatInfo.Initialize(nStrings, 
                                 pCommandArgs[eCommList].bDefined != 0,
                                 pCommandArgs[eCommQuiet].bDefined != 0);
      if (FAILED(hr))
      {
         break;
      }

      //
      // Loop through each of the objects
      //
      for (UINT nNameIdx = 0; nNameIdx < nStrings; nNameIdx++)
      {
         //
         // Use a false do loop here so that we can break on an
         // error but still have the chance to determine if we
         // should continue the for loop if the -c option was provided
         //
         bool fDisplayedMessage = false; // 662519-2002/07/11-JonN double-display
         do // false loop
         {

            PWSTR pszObjectDN = ppszArray[nNameIdx];
            if (!pszObjectDN)
            {
               //
               // Display an error message and then fail
               //
               hr = E_INVALIDARG;
               break;
            }

            // If partition object then look at first DN and then munge it
            if(0 == lstrcmpi(pObjectEntry->pszCommandLineObjectType, g_pszPartition))
            {                
                // Validate the partition and get the DN to the NTDS Quotas Container
                hr = GetQuotaContainerDN(basePathsInfo, credentialObject, 
                        pszObjectDN, &pszPartitionDN);

                if(FAILED(hr))
                {
                    hr = E_INVALIDARG;
                    DisplayErrorMessage(g_pszDSCommandName, 
                                        NULL,
                                        hr,
                                        IDS_ERRMSG_NO_QUOTAS_CONTAINER);
                    fDisplayedMessage = true;
                    break;
                }

                // Replace the object pointer with the new partition container DN
                pszObjectDN = pszPartitionDN;            
            }

            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Object DN = %s", pszObjectDN);

            CComBSTR sbstrObjectPath;
            basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);

            CComPtr<IDirectoryObject> spObject;
            hr = DSCmdOpenObject(credentialObject,
                                 sbstrObjectPath,
                                 IID_IDirectoryObject,
                                 (void**)&spObject,
                                 true);
            if(FAILED(hr))
            {
               break;
            }

            // 602981-2002/04/25-JonN check object class
            CComQIPtr<IADs> spADs(spObject);
            if (!spADs)
            {
               ASSERT(spADs);
               hr = E_INVALIDARG;
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               fDisplayedMessage = true; // 662519-2002/07/11-JonN double-display
               break;
            }
            CComBSTR sbstrClass;
            hr = spADs->get_Class( &sbstrClass );
            if (FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING,
                            L"get_Class failed: hr = 0x%x",
                            hr);
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               fDisplayedMessage = true; // 662519-2002/07/11-JonN double-display
               break;
            }
            if (_wcsicmp(sbstrClass, pObjectEntry->pszObjectClass)
                && ( _wcsicmp(pObjectEntry->pszObjectClass,L"user")
                  || _wcsicmp(sbstrClass,L"inetorgperson"))
                // 662519-2002/07/11-JonN fix OU bug
                && ( _wcsicmp(pObjectEntry->pszObjectClass,L"ou")
                  || _wcsicmp(sbstrClass,L"organizationalUnit"))
               )
            {
               //
               // Display error message and return
               //
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Command line type does not match object class");
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"command line type = %s", pCommandArgs[eCommObjectType].strValue);
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"object class = %s", sbstrClass);

               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr,
                                   IDS_ERRMSG_CLASS_NOT_EQUAL);
               hr = E_INVALIDARG;
               fDisplayedMessage = true; // 662519-2002/07/11-JonN double-display
               break;
            }
 
            //
            //Get the attributes to fetch
            //
            LPWSTR *ppszAttributes = NULL;
            DWORD dwCountAttr = 0;
            hr = GetAttributesToFetch(pCommandArgs,
                                      pObjectEntry,
                                      &ppszAttributes,
                                      &dwCountAttr);
            if (FAILED(hr))
            {
               break;
            }

            DEBUG_OUTPUT(MINIMAL_LOGGING, 
                         L"Calling GetObjectAttributes for %d attributes.",
                         dwCountAttr);

            DWORD dwAttrsReturned = 0;
            PADS_ATTR_INFO pAttrInfo = NULL;
            if(dwCountAttr > 0)
            {
                hr = spObject->GetObjectAttributes(ppszAttributes, 
                                                dwCountAttr, 
                                                &pAttrInfo, 
                                                &dwAttrsReturned);
                if(FAILED(hr))
                {
                DEBUG_OUTPUT(MINIMAL_LOGGING,
                                L"GetObjectAttributes failed: hr = 0x%x",
                                hr);
                FreeAttributesToFetch(ppszAttributes,dwCountAttr);
                break;
                }        
                DEBUG_OUTPUT(LEVEL5_LOGGING,
                            L"GetObjectAttributes succeeded: dwAttrsReturned = %d",
                            dwAttrsReturned);
            }
            //
            // NOTE: there may be other items to display that are not
            //       part of the attributes fetched
            //
            /*
            if (dwAttrsReturned == 0 || !pAttrInfo)
            {
               break;
            }
            */
            //
            // Output the result of search   
            //
            hr = DsGetOutputValuesList(pszObjectDN,
                                       basePathsInfo,
                                       credentialObject,
                                       pCommandArgs,
                                       pObjectEntry,
                                       dwAttrsReturned,
                                       pAttrInfo,
                                       spObject,
                                       formatInfo); 
         } while (false);

         //
         // If there was a failure and the -c (continue) flag wasn't given
         // then stop processing names
         //
         if (FAILED(hr))
         {
             if (!fDisplayedMessage) // 662519-2002/07/11-JonN double-display
             {
                DisplayErrorMessage(g_pszDSCommandName, 0, hr);
             }
             if (!pCommandArgs[eCommContinue].bDefined)
             {
                 break;
             }
         }

         // If we alloc'd a partition DN, then free it
         if(pszPartitionDN)
         {
             LocalFree(pszPartitionDN);
             pszPartitionDN = NULL;
         }
      } // Names for loop

      //
      // Now display the results
      //
      formatInfo.Display();

   } while (false);

    // If we alloc'd a partition DN, then free it
    if(pszPartitionDN)
    {
        LocalFree(pszPartitionDN);
        pszPartitionDN = NULL;
    }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetAttributesToFetch
//
//  Synopsis:   Make an array of attributes to fetch.
//  Arguments:  [ppszAttributes - OUT] : array of attributes to fetch
//              [pCount - OUT] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetAttributesToFetch(IN PARG_RECORD pCommandArgs,
                             IN PDSGetObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount)
{
   ENTER_FUNCTION_HR(LEVEL8_LOGGING, GetAttributesToFetch, hr);

   do // false loop
   {

      if(!pCommandArgs || 
         !pObjectEntry)
      {   
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      LPWSTR *ppszAttr = (LPWSTR *)LocalAlloc(LPTR,pObjectEntry->dwAttributeCount *sizeof(LPCTSTR));
      if(!ppszAttr)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Loop through the attributes that are needed and copy
      // them into the array.
      //
      // REVIEW_JEFFON : what if there are duplicates?
      //
      DEBUG_OUTPUT(FULL_LOGGING, L"Adding attributes to list:");

      DWORD dwAttrCount = 0;
      for(DWORD i = 0; i < pObjectEntry->dwAttributeCount; i++)
      {
         if (pObjectEntry->pAttributeTable[i])
         {
            UINT nCommandEntry = pObjectEntry->pAttributeTable[i]->nAttributeID;
            if (pCommandArgs[nCommandEntry].bDefined)
            {
               LPWSTR pszAttr = pObjectEntry->pAttributeTable[i]->pszName;
               if (pszAttr)
               {
                  // 702724 ronmart 2002/09/18 If looking for top 
                  // object owner then specify a range
                  if(0 == lstrcmpi(pObjectEntry->pszCommandLineObjectType, g_pszPartition) 
                      && pCommandArgs[ePartitionTopObjOwner].bDefined)
                  {
                    hr =  SetRange(pszAttr, pCommandArgs[ePartitionTopObjOwner].nValue,
                                    ppszAttr+dwAttrCount);
                  }
                  else if(0 == lstrcmpi(pObjectEntry->pszCommandLineObjectType, g_pszServer) 
                      && pCommandArgs[eServerTopObjOwner].bDefined)
                  {
                    hr =  SetRange(pszAttr, pCommandArgs[eServerTopObjOwner].nValue,
                                    ppszAttr+dwAttrCount);
                  }
                  // NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit -qused 
                  //                                         not returning values 
                  // These do not appear on the user object so GetObjectAttributes 
                  // will fail if these are included in the fetch array
                  else if(0 == lstrcmpi(pszAttr,g_pszAttrmsDSQuotaEffective) ||
                          0 == lstrcmpi(pszAttr,g_pszAttrmsDSQuotaUsed))
                  {
                      continue; // ignore
                  }
                  else
                  {
                    hr = LocalCopyString(ppszAttr+dwAttrCount, pszAttr);
                  }
                  if (FAILED(hr))
                  {
                     LocalFree(ppszAttr);
                     hr = E_OUTOFMEMORY;
                     break;
                  }
                  // 702724 ronmart 2002/09/18 Use the array value that has
                  // be created (and possibly modified to include the range)
                  // rather than the attribute name when spewing attrs
                  DEBUG_OUTPUT(FULL_LOGGING, L"\t%s", *(ppszAttr+dwAttrCount));
                  dwAttrCount++;
               }
            }
         }
      }

      if (SUCCEEDED(hr))
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Done adding %d attributes to list.", dwAttrCount);
      }

      *ppszAttributes = ppszAttr;
      *pCount = dwAttrCount;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   FreeAttributesToFetch
//
//  Synopsis:   Function to free memory allocated by GetAttributesToFetch
//  Arguments:  [dwszAttributes - in] : array of attributes to fetch
//              [dwCount - in] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount)
{
    while(dwCount)
    {
        LocalFree(ppszAttributes[--dwCount]);
    }
    LocalFree(ppszAttributes);
}

//+--------------------------------------------------------------------------
//
//  Function:   SetRange
//
//  Synopsis:   Set's the range qualifier for an attribute
//  Arguments:  [pszAttrName - IN]  : attribute name to append the range to
//              [dwRangeUBound - IN]: one based upper bound of the range 
//              [pszAttrs - OUT]    : attr array entry that should be allocated
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    18-Sep-2002   ronmart Created for 702724 fix
//
//---------------------------------------------------------------------------
HRESULT SetRange(IN  LPCWSTR pszAttrName, 
                 IN  DWORD   dwRangeUBound, 
                 OUT LPWSTR* pszAttrs)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, SetRange, hr);

    do // false loop
    {
        // Validate params
        if(!pszAttrName ||
           !pszAttrs )
        {
            hr = E_INVALIDARG;
            break;
        }

        // Get the size of the base attribute name
        size_t cbSize = lstrlen(pszAttrName);
        if(cbSize == 0)
            break;
        cbSize += 64; // leave room for null term, range string and int value
        cbSize *= sizeof(WCHAR);

        // Allocate the  buffer to hold the range
        *pszAttrs = (LPWSTR) LocalAlloc(LPTR, cbSize);
        if(NULL == *pszAttrs)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // If zero then show all
        if(dwRangeUBound == 0)
        {
            hr = StringCbPrintf(*pszAttrs, cbSize, L"%s%s=0-*", pszAttrName, g_pszRange);
        }
        // Otherwise show the value specified
        else 
        {
            hr = StringCbPrintf(*pszAttrs, cbSize, L"%s%s=0-%d", 
                pszAttrName,        // Name of the attribute to append the range to
                g_pszRange,         // The range qualifer ;range
                dwRangeUBound - 1); // Range is 0 based, and input is 1 based so adjust
        }

        if(FAILED(hr))
            break;

    } while(false);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\gettable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      gettable.cpp
//
//  Contents:  Defines Table DSGet
//
//  History:   13-Oct-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "gettable.h"
#include "display.h"
#include "usage.h"

//+--------------------------------------------------------------------------
//
//  Member:     CDSGetDisplayInfo::AddValue
//
//  Synopsis:   Adds a value to the value array and allocates more space
//              if necessary.
//
//  Arguments:  [pszValue IN] : new value to be added
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                        S_OK if we succeeded in setting the password
//
//  History:    23-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSGetDisplayInfo::AddValue(PCWSTR pszValue)
{
   ENTER_FUNCTION_HR(LEVEL8_LOGGING, CDSGetDisplayInfo::AddValue, hr);
   
   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszValue)
      {
         ASSERT(pszValue);
         hr = E_INVALIDARG;
         break;
      }

      if (m_dwAttributeValueCount == m_dwAttributeValueSize)
      {
         DWORD dwNewSize = m_dwAttributeValueSize + 5;

         //
         // Allocate a new array with more space
         //
         PWSTR* ppszNewArray = new PWSTR[dwNewSize];
         if (!ppszNewArray)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         m_dwAttributeValueSize = dwNewSize;

         //
         // Copy the old values
         //
		 //Security Review:This is fine.
         memcpy(ppszNewArray, m_ppszAttributeStringValue, m_dwAttributeValueCount * sizeof(PWSTR));

         //
         // Delete the old array
         //
         if (m_ppszAttributeStringValue)
         {
            delete[] m_ppszAttributeStringValue;
         }
         m_ppszAttributeStringValue = ppszNewArray;
      }

      //
      // Add the new value to the end of the array
      //
	  m_ppszAttributeStringValue[m_dwAttributeValueCount] = new WCHAR[wcslen(pszValue) + 1];
      if (!m_ppszAttributeStringValue[m_dwAttributeValueCount])
      {
         hr = E_OUTOFMEMORY;
         break;
      }

	  //Buffer is allocated correctly.
      wcscpy(m_ppszAttributeStringValue[m_dwAttributeValueCount], pszValue);
      m_dwAttributeValueCount++;

   } while (false);

   return hr;
}

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSGET_COMMON_COMMANDS[] = 
{

   COMMON_COMMANDS

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,  
   0,    
   0,  NULL,

   //
   // c  Continue
   //
   0,(PWSTR)c_sz_arg1_com_continue,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0, NULL,

   //
   // l  List
   //
   0,(LPWSTR)c_sz_arg1_com_listformat, 
   0,NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,    
   0,  NULL,

   //
   // dn
   //
   0, (PWSTR)g_pszArg1UserDN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // description
   //
   0, (PWSTR)c_sz_arg1_com_description,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   ARG_TERMINATOR

};


ARG_RECORD DSGET_USER_COMMANDS[]=
{
   //
   // SamID
   //
   0, (PWSTR)g_pszArg1UserSAMID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // sid
   //
   0, (PWSTR)g_pszArg1UserSID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // upn
   //
   0, (PWSTR)g_pszArg1UserUPN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // empid   Employee ID
   //
   0, (PWSTR)g_pszArg1UserEmployeeID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // iptel  IP phone#
   //
   0, (PWSTR)g_pszArg1UserIPTel,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // webpg  Web Page
   //
   0, (PWSTR)g_pszArg1UserWebPage,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mgr  Manager
   //
   0, (PWSTR)g_pszArg1UserManager,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // hmdir  Home Directory
   //
   0, (PWSTR)g_pszArg1UserHomeDirectory,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // hmdrv  Home Drive
   //
   0, (PWSTR)g_pszArg1UserHomeDrive,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // profile  Profile
   //
   0, (PWSTR)g_pszArg1UserProfile,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // loscr  Logon Script
   //
   0, (PWSTR)g_pszArg1UserLogonScript,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // mustchpwd Must Change Password at next logon
   //
   0, (PWSTR)g_pszArg1UserMustChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // canchpwd Can Change Password
   //
   0, (PWSTR)g_pszArg1UserCanChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,
   
   //
   // pwdneverexpires Password never expires
   //
   0, (PWSTR)g_pszArg1UserPwdNeverExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,
 
   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1UserDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // acctexpires  Account Expires
   //
   0, (PWSTR)g_pszArg1UserAcctExpires,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // reversiblepwd  Password stored with reversible encryption
   //
   0, (PWSTR)g_pszArg1UserReversiblePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // memberof  Member of group
   //
   0, (PWSTR)g_pszArg1UserMemberOf, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // expand  Recursively expand group membership
   //
   0, (PWSTR)g_pszArg1UserExpand, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // part
   //
   0, (PWSTR)g_pszArg1UserPart, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // qlimit
   //
   0, (PWSTR)g_pszArg1UserQLimit, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // qUsed
   //
   0, (PWSTR)g_pszArg1UserQuotaUsed, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSGET_COMPUTER_COMMANDS[]=
{
   //
   // SamID
   //
   0, (PWSTR)g_pszArg1ComputerSAMID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // sid
   //
   0, (PWSTR)g_pszArg1ComputerSID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // loc
   //
   0, (PWSTR)g_pszArg1ComputerLoc,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1ComputerDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // memberof  Member of group
   //
   0, (PWSTR)g_pszArg1ComputerMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // expand   Recursively expand group membership
   //
   0, (PWSTR)g_pszArg1ComputerExpand,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0,  NULL,

   //
   // part
   //
   0, (PWSTR)g_pszArg1ComputerPart, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // qlimit
   //
   0, (PWSTR)g_pszArg1ComputerQLimit, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // qUsed
   //
   0, (PWSTR)g_pszArg1ComputerQuotaUsed, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSGET_GROUP_COMMANDS[]=
{
   //
   // samname
   //
   0, (PWSTR)g_pszArg1GroupSamid,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // sid
   //
   0, (PWSTR)g_pszArg1GroupSID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // secgrp Security enabled
   //
   0, (PWSTR)g_pszArg1GroupSecGrp,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // scope Group scope (local/global/universal)
   //
   0, (PWSTR)g_pszArg1GroupScope,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // memberof  Member of groups
   //
   0, (PWSTR)g_pszArg1GroupMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // members  Contains members
   //
   0, (PWSTR)g_pszArg1GroupMembers,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // expand   Recursively expand group membership
   //
   0, (PWSTR)g_pszArg1GroupExpand,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // part
   //
   0, (PWSTR)g_pszArg1GroupPart, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // qlimit
   //
   0, (PWSTR)g_pszArg1GroupQLimit, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // qUsed
   //
   0, (PWSTR)g_pszArg1GroupQuotaUsed, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};


ARG_RECORD DSGET_CONTACT_COMMANDS[]=
{
   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // iptel  IP phone#
   //
   0, (PWSTR)g_pszArg1UserIPTel,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};


ARG_RECORD DSGET_SERVER_COMMANDS[]=
{
   //
   // dnsname dnsHostName
   //
   0, (PWSTR)g_pszArg1ServerDnsName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // site 
   //
   0, (PWSTR)g_pszArg1ServerSite, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // isGC
   //
   0, (PWSTR)g_pszArg1ServerIsGC, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // part
   //
   0, (PWSTR)g_pszArg1ServerPart, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // topobjowner
   //
   0, (PWSTR)g_pszArg1ServerTopObjOwner, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL | ARG_FLAG_DEFAULTABLE,  
   (void*) 10, // default nValue is 10 if not specified 
   0,  NULL,


   ARG_TERMINATOR,
};

ARG_RECORD DSGET_SITE_COMMANDS[]=
{
   //
   // dnsname dnsHostName
   //
   0, (PWSTR)g_pszArg1SiteAutotopology, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // site 
   //
   0, (PWSTR)g_pszArg1SiteCacheGroups, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // isGC
   //
   0, (PWSTR)g_pszArg1SitePrefGCSite, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSGET_SUBNET_COMMANDS[]=
{
   //
   // loc Location
   //
   0, (PWSTR)g_pszArg1SubnetLocation, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // site 
   //
   0, (PWSTR)g_pszArg1SubnetSite, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};


ARG_RECORD DSGET_PARTITION_COMMANDS[]=
{
   //
   // qdefault
   //
   0, (PWSTR)g_pszArg1PartitionQDefault, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // qmbstnwt
   //
   0, (PWSTR)g_pszArg1PartitionQTombstoneWeight, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // topobjowner
   //
   0, (PWSTR)g_pszArg1PartitionTopObjOwner, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL | ARG_FLAG_DEFAULTABLE,  
   (void*) 10, // default nValue is 10 if not specified    
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSGET_QUOTA_COMMANDS[]=
{
   //
   // acct
   //
   0, (PWSTR)g_pszArg1QuotaAcct, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // qlimit
   //
   0, (PWSTR)g_pszArg1QuotaQLimit, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};

//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------

//
// User Quota Entries
//
DSGET_ATTR_TABLE_ENTRY qlimitUserEntry =
{
   g_pszArg1UserQLimit,
   (PWSTR)g_pszAttrmsDSQuotaEffective,
   eUserQLimit,
   0,
   DisplayQuotaInfoFunc
};

DSGET_ATTR_TABLE_ENTRY quotaUsedUserEntry =
{
   g_pszArg1UserQuotaUsed,
   (PWSTR)g_pszAttrmsDSQuotaUsed,
   eUserQuotaUsed,
   0,
   DisplayQuotaInfoFunc
};

//
// Group Quota Entries
//
DSGET_ATTR_TABLE_ENTRY qlimitGroupEntry =
{
   g_pszArg1GroupQLimit,
   (PWSTR)g_pszAttrmsDSQuotaEffective,
   eGroupQLimit,
   0,
   DisplayQuotaInfoFunc
};

DSGET_ATTR_TABLE_ENTRY quotaUsedGroupEntry =
{
   g_pszArg1GroupQuotaUsed,
   (PWSTR)g_pszAttrmsDSQuotaUsed,
   eGroupQuotaUsed,
   0,
   DisplayQuotaInfoFunc
};

//
// Description
//
DSGET_ATTR_TABLE_ENTRY descriptionEntry =
{
   c_sz_arg1_com_description,
   L"description",
   eCommDescription,
   0,
   CommonDisplayStringFunc,   
};

//
// SamID
//
DSGET_ATTR_TABLE_ENTRY UserSAMEntry =
{
   g_pszArg1UserSAMID,
   L"sAMAccountName",
   eUserSamID,
   0,
   CommonDisplayStringFunc,
};

//
// SamID
//
DSGET_ATTR_TABLE_ENTRY ComputerSAMEntry =
{
   g_pszArg1ComputerSAMID,
   L"sAMAccountName",
   eComputerSamID,
   0,
   CommonDisplayStringFunc,
};

//
// SID
//
DSGET_ATTR_TABLE_ENTRY UserSIDEntry =
{
   g_pszArg1UserSID,
   L"objectSID",
   eUserSID,
   0,
   CommonDisplayStringFunc,
};

//
// SID
//
DSGET_ATTR_TABLE_ENTRY ComputerSIDEntry =
{
   g_pszArg1ComputerSID,
   L"objectSID",
   eComputerSID,
   0,
   CommonDisplayStringFunc,
};

//
// SID
//
DSGET_ATTR_TABLE_ENTRY GroupSIDEntry =
{
   g_pszArg1GroupSID,
   L"objectSID",
   eGroupSID,
   0,
   CommonDisplayStringFunc,
};

//
// UPN
//
DSGET_ATTR_TABLE_ENTRY UserUPNEntry =
{
   g_pszArg1UserUPN,
   L"userPrincipalName",
   eUserUpn,
   0,
   CommonDisplayStringFunc,
};


//
// First name
//
DSGET_ATTR_TABLE_ENTRY firstNameUserEntry =
{
   g_pszArg1UserFirstName,
   L"givenName",
   eUserFn,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY firstNameContactEntry =
{
   g_pszArg1UserFirstName,
   L"givenName",
   eContactFn,
   0,
   CommonDisplayStringFunc,
};

//
// Middle Initial
//
DSGET_ATTR_TABLE_ENTRY middleInitialUserEntry =
{
   g_pszArg1UserMiddleInitial,
   L"initials",
   eUserMi,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY middleInitialContactEntry =
{
   g_pszArg1UserMiddleInitial,
   L"initials",
   eContactMi,
   0,
   CommonDisplayStringFunc,
};

//
// Last name
//
DSGET_ATTR_TABLE_ENTRY lastNameUserEntry =
{
   g_pszArg1UserLastName,
   L"sn",
   eUserLn,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY lastNameContactEntry =
{
   g_pszArg1UserLastName,
   L"sn",
   eContactLn,
   0,
   CommonDisplayStringFunc,
};

//
// Display name
//
DSGET_ATTR_TABLE_ENTRY displayNameUserEntry =
{
   g_pszArg1UserDisplayName,
   L"displayName",
   eUserDisplay,
   0,
   CommonDisplayStringFunc,
};

//
// Employee ID
//
DSGET_ATTR_TABLE_ENTRY employeeIDUserEntry =
{
   g_pszArg1UserEmployeeID,
   L"employeeID",
   eUserEmpID,
   0,
   CommonDisplayStringFunc,
};



DSGET_ATTR_TABLE_ENTRY displayNameContactEntry =
{
   g_pszArg1UserDisplayName,
   L"displayName",
   eContactDisplay,
   0,
   CommonDisplayStringFunc,
};

//
// Office
//
DSGET_ATTR_TABLE_ENTRY officeUserEntry =
{
   g_pszArg1UserOffice,
   L"physicalDeliveryOfficeName",
   eUserOffice,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY officeContactEntry =
{
   g_pszArg1UserOffice,
   L"physicalDeliveryOfficeName",
   eContactOffice,
   0,
   CommonDisplayStringFunc,
};

//
// Telephone
//
DSGET_ATTR_TABLE_ENTRY telephoneUserEntry =
{
   g_pszArg1UserTelephone,
   L"telephoneNumber",
   eUserTel,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY telephoneContactEntry =
{
   g_pszArg1UserTelephone,
   L"telephoneNumber",
   eContactTel,
   0,
   CommonDisplayStringFunc,
};

//
// Email
//
DSGET_ATTR_TABLE_ENTRY emailUserEntry =
{
   g_pszArg1UserEmail,
   L"mail",
   eUserEmail,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY emailContactEntry =
{
   g_pszArg1UserEmail,
   L"mail",
   eContactEmail,
   0,
   CommonDisplayStringFunc,
};

//
// Home Telephone
//
DSGET_ATTR_TABLE_ENTRY homeTelephoneUserEntry =
{
   g_pszArg1UserHomeTelephone,
   L"homePhone",
   eUserHometel,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY homeTelephoneContactEntry =
{
   g_pszArg1UserHomeTelephone,
   L"homePhone",
   eContactHometel,
   0,
   CommonDisplayStringFunc,
};

//
// Pager
//
DSGET_ATTR_TABLE_ENTRY pagerUserEntry =
{
   g_pszArg1UserPagerNumber,
   L"pager",
   eUserPager,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY pagerContactEntry =
{
   g_pszArg1UserPagerNumber,
   L"pager",
   eContactPager,
   0,
   CommonDisplayStringFunc,
};

//
// Mobile phone
//
DSGET_ATTR_TABLE_ENTRY mobileUserEntry =
{
   g_pszArg1UserMobileNumber,
   L"mobile",
   eUserMobile,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY mobileContactEntry =
{
   g_pszArg1UserMobileNumber,
   L"mobile",
   eContactMobile,
   0,
   CommonDisplayStringFunc,
};

//
// Fax
//
DSGET_ATTR_TABLE_ENTRY faxUserEntry =
{
   g_pszArg1UserFaxNumber,
   L"facsimileTelephoneNumber",
   eUserFax,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY faxContactEntry =
{
   g_pszArg1UserFaxNumber,
   L"facsimileTelephoneNumber",
   eContactFax,
   0,
   CommonDisplayStringFunc,
};

//
// IP phone #
//
DSGET_ATTR_TABLE_ENTRY ipPhoneUserEntry =
{
   g_pszArg1UserIPTel,
   L"ipPhone",
   eUserIPTel,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY ipPhoneContactEntry =
{
   g_pszArg1UserIPTel,
   L"ipPhone",
   eContactIPTel,
   0,
   CommonDisplayStringFunc,
};

//
// Web Page
//
DSGET_ATTR_TABLE_ENTRY webPageUserEntry =
{
   g_pszArg1UserWebPage,
   L"wWWHomePage",
   eUserWebPage,
   0,
   CommonDisplayStringFunc,
};


//
// Title
//
DSGET_ATTR_TABLE_ENTRY titleUserEntry =
{
   g_pszArg1UserTitle,
   L"title",
   eUserTitle,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY titleContactEntry =
{
   g_pszArg1UserTitle,
   L"title",
   eContactTitle,
   0,
   CommonDisplayStringFunc,
};

//
// Department
//
DSGET_ATTR_TABLE_ENTRY departmentUserEntry =
{
   g_pszArg1UserDepartment,
   L"department",
   eUserDept,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY departmentContactEntry =
{
   g_pszArg1UserDepartment,
   L"department",
   eContactDept,
   0,
   CommonDisplayStringFunc,
};

//
// Company
//
DSGET_ATTR_TABLE_ENTRY companyUserEntry =
{
   g_pszArg1UserCompany,
   L"company",
   eUserCompany,
   0,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY companyContactEntry =
{
   g_pszArg1UserCompany,
   L"company",
   eContactCompany,
   0,
   CommonDisplayStringFunc,
};

//
// Manager
//
DSGET_ATTR_TABLE_ENTRY managerUserEntry =
{
   g_pszArg1UserManager,
   L"manager",
   eUserManager,
   DSGET_OUTPUT_DN_FLAG,
   CommonDisplayStringFunc,
};

//
// Home directory
//
DSGET_ATTR_TABLE_ENTRY homeDirectoryUserEntry =
{
   g_pszArg1UserHomeDirectory,
   L"homeDirectory",
   eUserHomeDirectory,
   0,
   CommonDisplayStringFunc,
};

//
// Home drive
//
DSGET_ATTR_TABLE_ENTRY homeDriveUserEntry =
{
   g_pszArg1UserHomeDrive,
   L"homeDrive",
   eUserHomeDrive,
   0,
   CommonDisplayStringFunc,
};

//
// Profile path
//
DSGET_ATTR_TABLE_ENTRY profilePathUserEntry =
{
   g_pszArg1UserProfile,
   L"profilePath",
   eUserProfilePath,
   0,
   CommonDisplayStringFunc,
};

//
// Logon script
//
DSGET_ATTR_TABLE_ENTRY logonScriptUserEntry =
{
   g_pszArg1UserLogonScript,
   L"scriptPath",
   eUserLogonScript,
   0,
   CommonDisplayStringFunc,
};

//
// pwdLastSet
//
DSGET_ATTR_TABLE_ENTRY mustChangePwdUserEntry =
{
   g_pszArg1UserMustChangePwd,
   L"pwdLastSet",
   eUserMustchpwd,
   0,
   DisplayMustChangePassword, 
};

//
// user account control 
//
DSGET_ATTR_TABLE_ENTRY disableUserEntry =
{
   g_pszArg1UserDisableAccount,
   L"userAccountControl",
   eUserDisabled,
   0,
   DisplayAccountDisabled
};

DSGET_ATTR_TABLE_ENTRY disableComputerEntry =
{
   g_pszArg1ComputerDisableAccount,
   L"userAccountControl",
   eComputerDisabled,
   0,
   DisplayAccountDisabled
};

DSGET_ATTR_TABLE_ENTRY pwdNeverExpiresUserEntry =
{
   g_pszArg1UserPwdNeverExpires,
   L"userAccountControl",
   eUserPwdneverexpires,
   0,
   DisplayPasswordNeverExpires
};

DSGET_ATTR_TABLE_ENTRY reverisblePwdUserEntry =
{
   g_pszArg1UserReversiblePwd,
   L"userAccountControl",
   eUserReversiblePwd,
   0,
   DisplayReversiblePassword
};

//
// Account expires
//
DSGET_ATTR_TABLE_ENTRY accountExpiresUserEntry =
{
   g_pszArg1UserAcctExpires,
   L"accountExpires",
   eUserAcctExpires,
   0,
   DisplayAccountExpires,
};

//
// SAM Account Name
//
DSGET_ATTR_TABLE_ENTRY samNameGroupEntry =
{
   g_pszArg1GroupSamid,
   L"sAMAccountName",
   eGroupSamname,
   0,
   CommonDisplayStringFunc,
};

//
// Group Type
//
DSGET_ATTR_TABLE_ENTRY groupScopeTypeEntry =
{
   g_pszArg1GroupScope,
   L"groupType",
   eGroupScope,
   0,
   DisplayGroupScope
};

DSGET_ATTR_TABLE_ENTRY groupSecurityTypeEntry =
{
   g_pszArg1GroupSecGrp,
   L"groupType",
   eGroupSecgrp,
   0,
   DisplayGroupSecurityEnabled
};

//
// Group Members
//
DSGET_ATTR_TABLE_ENTRY membersGroupEntry =
{
   g_pszArg1GroupMembers,
   L"member",
   eGroupMembers,
   DSGET_OUTPUT_DN_FLAG,
   DisplayGroupMembers
};

//
// MemberOf
//
DSGET_ATTR_TABLE_ENTRY memberOfUserEntry =
{
   L"Member of",
   L"memberOf",
   eUserMemberOf,
   DSGET_OUTPUT_DN_FLAG,
   DisplayUserMemberOf
};

DSGET_ATTR_TABLE_ENTRY memberOfComputerEntry =
{
   g_pszArg1UserMemberOf,
   L"memberOf",
   eComputerMemberOf,
   DSGET_OUTPUT_DN_FLAG,
   DisplayComputerMemberOf
};

DSGET_ATTR_TABLE_ENTRY memberOfGroupEntry =
{
   g_pszArg1GroupMemberOf,
   L"memberOf",
   eGroupMemberOf,
   DSGET_OUTPUT_DN_FLAG,
   DisplayGroupMemberOf  
};

//
// User Can Change Password
//
DSGET_ATTR_TABLE_ENTRY canChangePwdUserEntry =
{
   g_pszArg1UserCanChangePwd,
   NULL,
   eUserCanchpwd,
   0,
   DisplayCanChangePassword
};

//
// Server entries
//
DSGET_ATTR_TABLE_ENTRY dnsNameServerEntry =
{
   g_pszArg1ServerDnsName,
   L"dnsHostName",
   eServerDnsName,
   0,
   CommonDisplayStringFunc  
};

DSGET_ATTR_TABLE_ENTRY siteServerEntry =
{
   g_pszArg1ServerSite,
   NULL,
   eServerSite,
   0,
   DisplayGrandparentRDN
};

DSGET_ATTR_TABLE_ENTRY isGCServerEntry =
{
   g_pszArg1ServerIsGC,
   NULL,
   eServerIsGC,
   0,
   IsServerGCDisplay
};

DSGET_ATTR_TABLE_ENTRY topObjOwnerServerEntry =
{
   NULL,
   L"msDS-TopQuotaUsage",
   eServerTopObjOwner,
   DSGET_OUTPUT_DN_FLAG,
   DisplayTopObjOwner
};

DSGET_ATTR_TABLE_ENTRY partServerEntry =
{
   g_pszArg1ServerPart,
   NULL,
   eServerPart,
   DSGET_OUTPUT_DN_FLAG,
   DisplayPartitions
};

//
// Site entries
//
DSGET_ATTR_TABLE_ENTRY autoTopSiteEntry =
{
   g_pszArg1SiteAutotopology,
   NULL,
   eSiteAutoTop,
   0,
   IsAutotopologyEnabledSite  
};

DSGET_ATTR_TABLE_ENTRY cacheGroupsSiteEntry =
{
   g_pszArg1SiteCacheGroups,
   NULL,
   eSiteCacheGroups,
   0,
   IsCacheGroupsEnabledSite
};

DSGET_ATTR_TABLE_ENTRY prefGCSiteEntry =
{
   g_pszArg1SitePrefGCSite,
   NULL,
   eSitePrefGC,
   0,
   DisplayPreferredGC
};

// Computer entries

DSGET_ATTR_TABLE_ENTRY locComputerEntry =
{
   g_pszArg1ComputerLoc,
   L"location",
   eComputerLoc,
   0,
   CommonDisplayStringFunc
};

DSGET_ATTR_TABLE_ENTRY qlimitComputerEntry =
{
   g_pszArg1ComputerQLimit,
   (PWSTR)g_pszAttrmsDSQuotaEffective,
   eComputerQLimit,
   0,
   DisplayQuotaInfoFunc
};

DSGET_ATTR_TABLE_ENTRY quotaUsedComputerEntry =
{
   g_pszArg1ComputerQuotaUsed,
   (PWSTR)g_pszAttrmsDSQuotaUsed,
   eComputerQuotaUsed,
   0,
   DisplayQuotaInfoFunc
};


//
// Subnet entries
//
DSGET_ATTR_TABLE_ENTRY locSubnetEntry =
{
   g_pszArg1SubnetLocation,
   L"location",
   eSubnetLocation,
   0,
   CommonDisplayStringFunc
};

DSGET_ATTR_TABLE_ENTRY siteSubnetEntry =
{
   g_pszArg1SubnetSite,
   L"siteObject",
   eSubnetSite,
   0,
   DisplayObjectAttributeAsRDN
};

//
// partition entries
//
DSGET_ATTR_TABLE_ENTRY QDefaultPartitionEntry =
{
   g_pszArg1PartitionQDefault,
   L"msDS-DefaultQuota",
   ePartitionQDefault,
   0,
   CommonDisplayStringFunc
};

DSGET_ATTR_TABLE_ENTRY qTombstoneWeightPartitionEntry =
{
   g_pszArg1PartitionQTombstoneWeight,
   L"msDS-TombstoneQuotaFactor",
   ePartitionQTombstoneWeight,
   0,
   CommonDisplayStringFunc
};

DSGET_ATTR_TABLE_ENTRY topObjOwnerPartitionEntry =
{
   NULL,
   L"msDS-TopQuotaUsage",
   ePartitionTopObjOwner,
   DSGET_OUTPUT_DN_FLAG,
   DisplayTopObjOwner
};

//
// quota entries
//
DSGET_ATTR_TABLE_ENTRY acctQuotaEntry =
{
   g_pszArg1QuotaAcct,
   L"msDS-QuotaTrustee",
   eQuotaAcct,
   0,
   DisplayUserFromSidFunc
};

DSGET_ATTR_TABLE_ENTRY qlimitQuotaEntry =
{
   g_pszArg1QuotaQLimit,
   L"msDS-QuotaAmount",
   eQuotaQLimit,
   0,
   CommonDisplayStringFunc
};

//
//Attribute Table entries and ObjectTableEntries
//

//
// User
//

PDSGET_ATTR_TABLE_ENTRY UserAttributeTable[] =
{
   &descriptionEntry,
   &UserSAMEntry,
   &UserSIDEntry,
   &UserUPNEntry,
   &firstNameUserEntry,
   &middleInitialUserEntry,
   &lastNameUserEntry,
   &displayNameUserEntry,
   &employeeIDUserEntry,
   &officeUserEntry,
   &telephoneUserEntry,
   &emailUserEntry,
   &homeTelephoneUserEntry,
   &pagerUserEntry,
   &mobileUserEntry,
   &faxUserEntry,
   &ipPhoneUserEntry,
   &webPageUserEntry,
   &titleUserEntry,
   &departmentUserEntry,
   &companyUserEntry,
   &managerUserEntry,
   &homeDirectoryUserEntry,
   &homeDriveUserEntry,
   &profilePathUserEntry,
   &logonScriptUserEntry,
   &mustChangePwdUserEntry,
   &canChangePwdUserEntry,
   &reverisblePwdUserEntry,
   &pwdNeverExpiresUserEntry,
   &accountExpiresUserEntry,
   &disableUserEntry,
   &memberOfUserEntry,
   //&partUserEntry,
   &qlimitUserEntry,
   &quotaUsedUserEntry,
};

DSGetObjectTableEntry g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSGET_USER_COMMANDS,
   USAGE_DSGET_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable,
};

//
// Contact
//

PDSGET_ATTR_TABLE_ENTRY ContactAttributeTable[] =
{
   &descriptionEntry,
   &firstNameContactEntry,
   &middleInitialContactEntry,
   &lastNameContactEntry,
   &displayNameContactEntry,
   &officeContactEntry,
   &telephoneContactEntry,
   &emailContactEntry,
   &homeTelephoneContactEntry,
   &pagerContactEntry,
   &mobileContactEntry,
   &faxContactEntry,
   &ipPhoneContactEntry,
   &titleContactEntry,
   &departmentContactEntry,
   &companyContactEntry,
};

DSGetObjectTableEntry g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSGET_CONTACT_COMMANDS,
   USAGE_DSGET_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable,
};

//
// Computer
//

PDSGET_ATTR_TABLE_ENTRY ComputerAttributeTable[] =
{
   &descriptionEntry,
   &ComputerSAMEntry,
   &ComputerSIDEntry,
   &locComputerEntry,
   &disableComputerEntry,
   &memberOfComputerEntry,
   //&partComputerEntry,
   &qlimitComputerEntry,
   &quotaUsedComputerEntry,
};

DSGetObjectTableEntry g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSGET_COMPUTER_COMMANDS,
   USAGE_DSGET_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable,
};

//
// Group
//
PDSGET_ATTR_TABLE_ENTRY GroupAttributeTable[] =
{
   &descriptionEntry,
   &samNameGroupEntry,
   &GroupSIDEntry,
   &groupScopeTypeEntry,
   &groupSecurityTypeEntry,
   &memberOfGroupEntry,
   &membersGroupEntry,
   //&partGroupEntry,
   &qlimitGroupEntry,
   &quotaUsedGroupEntry,
};

DSGetObjectTableEntry g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSGET_GROUP_COMMANDS,
   USAGE_DSGET_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable,
};


//
// OU
//
PDSGET_ATTR_TABLE_ENTRY OUAttributeTable[] =
{
   &descriptionEntry
};

DSGetObjectTableEntry g_OUObjectEntry = 
{
   L"ou",
   g_pszOU,
   NULL,
   USAGE_DSGET_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable,
};


//
// Server
//
PDSGET_ATTR_TABLE_ENTRY ServerAttributeTable[] =
{
   &descriptionEntry,
   &dnsNameServerEntry,
   &siteServerEntry,
   &isGCServerEntry,
   &topObjOwnerServerEntry,
   &partServerEntry
};

DSGetObjectTableEntry g_ServerObjectEntry = 
{
   L"server",
   g_pszServer,
   DSGET_SERVER_COMMANDS,
   USAGE_DSGET_SERVER,
   sizeof(ServerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ServerAttributeTable,
};

//
// Site
//
PDSGET_ATTR_TABLE_ENTRY SiteAttributeTable[] =
{
   &descriptionEntry,
   &autoTopSiteEntry,
   &cacheGroupsSiteEntry,
   &prefGCSiteEntry
};

DSGetObjectTableEntry g_SiteObjectEntry = 
{
   L"site",
   g_pszSite,
   DSGET_SITE_COMMANDS,
   USAGE_DSGET_SITE,
   sizeof(SiteAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SiteAttributeTable,
};

//
// Subnet
//
PDSGET_ATTR_TABLE_ENTRY SubnetAttributeTable[] =
{
   &descriptionEntry,
   &locSubnetEntry,
   &siteSubnetEntry
};

DSGetObjectTableEntry g_SubnetObjectEntry = 
{
   L"subnet",
   g_pszSubnet,
   DSGET_SUBNET_COMMANDS,
   USAGE_DSGET_SUBNET,
   sizeof(SubnetAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SubnetAttributeTable,
};

//
// partition
//
PDSGET_ATTR_TABLE_ENTRY PartitionAttributeTable[] = 
{
    &QDefaultPartitionEntry,
    &qTombstoneWeightPartitionEntry,
    &topObjOwnerPartitionEntry,
};

DSGetObjectTableEntry g_PartitionObjectEntry = 
{
    L"msDS-QuotaContainer",
    g_pszPartition,
    DSGET_PARTITION_COMMANDS,
    USAGE_DSGET_PARTITION,
    sizeof(PartitionAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
    PartitionAttributeTable,
};

//
// quota
//
PDSGET_ATTR_TABLE_ENTRY QuotaAttributeTable[] = 
{
    &descriptionEntry,
    &acctQuotaEntry,
    &qlimitQuotaEntry,
};

DSGetObjectTableEntry g_QuotaObjectEntry = 
{
    L"msDS-QuotaControl",
    g_pszQuota,
    DSGET_QUOTA_COMMANDS,
    USAGE_DSGET_QUOTA,
    sizeof(QuotaAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
    QuotaAttributeTable,
};

//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSGetObjectTableEntry g_DSObjectTable[] =
{
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ContactObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_ServerObjectEntry,
   &g_SiteObjectEntry,
   &g_SubnetObjectEntry,
   &g_PartitionObjectEntry,
   &g_QuotaObjectEntry,
   NULL
};

//
//Usage Table
//
UINT USAGE_DSGET[] =
{
	USAGE_DSGET_DESCRIPTION,
	USAGE_DSGET_REMARKS,
	USAGE_DSGET_EXAMPLES,
	USAGE_END,
};
UINT USAGE_DSGET_USER[] =
{
	USAGE_DSGET_USER_DESCRIPTION,
	USAGE_DSGET_USER_SYNTAX,
	USAGE_DSGET_USER_PARAMETERS,
	USAGE_DSGET_USER_REMARKS,
	USAGE_DSGET_USER_EXAMPLES,
	USAGE_END,
};
UINT USAGE_DSGET_CONTACT[] =
{
	USAGE_DSGET_CONTACT_DESCRIPTION,
	USAGE_DSGET_CONTACT_SYNTAX,
	USAGE_DSGET_CONTACT_PARAMETERS,
	USAGE_DSGET_CONTACT_REMARKS,
	USAGE_DSGET_CONTACT_EXAMPLES,
	USAGE_DSGET_CONTACT_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSGET_COMPUTER[] =
{
	USAGE_DSGET_COMPUTER_DESCRIPTION,
	USAGE_DSGET_COMPUTER_SYNTAX,
	USAGE_DSGET_COMPUTER_PARAMETERS,
	USAGE_DSGET_COMPUTER_REMARKS,
	USAGE_DSGET_COMPUTER_EXAMPLES,
	USAGE_DSGET_COMPUTER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSGET_GROUP[] =
{
	USAGE_DSGET_GROUP_DESCRIPTION,
	USAGE_DSGET_GROUP_SYNTAX,
	USAGE_DSGET_GROUP_PARAMETERS,
	USAGE_DSGET_GROUP_REMARKS,
	USAGE_DSGET_GROUP_EXAMPLES,
	USAGE_DSGET_GROUP_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSGET_OU[] =
{
	USAGE_DSGET_OU_DESCRIPTION,
	USAGE_DSGET_OU_SYNTAX,
	USAGE_DSGET_OU_PARAMETERS,
	USAGE_DSGET_OU_REMARKS,
	USAGE_DSGET_OU_EXAMPLES,
	USAGE_DSGET_OU_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSGET_SERVER[] =
{
	USAGE_DSGET_SERVER_DESCRIPTION,
	USAGE_DSGET_SERVER_SYNTAX,
	USAGE_DSGET_SERVER_PARAMETERS,
	USAGE_DSGET_SERVER_REMARKS,
	USAGE_DSGET_SERVER_EXAMPLES,
	USAGE_DSGET_SERVER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSGET_SITE[] =
{
	USAGE_DSGET_SITE_DESCRIPTION,
	USAGE_DSGET_SITE_SYNTAX,
	USAGE_DSGET_SITE_PARAMETERS,
	USAGE_DSGET_SITE_REMARKS,
	USAGE_DSGET_SITE_EXAMPLES,
	USAGE_DSGET_SITE_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSGET_SUBNET[] =
{
	USAGE_DSGET_SUBNET_DESCRIPTION,
	USAGE_DSGET_SUBNET_SYNTAX,
	USAGE_DSGET_SUBNET_PARAMETERS,
	USAGE_DSGET_SUBNET_REMARKS,
	USAGE_DSGET_SUBNET_EXAMPLES,
	USAGE_DSGET_SUBNET_SEE_ALSO,
	USAGE_END,
};

UINT USAGE_DSGET_PARTITION[] =
{
	USAGE_DSGET_PARTITION_DESCRIPTION,
	USAGE_DSGET_PARTITION_SYNTAX,
	USAGE_DSGET_PARTITION_PARAMETERS,
	USAGE_DSGET_PARTITION_REMARKS,
	USAGE_DSGET_PARTITION_EXAMPLES,
	USAGE_DSGET_PARTITION_SEE_ALSO,
	USAGE_END,
};

UINT USAGE_DSGET_QUOTA[] =
{
	USAGE_DSGET_QUOTA_DESCRIPTION,
	USAGE_DSGET_QUOTA_SYNTAX,
	USAGE_DSGET_QUOTA_PARAMETERS,
	USAGE_DSGET_QUOTA_REMARKS,
	USAGE_DSGET_QUOTA_EXAMPLES,
	USAGE_DSGET_QUOTA_SEE_ALSO,
	USAGE_END,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in dsget
//
//  History:   13-Oct-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "commonstrings.cpp"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsget";

//
// Object types as are typed on the command line
//
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszServer                  = L"server";
PCWSTR g_pszSite                    = L"site";
PCWSTR g_pszSubnet                  = L"subnet";
PCWSTR g_pszPartition               = L"partition";
PCWSTR g_pszQuota                   = L"quota";

PCWSTR c_sz_arg1_com_listformat     = L"l";

//
// User switches
//
PCWSTR g_pszArg1UserDN              = L"dn";
PCWSTR g_pszArg1UserSID             = L"sid";
PCWSTR g_pszArg1UserSAMID           = L"samid";
PCWSTR g_pszArg1UserUPN             = L"upn"; 
PCWSTR g_pszArg1UserFirstName       = L"fn";
PCWSTR g_pszArg1UserMiddleInitial   = L"mi";
PCWSTR g_pszArg1UserLastName        = L"ln";
PCWSTR g_pszArg1UserDisplayName     = L"display";
PCWSTR g_pszArg1UserEmployeeID      = L"empid";
PCWSTR g_pszArg1UserOffice          = L"office";
PCWSTR g_pszArg1UserTelephone       = L"tel"; 
PCWSTR g_pszArg1UserEmail           = L"email";
PCWSTR g_pszArg1UserHomeTelephone   = L"hometel";
PCWSTR g_pszArg1UserPagerNumber     = L"pager"; 
PCWSTR g_pszArg1UserMobileNumber    = L"mobile"; 
PCWSTR g_pszArg1UserFaxNumber       = L"fax";
PCWSTR g_pszArg1UserIPTel           = L"iptel";
PCWSTR g_pszArg1UserWebPage         = L"webpg";
PCWSTR g_pszArg1UserTitle           = L"title";
PCWSTR g_pszArg1UserDepartment      = L"dept"; 
PCWSTR g_pszArg1UserCompany         = L"company";
PCWSTR g_pszArg1UserManager         = L"mgr";
PCWSTR g_pszArg1UserHomeDirectory   = L"hmdir";
PCWSTR g_pszArg1UserHomeDrive       = L"hmdrv";
PCWSTR g_pszArg1UserProfile         = L"profile";
PCWSTR g_pszArg1UserLogonScript     = L"loscr";
PCWSTR g_pszArg1UserMustChangePwd   = L"mustchpwd";
PCWSTR g_pszArg1UserCanChangePwd    = L"canchpwd";
PCWSTR g_pszArg1UserPwdNeverExpires = L"pwdneverexpires";
PCWSTR g_pszArg1UserReversiblePwd   = L"reversiblepwd";
PCWSTR g_pszArg1UserDisableAccount  = L"disabled";
PCWSTR g_pszArg1UserAcctExpires     = L"acctexpires";
PCWSTR g_pszArg1UserMemberOf        = L"memberof";
PCWSTR g_pszArg1UserExpand          = L"expand";
PCWSTR g_pszArg1UserPart            = L"part";
PCWSTR g_pszArg1UserQLimit          = L"qlimit";
PCWSTR g_pszArg1UserQuotaUsed       = L"qused";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerSAMID       = L"samid";
PCWSTR g_pszArg1ComputerSID         = L"sid";
PCWSTR g_pszArg1ComputerLoc         = L"loc"; 
PCWSTR g_pszArg1ComputerDisableAccount = L"disabled";
PCWSTR g_pszArg1ComputerMemberOf    = L"memberof"; 
PCWSTR g_pszArg1ComputerExpand      = L"expand";
PCWSTR g_pszArg1ComputerPart        = L"part";
PCWSTR g_pszArg1ComputerQLimit      = L"qlimit";
PCWSTR g_pszArg1ComputerQuotaUsed   = L"qUsed";

//
// Group switches
//
PCWSTR g_pszArg1GroupSamid          = L"samid"; 
PCWSTR g_pszArg1GroupSID            = L"sid";
PCWSTR g_pszArg1GroupSecGrp         = L"secgrp";
PCWSTR g_pszArg1GroupScope          = L"scope"; 
PCWSTR g_pszArg1GroupMemberOf       = L"memberof";
PCWSTR g_pszArg1GroupMembers        = L"members";
PCWSTR g_pszArg1GroupExpand         = L"expand";
PCWSTR g_pszArg1GroupPart           = L"part";
PCWSTR g_pszArg1GroupQLimit         = L"qlimit";
PCWSTR g_pszArg1GroupQuotaUsed      = L"qUsed";

//
// Ou switches
//
// ** only uses common switches **

//
// Server switches
//
PCWSTR g_pszArg1ServerDnsName       = L"dnsname";
PCWSTR g_pszArg1ServerSite          = L"site";
PCWSTR g_pszArg1ServerIsGC          = L"isgc";
PCWSTR g_pszArg1ServerTopObjOwner   = L"topobjowner";
PCWSTR g_pszArg1ServerPart          = L"part";

//
// Site switches
//
PCWSTR g_pszArg1SiteAutotopology    = L"autotopology";
PCWSTR g_pszArg1SiteCacheGroups     = L"cachegroups";
PCWSTR g_pszArg1SitePrefGCSite      = L"prefGCsite";

//
// Subnet switches
//
PCWSTR g_pszArg1SubnetLocation      = L"loc";
PCWSTR g_pszArg1SubnetSite          = L"site";

//
// Partition switches
//
PCWSTR g_pszArg1PartitionQDefault         = L"qdefault";
PCWSTR g_pszArg1PartitionQTombstoneWeight = L"qtmbstnwt";
PCWSTR g_pszArg1PartitionTopObjOwner      = L"topobjowner";

//
// Quota switches
//
PCWSTR g_pszArg1QuotaAcct   = L"acct";
PCWSTR g_pszArg1QuotaQLimit = L"qlimit";

//
// Values
//
PCWSTR g_pszYes                     = L"yes";
PCWSTR g_pszNo                      = L"no";
PCWSTR g_pszNotConfigured           = L"not configured";
PCWSTR g_pszNever                   = L"never";

//
// 702724 ronmart 2002/09/18 Range qualifier
//
PCWSTR g_pszRange = L";range";

// NTRAID#NTBUG9-765440-2003/01/17-ronmart-dsget user/group -qlimit -qused 
//                                         not returning values 
PCWSTR g_pszAttrmsDSQuotaEffective = L"msDS-QuotaEffective";
PCWSTR g_pszAttrmsDSQuotaUsed      = L"msDS-QuotaUsed";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\gettable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      gettable.h
//
//  Contents:  Defines Enum for dsget.
//
//  History:   16-Oct-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _GETTABLE_H_
#define _GETTABLE_H_

//forward declarations
struct _DSGET_ATTRTABLE_ENTRY;
struct _DSGetObjectTableEntry;

//+--------------------------------------------------------------------------
//
//  Class:      CDSGetDisplayInfo
//
//  Purpose:    Object for maintaining attribute values which will be displayed
//
//  History:    23-Oct-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDSGetDisplayInfo
{
public:
   //
   // Constructor
   //
   CDSGetDisplayInfo() 
      : m_pszAttributeDisplayName(NULL),
        m_dwAttributeValueCount(0),
        m_ppszAttributeStringValue(NULL),
        m_dwAttributeValueSize(0),
        m_bShowAttribute(true)
   {}

   //
   // Desctructor
   //
   ~CDSGetDisplayInfo() 
   {
      if (m_ppszAttributeStringValue)
      {
         delete[] m_ppszAttributeStringValue;
         m_ppszAttributeStringValue = NULL;
      }
   }

   //
   // Public Accessors
   //
   void     SetDisplayName(PCWSTR pszDisplayName, bool bShowAttribute = true) 
   { 
      m_pszAttributeDisplayName = pszDisplayName; 
      m_bShowAttribute = bShowAttribute;
   }

   PCWSTR   GetDisplayName() { return m_pszAttributeDisplayName; }

   PCWSTR   GetValue(DWORD dwIdx)
   {
      if (dwIdx < m_dwAttributeValueCount)
      {
         return m_ppszAttributeStringValue[dwIdx];
      }
      return NULL;
   }
   HRESULT  AddValue(PCWSTR pszValue);

   DWORD    GetValueCount() { return m_dwAttributeValueCount; }

   bool     ShowAttribute() { return m_bShowAttribute; }

private:
   //
   // The name of the attribute as it is to be displayed in the output
   //
   PCWSTR m_pszAttributeDisplayName;

   //
   // The number of values in ppszAttributeStringValueArray
   //
   DWORD m_dwAttributeValueCount;

   //
   // The string value as it is to be displayed in the output
   //
   PWSTR* m_ppszAttributeStringValue;

   //
   // The size of the attribute array
   //
   DWORD m_dwAttributeValueSize;

   //
   // Whether or not to show the attribute when displaying
   //
   bool m_bShowAttribute;
};

typedef CDSGetDisplayInfo* PDSGET_DISPLAY_INFO;

//+-------------------------------------------------------------------------
// 
//  Type:      PGETDISPLAYSTRINGFUNC
//
//  Synopsis:  The definition of a function that prepares ldapFilter from
//             the infix filter given on the commandline.
//
//
//  Returns:   S_OK if the pAttr members were successfully set.
//             S_FALSE if the function failed but displayed its own error message. 
//
//  History:   25-Sep-2000    hiteshr     Created
//
//---------------------------------------------------------------------------
typedef HRESULT (*PGETDISPLAYSTRINGFUNC)(PCWSTR pszDN,
                                         CDSCmdBasePathsInfo& refBasePathsInfo,
                                         const CDSCmdCredentialObject& refCredentialObject,
                                         _DSGetObjectTableEntry* pEntry,
                                         ARG_RECORD* pRecord,
                                         PADS_ATTR_INFO pAttrInfo,
                                         CComPtr<IDirectoryObject>& spDirObject,
                                         PDSGET_DISPLAY_INFO pDisplayInfo);

//+--------------------------------------------------------------------------
//
//  Flags for specifying what the form of the output will be
//
//---------------------------------------------------------------------------
#define DSGET_OUTPUT_DN_FLAG  0x00000001

//+--------------------------------------------------------------------------
//
//  Struct:     _DSGET_ATTRTABLE_ENTRY
//
//  Purpose:    Definition of a table entry that describes the attribute for
//              which filter can be specified at commandline.
//
//  History:    25-Sep-2000 hiteshr  Created
//
//---------------------------------------------------------------------------
typedef struct _DSGET_ATTRTABLE_ENTRY
{
   //
   // The name that will be used for display (ie "Account disabled" instead of
   // "userAccountControl")
   //
   PCWSTR          pszDisplayName;

   //
   // The ldapDisplayName of the attribute
   //
   PWSTR          pszName;

   //
   // The unique identifier for this attribute that cooresponds to
   // the command line switch
   //
   UINT           nAttributeID;

   //
   // Flags that specify the form of the output
   // For example DSGET_OUTPUT_DN_FLAG specifies
   // the output will be in DN form
   //
   DWORD          dwOutputFlags;

   //
   //  function that gets the string to display for
   //  the value
   //
   PGETDISPLAYSTRINGFUNC pDisplayStringFunc;

} DSGET_ATTR_TABLE_ENTRY, *PDSGET_ATTR_TABLE_ENTRY;

//+--------------------------------------------------------------------------
//
//  Struct:     _DSGetObjectTableEntry
//
//  Purpose:    Definition of a table entry that describes attributes of a given
//              objecttype
//
//  History:    25-Sep-2000 hiteshr Created
//
//---------------------------------------------------------------------------

typedef struct _DSGetObjectTableEntry
{
   //
   // The objectClass of the object to be created or modified
   //
   PCWSTR pszObjectClass;

   //
   // The command line string used to determine the object class
   // This is not always identical to pszObjectClass
   //
   PCWSTR pszCommandLineObjectType;

   //
   // The table to merge with the common switches for the parser
   //
   ARG_RECORD* pParserTable;

   //
   // The ID of the Usage help text for this 
   //
   UINT* nUsageID;

   //
   // A count of the number of attributes in the table below
   //
   DWORD dwAttributeCount;

   //
   // A table of attributes for
   // which filter can be specified at commandline.
   //
   DSGET_ATTR_TABLE_ENTRY** pAttributeTable; 

} DSGetObjectTableEntry, *PDSGetObjectTableEntry;


typedef enum DSGET_COMMAND_ENUM
{

   eCommObjectType = eCommLast+1,   
   eCommContinue,
   eCommList,
   eCommObjectDNorName,
   eCommDN,
   eCommDescription,
   eTerminator,

   //
   // User switches
   //
   eUserSamID = eTerminator,
   eUserSID,
   eUserUpn,
   eUserFn,
   eUserMi,
   eUserLn,
   eUserDisplay,
   eUserEmpID,
   eUserOffice,
   eUserTel,
   eUserEmail,
   eUserHometel,
   eUserPager,
   eUserMobile,
   eUserFax,
   eUserIPTel,
   eUserWebPage,
   eUserTitle,
   eUserDept,
   eUserCompany,
   eUserManager,
   eUserHomeDirectory,
   eUserHomeDrive,
   eUserProfilePath,
   eUserLogonScript,
   eUserMustchpwd,
   eUserCanchpwd,
   eUserPwdneverexpires,
   eUserDisabled,
   eUserAcctExpires,
   eUserReversiblePwd,
   eUserMemberOf,
   eUserExpand,
   eUserPart,
   eUserQLimit,
   eUserQuotaUsed,
   eUserLast = eUserQuotaUsed,

   //
   // Contact switches
   //
   eContactFn = eTerminator,
   eContactMi,
   eContactLn,
   eContactDisplay,
   eContactOffice,
   eContactTel,
   eContactEmail,
   eContactHometel,
   eContactPager,
   eContactMobile,
   eContactFax,
   eContactIPTel,
   eContactTitle,
   eContactDept,
   eContactCompany,
   eContactLast = eContactCompany,

   //
   // Computer switches
   //
   eComputerSamID = eTerminator,
   eComputerSID,
   eComputerLoc,
   eComputerDisabled,
   eComputerMemberOf,
   eComputerExpand,
   eComputerPart,
   eComputerQLimit,
   eComputerQuotaUsed,
   eComputerLast = eComputerQuotaUsed,


   //
   // Group switches
   //
   eGroupSamname = eTerminator,
   eGroupSID,
   eGroupSecgrp,
   eGroupScope,
   eGroupMemberOf,
   eGroupMembers,
   eGroupExpand,
   eGroupPart,
   eGroupQLimit,
   eGroupQuotaUsed,
   eGroupLast = eGroupQuotaUsed,

   //
   // OU doesn't have any additional switches
   //

   //
   // Server switches
   //
   eServerDnsName = eTerminator,
   eServerSite,
   eServerIsGC,
   eServerPart,
   eServerTopObjOwner,
   eServerLast = eServerTopObjOwner,

   //
   // Site switches
   //
   eSiteAutoTop = eTerminator,
   eSiteCacheGroups ,
   eSitePrefGC,
   eSiteLast = eSitePrefGC,


   //
   // Subnet switches
   //
   eSubnetLocation = eTerminator,
   eSubnetSite,
   eSubnetLast = eSubnetSite,

   //
   // Partition switches
   //
   ePartitionQDefault = eTerminator,
   ePartitionQTombstoneWeight,
   ePartitionTopObjOwner,
   ePartitionLast = ePartitionTopObjOwner,

    //
    // Quota switches
    //
    eQuotaAcct = eTerminator,
    eQuotaQLimit,
    eQuotaLast = eQuotaQLimit,

/*
   //
   // Site Link switches
   //
   eSLinkIp = eTerminator,
   eSLinkSmtp,
   eSLinkAddsite,
   eSLinkRmsite,
   eSLinkCost,
   eSLinkRepint,
   eSLinkAutobacksync,
   eSLinkNotify,

   //
   // Site Link Bridge switches
   //
   eSLinkBrIp = eTerminator,
   eSLinkBrSmtp,
   eSLinkBrAddslink,
   eSLinkBrRmslink,

   //
   // Replication Connection switches
   // 
   eConnTransport = eTerminator,
   eConnEnabled,
   eConnManual,
   eConnAutobacksync,
   eConnNotify,
*/
};

//
// The parser table
//
extern ARG_RECORD DSGET_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSGetObjectTableEntry g_DSObjectTable[];

//
//Usage Table
//
extern UINT USAGE_DSGET[];
extern UINT USAGE_DSGET_USER[];
extern UINT USAGE_DSGET_CONTACT[];
extern UINT USAGE_DSGET_COMPUTER[];
extern UINT USAGE_DSGET_GROUP[];
extern UINT USAGE_DSGET_OU[];
extern UINT USAGE_DSGET_SERVER[];
extern UINT USAGE_DSGET_SITE[];
extern UINT USAGE_DSGET_SUBNET[];
extern UINT USAGE_DSGET_PARTITION[];
extern UINT USAGE_DSGET_QUOTA[];

#endif //_QUERYTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\display.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      display.h
//
//  Contents:  Defines the functions used to convert values to strings
//             for display purposes
//
//  History:   17-Oct-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

//
// All these functions are of type PGETDISPLAYSTRINGFUNC as defined in
// gettable.h
//

HRESULT CommonDisplayStringFunc(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& spDirObject,
                                PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayCanChangePassword(PCWSTR pszDN,
                                 CDSCmdBasePathsInfo& refBasePathsInfo,
                                 const CDSCmdCredentialObject& refCredentialObject,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pRecord,
                                 PADS_ATTR_INFO pAttrInfo,
                                 CComPtr<IDirectoryObject>& spDirObject,
                                 PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayMustChangePassword(PCWSTR pszDN,
                                  CDSCmdBasePathsInfo& refBasePathsInfo,
                                  const CDSCmdCredentialObject& refCredentialObject,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayAccountDisabled(PCWSTR pszDN,
                               CDSCmdBasePathsInfo& refBasePathsInfo,
                               const CDSCmdCredentialObject& refCredentialObject,
                               _DSGetObjectTableEntry* pEntry,
                               ARG_RECORD* pRecord,
                               PADS_ATTR_INFO pAttrInfo,
                               CComPtr<IDirectoryObject>& spDirObject,
                               PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayPasswordNeverExpires(PCWSTR pszDN,
                                    CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& spDirObject,
                                    PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayReversiblePassword(PCWSTR pszDN,
                                  CDSCmdBasePathsInfo& refBasePathsInfo,
                                  const CDSCmdCredentialObject& refCredentialObject,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayAccountExpires(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              _DSGetObjectTableEntry* pEntry,
                              ARG_RECORD* pRecord,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupScope(PCWSTR pszDN,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          _DSGetObjectTableEntry* pEntry,
                          ARG_RECORD* pRecord,
                          PADS_ATTR_INFO pAttrInfo,
                          CComPtr<IDirectoryObject>& spDirObject,
                          PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupSecurityEnabled(PCWSTR pszDN,
                                    CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& spDirObject,
                                    PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupMembers(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* pEntry,
                            ARG_RECORD* pCommandArgs,
                            PADS_ATTR_INFO pAttrInfo,
                            CComPtr<IDirectoryObject>& spDirObject,
                            PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayPartitions(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* pEntry,
                            ARG_RECORD* pRecord,
                            PADS_ATTR_INFO pAttrInfo,
                            CComPtr<IDirectoryObject>& spDirObject,
                            PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayUserMemberOf(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* pEntry,
                            ARG_RECORD* pRecord,
                            PADS_ATTR_INFO pAttrInfo,
                            CComPtr<IDirectoryObject>& spDirObject,
                            PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayComputerMemberOf(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupMemberOf(PCWSTR pszDN,
                             CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             _DSGetObjectTableEntry* pEntry,
                             ARG_RECORD* pRecord,
                             PADS_ATTR_INFO pAttrInfo,
                             CComPtr<IDirectoryObject>& spDirObject,
                             PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGrandparentRDN(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              _DSGetObjectTableEntry* pEntry,
                              ARG_RECORD* pRecord,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayObjectAttributeAsRDN(PCWSTR pszDN,
                                    CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& spDirObject,
                                    PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT IsServerGCDisplay(PCWSTR pszDN,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          _DSGetObjectTableEntry* pEntry,
                          ARG_RECORD* pRecord,
                          PADS_ATTR_INFO pAttrInfo,
                          CComPtr<IDirectoryObject>& spDirObject,
                          PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT IsAutotopologyEnabledSite(PCWSTR pszDN,
                                  CDSCmdBasePathsInfo& refBasePathsInfo,
                                  const CDSCmdCredentialObject& refCredentialObject,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT IsCacheGroupsEnabledSite(PCWSTR pszDN,
                                 CDSCmdBasePathsInfo& refBasePathsInfo,
                                 const CDSCmdCredentialObject& refCredentialObject,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pRecord,
                                 PADS_ATTR_INFO pAttrInfo,
                                 CComPtr<IDirectoryObject>& spDirObject,
                                 PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayPreferredGC(PCWSTR pszDN,
                           CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           _DSGetObjectTableEntry* pEntry,
                           ARG_RECORD* pRecord,
                           PADS_ATTR_INFO pAttrInfo,
                           CComPtr<IDirectoryObject>& spDirObject,
                           PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayUserFromSidFunc(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& spDirObject,
                                PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayQuotaInfoFunc(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& spDirObject,
                                PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayTopObjOwner(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& spDirObject,
                                PDSGET_DISPLAY_INFO pDisplayInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\output.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      output.cpp
//
//  Contents:  Defines the functions which displays the query output
//  History:   05-OCT-2000    hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "gettable.h"
#include "display.h"
#include "query.h"
#include "resource.h"
#include "stdlib.h"
#include "output.h"

#include <sddl.h>


HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

	//Security Review:pString is null terminated.
    *ppResult = (LPTSTR)LocalAlloc(LPTR, (wcslen(pString)+1)*sizeof(WCHAR) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

	//Correct buffer is allocated.
    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


//+--------------------------------------------------------------------------
//
//  Function:   DisplayList
//
//  Synopsis:   Dispalys a name and value in list format.
//  Arguments:  [szName - IN] : name of the attribute
//              [szValue - IN]: value of the attribute
//              [bShowAttribute - IN] : if true the attribute name will be
//                              prepended to the output
//
//
//  History:    05-OCT-2000   hiteshr   Created
//              07-AUG-2001   jeffjon   Added the bShowAttribute parameter
//
//---------------------------------------------------------------------------
VOID DisplayList(LPCWSTR szName, LPCWSTR szValue, bool bShowAttributes = true)
{
    if(!szName)
        return;
    CComBSTR strTemp;

    if (bShowAttributes)
    {
        strTemp = szName;
        strTemp += L": ";
    }
    if(szValue)
        strTemp += szValue;
    DisplayOutput(strTemp);
}
    
//+--------------------------------------------------------------------------
//
//  Function:   FindAttrInfoForName
//
//  Synopsis:   This function finds the ADS_ATTR_INFO associated with an
//              attribute name
//
//  Arguments:  [pAttrInfo IN]   : Array of ADS_ATTR_INFOs
//              [dwAttrCount IN] : Count of attributes in array
//              [pszAttrName IN] : name of attribute to search for
//                                  
//  Returns:    PADS_ATTR_INFO : pointer to the ADS_ATTR_INFO struct associated
//                               with the attribute name, otherwise NULL
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

PADS_ATTR_INFO FindAttrInfoForName(PADS_ATTR_INFO pAttrInfo,
                                   DWORD dwAttrCount,
                                   PCWSTR pszAttrName)
{
   ENTER_FUNCTION(FULL_LOGGING, FindAttrInfoForName);

   PADS_ATTR_INFO pRetAttrInfo = 0;
   LPWSTR pRangeFound = NULL; // 702724 ronmart 2002/09/18 added for range support

   do // false loop
   {
      //
      // Validate Parameters
      //
      if (!pszAttrName)
      {
         ASSERT(pszAttrName);
         break;
      }

      //
      // If pAttrInfo is NULL then there is nothing to retrieve
      // that is acceptable if the value was not set
      //
      if (!pAttrInfo ||
          dwAttrCount == 0)
      {
         break;
      }

      for (DWORD dwIdx = 0; dwIdx < dwAttrCount; dwIdx++)
      {
        // 702724 ronmart 2002/09/18 See if a range qualifier has been specified
        pRangeFound = wcsstr(pAttrInfo[dwIdx].pszAttrName, g_pszRange);
        // If so, then terminate the string at the qualifer so that
        // the following comparision will only consider the attribute name
        if(pRangeFound)
        {
            pRangeFound[0] = 0;
        }

		//Security Review:Both are null terminated.
         if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, pszAttrName) == 0)
         {
            pRetAttrInfo = &(pAttrInfo[dwIdx]);
            break;
         }
         // If there wasn't a match and the item had a range qualifier
         // then restore the string
         if(pRangeFound)
         {
            pRangeFound[0] = g_pszRange[0];
            pRangeFound = NULL;
         }

      }
   } while (false);

   // All done so restore the string if a range qualifier was found
   if(pRangeFound)
       pRangeFound[0] = g_pszRange[0];

   return pRetAttrInfo;
}


//+--------------------------------------------------------------------------
//
//  Function:   DsGetOutputValuesList
//
//  Synopsis:   This function gets the values for the columns and then adds
//              the row to the format helper
//
//  Arguments:  [pszDN IN]        : the DN of the object
//              [refBasePathsInfo IN] : reference to path info
//              [refCredentialObject IN] : reference to the credential manager
//              [pCommandArgs IN] : Command line arguments
//              [pObjectEntry IN] : Entry in the object table being processed
//              [dwAttrCount IN]  : Number of arributes in above array
//              [pAttrInfo IN]    : the values to display
//              [spDirObject IN]  : Interface pointer to the object
//              [refFormatInfo IN]: Reference to the format helper
//                                  
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//
//  History:    16-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT DsGetOutputValuesList(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              PARG_RECORD pCommandArgs,
                              PDSGetObjectTableEntry pObjectEntry,
                              DWORD dwAttrCount,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              CFormatInfo& refFormatInfo)
{    
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DsGetOutputValuesList, hr);

   do // false loop
   {
      if(!pszDN ||
         !pCommandArgs ||
         !pObjectEntry)
      {
         ASSERT(pszDN);
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }


      DWORD dwDisplayInfoArraySize = pObjectEntry->dwAttributeCount;
      if (pCommandArgs[eCommDN].bDefined)
      {
         dwDisplayInfoArraySize++;
      }

      PDSGET_DISPLAY_INFO pDisplayInfoArray = new CDSGetDisplayInfo[dwDisplayInfoArraySize];
      if (!pDisplayInfoArray)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      DWORD dwDisplayCount = 0;
      if (pCommandArgs[eCommDN].bDefined)
      {
         
         CComBSTR sbstrOutputDN;

         // NTRAID#NTBUG9-702418-2002/09/12-ronmart- The partition 
         // object currently is not bound to the DN of the partition
         // but to the dn of the NTDS Quotas container of the 
         // partition passed on the cmd line. This happens because
         // the current attributes to retrieve are quota container
         // attributes only. If the user passes the common -dn
         // flag on the cmd line then they should get back the
         // partition DN, not the quotas container dn
         if(0 == lstrcmpi(pObjectEntry->pszCommandLineObjectType, g_pszPartition))
         {
            // The NTDS Quotas container is a child of the parition
            // so this will retrieve the partition DN
            CComBSTR sbstrParentDN;
            hr = CPathCracker::GetParentDN(pszDN, sbstrParentDN);
            if (FAILED(hr))
            {
                ASSERT(FALSE);
                break; 
            }

            hr = GetOutputDN( &sbstrOutputDN, sbstrParentDN);
            if (FAILED(hr))
            {
                ASSERT(FALSE);
                break;
            }

         }
         else
         {
            // JonN 5/10/01 256583 output DSCMD-escaped DN  
            hr = GetOutputDN( &sbstrOutputDN, pszDN );
            if (FAILED(hr))
            {
                ASSERT(FALSE);
                break;
            }
         }

         pDisplayInfoArray[dwDisplayCount].SetDisplayName(g_pszArg1UserDN);
         pDisplayInfoArray[dwDisplayCount].AddValue(sbstrOutputDN);
         dwDisplayCount++;
      }

      //
      // Loop through the attributes getting their display values
      //
      for(DWORD i = 0; i < pObjectEntry->dwAttributeCount; i++)
      {
         if (pObjectEntry->pAttributeTable[i])
         {
            UINT nCommandEntry = pObjectEntry->pAttributeTable[i]->nAttributeID;
            if (pCommandArgs[nCommandEntry].bDefined &&
                pObjectEntry->pAttributeTable[i]->pDisplayStringFunc)
            {
               //
               // Find the ADS_ATTR_INFO structure associated with this attribute
               //
               PADS_ATTR_INFO pAttrInfoDisplay = NULL;
               if (pObjectEntry->pAttributeTable[i]->pszName)
               {
                  pAttrInfoDisplay = FindAttrInfoForName(pAttrInfo,
                                                         dwAttrCount,
                                                         pObjectEntry->pAttributeTable[i]->pszName);
               }

               //
               // Fill in the column header even if there isn't a value
               //
               pDisplayInfoArray[dwDisplayCount].SetDisplayName(pCommandArgs[nCommandEntry].strArg1,
                                                                !(pObjectEntry->pAttributeTable[i]->dwOutputFlags & DSGET_OUTPUT_DN_FLAG));

               //
               // Format the output strings
               // Note: this could actually involve some operation if the value isn't
               // retrieved by GetObjectAttributes (ie Can change password)
               //
               hr = pObjectEntry->pAttributeTable[i]->pDisplayStringFunc(pszDN,
                                                                         refBasePathsInfo,
                                                                         refCredentialObject,
                                                                         pObjectEntry,
                                                                         pCommandArgs,
                                                                         pAttrInfoDisplay,
                                                                         spDirObject,
                                                                         &(pDisplayInfoArray[dwDisplayCount]));
               if (FAILED(hr))
               {
                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Failed display string func for %s: hr = 0x%x",
                               pObjectEntry->pAttributeTable[i]->pszName,
                               hr);
               }
               dwDisplayCount++;
            }
         }
      }


      DEBUG_OUTPUT(FULL_LOGGING, L"Attributes returned with values:");

#ifdef DBG
      for (DWORD dwIdx = 0; dwIdx < dwDisplayCount; dwIdx++)
      {
         for (DWORD dwValue = 0; dwValue < pDisplayInfoArray[dwIdx].GetValueCount(); dwValue++)
         {
            if (pDisplayInfoArray[dwIdx].GetDisplayName() &&
                pDisplayInfoArray[dwIdx].GetValue(dwValue))
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t%s = %s", 
                            pDisplayInfoArray[dwIdx].GetDisplayName(),
                            pDisplayInfoArray[dwIdx].GetValue(dwValue));
            }
            else if (pDisplayInfoArray[dwIdx].GetDisplayName() &&
                     !pDisplayInfoArray[dwIdx].GetValue(dwValue))
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t%s = ", 
                            pDisplayInfoArray[dwIdx].GetDisplayName());
            }
            else if (!pDisplayInfoArray[dwIdx].GetDisplayName() &&
                     pDisplayInfoArray[dwIdx].GetValue(dwValue))
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t??? = %s", 
                            pDisplayInfoArray[dwIdx].GetValue(dwValue));
            }
            else
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t??? = ???");
            }
         }
      }
#endif

      hr = refFormatInfo.AddRow(pDisplayInfoArray, dwDisplayCount);

   } while (false);

   return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromADs
//
//  Synopsis:   Converts Value into string depending upon type
//  Arguments:  [pValues - IN]: Value to be converted to string
//              [dwADsType-IN]: ADSTYPE of pValue
//              [pBuffer - OUT]:Output buffer which gets the string 
//              [dwBufferLen-IN]:Size of output buffer
//              [pszAttrName-IN]:Name of the attribute being formatted
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR* ppBuffer, 
                         IN PCWSTR pszAttrName)
{
    HRESULT hr = S_OK;

    if(!pValues || !ppBuffer)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    if( dwADsType == ADSTYPE_INVALID )
    {
        return E_INVALIDARG;
    }

        switch( dwADsType ) 
        {
        case ADSTYPE_DN_STRING : 
            {
                CComBSTR sbstrOutputDN;
                hr = GetOutputDN( &sbstrOutputDN, pValues->DNString );
                if (FAILED(hr))
                    return hr;

                // Quote output DNs so that they can be piped to other
                // commands

                sbstrOutputDN = GetQuotedDN(sbstrOutputDN);

                UINT length = sbstrOutputDN.Length();
                *ppBuffer = new WCHAR[length + 1];
                if (!(*ppBuffer))
                {
                   hr = E_OUTOFMEMORY;
                   return hr;
                }
				//Security Review:Correct Buffer size is passed.
                ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
				//Security Review:wcsncpy will copy length char
				//length + 1 is already set to zero so we are fine.
                wcsncpy(*ppBuffer, (BSTR)sbstrOutputDN, length);
            }
            break;

        case ADSTYPE_CASE_EXACT_STRING :
           {
             size_t length = wcslen(pValues->CaseExactString);
             *ppBuffer = new WCHAR[length + 1];
             if (!(*ppBuffer))
             {
                hr = E_OUTOFMEMORY;
                return hr;
             }
             //Security Review:Correct Buffer size is passed.
			 ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
			//Security Review:wcsncpy will copy length char
			//length + 1 is already set to zero so we are fine.
             wcsncpy(*ppBuffer ,pValues->CaseExactString, length);
           }
           break;

        case ADSTYPE_CASE_IGNORE_STRING:
           {
             size_t length = wcslen(pValues->CaseIgnoreString);
             *ppBuffer = new WCHAR[length + 1];
             if (!(*ppBuffer))
             {
                hr = E_OUTOFMEMORY;
                return hr;
             }
             //Security Review:Correct Buffer size is passed.
             ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
			//Security Review:wcsncpy will copy length char
			//length + 1 is already set to zero so we are fine.
             wcsncpy(*ppBuffer ,pValues->CaseIgnoreString, length);
           }
           break;

        case ADSTYPE_PRINTABLE_STRING  :
           {
             size_t length = wcslen(pValues->PrintableString);
             *ppBuffer = new WCHAR[length + 1];
             if (!(*ppBuffer))
             {
                hr = E_OUTOFMEMORY;
                return hr;
             }
             //Security Review:Correct Buffer size is passed.
             ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
			//Security Review:wcsncpy will copy length char
			//length + 1 is already set to zero so we are fine.
             wcsncpy(*ppBuffer ,pValues->PrintableString, length);
           }
           break;

        case ADSTYPE_NUMERIC_STRING    :
           {
             size_t length = wcslen(pValues->NumericString);
             *ppBuffer = new WCHAR[length + 1];
             if (!(*ppBuffer))
             {
                hr = E_OUTOFMEMORY;
                return hr;
             }
             //Security Review:Correct Buffer size is passed.
             ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
			 //Security Review:wcsncpy will copy length char
			 //length + 1 is already set to zero so we are fine.
             wcsncpy(*ppBuffer ,pValues->NumericString, length);
           }
           break;
    
        case ADSTYPE_OBJECT_CLASS    :
           {
             size_t length = wcslen(pValues->ClassName);
             *ppBuffer = new WCHAR[length + 1];
             if (!(*ppBuffer))
             {
                hr = E_OUTOFMEMORY;
                return hr;
             }
             //Security Review:Correct Buffer size is passed.
             ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
			 //Security Review:wcsncpy will copy length char
			 //length + 1 is already set to zero so we are fine.
             wcsncpy(*ppBuffer ,pValues->ClassName, length);
           }
           break;
    
        case ADSTYPE_BOOLEAN :
           {
            size_t length = 0;
            if (pValues->Boolean)
            {
               length = wcslen(L"TRUE");
               *ppBuffer = new WCHAR[length + 1];
            }
            else
            {
               length = wcslen(L"FALSE");
               *ppBuffer = new WCHAR[length + 1];
            }

            if (!(*ppBuffer))
            {
               hr = E_OUTOFMEMORY;
               return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            wcscpy(*ppBuffer ,((DWORD)pValues->Boolean) ? L"TRUE" : L"FALSE");
           }
           break;
    
        case ADSTYPE_INTEGER           :
            // Just allocate too much...
            *ppBuffer = new WCHAR[MAXSTR];
            if (!(*ppBuffer))
            {
               hr = E_OUTOFMEMORY;
               return hr;
            }
			//Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, MAXSTR * sizeof(WCHAR));
			  //Security Review:Usage is safe. Filed a generic bug to replace
			  //wsprintf with strsafe api.
			  //NTRAID#NTBUG9-574456-2002/03/12-hiteshr

            wsprintf(*ppBuffer ,L"%d", (DWORD) pValues->Integer);
            break;
    
        case ADSTYPE_OCTET_STRING      :
          {		
            BYTE  b;
            WCHAR sOctet[128];
            DWORD dwLen = 0;

            // I am just going to limit the buffer to MAXSTR.
            // It will be a rare occasion when someone wants
            // to look at a binary string that is not a GUID
            // or a SID.
            *ppBuffer = new WCHAR[MAXSTR+1];
            if (!(*ppBuffer))
            {
               hr = E_OUTOFMEMORY;
               return hr;
            }
			//Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (MAXSTR+1) * sizeof(WCHAR));

			   //
			   //Special case objectguid and objectsid attribute
			   //
			   //Security Review:pszAttrName is null terminated
			   if(pszAttrName && !_wcsicmp(pszAttrName, L"objectguid"))
			   {
				   GUID *pguid = (GUID*)pValues->OctetString.lpValue;
				   StringFromGUID2(*pguid,(LPOLESTR)*ppBuffer,MAXSTR);
				   break;
			   }
			   //Security Review:pszAttrName is null terminated
			   if(pszAttrName && !_wcsicmp(pszAttrName, L"objectsid"))
			   {
				   LPWSTR pszSid = NULL;
				   PSID pSid = (PSID)pValues->OctetString.lpValue;
				   if(ConvertSidToStringSid(pSid, &pszSid))
				   {
					   //Security Review:
					   //NTRAID#NTBUG9-574385-2002/03/12-hiteshr
					   wcsncpy(*ppBuffer,pszSid,MAXSTR); //Change ppBuffer size to MAXSTR+1, yanggao
					   LocalFree(pszSid);
					   break;
				   }
			   }

			   for ( DWORD idx=0; idx<pValues->OctetString.dwLength; idx++) 
			   {                        
			       b = ((BYTE *)pValues->OctetString.lpValue)[idx];
				  //Security Review:Usage is safe. Filed a generic bug to replace
				  //wsprintf with strsafe api.
				  //NTRAID#NTBUG9-574456-2002/03/12-hiteshr

				   wsprintf(sOctet,L"0x%02x ", b);						                
				   //sOctet is null terminated.
                   dwLen += static_cast<DWORD>(wcslen(sOctet));
                   if(dwLen > (MAXSTR - 1) )
                       break;
                   else
                       wcscat(*ppBuffer,sOctet);
               }
           }
		   break;
    
        case ADSTYPE_LARGE_INTEGER :     
          {
            CComBSTR strLarge;   
            LARGE_INTEGER li = pValues->LargeInteger;
                    litow(li, strLarge);

            UINT length = strLarge.Length();
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
               hr = E_OUTOFMEMORY;
               return hr;
            }
			//Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
			//Security Review:wcsncpy will copy length char
			//length + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer,strLarge,length);
          }
          break;
    
        case ADSTYPE_UTC_TIME          :
          // The longest date can be 20 characters including the NULL
          *ppBuffer = new WCHAR[20];
          if (!(*ppBuffer))
          {
             hr = E_OUTOFMEMORY;
             return hr;
          }
          ZeroMemory(*ppBuffer, sizeof(WCHAR) * 20);
		  //Security Review:Usage is safe. Filed a generic bug to replace
		  //wsprintf with strsafe api.
		  //NTRAID#NTBUG9-574456-2002/03/12-hiteshr
          wsprintf(*ppBuffer,
                   L"%02d/%02d/%04d %02d:%02d:%02d", pValues->UTCTime.wMonth, pValues->UTCTime.wDay, pValues->UTCTime.wYear,
                   pValues->UTCTime.wHour, pValues->UTCTime.wMinute, pValues->UTCTime.wSecond 
                  );
          break;

        case ADSTYPE_NT_SECURITY_DESCRIPTOR: // I use the ACLEditor instead
          {
            //ISSUE:2000/01/05-hiteshr
            //I am not sure what to do with the NT_SECURITY_DESCRIPTOR and also
            //with someother datatypes not coverd by dsquery.
          }
          break;

        default :
          break;
    }
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::CFormatInfo
//
//  Synopsis:   Constructor for the format info class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CFormatInfo::CFormatInfo()
   : m_bInitialized(false),
     m_bListFormat(false),
     m_bQuiet(false),
     m_dwSampleSize(0),
     m_dwTotalRows(0),
     m_dwNumColumns(0),
     m_pColWidth(NULL),
     m_ppDisplayInfoArray(NULL)
{};

//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::~CFormatInfo
//
//  Synopsis:   Destructor for the format info class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CFormatInfo::~CFormatInfo()
{        
   if (m_pColWidth)
   {
      delete[] m_pColWidth;
      m_pColWidth = NULL;
   }

   if (m_ppDisplayInfoArray)
   {
      delete[] m_ppDisplayInfoArray;
      m_ppDisplayInfoArray = NULL;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::Initialize
//
//  Synopsis:   Initializes the CFormatInfo object with the data
//
//  Arguments:  [dwSamplesSize IN] : Number of rows to use for formatting info
//              [bShowAsList IN]   : Display should be in list or table format
//              [bQuiet IN]        : Don't display anything to stdout
//
//  Returns:    HRESULT : S_OK if everything succeeded    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CFormatInfo::Initialize(DWORD dwSampleSize, 
                                bool bShowAsList,
                                bool bQuiet)
{
   ENTER_FUNCTION_HR(LEVEL8_LOGGING, CFormatInfo::Initialize, hr);

   do // false loop
   {
      //
      // Validate Parameters
      //
      if(!dwSampleSize)
      {
         ASSERT(dwSampleSize);
         hr = E_INVALIDARG;
         break;
      }
        
      m_dwSampleSize = dwSampleSize; 
      m_bListFormat = bShowAsList;
      m_bQuiet = bQuiet;

      //
      // Allocate the array of rows
      //
      m_ppDisplayInfoArray = new PDSGET_DISPLAY_INFO[m_dwSampleSize];
      if (!m_ppDisplayInfoArray)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
	  //Security Review:memset should take m_dwSampleSize*sizeof(PDSGET_DISPLAY_INFO);
	  //NTRAID#NTBUG9-574395-2002/03/12-hiteshr, fixed, yanggao
      memset(m_ppDisplayInfoArray, 0, m_dwSampleSize*sizeof(PDSGET_DISPLAY_INFO));

      //
      // We are now initialized
      //
      m_bInitialized = true;                      
   } while (false);

   return hr;
};

                 
//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::AddRow
//
//  Synopsis:   Cache and update the columns for specified row
//
//  Arguments:  [pDisplayInfoArray IN] : Column headers and values
//              [dwColumnCount IN]     : Number of columns
//
//  Returns:    HRESULT : S_OK if everything succeeded    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CFormatInfo::AddRow(PDSGET_DISPLAY_INFO pDisplayInfo,
                            DWORD dwColumnCount)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CFormatInfo::AddRow, hr);

   do // false loop
   {
      //
      // Make sure we have been initialized
      //
      if (!m_bInitialized)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"CFormatInfo::Initialize has not been called yet!");
         ASSERT(m_bInitialized);
         hr = E_FAIL;
         break;
      }

      //
      // Verify parameters
      //
      if (!pDisplayInfo)
      {
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (m_bListFormat)
      {
         //
         // No reason to cache for the list format just output all the name/value pairs
         //
         for (DWORD dwIdx = 0; dwIdx < dwColumnCount; dwIdx++)
         {
            if (pDisplayInfo[dwIdx].GetValueCount())
            {
               for (DWORD dwValue = 0; dwValue < pDisplayInfo[dwIdx].GetValueCount(); dwValue++)
               {
                  DisplayList(pDisplayInfo[dwIdx].GetDisplayName(),
                              pDisplayInfo[dwIdx].GetValue(dwValue),
                              pDisplayInfo[dwIdx].ShowAttribute());
               }
            }
            else
            {
               DisplayList(pDisplayInfo[dwIdx].GetDisplayName(),
                           NULL,
                           pDisplayInfo[dwIdx].ShowAttribute());
            }
         }
         NewLine();
      }
      else // table format
      {
         //
         // Set the row in the array
         //
         m_ppDisplayInfoArray[m_dwTotalRows] = pDisplayInfo;

         //
         // If this is the first row, update the column count
         // and allocate the column widths array
         //
         if (m_dwTotalRows == 0)
         {
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Initializing column count to %d",
                         dwColumnCount);

            m_dwNumColumns = dwColumnCount;

            m_pColWidth = new DWORD[m_dwNumColumns];
            if (!m_pColWidth)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

			//Security Review:memset should take m_dwNumColumns*sizeof(DWORD);
			//NTRAID#NTBUG9-574395-2002/03/12-hiteshr, fixed, yanggao
            memset(m_pColWidth, 0, sizeof(m_dwNumColumns*sizeof(DWORD)));

            //
            // Set the initial column widths from the column headers
            //
            for (DWORD dwIdx = 0; dwIdx < m_dwNumColumns; dwIdx++)
            {
               if (pDisplayInfo[dwIdx].GetDisplayName())
               {
				  //Security Review:This is fine.
                  m_pColWidth[dwIdx] = static_cast<DWORD>(wcslen(pDisplayInfo[dwIdx].GetDisplayName()));
               }
               else
               {
                  ASSERT(false);
                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"The display name for column %d wasn't set!", dwIdx);
               }
            }

         }
         else
         {
            if (m_dwNumColumns != dwColumnCount)
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, 
                            L"Column count of new row (%d) does not equal the current column count (%d)",
                            dwColumnCount,
                            m_dwNumColumns);
               ASSERT(m_dwNumColumns == dwColumnCount);
            }
         }

         //
         // Go through the columns and update the widths if necessary
         //
         for (DWORD dwIdx = 0; dwIdx < m_dwNumColumns; dwIdx++)
         {
            for (DWORD dwValue = 0; dwValue < pDisplayInfo[dwIdx].GetValueCount(); dwValue++)
            {
               if (pDisplayInfo[dwIdx].GetValue(dwValue))
               {
				  //This is fine.
                  size_t sColWidth = wcslen(pDisplayInfo[dwIdx].GetValue(dwValue));
                  m_pColWidth[dwIdx] = (DWORD)__max(sColWidth, m_pColWidth[dwIdx]);
               }
            }
         }

         //
         // Increment the row count
         //
         m_dwTotalRows++;
      }
   } while (false);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsget.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_ERRMSG_CLASS_NOT_EQUAL      101
#define IDS_ERRMSG_PART_MISSING         102
#define IDS_ERRMSG_INVALID_PART         103
#define IDS_ERRMSG_NO_QUOTAS_CONTAINER  104
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmod\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

#include "commonstrings.h"

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;
extern PCWSTR g_pszServer;
extern PCWSTR g_pszQuota;
extern PCWSTR g_pszPartition;

//
// User and contact switches
//
extern PCWSTR g_pszArg1UserUPN; 
extern PCWSTR g_pszArg1UserFirstName;
extern PCWSTR g_pszArg1UserMiddleInitial;
extern PCWSTR g_pszArg1UserLastName;
extern PCWSTR g_pszArg1UserDisplayName;
extern PCWSTR g_pszArg1UserEmpID;
extern PCWSTR g_pszArg1UserPassword;
extern PCWSTR g_pszArg1UserOffice;
extern PCWSTR g_pszArg1UserTelephone;
extern PCWSTR g_pszArg1UserEmail;
extern PCWSTR g_pszArg1UserHomeTelephone;
extern PCWSTR g_pszArg1UserPagerNumber;
extern PCWSTR g_pszArg1UserMobileNumber;
extern PCWSTR g_pszArg1UserFaxNumber;
extern PCWSTR g_pszArg1UserIPTel;
extern PCWSTR g_pszArg1UserWebPage;
extern PCWSTR g_pszArg1UserTitle;
extern PCWSTR g_pszArg1UserDepartment;
extern PCWSTR g_pszArg1UserCompany;
extern PCWSTR g_pszArg1UserManager;
extern PCWSTR g_pszArg1UserHomeDirectory;
extern PCWSTR g_pszArg1UserHomeDrive;
extern PCWSTR g_pszArg1UserProfilePath;
extern PCWSTR g_pszArg1UserScriptPath;
extern PCWSTR g_pszArg1UserMustChangePwd;
extern PCWSTR g_pszArg1UserCanChangePwd;
extern PCWSTR g_pszArg1UserReversiblePwd;
extern PCWSTR g_pszArg1UserPwdNeverExpires;
extern PCWSTR g_pszArg1UserDisableAccount;
extern PCWSTR g_pszArg1UserAccountExpires;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerLocation;
extern PCWSTR g_pszArg1ComputerDisabled;
extern PCWSTR g_pszArg1ComputerReset;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupSAMName;
extern PCWSTR g_pszArg1GroupSec;
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupAddMember;
extern PCWSTR g_pszArg1GroupRemoveMember;
extern PCWSTR g_pszArg1GroupChangeMember;

//
// Server switches
//
extern PCWSTR g_pszArg1ServerIsGC;

//
// Quota switches
//
extern PCWSTR g_pszArg1QuotaQLimit;

//
// Partition switches
//
extern PCWSTR g_pszArg1PartitionQDefault;
extern PCWSTR g_pszArg1PartitionQtmbstnwt;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmod\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "commonstrings.cpp"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsmod";

//
// Object types as are typed on the command line
//
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszServer                  = L"server";
PCWSTR g_pszQuota                   = L"quota";
PCWSTR g_pszPartition               = L"partition";

//
// User and Contact switches
//
PCWSTR g_pszArg1UserUPN             = L"upn"; 
PCWSTR g_pszArg1UserFirstName       = L"fn";
PCWSTR g_pszArg1UserMiddleInitial   = L"mi";
PCWSTR g_pszArg1UserLastName        = L"ln";
PCWSTR g_pszArg1UserDisplayName     = L"display";
PCWSTR g_pszArg1UserEmpID           = L"empid";
PCWSTR g_pszArg1UserPassword        = L"pwd";
PCWSTR g_pszArg1UserOffice          = L"office";
PCWSTR g_pszArg1UserTelephone       = L"tel"; 
PCWSTR g_pszArg1UserEmail           = L"email";
PCWSTR g_pszArg1UserHomeTelephone   = L"hometel";
PCWSTR g_pszArg1UserPagerNumber     = L"pager"; 
PCWSTR g_pszArg1UserMobileNumber    = L"mobile"; 
PCWSTR g_pszArg1UserFaxNumber       = L"fax";
PCWSTR g_pszArg1UserIPTel           = L"iptel";
PCWSTR g_pszArg1UserWebPage         = L"webpg";
PCWSTR g_pszArg1UserTitle           = L"title";
PCWSTR g_pszArg1UserDepartment      = L"dept"; 
PCWSTR g_pszArg1UserCompany         = L"company";
PCWSTR g_pszArg1UserManager         = L"mgr";
PCWSTR g_pszArg1UserHomeDirectory   = L"hmdir";
PCWSTR g_pszArg1UserHomeDrive       = L"hmdrv";
PCWSTR g_pszArg1UserProfilePath     = L"profile";
PCWSTR g_pszArg1UserScriptPath      = L"loscr";
PCWSTR g_pszArg1UserMustChangePwd   = L"mustchpwd";
PCWSTR g_pszArg1UserCanChangePwd    = L"canchpwd";
PCWSTR g_pszArg1UserReversiblePwd   = L"reversiblepwd";
PCWSTR g_pszArg1UserPwdNeverExpires = L"pwdneverexpires";
PCWSTR g_pszArg1UserAccountExpires  = L"acctexpires";
PCWSTR g_pszArg1UserDisableAccount  = L"disabled";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerLocation    = L"loc";
PCWSTR g_pszArg1ComputerDisabled    = L"disabled";
PCWSTR g_pszArg1ComputerReset       = L"reset";

//
// Group switches
//
PCWSTR g_pszArg1GroupSAMName        = L"samid";
PCWSTR g_pszArg1GroupSec            = L"secgrp";
PCWSTR g_pszArg1GroupScope          = L"scope";
PCWSTR g_pszArg1GroupAddMember      = L"addmbr";
PCWSTR g_pszArg1GroupRemoveMember   = L"rmmbr";
PCWSTR g_pszArg1GroupChangeMember   = L"chmbr";

//
// Server switches
//
PCWSTR g_pszArg1ServerIsGC          = L"isgc";

//
// Quota switches
//
PCWSTR g_pszArg1QuotaQLimit      = L"qlimit";

//
// Partition switches
//
PCWSTR g_pszArg1PartitionQDefault   = L"qdefault";
PCWSTR g_pszArg1PartitionQtmbstnwt  = L"qtmbstnwt";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsget\output.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      output.h
//
//  Contents:  Header file for classes and function used for display
//
//  History:   3-oct-2000 hiteshr Created
//
//--------------------------------------------------------------------------

#include "gettable.h"

HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString);

//+--------------------------------------------------------------------------
//
//  Class:      CDisplay
//
//  Purpose:    This class is used for displaying a column
//
//  History:    3-oct-2000 hiteshr Created
//
//---------------------------------------------------------------------------

class CDisplay
{
#define MAXPAD 80
public:

    //
    //Initialize the Pad
    //    
    CDisplay()
    {
        PadChar = L' ';
        //Initialize the pad.
        for( int i = 0; i < MAXPAD; ++i)
            Pad[i] = PadChar;
    }

    //
    //Display width number of Pad Charachter
    //
    VOID DisplayPad(LONG width)
    {
        if(width <= 0 )
            return;
        if(width >= MAXPAD)
            width = MAXPAD -1;
        Pad[width] = 0;

        WriteStandardOut(L"%s",Pad);

        Pad[width] = PadChar;
    }
        
    //
    //Dispaly a column with two starting pad,
    //column value and two ending pad
    //
    VOID DisplayColumn(LONG width, PCWSTR lpszValue)
    {
        //Display Two PadChar in the begining
        DisplayPad(2);
        if(lpszValue)
        {
            WriteStandardOut(lpszValue);
			//lpszValue is null terminated.
            DisplayPad(width- static_cast<LONG>(wcslen(lpszValue)));
        }
        else
            DisplayPad(width);

                
        //Display Two Trailing Padchar
        DisplayPad(2);
    }        
    
    //
    //Display Newline
    //    
    VOID DisplayNewLine()
    {
        WriteStandardOut(L"%s",L"\r\n");
    }
private:
    WCHAR Pad[MAXPAD];    
    WCHAR PadChar;

};

//+--------------------------------------------------------------------------
//
//  Class:      CFormatInfo
//
//  Purpose:    Used to format table columns and display table
//
//  History:    17-Oct-2000 JeffJon Created
//
//---------------------------------------------------------------------------
class CFormatInfo
{
public:
   //
   // Constructor
   //
   CFormatInfo();

   //
   // Destructor
   //
   ~CFormatInfo();


   //
   // Public methods
   //
   HRESULT Initialize(DWORD dwSampleSize, bool bShowAsList = false, bool bQuiet = false);
                 
   inline DWORD GetColWidth(DWORD dwColNum)
   { 
      ASSERT(m_bInitialized);
      if(dwColNum >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return 0;
      }
      return m_pColWidth[dwColNum]; 
   }

   inline void SetColWidth(DWORD dwColNum, DWORD dwWidth)
   {
      ASSERT(m_bInitialized);
      if(dwColNum >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return;
      }

      if(dwWidth > m_pColWidth[dwColNum])
      {
         m_pColWidth[dwColNum] = dwWidth;
      }
   }

   HRESULT AddRow(PDSGET_DISPLAY_INFO pDisplayInfo, DWORD dwColumnCount);
   DWORD   GetRowCount() { return m_dwTotalRows; }
    
   inline HRESULT Get(DWORD dwRow, DWORD dwCol, CComBSTR& refsbstrColValue)
   {
      refsbstrColValue.Empty();

      ASSERT(m_bInitialized);
      if(dwRow >= m_dwTotalRows || dwCol >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return E_INVALIDARG;
      }

      refsbstrColValue += m_ppDisplayInfoArray[dwRow][dwCol].GetValue(0);
      for (DWORD dwIdx = 1; dwIdx < m_ppDisplayInfoArray[dwRow][dwCol].GetValueCount(); dwIdx++)
      {
         refsbstrColValue += L";";
         refsbstrColValue += m_ppDisplayInfoArray[dwRow][dwCol].GetValue(dwIdx);
      }

      return S_OK;
   }

   void DisplayHeaders()
   {    
      ASSERT(m_bInitialized);
      if (!m_bQuiet)
      {
         for( DWORD i = 0; i < m_dwNumColumns; ++i)
         {
            m_display.DisplayColumn(GetColWidth(i),m_ppDisplayInfoArray[0][i].GetDisplayName());
         }
         NewLine();
      }
   }

   void DisplayColumn(DWORD dwRow, DWORD dwCol)
   {
      ASSERT(m_bInitialized);
      if(dwRow >= m_dwTotalRows || dwCol >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return ;
      }

      if (!m_bQuiet)
      {
         CComBSTR sbstrValue;
         HRESULT hr  = Get(dwRow, dwCol, sbstrValue);
         if (SUCCEEDED(hr))
         {
            m_display.DisplayColumn(GetColWidth(dwCol), sbstrValue);
         }
      }
   }

   void DisplayColumn(DWORD dwCol, PCWSTR pszValue)
   {
      ASSERT(m_bInitialized);
      if(dwCol >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return;
      }

      if (!m_bQuiet)
      {
         m_display.DisplayColumn(GetColWidth(dwCol), pszValue);
      }
   }

   void Display()
   {
      ASSERT(m_bInitialized);

      if (!m_bListFormat && !m_bQuiet)
      {
         DisplayHeaders();
         for(DWORD i = 0; i < m_dwTotalRows; ++i)
         {
            for(DWORD j = 0; j < m_dwNumColumns; ++j)
            {
               DisplayColumn(i,j);
            }
            NewLine();
         }
      }
   }

   void NewLine() 
   {
      if (!m_bQuiet)
      {
         m_display.DisplayNewLine(); 
      }
   }
   
private:

   //
   // Private data
   //
   bool m_bInitialized;
   bool m_bListFormat;
   bool m_bQuiet;

   //
   //Number of rows to be used for calulating
   //column width. This is also the size of the table.
   //
   DWORD m_dwSampleSize;

   //
   //Count of rows in cache
   //
   DWORD m_dwTotalRows;

   //
   //Number of columns
   //
   DWORD m_dwNumColumns;

   //
   // Array of column widths
   //
   DWORD* m_pColWidth;

   //
   // Array of column header/value pairs
   //
   PDSGET_DISPLAY_INFO* m_ppDisplayInfoArray;

   CDisplay m_display;
};

//+--------------------------------------------------------------------------
//
//  Function:   DsGetOutputValuesList
//
//  Synopsis:   This function gets the values for the columns and then adds
//              the row to the format helper
//
//  Arguments:  [pszDN IN]        : the DN of the object
//              [refBasePathsInfo IN] : reference to path info
//              [refCredentialObject IN] : reference to the credential manager
//              [pCommandArgs IN] : Command line arguments
//              [pObjectEntry IN] : Entry in the object table being processed
//              [pAttrInfo IN]    : the values to display
//              [dwAttrCount IN]  : Number of arributes in above array
//              [spDirObject IN]  : Interface pointer to the object
//              [refFormatInfo IN]: Reference to the format helper
//                                  
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//
//  History:    16-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT DsGetOutputValuesList(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              PARG_RECORD pCommandArgs,
                              PDSGetObjectTableEntry pObjectEntry,
                              DWORD dwAttrCount,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              CFormatInfo& refFormatInfo);

//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromADs
//
//  Synopsis:   Converts Value into string depending upon type
//  Arguments:  [pValues - IN]: Value to be converted to string
//              [dwADsType-IN]: ADSTYPE of pValue
//              [ppBuffer - OUT]:Address of an output buffer which gets the string 
//              [dwBufferLen-IN]:Size of output buffer
//              [pszAttrName-IN]:Name of the attribute being formatted
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR* ppBuffer, 
                         IN PCWSTR pszAttrName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmod\modtable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.cpp
//
//  Contents:  Defines a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "modtable.h"
#include "usage.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSMOD_COMMON_COMMANDS[] = 
{

   COMMON_COMMANDS

   //
   // c  Continue
   //
   0,(PWSTR)c_sz_arg1_com_continue,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0, NULL,

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN,  
   0,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,    
   0,  NULL,

   //
   // description
   //
   0, (PWSTR)c_sz_arg1_com_description,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0, NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSMOD_USER_COMMANDS[]=
{
   //
   // upn
   //
   0, (PWSTR)g_pszArg1UserUPN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // empid  Employee ID
   //
   0, (PWSTR)g_pszArg1UserEmpID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // pwd Password
   //
   0, (PWSTR)g_pszArg1UserPassword, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_PASSWORD, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateUserPassword,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // iptel IP Telephone
   //
   0, (PWSTR)g_pszArg1UserIPTel, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // webpg  Web Page
   //
   0, (PWSTR)g_pszArg1UserWebPage, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mgr Manager
   //
   0, (PWSTR)g_pszArg1UserManager, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // hmdir  Home Directory
   //
   0, (PWSTR)g_pszArg1UserHomeDirectory, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // hmdrv  Home Drive
   //
   0, (PWSTR)g_pszArg1UserHomeDrive, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // profile Profile path
   //
   0, (PWSTR)g_pszArg1UserProfilePath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // loscr Script path
   //
   0, (PWSTR)g_pszArg1UserScriptPath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mustchpwd Must Change Password at next logon
   //
   0, (PWSTR)g_pszArg1UserMustChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   //
   // canchpwd Can Change Password
   //
   0, (PWSTR)g_pszArg1UserCanChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,
   
   //
   // reversiblepwd  Password stored with reversible encryption
   //
   0, (PWSTR)g_pszArg1UserReversiblePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   //
   // pwdneverexpires Password never expires
   //
   0, (PWSTR)g_pszArg1UserPwdNeverExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,
 
   //
   // acctexpires Account Expires
   //
   0, (PWSTR)g_pszArg1UserAccountExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_INTSTR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateNever,
  
   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1UserDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   ARG_TERMINATOR
};

ARG_RECORD DSMOD_COMPUTER_COMMANDS[]=
{
   //
   // loc Location
   //
   0, (PWSTR)g_pszArg1ComputerLocation,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  NULL,

   //
   // disabled
   //
   0, (PWSTR)g_pszArg1ComputerDisabled,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  ValidateYesNo,

   //
   //reset
   //
   0, (PWSTR)g_pszArg1ComputerReset,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   (CMD_TYPE)_T(""),
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSMOD_GROUP_COMMANDS[]=
{
   //
   // samname
   //
   0, (PWSTR)g_pszArg1GroupSAMName,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  NULL,

   //
   // secgrp Security enabled
   //
   0, (PWSTR)g_pszArg1GroupSec,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  ValidateYesNo,

   //
   // scope Group scope (local/global/universal)
   //
   0, (PWSTR)g_pszArg1GroupScope,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  ValidateGroupScope,

   //
   // addmbr  Add a member to the group
   //
   0, (PWSTR)g_pszArg1GroupAddMember,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,
   0,  NULL,

   //
   // rmmbr  Remove a member from the group
   //
   0, (PWSTR)g_pszArg1GroupRemoveMember,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,
   0,  NULL,

   //
   // chmbr  Change the entire membership list
   //
   0, (PWSTR)g_pszArg1GroupChangeMember,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSMOD_CONTACT_COMMANDS[]=
{
   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // iptel IP Telephone
   //
   0, (PWSTR)g_pszArg1UserIPTel, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSMOD_QUOTA_COMMANDS[]=
{
    //
    // qlimit
    //
    0, (PWSTR)g_pszArg1QuotaQLimit,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_INT, ARG_FLAG_OPTIONAL |ARG_FLAG_ATLEASTONE,
    0,
    0, NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSMOD_PARTITION_COMMANDS[]=
{
    //
    // qdefault
    //
    0, (PWSTR)g_pszArg1PartitionQDefault,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_INT, ARG_FLAG_OPTIONAL |ARG_FLAG_ATLEASTONE,
    0,
    0, NULL,

    //
    // qtmbstnwt
    //
    0, (PWSTR)g_pszArg1PartitionQtmbstnwt,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_INT, ARG_FLAG_OPTIONAL |ARG_FLAG_ATLEASTONE,
    0,
    0, NULL,

   ARG_TERMINATOR
};

/*
ARG_RECORD DSMOD_SUBNET_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SUBNET_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SUBNET_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SUBNET_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //site
    IDS_ARG1_SUBNET_SITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_SITE_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SITE_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
        ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SITE_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SITE_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autotopology
    IDS_ARG1_SITE_AUTOTOPOLOGY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_SLINK_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SLINK_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINK_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINK_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINK_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addsite
    IDS_ARG1_SLINK_ADDSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmsite
    IDS_ARG1_SLINK_RMSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //cost
    IDS_ARG1_SLINK_COST, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //repint
    IDS_ARG1_SLINK_REPINT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINK_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_SLINK_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_SLINK_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_SLINKBR_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SLINKBR_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINKBR_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINKBR_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINKBR_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addslink
    IDS_ARG1_SLINKBR_ADDSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmslink
    IDS_ARG1_SLINKBR_RMSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINKBR_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_CONN_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_CONN_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //transport
    IDS_ARG1_CONN_TRANSPORT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //enabled
    IDS_ARG1_CONN_ENABLED, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_CONN_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //manual
    IDS_ARG1_CONN_MANUAL, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_CONN_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_CONN_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};
*/
ARG_RECORD DSMOD_SERVER_COMMANDS[]=
{
   //
   // isGC
   //
   0, (PWSTR)g_pszArg1ServerIsGC, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   ARG_TERMINATOR
};



//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------

//
// Description
//
DSATTRIBUTEDESCRIPTION description =
{
   {
      L"description",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY descriptionEntry =
{
   L"description",
   eCommDescription,
   0,
   &description,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// UPN
//
DSATTRIBUTEDESCRIPTION upn =
{
   {
      L"userPrincipalName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY upnUserEntry =
{
   L"userPrincipalName",
   eUserUpn,
   0,
   &upn,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// First name
//
DSATTRIBUTEDESCRIPTION firstName =
{
   {
      L"givenName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY firstNameUserEntry =
{
   L"givenName",
   eUserFn,
   0,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY firstNameContactEntry =
{
   L"givenName",
   eContactFn,
   0,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Middle Initial
//
DSATTRIBUTEDESCRIPTION middleInitial =
{
   {
      L"initials",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY middleInitialUserEntry =
{
   L"initials",
   eUserMi,
   0,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY middleInitialContactEntry =
{
   L"initials",
   eContactMi,
   0,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Last name
//
DSATTRIBUTEDESCRIPTION lastName =
{
   {
      L"sn",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY lastNameUserEntry =
{
   L"sn",
   eUserLn,
   0,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY lastNameContactEntry =
{
   L"sn",
   eContactLn,
   0,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Display name
//
DSATTRIBUTEDESCRIPTION displayName =
{
   {
      L"displayName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY displayNameUserEntry =
{
   L"displayName",
   eUserDisplay,
   0,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY displayNameContactEntry =
{
   L"displayName",
   eContactDisplay,
   0,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Employee ID
//
DSATTRIBUTEDESCRIPTION employeeID =
{
   {
      L"employeeID",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY employeeIDUserEntry =
{
   L"employeeID",
   eUserEmpID,
   0,
   &employeeID,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Password
//
DSATTRIBUTEDESCRIPTION password =
{
   {
      NULL,
      ADS_ATTR_UPDATE,
      ADSTYPE_INVALID,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY passwordUserEntry =
{
   L"password",
   eUserPwd,
   0,
   &password,
   ResetUserPassword,
   NULL
};

//
// Office
//
DSATTRIBUTEDESCRIPTION office =
{
   {
      L"physicalDeliveryOfficeName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY officeUserEntry =
{
   L"physicalDeliveryOfficeName",
   eUserOffice,
   0,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY officeContactEntry =
{
   L"physicalDeliveryOfficeName",
   eContactOffice,
   0,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Telephone
//
DSATTRIBUTEDESCRIPTION telephone =
{
   {
      L"telephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY telephoneUserEntry =
{
   L"telephoneNumber",
   eUserTel,
   0,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY telephoneContactEntry =
{
   L"telephoneNumber",
   eContactTel,
   0,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Email
//
DSATTRIBUTEDESCRIPTION email =
{
   {
      L"mail",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY emailUserEntry =
{
   L"mail",
   eUserEmail,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &email,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

DSATTRIBUTETABLEENTRY emailContactEntry =
{
   L"mail",
   eContactEmail,
   0,
   &email,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Telephone
//
DSATTRIBUTEDESCRIPTION homeTelephone =
{
   {
      L"homePhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeTelephoneUserEntry =
{
   L"homePhone",
   eUserHometel,
   0,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY homeTelephoneContactEntry =
{
   L"homePhone",
   eContactHometel,
   0,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Pager
//
DSATTRIBUTEDESCRIPTION pager =
{
   {
      L"pager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY pagerUserEntry =
{
   L"pager",
   eUserPager,
   0,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY pagerContactEntry =
{
   L"pager",
   eContactPager,
   0,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Mobile phone
//
DSATTRIBUTEDESCRIPTION mobile =
{
   {
      L"mobile",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY mobileUserEntry =
{
   L"mobile",
   eUserMobile,
   0,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY mobileContactEntry =
{
   L"mobile",
   eContactMobile,
   0,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Fax
//
DSATTRIBUTEDESCRIPTION fax =
{
   {
      L"facsimileTelephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY faxUserEntry =
{
   L"facsimileTelephoneNumber",
   eUserFax,
   0,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY faxContactEntry =
{
   L"facsimileTelephoneNumber",
   eContactFax,
   0,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Title
//
DSATTRIBUTEDESCRIPTION title =
{
   {
      L"title",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY titleUserEntry =
{
   L"title",
   eUserTitle,
   0,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY titleContactEntry =
{
   L"title",
   eContactTitle,
   0,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Department
//
DSATTRIBUTEDESCRIPTION department =
{
   {
      L"department",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY departmentUserEntry =
{
   L"department",
   eUserDept,
   0,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY departmentContactEntry =
{
   L"department",
   eContactDept,
   0,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Company
//
DSATTRIBUTEDESCRIPTION company =
{
   {
      L"company",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY companyUserEntry =
{
   L"company",
   eUserCompany,
   0,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY companyContactEntry =
{
   L"company",
   eContactCompany,
   0,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Web Page
//
DSATTRIBUTEDESCRIPTION webPage =
{
   {
      L"wwwHomePage",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY webPageUserEntry =
{
   L"wwwHomePage",
   eUserWebPage,
   0,
   &webPage,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

//
// IP Phone
//
DSATTRIBUTEDESCRIPTION ipPhone =
{
   {
      L"ipPhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY ipPhoneUserEntry =
{
   L"ipPhone",
   eUserIPPhone,
   0,
   &ipPhone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY ipPhoneContactEntry =
{
   L"ipPhone",
   eContactIPPhone,
   0,
   &ipPhone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Script Path
//
DSATTRIBUTEDESCRIPTION scriptPath =
{
   {
      L"scriptPath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY scriptPathUserEntry =
{
   L"scriptPath",
   eUserScriptPath,
   0,
   &scriptPath,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Directory
//
DSATTRIBUTEDESCRIPTION homeDirectory =
{
   {
      L"homeDirectory",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDirectoryUserEntry =
{
   L"homeDirectory",
   eUserHomeDir,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &homeDirectory,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

//
// Home Drive
//
DSATTRIBUTEDESCRIPTION homeDrive =
{
   {
      L"homeDrive",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDriveUserEntry =
{
   L"homeDrive",
   eUserHomeDrive,
   0,
   &homeDrive,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Profile Path
//
DSATTRIBUTEDESCRIPTION profilePath =
{
   {
      L"profilePath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY profilePathUserEntry =
{
   L"profilePath",
   eUserProfilePath,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &profilePath,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

//
// pwdLastSet
//
DSATTRIBUTEDESCRIPTION pwdLastSet =
{
   {
      L"pwdLastSet",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};
DSATTRIBUTETABLEENTRY mustChangePwdUserEntry =
{
   L"pwdLastSet",
   eUserMustchpwd,
   DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_POSTCREATE,
   &pwdLastSet,
   ChangeMustChangePwd,
   NULL
};

//
// accountExpires
//
DSATTRIBUTEDESCRIPTION accountExpires =
{
   {
      L"accountExpires",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY accountExpiresUserEntry =
{
   L"accountExpires",
   eUserAcctexpires,
   0,
   &accountExpires,
   AccountExpires,
   NULL
};

//
// user account control 
//
DSATTRIBUTEDESCRIPTION userAccountControl =
{
   {
      L"userAccountControl",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY disableComputerEntry =
{
   L"userAccountControl",
   eComputerDisabled,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   DisableAccount,
   NULL
};

DSATTRIBUTETABLEENTRY disableUserEntry =
{
   L"userAccountControl",
   eUserDisabled,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   DisableAccount,
   NULL
};

DSATTRIBUTETABLEENTRY pwdNeverExpiresUserEntry =
{
   L"userAccountControl",
   eUserPwdneverexpires,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   PwdNeverExpires,
   NULL
};

DSATTRIBUTETABLEENTRY reverisblePwdUserEntry =
{
   L"userAccountControl",
   eUserReversiblePwd,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   ReversiblePwd,
   NULL
};

//
// SAM Account Name
//
DSATTRIBUTEDESCRIPTION samAccountName =
{
   {
      L"sAMAccountName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY samNameGroupEntry =
{
   L"sAMAccountName",
   eGroupSamname,
   0,
   &samAccountName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Manager
//
DSATTRIBUTEDESCRIPTION manager =
{
   {
      L"manager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY managerUserEntry =
{
   L"manager",
   eUserManager,
   0,
   &manager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Group Type
//
DSATTRIBUTEDESCRIPTION groupType =
{
   {
      L"groupType",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupScopeTypeEntry =
{
   L"groupType",
   eGroupScope,
   0,
   &groupType,
   ChangeGroupScope,
   NULL
};

DSATTRIBUTETABLEENTRY groupSecurityTypeEntry =
{
   L"groupType",
   eGroupSecgrp,
   0,
   &groupType,
   ChangeGroupSecurity,
   NULL
};

//
// Add Group Members
//
DSATTRIBUTEDESCRIPTION groupAddMember =
{
   {
      L"member",
      ADS_ATTR_APPEND,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupAddMemberEntry =
{
   L"member",
   eGroupAddMember,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &groupAddMember,
   ModifyGroupMembers,
   NULL
};

//
// Remove Group Members
//
DSATTRIBUTEDESCRIPTION groupRemoveMember =
{
   {
      L"member",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupRemoveMemberEntry =
{
   L"member",
   eGroupRemoveMember,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &groupRemoveMember,
   RemoveGroupMembers,
   NULL
};

//
// Change Group Members
//
DSATTRIBUTEDESCRIPTION groupChangeMember =
{
   {
      L"member",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupChangeMemberEntry =
{
   L"member",
   eGroupChangeMember,
   0,
   &groupChangeMember,
   ModifyGroupMembers,
   NULL
};

// Location
//
DSATTRIBUTEDESCRIPTION location =
{
   {
      L"location",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY locationComputerEntry =
{
   L"location",
   eComputerLocation,
   DS_ATTRIBUTE_ONCREATE,
   &location,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// Reset Computer account
//
DSATTRIBUTETABLEENTRY resetComputerEntry =
{
   NULL,
   eComputerReset,
   DS_ATTRIBUTE_NOT_REUSABLE,
   NULL,
   ResetComputerAccount,
   NULL
};

//
// User Can Change Password
//
DSATTRIBUTETABLEENTRY canChangePwdUserEntry =
{
   NULL,
   eUserCanchpwd,
   DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_POSTCREATE,
   NULL,
   ChangeCanChangePassword,
   NULL
};

//
// Server is GC
//
DSATTRIBUTEDESCRIPTION options =
{
   {
      L"options",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY serverIsGCEntry =
{
   L"options",
   eServerIsGC,
   DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_POSTCREATE,
   &options,
   SetIsGC,
   NULL
};

//
// qlimit
//
DSATTRIBUTEDESCRIPTION qlimit =
{
   {
      L"msDS-QuotaAmount",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY qlimitQuotaEntry =
{
   L"qlimit",
   eQuotaQlimit,
   DS_ATTRIBUTE_ONCREATE,
   &qlimit,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// qdefault
//
DSATTRIBUTEDESCRIPTION qdefault =
{
   {
      L"msDS-DefaultQuota",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY QDefaultPartitionEntry =
{
   L"qdefault",
   ePartitionQDefault,
   DS_ATTRIBUTE_ONCREATE,
   &qdefault,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// qtmbstnwt
//
DSATTRIBUTEDESCRIPTION qtmbstnwt =
{
   {
      L"msDS-TombstoneQuotaFactor",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY QtmbstnwtPartitionEntry =
{
   L"qtmbstnwt",
   ePartitionQtmbstnwt,
   DS_ATTRIBUTE_ONCREATE,
   &qtmbstnwt,
   FillAttrInfoFromObjectEntry,
   NULL
};

//+-------------------------------------------------------------------------
// Objects
//--------------------------------------------------------------------------

//
// Organizational Unit
//

PDSATTRIBUTETABLEENTRY OUAttributeTable[] =
{
   &descriptionEntry
};

DSOBJECTTABLEENTRY g_OUObjectEntry = 
{
   L"organizationalUnit",
   g_pszOU,
   NULL,       // Uses just the common switches
   USAGE_DSMOD_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable
};


//
// User
//

PDSATTRIBUTETABLEENTRY UserAttributeTable[] =
{
   &descriptionEntry,
   &upnUserEntry,
   &firstNameUserEntry,
   &middleInitialUserEntry,
   &lastNameUserEntry,
   &displayNameUserEntry,
   &employeeIDUserEntry,
   &passwordUserEntry,
   &officeUserEntry,
   &telephoneUserEntry,
   &emailUserEntry,
   &homeTelephoneUserEntry,
   &pagerUserEntry,
   &mobileUserEntry,
   &faxUserEntry,
   &ipPhoneUserEntry,
   &webPageUserEntry,
   &titleUserEntry,
   &departmentUserEntry,
   &companyUserEntry,
   &managerUserEntry,
   &homeDirectoryUserEntry,
   &homeDriveUserEntry,
   &profilePathUserEntry,
   &scriptPathUserEntry,
   &mustChangePwdUserEntry,
   &canChangePwdUserEntry,
   &reverisblePwdUserEntry,
   &pwdNeverExpiresUserEntry,
   &accountExpiresUserEntry,
   &disableUserEntry,
};

DSOBJECTTABLEENTRY g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSMOD_USER_COMMANDS,
   USAGE_DSMOD_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable
};

//
// Contact
//

PDSATTRIBUTETABLEENTRY ContactAttributeTable[] =
{
   &descriptionEntry,
   &firstNameContactEntry,
   &middleInitialContactEntry,
   &lastNameContactEntry,
   &displayNameContactEntry,
   &officeContactEntry,
   &telephoneContactEntry,
   &emailContactEntry,
   &homeTelephoneContactEntry,
   &pagerContactEntry,
   &mobileContactEntry,
   &faxContactEntry,
   &ipPhoneContactEntry,
   &titleContactEntry,
   &departmentContactEntry,
   &companyContactEntry
};

DSOBJECTTABLEENTRY g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSMOD_CONTACT_COMMANDS,
   USAGE_DSMOD_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable
};

//
// Computer
//

PDSATTRIBUTETABLEENTRY ComputerAttributeTable[] =
{
   &descriptionEntry,
   &locationComputerEntry,
   &disableComputerEntry,
   &resetComputerEntry,
};

DSOBJECTTABLEENTRY g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSMOD_COMPUTER_COMMANDS,
   USAGE_DSMOD_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable
};

//
// Group
//
PDSATTRIBUTETABLEENTRY GroupAttributeTable[] =
{
   &descriptionEntry,
   &samNameGroupEntry,
   &groupScopeTypeEntry,
   &groupSecurityTypeEntry,
   &groupAddMemberEntry,
   &groupRemoveMemberEntry,
   &groupChangeMemberEntry
};

DSOBJECTTABLEENTRY g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSMOD_GROUP_COMMANDS,
   USAGE_DSMOD_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable
};

//
// Server
//
PDSATTRIBUTETABLEENTRY ServerAttributeTable[] =
{
   &descriptionEntry,
   &serverIsGCEntry
};

DSOBJECTTABLEENTRY g_ServerObjectEntry = 
{
   L"server",
   g_pszServer,
   DSMOD_SERVER_COMMANDS,
   USAGE_DSMOD_SERVER,
   sizeof(ServerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ServerAttributeTable
};

//
// Quota
//

PDSATTRIBUTETABLEENTRY QuotaAttributeTable[] =
{
   &descriptionEntry,
   &qlimitQuotaEntry
};

DSOBJECTTABLEENTRY g_QuotaObjectEntry = 
{
   L"msDS-QuotaControl",
   g_pszQuota,
   DSMOD_QUOTA_COMMANDS,
   USAGE_DSMOD_QUOTA,
   sizeof(QuotaAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   QuotaAttributeTable
};

//
// Partition
//

PDSATTRIBUTETABLEENTRY PartitionAttributeTable[] =
{
   &QDefaultPartitionEntry,
   &QtmbstnwtPartitionEntry
};

DSOBJECTTABLEENTRY g_PartitionObjectEntry = 
{
   L"msDS-QuotaContainer",
   g_pszPartition,
   DSMOD_PARTITION_COMMANDS,
   USAGE_DSMOD_PARTITION,
   sizeof(PartitionAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   PartitionAttributeTable
};


//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSOBJECTTABLEENTRY g_DSObjectTable[] =
{
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ContactObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_ServerObjectEntry,
   &g_QuotaObjectEntry,
   &g_PartitionObjectEntry,
   NULL
};
UINT USAGE_DSMOD[] =
{
	USAGE_DSMOD_DESCRIPTION,
	USAGE_DSMOD_REMARKS,
	USAGE_DSMOD_EXAMPLES,
	USAGE_END,
};
UINT USAGE_DSMOD_OU[] =
{
	USAGE_DSMOD_OU_DESCRIPTION,
	USAGE_DSMOD_OU_SYNTAX,
	USAGE_DSMOD_OU_PARAMETERS,
	USAGE_DSMOD_OU_REMARKS,
	USAGE_DSMOD_OU_EXAMPLES,
	USAGE_DSMOD_OU_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_USER[] =
{
	USAGE_DSMOD_USER_DESCRIPTION,
	USAGE_DSMOD_USER_SYNTAX,
	USAGE_DSMOD_USER_PARAMETERS,
	USAGE_DSMOD_USER_REMARKS,
	USAGE_DSMOD_USER_EXAMPLES,
	USAGE_DSMOD_USER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_CONTACT[] =
{
	USAGE_DSMOD_CONTACT_DESCRIPTION,
	USAGE_DSMOD_CONTACT_SYNTAX,
	USAGE_DSMOD_CONTACT_PARAMETERS,
	USAGE_DSMOD_CONTACT_REMARKS,
	USAGE_DSMOD_CONTACT_EXAMPLES,
	USAGE_DSMOD_CONTACT_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_COMPUTER[] =
{
	USAGE_DSMOD_COMPUTER_DESCRIPTION,
	USAGE_DSMOD_COMPUTER_SYNTAX,
	USAGE_DSMOD_COMPUTER_PARAMETERS,
	USAGE_DSMOD_COMPUTER_REMARKS,
	USAGE_DSMOD_COMPUTER_EXAMPLES,
	USAGE_DSMOD_COMPUTER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_GROUP[] =
{
	USAGE_DSMOD_GROUP_DESCRIPTION,
	USAGE_DSMOD_GROUP_SYNTAX,
	USAGE_DSMOD_GROUP_PARAMETERS,
	USAGE_DSMOD_GROUP_REMARKS,
	USAGE_DSMOD_GROUP_EXAMPLES,
	USAGE_DSMOD_GROUP_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_SERVER[] =
{
	USAGE_DSMOD_SERVER_DESCRIPTION,
	USAGE_DSMOD_SERVER_SYNTAX,
	USAGE_DSMOD_SERVER_PARAMETERS,
	USAGE_DSMOD_SERVER_REMARKS,
	USAGE_DSMOD_SERVER_EXAMPLES,
	USAGE_DSMOD_SERVER_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_QUOTA[] = 
{
	USAGE_DSMOD_QUOTA_DESCRIPTION,
	USAGE_DSMOD_QUOTA_SYNTAX,
	USAGE_DSMOD_QUOTA_PARAMETERS,
	USAGE_DSMOD_QUOTA_REMARKS,
	USAGE_DSMOD_QUOTA_SEE_ALSO,
	USAGE_END,
};
UINT USAGE_DSMOD_PARTITION[] = 
{
	USAGE_DSMOD_PARTITION_DESCRIPTION,
	USAGE_DSMOD_PARTITION_SYNTAX,
	USAGE_DSMOD_PARTITION_PARAMETERS,
	USAGE_DSMOD_PARTITION_REMARKS,
	USAGE_DSMOD_PARTITION_SEE_ALSO,
	USAGE_END,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmod\modtable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.h
//
//  Contents:  Declares a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _MODTABLE_H_
#define _MODTABLE_H_

typedef enum DSMOD_COMMAND_ENUM
{
   eCommContinue = eCommLast+1,
   eCommObjectType,
   eCommObjectDNorName,
   eCommDescription,
   eTerminator,

   //
   // User and Contact switches
   //
   eUserUpn = eTerminator,
   eUserFn,
   eUserMi,
   eUserLn,
   eUserDisplay,
   eUserEmpID,
   eUserPwd,
   eUserOffice,
   eUserTel,
   eUserEmail,
   eUserHometel,
   eUserPager,
   eUserMobile,
   eUserFax,
   eUserIPPhone,
   eUserWebPage,
   eUserTitle,
   eUserDept,
   eUserCompany,
   eUserManager,
   eUserHomeDir,
   eUserHomeDrive,
   eUserProfilePath,
   eUserScriptPath,
   eUserMustchpwd,
   eUserCanchpwd,
   eUserReversiblePwd,
   eUserPwdneverexpires,
   eUserAcctexpires,
   eUserDisabled,

   //
   // Contact switches
   //
   eContactFn = eTerminator,
   eContactMi,
   eContactLn,
   eContactDisplay,
   eContactOffice,
   eContactTel,
   eContactEmail,
   eContactHometel,
   eContactPager,
   eContactMobile,
   eContactFax,
   eContactIPPhone,
   eContactTitle,
   eContactDept,
   eContactCompany,

   //
   // Computer switches
   //
   eComputerLocation = eTerminator,
   eComputerDisabled,
   eComputerReset,

   //
   // Group switches
   //
   eGroupSamname = eTerminator,
   eGroupSecgrp,
   eGroupScope,
   eGroupAddMember,
   eGroupRemoveMember,
   eGroupChangeMember,

   //
   // OU doesn't have any additional switches
   //

   //
   // Subnet switches
   //
   eSubnetSite = eTerminator,

   //
   // Site switches
   // 
   eSiteAutotopology = eTerminator,

   //
   // Site Link switches
   //
   eSLinkIp = eTerminator,
   eSLinkSmtp,
   eSLinkAddsite,
   eSLinkRmsite,
   eSLinkCost,
   eSLinkRepint,
   eSLinkAutobacksync,
   eSLinkNotify,

   //
   // Site Link Bridge switches
   //
   eSLinkBrIp = eTerminator,
   eSLinkBrSmtp,
   eSLinkBrAddslink,
   eSLinkBrRmslink,

   //
   // Replication Connection switches
   // 
   eConnTransport = eTerminator,
   eConnEnabled,
   eConnManual,
   eConnAutobacksync,
   eConnNotify,

   //
   // Server switches
   //
   eServerIsGC = eTerminator,

   //
   // Quota switches
   //
   eQuotaQlimit = eTerminator,

   //
   // Partition switches
   //
   ePartitionQDefault = eTerminator,
   ePartitionQtmbstnwt,
};

//
// The parser table
//
extern ARG_RECORD DSMOD_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSOBJECTTABLEENTRY g_DSObjectTable[];

//
//Usage Tables
//
extern UINT USAGE_DSMOD[];
extern UINT USAGE_DSMOD_OU[];
extern UINT USAGE_DSMOD_USER[];
extern UINT USAGE_DSMOD_CONTACT[];
extern UINT USAGE_DSMOD_COMPUTER[];
extern UINT USAGE_DSMOD_GROUP[];
extern UINT USAGE_DSMOD_SERVER[];
extern UINT USAGE_DSMOD_QUOTA[];
extern UINT USAGE_DSMOD_PARTITION[];

#endif //_MODTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmod\dsmod.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsMod.cpp
//
//  Contents:  Defines the main function and parser tables for the DSMod
//             command line utility
//
//  History:   06-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "modtable.h"
#include "resource.h"

//
// Function Declarations
//
HRESULT DoModValidation(PARG_RECORD pCommandArgs, BOOL& bErrorShown);
HRESULT DoMod(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry);


int __cdecl _tmain( VOID )
{

   int argc;
   LPTOKEN pToken = NULL;
   HRESULT hr = S_OK;

   //
   // Initialize COM
   //
   hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
   if (FAILED(hr))
   {
      DisplayErrorMessage(g_pszDSCommandName, 
                          NULL,
                          hr);
      return hr;
   }

   if( !GetCommandInput(&argc,&pToken) )
   {
      PARG_RECORD pNewCommandArgs = 0;

      //
      // False loop
      //
      do
      {
         if(argc == 1)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSMOD,TRUE);
            hr = E_INVALIDARG;
            break;
         }
        
            if(argc == 2)
            {
               if(IsTokenHelpSwitch(pToken + 1))
                {
                    hr = S_OK;
                    DisplayMessage(USAGE_DSMOD,TRUE);
                    break;
                }
         }

         //
         // Find which object table entry to use from
         // the second command line argument
         //
         PDSOBJECTTABLEENTRY pObjectEntry = NULL;
         UINT idx = 0;
         while (true)
         {
            pObjectEntry = g_DSObjectTable[idx];
            if (!pObjectEntry)
            {
               break;
            }

            PWSTR pszObjectType = (pToken+1)->GetToken();
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
               break;
            }
            idx++;
         }

         if (!pObjectEntry)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSMOD);
            hr = E_INVALIDARG;
            break;
         }

         //
         // Now that we have the correct table entry, merge the command line table
         // for this object with the common commands
         //
         hr = MergeArgCommand(DSMOD_COMMON_COMMANDS, 
                              pObjectEntry->pParserTable, 
                              &pNewCommandArgs);
         if (FAILED(hr))
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayErrorMessage(g_pszDSCommandName, L"", hr);
            break;
         }

         if (!pNewCommandArgs)
         {
            //
            // Display the usage text and then break out of the false loop
            //
            DisplayMessage(pObjectEntry->nUsageID);
            hr = E_FAIL;
            break;
         }

         PARSE_ERROR Error;
         if(!ParseCmd(g_pszDSCommandName,
                      pNewCommandArgs,
                      argc-1, 
                      pToken+1,
                      pObjectEntry->nUsageID, 
                      &Error,
                      TRUE))
         {
            //ParseCmd did not display any error. Error should
            //be handled here. Check DisplayParseError for the
            //cases where Error is not shown by ParseCmd

            if(Error.ErrorSource == ERROR_FROM_PARSER &&
               Error.Error == PARSE_ERROR_ATLEASTONE_NOTDEFINED)
            {
                //Show DSMOD specific error.
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    S_OK, // do not display in error message
                                    IDS_ERRMSG_ATLEASTONE);
                break;
            }
            else if(!Error.MessageShown)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                break;
            }
            
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                break;            
            }

            hr = E_INVALIDARG;
            break;
         }
         else
         {
            //
            // Check to see if we are doing debug spew
            //
#ifdef DBG
            bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                              pNewCommandArgs[eCommDebug].nValue;
            if (bDebugging)
            {
               ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
            }
#else
            DISABLE_DEBUG_OUTPUT();
#endif
            //
            // Be sure that mutually exclusive and dependent switches are correct
            //
            BOOL bErrorShown = FALSE;
            hr = DoModValidation(pNewCommandArgs, bErrorShown);
            if (FAILED(hr))
            {
               DisplayErrorMessage(g_pszDSCommandName, 0, hr);
               break;
            }

            //
            // Command line parsing succeeded
            //
            hr = DoMod(pNewCommandArgs, pObjectEntry);
         }

      } while (false);

      //
      // Free the memory associated with the command values
      //
      if (pNewCommandArgs)
      {
         FreeCmd(pNewCommandArgs);
      }

      //
      // Free the tokens
      //
      if (pToken)
      {
         delete[] pToken;
         pToken = 0;
      }
   }

   //
   // Uninitialize COM
   //
   ::CoUninitialize();

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoModValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both presetn
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [bErrorShown - OUT] : set to true if an error was shown
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    19-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoModValidation(PARG_RECORD pCommandArgs, BOOL& bErrorShown)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoModValidation, hr);

   do // false loop
   {
      // Check to be sure the server and domain switches
      // are mutually exclusive

      if (pCommandArgs[eCommServer].bDefined &&
          pCommandArgs[eCommDomain].bDefined)
      {
         hr = E_INVALIDARG;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr, IDS_NO_SERVER_AND_DOMAIN);
         bErrorShown = TRUE;
         break;
      }

      //
      // Check the user switches
      //
      if (pCommandArgs[eCommObjectType].bDefined &&
          pCommandArgs[eCommObjectType].strValue &&
          0 == _wcsicmp(g_pszUser, pCommandArgs[eCommObjectType].strValue))
      {
         //
         // Can't have user must change password if user can change password is no
         //
         if ((pCommandArgs[eUserMustchpwd].bDefined &&
              pCommandArgs[eUserMustchpwd].bValue) &&
             (pCommandArgs[eUserCanchpwd].bDefined &&
              !pCommandArgs[eUserCanchpwd].bValue))
         {
            DisplayErrorMessage(g_pszDSCommandName, NULL, S_OK, IDS_MUSTCHPWD_CANCHPWD_CONFLICT);
            hr = E_INVALIDARG;
            break;
         }

      }

      if (pCommandArgs[eCommObjectType].bDefined &&
          pCommandArgs[eCommObjectType].strValue &&
          0 == _wcsicmp(g_pszGroup, pCommandArgs[eCommObjectType].strValue))
      {
         if (pCommandArgs[eGroupAddMember].bDefined &&
             (!pCommandArgs[eGroupAddMember].strValue ||
              !pCommandArgs[eGroupAddMember].strValue[0]))
         {
            hr = E_INVALIDARG;
            break;
         }

         if (pCommandArgs[eGroupRemoveMember].bDefined &&
             (!pCommandArgs[eGroupRemoveMember].strValue ||
              !pCommandArgs[eGroupRemoveMember].strValue[0]))
         {
            hr = E_INVALIDARG;
            break;
         }

         if (pCommandArgs[eGroupChangeMember].bDefined &&
             (!pCommandArgs[eGroupChangeMember].strValue ||
              !pCommandArgs[eGroupChangeMember].strValue[0]))
         {
            hr = E_INVALIDARG;
            break;
         }
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoMod
//
//  Synopsis:   Finds the appropriate object in the object table and fills in
//              the attribute values and then applies the changes
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoMod(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoMod, hr);

   PADS_ATTR_INFO pAttrs = NULL;
   PWSTR pszPartitionDN = NULL;

   do // false loop
   {
      if (!pCommandArgs || !pObjectEntry)
      {
         ASSERT(pCommandArgs && pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      //
      // The DNs or Names should be given as a \0 separated list
      // So parse it and loop through each object
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(pCommandArgs[eCommObjectDNorName].strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         //
         // Display the usage text and then fail
         //
         hr = E_INVALIDARG;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr);
         break;
      }

      // Make sure all the DNs actually have DN syntax

      bool bContinue = pCommandArgs[eCommContinue].bDefined &&
                       pCommandArgs[eCommContinue].bValue;

      UINT nValidDNs = ValidateDNSyntax(ppszArray, nStrings);
      if (nValidDNs < nStrings && !bContinue)
      {
         hr = E_ADS_BAD_PATHNAME;
         DisplayErrorMessage(g_pszDSCommandName, 0, hr);
         break;
      }

      CDSCmdCredentialObject credentialObject;
      if (pCommandArgs[eCommUserName].bDefined)
      {
         credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      if (pCommandArgs[eCommPassword].bDefined)
      {
        credentialObject.SetEncryptedPassword(&pCommandArgs[eCommPassword].encryptedDataBlob);
        credentialObject.SetUsingCredentials(true);
      }

      //
      // Initialize the base paths info from the command line args
      // 
      CDSCmdBasePathsInfo basePathsInfo;
      if (pCommandArgs[eCommServer].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommServer].strValue,
                                               true);
      }
      else if (pCommandArgs[eCommDomain].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommDomain].strValue,
                                               false);
      }
      else
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
      }

      if (FAILED(hr))
      {
         //
         // Display error message and return
         //
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"CDSBasePathsInfo::InitializeFromName failed: hr = 0x%x", hr);
         DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
         break;
      }

      //
      // Now that we have the table entry loop through the other command line
      // args and see which ones can be applied
      //
      DWORD dwAttributeCount = 0;
      DWORD dwCount = pObjectEntry->dwAttributeCount; 
      pAttrs = new ADS_ATTR_INFO[dwCount];
      if (!pAttrs)
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, E_OUTOFMEMORY);
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Loop through each of the objects
      //
      for (UINT nNameIdx = 0; nNameIdx < nStrings; nNameIdx++)
      {
         dwAttributeCount = 0;
         do // false loop
         {
            //
            // Get the objects DN
            //
            PWSTR pszObjectDN = ppszArray[nNameIdx];
            if (!pszObjectDN)
            {
               //
               // Display the usage text and then fail
               //
               hr = E_INVALIDARG;
               DisplayErrorMessage(g_pszDSCommandName, 0, hr);
               break;
            }

            // If partition object then look at first DN and then munge it
            if(0 == lstrcmpi(pObjectEntry->pszCommandLineObjectType, g_pszPartition))
            {                
                // Validate the partition and get the DN to the NTDS Quotas Container
                hr = GetQuotaContainerDN(basePathsInfo, credentialObject, 
                        pszObjectDN, &pszPartitionDN);

                if(FAILED(hr))
                {
                    hr = E_INVALIDARG;
                    DisplayErrorMessage(g_pszDSCommandName, 
                                        NULL,
                                        hr,
                                        IDS_ERRMSG_NO_QUOTAS_CONTAINER);
                    break;
                }

                // Replace the object pointer with the new partition container DN
                pszObjectDN = pszPartitionDN;            
            }

            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Object DN = %s", pszObjectDN);

            //
            // Compose the objects path
            //
            CComBSTR sbstrObjectPath;
            basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);

            //
            // Verify that the object type matches the one entered on the command line
            //
            CComPtr<IDirectoryObject> spDirObject;
            hr = DSCmdOpenObject(credentialObject,
                                 sbstrObjectPath,
                                 IID_IDirectoryObject,
                                 (void**)&spDirObject,
                                 true);

            if (FAILED(hr))
            {
               //
               // Display error message and return
               //
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               break;
            }

            CComQIPtr<IADs> spADs(spDirObject);
            if (!spADs)
            {
               ASSERT(spADs);
               hr = E_INVALIDARG;
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               break;
            }


            CComBSTR sbstrClass;
            hr = spADs->get_Class(&sbstrClass);
            if (FAILED(hr))
            {
               //
               // Display error message and return
               //
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               break;
            }

            // 602981-2002/04/24-JonN allow inetorgperson
            if (_wcsicmp(sbstrClass, pObjectEntry->pszObjectClass)
                && ( _wcsicmp(pObjectEntry->pszObjectClass,L"user")
                  || _wcsicmp(sbstrClass,L"inetorgperson"))
                // 661841-2002/07/11-JonN fix OU bug
                && ( _wcsicmp(pObjectEntry->pszObjectClass,L"ou")
                  || _wcsicmp(sbstrClass,L"organizationalUnit"))
               )
            {
               //
               // Display error message and return
               //
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Command line type does not match object class");
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"command line type = %s", pCommandArgs[eCommObjectType].strValue);
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"object class = %s", sbstrClass);

               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr,
                                   IDS_ERRMSG_CLASS_NOT_EQUAL);
               hr = E_INVALIDARG;
               break;
            }

            UINT nModificationsAttempted = 0;
            for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
            {
               ASSERT(pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc);

               UINT nAttributeIdx = pObjectEntry->pAttributeTable[dwIdx]->nAttributeID;

               if (pCommandArgs[nAttributeIdx].bDefined)
               {
                  if (!(pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_DIRTY) ||
                      pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE)
                  {
                     //
                     // Call the evaluation function to get the ADS_ATTR_INFO set
                     //
                     PADS_ATTR_INFO pNewAttr = NULL;
                     hr = pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc(pszObjectDN,
                                                                          basePathsInfo,
                                                                          credentialObject,
                                                                          pObjectEntry, 
                                                                          pCommandArgs[nAttributeIdx],
                                                                          dwIdx, 
                                                                          &pNewAttr);
                     DEBUG_OUTPUT(MINIMAL_LOGGING, L"pEvalFunc returned hr = 0x%x", hr);
                     if (SUCCEEDED(hr) && hr != S_FALSE)
                     {
                        if (pNewAttr)
                        {
                           //
                           // Mark the attribute entry as DIRTY so that we don't have to 
                           // do the computation for the next object
                           //
                           pObjectEntry->pAttributeTable[dwIdx]->dwFlags |= DS_ATTRIBUTE_DIRTY;

                           //
                           // Copy the value
                           //
                           pAttrs[dwAttributeCount] = *pNewAttr;
                           dwAttributeCount++;
                        }
                     }
                     else
                     {
                        //
                        // Don't show an error if the eval function returned S_FALSE
                        //
                        if (hr != S_FALSE)
                        {
                           //
                           // Display an error
                           //
                           DisplayErrorMessage(g_pszDSCommandName,
                                               pszObjectDN,
                                               hr);
                        }
            
                        if (hr == S_FALSE)
                        {
                           //
                           // Return a generic error code so that we don't print the success message
                           //
                           hr = E_FAIL;
                        }
                        break;           
                     }
                  }
                  else
                  {
                    //
                    // Need to count previously retrieved values too
                    //
                    dwAttributeCount++;
                  }
                  nModificationsAttempted++;
               }
            }

            if (SUCCEEDED(hr) && dwAttributeCount > 0)
            {
               //
               // Now that we have the attributes ready, lets set them in the DS
               //

               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Setting %d attributes", dwAttributeCount);
   #ifdef DBG
               DEBUG_OUTPUT(FULL_LOGGING, L"Modified Attributes:");
               SpewAttrs(pAttrs, dwAttributeCount);
   #endif

               DWORD dwAttrsModified = 0;
               hr = spDirObject->SetObjectAttributes(pAttrs, 
                                                     dwAttributeCount,
                                                     &dwAttrsModified);
               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"SetObjectAttributes failed: hr = 0x%x", hr);

                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break;
               }
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"SetObjectAttributes succeeded");
            }
            else if (SUCCEEDED(hr) && nModificationsAttempted == 0)
            {
               //
               // Display the usage text and then break out of the false loop
               //
               hr = E_INVALIDARG;
               DisplayErrorMessage(g_pszDSCommandName, 0, hr);
               break;
            }
         } while (false);

         //
         // Loop through the attributes again, clearing any values for 
         // attribute entries that are marked DS_ATTRIBUTE_NOT_REUSABLE
         //
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Cleaning up memory and flags for object %d", nNameIdx);
         for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
         {
            if (pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE)
            {
               if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc &&
                   ((pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ) ||
                    (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_DIRTY)))
               {
                  //
                  // Cleanup the memory associated with the value
                  //
                  if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues)
                  {
                     delete[] pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues;
                     pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues = NULL;
                  }

                  //
                  // Cleanup the flags so that the attribute will be read for the next object
                  //
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_READ);
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_DIRTY);

                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Flags for attribute %s = %d",
                               pObjectEntry->pAttributeTable[dwIdx]->pszName,
                               pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags);
               }
            }
         }

         if (FAILED(hr) && !pCommandArgs[eCommContinue].bDefined)
         {
            break;
         }

         //
         // Display the success message
         //
         if (SUCCEEDED(hr) && !pCommandArgs[eCommQuiet].bDefined)
         {
            DisplaySuccessMessage(g_pszDSCommandName,
                                  ppszArray[nNameIdx]);
         }

         // If we alloc'd a partition DN, then free it
         if(pszPartitionDN)
         {
             LocalFree(pszPartitionDN);
             pszPartitionDN = NULL;
         }

      } // Name for loop
   } while (false);

    // If we alloc'd a partition DN, then free it
    if(pszPartitionDN)
    {
        LocalFree(pszPartitionDN);
        pszPartitionDN = NULL;
    }

   //
   // Cleanup
   //
   if (pAttrs)
   {
      delete[] pAttrs;
      pAttrs = NULL;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmod\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsmod.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_PASSWORD_TOO_LONG           101
#define IDS_ERRMSG_CLASS_NOT_EQUAL      102
#define IDS_ERRMSG_ATLEASTONE           103
#define IDS_ERRMSG_NO_QUOTAS_CONTAINER  104
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmove\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

#include "commonstrings.h"

extern PCWSTR c_sz_arg1_com_newparent;
extern PCWSTR c_sz_arg1_com_newname;
extern PCWSTR g_pszDSCommandName;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmove\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "commonstrings.cpp"

PCWSTR c_sz_arg1_com_newparent   = L"newparent";
PCWSTR c_sz_arg1_com_newname     = L"newname";
PCWSTR g_pszDSCommandName        = L"dsmove";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmove\movetable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.cpp
//
//  Contents:  Defines a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "movetable.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------
ARG_RECORD DSMOVE_COMMON_COMMANDS[] = 
{
   COMMON_COMMANDS

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,
   NULL,    
   0,  NULL,

   //
   // newparent
   //
   0, (PWSTR)c_sz_arg1_com_newparent,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // newname
   //
   0, (PWSTR)c_sz_arg1_com_newname,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,


   ARG_TERMINATOR
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmove\movetable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.h
//
//  Contents:  Declares a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _MOVETABLE_H_
#define _MOVETABLE_H_

typedef enum DSRM_COMMAND_ENUM
{
   eCommObjectDN = eCommLast+1,   
   eCommNewParent,
   eCommNewName,
   eTerminator
};

//
// The parser table
//
extern ARG_RECORD DSMOVE_COMMON_COMMANDS[];

#endif //_MOVETABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmove\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsmod.rc
//

#define IDS_PARENT_OR_NAME_REQUIRED 100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   24-Sep-2000    hiteshr  Created
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "commonstrings.cpp"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsquery";

//
// Object types as are typed on the command line
//
PCWSTR g_pszStar                    = L"*";
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszServer                  = L"server";
PCWSTR g_pszSite                    = L"site";
PCWSTR g_pszSubnet					= L"subnet";
PCWSTR g_pszQuota                   = L"quota";
PCWSTR g_pszPartition               = L"partition";

PCWSTR c_sz_arg1_com_recurse        = L"r";
PCWSTR c_sz_arg1_com_gc             = L"gc";
PCWSTR c_sz_arg1_com_output         = L"o";
PCWSTR c_sz_arg1_com_startnode      = L"startnode";
PCWSTR c_sz_arg1_com_limit          = L"limit";

//
// Star switches
//
PCWSTR g_pszArg1StarScope           = L"scope";
PCWSTR g_pszArg1StarFilter          = L"filter";
PCWSTR g_pszArg1StarAttr            = L"attr";
PCWSTR g_pszArg1StarAttrsOnly       = L"attrsonly";
PCWSTR g_pszArg1StarList            = L"l";

//
// User switches
//
PCWSTR g_pszArg1UserScope           = L"scope"; 
PCWSTR g_pszArg1UserName            = L"name";
PCWSTR g_pszArg1UserDesc            = L"desc"; 
PCWSTR g_pszArg1UserUpn             = L"upn";
PCWSTR g_pszArg1UserSamid           = L"samid"; 
PCWSTR g_pszArg1UserInactive        = L"inactive";
PCWSTR g_pszArg1UserDisabled        = L"disabled";
PCWSTR g_pszArg1UserStalepwd        = L"stalepwd";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerScope           = L"scope"; 
PCWSTR g_pszArg1ComputerName            = L"name";
PCWSTR g_pszArg1ComputerDesc            = L"desc"; 
PCWSTR g_pszArg1ComputerSamid           = L"samid"; 
PCWSTR g_pszArg1ComputerInactive        = L"inactive";
PCWSTR g_pszArg1ComputerDisabled        = L"disabled";
PCWSTR g_pszArg1ComputerStalepwd        = L"stalepwd";

//
// Group switches
//
PCWSTR g_pszArg1GroupScope           = L"scope"; 
PCWSTR g_pszArg1GroupName            = L"name";
PCWSTR g_pszArg1GroupDesc            = L"desc"; 
PCWSTR g_pszArg1GroupSamid           = L"samid"; 

//
// Ou switches
//
PCWSTR g_pszArg1OUScope           = L"scope"; 
PCWSTR g_pszArg1OUName            = L"name";
PCWSTR g_pszArg1OUDesc            = L"desc"; 

//
// Server switches
//
PCWSTR g_pszArg1ServerForest      = L"forest";
PCWSTR g_pszArg1ServerSite        = L"site";
PCWSTR g_pszArg1ServerName        = L"name";
PCWSTR g_pszArg1ServerDesc        = L"desc";
PCWSTR g_pszArg1ServerHasFSMO     = L"hasfsmo";
PCWSTR g_pszArg1ServerIsGC        = L"isgc";

//
// Site switches
//
PCWSTR g_pszArg1SiteName            = L"name";
PCWSTR g_pszArg1SiteDesc            = L"desc"; 

//
// Subnet switches
//
PCWSTR g_pszArg1SubnetName			= L"name";
PCWSTR g_pszArg1SubnetDesc			= L"desc";
PCWSTR g_pszArg1SubnetLoc			= L"loc";
PCWSTR g_pszArg1SubnetSite			= L"site";

//
// Quota switches
//
PCWSTR g_pszArg1QuotaAcct       = L"acct";
PCWSTR g_pszArg1QuotaQLimit     = L"qlimit";
PCWSTR g_pszArg1QuotaDesc       = L"desc";

//
// Partition switches
//
PCWSTR g_pszArg1PartitionPart   = L"part";
PCWSTR g_pszArg1PartitionDesc   = L"desc";

//
// Valid Output formats{dn, rdn, upn, samid, ntlmid} 
//
PCWSTR g_pszDN      = L"dn";
PCWSTR g_pszRDN     = L"rdn";
PCWSTR g_pszUPN     = L"upn";
PCWSTR g_pszSamId   = L"samid";
PCWSTR g_pszNtlmId  = L"ntlmid";

//
//Valid Scope Strings
//
PCWSTR g_pszSubTree  = L"subtree";
PCWSTR g_pszOneLevel = L"onelevel";
PCWSTR g_pszBase     = L"base";


//Default Filter and Prefix filter
PCWSTR g_pszDefStarFilter     = L"(objectClass=*)";
PCWSTR g_pszDefUserFilter     = L"&(objectCategory=person)(objectClass=user)";
PCWSTR g_pszDefComputerFilter = L"&(objectCategory=Computer)";
PCWSTR g_pszDefGroupFilter    = L"&(objectCategory=Group)";
PCWSTR g_pszDefOUFilter       = L"&(objectCategory=organizationalUnit)";
PCWSTR g_pszDefServerFilter   = L"&(objectCategory=server)";
PCWSTR g_pszDefSiteFilter     = L"&(objectCategory=site)";
PCWSTR g_pszDefSubnetFilter   = L"&(objectCategory=subnet)";
PCWSTR g_pszDefContactFilter  = L"&(objectCategory=person)(objectClass=contact)";
PCWSTR g_pszDefQuotaFilter    = L"&(objectCategory=msDS-QuotaControl)";
PCWSTR g_pszDefPartitionFilter= L"&(objectClass=crossRef)";

//Valid start node values
PCWSTR g_pszDomainRoot = L"domainroot";
PCWSTR g_pszForestRoot = L"forestroot";
PCWSTR g_pszSiteRoot   = L"site";



//Attributes to fetch
PCWSTR g_szAttrDistinguishedName = L"distinguishedName";
PCWSTR g_szAttrUserPrincipalName = L"userPrincipalName";
PCWSTR g_szAttrSamAccountName = L"sAMAccountName";
PCWSTR g_szAttrRDN = L"name";
PCWSTR g_szAttrServerReference = L"serverReference";
PCWSTR g_szAttrNCName = L"nCName";

// FSMOs
PCWSTR g_pszSchema    = L"schema";
PCWSTR g_pszName      = L"name";
PCWSTR g_pszInfr      = L"infr";
PCWSTR g_pszPDC       = L"pdc";
PCWSTR g_pszRID       = L"rid";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsmove\dsmove.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsmove.cpp
//
//  Contents:  Defines the main function and parser tables for the dsmove
//             command line utility
//
//  History:   06-Sep-2000    hiteshr Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "stdio.h"
#include "cstrings.h"
#include "usage.h"
#include "movetable.h"
#include "resource.h"

//
//Usage Table for Dsmove
//
UINT USAGE_DSMOVE[] =
{
    USAGE_DSMOVE_DESCRIPTION,
    USAGE_DSMOVE_SYNTAX,
    USAGE_DSMOVE_PARAMETERS,
    USAGE_DSMOVE_REMARKS,
    USAGE_DSMOVE_EXAMPLES,
    USAGE_END,
};

//
// Function Declarations
//
HRESULT DoMove();
HRESULT DoMoveValidation();

int __cdecl _tmain( VOID )
{

    int argc;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if(FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        goto exit_gracefully;
    }
    
    if( !GetCommandInput(&argc,&pToken) )
    {
        if(argc == 1)
        {
            DisplayMessage(USAGE_DSMOVE,TRUE);
            hr = E_INVALIDARG;
            goto exit_gracefully;
        }


        PARSE_ERROR Error;
        if(!ParseCmd(g_pszDSCommandName,
                     DSMOVE_COMMON_COMMANDS,
                     argc-1, 
                     pToken+1,
                     USAGE_DSMOVE, 
                     &Error,
                     TRUE))
        {
            //ParseCmd did not display any error. Error should
            //be handled here. Check DisplayParseError for the
            //cases where Error is not shown by ParseCmd
            if(!Error.MessageShown)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                goto exit_gracefully;
            }
            
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                goto exit_gracefully;            
            }

            hr = E_INVALIDARG;
            goto exit_gracefully;
        }
        else
        {
            hr =DoMoveValidation();
            if(FAILED(hr))
            {
                goto exit_gracefully;
            }
             //
             // Command line parsing succeeded
             //
             hr = DoMove();
        }
    }

exit_gracefully:

    //
    // Display the success message
    //
    if (SUCCEEDED(hr) && !DSMOVE_COMMON_COMMANDS[eCommQuiet].bDefined)
    {
        DisplaySuccessMessage(g_pszDSCommandName,
                              DSMOVE_COMMON_COMMANDS[eCommObjectDN].strValue);
    }

    // Free Command Array
    FreeCmd(DSMOVE_COMMON_COMMANDS);
    // Free Token
    if(pToken)
        delete []pToken;

    //
    // Uninitialize COM
    //
    CoUninitialize();

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   DoMoveValidation
//
//  Synopsis:   Does advanced switch dependency validation which parser cannot do.
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        
//  History:    07-Sep-2000   Hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT DoMoveValidation()
{
    HRESULT hr = S_OK;

    // Check to be sure the server and domain switches
    // are mutually exclusive

    if (DSMOVE_COMMON_COMMANDS[eCommServer].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommDomain].bDefined)
    {
       hr = E_INVALIDARG;
       DisplayErrorMessage(g_pszDSCommandName, 
                           NULL,
                           hr);
       return hr;
    }

    if(!DSMOVE_COMMON_COMMANDS[eCommNewParent].bDefined &&
       !DSMOVE_COMMON_COMMANDS[eCommNewName].bDefined )
    {
        hr = E_INVALIDARG;
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr,
                            IDS_PARENT_OR_NAME_REQUIRED);
        return hr;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoMove
//
//  Synopsis:   Finds the appropriate object in the object table and fills in
//              the attribute values and then applies the changes
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoMove()
{
    HRESULT hr = S_OK;

    PWSTR pszObjectDN = DSMOVE_COMMON_COMMANDS[eCommObjectDN].strValue;
    if (!pszObjectDN)
    {
        return E_INVALIDARG;
    }    

    CDSCmdCredentialObject credentialObject;
    if (DSMOVE_COMMON_COMMANDS[eCommUserName].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommUserName].strValue)
    {
        credentialObject.SetUsername(DSMOVE_COMMON_COMMANDS[eCommUserName].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    if (DSMOVE_COMMON_COMMANDS[eCommPassword].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommPassword].strValue)
    {
        //Security Review:pCommandArgs[eCommPassword].strValue is encrypted.
        //Decrypt pCommandArgs[eCommPassword].strValue  and then pass it to the
        //credentialObject.SetPassword. 
        //See NTRAID#NTBUG9-571544-2000/11/13-hiteshr

        credentialObject.SetEncryptedPassword(&DSMOVE_COMMON_COMMANDS[eCommPassword].encryptedDataBlob);
        credentialObject.SetUsingCredentials(true);
    }


    //
    // Initialize the base paths info from the command line args
    // 
    CDSCmdBasePathsInfo basePathsInfo;
    if (DSMOVE_COMMON_COMMANDS[eCommServer].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommServer].strValue)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                              DSMOVE_COMMON_COMMANDS[eCommServer].strValue,
                                              true);
    }
    else if (DSMOVE_COMMON_COMMANDS[eCommDomain].bDefined &&
             DSMOVE_COMMON_COMMANDS[eCommDomain].strValue)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                                DSMOVE_COMMON_COMMANDS[eCommDomain].strValue,
                                                false);
    }
    else
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
    }
    if (FAILED(hr))
    {
        //
        // Display error message and return
        //
        DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
        return hr;
    }

    CComBSTR sbstrObjectPath;    
    basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);


    //Get The ParentObjectPath
    CComBSTR sbstrParentObjectPath;
    if(DSMOVE_COMMON_COMMANDS[eCommNewParent].bDefined &&
       DSMOVE_COMMON_COMMANDS[eCommNewParent].strValue )
    {
        LPWSTR szParentDN = DSMOVE_COMMON_COMMANDS[eCommNewParent].strValue;
        basePathsInfo.ComposePathFromDN(szParentDN, sbstrParentObjectPath);
    }
    else
    {
        CPathCracker pathCracker;
        CComBSTR sbstrParentDN;
        hr = pathCracker.GetParentDN(pszObjectDN, sbstrParentDN);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
            return hr;
        }
        basePathsInfo.ComposePathFromDN(sbstrParentDN,sbstrParentObjectPath);
    }

    //
    //Get the RDN for NewName. User enters the only name. We need to convert it
    //into cn=name or ou=name format. To do this strip the leaf node from the
    //objectDN and replace the string after "=" by NewName
    //
    CComBSTR sbstrNewName;
    if(DSMOVE_COMMON_COMMANDS[eCommNewName].bDefined &&
       DSMOVE_COMMON_COMMANDS[eCommNewName].strValue )
    {
        CPathCracker pathCracker;
        CComBSTR sbstrLeafNode;
        hr = pathCracker.GetObjectRDNFromDN(pszObjectDN,sbstrLeafNode);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
            return hr;
        }
        sbstrNewName.Append(sbstrLeafNode,3);
        //Enclose the name in quotes to allow for special names like
        //test1,ou=ou1 NTRAID#NTBUG9-275556-2000/11/13-hiteshr
        sbstrNewName.Append(L"\"");
        sbstrNewName.Append(DSMOVE_COMMON_COMMANDS[eCommNewName].strValue);       
        sbstrNewName.Append(L"\"");
    }
    
    //Get IADsContainer pointer
    CComPtr<IADsContainer> spDsContainer;
    hr = DSCmdOpenObject(credentialObject,
                         sbstrParentObjectPath,
                         IID_IADsContainer,
                         (void**)&spDsContainer,
                         true);

    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
        return hr;
    }
    IDispatch * pDispObj = NULL;
    hr = spDsContainer->MoveHere(sbstrObjectPath,
                                 sbstrNewName,
                                 &pDispObj);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
        return hr;
    }

    if(pDispObj)
    {
        pDispObj->Release();
        pDispObj = NULL;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   24-Sep-2000    hiteshr  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

#include "commonstrings.h"

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszStar;
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;   
extern PCWSTR g_pszServer;
extern PCWSTR g_pszSite;
extern PCWSTR g_pszSubnet;
extern PCWSTR g_pszQuota;
extern PCWSTR g_pszPartition;

extern PCWSTR c_sz_arg1_com_objecttype;
extern PCWSTR c_sz_arg1_com_recurse;
extern PCWSTR c_sz_arg1_com_gc;
extern PCWSTR c_sz_arg1_com_output;
extern PCWSTR c_sz_arg1_com_startnode;
extern PCWSTR c_sz_arg1_com_limit;
;
//;
// Star switches;
//
extern PCWSTR g_pszArg1StarScope;
extern PCWSTR g_pszArg1StarFilter;
extern PCWSTR g_pszArg1StarAttr;
extern PCWSTR g_pszArg1StarAttrsOnly;
extern PCWSTR g_pszArg1StarList;

//
// User switches
//
extern PCWSTR g_pszArg1UserScope;
extern PCWSTR g_pszArg1UserName;
extern PCWSTR g_pszArg1UserDesc;
extern PCWSTR g_pszArg1UserUpn;
extern PCWSTR g_pszArg1UserSamid;
extern PCWSTR g_pszArg1UserInactive;
extern PCWSTR g_pszArg1UserDisabled;
extern PCWSTR g_pszArg1UserStalepwd;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerScope;
extern PCWSTR g_pszArg1ComputerName;
extern PCWSTR g_pszArg1ComputerDesc;
extern PCWSTR g_pszArg1ComputerSamid;
extern PCWSTR g_pszArg1ComputerInactive;
extern PCWSTR g_pszArg1ComputerDisabled;
extern PCWSTR g_pszArg1ComputerStalepwd;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupName;
extern PCWSTR g_pszArg1GroupDesc;
extern PCWSTR g_pszArg1GroupSamid;

//
// Ou switches
//
extern PCWSTR g_pszArg1OUScope;
extern PCWSTR g_pszArg1OUName;
extern PCWSTR g_pszArg1OUDesc;

//
// Server switches
//
extern PCWSTR g_pszArg1ServerForest;
extern PCWSTR g_pszArg1ServerSite;
extern PCWSTR g_pszArg1ServerName;
extern PCWSTR g_pszArg1ServerDesc;
extern PCWSTR g_pszArg1ServerHasFSMO;
extern PCWSTR g_pszArg1ServerIsGC;

//
// Site switches
//
extern PCWSTR g_pszArg1SiteName;
extern PCWSTR g_pszArg1SiteDesc;

//
// Subnet switches
//
extern PCWSTR g_pszArg1SubnetName;
extern PCWSTR g_pszArg1SubnetDesc;
extern PCWSTR g_pszArg1SubnetLoc;
extern PCWSTR g_pszArg1SubnetSite;

//
// Quota switches
//
extern PCWSTR g_pszArg1QuotaAcct;
extern PCWSTR g_pszArg1QuotaQLimit;
extern PCWSTR g_pszArg1QuotaDesc;

//
// Partition switches
//
extern PCWSTR g_pszArg1PartitionPart;
extern PCWSTR g_pszArg1PartitionDesc;

//
// Valid Output formats{dn, rdn, upn, samid, ntlmid} 
//
extern PCWSTR g_pszDN;
extern PCWSTR g_pszRDN;
extern PCWSTR g_pszUPN;
extern PCWSTR g_pszSamId;
extern PCWSTR g_pszNtlmId;

//
//Valid Scope Strings
//
extern PCWSTR g_pszSubTree;
extern PCWSTR g_pszOneLevel;
extern PCWSTR g_pszBase;

//Default Filter and Prefix filter
extern PCWSTR g_pszDefStarFilter;
extern PCWSTR g_pszDefUserFilter;
extern PCWSTR g_pszDefComputerFilter;
extern PCWSTR g_pszDefGroupFilter;
extern PCWSTR g_pszDefOUFilter;
extern PCWSTR g_pszDefServerFilter;
extern PCWSTR g_pszDefSiteFilter;
extern PCWSTR g_pszDefSubnetFilter;
extern PCWSTR g_pszDefContactFilter;
extern PCWSTR g_pszDefQuotaFilter;
extern PCWSTR g_pszDefPartitionFilter;

//Valid start node values
extern PCWSTR g_pszDomainRoot;
extern PCWSTR g_pszForestRoot;
extern PCWSTR g_pszSiteRoot;

//Attributes to fetch
extern PCWSTR g_szAttrDistinguishedName;
extern PCWSTR g_szAttrUserPrincipalName;
extern PCWSTR g_szAttrSamAccountName;
extern PCWSTR g_szAttrRDN;
extern PCWSTR g_szAttrServerReference;
extern PCWSTR g_szAttrNCName;

// FSMOs
extern PCWSTR g_pszSchema;
extern PCWSTR g_pszName;
extern PCWSTR g_pszInfr;
extern PCWSTR g_pszPDC;
extern PCWSTR g_pszRID;


#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\output.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      output.h
//
//  Contents:  Header file for classes and function used for display
//
//  History:   3-oct-2000 hiteshr Created
//
//--------------------------------------------------------------------------

extern bool g_bQuiet;
extern int g_iQueryLimit;
extern bool g_bDeafultLimit;

HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString);

//+--------------------------------------------------------------------------
//
//  Class:      CDisplay
//
//  Purpose:    This class is used for displaying a column
//
//  History:    3-oct-2000 hiteshr Created
//
//---------------------------------------------------------------------------

class CDisplay
{
#define MAXPAD 80
public:

    //
    //Initialize the Pad
    //    
    CDisplay()
    {
        PadChar = L' ';
        //Initialize the pad.
        for( int i = 0; i < MAXPAD; ++i)
            Pad[i] = PadChar;
    }

    //
    //Display width number of Pad Charachter
    //
    VOID DisplayPad(LONG width)
    {
        if(width <= 0 )
            return;
        if(width >= MAXPAD)
            width = MAXPAD -1;
        Pad[width] = 0;
		DisplayOutputNoNewline(Pad);

        Pad[width] = PadChar;
    }
        
    //
    //Dispaly a column with two starting pad,
    //column value and two ending pad
    //
    VOID DisplayColumn(LONG width, LPWSTR lpszValue)
    {
        //Display Two PadChar in the begining
        DisplayPad(2);
        if(lpszValue)
        {
            DisplayOutputNoNewline(lpszValue);

			//Security Review:This is fine.
            DisplayPad(width- static_cast<LONG>(wcslen(lpszValue)));
        }
        else
            DisplayPad(width);

                
        //Display Two Trailing Padchar
        DisplayPad(2);
    }        
    
    //
    //Display Newline
    //    
    VOID DisplayNewLine()
    {
        DisplayOutputNoNewline(L"\r\n");
    }
private:
    WCHAR Pad[MAXPAD];    
    WCHAR PadChar;

};

//+--------------------------------------------------------------------------
//
//  Class:      CFormaInfo
//
//  Purpose:    Used to format table columns and display table
//
//  History:    3-oct-2000 hiteshr Created
//
//---------------------------------------------------------------------------
class CFormatInfo
{
public:
    CFormatInfo():m_cCol(0),
                  m_ppszOutPutVal(NULL),
                  m_pColWidth(NULL),
                  m_bInit(FALSE),
                  m_cTotalRow(-1)
    {};

    ~CFormatInfo()
    {   
		if(m_ppszOutPutVal)
		{
			for(LONG i = 0; i < m_SampleSize*m_cCol; ++i)
				LocalFree(m_ppszOutPutVal[i]);
		}
        LocalFree(m_ppszOutPutVal);        
        LocalFree(m_pColWidth);
    }

    //
    //Do the initialization
    //
    HRESULT Init(LONG sampleSize, LONG cCol, LPWSTR * ppszColHeaders)
    {
        if(!sampleSize || !cCol || !ppszColHeaders)
        {
            ASSERT(FALSE);
            return E_INVALIDARG;
        }
        
        m_SampleSize = sampleSize; 
        m_cCol = cCol;
        m_ppszColHeaders = ppszColHeaders;
        m_ppszOutPutVal = (LPWSTR*)LocalAlloc(LPTR,m_SampleSize*cCol*sizeof(LPWSTR));
        if(!m_ppszOutPutVal)
            return E_OUTOFMEMORY;
        
        m_pColWidth = (LONG*)LocalAlloc(LPTR, cCol*sizeof(LONG));
        if(!m_pColWidth)
           return E_OUTOFMEMORY;   

        //
        //Initialize the minimum column width to width of column heading
        //
        for(LONG i = 0; i < m_cCol; ++i)
            m_pColWidth[i] = static_cast<LONG>(wcslen(m_ppszColHeaders[i]));

        m_bInit = TRUE;                      

        return S_OK;
    };

                 
    //
    //Get the Column Width
    //
    inline
    LONG GetColWidth(LONG col)
    { 
		 if(!m_bInit)
		 {
			ASSERT(m_bInit);
			return 0;
		 }
        if(col >= m_cCol)
        {
            ASSERT(FALSE);
            return 0;
        }
        return m_pColWidth[col]; 
    }

    //
    //Set the column Width
    //
    inline
    VOID SetColWidth(LONG col, LONG width)
    {
			if(!m_bInit)
			{
				ASSERT(m_bInit);
				return;
			}

        if(col >= m_cCol)
        {
            ASSERT(FALSE);
            return;
        }
        
        if(width > m_pColWidth[col])
            m_pColWidth[col] = width;
    }

    //
    //Cache the value and update column width
    //
    BOOL Set(LONG row, LONG col, LPWSTR pszValue)
    {
		 if(!m_bInit)
		 {
			ASSERT(m_bInit);
			return FALSE;
		 }

        if(row >= m_SampleSize || col >= m_cCol)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        if(pszValue)
        {
            SetColWidth(col, static_cast<LONG>(wcslen(pszValue)));
            LocalCopyString((LPWSTR*)(m_ppszOutPutVal + (row*m_cCol) + col),pszValue);                             
        }
        if(row>= m_cTotalRow)
            m_cTotalRow = row +1;

        return TRUE;
    }

    //
    //Total number of rows in cache
    //
    LONG GetRowCount()
    {
        return m_cTotalRow;
    }
    
    //
    //Get the value
    //
    inline
    LPWSTR Get(LONG row, LONG col)
    {
		 if(!m_bInit)
		 {
			ASSERT(m_bInit);
			NULL;
		 }

        if(row >= m_cTotalRow || col >= m_cCol)
        {
            ASSERT(FALSE);
            return NULL;
        }

        return (LPWSTR)(*(m_ppszOutPutVal + row*m_cCol +col));
    }

    //
    //Display headers 
    //
    VOID DisplayHeaders()
    {    
		 if(!m_bInit)
		 {
			ASSERT(m_bInit);
			return;
		 }

        if (g_bQuiet)
        {
            return;
        }
        if(!m_ppszColHeaders)
        {
            ASSERT(m_ppszColHeaders);    
            return;
        }
        for( long i = 0; i < m_cCol; ++i)
        {
            m_display.DisplayColumn(GetColWidth(i),m_ppszColHeaders[i]);
        }
        NewLine();
    }

    //
    //Display a coulmn which is in cache
    //
    VOID DisplayColumn(LONG row,LONG col)
    {
        ASSERT(m_bInit);
        if(row >= m_cTotalRow || col >= m_cCol)
        {
            ASSERT(FALSE);
            return ;
        }

        m_display.DisplayColumn(GetColWidth(col),Get(row,col));
    }

    //
    //Display the value using column width for col
    //
    VOID DisplayColumn(LONG col, LPWSTR pszValue)
    {
        if(col >= m_cCol)
        {
            ASSERT(FALSE);
            return;
        }

        m_display.DisplayColumn(GetColWidth(col),pszValue);
    }

    //
    //Display all rows in cache
    //
    VOID DisplayAllRows()
    {
        for(long i = 0; i < m_cTotalRow; ++i)
        {
            for(long j = 0; j < m_cCol; ++j)
                DisplayColumn(i,j);
            NewLine();
        }
    }

    //
    //Display a newline
    //
    VOID NewLine(){m_display.DisplayNewLine();}
   
private:
    //
    //True if Init is called
    //
    BOOL m_bInit;
    //
    //Number of rows to be used for calulating
    //column width. This is also the size of the table.
    //
    LONG m_SampleSize;
    //
    //Count of rows in cache
    //
    LONG m_cTotalRow;
    //
    //Number of columns
    //
    LONG m_cCol;

    LPWSTR *m_ppszOutPutVal;    
    LONG * m_pColWidth;
    //
    // Array of column headers. Its assumed that its length is same as m_cCol
    //
    LPWSTR *m_ppszColHeaders;
    CDisplay m_display;

};

//+--------------------------------------------------------------------------
//
//  Synopsis:     Defines the scopes that a search can be run against when
//                looking for a server object
//
//  NOTE:         If SERVER_QUERY_SCOPE_FOREST is not set then we are scoped
//                against a site.
//
//---------------------------------------------------------------------------
#define  SERVER_QUERY_SCOPE_SITE    0x00000001
#define  SERVER_QUERY_SCOPE_FOREST  0x00000002
#define  SERVER_QUERY_SCOPE_DOMAIN  0x00000004

//+--------------------------------------------------------------------------
//
//  Function:   GetServerSearchRoot
//
//  Synopsis:   Builds the path to the root of the search as determined by
//              the parameters passed in from the command line.
//
//  Arguments:  [pCommandArgs IN]     : the table of the command line input
//              [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    DWORD : one of: SERVER_QUERY_SCOPE_FOREST,
//                              SERVER_QUERY_SCOPE_DOMAIN,
//                              SERVER_QUERY_SCOPE_SITE 
//                      which define the scope being used
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
DWORD GetServerSearchRoot(IN PARG_RECORD               pCommandArgs,
                          IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                          OUT CComBSTR&                refsbstrDN);

//+--------------------------------------------------------------------------
//
//  Function:   GetSubnetSearchRoot
//
//  Synopsis:   Builds search root path for Subnet. Its always
//				cn=subnet,cn=site in configuration container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    HRESULT
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
VOID GetSubnetSearchRoot(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refsbstrDN);

//+--------------------------------------------------------------------------
//
//  Function:   GetSiteContainerPath
//
//  Synopsis:   Returns the DN for site container in Configuration
//				container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN 
//
//  Returns:    HRESULT
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
VOID GetSiteContainerPath(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refSubSiteSuffix);



//+--------------------------------------------------------------------------
//
//  Function:   DsQueryServerOutput
//
//  Synopsis:   This functions outputs the query results for server object.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [refServerSearch,IN]reference to the search Object
//              [refCredObject IN]  reference to the credential object
//              [refBasePathsInfo IN] reference to the base paths info
//              [pCommandArgs,IN]   The pointer to the commands table
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    08-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DsQueryServerOutput( IN DSQUERY_OUTPUT_FORMAT     outputFormat,
                             IN LPWSTR*                   ppszAttributes,
                             IN DWORD                     cAttributes,
                             IN CDSSearch&                refServerSearch,
                             IN const CDSCmdCredentialObject& refCredObject,
                             IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                             IN PARG_RECORD               pCommandArgs);

//+--------------------------------------------------------------------------
//
//  Function:   DsQueryOutput
//
//  Synopsis:   This functions outputs the query results.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [*pSeach,IN]        Search Object which has queryhandle
//              [bListFormat IN]    Is Output to shown in List Format.
//                                  This is valid for "dsquery *" only.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DsQueryOutput( IN DSQUERY_OUTPUT_FORMAT outputFormat,
                       IN LPWSTR * ppszAttributes,
                       IN DWORD cAttributes,
                       IN CDSSearch *pSearch,
                       IN BOOL bListFormat );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\dsquery.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsquery.cpp
//
//  Contents:  Defines the main function    DSQUERY
//             command line utility
//
//  History:   06-Sep-2000    hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "querytable.h"
#include "querybld.h"
#include "dsquery.h"
#include "query.h"
#include "resource.h"
#include "output.h"
#include <dscmn.h>
#include "Ntdsapi.h"
//
//Structure Defined to Store Global Values at one place.
//
typedef struct _GlobalInfo
{
    ADS_SCOPEENUM scope;                //Scope of query
    DSQUERY_OUTPUT_FORMAT outputFormat; //Output Format    
}GLOBAL_INFO,*PGLOBAL_INFO;
    
bool g_bQuiet = false;
int g_iQueryLimit = 100;
bool g_bDeafultLimit = true;
DSQUERY_COMMAND_ENUM g_eGC = (DSQUERY_COMMAND_ENUM)-1;

//
// Forward Function Declarations
//
HRESULT DoQueryValidation(PARG_RECORD pCommandArgs,
                          PDSQueryObjectTableEntry pObjectEntry,
                          PGLOBAL_INFO pcommon_info);

HRESULT DoQuery(PARG_RECORD pCommandArgs, 
                PDSQueryObjectTableEntry pObjectEntry,
                PGLOBAL_INFO pcommon_info);

HRESULT GetAttributesToFetch(IN PGLOBAL_INFO pcommon_info,
                             IN PARG_RECORD pCommandArgs,
                             IN PDSQueryObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount);
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount);

HRESULT GetSearchRoot(IN IN PDSQueryObjectTableEntry pObjectEntry,
                      IN PARG_RECORD               pCommandArgs,
                      IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                      OUT CComBSTR&                refsbstrDN,
                      OUT BOOL *pbSearchAtForestRoot,
                      OUT BOOL *pbSearchAtGC);

HRESULT GetSearchObject(IN IN PDSQueryObjectTableEntry pObjectEntry,
                        IN CDSCmdBasePathsInfo& refBasePathsInfo,
                        IN PARG_RECORD pCommandArgs,
                        IN CDSCmdCredentialObject& refCredentialObject,
                        IN CComBSTR& refsbstrDN,
                        IN BOOL bSearchAtForestRoot,
                        IN BOOL bSearchAtGC,
                        OUT CComPtr<IDirectorySearch>& refspSearchObject);

BOOL
TranslateNameFromDnToDns(const CComBSTR& bstrInputDN,
                         CComBSTR& bstrOutputDNS);


HRESULT GetGCIndex(PDSQueryObjectTableEntry pObjectEntry, int& nCommandEnum);

//
//Main Function
//
int __cdecl _tmain( VOID )
{

    int argc = 0;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    PARG_RECORD pNewCommandArgs = 0;

    //
    // False loop
    //
    do
    {
        //
        // Initialize COM
        //
        hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }

        //Get CommandLine Input
        DWORD dwErr = GetCommandInput(&argc,&pToken);
        hr = HRESULT_FROM_WIN32(dwErr);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }
    
        if(argc == 1)
        {
            //
            //  Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSQUERY,TRUE);
            hr = E_INVALIDARG;
            break;
        }

        if(argc == 2)
        {
               if(IsTokenHelpSwitch(pToken + 1))
                {
                    hr = S_OK;
                    DisplayMessage(USAGE_DSQUERY,TRUE);
                    break;
                }
        }

    
        //
        // Find which object table entry to use from
        // the second command line argument
        //
        PDSQueryObjectTableEntry pObjectEntry = NULL;
        UINT idx = 0;
        PWSTR pszObjectType = (pToken+1)->GetToken();
        while (true)
        {
            pObjectEntry = g_DSObjectTable[idx++];
            if (!pObjectEntry)
            {
                break;
            }
            //Security Review:Both strings are null terminated.
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
                break;
            }
        }

        if (!pObjectEntry)
        {                       
            //
            // Display the error message and then break out of the false loop
            //
            hr = E_INVALIDARG;
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr,
                                    IDS_INVALID_OBJECTTYPE);

            }
            break;
        }

        //
        // Now that we have the correct table entry, merge the command line table
        // for this object with the common commands
        //
        hr = MergeArgCommand(DSQUERY_COMMON_COMMANDS, 
                             pObjectEntry->pParserTable, 
                             &pNewCommandArgs);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }
        

        //
        //Parse the Input
        //
        PARSE_ERROR Error;
        if(!ParseCmd(g_pszDSCommandName,
                     pNewCommandArgs,
                     argc-1, 
                     pToken+1,
                     pObjectEntry->pUsageTable, 
                     &Error,
                     TRUE))
        {
            //ParseCmd did not display any error. Error should
            //be handled here. Check DisplayParseError for the
            //cases where Error is not shown by ParseCmd
            if(!Error.MessageShown)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                break;
            }
            
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                break;            
            }

            hr = E_INVALIDARG;
            break;
        }

        //
        // Check to see if we are doing debug spew
        //
#ifdef DBG
        bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                          pNewCommandArgs[eCommDebug].nValue;
        if (bDebugging)
        {
           ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
        }
#else
        DISABLE_DEBUG_OUTPUT();
#endif
        // Get the GC switch (if supported)
        int nCommandEnum = -1;
        if (FAILED(GetGCIndex(pObjectEntry, nCommandEnum)))
        {
            // An object type is missing in GetGCIndex
            if(!Error.MessageShown)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                break;
            }
        }
        g_eGC = (DSQUERY_COMMAND_ENUM) nCommandEnum;

        //
        // Set the global quiet flag
        //
        g_bQuiet = pNewCommandArgs[eCommQuiet].bDefined &&
                   pNewCommandArgs[eCommQuiet].bValue;

        //
        //
        //
        if(pNewCommandArgs[eCommLimit].bDefined)
        {
            g_iQueryLimit = pNewCommandArgs[eCommLimit].nValue;
            g_bDeafultLimit = false;
        }
        

        GLOBAL_INFO common_info;
        common_info.scope = ADS_SCOPE_SUBTREE;
        common_info.outputFormat = DSQUERY_OUTPUT_DN;
        
        //
        // Do extra validation like switch dependency check etc.
        // Also collect Query Scope and Output format
        //
        hr = DoQueryValidation(pNewCommandArgs,
                               pObjectEntry,
                               &common_info);
        if (FAILED(hr))
            break;

        //
        // Command line parsing succeeded
        //
        hr = DoQuery(pNewCommandArgs, 
                     pObjectEntry,
                     &common_info);
        if(FAILED(hr))
            break;
         

    } while (false);    //False Loop

    //
    //Do the CleanUp
    //

    //
    // Free the memory associated with the command values
    //
    if(pNewCommandArgs)
        FreeCmd(pNewCommandArgs);

    //
    // Free the tokens
    //
    if (pToken)
    {
        delete[] pToken;
        pToken = 0;
    }
   

    //
    // Uninitialize COM
    //
    CoUninitialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoQueryValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both presetn, and other validations which cannot be done by parser.
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be queryied
//              [pcommon_info - OUT]: gets scope and output format info
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DoQueryValidation(IN PARG_RECORD pCommandArgs,
                          IN PDSQueryObjectTableEntry pObjectEntry,
                          OUT PGLOBAL_INFO pcommon_info)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoQueryValidation, hr);

    if (!pCommandArgs || !pObjectEntry || !pcommon_info)
    {
        ASSERT(pCommandArgs);
        ASSERT(pObjectEntry);
        ASSERT(pcommon_info);
        hr = E_INVALIDARG;
        return hr;
    }

    // Check to be sure the server and domain switches
    // are mutually exclusive

    if (pCommandArgs[eCommServer].bDefined &&
        pCommandArgs[eCommDomain].bDefined)
    {
        hr = E_INVALIDARG;
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);

        return hr;
    }

    //
    //Validate OutputFormat for "dsquery objectType"
    //
    //Security Review:Both strings are null terminated.
    if(_wcsicmp(pObjectEntry->pszCommandLineObjectType,g_pszStar))
    {        
        DEBUG_OUTPUT(MINIMAL_LOGGING, L"dsquery <objectType> processing will be performed");

        if(pCommandArgs[eCommOutputFormat].bDefined &&
           pCommandArgs[eCommOutputFormat].strValue)
        {
            //
            //ppValidOutput contains the validoutput type for a 
            //given object type
            //
            ASSERT(pObjectEntry->ppValidOutput);
            BOOL bMatch = FALSE;
            for(UINT i = 0; i < pObjectEntry->dwOutputCount; ++i)             
            {
                //Security Review:Both strings are null terminated.
                if(_wcsicmp(pCommandArgs[eCommOutputFormat].strValue,
                            pObjectEntry->ppValidOutput[i]->pszOutputFormat) == 0 )
                {
                    bMatch = TRUE;
                    pcommon_info->outputFormat = pObjectEntry->ppValidOutput[i]->outputFormat;
                    break;
                }
            }
            if(!bMatch)
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr,
                                    IDS_INVALID_OUTPUT);

                return hr;
            }
        }
        //
        //default output format is DN
        //
        else 
            pcommon_info->outputFormat = DSQUERY_OUTPUT_DN;
    }
    else
    {
        //
        //-o is invalid switch form dsquery *, but since its 
        //common for all other objects its kept in common table 
        //and we do the special casing for dsquery *
        //
        if(pCommandArgs[eCommOutputFormat].bDefined &&
           pCommandArgs[eCommOutputFormat].strValue)
        {
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr,
                                IDS_O_NOT_FOR_STAR);
            return hr;
        }

        DEBUG_OUTPUT(MINIMAL_LOGGING, L"dsquery * processing will be performed");
        if(pCommandArgs[eStarAttrsOnly].bDefined)
            pcommon_info->outputFormat = DSQUERY_OUTPUT_ATTRONLY;
        else
            pcommon_info->outputFormat = DSQUERY_OUTPUT_ATTR;
    }

    //
    //Validate Scope string.    
    //default scope is subtree.
    //
    pcommon_info->scope = ADS_SCOPE_SUBTREE;     
    if(pObjectEntry->nScopeID != -1)
    {
        if( pCommandArgs[pObjectEntry->nScopeID].bDefined &&
            pCommandArgs[pObjectEntry->nScopeID].strValue )
        {
            LPCWSTR pszScope = pCommandArgs[pObjectEntry->nScopeID].strValue;
            //Security Review:Both strings are null terminated.
            if( _wcsicmp(pszScope,g_pszSubTree) == 0 )
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"scope = subtree");
                pcommon_info->scope = ADS_SCOPE_SUBTREE;     
            }
            else if( _wcsicmp(pszScope,g_pszOneLevel) == 0 )
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"scope = onelevel");
                pcommon_info->scope = ADS_SCOPE_ONELEVEL;     
            }
            else if( _wcsicmp(pszScope,g_pszBase) == 0 )
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"scope = base");
                pcommon_info->scope = ADS_SCOPE_BASE;    
            }
            else
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"Unknown scope = %s", pszScope);
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr,
                                    IDS_ERROR_SCOPE);

                return hr;
            }
        }
    }

    //
    //if startnode is forestroot, only valid scope is ADS_SCOPE_SUBTREE
    //NTRAID#NTBUG9-382511-2001/05/14-hiteshr
    //
    if(pCommandArgs[eCommStartNode].bDefined &&
       pCommandArgs[eCommStartNode].strValue)
    {
        //Security Review:Both strings are null terminated.
        if((_wcsicmp(pCommandArgs[eCommStartNode].strValue, g_pszForestRoot) == 0 )
           && (pcommon_info->scope != ADS_SCOPE_SUBTREE))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Startnode is forestroot, Scope must be SubTree");

            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr,
                                IDS_FOREST_SEARCH_SCOPE);                    

            return hr;
        }

        if((_wcsicmp(pCommandArgs[eCommStartNode].strValue, g_pszForestRoot) == 0 )
           && _wcsicmp(pObjectEntry->pszCommandLineObjectType, g_pszQuota) == 0)
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"A Startnode of forestroot is not allowed for quotas");

            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr,
                                IDS_FOREST_SEARCH_SCOPE_QUOTAS);                    

            return hr;
        }

    }



    
    //
    //Limit must be 0 or greater
    //
    if(pCommandArgs[eCommLimit].bDefined)
    {
        if(pCommandArgs[eCommLimit].nValue < 0)
        {
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr,
                                IDS_ERROR_LIMIT);
            return hr;
        }
    }

    
    //    
    //Forestwide Search implies the -GC switch so define it if it isn't already
    //
    if(pCommandArgs[eCommStartNode].bDefined &&
       pCommandArgs[eCommStartNode].strValue )
    {
        //Security Review:Both strings are null terminated.
        if(_wcsicmp(pCommandArgs[eCommStartNode].strValue,g_pszForestRoot) == 0)
        {
            // partitions and quotas don't support forestRoot so
            // g_eGC will be valid unless there is an upstream bug
            // so this ASSERT will catch that in private tests
            ASSERT(g_eGC != -1);
            if(!(pCommandArgs[g_eGC].bDefined &&
                 pCommandArgs[g_eGC].bValue))
            {
                pCommandArgs[g_eGC].bDefined = TRUE;
                pCommandArgs[g_eGC].bValue = TRUE;
            }
        }
    }


    //
    //For dsquery server, if none of the -domain, -forest, -site is 
    //specified, then define -domain as its default
    //
    //Security Review:Both strings are null terminated.
    if(!_wcsicmp(pObjectEntry->pszCommandLineObjectType,g_pszServer))
    {
        //
        //Value is assigned in DoQuery function
        //
        if(!pCommandArgs[eServerDomain].bDefined &&
           !pCommandArgs[eServerForest].bDefined &&
           !pCommandArgs[eServerSite].bDefined)
        {          
           pCommandArgs[eServerDomain].bDefined = TRUE;
        }           
    }       


    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Does the query
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//              [pcommon_info - IN] : scope and outputformat info
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DoQuery(PARG_RECORD pCommandArgs, 
                PDSQueryObjectTableEntry pObjectEntry,
                PGLOBAL_INFO pcommon_info)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoQuery, hr);

    if (!pCommandArgs || !pObjectEntry || !pcommon_info)
    {
        ASSERT(pCommandArgs);
        ASSERT(pObjectEntry);
        ASSERT(pcommon_info);
        hr = E_INVALIDARG;
        return hr;
    }

    CDSCmdCredentialObject credentialObject;
    if (pCommandArgs[eCommUserName].bDefined)
    {
        credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    if (pCommandArgs[eCommPassword].bDefined)
    {
        //Security Review:pCommandArgs[eCommPassword].strValue is encrypted.
        //Decrypt pCommandArgs[eCommPassword].strValue  and then pass it to the
        //credentialObject.SetPassword. 
        //See NTRAID#NTBUG9-571544-2000/11/13-hiteshr

        credentialObject.SetEncryptedPassword(&pCommandArgs[eCommPassword].encryptedDataBlob);
        credentialObject.SetUsingCredentials(true);
    }

    // If this is something that supports the GC switch then do the next check
    if(g_eGC != -1)
    {
        //if -GC and -s flags are specified together than server must be 
        //GC.
        if(pCommandArgs[g_eGC].bDefined &&
        pCommandArgs[g_eGC].bValue &&
        pCommandArgs[eCommServer].bDefined &&
        pCommandArgs[eCommServer].strValue)
        {
            if(!IsServerGC(pCommandArgs[eCommServer].strValue,credentialObject))
            {
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr,
                                    IDS_SEVER_NOT_GC);
                return hr;          
            }
        }
    }



    //
    // Initialize the base paths info from the command line args
    // 
    CDSCmdBasePathsInfo basePathsInfo;
    if (pCommandArgs[eCommServer].bDefined)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                              pCommandArgs[eCommServer].strValue,
                                              true);
    }
    else if (pCommandArgs[eCommDomain].bDefined)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                              pCommandArgs[eCommDomain].strValue,
                                              false);
    }
    else
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
    }

    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    //
    //Check if to search GC and get the search root path
    //    
    BOOL bSearchAtGC = FALSE;
    BOOL bSearchAtForestRoot = FALSE;
    CComBSTR sbstrObjectDN;

    hr = GetSearchRoot(pObjectEntry,
                       pCommandArgs,
                       basePathsInfo,
                       sbstrObjectDN,
                       &bSearchAtForestRoot,
                       &bSearchAtGC);
    if (FAILED(hr))
    {
        //Error is displayed in the function itself.
        return hr;
    }

    
    DEBUG_OUTPUT(MINIMAL_LOGGING, L"start node = %s", sbstrObjectDN);

    //
    //Build The Filter For Query
    //
   CComBSTR strSubSiteSuffix; 
    PVOID pParam = NULL;
    //Security Review:Both strings are null terminated.
    if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszSubnet) == 0)
    {
        GetSiteContainerPath(basePathsInfo, strSubSiteSuffix);
        pParam = (PVOID)&strSubSiteSuffix;
    }       

    CComBSTR strLDAPFilter;
    hr = BuildQueryFilter(pCommandArgs, 
                          pObjectEntry,
                          basePathsInfo,
                          credentialObject,
                          pParam,
                          strLDAPFilter);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }



    //
    //Create The IDirectorySearchObject
    //
    CComPtr<IDirectorySearch> spSearchObject;
    hr = GetSearchObject(pObjectEntry,
                         basePathsInfo,
                         pCommandArgs,
                         credentialObject,
                         sbstrObjectDN,
                         bSearchAtForestRoot,
                         bSearchAtGC,
                         spSearchObject);
    if (FAILED(hr))
    {
        //Error is displayed in the function itself.
        return hr;
    }
   
    //
    //Get the arributes to fetch
    //
    LPWSTR *ppszAttributes = NULL;
    DWORD dwCountAttr = 0;
    hr = GetAttributesToFetch(pcommon_info,
                              pCommandArgs,
                              pObjectEntry,
                              &ppszAttributes,
                              &dwCountAttr);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    //
    //Lets Query Now
    //
    CDSSearch searchObject;
    hr = searchObject.Init(spSearchObject);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING, 
                     L"Initializing search object failed: hr = 0x%x",
                     hr);
        FreeAttributesToFetch(ppszAttributes, dwCountAttr);
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    searchObject.SetFilterString(strLDAPFilter);
    searchObject.SetSearchScope(pcommon_info->scope);
    searchObject.SetAttributeList(ppszAttributes,dwCountAttr?dwCountAttr:-1);
    hr = searchObject.DoQuery();
    if(FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING, L"DoQuery failed hr = 0x%x", hr);
        FreeAttributesToFetch(ppszAttributes,dwCountAttr);
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }        
    //
    //Find out the display format for dsquery *
    //It can be either List or Table
    //
    BOOL bListFormat = TRUE;
    if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTR)
    {     
        //
        //If all attributes are to be displayed, only List Format is valid
        //If attributes to fetch are specified at commandline, Table is default format.   
        if(dwCountAttr && 
           !pCommandArgs[eStarList].bDefined)
            bListFormat = FALSE;
    }
          
    bool bUseStandardOutput = true;
    if (pCommandArgs[eCommObjectType].bDefined &&
        _wcsicmp(pCommandArgs[eCommObjectType].strValue, g_pszServer) == 0)
        //Security Review:Both strings are null terminated.
    {
        //
        // "dsquery server" requires additional processing if either the
        // -isgc or the -hasfsmo switch is specified
        //
        if ((pCommandArgs[eServerIsGC].bDefined && pCommandArgs[eServerIsGC].bValue) ||
            (pCommandArgs[eServerHasFSMO].bDefined && pCommandArgs[eServerHasFSMO].strValue)||
            (pCommandArgs[eServerDomain].bDefined && pCommandArgs[eServerDomain].strValue))
        {
            bUseStandardOutput = false;
            hr = DsQueryServerOutput(pcommon_info->outputFormat,
                                     ppszAttributes,
                                     dwCountAttr,
                                     searchObject,
                                     credentialObject,
                                     basePathsInfo,
                                     pCommandArgs);
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
            }

        }
    }

    if (bUseStandardOutput)
    {
        //
        //Output the result of search       
        //
        hr = DsQueryOutput(pcommon_info->outputFormat,
                           ppszAttributes,
                           dwCountAttr,
                           &searchObject,
                           bListFormat);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
        }
    }

    FreeAttributesToFetch(ppszAttributes,dwCountAttr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetAttributesToFetch
//
//  Synopsis:   Make an array of attributes to fetch.
//  Arguments:  [pcommon_info - IN] : outputformat and scope info
//              [ppszAttributes - OUT] : array of attributes to fetch
//              [pCount - OUT] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetAttributesToFetch(IN PGLOBAL_INFO pcommon_info,
                             IN PARG_RECORD pCommandArgs,
                             IN PDSQueryObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, GetAttributesToFetch, hr);

    if(!pcommon_info || !pCommandArgs || !pObjectEntry)
    {   
        ASSERT(pcommon_info);
        ASSERT(pCommandArgs);
        ASSERT(pObjectEntry);
        hr = E_INVALIDARG;
        return hr;
    }

    if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTR ||
       pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTRONLY)
    {
        if(pCommandArgs[eStarAttr].bDefined)
        {
            //                
            //If input is "*", fetch all attributes
            //
            //Security Review:Both strings are null terminated.
            if(wcscmp(pCommandArgs[eStarAttr].strValue,L"*") == 0 )
            {
                *ppszAttributes = NULL;
                *pCount = 0;
                return hr;
            }
            

            LPWSTR *ppszTemp = NULL;
            UINT argc = 0;
            ParseNullSeparatedString(pCommandArgs[eStarAttr].strValue,
                                     &ppszTemp,
                                     &argc);


            LPWSTR *ppszAttr = (LPWSTR *)LocalAlloc(LPTR,argc*sizeof(LPCTSTR));
            if(!ppszAttr)
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            for(UINT i = 0; i < argc; ++i)
            {
                if(FAILED(LocalCopyString(ppszAttr+i, ppszTemp[i])))
                {
                    LocalFree(ppszAttr);
                    hr = E_OUTOFMEMORY;
                    return hr;
                }
            }
            *ppszAttributes = ppszAttr;
            *pCount = argc;
            if(ppszTemp)
                LocalFree(ppszTemp);
            hr = S_OK;
            return hr;

        }
    }
    
    
    LPCWSTR pszAttr = NULL;
    if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTR)
    {   
        //
        //If eStarAttr is not defined, Fetch only DN
        pcommon_info->outputFormat = DSQUERY_OUTPUT_DN;

        if(_wcsicmp(pObjectEntry->pszCommandLineObjectType, g_pszPartition) == 0)
            pszAttr = g_szAttrNCName;
        else
            pszAttr = g_szAttrDistinguishedName;
    }
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTRONLY)  
        pszAttr = g_szAttrDistinguishedName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_DN)
    {
        if(_wcsicmp(pObjectEntry->pszCommandLineObjectType, g_pszPartition) == 0)
            pszAttr = g_szAttrNCName;
        else
            pszAttr = g_szAttrDistinguishedName;
    }
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_UPN)
        pszAttr = g_szAttrUserPrincipalName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_SAMID)
        pszAttr = g_szAttrSamAccountName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_RDN)
        pszAttr = g_szAttrRDN;

    //
    // Always include the DN in the search results as well.  It is quite useful.
    //
    size_t entries = 2;
    //Security Review:Both strings are null terminated.
    if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszServer) == 0)
    {
       // 
       // Add an addition space for the serverReference
       ++entries;
    }

    LPWSTR *ppszAttr = (LPWSTR *)LocalAlloc(LPTR,sizeof(LPWSTR) * entries);
    if(!ppszAttr)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //Security Review:Correct buffer size is passed.
    ZeroMemory(ppszAttr, sizeof(LPWSTR) * entries);

    if(FAILED(LocalCopyString(ppszAttr,pszAttr)))
    {
        LocalFree(ppszAttr);
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // Always include the DN in the search results as well.  It is quite useful.
    //
    if (FAILED(LocalCopyString(&(ppszAttr[1]), g_szAttrDistinguishedName)))
    {
        LocalFree(ppszAttr);
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //Security Review:Both strings are null terminated.
    if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszServer) == 0)
    {
       ASSERT(entries >= 3);
       if (FAILED(LocalCopyString(&(ppszAttr[2]), g_szAttrServerReference)))
       {
          LocalFree(ppszAttr);
          hr = E_OUTOFMEMORY;
          return hr;
       }
    }

    *ppszAttributes = ppszAttr;
    *pCount = static_cast<DWORD>(entries);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   FreeAttributesToFetch
//
//  Synopsis:   Function to free memory allocated by GetAttributesToFetch
//  Arguments:  [dwszAttributes - in] : array of attributes to fetch
//              [dwCount - in] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount)
{
    while(dwCount)
    {
        LocalFree(ppszAttributes[--dwCount]);
    }
    LocalFree(ppszAttributes);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetSearchRoot
//
//  Synopsis:   Builds the path to the root of the search as determined by
//              the parameters passed in from the command line.
//
//  Arguments:  [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//              [pCommandArgs IN]     : the table of the command line input
//              [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//              [pbSearchAtForestRoot] :Set to true is startnode is equal to 
//                                      forestroot
//
//  Returns:    HRESULT 
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT GetSearchRoot(IN IN PDSQueryObjectTableEntry pObjectEntry,
                      IN PARG_RECORD               pCommandArgs,
                      IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                      OUT CComBSTR&                refsbstrDN,
                      OUT BOOL *pbSearchAtForestRoot,
                      OUT BOOL *pbSearchAtGC)
{
    if(!pCommandArgs || 
        !pObjectEntry || 
        !pbSearchAtForestRoot || 
        !pbSearchAtGC)
    {       
        return E_POINTER;
    }

    PWSTR pszInputDN = NULL;

    // If GC switch isn't supported then set to false
    // otherwise check to see if it has been passed
    if(g_eGC == -1)
    {
        *pbSearchAtGC = FALSE;
    }
    else
    {
        if(pCommandArgs[g_eGC].bDefined &&
        pCommandArgs[g_eGC].bValue)
        {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"Searching the GC");
            *pbSearchAtGC = TRUE;
        }
    }
   
    //
    //Get the starting node
    //
    if(pCommandArgs[eCommStartNode].bDefined &&
       pCommandArgs[eCommStartNode].strValue )
    {
        pszInputDN = pCommandArgs[eCommStartNode].strValue;
        //Security Review:Both strings are null terminated.
        if(_wcsicmp(pszInputDN,g_pszDomainRoot) == 0)
        {
            refsbstrDN = refBasePathsInfo.GetDefaultNamingContext();
        }
        //Security Review:Both strings are null terminated.
        else if(_wcsicmp(pszInputDN,g_pszForestRoot) == 0)
        {   
            *pbSearchAtForestRoot = TRUE;
        }
        else
        {   
            //
            //DN is entered
            //
            refsbstrDN = pszInputDN;
        }
    }   
    else
    {   
        //Security Review:Both strings are null terminated.
        if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszServer) == 0)
        {
            if (pCommandArgs[eServerDomain].bDefined && 
                !pCommandArgs[eServerDomain].strValue)
            {
                PWSTR pszName = 0;
                CComBSTR bstrDomainName = refBasePathsInfo.GetDefaultNamingContext();
                HRESULT hr = CrackName(bstrDomainName,
                                       &pszName,
                                       GET_DNS_DOMAIN_NAME,
                                       NULL);
                if (FAILED(hr))
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"Failed to crack the DN into a domain name: hr = 0x%x",
                                 hr);
                    DisplayErrorMessage(g_pszDSCommandName, 
                                        NULL,
                                        hr);
                    return hr;

                }
                pCommandArgs[eServerDomain].strValue = pszName;
            }               

            //
            // Get the base path that corresponds with the scope
            //
            GetServerSearchRoot(pCommandArgs,
                                refBasePathsInfo,
                                refsbstrDN);
        }
        //Security Review:Both strings are null terminated.
        else if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszSite) == 0)
        {
            //
            // Scope is the configuration container
            //
            refsbstrDN = refBasePathsInfo.GetConfigurationNamingContext();
        }
        //Security Review:Both strings are null terminated.
        else if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszSubnet) == 0)
        {
            //
            // Get the base path that corresponds with the scope
            //
            GetSubnetSearchRoot(refBasePathsInfo,
                                refsbstrDN);
        }
        else if (_wcsicmp(pObjectEntry->pszCommandLineObjectType, g_pszPartition) == 0)
        {
            // For partitions, search from Configuration
            refsbstrDN = L"CN=Partitions,";
            refsbstrDN += refBasePathsInfo.GetConfigurationNamingContext();
        }
        else
        {
            //
            //default is Domain DN
            //
            refsbstrDN = refBasePathsInfo.GetDefaultNamingContext();
        }
    }
    return S_OK;
}

HRESULT GetSearchObject(IN IN PDSQueryObjectTableEntry pObjectEntry,
                        IN CDSCmdBasePathsInfo& refBasePathsInfo,
                        IN PARG_RECORD pCommandArgs,
                        IN CDSCmdCredentialObject& refCredentialObject,
                        IN CComBSTR& refsbstrDN,
                        IN BOOL bSearchAtForestRoot,
                        IN BOOL bSearchAtGC,
                        OUT CComPtr<IDirectorySearch>& refspSearchObject)
{

    ENTER_FUNCTION_HR(MINIMAL_LOGGING, GetSearchObject, hr);

    if(!pObjectEntry || !pCommandArgs)
        return E_POINTER;

    //
    //Rules for determining where to search.
    //if -s server is given always search at server
    //if -gc is given search at gc.
    //if startnode is forestroot, search at gc. so -gc is implicit here.
    //if startnode is forestroot, and -s server is provided, server must 
    //be gc.
    //if -s server and -gc are given, server must be gc. This check is 
    //done in DoQueryValidation
    //
    
    if(!bSearchAtForestRoot)
    {
        CComBSTR sbstrObjectPath; 
        bool bBindToServer = true;
        
        //
        //Search at GC
        //
        if(bSearchAtGC)
        {    
            //
            //Change the provider in sbstrObjectPath from LDAP to GC
            //
            CComPtr<IADsPathname> spPathNameObject;
            //Security Review:CLSCTX_INPROC_SERVER is passed. This is fine.
            hr = CoCreateInstance(CLSID_Pathname,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname,
                                  (LPVOID*)&spPathNameObject);
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
                return hr;
            }

            //Set Provider to GC
            hr = spPathNameObject->Set(CComBSTR(L"GC"), ADS_SETTYPE_PROVIDER);
            ASSERT(SUCCEEDED(hr));

            //Set the DN
            hr = spPathNameObject->Set(refsbstrDN, ADS_SETTYPE_DN);
            ASSERT(SUCCEEDED(hr));
            
            //If server name present, search there. Server must be GC, check
            //already done DoQueryValidation.
            if(pCommandArgs[eCommServer].bDefined &&
               pCommandArgs[eCommServer].strValue)
            {
                //Convert DN to adsi path with GC provider
                hr = spPathNameObject->Set(CComBSTR(pCommandArgs[eCommServer].strValue), ADS_SETTYPE_SERVER);
                //
                //server name in path
                //
                bBindToServer = true;
            }
            else
            {
                //
                //No server name in path
                //
                bBindToServer = false;
            }

            hr = spPathNameObject->Retrieve(bBindToServer ? ADS_FORMAT_X500 : ADS_FORMAT_X500_NO_SERVER, 
                                            &sbstrObjectPath);
            ASSERT(SUCCEEDED(hr));

        }        
        else
        {
            //
            // Convert the DN to an ADSI path
            //
            refBasePathsInfo.ComposePathFromDN(refsbstrDN, sbstrObjectPath);            
            //Security Review:Both strings are null terminated.
            if((_wcsicmp(pObjectEntry->pszObjectClass, g_pszUser) == 0 &&
                pCommandArgs[eUserInactive].bDefined) ||
            //Security Review:Both strings are null terminated.
               (_wcsicmp(pObjectEntry->pszObjectClass, g_pszComputer) == 0 && 
                pCommandArgs[eComputerInactive].bDefined))
            {
                INT nDomainBehaviorVersion = 0;
                CComPtr<IADs> spDomain;
                CComBSTR sbstrBasePath; 
                refBasePathsInfo.ComposePathFromDN(refBasePathsInfo.GetDefaultNamingContext(),
                                                sbstrBasePath);
                hr = DSCmdOpenObject(refCredentialObject,
                                     sbstrBasePath,
                                     IID_IADs,
                                     (void**)&spDomain,
                                     bBindToServer);  
                                                     
                
                if (SUCCEEDED(hr))
                {
                    CComVariant varVer;
                    hr = spDomain->GetInfo();

                    if(SUCCEEDED(hr))
                    {
                        CComBSTR bstrVer = L"msDS-Behavior-Version";
                        hr = spDomain->Get(bstrVer, &varVer);
                
                        if(SUCCEEDED(hr))
                        {
                            ASSERT(varVer.vt == VT_I4);
                            nDomainBehaviorVersion = static_cast<UINT>(varVer.lVal);
                        }
                    }
                }

                if(nDomainBehaviorVersion == 0)
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"DomainBehaviorVersion is 0.");
                    
                    hr = E_INVALIDARG;
                    DisplayErrorMessage(g_pszDSCommandName, 
                                        NULL,
                                        hr,
                                        IDS_FILTER_LAST_LOGON_VERSION);                                        
                    return hr;
                                                           
                }
            }
        }

        hr = DSCmdOpenObject(refCredentialObject,
                             sbstrObjectPath,
                             IID_IDirectorySearch,
                             (void**)&refspSearchObject,
                             bBindToServer);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }
    }
    else
    { 
        CComBSTR bstrSearchRoot = L"GC://";
        bool bBindToServer = false;

        //If server name is provided search there
        if(pCommandArgs[eCommServer].bDefined &&
           pCommandArgs[eCommServer].strValue)
        {
            bstrSearchRoot += pCommandArgs[eCommServer].strValue;
            bBindToServer = true;
        }
        else
        {
            //Get RootDse
            CComPtr<IADs> spRootDSE = refBasePathsInfo.GetRootDSE();


            //Get name of forest
            VARIANT Default;
            VariantInit(&Default);
            hr = spRootDSE->Get (CComBSTR(L"rootDomainNamingContext"), &Default);
            if(FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
                return hr;
            }

            ASSERT(Default.vt == VT_BSTR);
            CComBSTR bstrForestDN = Default.bstrVal;
            ::VariantClear(&Default);

            //Convert DN to dns path
            CComBSTR bstrForestDNS;         
            if(!TranslateNameFromDnToDns(bstrForestDN,
                                        bstrForestDNS))
            {
                hr = E_FAIL;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
                return hr;
            }

            bBindToServer = false;
            bstrSearchRoot += bstrForestDNS;
        }       


        //BIND to GC to search entire forest
        hr = DSCmdOpenObject(refCredentialObject,
                             bstrSearchRoot,
                             IID_IDirectorySearch,
                             (void**)&refspSearchObject,
                              bBindToServer);

        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }
    }

    return hr;
}


BOOL
TranslateNameFromDnToDns(const CComBSTR& bstrInputDN,
                         CComBSTR& bstrOutputDNS)
{
    if(bstrInputDN.Length() == 0)
        return FALSE;

    bstrOutputDNS.Empty();
    
    LPCWSTR pstrName = bstrInputDN;
    PDS_NAME_RESULT pResult = NULL;
    if( DS_NAME_NO_ERROR
        == DsCrackNames(NULL,
                        DS_NAME_FLAG_SYNTACTICAL_ONLY,
                        DS_FQDN_1779_NAME,
                        DS_CANONICAL_NAME,
                        1,
                        (LPWSTR*)(&pstrName),
                        &pResult))
    {
        if(pResult && 
           pResult->cItems == 1 && 
           pResult->rItems[0].status  == DS_NAME_NO_ERROR &&
           pResult->rItems[0].pDomain)
        {           
            bstrOutputDNS = pResult->rItems[0].pDomain;
        }

        if(pResult)
        {
            DsFreeNameResult(pResult);
        }
    }
    return !!bstrOutputDNS.Length();
}

//+--------------------------------------------------------------------------
//
//  Function:   GetGCIndex
//
//  Synopsis:   Performs a lookup to determine which enum value is holding
//              the GC (if any). This was necessary removing -gc from common
//
//  Arguments:  [pObjectEntry IN]   : ObjectEntry from the parser
//              [nCommandEnum OUT]  : Enum value of the object, else -1
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//
//  Remarks:    
//              
//
//  History:    10-Sep-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT GetGCIndex(PDSQueryObjectTableEntry pObjectEntry, int& nCommandEnum)
{
    HRESULT hr = S_OK;

    do // false loop
    {
        // Init nCommandEnum to an error value by default
        nCommandEnum = -1;

        if(NULL == pObjectEntry)
        {
            hr = E_INVALIDARG;
            break;
        }

        // Get a pointer to the object class for readability
        PCWSTR pszCommandLineObjectType = pObjectEntry->pszCommandLineObjectType;

        // Now compare each object type against the specified
        // object class to see what the enum index is
        if(0 == lstrcmpi(pszCommandLineObjectType, g_pszStar))
        {
            nCommandEnum = eStarGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszOU))
        {
            nCommandEnum = eOUGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszUser))
        {
            nCommandEnum = eUserGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszContact))
        {
            nCommandEnum = eContactGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszComputer))
        {
            nCommandEnum = eComputerGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszGroup))
        {
            nCommandEnum = eGroupGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszServer))
        {
            nCommandEnum = eServerGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszSite))
        {
            nCommandEnum = eSiteGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType,g_pszSubnet))
        {
            nCommandEnum = eSubnetGC;
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszQuota))
        {
            nCommandEnum = -1; // -gc not supported
            break;
        }
        else if(0 == lstrcmpi(pszCommandLineObjectType, g_pszPartition))
        {
            nCommandEnum = -1; // -gc not supported
            break;
        }
        else
        {
            hr = E_FAIL;
            // If you get here, then you've added a new object
            // to cstrings.* without adding it to the 
            // if statement. This should only happen
            // when testing a new object for the first time
            // without a corresponding check above.
            ASSERT(FALSE);
            break;
        }
    } while(false);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\output.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      output.cpp
//
//  Contents:  Defines the functions which displays the query output
//  History:   05-OCT-2000    hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "querytable.h"
#include "querybld.h"
#include "dsquery.h"
#include "query.h"
#include "resource.h"
#include "stdlib.h"
#include "output.h"
#include "sddl.h"

#include <dscmn.h>

//
// list was causing unused formal parameter warnings when compiling with /W4
//
#pragma warning(disable : 4100)
#include <list>
#pragma warning(default : 4100)

HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR* ppBuffer, 
                         IN PCWSTR pszAttrName);

HRESULT OutputFetchAttr(IN LPWSTR * ppszAttributes,
                        IN DWORD cAttributes,
                        IN CDSSearch *pSearch,
                        IN BOOL bListFormat);

HRESULT OutputAllAttr(IN CDSSearch *pSearch, BOOL bAttrOnly);


HRESULT OutputSingleAttr(IN LPWSTR * ppszAttributes,
                         IN DWORD cAttributes,
                         IN CDSSearch *pSearch);

BOOL IsQueryLimitReached(int iResultsDisplayed)
{
    if(g_iQueryLimit != 0)
    {
        if(iResultsDisplayed == g_iQueryLimit)
        {
            if(!g_bQuiet)
            {
                if(g_bDeafultLimit)
                    WriteStringIDToStandardErr(IDS_DEFAULT_QUERY_LIMIT_REACHED);
                else
                    WriteStringIDToStandardErr(IDS_QUERY_LIMIT_REACHED);
            }
            return TRUE;
        }
    }
    return FALSE;
}


HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    //pString is NULL terminated.
    *ppResult = (LPTSTR)LocalAlloc(LPTR, (wcslen(pString)+1)*sizeof(WCHAR) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    //Correct buffer is allocated above.
    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


//+--------------------------------------------------------------------------
//
//  Function:   DisplayList
//
//  Synopsis:   Dispalys a name and value in list format.
//  Arguments:  [szName - IN] : name of the attribute
//              [szValue - IN]: value of the attribute
//              [bShowAttribute - IN] : if true the attribute name will be
//                              prepended to the output
//
//
//  History:    05-OCT-2000   hiteshr   Created
//              13-Dec-2000   JeffJon   Modified - Added the bShowAttribute flag
//                                      so that the caller can determine whether
//                                      or not to show the attribute name
//
//---------------------------------------------------------------------------
VOID DisplayList(LPCWSTR szName, LPCWSTR szValue, bool bShowAttribute = true)
{
    if(!szName)
        return;
    CComBSTR strTemp;
    if (bShowAttribute)
    {
      strTemp = szName;
      strTemp += L": ";
    }
    if(szValue)
        strTemp += szValue;
    DisplayOutput(strTemp);
}
    

//+--------------------------------------------------------------------------
//
//  Function:   DsQueryOutput
//
//  Synopsis:   This functions outputs the query results.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [*pSeach,IN]        Search Object which has queryhandle
//              [bListFormat IN]    Is Output to shown in List Format.
//                                  This is valid for "dsquery *" only.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT DsQueryOutput( IN DSQUERY_OUTPUT_FORMAT outputFormat,
                       IN LPWSTR * ppszAttributes,
                       IN DWORD cAttributes,
                       IN CDSSearch *pSearch,
                       IN BOOL bListFormat )
{    
    ENTER_FUNCTION_HR(FULL_LOGGING, DsQueryOutput, hr);

    if(!pSearch)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    if(outputFormat == DSQUERY_OUTPUT_ATTRONLY)
    {
        hr = OutputAllAttr(pSearch, TRUE);
        return hr;
    }
    else if(outputFormat == DSQUERY_OUTPUT_ATTR)
    {   
        //
        //Attributes to display were specified at command line
        //
        if(cAttributes)
        {
            hr = OutputFetchAttr(ppszAttributes,
                                   cAttributes,
                                   pSearch,
                                   bListFormat);                            
            return hr;
        }
        else
        {   
            //
            //No attributes were specified at commandline Display All the attributes.
            //
            hr = OutputAllAttr(pSearch, FALSE);
            return hr;
        }
    }
    else
    {
        //
        //Do the output for "dsquery objecttype"
        //
        hr = OutputSingleAttr(ppszAttributes,
                              cAttributes,
                              pSearch);
        return hr;
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   GetServerSearchRoot
//
//  Synopsis:   Builds the path to the root of the search as determined by
//              the parameters passed in from the command line.
//
//  Arguments:  [pCommandArgs IN]     : the table of the command line input
//              [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    SERVER_QUERY_SCOPE : a value from the enumeration that represents
//                                   the scope that will be searched
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
DWORD GetServerSearchRoot(IN PARG_RECORD               pCommandArgs,
                          IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                          OUT CComBSTR&                refsbstrDN)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, GetServerSearchRoot);

    DWORD scope = SERVER_QUERY_SCOPE_FOREST;
    CComBSTR sbstrRootDN = L"CN=Sites,";
    sbstrRootDN += refBasePathsInfo.GetConfigurationNamingContext();
    
    do // false loop
    {
        //
        // Validate parameters
        //
        if (!pCommandArgs)
        {
            ASSERT(pCommandArgs);
            break;
        }

        if (pCommandArgs[eServerSite].bDefined &&
            pCommandArgs[eServerSite].strValue)
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"Using the site as the root of the search: %s",
                         pCommandArgs[eServerSite].strValue);

            //
            // Prepend the named site container to the current root
            //
            CComBSTR sbstrTemp = L"CN=";
            sbstrTemp += pCommandArgs[eServerSite].strValue;
            sbstrTemp += L",";
            sbstrTemp += sbstrRootDN;
            sbstrRootDN = sbstrTemp;

            DEBUG_OUTPUT(FULL_LOGGING,
                         L"scope = SERVER_QUERY_SCOPE_SITE");
            scope = SERVER_QUERY_SCOPE_SITE;
        }
        else
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"scope = SERVER_QUERY_SCOPE_FOREST");
            scope = SERVER_QUERY_SCOPE_FOREST;
        }

        if (pCommandArgs[eServerDomain].bDefined &&
            pCommandArgs[eServerDomain].strValue)
        {        
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"scope |= SERVER_QUERY_SCOPE_DOMAIN");
            scope |= SERVER_QUERY_SCOPE_DOMAIN;
        }

        refsbstrDN = sbstrRootDN;
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"search root = %s",
                     refsbstrDN);
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"search scope = 0x%x",
                     scope);
    } while (false);

    return scope;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetSubnetSearchRoot
//
//  Synopsis:   Builds search root path for Subnet. Its always
//              cn=subnet,cn=site in configuration container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    HRESULT
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
VOID GetSubnetSearchRoot(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refsbstrDN)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, GetSubnetSearchRoot);

    refsbstrDN = L"CN=subnets,CN=Sites,";
    refsbstrDN += refBasePathsInfo.GetConfigurationNamingContext();
    return;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetSiteContainerPath
//
//  Synopsis:   Returns the DN for site container in Configuration
//              container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN 
//
//  Returns:    HRESULT
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
VOID GetSiteContainerPath(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refSubSiteSuffix)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, GetSubnetSearchRoot);

    refSubSiteSuffix = L"CN=Sites,";
    refSubSiteSuffix += refBasePathsInfo.GetConfigurationNamingContext();
    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetGCList
//
//  Synopsis:   Does a search from the passed in path looking for GCs
//
//  Arguments:  [pszSearchRootPath IN]  : the path to the root of the search
//              [refCredObject IN]      : reference to the credential object
//              [refGCList OUT]         : reference to an STL list that will
//                                        take the DNs of the GCs
//                                       
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  Remarks:    Caller must free all strings added to the list by calling
//              SysFreeString()
//
//  History:    08-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT GetGCList( IN  PCWSTR                   pszSearchRootPath,
                   IN  const CDSCmdCredentialObject& refCredObject,
                   OUT std::list<BSTR>&        refGCList)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetGCList, hr);

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pszSearchRootPath)
        {
            ASSERT(pszSearchRootPath);

            hr = E_INVALIDARG;
            break;
        }

        //
        // Search for NTDSDSA objects that have the options bit set for a GC
        //
        CDSSearch gcSearchObj;
        hr = gcSearchObj.Init(pszSearchRootPath,
                              refCredObject);
        if (FAILED(hr))
        {
          break;
        }

        //
        // Prepare the search object
        //
        PWSTR ppszAttrs[] = { L"distinguishedName" };
        DWORD dwAttrCount = sizeof(ppszAttrs)/sizeof(PCWSTR);
        PWSTR pszGCFilter = L"(&(objectClass=nTDSDSA)(options:LDAP_MATCHING_RULE_BIT_AND_W:=1))";

        gcSearchObj.SetFilterString(pszGCFilter);
        gcSearchObj.SetSearchScope(ADS_SCOPE_SUBTREE);
        gcSearchObj.SetAttributeList(ppszAttrs, dwAttrCount);
        
        hr = gcSearchObj.DoQuery();
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to search for NTDSDSA objects that are GCs: hr = 0x%x",
                         hr);
            break;
        }

        while (SUCCEEDED(hr))
        {
            hr = gcSearchObj.GetNextRow();
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"GetNextRow() failed: hr = 0x%x",
                             hr);
                break;
            }

            if (hr == S_ADS_NOMORE_ROWS)
            {
                hr = S_OK;
                break;
            }

            ADS_SEARCH_COLUMN column;
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(&column, sizeof(ADS_SEARCH_COLUMN));

            hr = gcSearchObj.GetColumn(ppszAttrs[0], &column);
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"Failed to get column %s",
                             ppszAttrs[0]);
                break;
            }

            //Security Review:Done
            ASSERT(0 == _wcsicmp(column.pszAttrName, ppszAttrs[0]));
            if (column.dwNumValues == 1 &&
                column.pADsValues)
            { 
                //
                // Since the server is really the parent of the NTDSDSA object,
                // get the server DN and add it to the list
                //
                CComBSTR sbstrParentDN;
                hr = CPathCracker::GetParentDN(column.pADsValues->DNString, 
                                               sbstrParentDN);
                if (SUCCEEDED(hr))
                {
                    refGCList.push_back(sbstrParentDN.Copy());
                    DEBUG_OUTPUT(FULL_LOGGING,
                                 L"GC found: %s",
                                 column.pADsValues->DNString);
                }
                else
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"Failed to get the parent DN from the NTDSDSA DN: %s",
                                 column.pADsValues->DNString);
                    break;
                }
            }
            else
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"The column has no values!");
            }

            hr = gcSearchObj.FreeColumn(&column);
            ASSERT(SUCCEEDED(hr));
        }
    } while (false);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetFSMOList
//
//  Synopsis:   Does a search from the passed in path looking for the FSMO
//              role owners
//
//  Arguments:  [pszSearchRootPath IN]    : the path to the root of the search
//              [refBasePathsInfo IN]     : reference to the base paths info
//              [refCredObject IN]        : reference to the credential object
//              [pszFSMOArg IN]           : the value of the -hasfsmo arg
//              [refFSMOList OUT]         : reference to the search object that
//                                          will hold the results
//                                       
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  Remarks:    Caller must free all strings added to the list by calling
//              SysFreeString()
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT GetFSMOList( IN  PCWSTR                     pszSearchRootPath,
                     IN  CDSCmdBasePathsInfo&       refBasePathsInfo,
                     IN  const CDSCmdCredentialObject& refCredObject,
                     IN  PCWSTR                     pszFSMOArg,
                     OUT std::list<BSTR>&           refFSMOList)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetFSMOList, hr);

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pszSearchRootPath ||
            !pszFSMOArg)
        {
            ASSERT(pszSearchRootPath);

            hr = E_INVALIDARG;
            break;
        }

        FSMO_TYPE fsmoType = SCHEMA_FSMO;

        //Security Reivew: Both strings are null terminated.
        if (0 == _wcsicmp(pszFSMOArg, g_pszSchema))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the schema FSMO holder");
            fsmoType = SCHEMA_FSMO;
        }
        //Security Reivew: Both strings are null terminated.
        else if (0 == _wcsicmp(pszFSMOArg, g_pszName))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the domain naming master FSMO holder");
            fsmoType = DOMAIN_NAMING_FSMO;
        }
        //Security Reivew: Both strings are null terminated.
        else if (0 == _wcsicmp(pszFSMOArg, g_pszInfr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the infrastructure FSMO holder");
            fsmoType = INFRASTUCTURE_FSMO;
        }
        //Security Reivew: Both strings are null terminated.
        else if (0 == _wcsicmp(pszFSMOArg, g_pszPDC))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the PDC FSMO holder");
            fsmoType = PDC_FSMO;
        }
        //Security Reivew: Both strings are null terminated.
        else if (0 == _wcsicmp(pszFSMOArg, g_pszRID))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the RID FSMO holder");
            fsmoType = RID_POOL_FSMO;
        }
        else
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Unknown FSMO was passed in: %s",
                         pszFSMOArg);
            hr = E_INVALIDARG;
            break;
        }

        CComBSTR sbstrServerDN;
        hr = FindFSMOOwner(refBasePathsInfo,
                           refCredObject,
                           fsmoType,
                           sbstrServerDN);
        if (FAILED(hr))
        {
            break;
        }
        refFSMOList.push_back(sbstrServerDN.Copy());
    } while (false);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsObjectValidInAllLists
//
//  Synopsis:   Determines if the passed in DN exists in the other lists
//
//  Arguments:  [pszDN IN]        : DN to search for in the lists
//              [refGCList IN]    : reference to the list of GCs found
//              [bUseGCList IN]   : if true refGCList will be used to validate DN
//              [refFSMOList IN]  : reference to the list of FSMO holders found
//              [bUseFSMOList IN] : if true refFSMOList will be used to validate DN
//
//  Returns:    bool : true if the object is in all valid lists
//                     false otherwise
//
//  History:    12-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
bool IsObjectValidInAllLists(IN PCWSTR              pszComputerDN,
                             IN PCWSTR              pszDN,
                             IN DWORD               scope,
                             IN PCWSTR              pszDomain,
                             IN const std::list<BSTR>&   refGCList, 
                             IN bool                bUseGCList,
                             IN const std::list<BSTR>&   refFSMOList,
                             IN bool                bUseFSMOList)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, IsObjectValidInAllLists);

    bool bReturn = false;
    PWSTR pszName = 0;
    do // false loop
    {
        //
        // Validate parameters
        //
        if (!pszDN ||
            !pszComputerDN)
        {
            ASSERT(pszDN);
            ASSERT(pszComputerDN);
            return false;
        }

        bool bFoundInGCList = false;
        bool bFoundInFSMOList = false;

        DEBUG_OUTPUT(LEVEL7_LOGGING,
                     L"Searching for %s",
                     pszDN);

        if (scope & SERVER_QUERY_SCOPE_DOMAIN)
        {
            if (!pszDomain)
            {
                //
                // If no domain was specified there is no way we could find a match
                //
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"The scope is domain but no domain argument was specified!");
                bReturn = false;
                break;
            }

            DEBUG_OUTPUT(FULL_LOGGING,
                         L"Looking for domain: %s",
                         pszDomain);

            //
            // Use CrackName to get the domain name from the DN
            //
    
            HRESULT hr = CrackName(const_cast<PTSTR>(pszComputerDN),
                                   &pszName,
                                   GET_DNS_DOMAIN_NAME,
                                   NULL);
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"Failed to crack the DN into a domain name: hr = 0x%x",
                             hr);
                bReturn = false;
                break;
            }

            //Both names are null terminated.
            if (0 != _wcsicmp(pszName, pszDomain))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"Domain names don't match");
                bReturn = false;
                break;
            }
        }


        if (bUseGCList)
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching through GC list...");

            std::list<PWSTR>::iterator itr;
            for (itr = refGCList.begin(); itr != refGCList.end(); ++itr)
            {
                //Both names are null terminated.
                if (0 == _wcsicmp(*itr, pszDN))
                {
                    bFoundInGCList = true;
                    break;
                }
            }
        }

        if (bUseFSMOList)
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching through FSMO list...");

            std::list<PWSTR>::iterator itr;
            for (itr = refFSMOList.begin(); itr != refFSMOList.end(); ++itr)
            {
                DEBUG_OUTPUT(FULL_LOGGING,
                             L"Comparing: %s and %s",
                             *itr,
                             pszDN);
                //Both names are null terminated.
                if (0 == _wcsicmp(*itr, pszDN))
                {
                    bFoundInFSMOList = true;
                    break;
                }
            }
        }

        bReturn = ((bUseGCList && bFoundInGCList) || !bUseGCList) &&
                  ((bUseFSMOList && bFoundInFSMOList) || !bUseFSMOList);
        
    } while (false);


    if(pszName)
        LocalFree(pszName);


    if (bReturn)
    {
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"%s is a valid result",
                     pszDN);
    }
    else
    {
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"%s is NOT a valid result",
                     pszDN);
    }

    return bReturn;
}


//+--------------------------------------------------------------------------
//
//  Function:   OutputValidSearchResult
//
//  Synopsis:   Determines if the passed in DN exists in the other lists
//
//  Arguments:  [refSearchObject - IN] : reference to the object that performed
//                                       the search
//              [ppszAttributes - IN]  : list of attributes to be displayed
//              [cAttributes - IN]     : count of attributes in ppszAttributes
//
//  Returns:   
//
//  History:    12-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void OutputValidSearchResult(IN DSQUERY_OUTPUT_FORMAT outputFormat,
                             IN CDSSearch&            refSearchObject,
                             IN PWSTR*                ppszAttributes,
                             IN DWORD                 cAttributes)
{
    ENTER_FUNCTION(LEVEL5_LOGGING, OutputValidSearchResult);

    HRESULT hr = S_OK;

    if (!ppszAttributes ||
        cAttributes == 0)
    {
        ASSERT(cAttributes > 0);
        ASSERT(ppszAttributes);
        return;
    }

    //
    // Output in list format, note that we are only displaying one attribute
    // The first attribute in the array must be the one we want to display
    //
    ADS_SEARCH_COLUMN ColumnData;
    hr = refSearchObject.GetColumn(ppszAttributes[0], &ColumnData);
    if(SUCCEEDED(hr))
    {
        ADSVALUE *pValues = ColumnData.pADsValues;
        for( DWORD j = 0; j < ColumnData.dwNumValues && pValues; ++j )
        {             
            LPWSTR pBuffer = NULL;
            hr = GetStringFromADs(pValues,
                                  ColumnData.dwADsType,
                                  &pBuffer, 
                                  ppszAttributes[0]);
            if(SUCCEEDED(hr))
            {

                CComBSTR sbstrTemp;
                if (outputFormat == DSQUERY_OUTPUT_DN)
                {
                    sbstrTemp = L"\"";
                    sbstrTemp += pBuffer;
                    sbstrTemp += L"\"";
                }
                else
                {
                    sbstrTemp = pBuffer;
                }
                DisplayList(ppszAttributes[0], sbstrTemp, false);
                delete pBuffer;
                pBuffer = NULL;
            }
            ++pValues;
        }
        refSearchObject.FreeColumn(&ColumnData);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   DsQueryServerOutput
//
//  Synopsis:   This functions outputs the query results for server object.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [refServerSearch,IN]reference to the search Object
//              [refBasePathsInfo IN] reference to the base paths info
//              [pCommandArgs,IN]   The pointer to the commands table
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    08-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DsQueryServerOutput( IN DSQUERY_OUTPUT_FORMAT     outputFormat,
                             IN LPWSTR*                   ppszAttributes,
                             IN DWORD                     cAttributes,
                             IN CDSSearch&                refServerSearch,
                             IN const CDSCmdCredentialObject&  refCredObject,
                             IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                             IN PARG_RECORD               pCommandArgs)
{    
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, DsQueryServerOutput, hr);

    std::list<BSTR> gcList;
    std::list<BSTR> fsmoList;

    do // false loop
    {
        //
        // Validate parameters
        //
        if (!ppszAttributes ||
            !pCommandArgs)
        {
            ASSERT(ppszAttributes);
            ASSERT(pCommandArgs);
            hr = E_INVALIDARG;
            break;
        }

        //
        // Determine the scope that should be used
        //
        CComBSTR sbstrSearchRootDN;
        DWORD scope = GetServerSearchRoot(pCommandArgs, 
                                          refBasePathsInfo,
                                          sbstrSearchRootDN);
        CComBSTR sbstrSearchRootPath;
        refBasePathsInfo.ComposePathFromDN(sbstrSearchRootDN, sbstrSearchRootPath);

        //
        // Build the list of GCs if needed
        //
        bool bUseGCSearchResults = false;
        if (pCommandArgs[eServerIsGC].bDefined &&
            pCommandArgs[eServerIsGC].bValue)
        {
            hr = GetGCList(sbstrSearchRootPath, 
                           refCredObject,
                           gcList);
            if (FAILED(hr))
            {
                break;
            }

            //
            // If we didn't get any values then there is no reason to continue
            // since we won't have anything that matches the -isgc flag
            //
            if (gcList.size() < 1)
            {
                break;
            }
            bUseGCSearchResults = true;
        }

        //
        // Build the list of FSMO owners if needed
        //
        bool bUseFSMOSearchResults = false;
        if (pCommandArgs[eServerHasFSMO].bDefined &&
            pCommandArgs[eServerHasFSMO].strValue)
        {
            hr = GetFSMOList(sbstrSearchRootPath,
                             refBasePathsInfo,
                             refCredObject,
                             pCommandArgs[eServerHasFSMO].strValue,
                             fsmoList);
            if (FAILED(hr))
            {
                break;
            }
            bUseFSMOSearchResults = true;
        }

        //
        // See if we need to filter on domain
        //
        bool bUseDomainFiltering = false;
        if (pCommandArgs[eServerDomain].bDefined &&
            pCommandArgs[eServerDomain].strValue)
        {
            bUseDomainFiltering = true;
        }

        if (!bUseGCSearchResults &&
            !bUseFSMOSearchResults &&
            !bUseDomainFiltering)
        {
            hr = DsQueryOutput(outputFormat,
                               ppszAttributes,
                               cAttributes,
                               &refServerSearch,
                               true);
        }
        else
        {
            //
            // Either -isgc or -hasfsmo was specified so we have to take the intersection
            // of the lists of objects found in each search to use as output
            //
            while (SUCCEEDED(hr))
            {
                hr = refServerSearch.GetNextRow();
                if (FAILED(hr))
                {
                    break;
                }

                if (hr == S_ADS_NOMORE_ROWS)
                {
                    hr = S_OK;
                    break;
                }
        
                ADS_SEARCH_COLUMN computerColumn;
                //Security Review:Correct Buffer size is passed.
                ZeroMemory(&computerColumn, sizeof(ADS_SEARCH_COLUMN));

                //
                // Get the DN
                //
                hr = refServerSearch.GetColumn((PWSTR)g_szAttrServerReference, &computerColumn);
                if (FAILED(hr))
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"Failed to get the server reference for a column: hr = 0x%x",
                                 hr);
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"continuing...");
                    hr = S_OK;
                    continue;
                }

                ADS_SEARCH_COLUMN serverColumn;
                //Security Review:Correct Buffer size is passed.
                ZeroMemory(&serverColumn, sizeof(ADS_SEARCH_COLUMN));

                hr = refServerSearch.GetColumn((PWSTR)g_szAttrDistinguishedName, &serverColumn);
                if (FAILED(hr))
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"Failed to get the distinguishedName for a column: hr = 0x%x",
                                 hr);
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"continuing...");
                    hr = S_OK;
                    continue;
                }

                if (computerColumn.dwNumValues == 1 &&
                    computerColumn.pADsValues &&
                    serverColumn.dwNumValues == 1 &&
                    serverColumn.pADsValues)
                {
                    //
                    // Search the lists and determine if the DN exists in all the lists
                    //
                    bool bValidEntry = IsObjectValidInAllLists(computerColumn.pADsValues->DNString,
                                                               serverColumn.pADsValues->DNString,
                                                               scope,
                                                               pCommandArgs[eServerDomain].strValue,
                                                               gcList, 
                                                               bUseGCSearchResults,
                                                               fsmoList,
                                                               bUseFSMOSearchResults);
                    if (bValidEntry)
                    {
                        //
                        // Output this server object since it matches all search criteria
                        //
                        OutputValidSearchResult(outputFormat,
                                                refServerSearch,
                                                ppszAttributes,
                                                cAttributes);
                    }
                }

                hr = refServerSearch.FreeColumn(&computerColumn);
                ASSERT(SUCCEEDED(hr));
            }
        }

    } while (false);

    std::list<BSTR>::iterator gcItr;
    for (gcItr = gcList.begin(); gcItr != gcList.end(); ++gcItr)
    {
        // Prefast will bark at this but it is correct.  The container
        // is filled with BSTRs which need to be freed using SysFreeString
        SysFreeString(*gcItr);
    }

    std::list<BSTR>::iterator fsmoItr;
    for (fsmoItr = fsmoList.begin(); fsmoItr != fsmoList.end(); ++fsmoItr)
    {
        // Prefast will bark at this but it is correct.  The container
        // is filled with BSTRs which need to be freed using SysFreeString
        SysFreeString(*fsmoItr);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   OutputFetchAttr
//
//  Synopsis:   Dispalys the fetched attributes in either list or table format
//  Arguments:  [ppszAttributes - IN] : Array containing list of attributes to display
//              [cAttributes - IN]: Count of attributes in ppszAttributes
//              [pSearch - IN]: pointer to search object
//              [bListFormat - IN]: List or Table format
//  Returns     HRESULT  S_OK if Successful
//                       E_INVALIDARG
//                       Anything else is a failure code from an ADSI call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT OutputFetchAttr(IN LPWSTR * ppszAttributes,
                        IN DWORD cAttributes,
                        IN CDSSearch *pSearch,
                        IN BOOL bListFormat)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, OutputFetchAttr, hr);

        
    if(bListFormat)
    {
        //
        //Display in list format
        //
        int cListDisplayed = 0;
        while(TRUE)
        {
            hr = pSearch->GetNextRow();

            if(IsQueryLimitReached(cListDisplayed))
                    break;
        
            if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
                break;

            bool bShowAttributes = false;
            if (cAttributes > 1)
            {
                bShowAttributes = true;
            }

            for(DWORD i = 0; i < cAttributes; ++i)
            {
                ADS_SEARCH_COLUMN ColumnData;
                hr = pSearch->GetColumn(ppszAttributes[i], &ColumnData);
                if(SUCCEEDED(hr))
                {
                    ADSVALUE *pValues = ColumnData.pADsValues;
                    for( DWORD j = 0; j < ColumnData.dwNumValues; ++j )
                    {              
                        LPWSTR pBuffer = NULL;
                        hr = GetStringFromADs(pValues,
                                              ColumnData.dwADsType,
                                              &pBuffer, 
                                              ppszAttributes[i]);
                        if(SUCCEEDED(hr))
                        {
                            DisplayList(ppszAttributes[i], pBuffer, bShowAttributes);
                            delete pBuffer;
                            pBuffer = NULL;
                        }

                        ++pValues;
                    }
                    pSearch->FreeColumn(&ColumnData);
                }
                else if(hr == E_ADS_COLUMN_NOT_SET)
                    DisplayList(ppszAttributes[i], L"", bShowAttributes);
            }
            cListDisplayed++;
            
        }
        if(hr == S_ADS_NOMORE_ROWS)
            hr = S_OK;

        return hr;
    }
    else    
    {
        //
        //Display in table format
        //

        //
        //format will use first 80 rows to calculate column width
        //
        CFormatInfo format;
        LONG sampleSize = 80;

        //
        //sampleSize should be lessthan or equal to QueryLimit
        //
        if(g_iQueryLimit != 0 && (sampleSize > g_iQueryLimit))
            sampleSize = g_iQueryLimit;     

        LONG cRow = 0;
        hr = format.Init(sampleSize,cAttributes,ppszAttributes);
        if(FAILED(hr))
            return hr;

        //
        //Display in table format
        //
        while(TRUE)
        {

            //
            //we have reached sampleSize, so display column headers and
            //display all the sample rows.
            //
            if(cRow == sampleSize)
            {
                format.DisplayHeaders();
                format.DisplayAllRows();
            }

            hr = pSearch->GetNextRow();
            //We are done
            if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
                break;

            //
            //Check if we have reached querylimit
            //
            if(IsQueryLimitReached(cRow))
                break;

            //
            //Fetch columns
            //
            for( DWORD i = 0; i < cAttributes; ++i )
            {
                ADS_SEARCH_COLUMN ColumnData;
                hr = pSearch->GetColumn(ppszAttributes[i], &ColumnData);
                CComBSTR strValue;
                if(SUCCEEDED(hr))
                {
                    strValue = "";
                    ADSVALUE *pValues = ColumnData.pADsValues;                    
                    for( DWORD j = 0; j < ColumnData.dwNumValues; ++j )
                    {          
                        LPWSTR pBuffer = NULL;
                        hr = GetStringFromADs(pValues,
                                              ColumnData.dwADsType,
                                              &pBuffer, 
                                              ppszAttributes[i]);
                        //
                        //In table format multiple values are shown separated by ;
                        //
                        if(SUCCEEDED(hr))
                        {
                            strValue += pBuffer;
                            delete pBuffer;
                            pBuffer = NULL;
                            if(ColumnData.dwNumValues > 1)
                            {
                                strValue += L";";              
                            }
                        }
                        ++pValues;
                    }
                    pSearch->FreeColumn(&ColumnData);
                }   
                
                if(SUCCEEDED(hr) || hr == E_ADS_COLUMN_NOT_SET)
                {
                    if(cRow < sampleSize)
                    {
                        //
                        //Cache this value in format and use it to calculate column width
                        //
                        format.Set(cRow,i,strValue);
                    }
                    else 
                    {
                        //
                        //Display the column value
                        //
                        format.DisplayColumn(i,strValue);
                        if(i == (cAttributes - 1))
                            format.NewLine();

                    }                    
                }
            }
            
            ++cRow;

        }//End of while loop
        if(hr == S_ADS_NOMORE_ROWS)
            hr = S_OK;

        if(cRow && (cRow < sampleSize))
        {
            //
            //if total number of rows is less that sample size they are not 
            //displayed yet. Display them
            //
            format.DisplayHeaders();
            format.DisplayAllRows();
        }

        return hr;
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   OutputSingleAttr
//
//  Synopsis:   Displays the single attribute which user has asked for.
//  Arguments:  [ppszAttributes - IN] : Array containing list of attributes to display
//              [cAttributes - IN]: Count of attributes in ppszAttributes. Should be 1
//              [pSearch - IN]: pointer to search object
//  Returns     HRESULT  S_OK if Successful
//                       E_INVALIDARG
//                       Anything else is a failure code from an ADSI call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT OutputSingleAttr(IN LPWSTR * ppszAttributes,
                         IN DWORD cAttributes,
                         IN CDSSearch *pSearch)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, OutputSingleAttr, hr);

    if(!ppszAttributes || !cAttributes || !pSearch)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    ASSERT(cAttributes > 0);

    LONG cRow = 0;

    while(TRUE)
    {
        hr = pSearch->GetNextRow();
        
        //We are done
        if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
            break;
        //
        //Check if we have reached querylimit
        //
        if(IsQueryLimitReached(cRow))
            break;

        ADS_SEARCH_COLUMN ColumnData;
        hr = pSearch->GetColumn(ppszAttributes[0], &ColumnData);
        if(SUCCEEDED(hr))
        {
            LPWSTR pBuffer = NULL;
            hr = GetStringFromADs(ColumnData.pADsValues,
                                  ColumnData.dwADsType,
                                  &pBuffer, 
                                  ppszAttributes[0]);
            if(SUCCEEDED(hr))
            {
                //Display the output enclosed in Double Quotes
                CComBSTR strTemp;
                strTemp = L"\"" ;
                strTemp += pBuffer;
                strTemp += L"\"";
                DisplayOutput(strTemp);
                delete pBuffer;
                pBuffer = NULL;
            }
            pSearch->FreeColumn(&ColumnData);
        }
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            //
            //If Attribute is not set display ""
            //
            DisplayOutput(L"\"\"");
        }
        //
        //Increment number of Row displayed
        //
        cRow++;
    }//End of while loop
    
    if(hr == S_ADS_NOMORE_ROWS)
        hr = S_OK;

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   OutputAllAttr
//
//  Synopsis:   Displays all the attributes.
//  Arguments:  [pSearch - IN]: pointer to search object
//              [bAttrOnly - IN]: display attributes names only
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT OutputAllAttr(IN CDSSearch *pSearch, BOOL bAttrOnly)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, OutputAllAttr, hr);

    if(!pSearch)
    {        
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }
    LONG cRow = 0;

    while(TRUE)
    {
        hr = pSearch->GetNextRow();
        
        //We are done
        if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
            break;

        //
        //Check if we reached querylimit
        //
        if(IsQueryLimitReached(cRow))
            break;
        
        LPWSTR pszColumnName;
        BOOL bColumnNameDisplayed = FALSE;
        //
        //Get the name of next column which has value
        //
        while(pSearch->GetNextColumnName(&pszColumnName) != S_ADS_NOMORE_COLUMNS)
        {
            WCHAR szBuffer[MAXSTR];

            if(bAttrOnly)
            {
                //Security Review:Replace with strsafe api
                //NTRAID#NTBUG9-573989-2002/03/12-hiteshr
                //Its fine to truncate.
                hr = StringCchPrintf(szBuffer,MAXSTR, L"%ws ", pszColumnName);
                if(SUCCEEDED(hr))
                {
                    DisplayOutputNoNewline(szBuffer);
                    bColumnNameDisplayed = TRUE;
                }
            }
            else
            {
                ADS_SEARCH_COLUMN ColumnData;
                hr = pSearch->GetColumn(pszColumnName, &ColumnData);
                if(SUCCEEDED(hr))
                {
                    ADSVALUE *pValues = ColumnData.pADsValues;
                    for( DWORD j = 0; j < ColumnData.dwNumValues; ++j )
                    {                        
                        LPWSTR pBuffer = NULL;
                        hr = GetStringFromADs(pValues,
                                              ColumnData.dwADsType,
                                              &pBuffer, 
                                              pszColumnName);
                        if(SUCCEEDED(hr))
                        {
                            DisplayList(pszColumnName, pBuffer);
                            delete pBuffer;
                            pBuffer = NULL;
                        }
                        ++pValues;
                    }
                    pSearch->FreeColumn(&ColumnData);                
                }
                else if(hr == E_ADS_COLUMN_NOT_SET)
                    DisplayList(pszColumnName, L"");
            }
            pSearch->FreeColumnName(pszColumnName);            
        }

        
        if(bAttrOnly)
        {
            if(bColumnNameDisplayed)
            {               
                DisplayOutputNoNewline(L"\r\n");
                cRow++;
            }
        }
        else
            cRow++;

    }//End of while loop

    if(hr == S_ADS_NOMORE_ROWS)
        hr = S_OK;

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromADs
//
//  Synopsis:   Converts Value into string depending upon type
//  Arguments:  [pValues - IN]: Value to be converted to string
//              [dwADsType-IN]: ADSTYPE of pValue
//              [pBuffer - OUT]:Output buffer which gets the string 
//              [dwBufferLen-IN]:Size of output buffer
//              [pszAttrName-IN]:Name of the attribute being formatted
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR* ppBuffer, 
                         IN PCWSTR pszAttrName)
{
    HRESULT hr = S_OK;
    
    if(!pValues || !ppBuffer)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    
    if( dwADsType == ADSTYPE_INVALID )
    {
        return E_INVALIDARG;
    }
    
    switch( dwADsType ) 
    {
    case ADSTYPE_DN_STRING : 
        {
            CComBSTR sbstrOutputDN;
            hr = GetOutputDN( &sbstrOutputDN, pValues->DNString );
            if (FAILED(hr))
                return hr;
            
            UINT length = sbstrOutputDN.Length();
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //lenght + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer, (BSTR)sbstrOutputDN, length);
        }
        break;
        
    case ADSTYPE_CASE_EXACT_STRING :
        {
            //Security Review:This is null terminated.
            size_t length = wcslen(pValues->CaseExactString);
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //lenght + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer ,pValues->CaseExactString, length);
        }
        break;
        
    case ADSTYPE_CASE_IGNORE_STRING:
        {
            
            size_t length = wcslen(pValues->CaseIgnoreString);
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //lenght + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer ,pValues->CaseIgnoreString, length);
        }
        break;
        
    case ADSTYPE_PRINTABLE_STRING  :
        {
            //Security Review:Null terminated string.
            size_t length = wcslen(pValues->PrintableString);
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //lenght + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer ,pValues->PrintableString, length);
        }
        break;
        
    case ADSTYPE_NUMERIC_STRING    :
        {
            //Security Review:Null terminated string.
            size_t length = wcslen(pValues->NumericString);
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //lenght + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer ,pValues->NumericString, length);
        }
        break;
        
    case ADSTYPE_OBJECT_CLASS    :
        {
            //Security Review:Null terminated string.
            size_t length = wcslen(pValues->ClassName);
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //length + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer ,pValues->ClassName, length);
        }
        break;
        
    case ADSTYPE_BOOLEAN :
        {
            size_t length = 0;
            if (pValues->Boolean)
            {
                length = wcslen(L"TRUE");
                *ppBuffer = new WCHAR[length + 1];
            }
            else
            {
                length = wcslen(L"FALSE");
                *ppBuffer = new WCHAR[length + 1];
            }
            
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:Replace with strsafe api
            //NTRAID#NTBUG9-573989-2002/03/12-hiteshr
            hr = StringCchPrintf(*ppBuffer ,length + 1,L"%s", ((DWORD)pValues->Boolean) ? L"TRUE" : L"FALSE");
            if(FAILED(hr))
            {
                delete[] *ppBuffer;
                *ppBuffer = NULL;
                return hr;
            }                   

        }
        break;
        
    case ADSTYPE_INTEGER           :
        // Just allocate too much...
        *ppBuffer = new WCHAR[MAXSTR];
        if (!(*ppBuffer))
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        //Security Review:Correct Buffer size is passed.
        ZeroMemory(*ppBuffer, MAXSTR * sizeof(WCHAR));
        
        //Security Review:Replace with strsafe api
        //NTRAID#NTBUG9-573989-2002/03/12-hiteshr
        hr = StringCchPrintf(*ppBuffer,MAXSTR ,L"%d", (DWORD) pValues->Integer);
        if(FAILED(hr))
        {
            delete[] *ppBuffer;
            *ppBuffer = NULL;
            return hr;
        }                   
        break;
        
    case ADSTYPE_OCTET_STRING      :
        {               
            // I am just going to limit the buffer to MAXSTR.
            // It will be a rare occasion when someone wants
            // to look at a binary string that is not a GUID
            // or a SID.
            *ppBuffer = new WCHAR[MAXSTR];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, MAXSTR * sizeof(WCHAR));
            
            //
            //Special case objectguid and objectsid and sid history attribute
            //
            //Security Review:pszAttrName is null terminated
            if(pszAttrName && !_wcsicmp(pszAttrName, L"objectguid"))
            {
                GUID *pguid = (GUID*)pValues->OctetString.lpValue;
                StringFromGUID2(*pguid,(LPOLESTR)*ppBuffer,MAXSTR);
                break;
            }
            //Security Review:pszAttrName is null terminated
            if(pszAttrName && (!_wcsicmp(pszAttrName, L"objectsid") || !_wcsicmp(pszAttrName, L"sidhistory")))
            {
                LPWSTR pszSid = NULL;
                PSID pSid = (PSID)pValues->OctetString.lpValue;
                if(ConvertSidToStringSid(pSid, &pszSid))
                {
                    LocalFree(pszSid);
                    //Security Review:
                    //NTRAID#NTBUG9-574198-2002/03/12-hiteshr
                    //Its fine to truncate
                    hr = StringCchCopy(*ppBuffer,MAXSTR,pszSid);
                    if(FAILED(hr))
                    {
                        delete[] *ppBuffer;
                        *ppBuffer = NULL;
                        return hr;
                    }                   
                    break;
                }
            }
            
            for ( DWORD idx=0; idx<pValues->OctetString.dwLength; idx++) 
            {  
                BYTE  b = ((BYTE *)pValues->OctetString.lpValue)[idx];              
                //Security Review:Replace with strsafe api
                //NTRAID#NTBUG9-573989-2002/03/12-hiteshr
                WCHAR sOctet[128];
                hr = StringCchPrintf(sOctet,128,L"0x%02x ", b);                                      
                if(FAILED(hr))
                {
                    delete[] *ppBuffer;
                    *ppBuffer = NULL;
                    return hr;
                }                   

                if(FAILED(StringCchCat(*ppBuffer,MAXSTR,sOctet)))
                {
                    //We are truncating the string. We will display only
                    //MAXSTR -1 chars.
                    break;
                }
            }
        }
        break;
        
    case ADSTYPE_LARGE_INTEGER :     
        {
            CComBSTR strLarge;   
            LARGE_INTEGER li = pValues->LargeInteger;
            litow(li, strLarge);
            
            UINT length = strLarge.Length();
            *ppBuffer = new WCHAR[length + 1];
            if (!(*ppBuffer))
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            //Security Review:Correct Buffer size is passed.
            ZeroMemory(*ppBuffer, (length + 1) * sizeof(WCHAR));
            //Security Review:wcsncpy will copy length char
            //length + 1 is already set to zero so we are fine.
            wcsncpy(*ppBuffer,strLarge,length);
        }
        break;
        
    case ADSTYPE_UTC_TIME          :
        // The longest date can be 20 characters including the NULL
        *ppBuffer = new WCHAR[20];
        if (!(*ppBuffer))
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        //Security Review:Correct Buffer size is passed.
        ZeroMemory(*ppBuffer, sizeof(WCHAR) * 20);
        
        //Security Review:Replace with strsafe api
        //NTRAID#NTBUG9-573989-2002/03/12-hiteshr
        hr = StringCchPrintf(*ppBuffer,20,
            L"%02d/%02d/%04d %02d:%02d:%02d", pValues->UTCTime.wMonth, pValues->UTCTime.wDay, pValues->UTCTime.wYear,
            pValues->UTCTime.wHour, pValues->UTCTime.wMinute, pValues->UTCTime.wSecond 
            );
        //This should never fail
        if(FAILED(hr))
        {
            ASSERT(FALSE);
            delete[] *ppBuffer;
            *ppBuffer = NULL;
            return hr;
        }
        break;
        
    case ADSTYPE_NT_SECURITY_DESCRIPTOR: // I use the ACLEditor instead
        {
            if((pValues->SecurityDescriptor).lpValue)
            {
                LPWSTR pszSD = NULL;
                ULONG lLen = 0;
                if(ConvertSecurityDescriptorToStringSecurityDescriptor(
                    (PSECURITY_DESCRIPTOR )((pValues->SecurityDescriptor).lpValue),
                    SDDL_REVISION_1,
                    OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION,
                    &pszSD,
                    &lLen))
                {
                    if(pszSD)
                    {
                        //pszSD is null terminated.
                        size_t length = wcslen(pszSD);
                        *ppBuffer = new WCHAR[length + 1];
                        if (!(*ppBuffer))
                        {
                            hr = E_OUTOFMEMORY;
                            return hr;
                        }
                        //Security Review:Correct Buffer size is passed.
                        ZeroMemory(*ppBuffer, sizeof(WCHAR) * (length+1));
                        //Security Review:wcsncpy will copy length char
                        //length + 1 is already set to zero so we are fine.
                        wcsncpy(*ppBuffer,pszSD,length);    
                        LocalFree(pszSD);
                    }
                }
            }
        }
        break;
        
    default :
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\querytable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querytable.cpp
//
//  Contents:  Defines Table For Parser.
//
//  History:   24-Sep-2000    Hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "querytable.h"
#include "usage.h"
#include "querybld.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSQUERY_COMMON_COMMANDS[] = 
{
   COMMON_COMMANDS

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,  
   0,    
   0,  NULL,

   //
   // r,r
   //
   0,(LPWSTR)c_sz_arg1_com_recurse, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // o,outputformat
   //
   0,(LPWSTR)c_sz_arg1_com_output, 
   0,NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // startnode,startnode
   //
   // JonN 4/28/01 256583
   // Note that startnode can also be "domainroot" or "forestroot",
   // which just happen to be unaffected by the escaping functions.
   0,(LPWSTR)c_sz_arg1_com_startnode, 
   0,NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN|ARG_FLAG_NOFLAG,
   NULL,    
   0,  NULL,

   //
   // limit
   //
   0,(LPWSTR)c_sz_arg1_com_limit,
   0,NULL,
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,


   ARG_TERMINATOR

};

ARG_RECORD DSQUERY_STAR_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // scope
   //
   0, (PWSTR)g_pszArg1StarScope, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // filter
   //
   0, (PWSTR)g_pszArg1StarFilter, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // attr
   //
   0, (PWSTR)g_pszArg1StarAttr, 
   0, NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // attrsonly
   //
   0, (PWSTR)g_pszArg1StarAttrsOnly, 
   0, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // l, listoutput
   //
   0, (PWSTR)g_pszArg1StarList, 
   0, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR
};


ARG_RECORD DSQUERY_USER_COMMANDS[]=
{

   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // scope
   //
   0, (PWSTR)g_pszArg1UserScope, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Name
   //
   0, (PWSTR)g_pszArg1UserName, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Desc
   //
   0, (PWSTR)g_pszArg1UserDesc, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Upn
   //
   0, (PWSTR)g_pszArg1UserUpn, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Samid
   //
   0, (PWSTR)g_pszArg1UserSamid, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // inactive
   //
   0, (PWSTR)g_pszArg1UserInactive, 
   0, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // stalepwd
   //
   0, (PWSTR)g_pszArg1UserStalepwd, 
   0, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,


   //
   // -disabled
   //
   0, (PWSTR)g_pszArg1UserDisabled, 
   0, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSQUERY_COMPUTER_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // scope
   //
   0, (PWSTR)g_pszArg1ComputerScope,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   //name
   //
   0, (PWSTR)g_pszArg1ComputerName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1ComputerDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //samid
   //
   0, (PWSTR)g_pszArg1ComputerSamid,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //inactive
   //
   0, (PWSTR)g_pszArg1ComputerInactive,
   0, NULL,
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // stalepwd
   //
   0, (PWSTR)g_pszArg1ComputerStalepwd, 
   0, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,


   //
   //disabled
   //
   0, (PWSTR)g_pszArg1ComputerDisabled,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSQUERY_GROUP_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // scope
   //
   0, (PWSTR)g_pszArg1GroupScope,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   //name
   //
   0, (PWSTR)g_pszArg1GroupName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1GroupDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //samid
   //
   0, (PWSTR)g_pszArg1GroupSamid,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSQUERY_OU_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // scope
   //
   0, (PWSTR)g_pszArg1OUScope,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   //name
   //
   0, (PWSTR)g_pszArg1OUName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1OUDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_CONTACT_COMMANDS[]=
{

   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // scope
   //
   0, (PWSTR)g_pszArg1UserScope, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Name
   //
   0, (PWSTR)g_pszArg1UserName, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Desc
   //
   0, (PWSTR)g_pszArg1UserDesc, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_SERVER_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // forest - Forest
   //
   0, (PWSTR)g_pszArg1ServerForest,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // domain - Domain
   //
   0, (PWSTR)c_sz_arg2_com_domain,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // site - Site
   //
   0, (PWSTR)g_pszArg1ServerSite,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // name - Name
   //
   0, (PWSTR)g_pszArg1ServerName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1ServerDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // hasfsmo 
   //
   0, (PWSTR)g_pszArg1ServerHasFSMO,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // isgc 
   //
   0, (PWSTR)g_pszArg1ServerIsGC,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_SITE_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   //name
   //
   0, (PWSTR)g_pszArg1SiteName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1SiteDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_SUBNET_COMMANDS[]=
{
   //
   // ronmart 9/10/02 701516 - gc is not a common param
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   //name
   //
   0, (PWSTR)g_pszArg1SubnetName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1SubnetDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //Location
   //
   0, (PWSTR)g_pszArg1SubnetLoc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //site
   //
   0, (PWSTR)g_pszArg1SubnetSite,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};



ARG_RECORD DSQUERY_QUOTA_COMMANDS[]=
{
   //
   // acct
   //
   0, (PWSTR)g_pszArg1QuotaAcct,
   0, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL | ARG_FLAG_STDIN,
   NULL,
   0,  NULL,

   //
   // qlimit
   //
   0, (PWSTR)g_pszArg1QuotaQLimit,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // Desc
   //
   0, (PWSTR)g_pszArg1QuotaDesc, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

    ARG_TERMINATOR,

};


ARG_RECORD DSQUERY_PARTITION_COMMANDS[]=
{
   //
   // Partition
   //
   0,(PWSTR)g_pszArg1PartitionPart, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Desc
   //
   0, (PWSTR)g_pszArg1PartitionDesc, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

    ARG_TERMINATOR,

};

//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------
//
// filter, this is no ds attribute, but dummy attribute for commandline filter 
// specified in case of dsquery *

//Star Filter
DSQUERY_ATTR_TABLE_ENTRY StarFilterEntry =
{
   L"filter",
   eStarFilter,
   NULL,
   StarFilterFunc,   
};


//
// name
//
DSATTRIBUTEDESCRIPTION name=
{
   {
      L"cn",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User Name
DSQUERY_ATTR_TABLE_ENTRY UserNameEntry =
{
   L"cn",
   eUserName,
   &name,
   CommonFilterFunc,   
};

//Computer Name
DSQUERY_ATTR_TABLE_ENTRY ComputerNameEntry =
{
   L"cn",
   eComputerName,
   &name,
   CommonFilterFunc,   
};

//Group Name
DSQUERY_ATTR_TABLE_ENTRY GroupNameEntry =
{
   L"cn",
   eGroupName,
   &name,
   CommonFilterFunc,   
};

//OU Name
DSQUERY_ATTR_TABLE_ENTRY OUNameEntry =
{
   L"ou",
   eOUName,
   &name,
   CommonFilterFunc,   
};

// Server Name
DSQUERY_ATTR_TABLE_ENTRY ServerNameEntry =
{
   L"cn",
   eServerName,
   &name,
   CommonFilterFunc,
};

// Site Name
DSQUERY_ATTR_TABLE_ENTRY SiteNameEntry =
{
   L"cn",
   eSiteName,
   &name,
   CommonFilterFunc,
};

// Contact Name
DSQUERY_ATTR_TABLE_ENTRY ContactNameEntry =
{
   L"cn",
   eContactName,
   &name,
   CommonFilterFunc,
};

// Subnet Name
DSQUERY_ATTR_TABLE_ENTRY SubnetNameEntry =
{
   L"cn",
   eSubnetName,
   &name,
   CommonFilterFunc,
};


//
// Description
//
DSATTRIBUTEDESCRIPTION description =
{
   {
      L"description",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User Description
DSQUERY_ATTR_TABLE_ENTRY UserDescEntry =
{
   L"description",
   eUserDesc,
   &description,
   CommonFilterFunc,   
};

//Computer Description
DSQUERY_ATTR_TABLE_ENTRY ComputerDescEntry =
{
   L"description",
   eComputerDesc,
   &description,
   CommonFilterFunc,   
};

//Group Description
DSQUERY_ATTR_TABLE_ENTRY GroupDescEntry =
{
   L"description",
   eGroupDesc,
   &description,
   CommonFilterFunc,   
};

//OU Description
DSQUERY_ATTR_TABLE_ENTRY OUDescEntry =
{
   L"description",
   eOUDesc,
   &description,
   CommonFilterFunc,   
};

//Server Description
DSQUERY_ATTR_TABLE_ENTRY ServerDescEntry =
{
   L"description",
   eServerDesc,
   &description,
   CommonFilterFunc,   
};

//Site Description
DSQUERY_ATTR_TABLE_ENTRY SiteDescEntry =
{
   L"description",
   eSiteDesc,
   &description,
   CommonFilterFunc,   
};

//Cotnact Description
DSQUERY_ATTR_TABLE_ENTRY ContactDescEntry =
{
   L"description",
   eContactDesc,
   &description,
   CommonFilterFunc,   
};

//Subnet Description
DSQUERY_ATTR_TABLE_ENTRY SubnetDescEntry =
{
   L"description",
   eSubnetDesc,
   &description,
   CommonFilterFunc,   
};

//Quota Description
DSQUERY_ATTR_TABLE_ENTRY QuotaDescEntry =
{
   L"description",
   eQuotaDesc,
   &description,
   CommonFilterFunc,   
};

//
// UPN
//
DSATTRIBUTEDESCRIPTION upn =
{
   {
      L"userPrincipalName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User Upn
DSQUERY_ATTR_TABLE_ENTRY UserUPNEntry =
{
   L"userPrincipalName",
   eUserUPN,
   &upn,
   CommonFilterFunc,
};


//
// SAM Account Name
//
DSATTRIBUTEDESCRIPTION samAccountName =
{
   {
      L"sAMAccountName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User SAM Account
DSQUERY_ATTR_TABLE_ENTRY UserSamidEntry =
{
   L"sAMAccountName",
   eUserSamid,
   &samAccountName,
   CommonFilterFunc,   
};
//Computer samAccountName
DSQUERY_ATTR_TABLE_ENTRY ComputerSamidEntry =
{
   L"sAMAccountName",
   eComputerSamid,
   &samAccountName,
   CommonFilterFunc,   
};

//Group samAccountName
DSQUERY_ATTR_TABLE_ENTRY GroupSamidEntry =
{
   L"sAMAccountName",
   eGroupSamid,
   &samAccountName,
   CommonFilterFunc,   
};

//User Disabled
DSQUERY_ATTR_TABLE_ENTRY UserDisabledEntry =
{
   L"disabled",
   eUserDisabled,
   NULL,
   DisabledFilterFunc,   
};

//Computer Disabled
DSQUERY_ATTR_TABLE_ENTRY ComputerDisabledEntry =
{
   L"disabled",
   eComputerDisabled,
   NULL,
   DisabledFilterFunc,   
};

//User Inactive
DSQUERY_ATTR_TABLE_ENTRY UserInactiveEntry =
{
   L"inactive",
   eUserInactive,
   NULL,
   InactiveUserFilterFunc,   
};

//Computer Inactive
DSQUERY_ATTR_TABLE_ENTRY ComputerInactiveEntry =
{
   L"inactive",
   eComputerInactive,
   NULL,
   InactiveComputerFilterFunc,   
};

//User stalepwd
DSQUERY_ATTR_TABLE_ENTRY UserStalepwdEntry =
{
   L"stalepwd",
   eUserStalepwd,
   NULL,
   StalepwdUserFilterFunc,   
};

//Computer stalepwd
DSQUERY_ATTR_TABLE_ENTRY ComputerStalepwdEntry =
{
   L"stalepwd",
   eComputerStalepwd,
   NULL,
   StalepwdComputerFilterFunc,   
};

//
// Locations
//
DSATTRIBUTEDESCRIPTION location =
{
   {
      L"location",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};
//Subnet location
DSQUERY_ATTR_TABLE_ENTRY SubnetLocEntry=
{
   L"location",
   eSubnetLoc,
   &location,
   CommonFilterFunc,   
};

//
// SiteObject
//
DSATTRIBUTEDESCRIPTION siteObject=
{
   {
      L"siteObject",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};
//Subnet Site
DSQUERY_ATTR_TABLE_ENTRY SubnetSiteEntry=
{
   L"siteObject",
   eSubnetSite,
   &siteObject,
   SubnetSiteFilterFunc,   
};

// acct
DSATTRIBUTEDESCRIPTION quotaAcct =
{
   {
      L"msDS-QuotaTrustee",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};


DSQUERY_ATTR_TABLE_ENTRY QuotaEntryAcct =
{
   L"acct",
   eQuotaAcct,
   &quotaAcct,
   AccountFilterFunc,   
};

// qlimit
DSATTRIBUTEDESCRIPTION quotaQLimit =
{
   {
      L"msDS-QuotaAmount",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};


DSQUERY_ATTR_TABLE_ENTRY QuotaEntryQLimit =
{
   L"qlimit",
   eQuotaQLimit,
   &quotaQLimit,
   QLimitFilterFunc,
};


// Quota desc
DSQUERY_ATTR_TABLE_ENTRY QuotaEntryDesc =
{
   L"description",
   eQuotaDesc,
   &description,
   CommonFilterFunc,
};


// part
DSATTRIBUTEDESCRIPTION partitionPart =
{
   {
      L"part",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};


DSQUERY_ATTR_TABLE_ENTRY PartitionEntryPart =
{
   L"cn",
   ePartitionPart,
   &partitionPart,
   CommonFilterFunc,
};

// Partition desc
DSQUERY_ATTR_TABLE_ENTRY PartitionEntryDesc =
{
   L"description",
   ePartitionDesc,
   &description,
   CommonFilterFunc,
};

//
//Valid OutputStrings for each objecttype
//
//

DSQUERY_OUTPUT_FORMAT_MAP g_format_dn =
{
    g_pszDN,
    DSQUERY_OUTPUT_DN
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_rdn =
{
    g_pszRDN,
    DSQUERY_OUTPUT_RDN
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_upn =
{
    g_pszUPN,
    DSQUERY_OUTPUT_UPN
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_samid =
{
    g_pszSamId,
    DSQUERY_OUTPUT_SAMID
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_ntlmid =
{
    g_pszNtlmId,
    DSQUERY_OUTPUT_NTLMID
};

PDSQUERY_OUTPUT_FORMAT_MAP UserOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn,
   &g_format_upn,
   &g_format_samid,
   &g_format_ntlmid
};

//Computer
PDSQUERY_OUTPUT_FORMAT_MAP ComputerOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn,
   &g_format_samid,
   &g_format_ntlmid
};
//Group
PDSQUERY_OUTPUT_FORMAT_MAP GroupOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn,
   &g_format_samid,
   &g_format_ntlmid
};
//OU
PDSQUERY_OUTPUT_FORMAT_MAP OuOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Contact
PDSQUERY_OUTPUT_FORMAT_MAP ContactOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Server
PDSQUERY_OUTPUT_FORMAT_MAP ServerOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Site
PDSQUERY_OUTPUT_FORMAT_MAP SiteOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Subnet
PDSQUERY_OUTPUT_FORMAT_MAP SubnetOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

// Quota
PDSQUERY_OUTPUT_FORMAT_MAP QuotaOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

// Partition
PDSQUERY_OUTPUT_FORMAT_MAP PartitionOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Attribute Table entries and ObjectTableEntries
//
//
//* Star
//
PDSQUERY_ATTR_TABLE_ENTRY StarAttributeTable[] =
{
   &StarFilterEntry,   
};

DSQueryObjectTableEntry g_StarObjectEntry = 
{
   L"*",
   g_pszStar,
   DSQUERY_STAR_COMMANDS,
   USAGE_DSQUERY_STAR,
   sizeof(StarAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   StarAttributeTable,
   0,
   NULL,
   eStarScope,
   g_pszDefStarFilter,
   NULL
};


//
// User
//

PDSQUERY_ATTR_TABLE_ENTRY UserAttributeTable[] =
{
   &UserNameEntry,
   &UserUPNEntry,
   &UserDescEntry,
   &UserSamidEntry,
   &UserDisabledEntry,
   &UserInactiveEntry,
   &UserStalepwdEntry
};

DSQueryObjectTableEntry g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSQUERY_USER_COMMANDS,
   USAGE_DSQUERY_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable,
   sizeof(UserOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   UserOutputFormatMap,
   eUserScope,
   g_pszDefUserFilter,
   g_pszDefUserFilter
};


//
// Computer
//

PDSQUERY_ATTR_TABLE_ENTRY ComputerAttributeTable[] =
{
   &ComputerNameEntry,   
   &ComputerDescEntry,
   &ComputerSamidEntry,
   &ComputerDisabledEntry,
   &ComputerInactiveEntry,
   &ComputerStalepwdEntry
};

DSQueryObjectTableEntry g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSQUERY_COMPUTER_COMMANDS,
   USAGE_DSQUERY_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable,
   sizeof(ComputerOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   ComputerOutputFormatMap,
   eComputerScope,
   g_pszDefComputerFilter,
   g_pszDefComputerFilter
};

//
// Group
//
PDSQUERY_ATTR_TABLE_ENTRY GroupAttributeTable[] =
{
   &GroupNameEntry,   
   &GroupDescEntry,
   &GroupSamidEntry
};

DSQueryObjectTableEntry g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSQUERY_GROUP_COMMANDS,
   USAGE_DSQUERY_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable,
   sizeof(GroupOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   GroupOutputFormatMap,
   eGroupScope,
   g_pszDefGroupFilter,
   g_pszDefGroupFilter
};


//
// OU
//
PDSQUERY_ATTR_TABLE_ENTRY OUAttributeTable[] =
{
   &OUNameEntry,   
   &OUDescEntry
};

DSQueryObjectTableEntry g_OUObjectEntry = 
{
   L"ou",
   g_pszOU,
   DSQUERY_OU_COMMANDS,
   USAGE_DSQUERY_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable,
   sizeof(OuOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   OuOutputFormatMap,
   eOUScope,
   g_pszDefOUFilter,
   g_pszDefOUFilter
};

//
// Server
//
PDSQUERY_ATTR_TABLE_ENTRY ServerAttributeTable[] =
{
   &ServerNameEntry,   
   &ServerDescEntry
};

DSQueryObjectTableEntry g_ServerObjectEntry = 
{
   L"server",
   g_pszServer,
   DSQUERY_SERVER_COMMANDS,
   USAGE_DSQUERY_SERVER,
   sizeof(ServerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ServerAttributeTable,
   sizeof(ServerOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   ServerOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefServerFilter,
   g_pszDefServerFilter
};

//
// Site
//
PDSQUERY_ATTR_TABLE_ENTRY SiteAttributeTable[] =
{
   &SiteNameEntry,   
   &SiteDescEntry
};

DSQueryObjectTableEntry g_SiteObjectEntry = 
{
   L"site",
   g_pszSite,
   DSQUERY_SITE_COMMANDS,
   USAGE_DSQUERY_SITE,
   sizeof(SiteAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SiteAttributeTable,
   sizeof(SiteOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   SiteOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefSiteFilter,
   g_pszDefSiteFilter
};

//
// Contact
//

PDSQUERY_ATTR_TABLE_ENTRY ContactAttributeTable[] =
{
   &ContactNameEntry,
   &ContactDescEntry,
};

DSQueryObjectTableEntry g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSQUERY_CONTACT_COMMANDS,
   USAGE_DSQUERY_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable,
   sizeof(ContactOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   ContactOutputFormatMap,
   eContactScope,
   g_pszDefContactFilter,
   g_pszDefContactFilter
};

//
// Subnet
//
PDSQUERY_ATTR_TABLE_ENTRY SubnetAttributeTable[] =
{
   &SubnetNameEntry,   
   &SubnetDescEntry,
   &SubnetLocEntry,
   &SubnetSiteEntry,
};

DSQueryObjectTableEntry g_SubnetObjectEntry = 
{
   L"subnet",
   g_pszSubnet,
   DSQUERY_SUBNET_COMMANDS,
   USAGE_DSQUERY_SUBNET,
   sizeof(SubnetAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SubnetAttributeTable,
   sizeof(SubnetOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   SubnetOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefSubnetFilter,
   g_pszDefSubnetFilter
};

//
// Quota
//
PDSQUERY_ATTR_TABLE_ENTRY QuotaAttributeTable[] =
{
   &QuotaEntryAcct,
   &QuotaEntryQLimit,
   &QuotaEntryDesc,
};

DSQueryObjectTableEntry g_QuotaObjectEntry = 
{
   L"msDS-QuotaControl",
   g_pszQuota,
   DSQUERY_QUOTA_COMMANDS,
   USAGE_DSQUERY_QUOTA,
   sizeof(QuotaAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   QuotaAttributeTable,
   sizeof(QuotaOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   QuotaOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefQuotaFilter,
   g_pszDefQuotaFilter
};

//
// Partition
//
PDSQUERY_ATTR_TABLE_ENTRY PartitionAttributeTable[] =
{
   &PartitionEntryPart,
   &PartitionEntryDesc
};

DSQueryObjectTableEntry g_PartitionObjectEntry = 
{
   L"RootDSE", // ignored
   g_pszPartition,
   DSQUERY_PARTITION_COMMANDS,
   USAGE_DSQUERY_PARTITION,
   sizeof(PartitionAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   PartitionAttributeTable,
   sizeof(PartitionOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   PartitionOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefPartitionFilter,
   g_pszDefPartitionFilter
};


//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSQueryObjectTableEntry g_DSObjectTable[] =
{
   &g_StarObjectEntry,
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_ServerObjectEntry,
   &g_SiteObjectEntry,
   &g_ContactObjectEntry,
   &g_SubnetObjectEntry,
   &g_QuotaObjectEntry,
   &g_PartitionObjectEntry,
   NULL
};



//+-------------------------------------------------------------------------
// Usage Table
//--------------------------------------------------------------------------
UINT USAGE_DSQUERY[] =
{
	USAGE_DSQUERY_DESCRIPTION,
	USAGE_DSQUERY_REMARKS,
	USAGE_DSQUERY_EXAMPLES,
	USAGE_END
};

UINT USAGE_DSQUERY_STAR[] =
{
	USAGE_DSQUERY_STAR_DESCRIPTION,
	USAGE_DSQUERY_STAR_SYNTAX,
	USAGE_DSQUERY_STAR_PARAMETERS,
	USAGE_DSQUERY_STAR_REMARKS,
	USAGE_DSQUERY_STAR_EXAMPLES,
	USAGE_DSQUERY_STAR_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_USER[] =
{
	USAGE_DSQUERY_USER_DESCRIPTION,
	USAGE_DSQUERY_USER_SYNTAX,
	USAGE_DSQUERY_USER_PARAMETERS,
	USAGE_DSQUERY_USER_REMARKS,
	USAGE_DSQUERY_USER_EXAMPLES,
	USAGE_DSQUERY_USER_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_COMPUTER[] =
{
	USAGE_DSQUERY_COMPUTER_DESCRIPTION,
	USAGE_DSQUERY_COMPUTER_SYNTAX,
	USAGE_DSQUERY_COMPUTER_PARAMETERS,
	USAGE_DSQUERY_COMPUTER_REMARKS,
	USAGE_DSQUERY_COMPUTER_EXAMPLES,
	USAGE_DSQUERY_COMPUTER_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_GROUP[] =
{
	USAGE_DSQUERY_GROUP_DESCRIPTION,
	USAGE_DSQUERY_GROUP_SYNTAX,
	USAGE_DSQUERY_GROUP_PARAMETERS,
	USAGE_DSQUERY_GROUP_REMARKS,
	USAGE_DSQUERY_GROUP_EXAMPLES,
	USAGE_DSQUERY_GROUP_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_OU[] =
{
	USAGE_DSQUERY_OU_DESCRIPTION,
	USAGE_DSQUERY_OU_SYNTAX,
	USAGE_DSQUERY_OU_PARAMETERS,
	USAGE_DSQUERY_OU_REMARKS,
	USAGE_DSQUERY_OU_EXAMPLES,
	USAGE_DSQUERY_OU_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_SERVER[] =
{
	USAGE_DSQUERY_SERVER_DESCRIPTION,
	USAGE_DSQUERY_SERVER_SYNTAX,
	USAGE_DSQUERY_SERVER_PARAMETERS,
	USAGE_DSQUERY_SERVER_REMARKS,
	USAGE_DSQUERY_SERVER_EXAMPLES,
	USAGE_DSQUERY_SERVER_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_CONTACT[] =
{
	USAGE_DSQUERY_CONTACT_DESCRIPTION,
	USAGE_DSQUERY_CONTACT_SYNTAX,
	USAGE_DSQUERY_CONTACT_PARAMETERS,
	USAGE_DSQUERY_CONTACT_REMARKS,
	USAGE_DSQUERY_CONTACT_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_SUBNET[] =
{
	USAGE_DSQUERY_SUBNET_DESCRIPTION,
	USAGE_DSQUERY_SUBNET_SYNTAX,
	USAGE_DSQUERY_SUBNET_PARAMETERS,
	USAGE_DSQUERY_SUBNET_REMARKS,
	USAGE_DSQUERY_SUBNET_EXAMPLES,
	USAGE_END
};

UINT USAGE_DSQUERY_SITE[] =
{
	USAGE_DSQUERY_SITE_DESCRIPTION,
	USAGE_DSQUERY_SITE_SYNTAX,
	USAGE_DSQUERY_SITE_PARAMETERS,
	USAGE_DSQUERY_SITE_REMARKS,
	USAGE_DSQUERY_SITE_EXAMPLES,
	USAGE_DSQUERY_SITE_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_QUOTA[] =
{
	USAGE_DSQUERY_QUOTA_DESCRIPTION,
	USAGE_DSQUERY_QUOTA_SYNTAX,
	USAGE_DSQUERY_QUOTA_PARAMETERS,
	USAGE_DSQUERY_QUOTA_REMARKS,
	USAGE_DSQUERY_QUOTA_EXAMPLES,
	USAGE_DSQUERY_QUOTA_SEE_ALSO,
	USAGE_END
};

UINT USAGE_DSQUERY_PARTITION[] =
{
	USAGE_DSQUERY_PARTITION_DESCRIPTION,
	USAGE_DSQUERY_PARTITION_SYNTAX,
	USAGE_DSQUERY_PARTITION_PARAMETERS,
	USAGE_DSQUERY_PARTITION_REMARKS,
	USAGE_DSQUERY_PARTITION_EXAMPLES,
	USAGE_DSQUERY_PARTITION_SEE_ALSO,
	USAGE_END
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsquery.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_FILTER_LAST_LOGON_VERSION   101
#define IDS_DEFAULT_QUERY_LIMIT_REACHED 102
#define IDS_QUERY_LIMIT_REACHED         103
#define IDS_FOREST_SEARCH_SCOPE         104
#define IDS_INVALID_OBJECTTYPE          105
#define IDS_INVALID_OUTPUT              106
#define IDS_O_NOT_FOR_STAR              107
#define IDS_ERROR_SCOPE                 108
#define IDS_ERROR_LIMIT                 109
#define IDS_SEVER_NOT_GC                110
#define IDS_MSG_INVALID_ACCT_ERROR      111
#define IDS_FOREST_SEARCH_SCOPE_QUOTAS  112

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\querytable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querytable.h
//
//  Contents:  Defines Enum for parsertable.
//
//  History:   25-Sep-2000    hiteshr Created
//
//--------------------------------------------------------------------------

#ifndef _QUERYTABLE_H_
#define _QUERYTABLE_H_

//forward declarations
struct _DSQUERY_ATTRTABLE_ENTRY;

//+-------------------------------------------------------------------------
// 
//  Type:      PMAKEFILTERFUNC
//
//  Synopsis:  The definition of a function that prepares ldapFilter from
//             the infix filter given on the commandline.
//
//
//  Returns:   S_OK if the pAttr members were successfully set.
//             S_FALSE if the function failed but displayed its own error message. 
//
//  History:   25-Sep-2000    hiteshr     Created
//
//---------------------------------------------------------------------------
typedef HRESULT (*PMAKEFILTERFUNC)(_DSQUERY_ATTRTABLE_ENTRY *pEntry,
                                   ARG_RECORD* pRecord,
                                   CDSCmdBasePathsInfo& refBasePathsInfo,
                                   CDSCmdCredentialObject& refCredentialObject,
                                   PVOID pVoid,
                                   CComBSTR &strFilter);

//+--------------------------------------------------------------------------
//
//  Struct:     _DSQUERY_ATTRTABLE_ENTRY
//
//  Purpose:    Definition of a table entry that describes the attribute for
//              which filter can be specified at commandline.
//
//  History:    25-Sep-2000 hiteshr  Created
//
//---------------------------------------------------------------------------
typedef struct _DSQUERY_ATTRTABLE_ENTRY
{
   //
   // The ldapDisplayName of the attribute
   //
   PWSTR          pszName;

   //
   // The unique identifier for this attribute that cooresponds to
   // the command line switch
   //
   UINT           nAttributeID;

   //
   // Pointer to the description of the attribute
   //
   PDSATTRIBUTEDESCRIPTION pAttrDesc;

   //
   //  function that prepares ldapFilter from
   //  the infix filter given on the commandline.
   //
   PMAKEFILTERFUNC pMakeFilterFunc;

} DSQUERY_ATTR_TABLE_ENTRY, *PDSQUERY_ATTR_TABLE_ENTRY;

typedef enum{
	DSQUERY_OUTPUT_ATTRONLY,	//Only the names of attributes
    DSQUERY_OUTPUT_ATTR,		//Attribute list given at commandline
    DSQUERY_OUTPUT_DN,			//DN
    DSQUERY_OUTPUT_RDN,			//RDN
    DSQUERY_OUTPUT_UPN,			//UPN
    DSQUERY_OUTPUT_SAMID,		//SAMID
    DSQUERY_OUTPUT_NTLMID,
}DSQUERY_OUTPUT_FORMAT;


typedef struct _DSQUERY_OUTPUT_FORMAT_MAP
{
    LPCWSTR pszOutputFormat;
    DSQUERY_OUTPUT_FORMAT  outputFormat;
}DSQUERY_OUTPUT_FORMAT_MAP,*PDSQUERY_OUTPUT_FORMAT_MAP;


//+--------------------------------------------------------------------------
//
//  Struct:     _DSQueryObjectTableEntry
//
//  Purpose:    Definition of a table entry that describes attributes of a given
//              objecttype
//
//  History:    25-Sep-2000 hiteshr Created
//
//---------------------------------------------------------------------------

typedef struct _DSQueryObjectTableEntry
{
   //
   // The objectClass of the object to be created or modified
   //
   PCWSTR pszObjectClass;

   //
   // The command line string used to determine the object class
   // This is not always identical to pszObjectClass
   //
   PCWSTR pszCommandLineObjectType;

   //
   // The table to merge with the common switches for the parser
   //
   ARG_RECORD* pParserTable;

   //
   // The ID of the Usage help text for this 
   //
   UINT* pUsageTable;

   //
   // A count of the number of attributes in the table below
   //
   DWORD dwAttributeCount;

   //
   // A table of attributes for
   // which filter can be specified at commandline.
   //
   DSQUERY_ATTR_TABLE_ENTRY** pAttributeTable; 

   //
   // A count of the number of output formats in the table below
   //
   DWORD dwOutputCount;

   //
   // Array of valid values for Output format. NULL in case of dsquery *
   //
   PDSQUERY_OUTPUT_FORMAT_MAP *ppValidOutput;

   //
   // The unique identifier for commandline scope switch in ParserTable
   // -1 if not applicable
   //
   UINT           nScopeID;

   //
   //This is the default fiter to use in case no filter is specified on commandline
   //
   LPCWSTR pszDefaultFilter;

   //
   //Append this filter to filter specifed at commandline.
   //
   LPCWSTR pszPrefixFilter;

   // Some sort of creation function
} DSQueryObjectTableEntry, *PDSQueryObjectTableEntry;


typedef enum DSQUERY_COMMAND_ENUM
{
   eCommObjectType = eCommLast+1,   
   eCommRecurse,
   eCommOutputFormat,
   eCommStartNode,   
   eCommLimit,
   eTerminator,

   //
   // Star switches
   //
   eStarGC = eTerminator, 
   eStarScope,
   eStarFilter,
   eStarAttr,
   eStarAttrsOnly,
   eStarList,

   //
   // User switches
   //
   eUserGC = eTerminator,
   eUserScope,
   eUserName,
   eUserDesc,
   eUserUPN,
   eUserSamid,
   eUserInactive,
   eUserStalepwd,
   eUserDisabled,

   //
   // Computer switches
   //
   eComputerGC = eTerminator,
   eComputerScope,
   eComputerName,
   eComputerDesc,
   eComputerSamid,
   eComputerInactive,
   eComputerStalepwd,
   eComputerDisabled,

   //
   // Group switches
   //
   eGroupGC = eTerminator,
   eGroupScope,
   eGroupName,
   eGroupDesc,
   eGroupSamid,

   //
   // OU switches
   //
   eOUGC = eTerminator,
   eOUScope,
   eOUName,
   eOUDesc,

   //
   // Server switches
   //
   eServerGC = eTerminator,
   eServerForest,
   eServerDomain,
   eServerSite,
   eServerName,
   eServerDesc,
   eServerHasFSMO,
   eServerIsGC,

   //
   // Site switches
   //
   eSiteGC = eTerminator,
   eSiteName,
   eSiteDesc,

   //
   //Contact switches
   //
   eContactGC = eTerminator,
   eContactScope,
   eContactName,
   eContactDesc,

   //
   //Subnet switches
   //
   eSubnetGC = eTerminator,
   eSubnetName,
   eSubnetDesc,
   eSubnetLoc,
   eSubnetSite,
    
   //
   // Quota switches
   //
   eQuotaAcct = eTerminator,
   eQuotaQLimit,
   eQuotaDesc,

   //
   // Partition switches
   //
   ePartitionPart = eTerminator,
   ePartitionDesc,
};

//
// The parser table
//
extern ARG_RECORD DSQUERY_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSQueryObjectTableEntry g_DSObjectTable[];

//
//Usage Tables
//
extern UINT USAGE_DSQUERY[];
extern UINT USAGE_DSQUERY_STAR[];
extern UINT USAGE_DSQUERY_USER[];
extern UINT USAGE_DSQUERY_COMPUTER[];
extern UINT USAGE_DSQUERY_GROUP[];
extern UINT USAGE_DSQUERY_OU[];
extern UINT USAGE_DSQUERY_SERVER[];
extern UINT USAGE_DSQUERY_CONTACT[];
extern UINT USAGE_DSQUERY_SUBNET[];
extern UINT USAGE_DSQUERY_SITE[];
extern UINT USAGE_DSQUERY_QUOTA[];
extern UINT USAGE_DSQUERY_PARTITION[];

#endif //_QUERYTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\querybld.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querybld.cpp
//
//  Contents:  Contains implementatin of functions to build query.
//
//  History:   24-Sep-2000    Hiteshr  Created
//             
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "cstrings.h"
#include "querytable.h"
#include "usage.h"
#include "querybld.h"
#include "resource.h" // For IDS_MSG_INVALID_ACCT_ERROR
#include <lmaccess.h> // UF_ACCOUNTDISABLE and UF_DONT_EXPIRE_PASSWD
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W
#include <Sddl.h>     // For ConvertSidToStringSid

static const LPWSTR g_szUserAccountCtrlQuery = L"(userAccountControl:" LDAP_MATCHING_RULE_BIT_AND_W L":=%u)";
static const LPWSTR g_szServerIsGCQuery = L"(&(objectCategory=NTDS-DSA)(options:" LDAP_MATCHING_RULE_BIT_AND_W L":=1))";


static const LPWSTR g_szCommonQueryFormat= L"(%s=%s)"; 




//+--------------------------------------------------------------------------
//
//  Function:   LdapEscape
//
//  Synopsis:   Escape the characters in *[pszInput] as required by
//              RFC 2254.
//
//  Arguments:  [pszInput] - string to escape
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      RFC 2254
//
//              If a value should contain any of the following characters
//
//                     Character       ASCII value
//                     ---------------------------
//                     *               0x2a
//                     (               0x28
//                     )               0x29
//                     \               0x5c
//                     NUL             0x00
//
//              the character must be encoded as the backslash '\'
//              character (ASCII 0x5c) followed by the two hexadecimal
//              digits representing the ASCII value of the encoded
//              character.  The case of the two hexadecimal digits is not
//              significant.
//
//---------------------------------------------------------------------------

bool
LdapEscape(IN LPCWSTR pszInput, OUT CComBSTR& strFilter)
{
	if(!pszInput)
		return FALSE;


	//Security Review:pszInput is null terminated.
	int iLen = (int)wcslen(pszInput);
	
	for( int i = 0; i < iLen; ++i)
	{
        switch (*(pszInput+i))
        {
        case L'(':
            strFilter += L"\\28";
            break;

        case L')':
            strFilter += L"\\29";
            break;

        case L'\\':
			if( i + 1 < iLen )
			{
				// \\ is treated as '\'
				switch (*(pszInput+i + 1))
				{
				case L'\\':
					strFilter += L"\\5c";
					i++;
					break;
				// \* is treated as '*'					
				case L'*':
					strFilter += L"\\2a";
					i++;
					break;
				default:
				// \X is treated \X only
					strFilter += L"\\5c";
					break;
				}
			}
			else
				strFilter += L"\\5c";
			           
            break;

        default:
			strFilter.Append(pszInput+i,1);
			break;
        }
    }
	return TRUE;
}


HRESULT MakeQuery(IN LPCWSTR pszAttrName,
                  IN LPCWSTR pszCommandLineFilter,
                  OUT CComBSTR& strFilter)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, MakeQuery, hr);

    if(!pszAttrName || !pszCommandLineFilter)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

	CComBSTR strEscapedCLFilter;
	LdapEscape(pszCommandLineFilter,strEscapedCLFilter);

    strFilter = L"(";
    strFilter += pszAttrName;
    strFilter += L"=";
    strFilter += strEscapedCLFilter;
    strFilter += L")";
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CommonFilterFunc
//
//  Synopsis:   This function takes the input filter from the commandline
//              and converts it into ldapfilter.
//              For ex -user (ab* | bc*) is converted to |(cn=ab*)(cn=bc*)               
//              The pEntry->pszName given the attribute name to use in
//              filter( cn in above example).
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT CommonFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                         IN CDSCmdCredentialObject& /*refCredentialObject*/,
                         IN PVOID ,
                         OUT CComBSTR& strFilter)   
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, CommonFilterFunc, hr);

    //validate input
    if( !pEntry || !pRecord
        //validate DSQUERY_ATTR_TABLE_ENTRY entry
        || !pEntry->pszName || !pEntry->nAttributeID 
        //validate pRecord
        || !pRecord->bDefined || !pRecord->strValue)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    //Make Query
    hr = MakeQuery(pEntry->pszName,
                   pRecord->strValue,
                   strFilter);

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   StarFilterFunc
//
//  Synopsis:   Filter Function for dsquery *. It returns the value of 
//              -filter flag.                
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StarFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                         IN CDSCmdCredentialObject& /*refCredentialObject*/,
                         IN PVOID ,
                         OUT CComBSTR& strFilter)   
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, StarFilterFunc, hr);

    //validate input
    if(!pEntry || !pRecord
        //validate DSQUERY_ATTR_TABLE_ENTRY entry
       || !pEntry->nAttributeID 
       //validate pRecord
       || !pRecord->bDefined || !pRecord->strValue)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    strFilter = pRecord->strValue;
    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InactiveComputerFilterFunc
//
//  Synopsis:   Filter Function for computer inactive query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-05-2002 hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveComputerFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                                   IN ARG_RECORD* pRecord,
                                   IN CDSCmdBasePathsInfo& refBasePathsInfo,
                                   IN CDSCmdCredentialObject& refCredentialObject,
                                   IN PVOID pData,
                                   OUT CComBSTR& strFilter)  
{
    return InactiveFilterFunc(pEntry,
                              pRecord,
                              refBasePathsInfo,
                              refCredentialObject,
                              pData,
                              strFilter,
                              true);  
}
//+--------------------------------------------------------------------------
//
//  Function:   InactiveUserFilterFunc
//
//  Synopsis:   Filter Function for user inactive query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveUserFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                               IN ARG_RECORD* pRecord,
                               IN CDSCmdBasePathsInfo& refBasePathsInfo,
                               IN CDSCmdCredentialObject& refCredentialObject,
                               IN PVOID pData,
                               OUT CComBSTR& strFilter)  
{
    return InactiveFilterFunc(pEntry,
                              pRecord,
                              refBasePathsInfo,
                              refCredentialObject,
                              pData,
                              strFilter,
                              false);  
}

//+--------------------------------------------------------------------------
//
//  Function:   InactiveFilterFunc
//
//  Synopsis:   Filter Function for account inactive query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//              [bComputer]: if true query is for inactive computer accounts
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                           IN CDSCmdCredentialObject& /*refCredentialObject*/,
                           IN PVOID ,
                           OUT CComBSTR& strFilter,
                           IN bool bComputer)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, InactiveFilterFunc, hr);

    if( !pEntry || !pRecord || !pRecord->bDefined )
    {
        hr = E_INVALIDARG;
        return hr;
    }

	 if(pRecord->nValue < 0 )
	 {
		  hr = E_INVALIDARG;
        return hr;
	 }

	//
	//Unit at commandline is Week
	//
    int nDays = pRecord->nValue * 7;

    FILETIME ftCurrent;
    ::GetSystemTimeAsFileTime(&ftCurrent);

    LARGE_INTEGER li;
    li.LowPart = ftCurrent.dwLowDateTime;
    li.HighPart = ftCurrent.dwHighDateTime;

	//
	//Get the number of days since the reference time
	//
	int nDaysSince1600 = (int)(li.QuadPart/(((LONGLONG) (24 * 60) * 60) * 10000000));

	if(nDaysSince1600 < nDays)
	{
		hr = E_INVALIDARG;
		return hr;
	}

	li.QuadPart -= ((((LONGLONG)nDays * 24) * 60) * 60) * 10000000;
	
    CComBSTR strTime;
    litow(li, strTime);
    WCHAR buffer[256];
	//Security Review:Replace with strsafe api
	//NTRAID#NTBUG9-573989-2002/03/12-hiteshr
    if(bComputer)
    {
        //NTRAID#NTBUG9-616892-2002/06/05-hiteshr
        //Cluster creates some virtual computers which never update password or login and
        //these accounts should not be displayed by dsquery computer -[inactive|stalepwd] 
        hr = StringCchPrintf(buffer,256,L"(!(serviceprincipalname=msclustervirtualserver/*))(lastLogonTimestamp<=%s)",(LPCWSTR)strTime);
    }
    else
    {
        hr = StringCchPrintf(buffer,256,L"(lastLogonTimestamp<=%s)",(LPCWSTR)strTime);
    }
	 
    if(SUCCEEDED(hr))
	{
	    strFilter = buffer;
		DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
	}    
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   StalepwdComputerFilterFunc
//
//  Synopsis:   Filter Function for Stale Computer Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdComputerFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                                   IN ARG_RECORD* pRecord,
                                   IN CDSCmdBasePathsInfo& refBasePathsInfo,
                                   IN CDSCmdCredentialObject& refCredentialObject,
                                   IN PVOID pData,
                                   OUT CComBSTR& strFilter)  
{
    return StalepwdFilterFunc(pEntry,
                              pRecord,
                              refBasePathsInfo,
                              refCredentialObject,
                              pData,
                              strFilter,
                              true);
}

//+--------------------------------------------------------------------------
//
//  Function:   StalepwdUserFilterFunc
//
//  Synopsis:   Filter Function for Stale User Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdUserFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                               IN ARG_RECORD* pRecord,
                               IN CDSCmdBasePathsInfo& refBasePathsInfo,
                               IN CDSCmdCredentialObject& refCredentialObject,
                               IN PVOID pData,
                               OUT CComBSTR& strFilter)  
{
    return StalepwdFilterFunc(pEntry,
                              pRecord,
                              refBasePathsInfo,
                              refCredentialObject,
                              pData,
                              strFilter,
                              false);
}

//+--------------------------------------------------------------------------
//
//  Function:   StalepwdFilterFunc
//
//  Synopsis:   Filter Function for Stale Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//              [bComputer]: if true query is for inactive computer accounts
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                           IN CDSCmdCredentialObject& /*refCredentialObject*/,
                           IN PVOID ,
                           OUT CComBSTR& strFilter,
                           bool bComputer)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, StalepwdFilterFunc, hr);

    if( !pEntry || !pRecord || !pRecord->bDefined )
    {
        hr = E_INVALIDARG;
        return hr;
    }

    int nDays = pRecord->nValue;

	if(nDays < 0)
	{
	    hr = E_INVALIDARG;
		return hr;
	}

    FILETIME ftCurrent;
    ::GetSystemTimeAsFileTime(&ftCurrent);

    LARGE_INTEGER li;
    li.LowPart = ftCurrent.dwLowDateTime;
    li.HighPart = ftCurrent.dwHighDateTime;
	//
	//Get the number of days since the reference time
	//
	int nDaysSince1600 = (int)(li.QuadPart/(((LONGLONG) (24 * 60) * 60) * 10000000));

	if(nDaysSince1600 < nDays)
	{
		hr = E_INVALIDARG;
		return hr;
	}


    li.QuadPart -= ((((ULONGLONG)nDays * 24) * 60) * 60) * 10000000;

    CComBSTR strTime;
    litow(li, strTime);
    WCHAR buffer[256];
	//Security Review:Replace with strsafe api
	//NTRAID#NTBUG9-573989-2002/03/12-hiteshr
    if(bComputer)
    {        
        //NTRAID#NTBUG9-616892-2002/06/05-hiteshr
        //Cluster creates some virtual computers which never update password or login and
        //these accounts should not be displayed by dsquery computer -[inactive|stalepwd] 
	    hr = StringCchPrintf(buffer,256,L"(!(serviceprincipalname=msclustervirtualserver/*))(pwdLastSet<=%s)",(LPCWSTR)strTime);
    }
    else
    {
        hr = StringCchPrintf(buffer,256,L"(pwdLastSet<=%s)",(LPCWSTR)strTime);
    }
	if(SUCCEEDED(hr))
	{
	    strFilter = buffer;
		DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
	}    
    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   DisabledFilterFunc
//
//  Synopsis:   Filter Function for account disabled query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT DisabledFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                         IN ARG_RECORD* ,
                         IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                         IN CDSCmdCredentialObject& /*refCredentialObject*/,
                         IN PVOID ,
                         OUT CComBSTR& strFilter)   
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, DisabledFilterFunc, hr);

    WCHAR buffer[256]; //This is long enough
	
	//Security Review:Replace with strsafe api
	//NTRAID#NTBUG9-573989-2002/03/12-hiteshr
	 hr = StringCchPrintf(buffer,256,g_szUserAccountCtrlQuery,UF_ACCOUNTDISABLE);
	 if(SUCCEEDED(hr))
	 {
		 strFilter = buffer;

		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
	 }
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   SubnetSiteFilterFunc
//
//  Synopsis:   Filter Function for -site switch in dsquery subnet. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : suffix for the siteobject attribute.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    24-April-2001   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT SubnetSiteFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                             IN ARG_RECORD* pRecord,
                             IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                             IN CDSCmdCredentialObject& /*refCredentialObject*/,
                             IN PVOID pParam,
                             OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, InactiveFilterFunc, hr);

    if( !pRecord || !pRecord->bDefined || !pParam)
    {
        hr = E_INVALIDARG;
        return hr;
    }

	CComBSTR strEscapedCLFilter;
	LdapEscape(pRecord->strValue,strEscapedCLFilter);
	

	strFilter = L"(siteobject=cn=";
	strFilter += strEscapedCLFilter;
	strFilter += L",";
	strFilter += *(static_cast<BSTR*>(pParam));
	strFilter += L")";
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildQueryFilter
//
//  Synopsis:   This function builds the LDAP query filter for given object type.
//
//  Arguments:  [pCommandArgs - IN] :the command line argument structure used
//                                  to retrieve the values of switches
//              [pObjectEntry - IN] :Contains info about the object type
//				[pParam		   -IN]	:This value is passed to filter function.
//              [strLDAPFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT BuildQueryFilter(PARG_RECORD pCommandArgs, 
                         PDSQueryObjectTableEntry pObjectEntry,
                         CDSCmdBasePathsInfo& refBasePathsInfo,
                         CDSCmdCredentialObject& refCredentialObject,
                         PVOID pParam,
                         CComBSTR& strLDAPFilter)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildQueryFilter, hr);

    if( !pCommandArgs || !pObjectEntry )
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    DSQUERY_ATTR_TABLE_ENTRY** pAttributeTable; 
    DWORD dwAttributeCount;


    pAttributeTable = pObjectEntry->pAttributeTable;
    dwAttributeCount = pObjectEntry->dwAttributeCount;

    if( !pAttributeTable || !dwAttributeCount )
    {
        hr = E_INVALIDARG;
        return hr;
    }

    BOOL bUseDefaultFilter = TRUE;
    CComBSTR strFilter;
    for( UINT i = 0; i < dwAttributeCount; ++i )
    {
        if(pCommandArgs[pAttributeTable[i]->nAttributeID].bDefined)
        {
            bUseDefaultFilter = FALSE;
            CComBSTR strLocalFilter;
            hr = pAttributeTable[i]->pMakeFilterFunc(pAttributeTable[i],
                                                    pCommandArgs + pAttributeTable[i]->nAttributeID,
                                                    refBasePathsInfo,
                                                    refCredentialObject,
                                                    pParam,
                                                    strLocalFilter);
            if(FAILED(hr))
                return hr;
            
            strFilter += strLocalFilter;
            DEBUG_OUTPUT(FULL_LOGGING, L"Current filter = %s", strFilter);
        }   
    }
    //
    //If none of the commandline filter switches are specified, use
    //default filter
    //
    strLDAPFilter = L"(";
    if(bUseDefaultFilter)
    {
        strLDAPFilter += pObjectEntry->pszDefaultFilter;
    }
    else
    {
        if(pObjectEntry->pszPrefixFilter)
        {
            strLDAPFilter += pObjectEntry->pszPrefixFilter;
            strLDAPFilter += strFilter;
        }
        else
             strLDAPFilter += strFilter;
    }
    strLDAPFilter += L")";

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"ldapfilter = %s", strLDAPFilter);
    return hr;
}            

//+--------------------------------------------------------------------------
//
//  Function:   QLimitFilterFunc
//
//  Synopsis:   Filter Function for -qlimit switch in dsquery quota. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : unused.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    13-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT QLimitFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                             IN ARG_RECORD* pRecord,
                             IN CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                             IN CDSCmdCredentialObject& /*refCredentialObject*/,
                             IN PVOID,
                             OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, QLimitFilterFunc, hr);

    if( !pRecord || !pRecord->bDefined)
    {
        hr = E_INVALIDARG;
        return hr;
    }
    // Build the quotaAmount string
    strFilter = L"(msDS-QuotaAmount";
    strFilter += pRecord->strValue;
    strFilter += L")";
    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   AccountFilterFunc
//
//  Synopsis:   Filter Function for -acct switch in dsquery quota. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : Not Used
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    14-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT AccountFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                           IN ARG_RECORD* pRecord,
                           IN CDSCmdBasePathsInfo& refBasePathsInfo,
                           IN CDSCmdCredentialObject& refCredentialObject,
                           IN PVOID ,
                           OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, AccountFilterFunc, hr);

    if( !pRecord || !pRecord->bDefined || !refBasePathsInfo.IsInitialized())
    {
        hr = E_INVALIDARG;
        return hr;
    }

    PWSTR* ppszArray = NULL;    // Array of accts from param or STDIN

    do // false loop
    {
        // Get the accts (trustees)
        UINT nStrings = 0;
        ParseNullSeparatedString(pRecord->strValue,
                                &ppszArray,
                                &nStrings);
        if (nStrings < 1 ||
            !ppszArray)
        {
            ASSERT(false); // This should never happen
            hr = E_OUTOFMEMORY;
            break;
        }
        // Or the return values together
        strFilter = L"(|";
        // Get a trustee query for each acct
        for(UINT i = 0; i < nStrings; i++)
        {
            // Append (msDS-QuotaTrustee=<sid>) for this acct
            // to the filter
            hr = AddSingleAccountFilter(ppszArray[i], refBasePathsInfo, 
                refCredentialObject, strFilter);
            if(FAILED(hr))
            {
                hr = E_UNEXPECTED;
                break;
            }
        }
        // Close the query string
        strFilter += L")";
    } while (false);

    // Free the Acct array
    if(ppszArray)
        LocalFree(ppszArray);

    // If we failed in the loop then clear out the filter string
    if(FAILED(hr))
        strFilter = L"";

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   AddSingleAccountFilter
//
//  Synopsis:   Appends an account string to strFilter for the specified user
//
//  Arguments:  [lpszUser - IN]   : User whose sid string is requested
//              [strFilter - OUT] : Contains the output filter to append to
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    14-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT AddSingleAccountFilter(IN LPCWSTR lpszUser,
                               IN CDSCmdBasePathsInfo& refBasePathsInfo,
                               IN CDSCmdCredentialObject& refCredentialObject,
                               OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, AddSingleAccountFilter, hr);

    if(!lpszUser)
    {
        hr = E_INVALIDARG;
        return hr;
    }

    PSID pSid = NULL;
    LPWSTR pszSid = NULL;
    LPWSTR lpszDN = NULL;

    do // false loop
    {
        // TODO: Need to provide the first param
        hr = ConvertTrusteeToDN(NULL, lpszUser, &lpszDN);
        if(FAILED(hr))
        {
            // 700068 - If the user doesn't exist or has been deleted then 
            // give the user a clue as to what went wrong. 686693 addresses
            // the known issue of multiple error messages being displayed
            // and may not be addressed until a future release - ronmart
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 0, hr, IDS_MSG_INVALID_ACCT_ERROR);
            break;
        }

        // Get the SID
        hr = GetDNSid(lpszDN,
                 refBasePathsInfo,
                 refCredentialObject,
                 &pSid);
        if(FAILED(hr))
        {
            break;
        }

        // Convert the sid to a string
        if(ConvertSidToStringSid(pSid, &pszSid))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"ConvertSidToStringSid = %s", pszSid);
            // APPEND the trustee query with the sid
            strFilter += L"(msDS-QuotaTrustee=";
            strFilter += pszSid;
            strFilter += L")";
        }
        else
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"ConvertSidToStringSid failed!");
            hr = E_FAIL;
            break;
        }

    } while (false);

    if(pSid)
        LocalFree(pSid);

    if(pszSid)
        LocalFree(pszSid);

    if(lpszDN)
        LocalFree(lpszDN);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsquery\querybld.h ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querybld.h
//
//  Contents:  Contains declarations of functions to build query.
//
//  History:   24-Sep-2000    Hiteshr  Created
//             
//
//--------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   CommonFilterFunc
//
//  Synopsis:   This function takes the input filter from the commandline
//              and converts it into ldapfilter.
//              For ex -user (ab* | bc*) is converted to |(cn=ab*)(cn=bc*)               
//              The pEntry->pszName given the attribute name to use in
//              filter( cn in above example).
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT CommonFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN CDSCmdBasePathsInfo& refBasePathsInfo,
                         IN CDSCmdCredentialObject& refCredentialObject,
                         IN PVOID pVoid,
                         OUT CComBSTR& strFilter);
                         
                         
//+--------------------------------------------------------------------------
//
//  Function:   StarFilterFunc
//
//  Synopsis:   Filter Function for dsquery *. It returns the value of 
//              -filter flag.                
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StarFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN CDSCmdBasePathsInfo& refBasePathsInfo,
                         IN CDSCmdCredentialObject& refCredentialObject,
                         IN PVOID pVoid,
                         OUT CComBSTR& strFilter);   
                            


//
//  Function:   DisabledFilterFunc
//
//  Synopsis:   Filter Function for account disabled query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DisabledFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                         IN ARG_RECORD* ,
                         IN CDSCmdBasePathsInfo& refBasePathsInfo,
                         IN CDSCmdCredentialObject& refCredentialObject,
                         IN PVOID ,
                         OUT CComBSTR& strFilter);   

//+--------------------------------------------------------------------------
//
//  Function:   InactiveFilterFunc
//
//  Synopsis:   Filter Function for account inactive query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//              [bComputer]: if true query is for inactive computer accounts
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN CDSCmdBasePathsInfo& refBasePathsInfo,
                           IN CDSCmdCredentialObject& refCredentialObject,
                           IN PVOID ,
                           OUT CComBSTR& strFilter,
                           bool bComputer = false);


//+--------------------------------------------------------------------------
//
//  Function:   StalepwdFilterFunc
//
//  Synopsis:   Filter Function for Stale Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//              [bComputer]: if true query is for inactive computer accounts
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN CDSCmdBasePathsInfo& refBasePathsInfo,
                           IN CDSCmdCredentialObject& refCredentialObject,
                           IN PVOID ,
                           OUT CComBSTR& strFilter,
                           bool bComputer);  


//+--------------------------------------------------------------------------
//
//  Function:   SubnetSiteFilterFunc
//
//  Synopsis:   Filter Function for -site switch in dsquery subnet. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : suffix for the siteobject attribute.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    24-April-2001   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT SubnetSiteFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                             IN ARG_RECORD* pRecord,
                             IN CDSCmdBasePathsInfo& refBasePathsInfo,
                             IN CDSCmdCredentialObject& refCredentialObject,
                             IN PVOID pParam,
                             OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   BuildQueryFilter
//
//  Synopsis:   This function builds the LDAP query filter for given object type.
//
//  Arguments:  [pCommandArgs - IN] :the command line argument structure used
//                                  to retrieve the values of switches
//              [pObjectEntry - IN] :Contains info about the object type
//				[pParam		   -IN]	:This value is passed to filter function.
//              [strLDAPFilter - OUT]   :Contains the output filter.		
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT BuildQueryFilter(PARG_RECORD pCommandArgs, 
                         PDSQueryObjectTableEntry pObjectEntry,
                         CDSCmdBasePathsInfo& refBasePathsInfo,
                         CDSCmdCredentialObject& refCredentialObject,
                         PVOID pParam,
                         CComBSTR& strLDAPFilter);

//+--------------------------------------------------------------------------
//
//  Function:   InactiveComputerFilterFunc
//
//  Synopsis:   Filter Function for computer inactive query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-05-2002 hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveComputerFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                                   IN ARG_RECORD* pRecord,
                                   IN CDSCmdBasePathsInfo& refBasePathsInfo,
                                   IN CDSCmdCredentialObject& refCredentialObject,
                                   IN PVOID pData,
                                   OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   InactiveUserFilterFunc
//
//  Synopsis:   Filter Function for user inactive query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveUserFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                               IN ARG_RECORD* pRecord,
                               IN CDSCmdBasePathsInfo& refBasePathsInfo,
                               IN CDSCmdCredentialObject& refCredentialObject,
                               IN PVOID pData,
                               OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   StalepwdComputerFilterFunc
//
//  Synopsis:   Filter Function for Stale Computer Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdComputerFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                                   IN ARG_RECORD* pRecord,
                                   IN CDSCmdBasePathsInfo& refBasePathsInfo,
                                   IN CDSCmdCredentialObject& refCredentialObject,
                                   IN PVOID pData,
                                   OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   StalepwdUserFilterFunc
//
//  Synopsis:   Filter Function for Stale User Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdUserFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                               IN ARG_RECORD* pRecord,
                               IN CDSCmdBasePathsInfo& refBasePathsInfo,
                               IN CDSCmdCredentialObject& refCredentialObject,
                               IN PVOID pData,
                               OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   QLimitFilterFunc
//
//  Synopsis:   Filter Function for -qlimit switch in dsquery quota. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : suffix for the quota attribute.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    13-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT QLimitFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                             IN ARG_RECORD* pRecord,
                             IN CDSCmdBasePathsInfo& refBasePathsInfo,
                             IN CDSCmdCredentialObject& refCredentialObject,
                             IN PVOID pParam,
                             OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   AccountFilterFunc
//
//  Synopsis:   Filter Function for -acct switch in dsquery quota. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : suffix for the quota attribute.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    14-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT AccountFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN CDSCmdBasePathsInfo& refBasePathsInfo,
                           IN CDSCmdCredentialObject& refCredentialObject,
                           IN PVOID pData,
                           OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   AddSingleAccountFilter
//
//  Synopsis:   Appends an account string to strFilter for the specified user
//
//  Arguments:  [lpszUser - IN]   : User whose sid string is requested
//              [strFilter - OUT] : Contains the output filter to append to
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    14-Aug-2002   ronmart   Created
//
//---------------------------------------------------------------------------
HRESULT AddSingleAccountFilter(IN LPCWSTR lpszValue,
                               IN CDSCmdBasePathsInfo& refBasePathsInfo,
                               IN CDSCmdCredentialObject& refCredentialObject,
                               OUT CComBSTR& strFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsrm\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

#include "commonstrings.h"

extern PCWSTR c_sz_arg1_com_continue;
extern PCWSTR c_sz_arg1_com_noprompt;
extern PCWSTR c_sz_arg1_com_subtree;
extern PCWSTR c_sz_arg1_com_exclude;
extern PCWSTR c_sz_arg1_com_objectDN;
extern PCWSTR g_pszDSCommandName;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsrm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsrm.rc
//

#define IDS_DELETE_PROMPT 101
#define IDS_DELETE_PROMPT_EXCLUDE 102
#define IDS_DELETE_RESPONSE_Y 103
#define IDS_DELETE_RESPONSE_N 104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsrm\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "commonstrings.cpp"

PCWSTR c_sz_arg1_com_noprompt    = L"noprompt";
PCWSTR c_sz_arg1_com_subtree     = L"subtree";
PCWSTR c_sz_arg1_com_exclude     = L"exclude";
PCWSTR g_pszDSCommandName        = L"dsrm";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsrm\rmtable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.cpp
//
//  Contents:  Defines a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "rmtable.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------
ARG_RECORD DSRM_COMMON_COMMANDS[] = 
{
   COMMON_COMMANDS

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   0,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,  
   NULL,    
   0,  NULL,

   //
   // continue
   //
   0, (PWSTR)c_sz_arg1_com_continue,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // noprompt
   //
   0, (PWSTR)c_sz_arg1_com_noprompt,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // subtree
   //
   0, (PWSTR)c_sz_arg1_com_subtree,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // exclude
   //
   0, (PWSTR)c_sz_arg1_com_exclude,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,


   ARG_TERMINATOR
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsrm\rmtable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.h
//
//  Contents:  Declares a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _RMTABLE_H_
#define _RMTABLE_H_

typedef enum DSRM_COMMAND_ENUM
{
   eCommObjectDN = eCommLast+1,   
   eCommContinue,
   eCommNoPrompt,
   eCommSubtree,
   eCommExclude,
   eTerminator
};

//
// The parser table
//
extern ARG_RECORD DSRM_COMMON_COMMANDS[];

#endif //_RMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\parser.h ===
#define IDS_PARSE_ERROR_SWITCH_NOTDEFINED       8001
#define IDS_PARSE_ERROR_SWITCH_VALUE            8002
#define IDS_PARSE_ERROR_UNKNOWN_INPUT_PARAMETER 8003
#define IDS_PARSE_ERROR_MULTIPLE_DEF            8004       
#define IDS_PARSE_ERROR_SWICH_NO_VALUE          8005
#define IDS_PARSE_ERROR_UNICODE_NOTDEFINED      8006
#define IDS_PARSE_ERROR_UNICODE_DEFINED         8007
#define IDS_PARSER_FAILED                       8008
#define IDS_DISPLAY_HELP                        8009
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include "Wincrypt.h"
//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 



#include "parser.h"
#include "strings.h"
#include "util.h"
#include "varg.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\dsrm\dsrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsrm.cpp
//
//  Contents:  Defines the main function and parser tables for the dsrm
//             command line utility
//
//  History:    07-Sep-2000   HiteshR   Created dsmove
//              13-Sep-2000   JonN      Templated dsrm from dsmove
//              26-Sep-2000   JonN      Cleanup in several areas
//             
//--------------------------------------------------------------------------

/*
Error message strategy:

-- If errors occur before any particular directory object
   is contacted, they will be reported as "dsrm failed: <error>".

-- For each target, either one or more errors will be reported,
   or (if "quiet" is not specified) one success will be reported.
   If "continue" is not specified, nothing will be reported on
   targets after the first one to experience an error.

-- More than one error can be reported on a target, but only if
   the "subtree", "exclude" and "continue" flags are all specified.
   In this case, DSRM will continue to delete the other children
   of that specified target object.

-- If a subtree is being deleted and the error actually relates to
   a child object, the error reported will reference the particular
   child object, rather than the specified target object.

-- Failure to delete a system object will be reported as
   ERROR_DS_CANT_DELETE_DSA_OBJ or ERROR_DS_CANT_DELETE.

-- Failure to delete the logged-in user will be reported as
   ERROR_DS_CANT_DELETE.  This test will only be performed on the
   specified target object, not on any of its child objects.
*/

#include "pch.h"
#include "stdio.h"
#include "cstrings.h"
#include "usage.h"
#include "rmtable.h"
#include "resource.h" // IDS_DELETE_PROMPT[_EXCLUDE]
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W
#define SECURITY_WIN32
#include <security.h> // GetUserNameEx

//
// Function Declarations
//
HRESULT ValidateSwitches();
HRESULT DoRm( PWSTR pszDoubleNullObjectDN );
HRESULT DoRmItem( CDSCmdCredentialObject& credentialObject,
                  CDSCmdBasePathsInfo& basePathsInfo,
                  PWSTR pszObjectDN,
                  bool* pfErrorReported );
HRESULT IsCriticalSystemObject( CDSCmdBasePathsInfo& basePathsInfo,
                                IADs* pIADs,
                                const BSTR pszClass,
                                const BSTR pszObjectDN,
                                bool* pfErrorReported );
HRESULT RetrieveStringColumn( IDirectorySearch* pSearch,
                              ADS_SEARCH_HANDLE SearchHandle,
                              LPWSTR szColumnName,
                              CComBSTR& sbstr );
HRESULT SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope);
HRESULT IsThisUserLoggedIn( const BSTR bstrUserDN );
HRESULT DeleteChildren( CDSCmdCredentialObject& credentialObject,
                        IADs* pIADs,
                        bool* pfErrorReported );


//
// Global variables
//
BOOL fSubtree  = false; // BOOL is used in parser structure
BOOL fExclude  = false;
BOOL fContinue = false;
BOOL fQuiet    = false;
BOOL fNoPrompt = false;
LPWSTR g_lpszLoggedInUser = NULL;

//
//Usage Table
//
UINT USAGE_DSRM[] =
{
    USAGE_DSRM_DESCRIPTION,
    USAGE_DSRM_SYNTAX,
    USAGE_DSRM_PARAMETERS,
    USAGE_DSRM_REMARKS,
    USAGE_DSRM_EXAMPLES,
    USAGE_END,
};


//+--------------------------------------------------------------------------
//
//  Function:   _tmain
//
//  Synopsis:   Main function for command-line app
//              beyond what parser can do.
//
//  Returns:    int : HRESULT to be returned from command-line app
//                        
//  History:    07-Sep-2000   HiteshR   Created dsmove
//              13-Sep-2000   JonN      Templated from dsmove
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------
int __cdecl _tmain( VOID )
{

    int argc = 0;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
        goto exit_gracefully;
    }

    DWORD _dwErr = GetCommandInput(&argc,&pToken);
    hr = HRESULT_FROM_WIN32( _dwErr );
    if (FAILED(hr) || argc == 1)
    {
        if (FAILED(hr)) // JonN 3/27/01 344920
            DisplayErrorMessage( g_pszDSCommandName, NULL, hr );
          //if argc is 1, show usage in STDOUT
        DisplayMessage(USAGE_DSRM,(argc == 1));
        goto exit_gracefully;
    }


    PARSE_ERROR Error;
    //Security Review:Correct Bound is passed.
    ::ZeroMemory( &Error, sizeof(Error) );
    if(!ParseCmd(g_pszDSCommandName,    
            DSRM_COMMON_COMMANDS,
             argc-1, 
             pToken+1,
             USAGE_DSRM, 
             &Error,
             TRUE))
    {
        //ParseCmd did not display any error. Error should
        //be handled here. Check DisplayParseError for the
        //cases where Error is not shown by ParseCmd
        if(!Error.MessageShown)
        {
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
                NULL,
                hr);
            
            goto exit_gracefully;
        }
        
        if(Error.ErrorSource == ERROR_FROM_PARSER 
            && Error.Error == PARSE_ERROR_HELP_SWITCH)
        {
            hr = S_OK;
            goto exit_gracefully;
        }
        
        hr = E_INVALIDARG;
        goto exit_gracefully;

    }

    hr = ValidateSwitches();
    if (FAILED(hr))
    {
        DisplayMessage(USAGE_DSRM);
        goto exit_gracefully;
    }

    //
    // Command line parsing succeeded
    //
    hr = DoRm( DSRM_COMMON_COMMANDS[eCommObjectDN].strValue );

exit_gracefully:

    // Free Command Array
    FreeCmd(DSRM_COMMON_COMMANDS);
    // Free Token
    if(pToken)
        delete []pToken;

    if (NULL != g_lpszLoggedInUser)
        delete[] g_lpszLoggedInUser;

    //
    // Uninitialize COM
    //
    CoUninitialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateSwitches
//
//  Synopsis:   Does advanced switch dependency validation
//              beyond what parser can do.
//
//  Arguments:  
//
//  Returns:    S_OK or E_INVALIDARG
//                        
//  History:    07-Sep-2000   HiteshR   Created dsmove
//              13-Sep-2000   JonN      Templated from dsmove
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------

HRESULT ValidateSwitches()
{
   // Check to be sure the server and domain switches
   // are mutually exclusive

   if (DSRM_COMMON_COMMANDS[eCommServer].bDefined &&
       DSRM_COMMON_COMMANDS[eCommDomain].bDefined)
   {
      return E_INVALIDARG;
   }


   // read subtree parameters
    fSubtree  = DSRM_COMMON_COMMANDS[eCommSubtree].bDefined;
    fExclude  = DSRM_COMMON_COMMANDS[eCommExclude].bDefined;
    fContinue = DSRM_COMMON_COMMANDS[eCommContinue].bDefined;
    fQuiet    = DSRM_COMMON_COMMANDS[eCommQuiet].bDefined;
    fNoPrompt = DSRM_COMMON_COMMANDS[eCommNoPrompt].bDefined;

    if (   NULL == DSRM_COMMON_COMMANDS[eCommObjectDN].strValue
        || L'\0' == DSRM_COMMON_COMMANDS[eCommObjectDN].strValue[0]
        || (fExclude && !fSubtree) )
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING, L"ValidateSwitches: Invalid switches");
        return E_INVALIDARG;
    }

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoRm
//
//  Synopsis:   Deletes the appropriate object(s)
//              DoRm reports its own error and success messages
//
//  Arguments:  pszDoubleNullObjectDN: double-null-terminated stringlist
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              Could be almost any ADSI error
//
//  History:    13-Sep-2000   JonN      templated from DoMove
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------
HRESULT DoRm( PWSTR pszDoubleNullObjectDN )
{
    ASSERT(   NULL != pszDoubleNullObjectDN
           && L'\0' != *pszDoubleNullObjectDN );

    //
    // Check to see if we are doing debug spew
    //
#ifdef DBG
    bool bDebugging = DSRM_COMMON_COMMANDS[eCommDebug].bDefined &&
                      DSRM_COMMON_COMMANDS[eCommDebug].nValue;
    if (bDebugging)
    {
       ENABLE_DEBUG_OUTPUT(DSRM_COMMON_COMMANDS[eCommDebug].nValue);
    }
#else
    DISABLE_DEBUG_OUTPUT();
#endif
    ENTER_FUNCTION(MINIMAL_LOGGING, DoRm);

    HRESULT hr = S_OK;

    CDSCmdCredentialObject credentialObject;
    if (DSRM_COMMON_COMMANDS[eCommUserName].bDefined &&
        DSRM_COMMON_COMMANDS[eCommUserName].strValue)
    {
        credentialObject.SetUsername(
            DSRM_COMMON_COMMANDS[eCommUserName].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    if (DSRM_COMMON_COMMANDS[eCommPassword].bDefined &&
        DSRM_COMMON_COMMANDS[eCommPassword].strValue)
    {
        //Security Review:pCommandArgs[eCommPassword].strValue is encrypted.
        //Decrypt pCommandArgs[eCommPassword].strValue  and then pass it to the
        //credentialObject.SetPassword. 
        //See NTRAID#NTBUG9-571544-2000/11/13-hiteshr        
        credentialObject.SetEncryptedPassword(&DSRM_COMMON_COMMANDS[eCommPassword].encryptedDataBlob);
        credentialObject.SetUsingCredentials(true);
    }

    //
    // Initialize the base paths info from the command line args
    // 
    // CODEWORK should I just make this global?
    CDSCmdBasePathsInfo basePathsInfo;
    if (DSRM_COMMON_COMMANDS[eCommServer].bDefined &&
        DSRM_COMMON_COMMANDS[eCommServer].strValue)
    {
        hr = basePathsInfo.InitializeFromName(
                credentialObject, 
                DSRM_COMMON_COMMANDS[eCommServer].strValue,
                true);
    }
    else if (DSRM_COMMON_COMMANDS[eCommDomain].bDefined &&
             DSRM_COMMON_COMMANDS[eCommDomain].strValue)
    {
        hr = basePathsInfo.InitializeFromName(
                credentialObject, 
                DSRM_COMMON_COMMANDS[eCommDomain].strValue);
    }
    else
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, NULL);
    }
    if (FAILED(hr))
    {
        //
        // Display error message and return
        //
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRm: InitializeFromName failure:  0x%08x",
                     hr);
        DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
        return hr;
    }

    // count through double-NULL-terminated string list
    //Security Review:pszDoubleNullObjectDN is series of string separated by '\0'
    //and last string is terminated by two '\0'.This code is fine.
    for ( ;
          L'\0' != *pszDoubleNullObjectDN;
          pszDoubleNullObjectDN += (wcslen(pszDoubleNullObjectDN)+1) )
    {
        bool fErrorReported = false;
        // return the error value for the first error encountered
        HRESULT hrThisItem = DoRmItem( credentialObject,
                                       basePathsInfo,
                                       pszDoubleNullObjectDN,
                                       &fErrorReported );
        if (FAILED(hrThisItem))
        {
            if (!FAILED(hr))
                hr = hrThisItem;
            if (!fErrorReported)
                DisplayErrorMessage(g_pszDSCommandName,
                                    pszDoubleNullObjectDN,
                                    hrThisItem);
            if (fContinue)
                continue;
            else
                break;
        }

        // display success message for each individual deletion
        if (!fQuiet && S_FALSE != hrThisItem)
        {
            DisplaySuccessMessage(g_pszDSCommandName,
                                  pszDoubleNullObjectDN);
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoRmItem
//
//  Synopsis:   Deletes a single target
//
//  Arguments:  credentialObject
//              basePathsInfo
//              pszObjectDN: X500 DN of object to delete
//              *pfErrorReported: Will be set to true if DoRmItem takes
//                                care of reporting the error itself
//
//  Returns:    HRESULT : error code to be returned from command-line app
//                        Could be almost any ADSI error
//                        S_FALSE indicates the operation was cancelled
//
//  History:    13-Sep-2000   JonN      Created
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------

HRESULT DoRmItem( CDSCmdCredentialObject& credentialObject,
                  CDSCmdBasePathsInfo& basePathsInfo,
                  PWSTR pszObjectDN,
                  bool* pfErrorReported )
{
    ASSERT(   NULL != pszObjectDN
           && L'\0' != *pszObjectDN
           && NULL != pfErrorReported );

    ENTER_FUNCTION(LEVEL3_LOGGING, DoRmItem);

    HRESULT hr = S_OK;

    CComBSTR sbstrADsPath;
    basePathsInfo.ComposePathFromDN(pszObjectDN,sbstrADsPath);

    CComPtr<IADs> spIADsItem;
    hr = DSCmdOpenObject(credentialObject,
                         sbstrADsPath,
                         IID_IADs,
                         (void**)&spIADsItem,
                         true);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): DsCmdOpenObject failure: 0x%08x",
                     sbstrADsPath, hr);
        return hr;
    }
    ASSERT( !!spIADsItem );

    // CODEWORK Is this a remote LDAP operation, or does the ADsOpenObject
    // already retrieve the class?  I can bundle the class retrieval into
    // the IsCriticalSystemObject search if necessary.
    CComBSTR sbstrClass;
    hr = spIADsItem->get_Class( &sbstrClass );
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): get_class failure: 0x%08x",
                     sbstrADsPath, hr);
        return hr;
    }
    ASSERT( !!sbstrClass && L'\0' != sbstrClass[0] );

    // Check whether this is a critical system object
    // This method will report its own errors
    hr = IsCriticalSystemObject( basePathsInfo,
                                 spIADsItem,
                                 sbstrClass,
                                 CComBSTR(pszObjectDN),
                                 pfErrorReported );
    if (FAILED(hr))
        return hr;

    if (!fNoPrompt)
    {
        while (true)
        {
            // display prompt
            // CODEWORK allow "a" for all?
            CComBSTR sbstrPrompt;
            if (!sbstrPrompt.LoadString(
                    ::GetModuleHandle(NULL),
                    (fExclude) ? IDS_DELETE_PROMPT_EXCLUDE
                               : IDS_DELETE_PROMPT))
            {
                ASSERT(FALSE);
                sbstrPrompt = (fExclude)
                    ? L"Are you sure you wish to delete %1 (Y/N)? "
                    : L"Are you sure you wish to delete all children of %1 (Y/N)? ";
            }
            // 476225-2002/04/26-JonN escaped output
            CComBSTR sbstrOutputDN;
            hr = GetOutputDN( &sbstrOutputDN, pszObjectDN );
            PWSTR pszOutputDN = (SUCCEEDED(hr)) ? sbstrOutputDN : pszObjectDN;
            PTSTR ptzSysMsg = NULL;
            //Security Review:FormatMessage is called with FORMAT_MESSAGE_ALLOCATE_BUFFER
            //so the buffer is correctly allocated by the API.
            DWORD cch = ::FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_STRING
                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                sbstrPrompt,
                0,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&ptzSysMsg,
                0,
                (va_list*)&pszOutputDN );
            if (0 == cch)
            {
                DWORD _dwErr = GetLastError();       
                DEBUG_OUTPUT(MINIMAL_LOGGING,
                             L"DoRmItem(%s): FormatMessage failure: %d",
                             sbstrADsPath, _dwErr);
                return HRESULT_FROM_WIN32( _dwErr );
            }
            DisplayOutputNoNewline( ptzSysMsg );
            (void) ::LocalFree( ptzSysMsg );

            // read a line of console input
            WCHAR ach[129];
            //Security Review:ZermoMemory takes number of bytes. This is correct.
            ::ZeroMemory( ach, sizeof(ach) );
            DWORD cchRead = 0;
            //Security Review: Bound is fine here. User input is handled correctly.
            if (!ReadConsole(GetStdHandle(STD_INPUT_HANDLE),
                             ach,
                             128,
                             &cchRead,
                             NULL))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_INSUFFICIENT_BUFFER == dwErr)
                    continue;
                DEBUG_OUTPUT(MINIMAL_LOGGING,
                             L"DoRmItem(%s): ReadConsole failure: %d",
                             sbstrADsPath, dwErr);
                return HRESULT_FROM_WIN32(dwErr);
            }
            if (cchRead < 1)
                continue;

            CComBSTR sbstrY;
            if (!sbstrY.LoadString(
                    ::GetModuleHandle(NULL),
                    IDS_DELETE_RESPONSE_Y ))
            {
                sbstrY = L"Y";
            }
            CComBSTR sbstrN;
            if (!sbstrN.LoadString(
                    ::GetModuleHandle(NULL),
                    IDS_DELETE_RESPONSE_N ))
            {
                sbstrN = L"N";
            }

            // return S_FALSE if user types 'n'
            WCHAR wchUpper = (WCHAR)::CharUpper( (LPTSTR)(ach[0]) );
            if (NULL != wcschr(sbstrN,wchUpper))
                return S_FALSE;
            else if (NULL != wcschr(sbstrY,wchUpper))
                break;

            // loop back to prompt
        }
    }

    if (fExclude)
    {
        return DeleteChildren( credentialObject, spIADsItem, pfErrorReported );
    }
    else if (fSubtree)
    {
        // delete the whole subtree
        CComQIPtr<IADsDeleteOps> spDeleteOps( spIADsItem );
        ASSERT( !!spDeleteOps );
        if ( !spDeleteOps )
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"DoRmItem(%s): IADsDeleteOps init failure",
                         sbstrADsPath);
            return E_FAIL;
        }
        hr = spDeleteOps->DeleteObject( NULL );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"DoRmItem(%s): DeleteObject failure: 0x%08x",
                         sbstrADsPath, hr);
        }
        else
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"DoRmItem(%s): DeleteObject succeeds: 0x%08x",
                         sbstrADsPath, hr);
        }
        return hr;
    }

    // Single-object deletion

    // get IADsContainer for parent object
    CComBSTR sbstrParentObjectPath;
    hr = spIADsItem->get_Parent( &sbstrParentObjectPath );
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): get_Parent failure: 0x%08x",
                     sbstrADsPath, hr);
        return hr;
    }
    ASSERT(   !!sbstrParentObjectPath
           && L'\0' != sbstrParentObjectPath[0] );
    CComPtr<IADsContainer> spDsContainer;
    hr = DSCmdOpenObject(credentialObject,
                         sbstrParentObjectPath,
                         IID_IADsContainer,
                         (void**)&spDsContainer,
                         true);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): DSCmdOpenObject failure: 0x%08x",
                     sbstrParentObjectPath, hr);
        return hr;
    }
    ASSERT( !!spDsContainer );

    // get leaf name
    CComBSTR sbstrLeafWithDecoration; // will contain "CN="
    CPathCracker pathCracker;
    hr = pathCracker.Set(CComBSTR(pszObjectDN), ADS_SETTYPE_DN);
    ASSERT(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    hr = pathCracker.GetElement(0, &sbstrLeafWithDecoration);
    ASSERT(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    ASSERT(   !!sbstrLeafWithDecoration
           && L'\0' != sbstrLeafWithDecoration[0] );

    // delete just this object
    hr = spDsContainer->Delete( sbstrClass, sbstrLeafWithDecoration );
    DEBUG_OUTPUT((FAILED(hr)) ? MINIMAL_LOGGING : FULL_LOGGING,
                 L"DoRmItem(%s): Delete(%s, %s) returns 0x%08x",
                 sbstrADsPath, sbstrClass, sbstrLeafWithDecoration, hr);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsCriticalSystemObject
//
//  Synopsis:   Checks whether a single target is a critical system
//              object or whether the subtree contains any such objects.
//              The root object is tested on these criteria (if "exclude"
//              is not specified):
//              (1) is of class user and represents the logged-in user
//              (2) is of class nTDSDSA
//              (3) is of class trustedDomain
//              (3.5) is of class interSiteTransport (212232 JonN 10/27/00)
//              (4) is of class computer and userAccountControl indicates
//                  that this is a DC
//              The entire subtree is tested on these criteria (if "subtree"
//              is specified, excepting the root object if "exclude"
//              is specified):
//              (1) isCriticalSystemObject is true
//              (2) is of class nTDSDSA
//              (3) is of class trustedDomain
//              (3.5) is of class interSiteTransport (212232 JonN 10/27/00)
//              (4) is of class computer and userAccountControl indicates
//                  that this is a DC
//
//  Arguments:  credentialObject
//              basePathsInfo
//              pszObjectDN: X500 DN of object to delete
//              *pfErrorReported: Will be set to true if DoRmItem takes
//                                care of reporting the error itself
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              Could be almost any ADSI error, although likely codes are
//              ERROR_DS_CANT_DELETE
//              ERROR_DS_CANT_DELETE_DSA_OBJ
//              ERROR_DS_CANT_FIND_DSA_OBJ
//
//  History:    13-Sep-2000   JonN      Created
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------
// CODEWORK This could use the pszMessage parameter to ReportErrorMessage
// to provide additional details on why the object is protected.
HRESULT IsCriticalSystemObject( CDSCmdBasePathsInfo& basePathsInfo,
                                IADs* pIADs,
                                const BSTR pszClass,
                                const BSTR pszObjectDN,
                                bool* pfErrorReported )
{
    ASSERT( pIADs && pszClass && pszObjectDN && pfErrorReported );
    if ( !pIADs || !pszClass || !pszObjectDN || !pfErrorReported )
        return E_INVALIDARG;

    ENTER_FUNCTION(LEVEL5_LOGGING, IsCriticalSystemObject);

    HRESULT hr = S_OK;

    // Class-specific checks
    // Let the parent report errors on the root object
    if (fExclude)
    {
        // skip tests on root object, it won't be deleted anyhow
    }
    //Security Review:One of the string is constant in all the 
    //_wcsicmp below. They are all fine.
    else if (!_wcsicmp(L"user",pszClass))
    {
        // CODEWORK we could do this check for the entire subtree
        hr = IsThisUserLoggedIn(pszObjectDN);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsCriticalSystemObject(%s): User is logged in: 0x%08x",
                         pszObjectDN, hr);
            return hr;
        }
    }
    else if (!_wcsicmp(L"nTDSDSA",pszClass))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"IsCriticalSystemObject(%s): Object is an nTDSDSA",
                     pszObjectDN);
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE_DSA_OBJ);
    }
    else if (!_wcsicmp(L"trustedDomain",pszClass))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"IsCriticalSystemObject(%s): Object is a trustedDomain",
                     pszObjectDN);
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);
    }
    else if (!_wcsicmp(L"interSiteTransport",pszClass))
    {
        // 212232 JonN 10/27/00 Protect interSiteTransport objects
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"IsCriticalSystemObject(%s): Object is an interSiteTransport",
                     pszObjectDN);
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);
    }
    else if (!_wcsicmp(L"computer",pszClass)) 
    {
        // Figure out if the account is a DC
        CComVariant Var;
        hr = pIADs->Get(CComBSTR(L"userAccountControl"), &Var);
        if ( SUCCEEDED(hr) && (Var.lVal & ADS_UF_SERVER_TRUST_ACCOUNT))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
      L"IsCriticalSystemObject(%s): Object is a DC computer object",
                         pszObjectDN);
            return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE_DSA_OBJ);
        }
    }

    if (!fSubtree)
        return S_OK;

    // The user passed the "subtree" flag.  Search the entire subtree.
    // Note that the checks are not identical to the single-object
    // checks, they generally conform to what DSADMIN/SITEREPL does.

    CComQIPtr<IDirectorySearch,&IID_IDirectorySearch> spSearch( pIADs );
    ASSERT( !!spSearch );
    if ( !spSearch )
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
            L"IsCriticalSystemObject(%s): Failed to load IDirectorySearch",
                     pszObjectDN);
        return E_FAIL;
    }

    hr = SetSearchPreference(spSearch, ADS_SCOPE_SUBTREE);
    ASSERT( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    CComBSTR sbstrDSAObjectCategory = L"CN=NTDS-DSA,";
    sbstrDSAObjectCategory += basePathsInfo.GetSchemaNamingContext();
    CComBSTR sbstrComputerObjectCategory = L"CN=Computer,";
    sbstrComputerObjectCategory += basePathsInfo.GetSchemaNamingContext();
    CComBSTR sbstrFilter;
    sbstrFilter = L"(|(isCriticalSystemObject=TRUE)(objectCategory=";
    sbstrFilter +=        sbstrDSAObjectCategory;
    sbstrFilter +=  L")(objectCategory=CN=Trusted-Domain,";
    sbstrFilter +=        basePathsInfo.GetSchemaNamingContext();

    // 212232 JonN 10/27/00 Protect interSiteTransport objects
    sbstrFilter +=  L")(objectCategory=CN=Inter-Site-Transport,";
    sbstrFilter +=        basePathsInfo.GetSchemaNamingContext();

    sbstrFilter +=  L")(&(objectCategory=";
    sbstrFilter +=          sbstrComputerObjectCategory;
    sbstrFilter +=     L")(userAccountControl:";
    sbstrFilter +=           LDAP_MATCHING_RULE_BIT_AND_W L":=8192)))";

    LPWSTR pAttrs[2] = { L"aDSPath",
                         L"objectCategory"};

    ADS_SEARCH_HANDLE SearchHandle = NULL;
    hr = spSearch->ExecuteSearch (sbstrFilter,
                                  pAttrs,
                                  2,
                                  &SearchHandle);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
     L"IsCriticalSystemObject(%s): Search with filter %s fails: 0x%08x",
                     pszObjectDN, sbstrFilter, hr);
        return hr;
    }
        DEBUG_OUTPUT(LEVEL6_LOGGING,
     L"IsCriticalSystemObject(%s): Search with filter %s succeeds: 0x%08x",
                     pszObjectDN, sbstrFilter, hr);

    while ( hr = spSearch->GetNextRow( SearchHandle ),
            SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
    {
        CComBSTR sbstrADsPathThisItem;
        hr = RetrieveStringColumn( spSearch,
                                   SearchHandle,
                                   pAttrs[0],
                                   sbstrADsPathThisItem );
        ASSERT( !FAILED(hr) );
        if (FAILED(hr))
            return hr;
        // only compare DNs
        CPathCracker pathcracker;
        hr = pathcracker.Set( sbstrADsPathThisItem, ADS_SETTYPE_FULL );
        ASSERT( !FAILED(hr) ); // 571371-JonN-2002/04/08
        if (FAILED(hr))
            return hr;
        CComBSTR sbstrDN;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );
        ASSERT( !FAILED(hr) ); // 571371-JonN-2002/04/08
        if (FAILED(hr))
            return hr;

        // ignore matches on root object if fExclude, it won't
        // be deleted anyway
        //Security Review:Check for the return value of pathcracker.Retrieve
        //if it fails we may AV. 571371-2000/11/13-hiteshr
        if (fExclude && !!sbstrDN && !_wcsicmp( pszObjectDN, sbstrDN ))
            continue;

        CComBSTR sbstrObjectCategory;
        hr = RetrieveStringColumn( spSearch,
                                   SearchHandle,
                                   pAttrs[1],
                                   sbstrObjectCategory );
        ASSERT( !FAILED(hr) );
        if (FAILED(hr))
            return hr;

        //Security Review:sbstrObjectCategory is coming from ADSI and is fine.
        //sbstrDSAObjectCategory are formed by adding string from ADSI to hardcoded string.
        //This is fine.
        hr = (   !_wcsicmp(sbstrObjectCategory,sbstrDSAObjectCategory)
              || !_wcsicmp(sbstrObjectCategory,sbstrComputerObjectCategory) )
            ? HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE_DSA_OBJ)
            : HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);

        DisplayErrorMessage(g_pszDSCommandName,
                            sbstrDN,
                            hr);
        *pfErrorReported = TRUE;
        return hr; // do not permit deletion
    }

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RetrieveStringColumn
//
//  Synopsis:   Extracts a string value from a SearchHandle
//              beyond what parser can do.
//
//  Arguments:  IDirectorySearch*
//              SearchHandle: must be current on an active record
//              szColumnName: as passed to ExecuteSearch
//              sbstr: returns contents of string value
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              errors should not occur here
//                        
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------
HRESULT RetrieveStringColumn( IDirectorySearch* pSearch,
                              ADS_SEARCH_HANDLE SearchHandle,
                              LPWSTR szColumnName,
                              CComBSTR& sbstr )
{
    ASSERT( pSearch && szColumnName );
    ADS_SEARCH_COLUMN col;
    //Security Review:Correct size in byte is passed.
    ::ZeroMemory( &col, sizeof(col) );
    HRESULT hr = pSearch->GetColumn( SearchHandle, szColumnName, &col );
    ASSERT( !FAILED(hr) );
    if (FAILED(hr))
        return hr;
    ASSERT( col.dwNumValues == 1 );
    if ( col.dwNumValues != 1 )
    {
        (void) pSearch->FreeColumn( &col );
        return E_FAIL;
    }
    switch (col.dwADsType)
    {
    case ADSTYPE_CASE_IGNORE_STRING:
        sbstr = col.pADsValues[0].CaseIgnoreString;
        break;
    case ADSTYPE_DN_STRING:
        sbstr = col.pADsValues[0].DNString;
        break;
    default:
        ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }
    (void) pSearch->FreeColumn( &col );
    return hr;
}


#define QUERY_PAGESIZE 50

//+--------------------------------------------------------------------------
//
//  Function:   SetSearchPreference
//
//  Synopsis:   Sets default search parameters
//
//  Arguments:  IDirectorySearch*
//              ADS_SCOPEENUM: scope of search
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              errors should not occur here
//                        
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------
HRESULT SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope)
{
  if (NULL == piSearch)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  ADS_SEARCHPREF_INFO aSearchPref[4];
  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
  aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
  aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[3].vValue.Integer = scope;

  return piSearch->SetSearchPreference (aSearchPref, 4);
}


//+--------------------------------------------------------------------------
//
//  Function:   IsThisUserLoggedIn
//
//  Synopsis:   Checks whether the object with this DN represents
//              the currently logged-in user
//
//  Arguments:  bstrUserDN: DN of object to check
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              ERROR_DS_CANT_DELETE indicates that this user is logged in
//                        
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------
HRESULT IsThisUserLoggedIn( const BSTR bstrUserDN )
{
    ENTER_FUNCTION(LEVEL7_LOGGING, IsThisUserLoggedIn);

    if (g_lpszLoggedInUser == NULL) {
        // get the size passing null pointer
        DWORD nSize = 0;
        // this is expected to fail
        if (GetUserNameEx(NameFullyQualifiedDN , NULL, &nSize))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"IsThisUserLoggedIn(%s): GetUserNameEx unexpected success",
                         bstrUserDN);
            return E_FAIL;
        }
    
        if( nSize == 0 )
        {
            // JonN 3/16/01 344862
            // dsrm from workgroup computer cannot remotely delete users from domain
            // This probably failed because the local computer is in a workgroup
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsThisUserLoggedIn(%s): GetUserNameEx nSize==0",
                         bstrUserDN);
            return S_OK; // allow user deletion
        }
    
        g_lpszLoggedInUser = new WCHAR[ nSize ];
        if( g_lpszLoggedInUser == NULL )
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsThisUserLoggedIn(%s): out of memory",
                         bstrUserDN);
            return E_OUTOFMEMORY;
        }
        //Security Review:Correct size in byte is passed.
        ::ZeroMemory( g_lpszLoggedInUser, nSize*sizeof(WCHAR) );

        // this is expected to succeed
        if (!GetUserNameEx(NameFullyQualifiedDN, g_lpszLoggedInUser, &nSize ))
        {
            // JonN 3/16/01 344862
            // dsrm from workgroup computer cannot remotely delete users from domain
            // This probably failed because the local computer is in a workgroup
            DWORD dwErr = ::GetLastError();
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsThisUserLoggedIn(%s): GetUserNameEx unexpected failure: %d",
                         bstrUserDN, dwErr);
            return S_OK; // allow user deletion
        }
    }

    //Security Review:GetUserNameEx returns Null terminated user name. 
    if (!_wcsicmp (g_lpszLoggedInUser, bstrUserDN))
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteChildren
//
//  Synopsis:   Deletes only the children of a single target
//
//  Arguments:  credentialObject
//              basePathsInfo
//              pIADs: IADs pointer to the object
//              *pfErrorReported: Will be set to true if DeleteChildren
//                                takes care of reporting the error itself
//
//  Returns:    HRESULT : error code to be returned from command-line app
//                        Could be almost any ADSI error
//                        Returns S_OK if there are no children
//
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------

HRESULT DeleteChildren( CDSCmdCredentialObject& credentialObject,
                        IADs* pIADs,
                        bool* pfErrorReported )
{
    ENTER_FUNCTION(LEVEL5_LOGGING, DeleteChildren);

    ASSERT( pIADs && pfErrorReported );
    if ( !pIADs || !pfErrorReported )
        return E_POINTER;

    CComQIPtr<IDirectorySearch,&IID_IDirectorySearch> spSearch( pIADs );
    ASSERT( !!spSearch );
    if ( !spSearch )
        return E_FAIL;
    HRESULT hr = SetSearchPreference(spSearch, ADS_SCOPE_ONELEVEL);
    ASSERT( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    LPWSTR pAttrs[1] = { L"aDSPath" };
    ADS_SEARCH_HANDLE SearchHandle = NULL;
    hr = spSearch->ExecuteSearch (L"(objectClass=*)",
                                  pAttrs,
                                  1,
                                  &SearchHandle);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DeleteChildren: ExecuteSearch failure: 0x%08x",
                     hr);
        return hr;
    }

    while ( hr = spSearch->GetNextRow( SearchHandle ),
            SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
    {
        CComBSTR sbstrADsPathThisItem;
        hr = RetrieveStringColumn( spSearch,
                                   SearchHandle,
                                   pAttrs[0],
                                   sbstrADsPathThisItem );
        ASSERT( !FAILED(hr) );
        if (FAILED(hr))
            break;

        CComPtr<IADsDeleteOps> spDeleteOps;
        // return the error value for the first error encountered
        HRESULT hrThisItem = DSCmdOpenObject(credentialObject,
                                             sbstrADsPathThisItem,
                                             IID_IADsDeleteOps,
                                             (void**)&spDeleteOps,
                                             true);
        if (FAILED(hrThisItem))
        {
            DEBUG_OUTPUT(
                MINIMAL_LOGGING,
                L"DeleteChildren: DsCmdOpenObject(%s) failure: 0x%08x",
                sbstrADsPathThisItem, hrThisItem);
        }
        else
        {
            ASSERT( !!spDeleteOps );
            hrThisItem = spDeleteOps->DeleteObject( NULL );
            if (FAILED(hrThisItem))
            {
                DEBUG_OUTPUT(
                    MINIMAL_LOGGING,
                    L"DeleteChildren: DeleteObject(%s) failure: 0x%08x",
                    sbstrADsPathThisItem, hrThisItem);
            }
        }
        if (!FAILED(hrThisItem))
            continue;

        // an error occurred

        if (!FAILED(hr))
            hr = hrThisItem;

        CComBSTR sbstrDN;
        CPathCracker pathcracker;
        HRESULT hr2 = pathcracker.Set( sbstrADsPathThisItem, ADS_SETTYPE_FULL );
        ASSERT( !FAILED(hr2) );
        if (FAILED(hr2))
            break;
        hr2 = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );
        ASSERT( !FAILED(hr2) );
        if (FAILED(hr2))
            break;

        // Report error message for the child which could not be deleted
        DisplayErrorMessage(g_pszDSCommandName,
                            sbstrDN,
                            hrThisItem);
        *pfErrorReported = true;

        if (!fContinue)
            break;
    }
    if (hr != S_ADS_NOMORE_ROWS)
    {
        DEBUG_OUTPUT(FULL_LOGGING,
                     L"DeleteChildren: abandoning search");
        (void) spSearch->AbandonSearch( SearchHandle );
    }

    return (hr == S_ADS_NOMORE_ROWS) ? S_OK : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\util.h ===
#ifndef _UTIL_H_8_25_2000
#define _UTIL_H_8_25_2000

#define INIT_SIZE 1024


//General Utility Functions
DWORD ResizeByTwo( LPTSTR *ppBuffer,
                   LONG *pSize );
BOOL StringCopy( LPWSTR *ppDest, LPWSTR pSrc);

LONG ReadFromIn(LPTSTR *ppBuffer);




//+----------------------------------------------------------------------------
//  Function: ConvertStringToInterger  
//  Synopsis: Converts string to integer. Returns false if string is outside
//				  the range on an integer  
//  Arguments:pszInput: integer in string format
//				 :pIntOutput:takes converted integer  
////  Returns:TRUE is successful.
//-----------------------------------------------------------------------------
BOOL ConvertStringToInterger(LPWSTR pszInput, int* pIntOutput);









#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr);

// String formatting functions - *ppszResult must be LocalFree'd
DWORD FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...);
DWORD FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...);
DWORD vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs);
DWORD vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs);

DWORD GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.cpp
//
//  Useful string manipulation functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))

/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, StringByteSize(pString) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

	//Security Review:Buffer is correctly allocated
    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ ---------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen)
{
    if ( !ppResult || cLen == 0 )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (cLen+1) * sizeof(TCHAR));

    return *ppResult ? S_OK:E_OUTOFMEMORY; 

}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.   
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void LocalFreeString(LPTSTR* ppString)
{
    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


//*************************************************************
//
//  SizeofStringResource
//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//
//*************************************************************
UINT
SizeofStringResource(HINSTANCE hInstance,
                     UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}


//*************************************************************
//
//  LoadStringAlloc
//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
int
LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}


//*************************************************************
//
//  String formatting functions
//
//*************************************************************

DWORD
FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, idStr);
    dwResult = vFormatStringID(ppszResult, hInstance, idStr, &args);
    va_end(args);
    return dwResult;
}

DWORD
FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, pszFormat);
    dwResult = vFormatString(ppszResult, pszFormat, &args);
    va_end(args);
    return dwResult;
}

DWORD
vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs)
{
    DWORD dwResult = 0;
    LPTSTR pszFormat = NULL;
    if (LoadStringAlloc(&pszFormat, hInstance, idStr))
    {
        dwResult = vFormatString(ppszResult, pszFormat, pargs);
        LocalFree(pszFormat);
    }
    return dwResult;
}

DWORD
vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs)
{
	//Security Review:FORMAT_MESSAGE_ALLOCATE_BUFFER is used so function
	//will correctly allocate the buffer.
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         pszFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         pargs);
}


//*************************************************************
//
//  GetSystemErrorText
//
//  Purpose:    Retrieve error text for a win32 error value
//
//  Parameters: ppszResult - string resource returned here
//              dwErr - error ID
//
//  Return:     same as FormatMessage
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
DWORD
GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr)
{
	//Security Review:FORMAT_MESSAGE_ALLOCATE_BUFFER is used so function
	//will correctly allocate the buffer.

    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)ppszResult,
                         0,
                         NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\util.cpp ===
#include "pch.h"
#include "limits.h"






//Read From Stdin
//Caller responsible for LocalFree(*ppBuffer)
//Return Value:
//  Number of WCHAR read if successful 
//  -1 in case of Failure. Call GetLastError to get the error.
LONG ReadFromIn(OUT LPWSTR *ppBuffer)
{
    LPWSTR pBuffer = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    pBuffer = (LPWSTR)LocalAlloc(LPTR,INIT_SIZE*sizeof(WCHAR));        
    if(!pBuffer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return -1;
    }

    LONG Pos = 0;
    LONG MaxSize = INIT_SIZE;
    wint_t ch = 0;
    if (g_fUnicodeInput)
    {
		//Security Review: ch is widechar
        while(2 == fread(&ch,1,2,stdin))
        {
            if (0x000D == ch || 0xFEFF == ch) continue;

            if(Pos == MaxSize -1 )
            {
                if(ERROR_SUCCESS != ResizeByTwo(&pBuffer,&MaxSize))
                {
                    LocalFree(pBuffer);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return -1;
                }
            }
            pBuffer[Pos++] = (WCHAR)ch;
        }
    }
    else
    {
        while((ch = getwchar()) != WEOF)
        {
            if(Pos == MaxSize -1 )
            {
                if(ERROR_SUCCESS != ResizeByTwo(&pBuffer,&MaxSize))
                {
                    LocalFree(pBuffer);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return -1;
                }
            }
            pBuffer[Pos++] = (WCHAR)ch;
        }
    }
    pBuffer[Pos] = L'\0';
    *ppBuffer = pBuffer;
    return Pos;
}



//General Utility Functions
DWORD ResizeByTwo( LPTSTR *ppBuffer,
                   LONG *pSize )
{
	if(!ppBuffer || !pSize)
	{
		return ERROR_INVALID_PARAMETER;
	}

    LPWSTR pTempBuffer = (LPWSTR)LocalAlloc(LPTR,(*pSize)*2*sizeof(WCHAR));        
    if(!pTempBuffer)
        return ERROR_NOT_ENOUGH_MEMORY;

	//Security Review:Correct memory is allocated
    memcpy(pTempBuffer,*ppBuffer,*pSize*sizeof(WCHAR));
    LocalFree(*ppBuffer);
    *ppBuffer = pTempBuffer;
    *pSize *=2;
    return ERROR_SUCCESS;
}

BOOL StringCopy( LPWSTR *ppDest, LPWSTR pSrc)
{
	if(!ppDest || !pSrc)
	{
		return FALSE;
	}

    *ppDest = NULL;
    if(!pSrc)
        return TRUE;

	//Security Review:pSrc is null terminated.
    *ppDest = (LPWSTR)LocalAlloc(LPTR, (wcslen(pSrc) + 1)*sizeof(WCHAR));
    if(!*ppDest)
        return FALSE;
	//Security Review:Buffer is correctly allocated
    wcscpy(*ppDest,pSrc);
    return TRUE;
}

//+----------------------------------------------------------------------------
//  Function: ConvertStringToInterger  
//  Synopsis: Converts string to integer. Returns false if string is outside
//				  the range on an integer  
//  Arguments:pszInput: integer in string format
//				 :pIntOutput:takes converted integer  
////  Returns:TRUE is successful.
//-----------------------------------------------------------------------------
BOOL ConvertStringToInterger(LPWSTR pszInput, int* pIntOutput)
{
	if(!pIntOutput || !pszInput)
		return FALSE;
	
	//Get the Max len of integer
	int iMaxInt = INT_MAX;
	WCHAR szMaxIntBuffer[34];
	//Security Review:34 is maximum buffer required
	_itow(iMaxInt,szMaxIntBuffer,10);
	//Security Review:_itow returns a null terminated string
	UINT nMaxLen = wcslen(szMaxIntBuffer);
	
	LPWSTR pszTempInput = pszInput;
	if(pszInput[0] == L'-')
	{
		pszTempInput++;
	}

	//Security review:pszTempInput is null terminated
	UINT nInputLen = wcslen(pszTempInput);
	if(nInputLen > nMaxLen)
		return FALSE;

	//
	//Convert input to long
	//
	LONG lInput = _wtol(pszTempInput);

    //
    //RAID: 700067 - ronmart
    //If lInput zero, then make sure the value
    //is really zero and not an error from _wtol
    //
    if(lInput == 0)
    {
        //
        //Walk the string
        //
        for(UINT i = 0; i < nInputLen; i++)
        {
            //
            // If non-numeric value encountered
            //
            if(pszTempInput[i] < L'0' || pszTempInput[i] > L'9')
            {
                //
                // And the value isn't a space, then a char string has
                // been passed so fail
                //
                if(pszTempInput[i] != L' ')
                    return FALSE;
            }
        }
    }

    //
    //Check its less that max integer
    //
	if(lInput > (LONG)iMaxInt)
		return FALSE;

	//
	//Value is good
	//
	*pIntOutput = _wtoi(pszInput);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\varg.cpp ===
/*****************************************************************************\

    Author: Hiteshr
    Copyright (c) 1998-2000 Microsoft Corporation
    Change History:
    Adapted From Parser Implemenation of Corey Morgan
\*****************************************************************************/

#include "pch.h"
#include "..\dsutil2.h" // GetEscapedElement
#include "..\parserutil.h" // eCommUnicodeAll
#include <io.h> // _setmode()
#include <fcntl.h> // _O_BINARY
#include <locale.h> // setlocale 569040-2002/04/10-JonN initialize locale




BOOL ValidateCommands(IN LPCTSTR pszCommandName,
                      IN ARG_RECORD *Commands,
                      OUT PPARSE_ERROR pError);
// void DisplayDebugInfo(IN ARG_RECORD *Commands);

// JonN 4/26/01 256583
BOOL AddDNEscaping_Commands( IN OUT ARG_RECORD *Commands, OUT PPARSE_ERROR pError );
DWORD AddDNEscaping_DN( OUT LPWSTR* ppszOut, IN LPWSTR pszIn );
BOOL StartBuffer( OUT LPTSTR* pbuffer,
                  OUT LONG* pmaxSize,
                  OUT LONG* pcurrentSize );
DWORD AddToBuffer( IN LPCTSTR psz,
                   IN OUT LPTSTR* pbuffer,
                   IN OUT LONG* pmaxSize,
                   IN OUT LONG* pcurrentSize,
                   IN BOOL fMSZBuffer);

#define FILL_ERROR(pError,source,error_code,rec_index,argv_index) \
pError->ErrorSource = source;         \
pError->Error = error_code;           \
pError->ArgRecIndex = rec_index;      \
pError->ArgvIndex = argv_index;


// Copied from JSchwart
DWORD FileType( HANDLE fp )
{
    DWORD htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype;
}


// NOTE: this is only implemented to return the correct thing
//       for ARG_TYPE_BOOL, ARG_TYPE_STR, and ARG_TYPE_MSZ
//       All other types will return FALSE

BOOL HasValue( PARG_RECORD arg)
{
   if (!arg)
   {
      return FALSE;
   }

   BOOL hasValue = FALSE;
   switch (arg->fType)
   {
      case ARG_TYPE_BOOL:
         hasValue = arg->bDefined;
         break;

      case ARG_TYPE_STR:
      case ARG_TYPE_MSZ:
         if (arg->strValue && arg->strValue[0])
         {
            hasValue = TRUE;
         }
         break;

      case ARG_TYPE_INTSTR:
      case ARG_TYPE_INT:
      case ARG_TYPE_HELP:
      case ARG_TYPE_DEBUG:
      case ARG_TYPE_LAST:
      default:
         hasValue = FALSE;
         break;
   }

   return hasValue;
}

BOOL IsCmd( PARG_RECORD arg, LPTOKEN pToken)
{
    if(!arg || !pToken)
        return FALSE;    
    
    LPWSTR str = pToken->GetToken();

    if(!str)
        return FALSE;

    if(pToken->IsSwitch())
    {
        str++;
    }else
    {
        if( (arg->fFlag & ARG_FLAG_NOFLAG) && !arg->bDefined )
        {
            return TRUE;
        }
        if ((arg->fFlag & ARG_FLAG_STDIN) &&
            !HasValue(arg))
        {
            return TRUE;
        }

        if( !(arg->fFlag & ARG_FLAG_VERB) )
        {
            return FALSE;
        }
    }
    
    if( ( arg->strArg1 && !_tcsicmp( str, arg->strArg1 ) )
       ||(arg->strArg2 && !_tcsicmp( str, arg->strArg2 )) )
    {
        return TRUE;
    }
    return FALSE;
}



void FreeCmd(ARG_RECORD *Commands)
{
    int i;
    for(i=0;Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if((Commands[i].fType == ARG_TYPE_STR || 
            Commands[i].fType == ARG_TYPE_MSZ ) && 
            Commands[i].bDefined )
        {                       
            LocalFree( Commands[i].strValue );
            Commands[i].strValue = NULL;
        }
        if((Commands[i].fType == ARG_TYPE_PASSWORD) && 
            Commands[i].bDefined &&
            Commands[i].encryptedDataBlob.pbData)
        {                       
            LocalFree( Commands[i].encryptedDataBlob.pbData );
            Commands[i].encryptedDataBlob.pbData = NULL;
        }

        if( Commands[i].idArg1 && Commands[i].strArg1 != NULL )
        {
            LocalFree(Commands[i].strArg1);
        }
        if( Commands[i].idArg2 && Commands[i].strArg2 != NULL )
        {
            LocalFree( Commands[i].strArg2  );
        }
        Commands[i].bDefined = FALSE;
    }
}

BOOL LoadCmd(ARG_RECORD *Commands)
{
    int i;
    BOOL bRet = TRUE;
    for( i=0; Commands[i].fType!=ARG_TYPE_LAST; i++ )
    {
        if(Commands[i].idArg1 !=0)
            if(!LoadStringAlloc(&Commands[i].strArg1, NULL,Commands[i].idArg1))
            {
                bRet = FALSE;
                break;   
            }                
        if(Commands[i].idArg2 !=0 && Commands[i].idArg2 != ID_ARG2_NULL)
            if(!LoadStringAlloc(&Commands[i].strArg2, NULL,Commands[i].idArg2))
            {
                bRet = FALSE;
                break;
            }
    }   
    return bRet;
}
           
BOOL
ValidateCommands(LPCTSTR pszCommandName,
                 ARG_RECORD *Commands, 
                 PPARSE_ERROR pError)
{
    int i = 0;
    LONG cReadFromStdin = 0;
     int iFirstReadFromStdin = -1;
    ARG_RECORD *CommandsIn = NULL;
    LPWSTR pBuffer=NULL;    
    LONG BufferLen = 0;
    LPTOKEN pToken = NULL;   
    int argc=0;
    BOOL bRet = FALSE;

    bool bAtLeastOne = false;
    bool bAtLeastOneDefined = false;

    if(!Commands || !pError || !pszCommandName)
        goto exit_gracefully;
    
    for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined &&
            !(Commands[i].fFlag & ARG_FLAG_STDIN))
        {
            FILL_ERROR(pError,
                       ERROR_FROM_PARSER,
                       PARSE_ERROR_SWITCH_NOTDEFINED,
                       i,
                       -1);
            goto exit_gracefully;
        }

        // Mark for reading from STDIN if the following conditions apply
        // 1. Command is marked to be read from STDIN and it is not defined
        //    and it is marked as NOFLAG (no switch)
        // or
        // 2. Command is marked to be read from STDIN and it is defined and
        //    if is not marked as NOFLAG and there is no value specified

        if (Commands[i].fFlag & ARG_FLAG_STDIN && 
            (!Commands[i].bDefined && (Commands[i].fFlag & ARG_FLAG_NOFLAG) ||
            (Commands[i].bDefined && !(Commands[i].fFlag & ARG_FLAG_NOFLAG) && 
             !HasValue(&Commands[i]))))
        {
            cReadFromStdin++;
            if (-1 == iFirstReadFromStdin)
                iFirstReadFromStdin = i;
        }

        if (Commands[i].fFlag & ARG_FLAG_ATLEASTONE)
        {
            bAtLeastOne = true;
 
            if (Commands[i].bDefined)
            {
                bAtLeastOneDefined = true;
            }
        }
    }
    
    if (bAtLeastOne && !bAtLeastOneDefined)
    {
       pError->ErrorSource = ERROR_FROM_PARSER;
       pError->Error = PARSE_ERROR_ATLEASTONE_NOTDEFINED;
       pError->ArgRecIndex = -1;
       pError->ArgvIndex = -1;
       goto exit_gracefully;
    }

    if(!cReadFromStdin)
    {   
        bRet = TRUE;
        goto exit_gracefully;
    }
    
    //Read From STDIN
    BufferLen = ReadFromIn(&pBuffer);
    if(BufferLen == -1)
    {
        FILL_ERROR(pError,
                   ERROR_WIN32_ERROR,
                   GetLastError(),
                   -1,
                   -1);
        goto exit_gracefully;
    }
    
    if(BufferLen == 0)
    {
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }
    }
    
    if(BufferLen)
    {
        //
        // JonN 9/4/01 460583
        // Check for Unicode input with non-Unicode command, or vice-versa
        //
        if (BufferLen < 4)
        {
            // not able to determine Unicode-ness with such short input
        }
        else if (g_fUnicodeInput)
        {
            // If all the characters in the input have nonzero hiwords,
            // this is almost certainly ANSI.
            bool bFoundShortChar = false;
            for (int ich = 0; ich < BufferLen; ich++)
            {
                if (pBuffer[ich] <= 0xff)
                {
                    bFoundShortChar = true;
                    break;
                }
            }
            if (!bFoundShortChar)
//            if ( !IsTextUnicode( pBuffer, BufferLen, NULL ) )
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_UNICODE_DEFINED,
                           iFirstReadFromStdin,
                           -1);
                goto exit_gracefully;
            }
        }
        else
        {
            // If the signature is char 0000 char 0000, this looks like Unicode.
            // getwchar() has the behavior of padding 00xx to 000000xx.
            if (   BufferLen >= 4
                && pBuffer[0]
                && !pBuffer[1]
                && pBuffer[2]
                && !pBuffer[3] )
//            if ( IsTextUnicode( pBuffer, BufferLen, NULL ) ) false positives
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_UNICODE_NOTDEFINED,
                           iFirstReadFromStdin,
                           -1);
                goto exit_gracefully;
            }
        }

        //Tokenize what you have read from STDIN
        DWORD dwErr;
        WCHAR szDelimiters[] = L" \n\t";
        dwErr = Tokenize(pBuffer,
                         BufferLen,
                         szDelimiters,
                         &pToken,
                         &argc);
        if( dwErr != ERROR_SUCCESS )
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       dwErr,
                       -1,
                       -1);
            goto exit_gracefully;
        }

        //Prepare a CommandArray for them
        CommandsIn = (ARG_RECORD*)LocalAlloc(LPTR,sizeof(ARG_RECORD)*(cReadFromStdin+1));
        if(!CommandsIn)
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       ERROR_NOT_ENOUGH_MEMORY,
                       -1,
                       -1);
            goto exit_gracefully;
        }
        int j;
        j = 0;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if (Commands[i].fFlag & ARG_FLAG_STDIN && 
                (!Commands[i].bDefined && (Commands[i].fFlag & ARG_FLAG_NOFLAG) ||
                (Commands[i].bDefined && !(Commands[i].fFlag & ARG_FLAG_NOFLAG) && 
                 !HasValue(&Commands[i]))))
            {
                CommandsIn[j++] = Commands[i];        
            }
        }
        //Copy the Last One
        CommandsIn[j] = Commands[i];


        if(!ParseCmd(pszCommandName,
                    CommandsIn,
                    argc,
                    pToken,
                    0,
                    pError,
                    FALSE))
        {
            // 603157-2002/04/32-JonN
            // The commands read from STDIN are invalid.  We must not pass through
            // pError from the recursed call to ParseCmd since the token list
            // to which it refers will be deleted before the parsing error
            // is displayed.
            FILL_ERROR(pError,
                       ERROR_FROM_PARSER,
                       PARSE_ERROR_ALREADY_DISPLAYED,
                       i,
                       -1);

            goto exit_gracefully;
        }
       
        //Copy the values back to Commands
        j=0;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if(Commands[i].fFlag & ARG_FLAG_STDIN && 
                (!Commands[i].bDefined && (Commands[i].fFlag & ARG_FLAG_NOFLAG) ||
                (Commands[i].bDefined && !(Commands[i].fFlag & ARG_FLAG_NOFLAG) && 
                 !HasValue(&Commands[i]))))
            {
                Commands[i] = CommandsIn[j++];        
            }
        }
        
        //Validate Commands
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }

    }   
    bRet = TRUE;
exit_gracefully:
    if(CommandsIn)
        LocalFree(CommandsIn);
    if(pBuffer)
        LocalFree(pBuffer);
    if(pToken)
    {
       delete []pToken;
    }
    return bRet;
}


BOOL g_fUnicodeInput = FALSE;
BOOL g_fUnicodeOutput = FALSE;


BOOL ParseCmd(IN LPCTSTR pszCommandName,
              IN ARG_RECORD *Commands,
              IN int argc, 
              IN LPTOKEN pToken,
              IN UINT* pUsageMessageTable, 
              OUT PPARSE_ERROR pError,
              IN BOOL bValidate )
{
    int i;
    BOOL bFound;
    BOOL bDoDebug = FALSE;
    int argCount;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bReturn = TRUE;
    LPTOKEN pTokenCopy = pToken;

    if(!pError)
    {
        return FALSE;        
    }

    pError->MessageShown = FALSE;

    if(!Commands || argc == 0 || !pToken )
    {
        bReturn = FALSE;
        FILL_ERROR(pError,
                   ERROR_WIN32_ERROR,
                   E_INVALIDARG,
                   -1,
                   -1);
        goto exit_gracefully;
    }

    if(!LoadCmd(Commands))
    {
        bReturn = FALSE;
        FILL_ERROR(pError,
                   ERROR_WIN32_ERROR,
                   E_INVALIDARG,
                   -1,
                   -1);

        goto exit_gracefully;
    }

    argCount = argc;

    while( argc > 0 )
    {
        
        bFound = FALSE;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST && (!bFound);i++)
        {
            
            if( IsCmd( &Commands[i], pToken) )
            {

                if(Commands[i].bDefined &&
                   (!(Commands[i].fFlag & ARG_FLAG_STDIN) && HasValue(&Commands[i])))
                {
                    FILL_ERROR(pError,
                               ERROR_FROM_PARSER,
                               PARSE_ERROR_MULTIPLE_DEF,
                               i,
                               -1);
                    bReturn = FALSE;
                    goto exit_gracefully;
                }

                if( pToken->IsSwitch() || Commands[i].fFlag & ARG_FLAG_VERB ){
                    pToken++;argc--;
                }

                bFound = TRUE;

                Commands[i].bDefined = TRUE;

                switch( Commands[i].fType ){
                case ARG_TYPE_HELP:
                {
                    Commands[i].bValue = TRUE;
                    if( Commands[i].fntValidation != NULL )
                    {
                        Commands[i].fntValidation( Commands + i );
                    }
                    FILL_ERROR(pError,
                               ERROR_FROM_PARSER,
                               PARSE_ERROR_HELP_SWITCH,
                               i,
                               -1);
                    if(pUsageMessageTable)
                        DisplayMessage(pUsageMessageTable,TRUE);

                    bReturn = FALSE;
                    goto exit_gracefully;
                }
                break;
                case ARG_TYPE_DEBUG:
                   //
                   // REVIEW_JEFFJON : removed for now because it was AVing for dsadd group -secgrp
                   //
//                    bDoDebug = TRUE;
                    Commands[i].fFlag |= ARG_FLAG_DEFAULTABLE;
                case ARG_TYPE_INT:
                {
                    if( argc > 0 && !pToken->IsSlash())
                    {
                        PWSTR pszToken = pToken->GetToken();
                        if(!ConvertStringToInterger(pszToken,&Commands[i].nValue))
                        {
                           FILL_ERROR(pError,
                                      ERROR_FROM_PARSER,
                                      PARSE_ERROR_SWITCH_VALUE,
                                      i,
                                      argCount - argc);
                            bReturn = FALSE;
                            goto exit_gracefully;
                        }
                        pToken++;argc--;
                    }
                    else if( !(Commands[i].fFlag & ARG_FLAG_DEFAULTABLE) )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   argCount - argc);
                        bReturn = FALSE;
                        goto exit_gracefully;
                    }
                }
                break;
                case ARG_TYPE_BOOL:
                    Commands[i].bValue = TRUE;
                    break;
                case ARG_TYPE_MSZ:
                    if( argc > 0 && !pToken->IsSwitch())
                    {
                        LPTSTR buffer = NULL;
                        LONG maxSize = 0;
                        LONG currentSize = 0;
                        if (!StartBuffer(&buffer,&maxSize,&currentSize))
                        {
                            FILL_ERROR(pError,
                                       ERROR_WIN32_ERROR,
                                       ERROR_NOT_ENOUGH_MEMORY,
                                       -1,
                                       argCount - argc);
                            bReturn = FALSE;
                            goto exit_gracefully;
                        }
                        LPCTSTR pszTemp = pToken->GetToken();
                        dwErr = AddToBuffer(pszTemp,&buffer,&maxSize,&currentSize,TRUE);
                        if (NO_ERROR != dwErr)
                        {
                            FILL_ERROR(pError,
                                       ERROR_WIN32_ERROR,
                                       dwErr,
                                       i,
                                       -1);
                            bReturn = FALSE;
                            goto exit_gracefully;
                        }
                        pToken++;argc--;
                        while( argc > 0 && !pToken->IsSwitch() )
                        {
                            pszTemp = pToken->GetToken();
                            dwErr = AddToBuffer(pszTemp,&buffer,&maxSize,&currentSize,TRUE);
                            if (NO_ERROR != dwErr)
                            {
                                FILL_ERROR(pError,
                                           ERROR_WIN32_ERROR,
                                           dwErr,
                                           i,
                                           -1);
                                bReturn = FALSE;
                                goto exit_gracefully;
                            }
                           pToken++;argc--;
                        }
                        Commands[i].strValue = buffer;
                    }
                    else if( Commands[i].fFlag & ARG_FLAG_DEFAULTABLE )
                    {
                        //Here we are allocating the string using localAlloc so that
                        //free cmd can simply call LocalFree on all Commands.strValue
                        LPTSTR strValue = Commands[i].strValue;
                        Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(strValue)+1) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL )
                        {
                            //Buffer is correctly allocated.
                            _tcscpy( Commands[i].strValue, strValue );
                        }
                    }
                    else if ( Commands[i].fFlag & ARG_FLAG_STDIN )
                    {
                       // Do nothing here. The data should be retrieved from STDIN
                    }
                    else
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   -1);
                        bReturn = FALSE;
                        goto exit_gracefully;
                    }
                    break;
                case ARG_TYPE_STR:
                case ARG_TYPE_PASSWORD: //Password is input from commandline as string
                    if( argc > 0 && !pToken->IsSwitch())
                    {
                        Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(pToken->GetToken())+2) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL )
                        {
                            //Buffer is properly allocated.
                            _tcscpy( Commands[i].strValue, pToken->GetToken() );
                        }
                        pToken++;argc--;
                    }else if( Commands[i].fFlag & ARG_FLAG_DEFAULTABLE )
                    {
                        //Here we are allocating the string using localAlloc so that
                        //free cmd can simply call LocalFree on all Commands.strValue
                        LPTSTR strValue = Commands[i].strValue;
                        Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(strValue)+2) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL )
                        {
                            //Buffer is properly allocated. Actually one byte extra.
                            _tcscpy( Commands[i].strValue, strValue );
                        }
                    }else
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   -1);
                        bReturn = FALSE;
                        goto exit_gracefully;
                    }
                    break;

                case ARG_TYPE_INTSTR:
                    //
                    // We use IsSlash here instead of IsSwitch because we want to allow
                    // negative numbers
                    //
                    if( argc > 0 && !pToken->IsSlash())
                    {
                        PWSTR pszToken = pToken->GetToken();
                        //Its fine.
                        size_t strLen = wcslen(pszToken);
                        
                        Commands[i].nValue = _ttoi( pszToken);
                        Commands[i].fType = ARG_TYPE_INT;
                        if (Commands[i].nValue == 0 &&
                            !iswdigit(pszToken[0]))
                        {
                           //
                           // Then treat as a string
                           //
                           Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(pToken->GetToken())+2) * sizeof(TCHAR) );
                           if( Commands[i].strValue != NULL )
                           {
                               //proper buffer is allocated.
                              _tcscpy( Commands[i].strValue, pToken->GetToken() );
                              Commands[i].fType = ARG_TYPE_STR;
                           }
                        }
                        pToken++;argc--;
                    }
                    else if( !(Commands[i].fFlag & ARG_FLAG_DEFAULTABLE) )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   argCount - argc);
                        bReturn = FALSE;
                        goto exit_gracefully;
                    }
                    break;
                }

                if( Commands[i].bDefined && Commands[i].fntValidation != NULL )
                {
                    dwErr = Commands[i].fntValidation(Commands + i);
                    if( dwErr != ERROR_SUCCESS )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_VLDFN,
                                   dwErr,
                                   i,
                                   -1);
                        bReturn = FALSE;
                        goto exit_gracefully;
                    }
                }

            }
        }

        if (!bFound)
        {
            pError->ErrorSource = ERROR_FROM_PARSER;
            pError->Error = PARSE_ERROR_UNKNOWN_INPUT_PARAMETER;
            pError->ArgRecIndex = -1;
            pError->ArgvIndex = argCount - argc;
            bReturn = FALSE;
            goto exit_gracefully;
        }
    }

    if( bDoDebug )
    {
//        DisplayDebugInfo(Commands);
    }


    if(bValidate)
    {
        //This should be done only in first parse when bValidate is set to true.
        //ValidateCommands recursively calls ParseCmd with different ARG_RECORD 
        //array and that does not have eCommUnicodeInput etc switches.
        g_fUnicodeInput  = Commands[eCommUnicodeInput].bDefined
                    || (   Commands[eCommUnicodeAll].bDefined
                        && (FILE_TYPE_PIPE == FileType(GetStdHandle(STD_INPUT_HANDLE))) );
        g_fUnicodeOutput = Commands[eCommUnicodeOutput].bDefined
                    || (   Commands[eCommUnicodeAll].bDefined
                        && (FILE_TYPE_PIPE == FileType(GetStdHandle(STD_OUTPUT_HANDLE))) );
        if (g_fUnicodeInput)
        {
            int dummy = _setmode( _fileno(stdin), _O_BINARY );
        }
        if (g_fUnicodeOutput)
        {
            WriteStandardOut( L"\xFEFF" );
        }
    }
    if(bValidate && !ValidateCommands(pszCommandName,Commands,pError))
    {
        bReturn = FALSE;
        goto exit_gracefully;
    }

    // JonN 4/26/01 256583
    // Note that this must be called after ValidateCommands, which completes
    // reading parameters from STDIN.  If !bValidate, then we are in the
    // middle of a call to ValidateCommands.
    if (bValidate)
    {
        bReturn = AddDNEscaping_Commands(Commands,pError);
    }

exit_gracefully:
    if(!bReturn)
        DisplayParseError(pszCommandName,pError, Commands, pTokenCopy);

    return bReturn;
}

/*
void
DisplayDebugInfo(ARG_RECORD *Commands)
{
    int i;
    int nOut;

    for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if( Commands[i].fType == ARG_TYPE_HELP ){
            continue;
        }
        nOut = _tprintf( _T("%s"), Commands[i].strArg1 );
        while( ++nOut < 10 )
        {
            _tprintf( _T(" ") );
        }
        _tprintf( _T("= ") );
        switch( Commands[i].fType )
        {
        case ARG_TYPE_DEBUG:
        case ARG_TYPE_INT:
            _tprintf( _T("%d"),
                Commands[i].nValue 
                );
            break;
        case ARG_TYPE_BOOL:
            _tprintf( _T("%s"),
                Commands[i].bValue ? _T("TRUE") : _T("FALSE")
                );
            break;
        case ARG_TYPE_MSZ:
            if( NULL != Commands[i].strValue && _tcslen( Commands[i].strValue ) )
            {
                _tprintf( _T("%s ..."), Commands[i].strValue);
            }else
            {
                _tprintf( _T("%s"),_T("-") );
            }
            break;
        case ARG_TYPE_STR:
            _tprintf( _T("%s"),
                (Commands[i].strValue == NULL || !(_tcslen(Commands[i].strValue)) ) ? 
                _T("-") : Commands[i].strValue
                );
            break;
        }
        _tprintf( _T("\n") );
       
    }
    _tprintf( _T("\n") );
}
*/


//This Function reads from the Command Line, 
//return it in tokenized format.
DWORD GetCommandInput( OUT int *pargc,           //Number of Tokens
                       OUT LPTOKEN *ppToken)    //Array of CToken
{
    // 569040-2002/04/10-JonN initialize locale
    {
        UINT cp = GetConsoleCP();
        CHAR ach[256] = {0};
        HRESULT hr = StringCchPrintfA(ach, 256, ".%d", cp);
        assert( SUCCEEDED(hr) );
        char* pszOldLocale;
#if 0
        pszOldLocale = setlocale(LC_ALL, NULL);
        _tprintf( _T("old locale was    \"%hs\"\n"), pszOldLocale );
        _tprintf( _T("setting locale to \"%hs\"\n"), ach );
#endif
        pszOldLocale = setlocale(LC_ALL, ach);
        assert( NULL != pszOldLocale );
#if 0
        _tprintf( _T("new locale is     \"%hs\"\n"), pszOldLocale );
#endif
    }

    LPWSTR pBuffer = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szDelimiters[] = L" \n\t";
    
    *pargc = 0;
    //Read the commandline input
    pBuffer = GetCommandLine();
    if(pBuffer)
        dwErr = Tokenize(pBuffer, 
                         wcslen(pBuffer),
                         szDelimiters,
                         ppToken,
                         pargc);

    return dwErr;
}

BOOL IsDelimiter(WCHAR ch, LPWSTR pszDelimiters)
{
    while(*pszDelimiters)
        if((WCHAR)*pszDelimiters++ == ch)
            return TRUE;

    return FALSE;
}

/*
This Function Tokenize the input buffer. It needs to be called in two step.
First time you call it, provide pBuf and Buflen. First Call will return 
the first token. To get next token, call the function with NULL for pBuf and
0 for Buflen.
Output: pbQuote is true if this token was enclosed in a quote.
        ppToken: Token string. Call LocalFree to free it.
Return Value:Length of Token if token found.
             0 if no token found.
             -1 in case of error. Call GetLastError to get the error.
*/
LONG GetToken(IN LPWSTR pBuf,
              IN LONG BufLen,
              IN LPWSTR pszDelimiters,
              OUT BOOL *pbQuote,
              OUT LPWSTR *ppToken)
{
    static LPWSTR pBuffer;
    static LONG BufferLen;

    DWORD dwErr = ERROR_SUCCESS;
    if(pbQuote)
        *pbQuote = FALSE;

    if(ppToken)
        *ppToken = NULL;

    LONG MaxSize = INIT_SIZE;
    LONG pos = 0;
 

    if(pBuf)
        pBuffer = pBuf;

    if(BufLen)
        BufferLen = BufLen;

    if(!BufferLen)
        return pos;
 
    do
    {
        BOOL bQuoteBegin = FALSE;
        LPTSTR pItem = NULL;
        //Find the begining of Next Token
//        while( pBuffer[0] == L' '  ||
//               pBuffer[0] == L'\t' ||
//               pBuffer[0] == L'\n'  && BufferLen)
        while(BufferLen && IsDelimiter(pBuffer[0],pszDelimiters) )
        {
            ++pBuffer;--BufferLen;
        }
       
        if(!BufferLen)
            break;
        
        //Does Token Start with '"'
        if( pBuffer[0] == L'"' )
        {
            if(pbQuote)
                *pbQuote = TRUE;
            bQuoteBegin = TRUE;
            pBuffer++; --BufferLen;
        }
        if(!BufferLen)
            break;
        if(ppToken)
        {
            pItem = (LPTSTR)LocalAlloc(LPTR,sizeof(WCHAR)*INIT_SIZE);
            if(!pItem)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return -1;
            }
        }
        
        //Now get the end
        WCHAR ch;
        while( BufferLen )
        {
            BOOL bChar = TRUE;
            if( BufferLen >= 2 && *pBuffer == L'\\' && *(pBuffer+1) == L'"')
            {
                ch = L'"';
                pBuffer +=2; BufferLen -=2;
            }
            else if(pBuffer[0] == L'"')
            {
                //A Matching Quote Found.
                if(bQuoteBegin)
                {
                    ++pBuffer;
                    --BufferLen;
                    if(BufferLen)
                    {
                        //If next char is whitespace endof token
                        //Ex "ABC" "xyz" . after C its endof token
                        //if(pBuffer[0] == L' '  ||
                        //   pBuffer[0] == L'\t' || 
                        //   pBuffer[0] == L'\n')
                        if(IsDelimiter(pBuffer[0],pszDelimiters) )
                            break;
                        else
                        {
                            //Ex "ABC"xyz 
                            if(pBuffer[0] != L'"')
                                bQuoteBegin = FALSE;
                            //"ABC""xyz"
                            else
                            {    
                                ++pBuffer;
                                --BufferLen;                                
                            }
                        }
                    }
                    bChar = FALSE;
                    //
                    // Don't break because "" means that we want to clear the field out
                    //
//                    else
//                        break;
                }
                //ABC" xyz" will get one token 'ABC xyz'
                else
                {
                    bQuoteBegin = TRUE;
                    ++pBuffer;
                    --BufferLen;
                    bChar = FALSE;
                }

            }
//            else if(!bQuoteBegin && (pBuffer[0] == L' '  ||
//                                     pBuffer[0] == L'\t' || 
//                                     pBuffer[0] == L'\n'))
            else if(!bQuoteBegin && IsDelimiter(pBuffer[0],pszDelimiters))
            {
                ++pBuffer;
                --BufferLen;
                break;
            }
            else
            {
                ch = pBuffer[0];
                ++pBuffer;
                --BufferLen;
            }
            if(bChar && ppToken)
            {
                if(pos == MaxSize -1)
                    if(ERROR_SUCCESS != ResizeByTwo(&pItem,&MaxSize))
                    {
                        LocalFree(pItem);
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return -1;
                    }            
                pItem[pos] = ch;
            }
            if(bChar)   
                ++pos;
        }
        if(pos ||
           (!pos && bQuoteBegin))
        {
            if(ppToken)
            {
                //Security review: Have checked the code very carefully to be sure that there
                //will always be space for terminating null. But this check is so cheap it won't
                //harm
                if( pos >= (LONG)MaxSize)
                {
                    LocalFree(pItem);
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return -1;
                }
                pItem[pos] = '\0';
                *ppToken = pItem;
            }
            ++pos;
        }
    }while(0);
    return pos;
}

/*
Function to convert string an array of CTokens.
INPUT: pBuf Input Buffer
       BufLen   Length of bBuf
OUTPUT:ppToken  Gets Pointer to array of CToken
       argc     Lenght of array of CToken
Return Value: WIN32 Error

*/
DWORD Tokenize(IN LPWSTR pBuf,
               IN LONG BufLen,
               LPWSTR szDelimiters,
               OUT CToken **ppToken,
               OUT int *argc)
{
    *argc = 0;
    CToken *pToken = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bQuote;
    LPWSTR pszItem = NULL;
    //Get First Token
    LONG ret = GetToken(pBuf,
                        BufLen,
                        szDelimiters,
                        &bQuote,
                        NULL);
    if(ret == -1)
    {
        dwErr = GetLastError();
        goto exit_gracefully;
    }

    while(ret)
    {
        ++(*argc);
        ret = GetToken(NULL,
                       NULL,
                       szDelimiters,
                       &bQuote,
                       NULL);
        if(ret == -1)
        {
            dwErr = GetLastError();
            goto exit_gracefully;
        }
    }

    if(*argc)
    {
        int i =0;
        pToken = new CToken[*argc];
        if(!pToken)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit_gracefully;
        }
        ret = GetToken(pBuf,
                       BufLen,
                       szDelimiters,
                       &bQuote,
                       &pszItem);
        if(ret == -1)
        {
            dwErr = GetLastError();
            goto exit_gracefully;
        }
            
        while(ret)
        {
            dwErr = pToken[i++].Init(pszItem,bQuote); 
            if(dwErr != ERROR_SUCCESS)
            {
                if(pszItem)
                    LocalFree(pszItem);
                goto exit_gracefully;
            }
            
            if(pszItem)
                LocalFree(pszItem);                                       
            pszItem = NULL;


            ret = GetToken(NULL,
                           NULL,
                           szDelimiters,
                           &bQuote,
                           &pszItem);
            if(ret == -1)
            {
                dwErr = GetLastError();
                goto exit_gracefully;
            }

        }
    }

exit_gracefully:
    if(dwErr != ERROR_SUCCESS)
    {
        if(pToken)
        {
            delete [] pToken ;
        }       
        return dwErr;
    }
    *ppToken = pToken;
    return dwErr;
}

/*
Function to display the parsing errors. If function cannot 
handle some error, it will return False (also sets
pError->MessageShown to false) and calling function
must handle that error.

Function will return false in following cases
1)
if(pError->ErrorSource == ERROR_FROM_PARSER &&
   pError->Error == PARSE_ERROR_ATLEASTONE_NOTDEFINED)

  In this case error can be best displayed by the calling
  routine.

2)
if(pError->ErrorSource == ERROR_FROM_VLDFN &&
   pError->Error != VLDFN_ERROR_NO_ERROR)

  Error returned by custom validation functions
  cannot be handled here. 

3)
if(pError->ErrorSource == ERROR_WIN32_ERROR) and 
I cannot get any error message for the error code.

*/
BOOL DisplayParseError(IN LPCTSTR pszCommandName,
                       IN PPARSE_ERROR pError,
                       IN ARG_RECORD *Commands,
                       IN CToken *pToken)
{

    if(!pError || !pszCommandName)
        return FALSE;

    VOID *parg1 = NULL;
    VOID *parg2 = NULL;

        

    UINT idStr = 0;

    BOOL bReturn = TRUE;
    BOOL bDisplayUsageHelp = TRUE;
    switch(pError->ErrorSource)
    {
        case ERROR_FROM_PARSER:
        {
            switch(pError->Error)
            {
                case PARSE_ERROR_SWITCH_VALUE:
                {
                    idStr = IDS_PARSE_ERROR_SWITCH_VALUE;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }
                break;

                case PARSE_ERROR_SWICH_NO_VALUE:
                {
                    idStr = IDS_PARSE_ERROR_SWICH_NO_VALUE;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;                
                }
                break;

                case PARSE_ERROR_UNKNOWN_INPUT_PARAMETER:   
                {
                    idStr = IDS_PARSE_ERROR_UNKNOWN_INPUT_PARAMETER;
                    parg1 = (pToken + pError->ArgvIndex)->GetToken();
                }
                break;
                
                case PARSE_ERROR_SWITCH_NOTDEFINED:   
                {
                    idStr = IDS_PARSE_ERROR_SWITCH_NOTDEFINED;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }
                break;
                case PARSE_ERROR_MULTIPLE_DEF:
                {
                    idStr = IDS_PARSE_ERROR_MULTIPLE_DEF;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }        
                break;
                case PARSE_ERROR_UNICODE_NOTDEFINED:
                {
                    idStr = IDS_PARSE_ERROR_UNICODE_NOTDEFINED;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }        
                break;
                case PARSE_ERROR_UNICODE_DEFINED:
                {
                    idStr = IDS_PARSE_ERROR_UNICODE_DEFINED;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }        
                break;

                // 603157-2002/04/23-JonN
                case PARSE_ERROR_ALREADY_DISPLAYED:
                {
                    return TRUE;
                }

                case PARSE_ERROR_HELP_SWITCH:
                {
                    bDisplayUsageHelp = FALSE;
                }
                default:
                    bReturn = FALSE;
            }

            if(idStr)
            {
                //Format the string
                LPWSTR pBuffer = NULL;
                FormatStringID(&pBuffer,
                                NULL,
                                idStr,
                                parg1,
                                parg2);

                //Display it
                if(pBuffer)
                {
                    LPWSTR pszFormat = NULL;
                    FormatStringID(&pszFormat,
                                    NULL,
                                    IDS_PARSER_FAILED,
                                    pszCommandName,
                                    pBuffer);
                    if(pszFormat)
                    {
                        DisplayError(pszFormat);
                        LocalFreeString(&pszFormat);
                    }
                    LocalFreeString(&pBuffer);
                }
            }

        }
        break;
        
        case ERROR_FROM_VLDFN:
        {
            if(pError->Error != VLDFN_ERROR_NO_ERROR)
                    bReturn = FALSE;            
        }
        break;
        
        case ERROR_WIN32_ERROR:
        {
            LPWSTR pBuffer = NULL;
            if(GetSystemErrorText(&pBuffer, pError->Error))
            {
                if(pBuffer)
                {
                    LPWSTR pszFormat = NULL;
                    FormatStringID(&pszFormat,
                                    NULL,
                                    IDS_PARSER_FAILED,
                                    pszCommandName,
                                    pBuffer);
                    if(pszFormat)
                    {
                        DisplayError(pszFormat);
                        LocalFreeString(&pszFormat);
                    }
                    LocalFreeString(&pBuffer);
                }
                else
                    bReturn = FALSE;
            }
            else
                bReturn = FALSE;
        }
        break;

        default:
            bReturn = FALSE;
        break;
    }
    if(bReturn && bDisplayUsageHelp)
        DisplayUsageHelp(pszCommandName);

    pError->MessageShown = bReturn;
    return bReturn;
}

VOID DisplayError(LPWSTR pszError)
{
    if(pszError)
        WriteStandardError(L"%s\r\n",pszError);
}

VOID DisplayOutput(LPWSTR pszOutput)
{
    if(pszOutput)
        WriteStandardOut(L"%s\r\n",pszOutput);
}

VOID DisplayOutputNoNewline(LPWSTR pszOutput)
{
    if(pszOutput)
        WriteStandardOut(L"%s",pszOutput);
}

/*******************************************************************

    NAME:       DisplayMessage

    SYNOPSIS:   Loads Message from Message Table and Formats its
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
VOID DisplayMessage(UINT *pUsageTable,
                          BOOL bUseStdOut)
{
     if(!pUsageTable)
     {
         return;
     }

     while(*pUsageTable != USAGE_END)
     {
         PWSTR MessageDisplayString;
         ULONG Length;


         Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                 NULL,
                                 *pUsageTable,
                                 0,
                                 (PWSTR)&MessageDisplayString,
                                 0,
                                 NULL);

         if ( Length != 0 ) 
         {
              if(bUseStdOut)
                    WriteStandardOut(L"%s",MessageDisplayString);
              else
                    WriteStandardError(L"%s",MessageDisplayString);
        
              LocalFree( MessageDisplayString );
         }

         ++pUsageTable;
     }
}


/*
Class CToken

*/
CToken::CToken():m_bInitQuote(FALSE),m_pszToken(NULL){}

CToken::~CToken()
{
        LocalFree(m_pszToken);
}

//Changed to return DWORD
////Added parameter validation NTRAID#NTBUG9-570360-2002/03/07-hiteshr
DWORD CToken::Init(LPWSTR psz, BOOL bQuote)
{
    m_bInitQuote = bQuote;
    if(!StringCopy(&m_pszToken,psz))
        return ERROR_NOT_ENOUGH_MEMORY;
    return 
        ERROR_SUCCESS;
}
    

//This function should be called only if
//CToken::Init has succeeded. 
LPWSTR CToken::GetToken(){return m_pszToken;}
    
BOOL CToken::IsSwitch()
{
    //Assert(m_pszToken);
    if(!m_pszToken)
        return FALSE;
    if(m_bInitQuote)
        return FALSE;
    if(m_pszToken[0] == L'/' ||
        m_pszToken[0] == L'-')
        return TRUE;
        
    return FALSE;
}

BOOL CToken::IsSlash()
{
   if (!m_pszToken)
      return FALSE;
   if (m_bInitQuote)
      return FALSE;
   if (m_pszToken[0] == L'/')
      return TRUE;
   return FALSE;
}




void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{

    if(!lpBuffer || !cchBuffer)
    {
        assert(false);
        return;
    }
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FILE_TYPE_CHAR == FileType(fp))
    {
        WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else if (g_fUnicodeOutput)
    {
        //Buffer bounds are passed correctly.
        WriteFile(fp, lpBuffer, cchBuffer*sizeof(WCHAR), &cchBuffer, NULL);
    }
    else
    {
        int nSizeAnsiBuffer = WideCharToMultiByte(CP_OEMCP,
                                                  0,
                                                  lpBuffer,
                                                  cchBuffer,
                                                  NULL,
                                                  0,
                                                  NULL,
                                                  NULL);
        if(nSizeAnsiBuffer > 0)
        {
            LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LPTR, nSizeAnsiBuffer);

            if (lpAnsiBuffer != NULL)
            {
                cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                                0,
                                                lpBuffer,
                                                cchBuffer,
                                                lpAnsiBuffer,
                                                nSizeAnsiBuffer,
                                                NULL,
                                                NULL);

                if (cchBuffer != 0)
                {
                    WriteFile(fp, lpAnsiBuffer, nSizeAnsiBuffer, &cchBuffer, NULL);
                }

                LocalFree(lpAnsiBuffer);
            }
        }
    }
}

void
WriteStandardOut(PCWSTR pszFormat, ...)
{
    static HANDLE standardOut = GetStdHandle(STD_OUTPUT_HANDLE);

    //
    // Verify parameters
    //
    if (!pszFormat)
    {
        return;
    }

    va_list args;
    va_start(args, pszFormat);

    int nBuf = -1;
    size_t currentBufferSize = 0;

    WCHAR* szBuffer = 0;
    
    while (nBuf == -1)
    {
       if (szBuffer)
       {
          delete[] szBuffer;
          szBuffer = 0;
       }

       currentBufferSize += 4 * MAX_PATH;
       szBuffer = new WCHAR[currentBufferSize];
       if (!szBuffer)
       {
          return;
       }
        
       //Security Review: Correct length is getting passed.
       ZeroMemory(szBuffer, currentBufferSize * sizeof(WCHAR));

       //Security Review: If retuned value is -1, buffer is getting expanded.
       nBuf = _vsnwprintf(szBuffer, currentBufferSize, pszFormat, args);
    }

    //
    // Output the results
    //
    if (nBuf > 0)
    {
        MyWriteConsole(standardOut,
                       szBuffer,
                       nBuf);
    }

    delete[] szBuffer;
    szBuffer = 0;
    va_end(args);

}

void
WriteStandardError(PCWSTR pszFormat, ...)
{
    static HANDLE standardErr = GetStdHandle(STD_ERROR_HANDLE);

   //
   // Verify parameters
   //
   if (!pszFormat)
   {
      return;
   }

   va_list args;
   va_start(args, pszFormat);

   // JonN 9/3/01 This needs to be large enough to accomodate the usage text
   //Security Review: This is huge. We should start with small buffer and 
   //increment if thats not sufficient. NTRAID#NTBUG9-569880-2002/03/07-hiteshr

    size_t cchSize = MAX_PATH * 4;
    const size_t cchGiveupSize = STRSAFE_MAX_CCH;
    WCHAR* pszBuffer = NULL;

    while(cchSize < cchGiveupSize)
    {
        pszBuffer = new WCHAR[cchSize];
        if (!pszBuffer)
        {
            return;
        }
        //Security Review:Correct buffer size is passed.
        ZeroMemory(pszBuffer, cchSize* sizeof(WCHAR));

        //Security Review:This is fine since we check the nBuf below.
        //if output is greated than 100*MAX_PATH, we won't print anything
        //which is a bug and is covered in NTRAID#NTBUG9-569880-2002/03/07-hiteshr
        HRESULT hr = StringCchVPrintf(pszBuffer, cchSize, pszFormat, args);
        if(SUCCEEDED(hr))
        {
            break;
        }
        
        if(hr == STRSAFE_E_INSUFFICIENT_BUFFER)
        {
            //Buffer is small. Try with bigger buffer
            delete[] pszBuffer;
            pszBuffer = NULL;
            cchSize = cchSize*2;
        }
        else
        {
            delete[] pszBuffer;
            pszBuffer = NULL;
            break;
        }
    }
            

   //
   // Output the results
   //
   if (pszBuffer)
   {
      MyWriteConsole(standardErr,
                     pszBuffer,
                     wcslen(pszBuffer));
        delete[] pszBuffer;
   }
   va_end(args);

}


/*******************************************************************

    NAME:       AddDNEscaping_Commands

    SYNOPSIS:   Adds full ADSI escaping to DN arguments

********************************************************************/
BOOL AddDNEscaping_Commands( IN OUT ARG_RECORD *Commands, OUT PPARSE_ERROR pError )
{
    for( int i=0; ARG_TYPE_LAST != Commands[i].fType; i++ )
    {
        if (!(ARG_FLAG_DN & Commands[i].fFlag))
            continue;

        if (ARG_TYPE_STR == Commands[i].fType)
        {
            if (NULL == Commands[i].strValue)
                continue;
            LPWSTR pszEscaped = NULL;
            DWORD dwErr = AddDNEscaping_DN(&pszEscaped, Commands[i].strValue);
            if (ERROR_SUCCESS != dwErr)
            {
                 FILL_ERROR(pError,
                            ERROR_FROM_PARSER,
                            PARSE_ERROR_SWITCH_VALUE,
                            i,
                            -1);
                return FALSE;
            }
            LocalFree(Commands[i].strValue);
            Commands[i].strValue = pszEscaped;
            continue;
        }
        
        if (ARG_TYPE_MSZ != Commands[i].fType)
        {
            continue; // shouldn't happen
        }

        if (NULL == Commands[i].strValue)
            continue;

        // count through double-NULL-terminated string list
        PWSTR pszDoubleNullObjectDN = Commands[i].strValue;
        LPTSTR buffer = NULL;
        LONG maxSize = 0;
        LONG currentSize = 0;
        if (!StartBuffer(&buffer,&maxSize,&currentSize))
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       ERROR_NOT_ENOUGH_MEMORY,
                       -1,
                       -1);

            return FALSE;
        }
        for ( ;
                NULL != pszDoubleNullObjectDN &&
                L'\0' != *pszDoubleNullObjectDN;
                pszDoubleNullObjectDN += (wcslen(pszDoubleNullObjectDN)+1) )    //Security Review:
        {                                                                       //String is null terminated.
            LPWSTR pszEscaped = NULL;
            DWORD dwErr = AddDNEscaping_DN(&pszEscaped, pszDoubleNullObjectDN);
            if (ERROR_SUCCESS != dwErr)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_VALUE,
                           i,
                           -1);
                return FALSE;
            }
            
            dwErr = AddToBuffer(pszEscaped,
                                &buffer,&maxSize,&currentSize,TRUE);
            if (ERROR_SUCCESS != dwErr)
            {
                FILL_ERROR(pError,
                           ERROR_WIN32_ERROR,
                           dwErr,
                           -1,
                           -1);
                
                return FALSE;
            }
            LocalFree(pszEscaped);
        }
        LocalFree(Commands[i].strValue);
        Commands[i].strValue = buffer;
    }

    return TRUE;
} // AddDNEscaping_Commands

// JonN 10/17/01 476225 0x000A -> "\0A"
// returns hex value of character, or -1 on failure
int HexValue( WCHAR wch )
{
    if ( L'0' <= wch && L'9' >= wch )
        return wch - L'0';
    else if ( L'A' <= wch && L'F' >= wch )
        return 10 + wch - L'A';
    else if ( L'a' <= wch && L'f' >= wch )
        return 10 + wch - L'a';
    else return -1;
}

DWORD AddDNEscaping_DN( OUT LPWSTR* ppszOut, IN LPWSTR pszIn )
{
    //
    // JonN 5/12/01 special-case "domainroot" and "forestroot" which can be
    // parameters to "-startnode" but fail IADsPathname::GetEscapedElement().
    //
    if (!pszIn ||
        !*pszIn ||
        !_tcsicmp(L"domainroot",pszIn) ||
        !_tcsicmp(L"forestroot",pszIn))
    {
        return (StringCopy(ppszOut,pszIn))
            ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
    }

    LONG maxSize = 0;
    LONG currentSize = 0;
    if (!StartBuffer(ppszOut,&maxSize,&currentSize))
        return ERROR_NOT_ENOUGH_MEMORY;

    // copy pszIn into temporary buffer
    LPWSTR pszCopy = NULL;
    if (!StringCopy(&pszCopy,pszIn) || NULL == pszCopy)
        return ERROR_NOT_ENOUGH_MEMORY;

    WCHAR* pchElement = pszCopy;
    WCHAR* pch = pszCopy;
    do {
        if (L'\\' == *pch && (L','  == *(pch+1)
                           || L'\\' == *(pch+1)))
        {
            //
            // manual escaping on command line: "\," or "\\"
            //

            // also copies trailing L'\0'
            //Security review:pch is null terminated
            memmove(pch, pch+1, wcslen(pch)*sizeof(WCHAR));
        }
        // JonN 10/17/01 476225 0x000A -> "\0A"
        else if (L'\\' == *pch && 
                 0 <= HexValue(*(pch+1)) &&
                 0 <= HexValue(*(pch+2)) )
        {
            //
            // manual escaping on command line: "\0A" etc.
            //

            *pch = (WCHAR)( (16*HexValue(*(pch+1))) + HexValue(*(pch+2)));

            // also copies trailing L'\0'
            memmove(pch+1, pch+3, (wcslen(pch)-2)*sizeof(WCHAR));
        }
        // 613568-2002/05/03-JonN reject invalid escaping
        else if (L'\\' == *pch)
        {
            return ERROR_INVALID_PARAMETER; // CODEWORK create detailed error message
        }
        else if (L',' == *pch || L'\0' == *pch)
        {
            //
            // completes path element
            //

            WCHAR chTemp = *pch;
            *pch = L'\0';

            LPWSTR pszEscaped = NULL;
            HRESULT hr = GetEscapedElement( &pszEscaped, pchElement );

            if (FAILED(hr) || NULL == pszEscaped)
                return ERROR_INVALID_PARAMETER; // cannot return HRESULTs

            if (NULL != *ppszOut && L'\0' != **ppszOut)
            {
                // add seperator to DN
                DWORD dwErr = AddToBuffer(L",",
                                          ppszOut,&maxSize,&currentSize,
                                          FALSE); // not MSZ output
                if (ERROR_SUCCESS != dwErr)
                    return dwErr;
            }
            // add path element to DN
            DWORD dwErr = AddToBuffer(pszEscaped,
                                      ppszOut,&maxSize,&currentSize,
                                      FALSE); // not MSZ output
            if (ERROR_SUCCESS != dwErr)
                return dwErr;

            ::LocalFree(pszEscaped);

            if (L'\0' == chTemp)
                break;

            *pch = chTemp;
            pchElement = pch+1;
        }

        pch++;
    } while (true);

    LocalFree(pszCopy);

    return ERROR_SUCCESS;
} // AddDNEscaping_DN

//Added parameter validation NTRAID#NTBUG9-570344-2002/03/07-hiteshr
BOOL StartBuffer( OUT LPTSTR* pbuffer,
                  OUT LONG* pmaxSize,
                  OUT LONG* pcurrentSize )
{
    if(!pbuffer || !pmaxSize || !pcurrentSize)
        return FALSE;

    *pbuffer = (LPTSTR)LocalAlloc(LPTR,MAXSTR*sizeof(TCHAR)); // init to zero
    *pmaxSize = MAXSTR;
    *pcurrentSize = 0;
    return (NULL != pbuffer);
}

//Added parameter validation NTRAID#NTBUG9-569880-2002/03/07-hiteshr
DWORD AddToBuffer( IN LPCTSTR psz,
                   IN OUT LPTSTR* pbuffer,
                   IN OUT LONG* pmaxSize,
                   IN OUT LONG* pcurrentSize,
                   BOOL fMSZBuffer)
{
    if(!psz || !pbuffer || !pmaxSize || !pcurrentSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //Security Review: psz is terminated by NULL
    LONG len = (LONG)wcslen(psz);
    //-2 as last string is delimited by two null
    while(((*pcurrentSize) + len) > ((*pmaxSize) - 2))
    {
        DWORD dwErr = ResizeByTwo(pbuffer,pmaxSize);
        if (dwErr != ERROR_SUCCESS)
            return dwErr;
    }
    
    //Security Review:Buffer is correctly allocated above.
    _tcscpy(((*pbuffer) + (*pcurrentSize)), psz);
    (*pcurrentSize) += len;
    //tail end of pbuffer is all NULLs
    if (fMSZBuffer)
        (*pcurrentSize)++;
    return NO_ERROR;
}

BOOL 
IsTokenHelpSwitch(LPTOKEN pToken)
{
    if(!pToken)
    {
        return FALSE;
    }
    if(pToken->IsSwitch())
    {
        //Security Review:Right hand side string is constant.
        if(!wcscmp(pToken->GetToken(),L"/?") ||
           !wcscmp(pToken->GetToken(),L"/h") ||
           !wcscmp(pToken->GetToken(),L"-?") ||
           !wcscmp(pToken->GetToken(),L"-h"))
                return TRUE;                                                    
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplayUsageHelp
//
//  Synopsis:   Displays "type dscmd /? for help"
//
//  History:    11-Sep-2000   hiteshr Created
//---------------------------------------------------------------------------

void 
DisplayUsageHelp( LPCWSTR pszCommand)
{
    if(!pszCommand)
    {
        return;
    }
    
    LPWSTR pszFormat = NULL;
    if(LoadStringAlloc(&pszFormat,NULL,IDS_DISPLAY_HELP))
    {
        WriteStandardError(pszFormat,
                           pszCommand);
    }
    LocalFreeString(&pszFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dscmd\parser\varg.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)
            
    Copyright (c) 1998-2000 Microsoft Corporation
    
 
\*****************************************************************************/

#ifndef _VARG_H_012599_
#define _VARG_H_012599_

#define MAXSTR                   1025




//Class CToken
//It represents a Single Token.
class CToken
{
public:
    CToken();
    ~CToken();
    DWORD Init(LPWSTR psz, BOOL bQuote);   
    LPWSTR GetToken();    
    BOOL IsSwitch();
    BOOL IsSlash();
private:
    LPWSTR m_pszToken;
    BOOL   m_bInitQuote;
};
typedef CToken * LPTOKEN;



#define ARG_TYPE_INT             0
#define ARG_TYPE_BOOL            1
#define ARG_TYPE_STR             2
#define ARG_TYPE_HELP            3
#define ARG_TYPE_DEBUG           4
#define ARG_TYPE_MSZ             5
#define ARG_TYPE_INTSTR          6
#define ARG_TYPE_PASSWORD        7  //Password is input at commandline as string. It is 
                                    //stored in ARG_RECORD in vValue member where vValue
                                    //is a pointer to encrypted data_blob
#define ARG_TYPE_LAST            8


#define ARG_FLAG_OPTIONAL        0x00000001     
#define ARG_FLAG_REQUIRED        0x00000002
#define ARG_FLAG_DEFAULTABLE     0x00000004     
#define ARG_FLAG_NOFLAG          0x00000008     //For parameters like target name
#define ARG_FLAG_HIDDEN          0x00000010
#define ARG_FLAG_VERB            0x00000020     
#define ARG_FLAG_STDIN           0x00000040     //This must be Required. If not sepcified read from standard input
#define ARG_FLAG_ATLEASTONE      0x00000080     //If this flag is specified on one or more switch, at
                                                //least one of those switches must be defined
#define ARG_FLAG_DN              0x00000100     //JonN 4/26/01 256583 add ADSI escaping



#define ARG_TERMINATOR           0,NULL,0,NULL,ARG_TYPE_LAST,0,(CMD_TYPE)0,FALSE,NULL
#define ID_ARG2_NULL             (LONG)-1

#define CMD_TYPE    void*

typedef struct _ARG_RECORD
{
    LONG    idArg1;
    LPTSTR  strArg1;
    LONG    idArg2;
    LPTSTR  strArg2;
    int     fType;
    DWORD   fFlag;
    union{
        void*   vValue;
        LPTSTR  strValue;
        int     nValue;
        BOOL    bValue;
        DATA_BLOB encryptedDataBlob;
    };
    BOOL	bDefined;
    DWORD	(*fntValidation)(PVOID pArg);
} ARG_RECORD, *PARG_RECORD;


//Error Source
#define ERROR_FROM_PARSER   1
#define ERROR_FROM_VLDFN    2
#define ERROR_WIN32_ERROR   3

//Parse Errors for when ERROR_SOURCE is ERROR_FROM_PARSER
/*
SWITCH value is incorrect.
ArgRecIndex is index of record.
ArgvIndex is index of token.
*/
#define PARSE_ERROR_SWITCH_VALUE        1
/*No Value is given for a swich when one is expected.
ArgRecIndex is index of record.
ArgvIndex is -1.
*/
#define PARSE_ERROR_SWICH_NO_VALUE      2
/*
Invalid Input
ArgRecIndex is -1, 
ArgvIndex is index of token.
*/
#define PARSE_ERROR_UNKNOWN_INPUT_PARAMETER   3
/*
Required switch is not defined. 
ArgRecIndex is index of record.
ArgvIndex is -1.
*/
#define PARSE_ERROR_SWITCH_NOTDEFINED   4
/*
Switch or Parameter is defined twice.
ArgRecIndex is index of record.
ArgvIndex is -1
*/
#define PARSE_ERROR_MULTIPLE_DEF        5
/*
Error Reading From STDIN.
ArgRecIndex is -1.
ArgvIndex is -1.
*/
#define ERROR_READING_FROM_STDIN        6
/*
Parser Encountered Help Switch
ArgRecIndex is index of record.
ArgvIndex is -1
*/
#define PARSE_ERROR_HELP_SWITCH         7
/*
The ARG_FLAG_ATLEASTONE flag was
defined on one or more switch yet
none of these switches were defined
ArgRecIndex is -1
ArgvIndex is -1
*/
#define PARSE_ERROR_ATLEASTONE_NOTDEFINED 8
/*
The value read from STDIN appears to be
in UNICODE, but the -uc and -uci switches
were not defined.
*/
#define PARSE_ERROR_UNICODE_NOTDEFINED  9
/*
The value read from STDIN appears to be
in ANSI, but the -uc and/or -uci switches
were defined.
*/
#define PARSE_ERROR_UNICODE_DEFINED     10

// 603157-2002/04/23-JonN
/*
A parse error occurred which has already
been reported.
*/
#define PARSE_ERROR_ALREADY_DISPLAYED   11


//Parse Errors for when ERROR_SOURCE is VLDFN

/*
Use this error code when Validation Function has handled the error and
Shown appropriate error message.
*/
#define VLDFN_ERROR_NO_ERROR    1


//Error is returned by Parser in PARSE_ERROR structure
//ErrorSource: Source of Error. Parser or Validation Function
//Error This is the actual error code. Its value depend on ErrorSource value.
//  if( ErrorSource == PARSE_ERROR )
//      possible values are   ERROR_FROM_PARSER ERROR_FROM_VLDFN       
//  if( ErrorSource == ERROR_FROM_VLDFN )
//      depends on the function
//  ArgRecIndex is appropriate index in the ARG_RECORD, if applicable else -1
//  ArgvIndex is approproate index in the agrv array, if applicable else -1
typedef struct _PARSE_ERROR
{
    INT ErrorSource;
    DWORD Error;
    INT ArgRecIndex;
    INT ArgvIndex;
	BOOL MessageShown;
} PARSE_ERROR, *PPARSE_ERROR;

extern BOOL g_fUnicodeInput;
extern BOOL g_fUnicodeOutput;

BOOL ParseCmd(IN LPCTSTR pszCommandName,
			  IN ARG_RECORD *Commands,
              IN int argc, 
              IN CToken *pToken,
              IN UINT* pUsageMessageTable, 
              OUT PPARSE_ERROR pError,
              IN BOOL bValidate = TRUE);

void FreeCmd(ARG_RECORD *Commands);

DWORD GetCommandInput(OUT int *pargc,           //Number of Tokens
                      OUT LPTOKEN *ppToken);    //Array of CToken


DWORD Tokenize(IN LPWSTR pBuf,
               IN LONG BufLen,
               IN LPWSTR pszDelimiters,
               OUT CToken **ppToken,
               OUT int *argc);

LONG GetToken(IN LPWSTR pBuf,
              IN LONG BufLen,
              IN LPWSTR pszDelimiters,
              OUT BOOL *bQuote,
              OUT LPWSTR *ppToken);

BOOL DisplayParseError(IN LPCTSTR pszCommandName,
					   IN PPARSE_ERROR pError,
                       IN ARG_RECORD *Commands,
                       IN CToken *pToken);


//Function to display string to STDERR
VOID DisplayError(IN LPWSTR pszError);
//Function to display string to STDOUT, appending newline
VOID DisplayOutput(IN LPWSTR pszOut);
//Function to display string to STDOUT, without newline
VOID DisplayOutputNoNewline(IN LPWSTR pszOut);
//Function to display Usage Message .
VOID DisplayMessage(UINT *pUsageTable,
						  BOOL bUseStdOut = FALSE);
#define USAGE_END 0xffffffff


// Copied from JSchwart on 2/19/2001

void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );


void
WriteStandardOut(PCWSTR pszFormat, ...);

void
WriteStandardError(PCWSTR pszFormat, ...);

BOOL 
IsTokenHelpSwitch(LPTOKEN pToken);

void 
DisplayUsageHelp( LPCWSTR pszCommand);


#endif //_VARG_H_012599_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\analysisresults.hpp ===
// Results of the analysis phase
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#ifndef ANALYSIS_RESULTS_HPP
#define ANALYSIS_RESULTS_HPP

#include "global.hpp"
#include "constants.hpp"

using namespace std;


// This file contains the data structure with the analysis results
struct ObjectId
{
   long locale;
   String object;

   ObjectId(long locale_,String &object_):
         locale(locale_),object(object_) {};

   // The operator below is necessary for structs
   // to be map keys. It ends up defining the order
   // in which the ldiff entries will appear, i.e.
   // first by locale and then by object.
   bool operator < (const ObjectId& idArg) const
   {
      return   (locale < idArg.locale) ||
               (
                  (locale == idArg.locale) &&
                  (object < idArg.object)
               );
   }         

   bool operator == (const ObjectId& idArg) const
   {
      return   ( locale == idArg.locale ) &&
               ( object.icompare(idArg.object) == 0 );
   }         
};


struct ValueActions
{
   StringList addValues;
   StringList delValues;
};


typedef map < 
               String,
               ValueActions,
               less<String>, 
               Burnslib::Heap::Allocator<ValueActions> 
            > PropertyActions;


typedef map < 
               ObjectId,
               PropertyActions,
               less<ObjectId>, 
               Burnslib::Heap::Allocator<PropertyActions> 
            > ObjectActions;

   // The previous map was thought keeping in mind the repair phase.
   // It accumulates additions and removals for properties 
   // in order to provide an ldiff layout where all actions 
   // related to a property would be grouped under all
   // actions related to an object
   //
   // The repair phase will do something like
   // For each element of objectActions
   //    write the header for the object 
   //    like "dn: CN=object,CN=401,CN=DisplaySpecifiers...\n"
   //    write "changetype: ntdsSchemaModify\n"
   //    For each Property in the object
   //       get the list of actions for the property
   //       if you have a reset, write "delete: property\n-"
   //       if you have additions
   //          write "add: property\n"
   //          write all additions in the form "property: addValue\n"
   //          write "\n-\n"
   //       End if
   //       if you have removals
   //          write "delete: property\n"
   //          write all removals in the form "property: delValue\n"
   //          write "\n-\n"
   //       End if
   //    End For Each
   // End For Each

typedef list <
               ObjectId,
               Burnslib::Heap::Allocator<ObjectId>
             > ObjectIdList;


struct SingleValue
{
   long     locale;
   String   object;
   String   property;
   String   value;
   
   SingleValue
   (
      const long     locale_,
      const String   &object_,
      const String   &property_,
      const String   &value_
   )
   :
      locale(locale_),
      object(object_),
      property(property_),
      value(value_)
   {}
};

typedef list <
               SingleValue,
               Burnslib::Heap::Allocator<SingleValue>
             > SingleValueList;




struct AnalysisResults
{
   LongList          createContainers;
   ObjectIdList      conflictingWhistlerObjects;
   ObjectIdList      createWhistlerObjects;
   ObjectIdList      createW2KObjects;
   ObjectActions     objectActions;
   SingleValueList   customizedValues;
   ObjectActions     extraneousValues;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\adsihelpers.hpp ===
// ADSI Helper functions
//
// Copyright (c) 2001 Microsoft Corporation
//
// 1 Mar 2001 sburns



#ifndef ADSIHELPERS_HPP_INCLUDED
#define ADSIHELPERS_HPP_INCLUDED



// CODEWORK: consider putting this, and some of the more general purpose
// adsi goodies from admin\snapin\localsec\src\adsi.hpp|.cpp into an
// adsi header in burnslib.



// Template function that actually calls ADsOpenObject.
//
// Interface - The IADsXXX interface of the object to be bound.
//
// path - in, The ADSI path of the object to be bound.
//
// ptr - out, A null smart pointer to be bound to the interface of the object.

template <class Interface>
HRESULT
AdsiOpenObject(
   const String&              path,
   SmartInterface<Interface>& ptr)
{
   LOG_FUNCTION2(AdsiOpenObject, path);
   ASSERT(!path.empty());

   Interface* p = 0;
   HRESULT hr =
      ::ADsOpenObject(
         path.c_str(),
         0,
         0,
         ADS_SECURE_AUTHENTICATION,         
         __uuidof(Interface),
         reinterpret_cast<void**>(&p));
   if (SUCCEEDED(hr))
   {
      ptr.Acquire(p);
   }

   LOG_HRESULT(hr);
   
   return hr;
}



#endif   // ADSIHELPERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\analysis.cpp ===
#include "headers.hxx"
#include "global.hpp"


#include "Analysis.hpp"
#include "AnalysisResults.hpp"
#include "CSVDSReader.hpp"
#include "resourceDspecup.h"
#include "AdsiHelpers.hpp"
#include "constants.hpp"
#include "dspecup.hpp"


Analysis::Analysis
   (
      const GUID           guid_,
      const CSVDSReader&   csvReader409_,
      const CSVDSReader&   csvReaderIntl_,
      const String&        ldapPrefix_,
      const String&        rootContainerDn_,
      AnalysisResults      &res,
      const String         &reportName_,//=L"", 
      void                 *caleeStruct_,//=NULL,
      progressFunction     stepIt_,//=NULL,
      progressFunction     totalSteps_//=NULL,
   )
   :
   guid(guid_),
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   ldapPrefix(ldapPrefix_),
   rootContainerDn(rootContainerDn_),
   results(res),
   reportName(reportName_),
   caleeStruct(caleeStruct_),
   stepIt(stepIt_),
   totalSteps(totalSteps_)
{
   LOG_CTOR(Analysis);
   ASSERT(!ldapPrefix.empty());
   ASSERT(!rootContainerDn.empty());

};


// Analysis entry point
HRESULT 
Analysis::run()
{
   LOG_FUNCTION(Analysis::run);

   if(changes.size()==0)
   {
       setChanges();
   }

   HRESULT hr=S_OK;
   do
   {
      LongList locales;
      for(long t=0;LOCALEIDS[t]!=0;t++)
      {
         locales.push_back(LOCALEIDS[t]);
      }
      locales.push_back(LOCALE409[0]);
      
      if(totalSteps!=NULL)
      {
         // The cast bellow is for IA64 compilation since we know
         // that locales.size() will fit in a long.
         totalSteps(static_cast<long>(locales.size()),caleeStruct);
      }

      BREAK_ON_FAILED_HRESULT(hr);

      LongList::iterator begin=locales.begin();
      LongList::iterator end=locales.end();

      while(begin!=end)
      {
         long locale=*begin;
         bool isPresent;

         hr=dealWithContainer(locale,isPresent);
         BREAK_ON_FAILED_HRESULT(hr);

         if (isPresent)
         {
            hr=dealWithW2KObjects(locale);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if(stepIt!=NULL)
         {
            stepIt(1,caleeStruct);
         }

         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      if(!reportName.empty())
      {
         hr=createReport(reportName);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// add entry to result.createContainers if container is not present
// also returns flag isPresent
HRESULT 
Analysis::dealWithContainer(
   const long  locale,
   bool        &isPresent)
{
   LOG_FUNCTION(Analysis::dealWithContainer);

   ASSERT(locale > 0); 
   ASSERT(!rootContainerDn.empty());

   HRESULT hr = S_OK;
   

   do
   {
      String container = String::format(L"CN=%1!3x!,", locale);
      String childContainerDn =ldapPrefix +  container + rootContainerDn;

      // Attempt to bind to the container.
         
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(childContainerDn, iads);
      if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
      {
         // The container object does not exist.  This is possible because
         // the user has manually removed the container, or because it
         // was never created due to an aboted post-dcpromo import of the
         // display specifiers when the forest root dc was first promoted.

         // NTRAID#NTBUG9-726839-2002/10/31-lucios
         // We are only recovering the 409 container since recovering
         // an international locale will overwrite possible 409 customizations
         if (locale == 0x409) results.createContainers.push_back(locale);

         isPresent=false;

         hr = S_OK;
         break;
      }  
      else if (FAILED(hr))
      {
         error=String::format(IDS_ERROR_BINDING_TO_CONTAINER,
                              childContainerDn.c_str());
         break;
      }


      // At this point, the bind succeeded, so the child container exists.
      // So now we want to examine objects in that container.

      isPresent=true;
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// sets  iDirObj with the Active Directory object 
// corresponding to the locale and object
HRESULT
Analysis::getADObj
(
   const long locale,
   const String& object,
   SmartInterface<IDirectoryObject> &iDirObj
)
{
   HRESULT hr = S_OK;

   do
   {
      String objectPath =
         ldapPrefix +  L"CN=" + object + L"," + 
         String::format(L"CN=%1!3x!,", locale) + rootContainerDn;

      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);
      if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
      {
         // The object does not exist. 
         hr = S_FALSE;
         break;
      }
      
      if (FAILED(hr))
      {
         // Unexpected error
         error=String::format
               (
                  IDS_ERROR_BINDING_TO_OBJECT,
                  object.c_str(),
                  objectPath.c_str()
               );

         break;
      }

      // At this point, the display specifier object exists.  

      hr=iDirObj.AcquireViaQueryInterface(iads); 
      BREAK_ON_FAILED_HRESULT(hr);


   } while (0);
   
   LOG_HRESULT(hr);
   return hr;
}


// add entries to results.createW2KObjects 
//       and results.objectActions as necessary
HRESULT 
Analysis::dealWithW2KObjects(const long locale)
{
   LOG_FUNCTION(Analysis::dealWithW2KObjects);
   ASSERT(locale > 0);

   HRESULT hr = S_OK;

   do
   {
      hr=checkChanges(locale,changes[guid][locale]);
      BREAK_ON_FAILED_HRESULT(hr);
      hr=checkChanges(locale,changes[guid][-1]);
      BREAK_ON_FAILED_HRESULT(hr);
   } while (0);
   
   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
Analysis::checkChanges
(
   const long locale,
   const changeList& changes
)
{
   LOG_FUNCTION(Analysis::checkChanges);

   HRESULT hr=S_OK;

   do
   {
      changeList::const_iterator  curChange,endChange;
      for
      (
         curChange=changes.begin(),endChange=changes.end();
         curChange!=endChange;
         curChange++
      )
      {
         const String &object=curChange->object;
         const String &property=curChange->property;
         const String &firstArg=curChange->firstArg;
         const String &secondArg=curChange->secondArg;

         SmartInterface<IDirectoryObject> iDirObj;
         hr=getADObj(locale,object,iDirObj);
         BREAK_ON_FAILED_HRESULT(hr);

         if(hr==S_FALSE) // object doesn't exist
         {
            ObjectId tempObj(locale,String(object));
            if(curChange->type==ADD_OBJECT)
            {
                results.createWhistlerObjects.push_back(tempObj);
            }
            else
            {
                // NTRAID#NTBUG9-726839-2002/10/31-lucios
                // We are only recovering objects in the 409 container 
                // since recovering an object in an international locale
                // will overwrite possible 409 customizations
                if (
                      (locale == 0x409) &&
                      find
                      (
                         results.createW2KObjects.begin(),
                         results.createW2KObjects.end(),
                         tempObj
                      ) == results.createW2KObjects.end()
                   )
                {
                   results.createW2KObjects.push_back(tempObj);
                }
            }
            hr=S_OK;
            continue;
         }
         else
         {
            ObjectId tempObj(locale,String(object));
            if(curChange->type==ADD_OBJECT)
            {
                results.conflictingWhistlerObjects.push_back(tempObj);
            }
         }
      
         switch(curChange->type)
         {
            case ADD_ALL_CSV_VALUES: 
         
               hr = addAllCsvValues
                    (
                        iDirObj,
                        locale,
                        object,
                        property
                    );
               break;

            case ADD_VALUE: 
    
               hr = addValue
                    (
                        iDirObj,
                        locale,
                        object,
                        property,
                        firstArg
                    );
               break;

            case REPLACE_W2K_MULTIPLE_VALUE: 

               hr = replaceW2KMultipleValue
                    (
                        iDirObj,
                        locale,
                        object,
                        property,
                        firstArg,
                        secondArg
                    );
               break;

            case REPLACE_W2K_SINGLE_VALUE: 

               hr = replaceW2KSingleValue
                    (
                        iDirObj,
                        locale,
                        object,
                        property,
                        firstArg,
                        secondArg
                    );
               break;

            case ADD_GUID: 

               hr = addGuid
                    (
                        iDirObj,
                        locale,
                        object,
                        property,
                        firstArg
                    );
               break;

            case REMOVE_GUID: 

               hr = removeGuid
                    (
                        iDirObj,
                        locale,
                        object,
                        property,
                        firstArg
                    );
               break;

            case REPLACE_GUID:
               hr = replaceGuid
                    (
                        iDirObj,
                        locale,
                        object, 
                        property, 
                        firstArg,
                        secondArg
                    );
               break;
            case ADD_OBJECT:
               break; // dealt with in the beginning of the function

            default:
               ASSERT(false);
         }
         BREAK_ON_FAILED_HRESULT(hr);
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


// adds ordAndGuid to the property if Guid is not already there.
HRESULT 
Analysis::addGuid
(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const String         &object, 
   const String         &property, 
   const String         &ordAndGuid
)
{
   LOG_FUNCTION(Analysis::addGuid);

   HRESULT hr = S_OK;

   do
   {
      String guidFound;
      hr=getADGuid(   
                     iDirObj,
                     property,
                     ordAndGuid,
                     guidFound
                  );

      BREAK_ON_FAILED_HRESULT(hr);
   
      if (hr == S_FALSE)
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(ordAndGuid);
      }
       
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// replaces ordAndGuidWin2K for  ordAndGuidWhistler.
HRESULT 
Analysis::replaceGuid
(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const String         &object, 
   const String         &property, 
   const String         &ordAndGuidWin2K,
   const String         &ordAndGuidWhistler
)
{
   LOG_FUNCTION(Analysis::replaceGuid);
   HRESULT hr = S_OK;
   
   do
   {
      String guidFound;
      hr=getADGuid(   
                     iDirObj,
                     property,
                     ordAndGuidWhistler,
                     guidFound
                  );
      BREAK_ON_FAILED_HRESULT(hr);

      if (hr == S_OK) // The Whistler GUID was found
      {
         hr=removeExtraneousGUID
            (
                  iDirObj,
                  locale,
                  object,
                  property,
                  guidFound,
                  ordAndGuidWin2K,
                  ordAndGuidWhistler
            );
         break;
      }

      // The Whistler GUID is not present

      hr=getADGuid(   
                     iDirObj,
                     property,
                     ordAndGuidWin2K,
                     guidFound
                  );
      BREAK_ON_FAILED_HRESULT(hr);

      if (hr == S_OK) // The Win2K GUID was found
      {
         size_t posFound=guidFound.find(L',');
         ASSERT(posFound != String::npos); 
         size_t posWhistler=ordAndGuidWhistler.find(L',');
         ASSERT(posWhistler != String::npos); 

         String guidToAdd = guidFound.substr(0,posFound) +
                            ordAndGuidWhistler.substr(posWhistler); 

         ObjectId tempObj(locale,String(object));
         ValueActions &act=results.objectActions[tempObj][property];
         act.delValues.push_back(guidFound);
         act.addValues.push_back(guidToAdd);

         hr=removeExtraneousGUID
            (
                  iDirObj,
                  locale,
                  object,
                  property,
                  guidFound,
                  ordAndGuidWin2K,
                  ordAndGuidWhistler
            );
         break;
      }

      // Neither the Win2K nor the Whistler GUIDs were found
      // Since the customer did not wan't the Win2K GUID
      // he probably will not want the Whistler GUID either,
      // so we do nothing.

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}

// removes ordAndGuid from the property if Guid is there. 
HRESULT 
Analysis::removeGuid
(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const String         &object, 
   const String         &property,
   const String         &ordAndGuid)
{

   LOG_FUNCTION(Analysis::removeGuid);

   HRESULT hr = S_OK;
   
   do
   {
      String guidFound;
      hr=getADGuid(   
                     iDirObj,
                     property,
                     ordAndGuid,
                     guidFound
                  );
      BREAK_ON_FAILED_HRESULT(hr);
   
      if (hr == S_OK)
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.delValues.push_back(guidFound);
      }
       
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



// adds all csv values still not on the property
HRESULT
Analysis::addAllCsvValues
(
   IDirectoryObject     *iDirObj,
   const long           locale,
   const String         &object, 
   const String         &property
)
{
   LOG_FUNCTION(Analysis::addAllCsvValues);
   
   HRESULT hr = S_OK;
   const CSVDSReader &csvReader=(locale==0x409)?csvReader409:csvReaderIntl;

   do
   {
      StringList values;
      hr=csvReader.getCsvValues(locale,object.c_str(),property.c_str(),values);
      BREAK_ON_FAILED_HRESULT(hr);

      if (values.size()==0)
      {
         error=String::format(IDS_NO_CSV_VALUE,locale,object.c_str());
         hr=E_FAIL;
         break;
      }
      StringList::iterator begin=values.begin();
      StringList::iterator end=values.end();
      while(begin!=end)
      {
         hr=addValue(iDirObj,locale,object,property,begin->c_str());
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// adds value to the property if it is not already there. 
HRESULT 
Analysis::addValue(
   IDirectoryObject     *iDirObj,
   const long            locale,
   const String         &object, 
   const String         &property,
   const String         &value)
{
   LOG_FUNCTION(Analysis::addValue);

   HRESULT hr = S_OK;

   do
   {
      hr=isADValuePresent (   
                              iDirObj,
                              property,
                              value
                          );

      BREAK_ON_FAILED_HRESULT(hr);
   
      if (hr == S_FALSE)
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(value);
      }
       
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



// The idea of replaceW2KValue is replacing the W2K value
// for the Whistler. We also make sure we don't extraneous values.
HRESULT 
Analysis::replaceW2KSingleValue
          (
               IDirectoryObject     *iDirObj,
               const int            locale,
               const String         &object, 
               const String         &property,
               const String         &W2KCsvValue,
               const String         &WhistlerCsvValue
          )
{
   LOG_FUNCTION(Analysis::replaceW2KSingleValue);


   HRESULT hr = S_OK;
   do
   {

      hr=isADValuePresent(iDirObj,property,WhistlerCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The Whistler value is already there
      {
         // We will remove any other value than the Whistler
         hr=removeExtraneous
            (
               iDirObj,
               locale,
               object,
               property,
               WhistlerCsvValue
            );
         break;
      }

      // Now we know that the Whistler value is not present
      // and therefore we will add it if the W2K value is present

      hr=isADValuePresent(iDirObj,property,W2KCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The W2K value is there.
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(WhistlerCsvValue);
         act.delValues.push_back(W2KCsvValue);

         // remove all but the W2K that we removed in the previous line
         hr=removeExtraneous
            (
               iDirObj,
               locale,
               object,
               property,
               W2KCsvValue
            );
         break;
      }

      // Now we know that neither Whistler nor W2K values are present
      // If we have a value we will log that it is a custom value

      String ADValue;
      hr=getADFirstValue(iDirObj,property,ADValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // We have a value
      {
         SingleValue tmpCustom(locale,object,property,ADValue);
         results.customizedValues.push_back(tmpCustom);

         // We will remove any other value than the one we found
         hr=removeExtraneous(iDirObj,locale,object,property,ADValue);
         break;
      }
      
      // Now we know that we don't have any values at all.
      ObjectId tempObj(locale,String(object));

      ValueActions &act=results.objectActions[tempObj][property];
      act.addValues.push_back(WhistlerCsvValue);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}


// The idea of replaceW2KValue is replacing the W2K value
// for the Whistler. We also make sure we don't ahve  extraneous values.
HRESULT 
Analysis::replaceW2KMultipleValue
(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const String         &object, 
   const String         &property,
   const String         &W2KCsvValue,
   const String         &WhistlerCsvValue
)
{
   LOG_FUNCTION(Analysis::replaceW2KMultipleValue);

   // First we should get the beginning of the W2K 
   // snd Whistler strings for use in removeExtraneous calls
   size_t pos=W2KCsvValue.find(L',');
   ASSERT(pos != String::npos); // W2KRepl ensures the comma
   String W2KStart=W2KCsvValue.substr(0,pos+1);


   pos=WhistlerCsvValue.find(L',');
   ASSERT(pos != String::npos); // W2KRepl ensures the comma
   String WhistlerStart=WhistlerCsvValue.substr(0,pos+1);


   HRESULT hr = S_OK;
   do
   {
            
      hr=isADValuePresent(iDirObj,property,WhistlerCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The Whistler value is already there
      {
         hr=removeExtraneous(
                              iDirObj,
                              locale,
                              object,
                              property,
                              WhistlerCsvValue,
                              WhistlerStart,
                              W2KStart
                            );
         BREAK_ON_FAILED_HRESULT(hr);

         break;
      }

      // Now we know that the Whistler value is not present
      // and therefore we will add it if the W2K value is present

      hr=isADValuePresent(iDirObj,property,W2KCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The W2K value is there.
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(WhistlerCsvValue);
         act.delValues.push_back(W2KCsvValue);

         // remove all but the W2K that we removed in the previous line
         hr=removeExtraneous(
                              iDirObj,
                              locale,
                              object,
                              property,
                              W2KCsvValue,
                              WhistlerStart,
                              W2KStart
                            );
         break;
      }

      // Now we know that neither Whistler nor W2K values are present
      // If we have a value starting like the W2K we will log that it 
      // is a custom value

        
      String ADValue;

      hr=isADStartValuePresent(iDirObj,property,W2KStart,ADValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr==S_OK) // Something starts like the W2K csv value
      {
         SingleValue tmpCustom(locale,object,property,ADValue);
         results.customizedValues.push_back(tmpCustom);

         // We will keep only the first custom value
         hr=removeExtraneous(
                              iDirObj,
                              locale,
                              object,
                              property,
                              ADValue,
                              WhistlerStart,
                              W2KStart
                            );
         break;
      }
      

      // Now neither Whistler, W2K or W2KStart are present
      if ( WhistlerStart == W2KStart )
      {
         // We have to check the WhistlerStart as well

         hr=isADStartValuePresent(iDirObj,property,WhistlerStart,ADValue);
         BREAK_ON_FAILED_HRESULT(hr);

         if(hr == S_OK) // Something starts like the Whistler csv value
         {
            SingleValue tmpCustom(locale,object,property,ADValue);
            results.customizedValues.push_back(tmpCustom);

            // We will keep only the first custom value
            hr=removeExtraneous(
                                 iDirObj,
                                 locale,
                                 object,
                                 property,
                                 ADValue,
                                 WhistlerStart,
                                 W2KStart
                               );
            break;
         }
      }

      // Now we know that there are no values starting like
      // the Whistler or W2K csv values so we have to add 
      // the Whistler value
      ObjectId tempObj(locale,String(object));

      ValueActions &act=results.objectActions[tempObj][property];
      act.addValues.push_back(WhistlerCsvValue);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}




//called from RwplaceW2KMultipleValue to remove all values
// starting with start1 or start2 other than keeper
HRESULT
Analysis::removeExtraneous
          (
               IDirectoryObject     *iDirObj,
               const int            locale,
               const String         &object, 
               const String         &property,
               const String         &keeper,
               const String         &start1,
               const String         &start2
          )
{
   LOG_FUNCTION(Analysis::removeExtraneous);
   HRESULT hr = S_OK;

   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );
      
      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         if(pAttrInfo==NULL)
         {
            hr = S_FALSE;
            break;
         }

         for (
               DWORD val=0; 
               val < pAttrInfo->dwNumValues;
               val++ 
             )
         {
            ASSERT
            (
               pAttrInfo->pADsValues[val].dwType == 
               ADSTYPE_CASE_IGNORE_STRING
            );
            wchar_t *valueAD = pAttrInfo->pADsValues[val].CaseIgnoreString;

            if (  wcscmp(valueAD,keeper.c_str())!=0 &&
                  (
                     wcsncmp(valueAD,start1.c_str(),start1.size())==0 ||
                     wcsncmp(valueAD,start2.c_str(),start2.size())==0
                  )
               )
            {
               String value=valueAD;
               ObjectId tempObj(locale,String(object));

               ValueActions &act=results.extraneousValues[tempObj][property];
               act.delValues.push_back(value);
            }
         }
      } while(0);

      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// called from RwplaceW2KSingleValue to remove all values
// other than keeper
HRESULT
Analysis::removeExtraneous
          (
               IDirectoryObject    *iDirObj,
               const int           locale,
               const String        &object, 
               const String        &property,
               const String        &keeper
          )
{
   LOG_FUNCTION(Analysis::removeExtraneous);

   HRESULT hr = S_OK;
   
   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         if(pAttrInfo==NULL)
         {
            hr = S_FALSE;
            break;
         }


         for (
               DWORD val=0; 
               val < pAttrInfo->dwNumValues;
               val++
             )
         {
            ASSERT
            (
               pAttrInfo->pADsValues[val].dwType == 
               ADSTYPE_CASE_IGNORE_STRING
            );
            wchar_t *valueAD = pAttrInfo->pADsValues[val].CaseIgnoreString;

            if (  wcscmp(valueAD,keeper.c_str())!=0 )
            {
               String value=valueAD;
               ObjectId tempObj(locale,String(object));

               ValueActions &act=results.extraneousValues[tempObj][property];
               act.delValues.push_back(value);
            }
         }
      } while(0);

      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// called from replaceGUID to remove all values
// starting with the GUID in ordAndGuid1 
// or the GUID in ordAndGuid2 other than keeper
HRESULT
Analysis::removeExtraneousGUID
          (
               IDirectoryObject     *iDirObj,
               const int            locale,
               const String         &object, 
               const String         &property,
               const String         &keeper,
               const String         &ordAndGuid1,
               const String         &ordAndGuid2
          )
{
   LOG_FUNCTION(Analysis::removeExtraneousGUID);
   HRESULT hr = S_OK;

   size_t pos=ordAndGuid1.find(L',');
   ASSERT(pos != String::npos); 
   String guid1=ordAndGuid1.substr(pos+1);

   pos=ordAndGuid2.find(L',');
   ASSERT(pos != String::npos); 
   String guid2=ordAndGuid2.substr(pos+1);

   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );
      
      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         if(pAttrInfo==NULL)
         {
            hr = S_FALSE;
            break;
         }

         for (
               DWORD val=0; 
               val < pAttrInfo->dwNumValues;
               val++ 
             )
         {
            ASSERT
            (
               pAttrInfo->pADsValues[val].dwType == 
               ADSTYPE_CASE_IGNORE_STRING
            );
            wchar_t *valueAD = pAttrInfo->pADsValues[val].CaseIgnoreString;

            if (keeper.icompare(valueAD)!=0)
            {
               String valueStr=valueAD;
               pos=valueStr.find(L',');
               if (pos!=String::npos)
               {
                  String guid=valueStr.substr(pos+1);
                  if(guid1.icompare(guid)==0 || guid2.icompare(guid)==0)
                  {
                     ObjectId tempObj(locale,String(object));

                     ValueActions &act=results.extraneousValues[tempObj][property];
                     act.delValues.push_back(valueStr);
                  }
               }
            }
         }
      } while(0);

      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// if any value exists in the AD with the same guid as guidValue
// it is returned in guidFound, otherwise S_FALSE is returned
HRESULT
Analysis::getADGuid
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               const String         &guidValue,
               String               &guidFound
          )
{
   LOG_FUNCTION(Analysis::getADGuid);
   
   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};

   size_t pos=guidValue.find(L',');
   ASSERT(pos!=String::npos);

   String guid=guidValue.substr(pos+1);

   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         // If there are no values we finish the search
         hr=S_FALSE;

         if(pAttrInfo==NULL)
         {
            break;
         }

         for (
               DWORD val=0; 
               val < pAttrInfo->dwNumValues;
               val++
             )
         {
            ASSERT
            (
               pAttrInfo->pADsValues[val].dwType == 
               ADSTYPE_CASE_IGNORE_STRING
            );
            wchar_t *guidAD=wcschr(pAttrInfo->pADsValues[val].CaseIgnoreString,L',');
            if(guidAD != NULL)
            {
               guidAD++;

               if (guid.icompare(guidAD)==0)
               {
                  guidFound=pAttrInfo->pADsValues[val].CaseIgnoreString;
                  hr=S_OK;
                  break;
               }
            }
         }
      } while(0);

      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// returns S_OK if value is present or S_FALSE otherwise
HRESULT
Analysis::isADValuePresent
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               const String         &value
          )
{
   LOG_FUNCTION(Analysis::isADValuePresent);
   
   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         hr=S_FALSE;

         // If there are no values we finish the search
         if(pAttrInfo==NULL)
         {
            break;
         }


         for (
               DWORD val=0; 
               val < pAttrInfo->dwNumValues;
               val++
             )
         {
            ASSERT
            (
               pAttrInfo->pADsValues[val].dwType == 
               ADSTYPE_CASE_IGNORE_STRING
            );
            wchar_t *valueAD=pAttrInfo->pADsValues[val].CaseIgnoreString;
            if (wcscmp(value.c_str(),valueAD)==0)
            {
               hr=S_OK;
               break; 
            }
         }
      } while(0);
      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// retrieves the first value starting with valueStart 
// from the Active Directory
// If no value is found S_FALSE is returned.
HRESULT
Analysis::isADStartValuePresent
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               const String         &valueStart,
               String               &value
          )
{
   LOG_FUNCTION(Analysis::isADStartValuePresent);
   
   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         value.erase();

         hr = S_FALSE;

         // If there are no values we finish the search
         if(pAttrInfo==NULL)
         {
            break;
         }

         for (
               DWORD val=0; 
               (val < pAttrInfo->dwNumValues);
               val++ 
             )
         {
            ASSERT
            (
               pAttrInfo->pADsValues[val].dwType == 
               ADSTYPE_CASE_IGNORE_STRING
            );
            wchar_t *valueAD=pAttrInfo->pADsValues[val].CaseIgnoreString;
            if (wcsncmp(valueStart.c_str(),valueAD,valueStart.size())==0)
            {
               value=pAttrInfo->pADsValues[val].CaseIgnoreString;
               hr=S_OK;
               break;
            }
         }
      } while(0);

      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);


   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// retrieves the first value 
// from the Active Directory
// If no value is found S_FALSE is returned.
HRESULT
Analysis::getADFirstValue
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               String               &value
          )
{
   LOG_FUNCTION(Analysis::getADFirstValue);
   
   DWORD   dwReturn=0;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // iDirObj->GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      do
      {
         BREAK_ON_FAILED_HRESULT(hr);
         // If there are no values we finish the search
         if(pAttrInfo==NULL)
         {
            hr = S_FALSE;
            break;
         }
         ASSERT(pAttrInfo->pADsValues->dwType==ADSTYPE_CASE_IGNORE_STRING);
      
         value=pAttrInfo->pADsValues->CaseIgnoreString;
      } while(0);
      if (pAttrInfo!=NULL) FreeADsMem(pAttrInfo);

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



// auxiliary in the createReport to 
// enumerate an ObjectIdList
HRESULT 
Analysis::reportObjects
          (
               HANDLE file,
               const ObjectIdList &list,
               const String &header
          )
{
   LOG_FUNCTION(Analysis::reportObjects);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      ObjectIdList::const_iterator begin,end;
      begin=list.begin();
      end=list.end();
      while(begin!=end)
      {

         hr=FS::WriteLine(
                              file,
                              String::format
                              (
                                 IDS_RPT_OBJECT_FORMAT,
                                 begin->object.c_str(),
                                 begin->locale
                              )  
                         );
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}

// auxiliary in the createReport to 
// enumerate a LongList
HRESULT 
Analysis::reportContainers
            (
               HANDLE file,
               const LongList &list,
               const String &header
            )
{
   LOG_FUNCTION(Analysis::reportContainers);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      LongList::const_iterator begin,end;
      begin=list.begin();
      end=list.end();
      while(begin!=end)
      {

         hr=FS::WriteLine(
                              file,
                              String::format
                              (
                                 IDS_RPT_CONTAINER_FORMAT,
                                 *begin
                              )  
                         );
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}

// auxiliary in the createReport to 
// enumerate a SingleValueList
HRESULT 
Analysis::reportValues
            (
               HANDLE file,
               const SingleValueList &list,
               const String &header
            )
{
   LOG_FUNCTION(Analysis::reportValues);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      SingleValueList::const_iterator begin,end;
      begin=list.begin();
      end=list.end();
      while(begin!=end)
      {

         hr=FS::WriteLine(
                              file,
                              String::format
                              (
                                 IDS_RPT_VALUE_FORMAT,
                                 begin->value.c_str(),
                                 begin->locale,
                                 begin->object.c_str(),
                                 begin->property.c_str()
                              )  
                         );
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}


// auxiliary in the createReport to 
// enumerate ObjectActions
HRESULT 
Analysis::reportActions
            (
               HANDLE file,
               const ObjectActions &list,
               const String &header
            )
{
   LOG_FUNCTION(Analysis::reportActions);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      ObjectActions::const_iterator beginObj=list.begin();
      ObjectActions::const_iterator endObj=list.end();

      while(beginObj!=endObj) 
      {

         hr=FS::WriteLine
                (
                     file,
                     String::format
                     (
                        IDS_RPT_OBJECT_FORMAT,
                        beginObj->first.object.c_str(),
                        beginObj->first.locale
                     )  
                 );
         BREAK_ON_FAILED_HRESULT(hr);
         
    
         PropertyActions::iterator beginAct=beginObj->second.begin();
         PropertyActions::iterator endAct=beginObj->second.end();

         while(beginAct!=endAct)
         {

            StringList::iterator 
               beginDel = beginAct->second.delValues.begin();
            StringList::iterator 
               endDel = beginAct->second.delValues.end();
            while(beginDel!=endDel)
            {
               hr=FS::WriteLine
                      (
                           file,
                           String::format
                           (
                              IDS_RPT_DEL_VALUE_FORMAT,
                              beginAct->first.c_str(),
                              beginDel->c_str()
                           )  
                       );
               BREAK_ON_FAILED_HRESULT(hr);

               beginDel++;
            }
            BREAK_ON_FAILED_HRESULT(hr); 


            StringList::iterator 
               beginAdd = beginAct->second.addValues.begin();
            StringList::iterator 
               endAdd = beginAct->second.addValues.end();
            while(beginAdd!=endAdd)
            {
               hr=FS::WriteLine
                      (
                           file,
                           String::format
                           (
                              IDS_RPT_ADD_VALUE_FORMAT,
                              beginAct->first.c_str(),
                              beginAdd->c_str()
                           )  
                       );
               BREAK_ON_FAILED_HRESULT(hr);

               beginAdd++;
            }
            BREAK_ON_FAILED_HRESULT(hr); 

            beginAct++;
         } // while(beginAct!=endAct)
         BREAK_ON_FAILED_HRESULT(hr);

         beginObj++;
      } // while(beginObj!=endObj)
      
      BREAK_ON_FAILED_HRESULT(hr);

   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}


// Create the report from the AnalysisResults
HRESULT
Analysis::createReport(const String& reportName)
{
   LOG_FUNCTION(Analysis::createReport);
   HRESULT hr=S_OK;
   do
   {
      
      HANDLE file;

      hr=FS::CreateFile(reportName,
                        file,
                        GENERIC_WRITE);
   
      if (FAILED(hr))
      {
         error=String::format(IDS_COULD_NOT_CREATE_FILE,reportName.c_str());
         break;
      }


      do
      {
         hr=FS::WriteLine(file,String::load(IDS_RPT_HEADER));
         BREAK_ON_FAILED_HRESULT(hr);


         hr=reportActions (
                              file,
                              results.extraneousValues,
                              String::load(IDS_RPT_EXTRANEOUS)
                          );
         BREAK_ON_FAILED_HRESULT(hr);



         hr=reportValues (
                              file,
                              results.customizedValues,
                              String::load(IDS_RPT_CUSTOMIZED)
                          );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=reportObjects 
            (
               file,
               results.conflictingWhistlerObjects,
               String::load
               (
                  IDS_RPT_CONFLICTING_WITH_NEW_WHISTLER_OBJECTS
               )
            );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=reportActions (
                              file,
                              results.objectActions,
                              String::load(IDS_RPT_ACTIONS)
                          );
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=reportObjects  (
                              file,
                              results.createW2KObjects,
                              String::load(IDS_RPT_CREATEW2K)
                           );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=reportObjects  (
                              file,
                              results.createWhistlerObjects,
                              String::load(IDS_RPT_CREATE_WHISTLER)
                           );
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=reportContainers(
                              file,
                              results.createContainers,
                              String::load(IDS_RPT_CONTAINERS)
                            );
         BREAK_ON_FAILED_HRESULT(hr);

      } while(0);

      CloseHandle(file);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\changes001.cpp ===
// This file is generated by W2KRepl.exe
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios


#include "headers.hxx"
#include "constants.hpp"



void setChanges1()
{
   // the next three changes fix bug #497488
   addChange
   (
      guids[1],
      0x410,
      L"serversContainer-Display",
      L"classDisplayName",
      //Contenitore Server 
      L"\x43\x6f\x6e\x74\x65\x6e\x69\x74\x6f\x72\x65\x20\x53\x65\x72\x76\x65\x72",
      //Contenitore server 
      L"\x43\x6f\x6e\x74\x65\x6e\x69\x74\x6f\x72\x65\x20\x73\x65\x72\x76\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );


   addChange
   (
      guids[1],
      0x413,
      L"group-Display",
      L"classDisplayName",
      //Groep 
      L"\x47\x72\x6f\x65\x70",
      //GROEP 
      L"\x47\x52\x4f\x45\x50",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (
      guids[1],
      0x413,
      L"domainDNS-Display",
      L"classDisplayName",
      //Domein 
      L"\x44\x6f\x6d\x65\x69\x6e",
      //domein 
      L"\x64\x6f\x6d\x65\x69\x6e",
      REPLACE_W2K_SINGLE_VALUE
   );

    // The remaining changes are a fix for bug 517587 and for Korean localization bugs
   // 505060, 505065 and 510733
    addChange
    (
        guids[1],
        0x409,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, International ISDN Number (Others)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x49\x53\x44\x4e\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
        //internationalISDNNumber,International ISDN Number (Others)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x49\x53\x44\x4e\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x401,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, ??? ISDN ?????? (???)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x631\x642\x645\x20\x49\x53\x44\x4e\x20\x627\x644\x62f\x648\x644\x64a\x20\x28\x622\x62e\x631\x29",
        //internationalISDNNumber,??? ISDN ?????? (???)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x49\x53\x44\x4e\x20\x627\x644\x62f\x648\x644\x64a\x20\x28\x622\x62e\x631\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x405,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Mezinrodn cslo ISDN (ostatn)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
        //internationalISDNNumber,Mezinrodn cslo ISDN (ostatn)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x408,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, ??e???? a????? ISDN (?????)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
        //internationalISDNNumber,??e???? a????? ISDN (?????)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x40c,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Numro RNIS international (Autres)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4e\x75\x6d\xe9\x72\x6f\x20\x52\x4e\x49\x53\x20\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x28\x41\x75\x74\x72\x65\x73\x29",
        //internationalISDNNumber,Numro RNIS international (Autres)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\xe9\x72\x6f\x20\x52\x4e\x49\x53\x20\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x28\x41\x75\x74\x72\x65\x73\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x40d,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, ???? ISDN ???????? (?????)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
        //internationalISDNNumber,???? ISDN ???????? (?????)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x40e,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Nemzetkzi ISDN-szm (egyb)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4e\x65\x6d\x7a\x65\x74\x6b\xf6\x7a\x69\x20\x49\x53\x44\x4e\x2d\x73\x7a\xe1\x6d\x20\x28\x65\x67\x79\xe9\x62\x29",
        //internationalISDNNumber,Nemzetkzi ISDN-szm (egyb)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x65\x6d\x7a\x65\x74\x6b\xf6\x7a\x69\x20\x49\x53\x44\x4e\x2d\x73\x7a\xe1\x6d\x20\x28\x65\x67\x79\xe9\x62\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x410,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Numero ISDN internazionale (altri)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65\x20\x28\x61\x6c\x74\x72\x69\x29",
        //internationalISDNNumber,Numero ISDN internazionale (altri)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65\x20\x28\x61\x6c\x74\x72\x69\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x411,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, ?? ISDN ?? (???)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x56fd\x969b\x20\x49\x53\x44\x4e\x20\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
        //internationalISDNNumber,?? ISDN ?? (???)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x56fd\x969b\x20\x49\x53\x44\x4e\x20\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"user-Display",
        L"attributeDisplayNames",
        //givenName,??
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
        //givenName,??(? ??)
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"user-Display",
        L"attributeDisplayNames",
        //initials,???
        L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\xc774\xb2c8\xc15c",
        //initials,???(?? ??)
        L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\xc774\xb2c8\xc15c\x28\xc911\xac04\x20\xc774\xb984\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"user-Display",
        L"attributeDisplayNames",
        //personalTitle,??
        L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
        //personalTitle,??
        L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"user-Display",
        L"attributeDisplayNames",
        //userWorkstations,?????? ???
        L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158\x20\xb85c\xadf8\xc628",
        //userWorkstations,??? ??????
        L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xb85c\xadf8\xc628\x20\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"group-Display",
        L"attributeDisplayNames",
        //managedBy,?? ???
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xc7a5\xce58\x20\xad00\xb9ac\xc790",
        //managedBy,??
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xad00\xb9ac",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"contact-Display",
        L"attributeDisplayNames",
        //givenName,??
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
        //givenName,??(? ??)
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"contact-Display",
        L"attributeDisplayNames",
        //initials,???
        L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\xc774\xb2c8\xc15c",
        //initials,???(?? ??)
        L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\xc774\xb2c8\xc15c\x28\xc911\xac04\x20\xc774\xb984\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"contact-Display",
        L"attributeDisplayNames",
        //personalTitle,??
        L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
        //personalTitle,??
        L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"computer-Display",
        L"attributeDisplayNames",
        //managedBy,?? ???
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xc7a5\xce58\x20\xad00\xb9ac\xc790",
        //managedBy,??
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xad00\xb9ac",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"organizationalUnit-Display",
        L"attributeDisplayNames",
        //managedBy,?? ???
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xc7a5\xce58\x20\xad00\xb9ac\xc790",
        //managedBy,??
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xad00\xb9ac",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"volume-Display",
        L"attributeDisplayNames",
        //managedBy,?? ???
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xc7a5\xce58\x20\xad00\xb9ac\xc790",
        //managedBy,??
        L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\xad00\xb9ac",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"default-Display",
        L"extraColumns",
        //givenName,??,0,100,0
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x2c\x30\x2c\x31\x30\x30\x2c\x30",
        //givenName,??(? ??),0,100,0
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29\x2c\x30\x2c\x31\x30\x30\x2c\x30",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"default-Display",
        L"extraColumns",
        //st,State,0,100,0
        L"\x73\x74\x2c\x53\x74\x61\x74\x65\x2c\x30\x2c\x31\x30\x30\x2c\x30",
        //st,?/?,0,100,0
        L"\x73\x74\x2c\xc2dc\x2f\xb3c4\x2c\x30\x2c\x31\x30\x30\x2c\x30",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"lostAndFound-Display",
        L"extraColumns",
        //lastKnownParent,??? ??? ??,1,300,0
        L"\x6c\x61\x73\x74\x4b\x6e\x6f\x77\x6e\x50\x61\x72\x65\x6e\x74\x2c\xb9c8\xc9c0\xb9c9\x20\xc54c\xb824\xc9c4\x20\xbd80\xbaa8\x2c\x31\x2c\x33\x30\x30\x2c\x30",
        //lastKnownParent,????? ??? ??,1,300,0
        L"\x6c\x61\x73\x74\x4b\x6e\x6f\x77\x6e\x50\x61\x72\x65\x6e\x74\x2c\xb9c8\xc9c0\xb9c9\xc73c\xb85c\x20\xc54c\xb824\xc9c4\x20\xbd80\xbaa8\x2c\x31\x2c\x33\x30\x30\x2c\x30",
        REPLACE_W2K_SINGLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //givenName,??
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
        //givenName,??(? ??)
        L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //initials,???
        L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\xc774\xb2c8\xc15c",
        //initials,???(?? ??)
        L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\xc774\xb2c8\xc15c\x28\xc911\xac04\x20\xc774\xb984\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //personalTitle,??
        L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
        //personalTitle,??
        L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x412,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //userWorkstations,?????? ???
        L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158\x20\xb85c\xadf8\xc628",
        //userWorkstations,??? ??????
        L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xb85c\xadf8\xc628\x20\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x413,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Internationaal ISDN-nummer (overige)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
        //internationalISDNNumber,Internationaal ISDN-nummer (overige)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x414,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Internasjonalt ISDN-nummber (andre)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x49\x6e\x74\x65\x72\x6e\x61\x73\x6a\x6f\x6e\x61\x6c\x74\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x62\x65\x72\x20\x28\x61\x6e\x64\x72\x65\x29",
        //internationalISDNNumber,Internasjonalt ISDN-nummer (andre)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x73\x6a\x6f\x6e\x61\x6c\x74\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x61\x6e\x64\x72\x65\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x415,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Miedzynarodowy numer sieciowy ISDN (inne)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4d\x69\x119\x64\x7a\x79\x6e\x61\x72\x6f\x64\x6f\x77\x79\x20\x6e\x75\x6d\x65\x72\x20\x73\x69\x65\x63\x69\x6f\x77\x79\x20\x49\x53\x44\x4e\x20\x28\x69\x6e\x6e\x65\x29",
        //internationalISDNNumber,Miedzynarodowy numer sieciowy ISDN (inne)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x69\x119\x64\x7a\x79\x6e\x61\x72\x6f\x64\x6f\x77\x79\x20\x6e\x75\x6d\x65\x72\x20\x73\x69\x65\x63\x69\x6f\x77\x79\x20\x49\x53\x44\x4e\x20\x28\x69\x6e\x6e\x65\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x416,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Nmero ISDN internacional (outros)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4e\xfa\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x63\x69\x6f\x6e\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
        //internationalISDNNumber,Nmero ISDN internacional (outros)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x63\x69\x6f\x6e\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x419,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, ????????????? ????? ISDN (??????)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x41c\x435\x436\x434\x443\x43d\x430\x440\x43e\x434\x43d\x44b\x439\x20\x43d\x43e\x43c\x435\x440\x20\x49\x53\x44\x4e\x20\x28\x43f\x440\x43e\x447\x438\x435\x29",
        //internationalISDNNumber,????????????? ????? ISDN (??????)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x41c\x435\x436\x434\x443\x43d\x430\x440\x43e\x434\x43d\x44b\x439\x20\x43d\x43e\x43c\x435\x440\x20\x49\x53\x44\x4e\x20\x28\x43f\x440\x43e\x447\x438\x435\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x804,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, ?? ISDN ??(??)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x56fd\x9645\x20\x49\x53\x44\x4e\x20\x53f7\x7801\x28\x5176\x5b83\x29",
        //internationalISDNNumber,?? ISDN ??(??)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x56fd\x9645\x20\x49\x53\x44\x4e\x20\x53f7\x7801\x28\x5176\x5b83\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );


    addChange
    (
        guids[1],
        0x816,
        L"inetOrgPerson-Display",
        L"attributeDisplayNames",
        //internationalISDNNumber, Nmero RDIS internacional (outros)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x4e\xfa\x6d\x65\x72\x6f\x20\x52\x44\x49\x53\x20\x69\x6e\x74\x65\x72\x6e\x61\x63\x69\x6f\x6e\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
        //internationalISDNNumber,Nmero RDIS internacional (outros)
        L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x52\x44\x49\x53\x20\x69\x6e\x74\x65\x72\x6e\x61\x63\x69\x6f\x6e\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
        REPLACE_W2K_MULTIPLE_VALUE
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\changes000.cpp ===
// This file is generated by W2KRepl.exe
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#include "headers.hxx"
#include "constants.hpp"


void setChanges0()
{
   // new objects
   addChange
   (  guids[0],
      -1,
      L"msMQ-Custom-Recipient-Display",
      L"",
      L"",
      L"",
      ADD_OBJECT
   );
   
   addChange
   (  guids[0],
      -1,
      L"msMQ-Group-Display",
      L"",
      L"",
      L"",
      ADD_OBJECT
   );

   addChange
   (  guids[0],
      -1,
      L"msCOM-PartitionSet-Display",
      L"",
      L"",
      L"",
      ADD_OBJECT
   );
   addChange
   (  guids[0],
      -1,
      L"msCOM-Partition-Display",
      L"",
      L"",
      L"",
      ADD_OBJECT
   );

   addChange
   (  guids[0],
      -1,
      L"lostAndFound-Display",
      L"",
      L"",
      L"",
      ADD_OBJECT
   );

   addChange
   (  guids[0],
      -1,
      L"inetOrgPerson-Display",
      L"",
      L"",
      L"",
      ADD_OBJECT
   );
   // end of New Objects

   addChange
   (  guids[0],
      -1,
      L"DS-UI-Default-Settings",
      L"msDS-FilterContainers",
      L"",
      L"",
      ADD_ALL_CSV_VALUES
   );

   addChange
   (  guids[0],
      -1,
      L"DS-UI-Default-Settings",
      L"msDS-Non-Security-Group-Extra-Classes",
      L"",
      L"",
      ADD_ALL_CSV_VALUES
   );

   addChange
   (  guids[0],
      -1,
      L"DS-UI-Default-Settings",
      L"dSUIAdminNotification",
      L"2,{a00e1768-4a9b-4d97-afc6-99d329f605f2}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"computer-Display",
      L"adminPropertyPages",
      L"7,{B52C1E50-1DD2-11D1-BC43-00C04FC31FD3}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"organizationalUnit-Display",
      L"adminPropertyPages",
      L"6,{FA3E1D55-16DF-446d-872E-BD04D4F39C93}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"container-Display",
      L"adminContextMenu",
      L"3,{EEBD2F15-87EE-4F93-856F-6AD7E31787B3}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"container-Display",
      L"adminContextMenu",
      L"4,{AB790AA1-CDC1-478a-9351-B2E05CFCAD09}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"adminPropertyPages",
      L"1,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"1,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"adminPropertyPages",
      L"3,{4e40f770-369c-11d0-8922-00a024ab2dbb}",
      L"",
      REMOVE_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"shellPropertyPages",
      L"1,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"1,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );


   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"contextMenu",
      L"0,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"0,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );   

   

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"adminContextMenu",
      L"0,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"0,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );   

   addChange
   (  guids[0],
      -1,
      L"default-Display",
      L"adminMultiselectPropertyPages",
      L"1,{50d30563-9911-11d1-b9af-00c04fd8d5b0}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"default-Display",
      L"extraColumns",
      L"",
      L"",
      ADD_ALL_CSV_VALUES
   );

   addChange
   (  guids[0],
      -1,
      L"user-Display",
      L"adminMultiselectPropertyPages",
      L"1,{50d30564-9911-11d1-b9af-00c04fd8d5b0}",
      L"",
      ADD_GUID
   );  
   
   addChange
   (  guids[0],
      -1,
      L"user-Display",
      L"adminPropertyPages",
      L"9,{FA3E1D55-16DF-446d-872E-BD04D4F39C93}", 
      L"",
      ADD_GUID
   );


   ////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////
   //                                                    //
   //            LOCALE DEPENDENT CHANGES BELLOW         //
   //                                                    //
   ////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x62a\x639\x644\x64a\x642",
      //comment,??????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x627\x644\x62a\x639\x644\x64a\x642",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //directReports,????????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x645\x631\x624\x648\x633\x648\x646",
      //directReports,???????? ???????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x62a\x642\x627\x631\x64a\x631\x20\x627\x644\x645\x628\x627\x634\x631\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,????? ???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x64a\x629\x20\x627\x644\x645\x62c\x645\x648\x639\x629",
      //memberOf,??? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x20\x641\x64a",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,??? ?????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633",
      //primaryTelexNumber,??? ??????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //sn,????? ?????? 
      L"\x73\x6e\x2c\x627\x644\x627\x633\x645\x20\x627\x644\x623\x62e\x64a\x631",
      //sn,??? ??????? 
      L"\x73\x6e\x2c\x627\x633\x645\x20\x627\x644\x639\x627\x626\x644\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633\x20\x28\x622\x62e\x631\x29",
      //telexNumber,??? ??????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633\x20\x28\x622\x62e\x631\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"group-Display",
      L"classDisplayName",
      //???????? 
      L"\x627\x644\x645\x62c\x645\x648\x639\x629",
      //?????? 
      L"\x645\x62c\x645\x648\x639\x629",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,????? 
      L"\x63\x6e\x2c\x627\x644\x627\x633\x645",
      //dc,????? 
      L"\x64\x63\x2c\x627\x644\x627\x633\x645",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x62a\x639\x644\x64a\x642",
      //comment,??????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x627\x644\x62a\x639\x644\x64a\x642",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //directReports,????????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x645\x631\x624\x648\x633\x648\x646",
      //directReports,???????? ???????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x62a\x642\x627\x631\x64a\x631\x20\x627\x644\x645\x628\x627\x634\x631\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,????? ???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x64a\x629\x20\x627\x644\x645\x62c\x645\x648\x639\x629",
      //memberOf,??? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x20\x641\x64a",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,??? ?????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633",
      //primaryTelexNumber,??? ??????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //sn,????? ?????? 
      L"\x73\x6e\x2c\x627\x644\x627\x633\x645\x20\x627\x644\x623\x62e\x64a\x631",
      //sn,??? ??????? 
      L"\x73\x6e\x2c\x627\x633\x645\x20\x627\x644\x639\x627\x626\x644\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633\x20\x28\x622\x62e\x631\x29",
      //telexNumber,??? ??????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633\x20\x28\x622\x62e\x631\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"classDisplayName",
      //??? ??????? 
      L"\x62c\x647\x629\x20\x627\x644\x627\x62a\x635\x627\x644",
      //????? 
      L"\x627\x62a\x635\x627\x644",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //contactName,??? ??????? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x62c\x647\x629\x20\x627\x644\x627\x62a\x635\x627\x644",
      //contactName,????? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x627\x62a\x635\x627\x644",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //description,????? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x62a\x639\x644\x64a\x642",
      //description,??????? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x627\x644\x62a\x639\x644\x64a\x642",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"nTDSSettings-Display",
      L"classDisplayName",
      //????????? 
      L"\x627\x644\x625\x639\x62f\x627\x62f\x627\x62a",
      //??????? 
      L"\x625\x639\x62f\x627\x62f\x627\x62a",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,?&????...,RsAdmin.msc 
      L"\x30\x2c\x625\x26\x62f\x627\x631\x629\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&?????...,RsAdmin.msc 
      L"\x30\x2c\x26\x625\x62f\x627\x631\x629\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //????? ???????? ??? ??????? 
      L"\x62d\x627\x648\x64a\x629\x20\x627\x644\x646\x642\x644\x64a\x627\x62a\x20\x628\x64a\x646\x20\x627\x644\x645\x648\x627\x642\x639",
      //????? ????? ??? ??????? 
      L"\x62d\x627\x648\x64a\x629\x20\x627\x644\x646\x642\x644\x20\x628\x64a\x646\x20\x627\x644\x645\x648\x627\x642\x639",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5099\x8a3b",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x8a3b\x89e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ?????? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x53ef\x8fa8\x5225\x7684\x540d\x7a31",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x5225\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7fa4\x7d44\x7d44\x54e1\x8cc7\x683c",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x96b8\x5c6c\x65bc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5165\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4e4b\x524d\x7248\x672c\x29",
      //samAccountName,???? (Windows 2000 ??) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5165\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x524d\x7248\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ?????? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x53ef\x8fa8\x5225\x7684\x540d\x7a31",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x5225\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //member,?? 
      L"\x6d\x65\x6d\x62\x65\x72\x2c\x7d44\x54e1",
      //member,?? 
      L"\x6d\x65\x6d\x62\x65\x72\x2c\x6210\x54e1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7fa4\x7d44\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4e4b\x524d\x7248\x672c\x29",
      //samAccountName,???? (Windows 2000 ??) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7fa4\x7d44\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x524d\x7248\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x540d\x7a31",
      //dc,?? 
      L"\x64\x63\x2c\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5099\x8a3b",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x8a3b\x89e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ?????? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x53ef\x8fa8\x5225\x7684\x540d\x7a31",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x5225\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7fa4\x7d44\x7d44\x54e1\x8cc7\x683c",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x96b8\x5c6c\x65bc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"classDisplayName",
      //??? 
      L"\x806f\x7d61\x4eba",
      //??? 
      L"\x9023\x7d61\x4eba",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"computer-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x96fb\x8166\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4e4b\x524d\x7248\x672c\x29",
      //samAccountName,???? (Windows 2000 ??) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x96fb\x8166\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x524d\x7248\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x806f\x7d61\x4eba",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x9023\x7d61\x4eba",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x5099\x8a3b",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8a3b\x89e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaReady,???? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x53ef\x7528\x7d19\x5f35",
      //printMediaReady,????? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x53ef\x4f7f\x7528\x7d19\x5f35",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMemory,?????? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x5b89\x88dd\x7684\x8a18\x61b6\x9ad4",
      //printMemory,??????? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x5df2\x5b89\x88dd\x7684\x8a18\x61b6\x9ad4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printOwner,????? 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x64c1\x6709\x4eba\x540d\x7a31",
      //printOwner,????? 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x64c1\x6709\x8005\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"nTDSSettings-Display",
      L"classDisplayName",
      //?? 
      L"\x8a2d\x5b9a",
      //??? 
      L"\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"nTFRSSettings-Display",
      L"classDisplayName",
      //FRS ?? 
      L"\x46\x52\x53\x20\x8a2d\x5b9a",
      //FRS ??? 
      L"\x46\x52\x53\x20\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"licensingSiteSettings-Display",
      L"classDisplayName",
      //?????? 
      L"\x6388\x6b0a\x7db2\x7ad9\x8a2d\x5b9a",
      //??????? 
      L"\x6388\x6b0a\x7db2\x7ad9\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"nTDSSiteSettings-Display",
      L"classDisplayName",
      //???? 
      L"\x7ad9\x53f0\x8a2d\x5b9a",
      //????? 
      L"\x7ad9\x53f0\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"organizationalUnit-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"container-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"rpcContainer-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"trustedDomain-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"volume-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"mSMQSettings-Display",
      L"classDisplayName",
      //MSMQ ?? 
      L"\x4d\x53\x4d\x51\x20\x8a2d\x5b9a",
      //MSMQ ??? 
      L"\x4d\x53\x4d\x51\x20\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"default-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"foreignSecurityPrincipal-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"pKICertificateTemplate-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //c,Zkratka sttu 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x73\x74\xe1\x74\x75",
      //c,Zkratka zeme 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x7a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //co,Stt 
      L"\x63\x6f\x2c\x53\x74\xe1\x74",
      //co,Zeme 
      L"\x63\x6f\x2c\x5a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,Jmno podle protokol X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f\x20\x70\x6f\x64\x6c\x65\x20\x70\x72\x6f\x74\x6f\x6b\x6f\x6c\x20\x58\x35\x30\x30",
      //distinguishedName,Rozliujc nzev X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x52\x6f\x7a\x6c\x69\x161\x75\x6a\xed\x63\xed\x20\x6e\xe1\x7a\x65\x76\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //division,Divize 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x7a\x65",
      //division,Oddelen 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x4f\x64\x64\x11b\x6c\x65\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,ID zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x44\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      //employeeID,Identifikacn cslo zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x6b\x61\x10d\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,Generacn prpona 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x10d\x6e\xed\x20\x70\x159\xed\x70\x6f\x6e\x61",
      //generationQualifier,Prpona za jmnem 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x50\x159\xed\x70\x6f\x6e\x61\x20\x7a\x61\x20\x6a\x6d\xe9\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //givenName,Krestn jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4b\x159\x65\x73\x74\x6e\xed\x20\x6a\x6d\xe9\x6e\x6f",
      //givenName,Jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //homePhone,Telefonn cslo domu 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f",
      //homePhone,Telefon (domu) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x28\x64\x6f\x6d\x16f\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //initials,Inicily 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79",
      //initials,Inicily dalch jmen 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79\x20\x64\x61\x6c\x161\xed\x63\x68\x20\x6a\x6d\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Mezinrodn cslo ISDN (dal csla) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //internationalISDNNumber,Mezinrodn cslo ISDN (ostatn) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,Elektronick adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61",
      //mail,E-mailov adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Clenstv ve skupinch 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x10c\x6c\x65\x6e\x73\x74\x76\xed\x20\x76\x65\x20\x73\x6b\x75\x70\x69\x6e\xe1\x63\x68",
      //memberOf,Je clenem 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\x65\x20\x10d\x6c\x65\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,Cslo mobilnho telefonu 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75",
      //mobile,Mobiln telefon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Cslo faxu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x66\x61\x78\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherFacsimileTelephoneNumber,Faxov cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6f\x76\xe9\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefonn cslo domu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherHomePhone,Telefon domu (ostatn) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x64\x6f\x6d\x16f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefonn cslo IP (dal csla) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherIpPhone,Telefonn cslo IP (ostatn) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,Elektronick adresa (dal adresy) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //otherMailbox,E-mailov adresa (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,Cslo mobilnho telefonu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherMobile,Mobiln telefon (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,Cslo opertoru (dal csla) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherPager,Cslo opertoru (ostatn) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefonn cslo (dal csla) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherTelephone,Telefonn cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,Funkce 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      //personalTitle,Nzev 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Umsten kancelre 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x6b\x61\x6e\x63\x65\x6c\xe1\x159\x65",
      //physicalDeliveryOfficeName,Umsten pracovite 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x70\x72\x61\x63\x6f\x76\x69\x161\x74\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //postalCode,Potovn smerovac cslo 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x73\x6d\x11b\x72\x6f\x76\x61\x63\xed\x20\x10d\xed\x73\x6c\x6f",
      //postalCode,PSC 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x53\x10c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //postOfficeBox,PO Box 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x4f\x20\x42\x6f\x78",
      //postOfficeBox,Potovn prihrdka 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x70\x159\x69\x68\x72\xe1\x64\x6b\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,Cslo dlnopisu 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75",
      //primaryTelexNumber,Dlnopis 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Prihlaovac jmno (pred Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x50\x159\x69\x68\x6c\x61\x161\x6f\x76\x61\x63\xed\x20\x6a\x6d\xe9\x6e\x6f\x20\x28\x70\x159\x65\x64\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Prihlaovac jmno (pro systmy star ne Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x50\x159\x69\x68\x6c\x61\x161\x6f\x76\x61\x63\xed\x20\x6a\x6d\xe9\x6e\x6f\x20\x28\x70\x72\x6f\x20\x73\x79\x73\x74\xe9\x6d\x79\x20\x73\x74\x61\x72\x161\xed\x20\x6e\x65\x17e\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //streetAddress,Ulice 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x55\x6c\x69\x63\x65",
      //streetAddress,Adresa 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,Cslo dlnopisu (dal csla) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //telexNumber,Dlnopis (ostatn) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //title,Nzev funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x66\x75\x6e\x6b\x63\x65",
      //title,Funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW (dal adresy) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //url,Webov adresa (ostatn) 
      L"\x75\x72\x6c\x2c\x57\x65\x62\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //displayName,Zobrazovan jmno 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xe9\x20\x6a\x6d\xe9\x6e\x6f",
      //displayName,Zobrazovan nzev 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xfd\x20\x6e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresa strnky v sti WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //wWWHomePage,Adresa strnky WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //c,Zkratka sttu 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x73\x74\xe1\x74\x75",
      //c,Zkratka zeme 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x7a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,Jmno podle protokol X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f\x20\x70\x6f\x64\x6c\x65\x20\x70\x72\x6f\x74\x6f\x6b\x6f\x6c\x20\x58\x35\x30\x30",
      //distinguishedName,Rozliujc nzev X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x52\x6f\x7a\x6c\x69\x161\x75\x6a\xed\x63\xed\x20\x6e\xe1\x7a\x65\x76\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Umsten kancelre 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x6b\x61\x6e\x63\x65\x6c\xe1\x159\x65",
      //physicalDeliveryOfficeName,Umsten pracovite 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x70\x72\x61\x63\x6f\x76\x69\x161\x74\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Nzev skupiny (pred Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x73\x6b\x75\x70\x69\x6e\x79\x20\x28\x70\x159\x65\x64\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nzev skupiny (pro systmy star ne Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x73\x6b\x75\x70\x69\x6e\x79\x20\x28\x70\x72\x6f\x20\x73\x79\x73\x74\xe9\x6d\x79\x20\x73\x74\x61\x72\x161\xed\x20\x6e\x65\x17e\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW (dal adresy) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //url,Webov adresa (ostatn) 
      L"\x75\x72\x6c\x2c\x57\x65\x62\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresa strnky v sti WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //wWWHomePage,Adresa strnky WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Jmno 
      L"\x63\x6e\x2c\x4a\x6d\xe9\x6e\x6f",
      //dc,Jmno 
      L"\x64\x63\x2c\x4a\x6d\xe9\x6e\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,Zkratka sttu 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x73\x74\xe1\x74\x75",
      //c,Zkratka zeme 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x7a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //co,Stt 
      L"\x63\x6f\x2c\x53\x74\xe1\x74",
      //co,Zeme 
      L"\x63\x6f\x2c\x5a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //displayName,Zobrazovan jmno 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xe9\x20\x6a\x6d\xe9\x6e\x6f",
      //displayName,Zobrazovan nzev 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xfd\x20\x6e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,Jmno podle protokol X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f\x20\x70\x6f\x64\x6c\x65\x20\x70\x72\x6f\x74\x6f\x6b\x6f\x6c\x20\x58\x35\x30\x30",
      //distinguishedName,Rozliujc nzev X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x52\x6f\x7a\x6c\x69\x161\x75\x6a\xed\x63\xed\x20\x6e\xe1\x7a\x65\x76\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,Divize 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x7a\x65",
      //division,Oddelen 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x4f\x64\x64\x11b\x6c\x65\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,ID zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x44\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      //employeeID,Identifikacn cslo zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x6b\x61\x10d\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,Generacn prpona 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x10d\x6e\xed\x20\x70\x159\xed\x70\x6f\x6e\x61",
      //generationQualifier,Prpona za jmnem 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x50\x159\xed\x70\x6f\x6e\x61\x20\x7a\x61\x20\x6a\x6d\xe9\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //givenName,Krestn jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4b\x159\x65\x73\x74\x6e\xed\x20\x6a\x6d\xe9\x6e\x6f",
      //givenName,Jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePhone,Telefonn cslo domu 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f",
      //homePhone,Telefon (domu) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x28\x64\x6f\x6d\x16f\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //initials,Inicily 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79",
      //initials,Inicily dalch jmen 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79\x20\x64\x61\x6c\x161\xed\x63\x68\x20\x6a\x6d\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Mezinrodn cslo ISDN (dal csla) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //internationalISDNNumber,Mezinrodn cslo ISDN (ostatn) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,Elektronick adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61",
      //mail,E-mailov adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Clenstv ve skupinch 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x10c\x6c\x65\x6e\x73\x74\x76\xed\x20\x76\x65\x20\x73\x6b\x75\x70\x69\x6e\xe1\x63\x68",
      //memberOf,Je clenem 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\x65\x20\x10d\x6c\x65\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,Cslo mobilnho telefonu 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75",
      //mobile,Mobiln telefon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Cslo faxu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x66\x61\x78\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherFacsimileTelephoneNumber,Faxov cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6f\x76\xe9\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefonn cslo domu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherHomePhone,Telefon domu (ostatn) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x64\x6f\x6d\x16f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefonn cslo IP (dal csla) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherIpPhone,Telefonn cslo IP (ostatn) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,Elektronick adresa (dal adresy) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //otherMailbox,E-mailov adresa (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,Cslo mobilnho telefonu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherMobile,Mobiln telefon (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,Cslo opertoru (dal csla) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherPager,Cslo opertoru (ostatn) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefonn cslo (dal csla) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherTelephone,Telefonn cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,Funkce 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      //personalTitle,Nzev 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Umsten kancelre 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x6b\x61\x6e\x63\x65\x6c\xe1\x159\x65",
      //physicalDeliveryOfficeName,Umsten pracovite 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x70\x72\x61\x63\x6f\x76\x69\x161\x74\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //postalCode,Potovn smerovac cslo 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x73\x6d\x11b\x72\x6f\x76\x61\x63\xed\x20\x10d\xed\x73\x6c\x6f",
      //postalCode,PSC 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x53\x10c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //postOfficeBox,PO Box 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x4f\x20\x42\x6f\x78",
      //postOfficeBox,Potovn prihrdka 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x70\x159\x69\x68\x72\xe1\x64\x6b\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,Cslo dlnopisu 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75",
      //primaryTelexNumber,Dlnopis 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //streetAddress,Ulice 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x55\x6c\x69\x63\x65",
      //streetAddress,Adresa 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,Cslo dlnopisu (dal csla) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //telexNumber,Dlnopis (ostatn) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,Nzev funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x66\x75\x6e\x6b\x63\x65",
      //title,Funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW (dal adresy) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //url,Webov adresa (ostatn) 
      L"\x75\x72\x6c\x2c\x57\x65\x62\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresa strnky v sti WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //wWWHomePage,Adresa strnky WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Nzev poctace (pred Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x70\x6f\x10d\xed\x74\x61\x10d\x65\x20\x28\x70\x159\x65\x64\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nzev poctace (pro systmy star ne Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x70\x6f\x10d\xed\x74\x61\x10d\x65\x20\x28\x70\x72\x6f\x20\x73\x79\x73\x74\xe9\x6d\x79\x20\x73\x74\x61\x72\x161\xed\x20\x6e\x65\x17e\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //uNCName,Nzev ste 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x73\xed\x74\x11b",
      //uNCName,Stov nzev 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x53\xed\x165\x6f\x76\xfd\x20\x6e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Inventrn cslo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x76\x65\x6e\x74\xe1\x72\x6e\xed\x20\x10d\xed\x73\x6c\x6f",
      //assetNumber,Evidencn cslo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x45\x76\x69\x64\x65\x6e\x10d\x6e\xed\x20\x10d\xed\x73\x6c\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printCollate,Podpora kompletovn kopi 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x6b\x6f\x6d\x70\x6c\x65\x74\x6f\x76\xe1\x6e\xed\x20\x6b\x6f\x70\x69\xed",
      //printCollate,Podporuje skldn 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x73\x6b\x6c\xe1\x64\xe1\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printColor,Podpora barevnho tisku 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x62\x61\x72\x65\x76\x6e\xe9\x68\x6f\x20\x74\x69\x73\x6b\x75",
      //printColor,Podporuje barevn tisk 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x62\x61\x72\x65\x76\x6e\xfd\x20\x74\x69\x73\x6b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Podpora oboustrannho tisku 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x6f\x62\x6f\x75\x73\x74\x72\x61\x6e\x6e\xe9\x68\x6f\x20\x74\x69\x73\x6b\x75",
      //printDuplexSupported,Podporuje oboustrann tisk 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x6f\x62\x6f\x75\x73\x74\x72\x61\x6e\x6e\xfd\x20\x74\x69\x73\x6b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMemory,Nainstalovan pamet 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x4e\x61\x69\x6e\x73\x74\x61\x6c\x6f\x76\x61\x6e\xe1\x20\x70\x61\x6d\x11b\x165",
      //printMemory,Instalovan pamet 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x49\x6e\x73\x74\x61\x6c\x6f\x76\x61\x6e\xe1\x20\x70\x61\x6d\x11b\x165",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printPagesPerMinute,Strany za minutu 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x53\x74\x72\x61\x6e\x79\x20\x7a\x61\x20\x6d\x69\x6e\x75\x74\x75",
      //printPagesPerMinute,Strnky za minutu 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x53\x74\x72\xe1\x6e\x6b\x79\x20\x7a\x61\x20\x6d\x69\x6e\x75\x74\x75",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printStaplingSupported,Podpora sevn 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x73\x65\x161\xed\x76\xe1\x6e\xed",
      //printStaplingSupported,Podporuje sevn 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x73\x65\x161\xed\x76\xe1\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //url,Adresa strnky WWW 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"siteLink-Display",
      L"classDisplayName",
      //Propojen ste 
      L"\x50\x72\x6f\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\x11b",
      //Spojen st 
      L"\x53\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\xed",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //Most pro propojen ste 
      L"\x4d\x6f\x73\x74\x20\x70\x72\x6f\x20\x70\x72\x6f\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\x11b",
      //Most spojen st 
      L"\x4d\x6f\x73\x74\x20\x73\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\xed",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"nTFRSSubscriber-Display",
      L"classDisplayName",
      //Odberatel sluby FRS 
      L"\x4f\x64\x62\x11b\x72\x61\x74\x65\x6c\x20\x73\x6c\x75\x17e\x62\x79\x20\x46\x52\x53",
      //castnk sluby FRS 
      L"\xda\x10d\x61\x73\x74\x6e\xed\x6b\x20\x73\x6c\x75\x17e\x62\x79\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //Organizacn tvar 
      L"\x4f\x72\x67\x61\x6e\x69\x7a\x61\x10d\x6e\xed\x20\xfa\x74\x76\x61\x72",
      //Organizacn jednotka 
      L"\x4f\x72\x67\x61\x6e\x69\x7a\x61\x10d\x6e\xed\x20\x6a\x65\x64\x6e\x6f\x74\x6b\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"rpcContainer-Display",
      L"classDisplayName",
      //Sluba RPC 
      L"\x53\x6c\x75\x17e\x62\x61\x20\x52\x50\x43",
      //Sluby RPC 
      L"\x53\x6c\x75\x17e\x62\x79\x20\x52\x50\x43",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQConfiguration-Display",
      L"classDisplayName",
      //Konfigurace fronty MSMQ 
      L"\x4b\x6f\x6e\x66\x69\x67\x75\x72\x61\x63\x65\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Konfigurace MSMQ 
      L"\x4b\x6f\x6e\x66\x69\x67\x75\x72\x61\x63\x65\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //Rozlehl st fronty MSMQ 
      L"\x52\x6f\x7a\x6c\x65\x68\x6c\xe1\x20\x73\xed\x165\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Rozlehl st MSMQ 
      L"\x52\x6f\x7a\x6c\x65\x68\x6c\xe1\x20\x73\xed\x165\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //Inovovan uivatel fronty MSMQ 
      L"\x49\x6e\x6f\x76\x6f\x76\x61\x6e\xfd\x20\x75\x17e\x69\x76\x61\x74\x65\x6c\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Aktualizovan uivatel MSMQ 
      L"\x41\x6b\x74\x75\x61\x6c\x69\x7a\x6f\x76\x61\x6e\xfd\x20\x75\x17e\x69\x76\x61\x74\x65\x6c\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQSettings-Display",
      L"classDisplayName",
      //Nastaven fronty MSMQ 
      L"\x4e\x61\x73\x74\x61\x76\x65\x6e\xed\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Nastaven MSMQ 
      L"\x4e\x61\x73\x74\x61\x76\x65\x6e\xed\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"remoteStorageServicePoint-Display",
      L"classDisplayName",
      //Sluba vzdlen pameti 
      L"\x53\x6c\x75\x17e\x62\x61\x20\x76\x7a\x64\xe1\x6c\x65\x6e\xe9\x20\x70\x61\x6d\x11b\x74\x69",
      //Sluba Remote Storage 
      L"\x53\x6c\x75\x17e\x62\x61\x20\x52\x65\x6d\x6f\x74\x65\x20\x53\x74\x6f\x72\x61\x67\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"sitesContainer-Display",
      L"classDisplayName",
      //Kontejner st 
      L"\x4b\x6f\x6e\x74\x65\x6a\x6e\x65\x72\x20\x73\xed\x74\xed",
      //Konejner ste 
      L"\x4b\x6f\x6e\x65\x6a\x6e\x65\x72\x20\x73\xed\x74\x11b",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Kontejner mezistovch prenosu 
      L"\x4b\x6f\x6e\x74\x65\x6a\x6e\x65\x72\x20\x6d\x65\x7a\x69\x73\xed\x165\x6f\x76\xfd\x63\x68\x20\x70\x159\x65\x6e\x6f\x73\x16f",
      //Kontejner mezistovho prenosu 
      L"\x4b\x6f\x6e\x74\x65\x6a\x6e\x65\x72\x20\x6d\x65\x7a\x69\x73\xed\x165\x6f\x76\xe9\x68\x6f\x20\x70\x159\x65\x6e\x6f\x73\x75",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Ciz duveryhodn objekt 
      L"\x43\x69\x7a\xed\x20\x64\x16f\x76\x11b\x72\x79\x68\x6f\x64\x6e\xfd\x20\x6f\x62\x6a\x65\x6b\x74",
      //Ciz objekty zabezpecen 
      L"\x43\x69\x7a\xed\x20\x6f\x62\x6a\x65\x6b\x74\x79\x20\x7a\x61\x62\x65\x7a\x70\x65\x10d\x65\x6e\xed",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Privatadresse 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x50\x72\x69\x76\x61\x74\x61\x64\x72\x65\x73\x73\x65",
      //homePostalAddress,Adresse (privat) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x28\x70\x72\x69\x76\x61\x74\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskab 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x62",
      //memberOf,Medlem af 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //info,Bemrkninger 
      L"\x69\x6e\x66\x6f\x2c\x42\x65\x6d\xe6\x72\x6b\x6e\x69\x6e\x67\x65\x72",
      //info,Noter 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Kontor 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72",
      //physicalDeliveryOfficeName,Kontoradresse 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72\x61\x64\x72\x65\x73\x73\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //title,Jobtitel 
      L"\x74\x69\x74\x6c\x65\x2c\x4a\x6f\x62\x74\x69\x74\x65\x6c",
      //title,Stilling 
      L"\x74\x69\x74\x6c\x65\x2c\x53\x74\x69\x6c\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Adresse p Webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      //url,Adresse p webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,Logon p arbejdsstationer 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x4c\x6f\x67\x6f\x6e\x20\x70\xe5\x20\x61\x72\x62\x65\x6a\x64\x73\x73\x74\x61\x74\x69\x6f\x6e\x65\x72",
      //userWorkstations,Log p arbejdsstationer 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x4c\x6f\x67\x20\x70\xe5\x20\x61\x72\x62\x65\x6a\x64\x73\x73\x74\x61\x74\x69\x6f\x6e\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse p Websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //wWWHomePage,Adresse p websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //info,Bemrkninger 
      L"\x69\x6e\x66\x6f\x2c\x42\x65\x6d\xe6\x72\x6b\x6e\x69\x6e\x67\x65\x72",
      //info,Noter 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Kontor 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72",
      //physicalDeliveryOfficeName,Kontoradresse 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72\x61\x64\x72\x65\x73\x73\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Adresse p Webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      //url,Adresse p webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse p Websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //wWWHomePage,Adresse p websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Navn 
      L"\x63\x6e\x2c\x4e\x61\x76\x6e",
      //dc,Navn 
      L"\x64\x63\x2c\x4e\x61\x76\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Privatadresse 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x50\x72\x69\x76\x61\x74\x61\x64\x72\x65\x73\x73\x65",
      //homePostalAddress,Adresse (privat) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x28\x70\x72\x69\x76\x61\x74\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //info,Bemrkninger 
      L"\x69\x6e\x66\x6f\x2c\x42\x65\x6d\xe6\x72\x6b\x6e\x69\x6e\x67\x65\x72",
      //info,Noter 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskab 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x62",
      //memberOf,Medlem af 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Kontor 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72",
      //physicalDeliveryOfficeName,Kontoradresse 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72\x61\x64\x72\x65\x73\x73\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,Jobtitel 
      L"\x74\x69\x74\x6c\x65\x2c\x4a\x6f\x62\x74\x69\x74\x65\x6c",
      //title,Stilling 
      L"\x74\x69\x74\x6c\x65\x2c\x53\x74\x69\x6c\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Adresse p Webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      //url,Adresse p webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse p Websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //wWWHomePage,Adresse p websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adresse p Websted 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //url,Adresse p websted 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"site-Display",
      L"classDisplayName",
      //Omrde 
      L"\x4f\x6d\x72\xe5\x64\x65",
      //Websted 
      L"\x57\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //MSMQ Enterprise 
      L"\x4d\x53\x4d\x51\x20\x45\x6e\x74\x65\x72\x70\x72\x69\x73\x65",
      //MSMQ-netvrk 
      L"\x4d\x53\x4d\x51\x2d\x6e\x65\x74\x76\xe6\x72\x6b",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"nTDSService-Display",
      L"classDisplayName",
      //Active Directory-tjeneste 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x2d\x74\x6a\x65\x6e\x65\x73\x74\x65",
      //Tjenesten Active Directory 
      L"\x54\x6a\x65\x6e\x65\x73\x74\x65\x6e\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationale ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      //internationalISDNNumber,Intl. ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppenmitgliedschaft 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6e\x6d\x69\x74\x67\x6c\x69\x65\x64\x73\x63\x68\x61\x66\x74",
      //memberOf,Mitglied von 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x74\x67\x6c\x69\x65\x64\x20\x76\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Internationale ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      //primaryInternationalISDNNumber,Intl. ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Anmeldename (fr Windows NT 3.5x/4.0) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x6e\x6d\x65\x6c\x64\x65\x6e\x61\x6d\x65\x20\x28\x66\xfc\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x33\x2e\x35\x78\x2f\x34\x2e\x30\x29",
      //samAccountName,Anmeldename (Pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x6e\x6d\x65\x6c\x64\x65\x6e\x61\x6d\x65\x20\x28\x50\x72\xe4\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Gruppenname (fr Windows NT 3.5x/4.0) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x75\x70\x70\x65\x6e\x6e\x61\x6d\x65\x20\x28\x66\xfc\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x33\x2e\x35\x78\x2f\x34\x2e\x30\x29",
      //samAccountName,Gruppenname (Pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x75\x70\x70\x65\x6e\x6e\x61\x6d\x65\x20\x28\x50\x72\xe4\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Name 
      L"\x63\x6e\x2c\x4e\x61\x6d\x65",
      //dc,Name 
      L"\x64\x63\x2c\x4e\x61\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationale ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      //internationalISDNNumber,Intl. ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppenmitgliedschaft 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6e\x6d\x69\x74\x67\x6c\x69\x65\x64\x73\x63\x68\x61\x66\x74",
      //memberOf,Mitglied von 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x74\x67\x6c\x69\x65\x64\x20\x76\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Internationale ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      //primaryInternationalISDNNumber,Intl. ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Computername (fr Windows NT 3.5x/4.0) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x6d\x65\x20\x28\x66\xfc\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x33\x2e\x35\x78\x2f\x34\x2e\x30\x29",
      //samAccountName,Computername (Pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x6d\x65\x20\x28\x50\x72\xe4\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //cn,Name des Verzeichnisdienstes 
      L"\x63\x6e\x2c\x4e\x61\x6d\x65\x20\x64\x65\x73\x20\x56\x65\x72\x7a\x65\x69\x63\x68\x6e\x69\x73\x64\x69\x65\x6e\x73\x74\x65\x73",
      //cn,Verzeichnisdienstname 
      L"\x63\x6e\x2c\x56\x65\x72\x7a\x65\x69\x63\x68\x6e\x69\x73\x64\x69\x65\x6e\x73\x74\x6e\x61\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //location,Pfad 
      L"\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x2c\x50\x66\x61\x64",
      //location,Ort 
      L"\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x2c\x4f\x72\x74",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Untersttzt doppelseitiges Drucken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x55\x6e\x74\x65\x72\x73\x74\xfc\x74\x7a\x74\x20\x64\x6f\x70\x70\x65\x6c\x73\x65\x69\x74\x69\x67\x65\x73\x20\x44\x72\x75\x63\x6b\x65\x6e",
      //printDuplexSupported,Untersttzt beidseitiges Drucken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x55\x6e\x74\x65\x72\x73\x74\xfc\x74\x7a\x74\x20\x62\x65\x69\x64\x73\x65\x69\x74\x69\x67\x65\x73\x20\x44\x72\x75\x63\x6b\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"nTDSDSA-Display",
      L"classDisplayName",
      //Einstellungen des Domnencontrollers 
      L"\x45\x69\x6e\x73\x74\x65\x6c\x6c\x75\x6e\x67\x65\x6e\x20\x64\x65\x73\x20\x44\x6f\x6d\xe4\x6e\x65\x6e\x63\x6f\x6e\x74\x72\x6f\x6c\x6c\x65\x72\x73",
      //Domnencontrollereinstellungen 
      L"\x44\x6f\x6d\xe4\x6e\x65\x6e\x63\x6f\x6e\x74\x72\x6f\x6c\x6c\x65\x72\x65\x69\x6e\x73\x74\x65\x6c\x6c\x75\x6e\x67\x65\x6e",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"trustedDomain-Display",
      L"classDisplayName",
      //Vertrauenswrdige Domne 
      L"\x56\x65\x72\x74\x72\x61\x75\x65\x6e\x73\x77\xfc\x72\x64\x69\x67\x65\x20\x44\x6f\x6d\xe4\x6e\x65",
      //Vertraute Domne 
      L"\x56\x65\x72\x74\x72\x61\x75\x74\x65\x20\x44\x6f\x6d\xe4\x6e\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,Ver&walten...,RsAdmin.msc 
      L"\x30\x2c\x56\x65\x72\x26\x77\x61\x6c\x74\x65\x6e\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&Verwalten...,RsAdmin.msc 
      L"\x30\x2c\x26\x56\x65\x72\x77\x61\x6c\x74\x65\x6e\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Fremder Sicherheitsprincipal 
      L"\x46\x72\x65\x6d\x64\x65\x72\x20\x53\x69\x63\x68\x65\x72\x68\x65\x69\x74\x73\x70\x72\x69\x6e\x63\x69\x70\x61\x6c",
      //Fremder Sicherheitsprinzipal 
      L"\x46\x72\x65\x6d\x64\x65\x72\x20\x53\x69\x63\x68\x65\x72\x68\x65\x69\x74\x73\x70\x72\x69\x6e\x7a\x69\x70\x61\x6c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //directReports,?esa a?afe??e??? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3b1\x3bd\x3b1\x3c6\x3b5\x3c1\x3cc\x3bc\x3b5\x3bd\x3bf\x3b9",
      //directReports,?esa ?pe?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3c5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3b9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //division,???d?? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x39a\x3bb\x3ac\x3b4\x3bf\x3c2",
      //division,???a? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x3a4\x3bf\x3bc\x3ad\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,??a?????st??? ?pa?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3c5\x3c0\x3b1\x3bb\x3bb\x3ae\x3bb\x3bf\x3c5",
      //employeeID,??a?????st??? e??a?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3b5\x3c1\x3b3\x3b1\x3b6\x3bf\x3bc\x3ad\x3bd\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,?????????e?? p???ea 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x394\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3bf\x3cd\x3bc\x3b5\x3bd\x3bf\x20\x3c0\x3c1\x3cc\x3b8\x3b5\x3bc\x3b1",
      //generationQualifier,?p???a d???????a? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x395\x3c0\x3af\x3b8\x3b7\x3bc\x3b1\x20\x3b4\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3af\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //homeDrive,????a ???da d?s??? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x39a\x3cd\x3c1\x3b9\x3b1\x20\x3bc\x3bf\x3bd\x3ac\x3b4\x3b1\x20\x3b4\x3af\x3c3\x3ba\x3bf\x3c5",
      //homeDrive,?e?t???? ???da d?s??? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x39a\x3b5\x3bd\x3c4\x3c1\x3b9\x3ba\x3ae\x20\x3bc\x3bf\x3bd\x3ac\x3b4\x3b1\x20\x3b4\x3af\x3c3\x3ba\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,??e?t?????? d?e????s? 
      L"\x6d\x61\x69\x6c\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7",
      //mail,??e????s? ??e?t??????? ta??d??e??? 
      L"\x6d\x61\x69\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //manager,????st?e??? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a0\x3c1\x3bf\x3ca\x3c3\x3c4\x3ac\x3bc\x3b5\x3bd\x3bf\x3c2",
      //manager,?pe?????? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,????? ??da? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3bf\x3bc\x3ac\x3b4\x3b1\x3c2",
      //memberOf,????? t?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3c4\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,?????? ????t?? t??ef???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5",
      //mobile,?????? ????t?? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,????f??? ????a? (???a) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x3a4\x3b7\x3bb\x3ad\x3c6\x3c9\x3bd\x3bf\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b1\x29",
      //otherHomePhone,?????? t??ef???? ????a? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,??e?t?????? d?e????s? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //otherMailbox,??e????s? ??e?t??????? ta??d??e??? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? ????t?? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherMobile,?????? ????t?? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,?????? ??a ap?st??? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherPager,?????? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //pager,?????? ??a ap?st??? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      //pager,?????? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //postalCode,?a??d?????? ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b9\x3ba\x3cc\x3c2\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      //postalCode,?a?. ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x2e\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,???a s??des?? ???st? (p??? ta Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x38c\x3bd\x3bf\x3bc\x3b1\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2\x20\x3c7\x3c1\x3ae\x3c3\x3c4\x3b7\x20\x28\x3c0\x3c1\x3b9\x3bd\x20\x3c4\x3b1\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,???a s??des?? (p??? ta Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x38c\x3bd\x3bf\x3bc\x3b1\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2\x20\x28\x3c0\x3c1\x3b9\x3bd\x20\x3c4\x3b1\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,S??des? sta??? e??as?a? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x3a3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x20\x3c3\x3c4\x3b1\x3b8\x3bc\x3ce\x3bd\x20\x3b5\x3c1\x3b3\x3b1\x3c3\x3af\x3b1\x3c2",
      //userWorkstations,Sta??? e??as?a? s??des?? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x3a3\x3c4\x3b1\x3b8\x3bc\x3bf\x3af\x20\x3b5\x3c1\x3b3\x3b1\x3c3\x3af\x3b1\x3c2\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"group-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"group-Display",
      L"attributeDisplayNames",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //dc,???a 
      L"\x64\x63\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //directReports,?esa a?afe??e??? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3b1\x3bd\x3b1\x3c6\x3b5\x3c1\x3cc\x3bc\x3b5\x3bd\x3bf\x3b9",
      //directReports,?esa ?pe?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3c5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3b9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,???d?? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x39a\x3bb\x3ac\x3b4\x3bf\x3c2",
      //division,???a? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x3a4\x3bf\x3bc\x3ad\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,??a?????st??? ?pa?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3c5\x3c0\x3b1\x3bb\x3bb\x3ae\x3bb\x3bf\x3c5",
      //employeeID,??a?????st??? e??a?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3b5\x3c1\x3b3\x3b1\x3b6\x3bf\x3bc\x3ad\x3bd\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,?????????e?? p???ea 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x394\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3bf\x3cd\x3bc\x3b5\x3bd\x3bf\x20\x3c0\x3c1\x3cc\x3b8\x3b5\x3bc\x3b1",
      //generationQualifier,?p???a d???????a? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x395\x3c0\x3af\x3b8\x3b7\x3bc\x3b1\x20\x3b4\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3af\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,??e?t?????? d?e????s? 
      L"\x6d\x61\x69\x6c\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7",
      //mail,??e????s? ??e?t??????? ta??d??e??? 
      L"\x6d\x61\x69\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //manager,????st?e??? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a0\x3c1\x3bf\x3ca\x3c3\x3c4\x3ac\x3bc\x3b5\x3bd\x3bf\x3c2",
      //manager,?pe?????? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,????? ??da? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3bf\x3bc\x3ac\x3b4\x3b1\x3c2",
      //memberOf,????? t?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3c4\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,?????? ????t?? t??ef???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5",
      //mobile,?????? ????t?? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,????f??? ????a? (???a) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x3a4\x3b7\x3bb\x3ad\x3c6\x3c9\x3bd\x3bf\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b1\x29",
      //otherHomePhone,?????? t??ef???? ????a? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,??e?t?????? d?e????s? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //otherMailbox,??e????s? ??e?t??????? ta??d??e??? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? ????t?? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherMobile,?????? ????t?? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,?????? ??a ap?st??? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherPager,?????? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //pager,?????? ??a ap?st??? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      //pager,?????? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //postalCode,?a??d?????? ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b9\x3ba\x3cc\x3c2\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      //postalCode,?a?. ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x2e\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"computer-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printerName,???atep???? 
      L"\x70\x72\x69\x6e\x74\x65\x72\x4e\x61\x6d\x65\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //printerName,???a 
      L"\x70\x72\x69\x6e\x74\x65\x72\x4e\x61\x6d\x65\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"nTFRSReplicaSet-Display",
      L"classDisplayName",
      //S????? ??p???a? FRS 
      L"\x3a3\x3cd\x3bd\x3bf\x3bb\x3bf\x20\x3c1\x3ad\x3c0\x3bb\x3b9\x3ba\x3b1\x3c2\x20\x46\x52\x53",
      //S????? ?ep???a? FRS 
      L"\x3a3\x3cd\x3bd\x3bf\x3bb\x3bf\x20\x3c1\x3b5\x3c0\x3bb\x3af\x3ba\x3b1\x3c2\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"organizationalUnit-Display",
      L"attributeDisplayNames",
      //ou,???atep???? 
      L"\x6f\x75\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //ou,???a 
      L"\x6f\x75\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"container-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"rpcContainer-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"trustedDomain-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"trustedDomain-Display",
      L"classDisplayName",
      //?p?st?? t??a? 
      L"\x388\x3bc\x3c0\x3b9\x3c3\x3c4\x3bf\x3c2\x20\x3c4\x3bf\x3bc\x3ad\x3b1\x3c2",
      //????p?st?? t??a? 
      L"\x391\x3be\x3b9\x3cc\x3c0\x3b9\x3c3\x3c4\x3bf\x3c2\x20\x3c4\x3bf\x3bc\x3ad\x3b1\x3c2",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"volume-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"mSMQConfiguration-Display",
      L"classDisplayName",
      //?a??et??? MSMQ 
      L"\x3a0\x3b1\x3c1\x3ac\x3bc\x3b5\x3c4\x3c1\x3bf\x3b9\x20\x4d\x53\x4d\x51",
      //????s? pa?a?t??? MSMQ 
      L"\x3a1\x3cd\x3b8\x3bc\x3b9\x3c3\x3b7\x20\x3c0\x3b1\x3c1\x3b1\x3bc\x3ad\x3c4\x3c1\x3c9\x3bd\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //?ta????? MSMQ 
      L"\x395\x3c4\x3b1\x3b9\x3c1\x3b9\x3ba\x3cc\x20\x4d\x53\x4d\x51",
      //?ta??e?a MSMQ 
      L"\x395\x3c4\x3b1\x3b9\x3c1\x3b5\x3af\x3b1\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //????????s? s??des?? MSMQ 
      L"\x394\x3c1\x3bf\x3bc\x3bf\x3bb\x3cc\x3b3\x3b7\x3c3\x3b7\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2\x20\x4d\x53\x4d\x51",
      //S??des? d???????s?? MSMQ 
      L"\x3a3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x20\x3b4\x3c1\x3bf\x3bc\x3bf\x3bb\x3cc\x3b3\x3b7\x3c3\x3b7\x3c2\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,&??a?e???s?...,RsAdmin.msc 
      L"\x30\x2c\x26\x394\x3b9\x3b1\x3c7\x3b5\x3af\x3c1\x3b9\x3c3\x3b7\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,??a&?e???s?...,RsAdmin.msc 
      L"\x30\x2c\x394\x3b9\x3b1\x26\x3c7\x3b5\x3af\x3c1\x3b9\x3c3\x3b7\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"remoteStorageServicePoint-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"default-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"foreignSecurityPrincipal-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"pKICertificateTemplate-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Ryhmn jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x52\x79\x68\x6d\xe4\x6e\x20\x6a\xe4\x73\x65\x6e\x79\x79\x73",
      //memberOf,Jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\xe4\x73\x65\x6e\x79\x79\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nimi 
      L"\x63\x6e\x2c\x4e\x69\x6d\x69",
      //dc,Nimi 
      L"\x64\x63\x2c\x4e\x69\x6d\x69",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Ryhmn jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x52\x79\x68\x6d\xe4\x6e\x20\x6a\xe4\x73\x65\x6e\x79\x79\x73",
      //memberOf,Jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\xe4\x73\x65\x6e\x79\x79\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Adhsion au groupe 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x64\x68\xe9\x73\x69\x6f\x6e\x20\x61\x75\x20\x67\x72\x6f\x75\x70\x65",
      //memberOf,Membre de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse de page Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //wWWHomePage,Adresse de page Vb 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse de page Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //wWWHomePage,Adresse de page Vb 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nom 
      L"\x63\x6e\x2c\x4e\x6f\x6d",
      //dc,Nom 
      L"\x64\x63\x2c\x4e\x6f\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Adhsion au groupe 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x64\x68\xe9\x73\x69\x6f\x6e\x20\x61\x75\x20\x67\x72\x6f\x75\x70\x65",
      //memberOf,Membre de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse de page Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //wWWHomePage,Adresse de page Vb 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaReady,Papier disponible 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x50\x61\x70\x69\x65\x72\x20\x64\x69\x73\x70\x6f\x6e\x69\x62\x6c\x65",
      //printMediaReady,Papier disponible 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x50\x61\x70\x69\x65\x72\x20\x64\x69\x73\x70\x6f\x6e\x69\x62\x6c\x65\xa0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printShareName,Nom de partage 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x65\x20\x70\x61\x72\x74\x61\x67\x65",
      //printShareName,Nom du partage 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x75\x20\x70\x61\x72\x74\x61\x67\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //serverName,Nom du serveur 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x75\x20\x73\x65\x72\x76\x65\x75\x72",
      //serverName,Nom de serveur 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x65\x20\x73\x65\x72\x76\x65\x75\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adresse de page Web 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //url,Adresse de page Vb 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"subnet-Display",
      L"classDisplayName",
      //Sous-rseau 
      L"\x53\x6f\x75\x73\x2d\x72\xe9\x73\x65\x61\x75",
      //Sous-rseau 
      L"\x53\x6f\x75\x73\x2d\x72\xe9\x73\x65\x61\x75\xa0",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //Unit d'organisation 
      L"\x55\x6e\x69\x74\xe9\x20\x64\x27\x6f\x72\x67\x61\x6e\x69\x73\x61\x74\x69\x6f\x6e",
      //Unit d'organisation 
      L"\x55\x6e\x69\x74\xe9\x20\x64\x27\x6f\x72\x67\x61\x6e\x69\x73\x61\x74\x69\x6f\x6e\xa0",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"volume-Display",
      L"attributeDisplayNames",
      //keywords,Mots-cls 
      L"\x6b\x65\x79\x77\x6f\x72\x64\x73\x2c\x4d\x6f\x74\x73\x2d\x63\x6c\xe9\x73",
      //keywords,Mots cls 
      L"\x6b\x65\x79\x77\x6f\x72\x64\x73\x2c\x4d\x6f\x74\x73\x20\x63\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"volume-Display",
      L"classDisplayName",
      //Dossier partag 
      L"\x44\x6f\x73\x73\x69\x65\x72\x20\x70\x61\x72\x74\x61\x67\xe9",
      //Dossier partag 
      L"\x44\x6f\x73\x73\x69\x65\x72\x20\x70\x61\x72\x74\x61\x67\xe9\xa0",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"IntellimirrorGroup-Display",
      L"classDisplayName",
      //IntelliMirror Group 
      L"\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72\x20\x47\x72\x6f\x75\x70",
      //????? IntelliMirror 
      L"\x5e7\x5d1\x5d5\x5e6\x5ea\x20\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"IntellimirrorSCP-Display",
      L"classDisplayName",
      //IntelliMirror Service 
      L"\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72\x20\x53\x65\x72\x76\x69\x63\x65",
      //????? IntelliMirror 
      L"\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //assistant,???? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5e2\x5d5\x5d6\x5e8",
      //assistant,????? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5de\x5e1\x5d9\x5d9\x5e2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //c,????? ????? 
      L"\x63\x2c\x5e7\x5d9\x5e6\x5d5\x5e8\x20\x5de\x5d3\x5d9\x5e0\x5d4",
      //c,???? ????? ???? 
      L"\x63\x2c\x5e8\x5d0\x5e9\x5d9\x20\x5ea\x5d9\x5d1\x5d5\x5ea\x20\x5d4\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //co,????? 
      L"\x63\x6f\x2c\x5de\x5d3\x5d9\x5e0\x5d4",
      //co,??? 
      L"\x63\x6f\x2c\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //comment,???? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d4",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d5\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //directReports,?????? ?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5db\x5e4\x5d5\x5e4\x5d9\x5dd\x20\x5d9\x5e9\x5d9\x5e8\x5d5\x5ea",
      //directReports,????? ???? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5d3\x5d9\x5d5\x5d5\x5d7\x20\x5d9\x5e9\x5d9\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,?? ?????? ?? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x5e9\x5dc\x20\x58\x35\x30\x30",
      //distinguishedName,?? ?????? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5d7\x5d8\x5d9\x5d1\x5d4",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5de\x5d7\x5dc\x5e7\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,???? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5de\x5d6\x5d4\x5d4\x20\x5e2\x5d5\x5d1\x5d3",
      //employeeID,????? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5d6\x5d9\x5d4\x5d5\x5d9\x20\x5e2\x5d5\x5d1\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,????? ?? ??? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5e9\x5dc\x20\x5d3\x5d5\x5e8",
      //generationQualifier,????? ???? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5d4\x5d3\x5d5\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //homeDirectory,????? ????? 
      L"\x68\x6f\x6d\x65\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x2c\x5ea\x5d9\x5e7\x5d9\x5d4\x20\x5e8\x5d0\x5e9\x5d9\x5ea",
      //homeDirectory,?????? ???? 
      L"\x68\x6f\x6d\x65\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x2c\x5ea\x5d9\x5e7\x5d9\x5d9\x5ea\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //homeDrive,???? ???? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x5db\x5d5\x5e0\x5df\x20\x5e8\x5d0\x5e9\x5d9",
      //homeDrive,???? ???? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x5db\x5d5\x5e0\x5df\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d1\x5d1\x5d9\x5ea",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,???? ISDN ???????? (?????)? 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //internationalISDNNumber,???? ISDN ???????? (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,????? ???? ???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      //mail,????? ????-???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,????? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x5d5\x5ea\x20\x5d1\x5e7\x5d1\x5d5\x5e6\x5d4",
      //memberOf,??? ?- 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x20\x5d1\x2d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,???? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3",
      //mobile,???? ????? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? ??? (?????)? 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherFacsimileTelephoneNumber,???? ??? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,???? ????? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherHomePhone,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,???? ????? IP (?????)? 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200e",
      //otherIpPhone,???? ????? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,????? ???? ???????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMailbox,????? ????-???????? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,???? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMobile,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,???? ??????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherPager,???? ??????? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? ????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherTelephone,???? ????? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,????? ???? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5de\x5e9\x5e8\x5d3",
      //physicalDeliveryOfficeName,????? ????? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5d4\x5de\x5e9\x5e8\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,?? ????? ?(???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5db\x5e0\x5d9\x5e1\x5d4\x20\x200e\x28\x5d8\x5e8\x5d5\x5dd\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,?? ?????? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5db\x5e0\x5d9\x5e1\x5d4\x20\x28\x5dc\x5e4\x5e0\x5d9\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //streetAddress,????? ???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5e8\x5d7\x5d5\x5d1",
      //streetAddress,???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5e8\x5d7\x5d5\x5d1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,???? ???? (?????)? 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //telexNumber,???? ???? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //title,???? ????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5d5\x5d0\x5e8\x20\x5ea\x5e4\x5e7\x5d9\x5d3",
      //title,????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5e4\x5e7\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //url,????? ?? ??????? (?????)? 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //url,????? ?? ??????? (?????) 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //displayName,?? ????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5ea\x5e6\x5d5\x5d2\x5d4",
      //displayName,?? ?????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5ea\x5e6\x5d5\x5d2\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,????? ????? ?????? ????? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x5ea\x5d7\x5e0\x5d5\x5ea\x20\x5e2\x5d1\x5d5\x5d3\x5d4\x20\x5dc\x5d1\x5d9\x5e6\x5d5\x5e2\x20\x5db\x5e0\x5d9\x5e1\x5d4",
      //userWorkstations,????? ????? ?????? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x5ea\x5d7\x5e0\x5d5\x5ea\x20\x5e2\x5d1\x5d5\x5d3\x5d4\x20\x5dc\x5db\x5e0\x5d9\x5e1\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //userPrincipalName,?? ????? 
      L"\x75\x73\x65\x72\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5db\x5e0\x5d9\x5e1\x5d4",
      //userPrincipalName,?? ?????? 
      L"\x75\x73\x65\x72\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5db\x5e0\x5d9\x5e1\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //c,????? ????? 
      L"\x63\x2c\x5e7\x5d9\x5e6\x5d5\x5e8\x20\x5de\x5d3\x5d9\x5e0\x5d4",
      //c,???? ????? ???? 
      L"\x63\x2c\x5e8\x5d0\x5e9\x5d9\x20\x5ea\x5d9\x5d1\x5d5\x5ea\x20\x5d4\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,?? ?????? ?? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x5e9\x5dc\x20\x58\x35\x30\x30",
      //distinguishedName,?? ?????? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,????? ???? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5de\x5e9\x5e8\x5d3",
      //physicalDeliveryOfficeName,????? ????? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5d4\x5de\x5e9\x5e8\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,?? ?????? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e7\x5d1\x5d5\x5e6\x5d4\x200e\x20\x28\x5d8\x5e8\x5d5\x5dd\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,?? ????? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e7\x5d1\x5d5\x5e6\x5d4\x20\x28\x5dc\x5e4\x5e0\x5d9\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //url,????? ?? ??????? (?????)? 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //url,????? ?? ??????? (?????) 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x5e9\x5dd",
      //dc,?? 
      L"\x64\x63\x2c\x5e9\x5dd",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //assistant,???? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5e2\x5d5\x5d6\x5e8",
      //assistant,????? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5de\x5e1\x5d9\x5d9\x5e2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,????? ????? 
      L"\x63\x2c\x5e7\x5d9\x5e6\x5d5\x5e8\x20\x5de\x5d3\x5d9\x5e0\x5d4",
      //c,???? ????? ???? 
      L"\x63\x2c\x5e8\x5d0\x5e9\x5d9\x20\x5ea\x5d9\x5d1\x5d5\x5ea\x20\x5d4\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //co,????? 
      L"\x63\x6f\x2c\x5de\x5d3\x5d9\x5e0\x5d4",
      //co,??? 
      L"\x63\x6f\x2c\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //comment,???? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d4",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d5\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //directReports,?????? ?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5db\x5e4\x5d5\x5e4\x5d9\x5dd\x20\x5d9\x5e9\x5d9\x5e8\x5d5\x5ea",
      //directReports,????? ???? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5d3\x5d9\x5d5\x5d5\x5d7\x20\x5d9\x5e9\x5d9\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //displayName,?? ????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5ea\x5e6\x5d5\x5d2\x5d4",
      //displayName,?? ?????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5ea\x5e6\x5d5\x5d2\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,?? ?????? ?? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x5e9\x5dc\x20\x58\x35\x30\x30",
      //distinguishedName,?? ?????? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5d7\x5d8\x5d9\x5d1\x5d4",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5de\x5d7\x5dc\x5e7\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,???? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5de\x5d6\x5d4\x5d4\x20\x5e2\x5d5\x5d1\x5d3",
      //employeeID,????? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5d6\x5d9\x5d4\x5d5\x5d9\x20\x5e2\x5d5\x5d1\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,????? ?? ??? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5e9\x5dc\x20\x5d3\x5d5\x5e8",
      //generationQualifier,????? ???? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5d4\x5d3\x5d5\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d1\x5d1\x5d9\x5ea",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,???? ISDN ???????? (?????)? 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //internationalISDNNumber,???? ISDN ???????? (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,????? ???? ???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      //mail,????? ????-???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,????? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x5d5\x5ea\x20\x5d1\x5e7\x5d1\x5d5\x5e6\x5d4",
      //memberOf,??? ?- 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x20\x5d1\x2d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,???? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3",
      //mobile,???? ????? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? ??? (?????)? 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherFacsimileTelephoneNumber,???? ??? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,???? ????? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherHomePhone,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,???? ????? IP (?????)? 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200e",
      //otherIpPhone,???? ????? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,????? ???? ???????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMailbox,????? ????-???????? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,???? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMobile,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,???? ??????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherPager,???? ??????? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? ????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherTelephone,???? ????? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,????? ???? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5de\x5e9\x5e8\x5d3",
      //physicalDeliveryOfficeName,????? ????? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5d4\x5de\x5e9\x5e8\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //streetAddress,????? ???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5e8\x5d7\x5d5\x5d1",
      //streetAddress,???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5e8\x5d7\x5d5\x5d1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,???? ???? (?????)? 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //telexNumber,???? ???? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,???? ????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5d5\x5d0\x5e8\x20\x5ea\x5e4\x5e7\x5d9\x5d3",
      //title,????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5e4\x5e7\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,????? ?? ??????? (?????)? 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //url,????? ?? ??????? (?????) 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"computer-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,?? ???? ?(???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5de\x5d7\x5e9\x5d1\x20\x200e\x28\x5d8\x5e8\x5d5\x5dd\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,?? ???? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5de\x5d7\x5e9\x5d1\x20\x28\x5dc\x5e4\x5e0\x5d9\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //cn,?? ????? ?????? 
      L"\x63\x6e\x2c\x5e9\x5dd\x20\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5e1\x5e4\x5e8\x5d9\x5d5\x5ea",
      //cn,?? ????? ?????? 
      L"\x63\x6e\x2c\x5e9\x5dd\x20\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5e1\x5e4\x5e8\x5d9\x5d9\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //description,???? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x5d4\x5e2\x5e8\x5d4",
      //description,????? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x5d4\x5e2\x5e8\x5d5\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //driverName,??? 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5d3\x5d2\x5dd",
      //driverName,???? 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5de\x5d5\x5d3\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printLanguage,??? ????? 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x5e9\x5e4\x5ea\x20\x5de\x5d3\x5e4\x5e1\x5ea",
      //printLanguage,??? ?????? 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x5e9\x5e4\x5ea\x20\x5d4\x5de\x5d3\x5e4\x5e1\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMaxResolutionSupported,???????? ???????? 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x5e8\x5d6\x5d5\x5dc\x5d5\x5e6\x5d9\x5d4\x20\x5de\x5e7\x5e1\x5d9\x5de\x5dc\x5d9\x5ea",
      //printMaxResolutionSupported,???????? ????? 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x5e8\x5d6\x5d5\x5dc\x5d5\x5e6\x5d9\x5d4\x20\x5de\x5e8\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printPagesPerMinute,???? ???? 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x5d3\x5e4\x5d9\x5dd\x20\x5dc\x5d3\x5e7\x5d4",
      //printPagesPerMinute,???? ???? 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x5d3\x5e4\x5d9\x5dd\x20\x5d1\x5d3\x5e7\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printShareName,?? ????? 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e9\x5d9\x5ea\x5d5\x5e3",
      //printShareName,?? ????? 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5de\x5e9\x5d5\x5ea\x5e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //serverName,?? ??? 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e9\x5e8\x5ea",
      //serverName,?? ???? 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d4\x5e9\x5e8\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //versionNumber,????? ??????? 
      L"\x76\x65\x72\x73\x69\x6f\x6e\x4e\x75\x6d\x62\x65\x72\x2c\x5d2\x5d9\x5e8\x5e1\x5ea\x20\x5d0\x5d5\x5d1\x5d9\x5d9\x5e7\x5d8",
      //versionNumber,????? ???????? 
      L"\x76\x65\x72\x73\x69\x6f\x6e\x4e\x75\x6d\x62\x65\x72\x2c\x5d2\x5d9\x5e8\x5e1\x5ea\x20\x5d4\x5d0\x5d5\x5d1\x5d9\x5d9\x5e7\x5d8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"nTDSConnection-Display",
      L"classDisplayName",
      //??????? 
      L"\x5d4\x5ea\x5e7\x5e9\x5e8\x5d5\x5ea",
      //????? 
      L"\x5d7\x5d9\x5d1\x5d5\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"nTFRSReplicaSet-Display",
      L"classDisplayName",
      //????? ?????? ???????? ?? FRS 
      L"\x5e7\x5d1\x5d5\x5e6\x5ea\x20\x5e2\x5d5\x5ea\x5e7\x5d9\x5dd\x20\x5de\x5e9\x5d5\x5db\x5e4\x5dc\x5d9\x5dd\x20\x5e9\x5dc\x20\x46\x52\x53",
      //???? ?????? ???????? ?? FRS 
      L"\x5e2\x5e8\x5db\x5ea\x20\x5e2\x5d5\x5ea\x5e7\x5d9\x5dd\x20\x5de\x5e9\x5d5\x5db\x5e4\x5dc\x5d9\x5dd\x20\x5e9\x5dc\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"subnet-Display",
      L"classDisplayName",
      //??? ???? 
      L"\x5e8\x5e9\x5ea\x20\x5de\x5e9\x5e0\x5d4",
      //??? ????? Subnet 
      L"\x5e8\x5e9\x5ea\x20\x5de\x5e9\x5e0\x5d9\x5ea\x20\x53\x75\x62\x6e\x65\x74",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"siteLink-Display",
      L"classDisplayName",
      //????? ?????? 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8\x5d9\x5dd",
      //????? ???? 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //??? ????? ?????? 
      L"\x5d2\x5e9\x5e8\x20\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8\x5d9\x5dd",
      //??? ????? ???? 
      L"\x5d2\x5e9\x5e8\x20\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"interSiteTransport-Display",
      L"classDisplayName",
      //?????? ???? ????? 
      L"\x5ea\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5ea\x5d5\x5da\x20\x5d0\x5ea\x5e8\x5d9\x5dd",
      //?????? ???-????? 
      L"\x5ea\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5d9\x5df\x2d\x5d0\x5ea\x5e8\x5d9\x5dd",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"licensingSiteSettings-Display",
      L"classDisplayName",
      //?????? ??? ????? 
      L"\x5d4\x5d2\x5d3\x5e8\x5d5\x5ea\x20\x5d0\x5ea\x5e8\x20\x5e8\x5d9\x5e9\x5d5\x5d9",
      //????? ??????? ??? 
      L"\x5e8\x5e9\x5d9\x5d5\x5df\x20\x5dc\x5d4\x5d2\x5d3\x5e8\x5d5\x5ea\x20\x5d0\x5ea\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"nTFRSSubscriptions-Display",
      L"classDisplayName",
      //????? FRS 
      L"\x5de\x5e0\x5d5\x5d9\x5d9\x20\x46\x52\x53",
      //?????? ?-FRS 
      L"\x5de\x5e0\x5d5\x5d9\x5d9\x5dd\x20\x5dc\x2d\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"organizationalUnit-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"volume-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"volume-Display",
      L"attributeDisplayNames",
      //uNCName,???? ??? 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x5e0\x5ea\x5d9\x5d1\x20\x5e8\x5e9\x5ea",
      //uNCName,???? ???? 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x5e0\x5ea\x5d9\x5d1\x20\x5d4\x5e8\x5e9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"volume-Display",
      L"classDisplayName",
      //????? ?????? 
      L"\x5ea\x5d9\x5e7\x5d9\x5d4\x20\x5de\x5e9\x5d5\x5ea\x5e4\x5ea",
      //?????? ?????? 
      L"\x5ea\x5d9\x5e7\x5d9\x5d9\x5d4\x20\x5de\x5e9\x5d5\x5ea\x5e4\x5ea",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //MSMQ Enterprise 
      L"\x4d\x53\x4d\x51\x20\x45\x6e\x74\x65\x72\x70\x72\x69\x73\x65",
      //????? MSMQ 
      L"\x5d0\x5e8\x5d2\x5d5\x5df\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //????? ?????? ?? MSMQ 
      L"\x5de\x5e9\x5ea\x5de\x5e9\x20\x5de\x5e9\x5d5\x5d3\x5e8\x5d2\x20\x5e9\x5dc\x20\x4d\x53\x4d\x51",
      //????? ?????? ?-MSMQ 
      L"\x5de\x5e9\x5ea\x5de\x5e9\x20\x5de\x5e9\x5d5\x5d3\x5e8\x5d2\x20\x5d1\x2d\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //????? ?????? MSMQ 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5e0\x5d9\x5ea\x5d5\x5d1\x20\x4d\x53\x4d\x51",
      //????? ???? MSMQ 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5de\x5e0\x5ea\x5d1\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,&???...,RsAdmin.msc 
      L"\x30\x2c\x26\x5e0\x5d4\x5dc\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&?????...,RsAdmin.msc 
      L"\x30\x2c\x26\x5e0\x5d9\x5d4\x5d5\x5dc\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"remoteStorageServicePoint-Display",
      L"classDisplayName",
      //????? ????? ????? 
      L"\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5d0\x5d7\x5e1\x5d5\x5df\x20\x5de\x5e8\x5d5\x5d7\x5e7",
      //????? ?????? ????? 
      L"\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5d0\x5d9\x5d7\x5e1\x5d5\x5df\x20\x5de\x5e8\x5d5\x5d7\x5e7",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //???? ???? ?? ?????? ???? ????? 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5ea\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5ea\x5d5\x5da\x20\x5d0\x5ea\x5e8\x5d9\x5dd",
      //???? ???? ?? ?????? ???-????? 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5de\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5d9\x5df\x2d\x5d0\x5ea\x5e8\x5d9\x5dd",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"subnetContainer-Display",
      L"classDisplayName",
      //???? ???? ?? ????? ???? 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5e8\x5e9\x5ea\x5d5\x5ea\x20\x5de\x5e9\x5e0\x5d4",
      //???? ???? ?? ????? ???? (Subnets) 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5e8\x5e9\x5ea\x5d5\x5ea\x20\x5de\x5e9\x5e0\x5d4\x20\x28\x53\x75\x62\x6e\x65\x74\x73\x29",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"queryPolicy-Display",
      L"classDisplayName",
      //??????? ??????? 
      L"\x5de\x5d3\x5d9\x5e0\x5d9\x5d5\x5ea\x20\x5e9\x5d0\x5d9\x5dc\x5ea\x5d5\x5ea",
      //??????? ?????? 
      L"\x5de\x5d3\x5d9\x5e0\x5d9\x5d5\x5ea\x20\x5e9\x5d0\x5d9\x5dc\x5ea\x5d4",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //???? ????? ??? 
      L"\x5de\x5e0\x5d4\x5dc\x20\x5d0\x5d1\x5d8\x5d7\x5ea\x20\x5d7\x5d5\x5e5",
      //??? ??????? ???? 
      L"\x5e7\x5e8\x5df\x20\x5d1\x5d8\x5d7\x5d5\x5e0\x5d5\x5ea\x20\x5d6\x5e8\x5d9\x5dd",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"user-Display",
      L"attributeDisplayNames",
      //l,Vros 
      L"\x6c\x2c\x56\xe1\x72\x6f\x73",
      //l,Telepls 
      L"\x6c\x2c\x54\x65\x6c\x65\x70\xfc\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,Elektronikus levlcm 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x6b\x75\x73\x20\x6c\x65\x76\xe9\x6c\x63\xed\x6d",
      //mail,E-mail cm 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x20\x63\xed\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Csoporttagsg 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x73\x6f\x70\x6f\x72\x74\x74\x61\x67\x73\xe1\x67",
      //memberOf,A kvetkezo tagja 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x20\x6b\xf6\x76\x65\x74\x6b\x65\x7a\x151\x20\x74\x61\x67\x6a\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"group-Display",
      L"attributeDisplayNames",
      //l,Vros 
      L"\x6c\x2c\x56\xe1\x72\x6f\x73",
      //l,Telepls 
      L"\x6c\x2c\x54\x65\x6c\x65\x70\xfc\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Windows 2000 elotti csoportnv 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x63\x73\x6f\x70\x6f\x72\x74\x6e\xe9\x76",
      //samAccountName,Csoportnv (Windows 2000 elotti rendszer) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x73\x6f\x70\x6f\x72\x74\x6e\xe9\x76\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x72\x65\x6e\x64\x73\x7a\x65\x72\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nv 
      L"\x63\x6e\x2c\x4e\xe9\x76",
      //dc,Nv 
      L"\x64\x63\x2c\x4e\xe9\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"contact-Display",
      L"attributeDisplayNames",
      //l,Vros 
      L"\x6c\x2c\x56\xe1\x72\x6f\x73",
      //l,Telepls 
      L"\x6c\x2c\x54\x65\x6c\x65\x70\xfc\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,Elektronikus levlcm 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x6b\x75\x73\x20\x6c\x65\x76\xe9\x6c\x63\xed\x6d",
      //mail,E-mail cm 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x20\x63\xed\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Csoporttagsg 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x73\x6f\x70\x6f\x72\x74\x74\x61\x67\x73\xe1\x67",
      //memberOf,A kvetkezo tagja 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x20\x6b\xf6\x76\x65\x74\x6b\x65\x7a\x151\x20\x74\x61\x67\x6a\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"serviceAdministrationPoint-Display",
      L"classDisplayName",
      //Szolgltats 
      L"\x53\x7a\x6f\x6c\x67\xe1\x6c\x74\x61\x74\xe1\x73",
      //Active Directory szolgltats 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x73\x7a\x6f\x6c\x67\xe1\x6c\x74\x61\x74\xe1\x73",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Windows 2000 elotti szmtgpnv 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x73\x7a\xe1\x6d\xed\x74\xf3\x67\xe9\x70\x6e\xe9\x76",
      //samAccountName,Szmtgpnv (Windows 2000 elotti rendszer) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x53\x7a\xe1\x6d\xed\x74\xf3\x67\xe9\x70\x6e\xe9\x76\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x72\x65\x6e\x64\x73\x7a\x65\x72\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"trustedDomain-Display",
      L"classDisplayName",
      //Meghatalmazott tartomny 
      L"\x4d\x65\x67\x68\x61\x74\x61\x6c\x6d\x61\x7a\x6f\x74\x74\x20\x74\x61\x72\x74\x6f\x6d\xe1\x6e\x79",
      //Megbzhat tartomny 
      L"\x4d\x65\x67\x62\xed\x7a\x68\x61\x74\xf3\x20\x74\x61\x72\x74\x6f\x6d\xe1\x6e\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Helykzi tvitelek trolja 
      L"\x48\x65\x6c\x79\x6b\xf6\x7a\x69\x20\xe1\x74\x76\x69\x74\x65\x6c\x65\x6b\x20\x74\xe1\x72\x6f\x6c\xf3\x6a\x61",
      //Helyek kztti tvitel trolja 
      L"\x48\x65\x6c\x79\x65\x6b\x20\x6b\xf6\x7a\xf6\x74\x74\x69\x20\xe1\x74\x76\x69\x74\x65\x6c\x20\x74\xe1\x72\x6f\x6c\xf3\x6a\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"queryPolicy-Display",
      L"classDisplayName",
      //Lekrdezsi hzirend 
      L"\x4c\x65\x6b\xe9\x72\x64\x65\x7a\xe9\x73\x69\x20\x68\xe1\x7a\x69\x72\x65\x6e\x64",
      //Lekrdezsek hzirendje 
      L"\x4c\x65\x6b\xe9\x72\x64\x65\x7a\xe9\x73\x65\x6b\x20\x68\xe1\x7a\x69\x72\x65\x6e\x64\x6a\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Klso szereplo 
      L"\x4b\xfc\x6c\x73\x151\x20\x73\x7a\x65\x72\x65\x70\x6c\x151",
      //Idegen biztonsgi egyszerunv 
      L"\x49\x64\x65\x67\x65\x6e\x20\x62\x69\x7a\x74\x6f\x6e\x73\xe1\x67\x69\x20\x65\x67\x79\x73\x7a\x65\x72\x171\x6e\xe9\x76",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //Bizonytvnysablon 
      L"\x42\x69\x7a\x6f\x6e\x79\xed\x74\x76\xe1\x6e\x79\x73\x61\x62\x6c\x6f\x6e",
      //Tanstvnysablon 
      L"\x54\x61\x6e\xfa\x73\xed\x74\x76\xe1\x6e\x79\x73\x61\x62\x6c\x6f\x6e",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"user-Display",
      L"attributeDisplayNames",
      //ipPhone,Numero telefonico IP  
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50\x20",
      //ipPhone,Numero telefonico IP 
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Numero ISDN internazionale  
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65\x20",
      //primaryInternationalISDNNumber,Numero ISDN internazionale 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nome utente 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x65\x20\x75\x74\x65\x6e\x74\x65",
      //dc,Nome utente 
      L"\x64\x63\x2c\x4e\x6f\x6d\x65\x20\x75\x74\x65\x6e\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"contact-Display",
      L"attributeDisplayNames",
      //ipPhone,Numero telefonico IP  
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50\x20",
      //ipPhone,Numero telefonico IP 
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Numero ISDN internazionale  
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65\x20",
      //primaryInternationalISDNNumber,Numero ISDN internazionale 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"serviceAdministrationPoint-Display",
      L"classDisplayName",
      //Servizio 
      L"\x53\x65\x72\x76\x69\x7a\x69\x6f",
      //Servizio Active Directory 
      L"\x53\x65\x72\x76\x69\x7a\x69\x6f\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Valore principale protezione esterna 
      L"\x56\x61\x6c\x6f\x72\x65\x20\x70\x72\x69\x6e\x63\x69\x70\x61\x6c\x65\x20\x70\x72\x6f\x74\x65\x7a\x69\x6f\x6e\x65\x20\x65\x73\x74\x65\x72\x6e\x61",
      //Responsabili esterni protezione 
      L"\x52\x65\x73\x70\x6f\x6e\x73\x61\x62\x69\x6c\x69\x20\x65\x73\x74\x65\x72\x6e\x69\x20\x70\x72\x6f\x74\x65\x7a\x69\x6f\x6e\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //Modello certificato 
      L"\x4d\x6f\x64\x65\x6c\x6c\x6f\x20\x63\x65\x72\x74\x69\x66\x69\x63\x61\x74\x6f",
      //Modello di certificato 
      L"\x4d\x6f\x64\x65\x6c\x6c\x6f\x20\x64\x69\x20\x63\x65\x72\x74\x69\x66\x69\x63\x61\x74\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x30b0\x30eb\x30fc\x30d7\x20\x30e1\x30f3\x30d0\x30b7\x30c3\x30d7",
      //memberOf,???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6240\x5c5e\x3059\x308b\x30b0\x30eb\x30fc\x30d7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,???????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7",
      //mobile,?????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,???????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      //otherMobile,?????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x540d\x524d",
      //dc,?? 
      L"\x64\x63\x2c\x540d\x524d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x30b0\x30eb\x30fc\x30d7\x20\x30e1\x30f3\x30d0\x30b7\x30c3\x30d7",
      //memberOf,???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6240\x5c5e\x3059\x308b\x30b0\x30eb\x30fc\x30d7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,???????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7",
      //mobile,?????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,???????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      //otherMobile,?????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //MSMQ ??????? 
      L"\x4d\x53\x4d\x51\x20\x30a8\x30f3\x30bf\x30d7\x30e9\x30a4\x30ba",
      //MSMQ ???????? 
      L"\x4d\x53\x4d\x51\x20\x30a8\x30f3\x30bf\x30fc\x30d7\x30e9\x30a4\x30ba",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //givenName,??(? ??) 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
      //givenName,?? 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,?? ISDN ?? (??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //internationalISDNNumber,?? ISDN ??(??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xadf8\xb8f9\x20\xb4f1\xb85d",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xc18c\xc18d\x20\xadf8\xb8f9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherFacsimileTelephoneNumber,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherIpPhone,IP ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,?? ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //otherMailbox,?? ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherMobile,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherPager,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherTelephone,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //telexNumber,??? ??(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //url,? ??? ?? (??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //url,? ??? ??(??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,??? ?????? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xb85c\xadf8\xc628\x20\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158",
      //userWorkstations,?????? ??? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158\x20\xb85c\xadf8\xc628",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"group-Display",
      L"attributeDisplayNames",
      //url,? ??? ?? (??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //url,? ??? ??(??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\xc774\xb984",
      //dc,?? 
      L"\x64\x63\x2c\xc774\xb984",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //givenName,??(? ??) 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
      //givenName,?? 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,?? ISDN ?? (??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //internationalISDNNumber,?? ISDN ??(??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xadf8\xb8f9\x20\xb4f1\xb85d",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xc18c\xc18d\x20\xadf8\xb8f9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherFacsimileTelephoneNumber,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,? ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\xc9d1\x20\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherHomePhone,? ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\xc9d1\x20\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherIpPhone,IP ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,?? ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //otherMailbox,?? ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherMobile,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherPager,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherTelephone,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //telexNumber,??? ??(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,? ??? ?? (??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //url,? ??? ??(??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //?? ?? 
      L"\xc870\xc9c1\x20\xb2e8\xc704",
      //?? ?? ?? 
      L"\xc870\xc9c1\x20\xad6c\xc131\x20\xb2e8\xc704",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //??? ?? 
      L"\xc778\xc99d\xc11c\x20\xc591\xc2dd",
      //??? ??? 
      L"\xc778\xc99d\xc11c\x20\xd15c\xd50c\xb9bf",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //c,Land (afkorting) 
      L"\x63\x2c\x4c\x61\x6e\x64\x20\x28\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67\x29",
      //c,Landafkorting 
      L"\x63\x2c\x4c\x61\x6e\x64\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,Distinguished name (X500) 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x44\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x20\x6e\x61\x6d\x65\x20\x28\x58\x35\x30\x30\x29",
      //distinguishedName,X500 DN-naam 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x44\x4e\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //division,Divisie 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x65",
      //division,Afdeling 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x66\x64\x65\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,Werknemer-ID 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x57\x65\x72\x6b\x6e\x65\x6d\x65\x72\x2d\x49\x44",
      //employeeID,Medewerkers-id 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x4d\x65\x64\x65\x77\x65\x72\x6b\x65\x72\x73\x2d\x69\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,Naamachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x4e\x61\x61\x6d\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      //generationQualifier,Generatieachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x74\x69\x65\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //homePhone,Telefoonnummer (priv) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePhone,Telefoon (thuis) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x74\x68\x75\x69\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Adres (priv) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePostalAddress,Thuisadres 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x54\x68\x75\x69\x73\x61\x64\x72\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationaal ISDN-nummer (overig) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //internationalISDNNumber,Internationaal ISDN-nummer (overige) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //l,Woonplaats 
      L"\x6c\x2c\x57\x6f\x6f\x6e\x70\x6c\x61\x61\x74\x73",
      //l,Plaats 
      L"\x6c\x2c\x50\x6c\x61\x61\x74\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Groepslidmaatschap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x65\x70\x73\x6c\x69\x64\x6d\x61\x61\x74\x73\x63\x68\x61\x70",
      //memberOf,Lid van 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4c\x69\x64\x20\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //middleName,Tweede voornaam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x54\x77\x65\x65\x64\x65\x20\x76\x6f\x6f\x72\x6e\x61\x61\x6d",
      //middleName,Middelste naam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x4d\x69\x64\x64\x65\x6c\x73\x74\x65\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,Nummer van mobiele telefoon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e",
      //mobile,Mobiel nummer 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //info,Opmerkingen 
      L"\x69\x6e\x66\x6f\x2c\x4f\x70\x6d\x65\x72\x6b\x69\x6e\x67\x65\x6e",
      //info,Notities 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x69\x74\x69\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Faxnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherFacsimileTelephoneNumber,Faxnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefoonnummer priv (overig) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x70\x72\x69\x76\xe9\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherHomePhone,Telefoonnummer thuis (overige) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x74\x68\x75\x69\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP-telefoonnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherIpPhone,IP-telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,E-mailadres (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMailbox,E-mailadres (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,Nummer van mobiele telefoon (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMobile,Mobiel nummer (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,Nummer van pieper (overig) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x69\x65\x70\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherPager,Pagernummer (overige) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefoonnummer zakelijk (overig) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x7a\x61\x6b\x65\x6c\x69\x6a\x6b\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherTelephone,Telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //pager,Nummer van pager 
      L"\x70\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x61\x67\x65\x72",
      //pager,Pagernummer 
      L"\x70\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,Functie 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      //personalTitle,titel 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x74\x69\x74\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Aanmeldingsnaam (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x61\x6e\x6d\x65\x6c\x64\x69\x6e\x67\x73\x6e\x61\x61\x6d\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Aanmeldingsnaam (van voor Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x61\x6e\x6d\x65\x6c\x64\x69\x6e\x67\x73\x6e\x61\x61\x6d\x20\x28\x76\x61\x6e\x20\x76\x6f\x6f\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,Telexnummer (overig) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //telexNumber,Telexnummer (overige) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //title,Functie  
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65\x20",
      //title,Functie 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina (overig) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //url,Adres van website (overige) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //displayName,Weergavenaam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x61\x76\x65\x6e\x61\x61\x6d",
      //displayName,Weergegeven naam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x65\x67\x65\x76\x65\x6e\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adres van webpagina 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //wWWHomePage,Adres van website 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //c,Land (afkorting) 
      L"\x63\x2c\x4c\x61\x6e\x64\x20\x28\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67\x29",
      //c,Landafkorting 
      L"\x63\x2c\x4c\x61\x6e\x64\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,Distinguished name (X500) 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x44\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x20\x6e\x61\x6d\x65\x20\x28\x58\x35\x30\x30\x29",
      //distinguishedName,X500 DN-naam 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x44\x4e\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //l,Woonplaats 
      L"\x6c\x2c\x57\x6f\x6f\x6e\x70\x6c\x61\x61\x74\x73",
      //l,Plaats 
      L"\x6c\x2c\x50\x6c\x61\x61\x74\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //info,Opmerkingen 
      L"\x69\x6e\x66\x6f\x2c\x4f\x70\x6d\x65\x72\x6b\x69\x6e\x67\x65\x6e",
      //info,Notities 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x69\x74\x69\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Groepsnaam (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x6f\x65\x70\x73\x6e\x61\x61\x6d\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Groepsnaam (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x6f\x65\x70\x73\x6e\x61\x61\x6d\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina (overig) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //url,Adres van website (overige) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adres van webpagina 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //wWWHomePage,Adres van website 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Naam 
      L"\x63\x6e\x2c\x4e\x61\x61\x6d",
      //dc,Naam 
      L"\x64\x63\x2c\x4e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,Land (afkorting) 
      L"\x63\x2c\x4c\x61\x6e\x64\x20\x28\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67\x29",
      //c,Landafkorting 
      L"\x63\x2c\x4c\x61\x6e\x64\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //displayName,Weergavenaam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x61\x76\x65\x6e\x61\x61\x6d",
      //displayName,Weergegeven naam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x65\x67\x65\x76\x65\x6e\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,Distinguished name (X500) 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x44\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x20\x6e\x61\x6d\x65\x20\x28\x58\x35\x30\x30\x29",
      //distinguishedName,X500 DN-naam 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x44\x4e\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,Divisie 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x65",
      //division,Afdeling 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x66\x64\x65\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,Werknemer-ID 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x57\x65\x72\x6b\x6e\x65\x6d\x65\x72\x2d\x49\x44",
      //employeeID,Medewerkers-id 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x4d\x65\x64\x65\x77\x65\x72\x6b\x65\x72\x73\x2d\x69\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,Naamachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x4e\x61\x61\x6d\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      //generationQualifier,Generatieachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x74\x69\x65\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePhone,Telefoonnummer (priv) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePhone,Telefoon (thuis) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x74\x68\x75\x69\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Adres (priv) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePostalAddress,Thuisadres 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x54\x68\x75\x69\x73\x61\x64\x72\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //info,Opmerkingen 
      L"\x69\x6e\x66\x6f\x2c\x4f\x70\x6d\x65\x72\x6b\x69\x6e\x67\x65\x6e",
      //info,Notities 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x69\x74\x69\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationaal ISDN-nummer (overig) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //internationalISDNNumber,Internationaal ISDN-nummer (overige) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //l,Woonplaats 
      L"\x6c\x2c\x57\x6f\x6f\x6e\x70\x6c\x61\x61\x74\x73",
      //l,Plaats 
      L"\x6c\x2c\x50\x6c\x61\x61\x74\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Groepslidmaatschap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x65\x70\x73\x6c\x69\x64\x6d\x61\x61\x74\x73\x63\x68\x61\x70",
      //memberOf,Lid van 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4c\x69\x64\x20\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //middleName,Tweede voornaam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x54\x77\x65\x65\x64\x65\x20\x76\x6f\x6f\x72\x6e\x61\x61\x6d",
      //middleName,Middelste naam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x4d\x69\x64\x64\x65\x6c\x73\x74\x65\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,Nummer van mobiele telefoon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e",
      //mobile,Mobiel nummer 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Faxnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherFacsimileTelephoneNumber,Faxnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefoonnummer priv (overig) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x70\x72\x69\x76\xe9\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherHomePhone,Telefoonnummer thuis (overige) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x74\x68\x75\x69\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP-telefoonnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherIpPhone,IP-telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,E-mailadres (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMailbox,E-mailadres (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,Nummer van mobiele telefoon (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMobile,Mobiel nummer (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,Nummer van pieper (overig) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x69\x65\x70\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherPager,Pagernummer (overige) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefoonnummer zakelijk (overig) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x7a\x61\x6b\x65\x6c\x69\x6a\x6b\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherTelephone,Telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //pager,Nummer van pager 
      L"\x70\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x61\x67\x65\x72",
      //pager,Pagernummer 
      L"\x70\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,Functie 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      //personalTitle,titel 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x74\x69\x74\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,Telexnummer (overig) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //telexNumber,Telexnummer (overige) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,Functie  
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65\x20",
      //title,Functie 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina (overig) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //url,Adres van website (overige) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adres van webpagina 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //wWWHomePage,Adres van website 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"computer-Display",
      L"attributeDisplayNames",
      //operatingSystemVersion,Versie van besturingssysteem 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x56\x65\x72\x73\x69\x65\x20\x76\x61\x6e\x20\x62\x65\x73\x74\x75\x72\x69\x6e\x67\x73\x73\x79\x73\x74\x65\x65\x6d",
      //operatingSystemVersion,Operating System Version 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x4f\x70\x65\x72\x61\x74\x69\x6e\x67\x20\x53\x79\x73\x74\x65\x6d\x20\x56\x65\x72\x73\x69\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Computernaam (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x61\x6d\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Computernaam (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x61\x6d\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //cn,Naam van directory-service 
      L"\x63\x6e\x2c\x4e\x61\x61\x6d\x20\x76\x61\x6e\x20\x64\x69\x72\x65\x63\x74\x6f\x72\x79\x2d\x73\x65\x72\x76\x69\x63\x65",
      //cn,Naam van adreslijstservice 
      L"\x63\x6e\x2c\x4e\x61\x61\x6d\x20\x76\x61\x6e\x20\x61\x64\x72\x65\x73\x6c\x69\x6a\x73\x74\x73\x65\x72\x76\x69\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Inventarisnummer 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x76\x65\x6e\x74\x61\x72\x69\x73\x6e\x75\x6d\x6d\x65\x72",
      //assetNumber,Eigenschapsnummer 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x45\x69\x67\x65\x6e\x73\x63\x68\x61\x70\x73\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //driverName,Model 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4d\x6f\x64\x65\x6c",
      //driverName,model 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x6d\x6f\x64\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printBinNames,Invoerladen 
      L"\x70\x72\x69\x6e\x74\x42\x69\x6e\x4e\x61\x6d\x65\x73\x2c\x49\x6e\x76\x6f\x65\x72\x6c\x61\x64\x65\x6e",
      //printBinNames,Invoerlade 
      L"\x70\x72\x69\x6e\x74\x42\x69\x6e\x4e\x61\x6d\x65\x73\x2c\x49\x6e\x76\x6f\x65\x72\x6c\x61\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printCollate,Ondersteuning voor sorteren 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x73\x6f\x72\x74\x65\x72\x65\x6e",
      //printCollate,Ondersteunt sorteren 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x73\x6f\x72\x74\x65\x72\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printColor,Ondersteuning voor kleurafdrukken 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x6b\x6c\x65\x75\x72\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e",
      //printColor,Ondersteunt afdrukken in kleur 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e\x20\x69\x6e\x20\x6b\x6c\x65\x75\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Ondersteuning voor dubbelzijdig afdrukken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x64\x75\x62\x62\x65\x6c\x7a\x69\x6a\x64\x69\x67\x20\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e",
      //printDuplexSupported,Ondersteunt dubbelzijdig afdrukken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x64\x75\x62\x62\x65\x6c\x7a\x69\x6a\x64\x69\x67\x20\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMaxResolutionSupported,Maximumresolutie 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4d\x61\x78\x69\x6d\x75\x6d\x72\x65\x73\x6f\x6c\x75\x74\x69\x65",
      //printMaxResolutionSupported,Maximale resolutie 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4d\x61\x78\x69\x6d\x61\x6c\x65\x20\x72\x65\x73\x6f\x6c\x75\x74\x69\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaSupported,Ondersteunde papiertypen 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x64\x65\x20\x70\x61\x70\x69\x65\x72\x74\x79\x70\x65\x6e",
      //printMediaSupported,Ondersteunde papiersoorten 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x64\x65\x20\x70\x61\x70\x69\x65\x72\x73\x6f\x6f\x72\x74\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printOwner,Naam van eigenaar 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x4e\x61\x61\x6d\x20\x76\x61\x6e\x20\x65\x69\x67\x65\x6e\x61\x61\x72",
      //printOwner,Naam eigenaar 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x4e\x61\x61\x6d\x20\x65\x69\x67\x65\x6e\x61\x61\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printRateUnit,Eenheid van snelheid 
      L"\x70\x72\x69\x6e\x74\x52\x61\x74\x65\x55\x6e\x69\x74\x2c\x45\x65\x6e\x68\x65\x69\x64\x20\x76\x61\x6e\x20\x73\x6e\x65\x6c\x68\x65\x69\x64",
      //printRateUnit,Snelheidseenheden 
      L"\x70\x72\x69\x6e\x74\x52\x61\x74\x65\x55\x6e\x69\x74\x2c\x53\x6e\x65\x6c\x68\x65\x69\x64\x73\x65\x65\x6e\x68\x65\x64\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printShareName,Sharenaam 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x53\x68\x61\x72\x65\x6e\x61\x61\x6d",
      //printShareName,Share-naam 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x53\x68\x61\x72\x65\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printStaplingSupported,Ondersteuning voor nieten 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x6e\x69\x65\x74\x65\x6e",
      //printStaplingSupported,Ondersteunt nieten 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x6e\x69\x65\x74\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //url,Adres van website 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"site-Display",
      L"classDisplayName",
      //Site 
      L"\x53\x69\x74\x65",
      //Website 
      L"\x57\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"siteLink-Display",
      L"classDisplayName",
      //Site-koppeling 
      L"\x53\x69\x74\x65\x2d\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67",
      //Koppeling naar site 
      L"\x4b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x20\x6e\x61\x61\x72\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //Site-koppelingsbrug 
      L"\x53\x69\x74\x65\x2d\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x73\x62\x72\x75\x67",
      //Sitekoppelingsbrug 
      L"\x53\x69\x74\x65\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x73\x62\x72\x75\x67",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"interSiteTransport-Display",
      L"classDisplayName",
      //Intersite-transport 
      L"\x49\x6e\x74\x65\x72\x73\x69\x74\x65\x2d\x74\x72\x61\x6e\x73\x70\x6f\x72\x74",
      //Intersitetransport 
      L"\x49\x6e\x74\x65\x72\x73\x69\x74\x65\x74\x72\x61\x6e\x73\x70\x6f\x72\x74",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //Organisatie-eenheid 
      L"\x4f\x72\x67\x61\x6e\x69\x73\x61\x74\x69\x65\x2d\x65\x65\x6e\x68\x65\x69\x64",
      //Afdeling 
      L"\x41\x66\x64\x65\x6c\x69\x6e\x67",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //Gebruiker met MSMQ-upgrade 
      L"\x47\x65\x62\x72\x75\x69\x6b\x65\x72\x20\x6d\x65\x74\x20\x4d\x53\x4d\x51\x2d\x75\x70\x67\x72\x61\x64\x65",
      //Bijgewerkte MSMQ-gebruiker 
      L"\x42\x69\x6a\x67\x65\x77\x65\x72\x6b\x74\x65\x20\x4d\x53\x4d\x51\x2d\x67\x65\x62\x72\x75\x69\x6b\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //MSMQ-routeringskoppeling 
      L"\x4d\x53\x4d\x51\x2d\x72\x6f\x75\x74\x65\x72\x69\x6e\x67\x73\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67",
      //Koppeling van MSMQ-routering 
      L"\x4b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x20\x76\x61\x6e\x20\x4d\x53\x4d\x51\x2d\x72\x6f\x75\x74\x65\x72\x69\x6e\x67",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"sitesContainer-Display",
      L"classDisplayName",
      //Container voor sites 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x73\x69\x74\x65\x73",
      //Sitecontainer 
      L"\x53\x69\x74\x65\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Container voor intersite-transporten 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x69\x6e\x74\x65\x72\x73\x69\x74\x65\x2d\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x65\x6e",
      //Intersite-transportcontainer 
      L"\x49\x6e\x74\x65\x72\x73\x69\x74\x65\x2d\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"subnetContainer-Display",
      L"classDisplayName",
      //Container voor subnetten 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x73\x75\x62\x6e\x65\x74\x74\x65\x6e",
      //Subnetcontainer 
      L"\x53\x75\x62\x6e\x65\x74\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"serversContainer-Display",
      L"classDisplayName",
      //Container voor servers 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x73\x65\x72\x76\x65\x72\x73",
      //Servercontainer 
      L"\x53\x65\x72\x76\x65\x72\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"queryPolicy-Display",
      L"classDisplayName",
      //Querybeleid 
      L"\x51\x75\x65\x72\x79\x62\x65\x6c\x65\x69\x64",
      //Query-beleid 
      L"\x51\x75\x65\x72\x79\x2d\x62\x65\x6c\x65\x69\x64",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem av 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefon, arbeid (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x2c\x20\x61\x72\x62\x65\x69\x64\x20\x28\x61\x6e\x64\x72\x65\x29",
      //otherTelephone,Telefonnummer (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Navn 
      L"\x63\x6e\x2c\x4e\x61\x76\x6e",
      //dc,Navn 
      L"\x64\x63\x2c\x4e\x61\x76\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem av 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefon, arbeid (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x2c\x20\x61\x72\x62\x65\x69\x64\x20\x28\x61\x6e\x64\x72\x65\x29",
      //otherTelephone,Telefonnummer (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Czlonkostwo grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x6b\x6f\x73\x74\x77\x6f\x20\x67\x72\x75\x70\x79",
      //memberOf,Czlonek grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x65\x6b\x20\x67\x72\x75\x70\x79",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nazwa 
      L"\x63\x6e\x2c\x4e\x61\x7a\x77\x61",
      //dc,Nazwa 
      L"\x64\x63\x2c\x4e\x61\x7a\x77\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Czlonkostwo grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x6b\x6f\x73\x74\x77\x6f\x20\x67\x72\x75\x70\x79",
      //memberOf,Czlonek grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x65\x6b\x20\x67\x72\x75\x70\x79",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //Lacze listy wysylkowej uslugi MSMQ 
      L"\x141\x105\x63\x7a\x65\x20\x6c\x69\x73\x74\x79\x20\x77\x79\x73\x79\x142\x6b\x6f\x77\x65\x6a\x20\x75\x73\x142\x75\x67\x69\x20\x4d\x53\x4d\x51",
      //Lacze routingu uslugi MSMQ 
      L"\x141\x105\x63\x7a\x65\x20\x72\x6f\x75\x74\x69\x6e\x67\x75\x20\x75\x73\x142\x75\x67\x69\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"sitesContainer-Display",
      L"classDisplayName",
      //Kontener witryn 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x77\x69\x74\x72\x79\x6e",
      //Kontener lokacji 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x6c\x6f\x6b\x61\x63\x6a\x69",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Kontener transportu miedzy witrynami 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x75\x20\x6d\x69\x119\x64\x7a\x79\x20\x77\x69\x74\x72\x79\x6e\x61\x6d\x69",
      //Kontener transportu miedzylokacyjnego 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x75\x20\x6d\x69\x119\x64\x7a\x79\x6c\x6f\x6b\x61\x63\x79\x6a\x6e\x65\x67\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //c,Abreviatura do pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\x74\x75\x72\x61\x20\x64\x6f\x20\x70\x61\xed\x73",
      //c,Abreviao de pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\xe7\xe3\x6f\x20\x64\x65\x20\x70\x61\xed\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,Identificao do empregado 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x63\x61\xe7\xe3\x6f\x20\x64\x6f\x20\x65\x6d\x70\x72\x65\x67\x61\x64\x6f",
      //employeeID,Cdigo do Funcionrio 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x43\xf3\x64\x69\x67\x6f\x20\x64\x6f\x20\x46\x75\x6e\x63\x69\x6f\x6e\xe1\x72\x69\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,Sufixo geracional 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      //generationQualifier,Sufixo generativo 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x6e\x65\x72\x61\x74\x69\x76\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //givenName,Prenome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x50\x72\x65\x6e\x6f\x6d\x65",
      //givenName,Nome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,Endereo de correio eletrnico 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f",
      //mail,End. de email 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x2e\x20\x64\x65\x20\x65\x6d\x61\x69\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Participao no grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\xe7\xe3\x6f\x20\x6e\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Participante de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\x6e\x74\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Nmero de telefone residencial (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x72\x65\x73\x69\x64\x65\x6e\x63\x69\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherHomePhone,Nmero de telefone de casa (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x64\x65\x20\x63\x61\x73\x61\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherIpPhone,Nmero do telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,Endereo de correio eletrnico (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherMailbox,Endereo de email (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x65\x6d\x61\x69\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Nmero de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherTelephone,N de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xba\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Endereo comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      //physicalDeliveryOfficeName,End. comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x2e\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //st,UF 
      L"\x73\x74\x2c\x55\x46",
      //st,Estado/provncia 
      L"\x73\x74\x2c\x45\x73\x74\x61\x64\x6f\x2f\x70\x72\x6f\x76\xed\x6e\x63\x69\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //telephoneNumber,Nmero do telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65",
      //telephoneNumber,Telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //url,Endereo da pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x61\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Endereo de pgina da Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //wWWHomePage,Endereo na Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //c,Abreviatura do pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\x74\x75\x72\x61\x20\x64\x6f\x20\x70\x61\xed\x73",
      //c,Abreviao de pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\xe7\xe3\x6f\x20\x64\x65\x20\x70\x61\xed\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Endereo comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      //physicalDeliveryOfficeName,End. comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x2e\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //url,Endereo da pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x61\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Endereo de pgina da Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //wWWHomePage,Endereo na Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nome 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x65",
      //dc,Nome 
      L"\x64\x63\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,Abreviatura do pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\x74\x75\x72\x61\x20\x64\x6f\x20\x70\x61\xed\x73",
      //c,Abreviao de pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\xe7\xe3\x6f\x20\x64\x65\x20\x70\x61\xed\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,Identificao do empregado 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x63\x61\xe7\xe3\x6f\x20\x64\x6f\x20\x65\x6d\x70\x72\x65\x67\x61\x64\x6f",
      //employeeID,Cdigo do Funcionrio 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x43\xf3\x64\x69\x67\x6f\x20\x64\x6f\x20\x46\x75\x6e\x63\x69\x6f\x6e\xe1\x72\x69\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,Sufixo geracional 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      //generationQualifier,Sufixo generativo 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x6e\x65\x72\x61\x74\x69\x76\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //givenName,Prenome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x50\x72\x65\x6e\x6f\x6d\x65",
      //givenName,Nome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,Endereo de correio eletrnico 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f",
      //mail,End. de email 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x2e\x20\x64\x65\x20\x65\x6d\x61\x69\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Participao no grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\xe7\xe3\x6f\x20\x6e\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Participante de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\x6e\x74\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Nmero de telefone residencial (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x72\x65\x73\x69\x64\x65\x6e\x63\x69\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherHomePhone,Nmero de telefone de casa (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x64\x65\x20\x63\x61\x73\x61\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherIpPhone,Nmero do telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,Endereo de correio eletrnico (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherMailbox,Endereo de email (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x65\x6d\x61\x69\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Nmero de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherTelephone,N de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xba\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Endereo comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      //physicalDeliveryOfficeName,End. comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x2e\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //st,UF 
      L"\x73\x74\x2c\x55\x46",
      //st,Estado/provncia 
      L"\x73\x74\x2c\x45\x73\x74\x61\x64\x6f\x2f\x70\x72\x6f\x76\xed\x6e\x63\x69\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //telephoneNumber,Nmero do telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65",
      //telephoneNumber,Telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //url,Endereo da pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x61\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Endereo de pgina da Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //wWWHomePage,Endereo na Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"computer-Display",
      L"attributeDisplayNames",
      //operatingSystemVersion,Verso do sistema operacional 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x56\x65\x72\x73\xe3\x6f\x20\x64\x6f\x20\x73\x69\x73\x74\x65\x6d\x61\x20\x6f\x70\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      //operatingSystemVersion,Verso do sist. operacional 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x56\x65\x72\x73\xe3\x6f\x20\x64\x6f\x20\x73\x69\x73\x74\x2e\x20\x6f\x70\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Nome do computador (anterior ao Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65\x20\x64\x6f\x20\x63\x6f\x6d\x70\x75\x74\x61\x64\x6f\x72\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x6f\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nome comput. (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65\x20\x63\x6f\x6d\x70\x75\x74\x2e\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Nmero do ativo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x61\x74\x69\x76\x6f",
      //assetNumber,Nmero do recurso 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x72\x65\x63\x75\x72\x73\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printCollate,Fornece suporte a intercalao 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6e\x74\x65\x72\x63\x61\x6c\x61\xe7\xe3\x6f",
      //printCollate,Suporte a emulao 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x65\x6d\x75\x6c\x61\xe7\xe3\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printColor,Fornece suporte a impresso colorida 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x63\x6f\x6c\x6f\x72\x69\x64\x61",
      //printColor,Suporte a impresso a cores 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x61\x20\x63\x6f\x72\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Fornece suporte a impresso dos dois lados 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x64\x6f\x73\x20\x64\x6f\x69\x73\x20\x6c\x61\x64\x6f\x73",
      //printDuplexSupported,Suporte a impresso frente e verso 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x66\x72\x65\x6e\x74\x65\x20\x65\x20\x76\x65\x72\x73\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printLanguage,Linguagem de impresso 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x4c\x69\x6e\x67\x75\x61\x67\x65\x6d\x20\x64\x65\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f",
      //printLanguage,Idioma da impressora 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x49\x64\x69\x6f\x6d\x61\x20\x64\x61\x20\x69\x6d\x70\x72\x65\x73\x73\x6f\x72\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaSupported,Tipos de papel para os quais h suporte 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x54\x69\x70\x6f\x73\x20\x64\x65\x20\x70\x61\x70\x65\x6c\x20\x70\x61\x72\x61\x20\x6f\x73\x20\x71\x75\x61\x69\x73\x20\x68\xe1\x20\x73\x75\x70\x6f\x72\x74\x65",
      //printMediaSupported,Tipos de papel permitidos 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x54\x69\x70\x6f\x73\x20\x64\x65\x20\x70\x61\x70\x65\x6c\x20\x70\x65\x72\x6d\x69\x74\x69\x64\x6f\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printStaplingSupported,Fornece suporte a grampeamento 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x67\x72\x61\x6d\x70\x65\x61\x6d\x65\x6e\x74\x6f",
      //printStaplingSupported,Suporte a grampeamento 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x67\x72\x61\x6d\x70\x65\x61\x6d\x65\x6e\x74\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //url,Endereo na Web 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTDSDSA-Display",
      L"classDisplayName",
      //Configuraes do controlador de domnio 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x63\x6f\x6e\x74\x72\x6f\x6c\x61\x64\x6f\x72\x20\x64\x65\x20\x64\x6f\x6d\xed\x6e\x69\x6f",
      //Configuraes do controlador do domnio 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x63\x6f\x6e\x74\x72\x6f\x6c\x61\x64\x6f\x72\x20\x64\x6f\x20\x64\x6f\x6d\xed\x6e\x69\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSSettings-Display",
      L"classDisplayName",
      //Configuraes do servio de duplicao de arquivos 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Configuraes FRS 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSReplicaSet-Display",
      L"classDisplayName",
      //Conjunto de rplicas do servio de duplicao de arquivos 
      L"\x43\x6f\x6e\x6a\x75\x6e\x74\x6f\x20\x64\x65\x20\x72\xe9\x70\x6c\x69\x63\x61\x73\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Conjunto de rplicas FRS 
      L"\x43\x6f\x6e\x6a\x75\x6e\x74\x6f\x20\x64\x65\x20\x72\xe9\x70\x6c\x69\x63\x61\x73\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"siteLink-Display",
      L"classDisplayName",
      //Link do site 
      L"\x4c\x69\x6e\x6b\x20\x64\x6f\x20\x73\x69\x74\x65",
      //Link de site 
      L"\x4c\x69\x6e\x6b\x20\x64\x65\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //Ponte de links do site 
      L"\x50\x6f\x6e\x74\x65\x20\x64\x65\x20\x6c\x69\x6e\x6b\x73\x20\x64\x6f\x20\x73\x69\x74\x65",
      //Ponte de link de site 
      L"\x50\x6f\x6e\x74\x65\x20\x64\x65\x20\x6c\x69\x6e\x6b\x20\x64\x65\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"licensingSiteSettings-Display",
      L"classDisplayName",
      //Configuraes do site de licenciamento 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x73\x69\x74\x65\x20\x64\x65\x20\x6c\x69\x63\x65\x6e\x63\x69\x61\x6d\x65\x6e\x74\x6f",
      //Configuraes de site de licenciamento 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x65\x20\x73\x69\x74\x65\x20\x64\x65\x20\x6c\x69\x63\x65\x6e\x63\x69\x61\x6d\x65\x6e\x74\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTDSSiteSettings-Display",
      L"classDisplayName",
      //Configuraes do site 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x73\x69\x74\x65",
      //Definies de site 
      L"\x44\x65\x66\x69\x6e\x69\xe7\xf5\x65\x73\x20\x64\x65\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSMember-Display",
      L"classDisplayName",
      //Participante do servio de replicao de arquivos 
      L"\x50\x61\x72\x74\x69\x63\x69\x70\x61\x6e\x74\x65\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x72\x65\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Membro FRS 
      L"\x4d\x65\x6d\x62\x72\x6f\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSSubscriber-Display",
      L"classDisplayName",
      //Assinante do servio de duplicao de arquivos 
      L"\x41\x73\x73\x69\x6e\x61\x6e\x74\x65\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Assinante FRS 
      L"\x41\x73\x73\x69\x6e\x61\x6e\x74\x65\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSSubscriptions-Display",
      L"classDisplayName",
      //Assinaturas do servio de duplicao de arquivos 
      L"\x41\x73\x73\x69\x6e\x61\x74\x75\x72\x61\x73\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Assinaturas FRS 
      L"\x41\x73\x73\x69\x6e\x61\x74\x75\x72\x61\x73\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"rpcContainer-Display",
      L"classDisplayName",
      //Servios de chamada a procedimentos remotos 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x73\x20\x64\x65\x20\x63\x68\x61\x6d\x61\x64\x61\x20\x61\x20\x70\x72\x6f\x63\x65\x64\x69\x6d\x65\x6e\x74\x6f\x73\x20\x72\x65\x6d\x6f\x74\x6f\x73",
      //Servios de chamada de procedimento remoto 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x73\x20\x64\x65\x20\x63\x68\x61\x6d\x61\x64\x61\x20\x64\x65\x20\x70\x72\x6f\x63\x65\x64\x69\x6d\x65\x6e\x74\x6f\x20\x72\x65\x6d\x6f\x74\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //Empreendimento MSMQ 
      L"\x45\x6d\x70\x72\x65\x65\x6e\x64\x69\x6d\x65\x6e\x74\x6f\x20\x4d\x53\x4d\x51",
      //MSMQ corporativa 
      L"\x4d\x53\x4d\x51\x20\x63\x6f\x72\x70\x6f\x72\x61\x74\x69\x76\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //Usurio atualizado MSMQ 
      L"\x55\x73\x75\xe1\x72\x69\x6f\x20\x61\x74\x75\x61\x6c\x69\x7a\x61\x64\x6f\x20\x4d\x53\x4d\x51",
      //Usurio atualizado do MSMQ 
      L"\x55\x73\x75\xe1\x72\x69\x6f\x20\x61\x74\x75\x61\x6c\x69\x7a\x61\x64\x6f\x20\x64\x6f\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //Link de roteamento MSMQ 
      L"\x4c\x69\x6e\x6b\x20\x64\x65\x20\x72\x6f\x74\x65\x61\x6d\x65\x6e\x74\x6f\x20\x4d\x53\x4d\x51",
      //Link de roteamento do servio de enfileiramento de mensagens da Microsoft 
      L"\x4c\x69\x6e\x6b\x20\x64\x65\x20\x72\x6f\x74\x65\x61\x6d\x65\x6e\x74\x6f\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x65\x6e\x66\x69\x6c\x65\x69\x72\x61\x6d\x65\x6e\x74\x6f\x20\x64\x65\x20\x6d\x65\x6e\x73\x61\x67\x65\x6e\x73\x20\x64\x61\x20\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTDSService-Display",
      L"classDisplayName",
      //Servio Active Directory 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      //Servio do Active Directory 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x20\x64\x6f\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Principal segurana externa 
      L"\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x20\x73\x65\x67\x75\x72\x61\x6e\xe7\x61\x20\x65\x78\x74\x65\x72\x6e\x61",
      //Objeto de segurana externo 
      L"\x4f\x62\x6a\x65\x74\x6f\x20\x64\x65\x20\x73\x65\x67\x75\x72\x61\x6e\xe7\x61\x20\x65\x78\x74\x65\x72\x6e\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"user-Display",
      L"attributeDisplayNames",
      //department,????????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b\x435\x43d\x438\x435",
      //department,????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,???????? ? ??????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x441\x442\x432\x43e\x20\x432\x20\x433\x440\x443\x43f\x43f\x430\x445",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x20\x433\x440\x443\x43f\x43f\x44b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?????? ??? 
      L"\x63\x6e\x2c\x41f\x43e\x43b\x43d\x43e\x435\x20\x438\x43c\x44f",
      //dc,?????? ??? 
      L"\x64\x63\x2c\x41f\x43e\x43b\x43d\x43e\x435\x20\x438\x43c\x44f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"contact-Display",
      L"attributeDisplayNames",
      //department,????????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b\x435\x43d\x438\x435",
      //department,????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,???????? ? ??????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x441\x442\x432\x43e\x20\x432\x20\x433\x440\x443\x43f\x43f\x430\x445",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x20\x433\x440\x443\x43f\x43f\x44b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"nTDSService-Display",
      L"classDisplayName",
      //?????? ????????? Active Directory 
      L"\x421\x43b\x443\x436\x431\x430\x20\x43a\x430\x442\x430\x43b\x43e\x433\x43e\x432\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      //?????? Active Directory 
      L"\x421\x43b\x443\x436\x431\x430\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"user-Display",
      L"attributeDisplayNames",
      //division,Division 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x6f\x6e",
      //division,Avdelning 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x76\x64\x65\x6c\x6e\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppmedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem i 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x69",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Namn 
      L"\x63\x6e\x2c\x4e\x61\x6d\x6e",
      //dc,Namn 
      L"\x64\x63\x2c\x4e\x61\x6d\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,Division 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x6f\x6e",
      //division,Avdelning 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x76\x64\x65\x6c\x6e\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppmedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem i 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x69",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"computer-Display",
      L"classDisplayName",
      //Dator 
      L"\x44\x61\x74\x6f\x72",
      //computer 
      L"\x63\x6f\x6d\x70\x75\x74\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Grup yeligi 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x20\xdc\x79\x65\x6c\x69\x11f\x69",
      //memberOf,yesi olunan gruplar 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xdc\x79\x65\x73\x69\x20\x6f\x6c\x75\x6e\x61\x6e\x20\x67\x72\x75\x70\x6c\x61\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,nvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xdc\x6e\x76\x61\x6e",
      //personalTitle,Unvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x55\x6e\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Adi 
      L"\x63\x6e\x2c\x41\x64\x131",
      //dc,Adi 
      L"\x64\x63\x2c\x41\x64\x131",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Grup yeligi 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x20\xdc\x79\x65\x6c\x69\x11f\x69",
      //memberOf,yesi olunan gruplar 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xdc\x79\x65\x73\x69\x20\x6f\x6c\x75\x6e\x61\x6e\x20\x67\x72\x75\x70\x6c\x61\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,nvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xdc\x6e\x76\x61\x6e",
      //personalTitle,Unvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x55\x6e\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"serviceAdministrationPoint-Display",
      L"classDisplayName",
      //Hizmet 
      L"\x48\x69\x7a\x6d\x65\x74",
      //Active Directory Hizmeti 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x48\x69\x7a\x6d\x65\x74\x69",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Yabanci Gvenlik Ilkesi 
      L"\x59\x61\x62\x61\x6e\x63\x131\x20\x47\xfc\x76\x65\x6e\x6c\x69\x6b\x20\x130\x6c\x6b\x65\x73\x69",
      //Yabanci Gvenlik Sorumlusu 
      L"\x59\x61\x62\x61\x6e\x63\x131\x20\x47\xfc\x76\x65\x6e\x6c\x69\x6b\x20\x53\x6f\x72\x75\x6d\x6c\x75\x73\x75",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x7279\x5f02\x540d\x79f0",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x522b\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7ec4\x6210\x5458",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6210\x5458\x8eab\x4efd\x5c5e\x4e8e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherFacsimileTelephoneNumber,????(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherHomePhone,??????(??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ???? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherIpPhone,IP ????(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //otherMailbox,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherMobile,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,???? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherPager,????(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherTelephone,????(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,??? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5f55\x540d\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      //samAccountName,???(Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5f55\x540d\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,???? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //telexNumber,????(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //url,???? (??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //url,????(??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x7279\x5f02\x540d\x79f0",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x522b\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,?? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7ec4\x540d\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      //samAccountName,??(Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7ec4\x540d\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"group-Display",
      L"attributeDisplayNames",
      //url,???? (??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //url,????(??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x540d\x79f0",
      //dc,?? 
      L"\x64\x63\x2c\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x7279\x5f02\x540d\x79f0",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x522b\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,?? ISDN ?? (??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x56fd\x9645\x20\x49\x53\x44\x4e\x20\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //internationalISDNNumber,?? ISDN ??(??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x56fd\x9645\x20\x49\x53\x44\x4e\x20\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7ec4\x6210\x5458",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6210\x5458\x8eab\x4efd\x5c5e\x4e8e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherFacsimileTelephoneNumber,????(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherHomePhone,??????(??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ???? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherIpPhone,IP ????(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //otherMailbox,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherMobile,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,???? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherPager,????(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherTelephone,????(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,???? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //telexNumber,????(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,???? (??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //url,????(??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"classDisplayName",
      //??? 
      L"\x8054\x7edc\x4eba",
      //??? 
      L"\x8054\x7cfb\x4eba",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x8ba1\x7b97\x673a\x540d\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      //samAccountName,????(Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x8ba1\x7b97\x673a\x540d\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x8054\x7edc\x4eba",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x8054\x7cfb\x4eba",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //???? 
      L"\x8bc1\x4e66\x6478\x677f",
      //???? 
      L"\x8bc1\x4e66\x6a21\x677f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Membro do grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Membro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nome 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x65",
      //dc,Nome 
      L"\x64\x63\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Membro do grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Membro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"site-Display",
      L"classDisplayName",
      //Site 
      L"\x53\x69\x74\x65",
      //Local 
      L"\x4c\x6f\x63\x61\x6c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"queryPolicy-Display",
      L"classDisplayName",
      //Poltica de consultas 
      L"\x50\x6f\x6c\xed\x74\x69\x63\x61\x20\x64\x65\x20\x63\x6f\x6e\x73\x75\x6c\x74\x61\x73",
      //Poltica de consulta 
      L"\x50\x6f\x6c\xed\x74\x69\x63\x61\x20\x64\x65\x20\x63\x6f\x6e\x73\x75\x6c\x74\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Pertenencia a grupos 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x65\x72\x74\x65\x6e\x65\x6e\x63\x69\x61\x20\x61\x20\x67\x72\x75\x70\x6f\x73",
      //memberOf,Miembro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Nombre de inicio de sesin (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x69\x6e\x69\x63\x69\x6f\x20\x64\x65\x20\x73\x65\x73\x69\xf3\x6e\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nombre de inicio de sesin (anterior a Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x69\x6e\x69\x63\x69\x6f\x20\x64\x65\x20\x73\x65\x73\x69\xf3\x6e\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Nombre del grupo (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x67\x72\x75\x70\x6f\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nombre del grupo (anterior a Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x67\x72\x75\x70\x6f\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nombre 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x62\x72\x65",
      //dc,Nombre 
      L"\x64\x63\x2c\x4e\x6f\x6d\x62\x72\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Pertenencia a grupos 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x65\x72\x74\x65\x6e\x65\x6e\x63\x69\x61\x20\x61\x20\x67\x72\x75\x70\x6f\x73",
      //memberOf,Miembro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Nombre de equipo (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x65\x71\x75\x69\x70\x6f\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nombre del equipo (anterior a Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x65\x71\x75\x69\x70\x6f\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Nmero de activo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x61\x63\x74\x69\x76\x6f",
      //assetNumber,Nmero de inventario 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x69\x6e\x76\x65\x6e\x74\x61\x72\x69\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printLanguage,Lenguaje de la impresora 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x4c\x65\x6e\x67\x75\x61\x6a\x65\x20\x64\x65\x20\x6c\x61\x20\x69\x6d\x70\x72\x65\x73\x6f\x72\x61",
      //printLanguage,Idioma de impresin 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x49\x64\x69\x6f\x6d\x61\x20\x64\x65\x20\x69\x6d\x70\x72\x65\x73\x69\xf3\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //serverName,Nombre de servidor 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x73\x65\x72\x76\x69\x64\x6f\x72",
      //serverName,Nombre del servidor 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x73\x65\x72\x76\x69\x64\x6f\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"trustedDomain-Display",
      L"classDisplayName",
      //Dominio en que se confa 
      L"\x44\x6f\x6d\x69\x6e\x69\x6f\x20\x65\x6e\x20\x71\x75\x65\x20\x73\x65\x20\x63\x6f\x6e\x66\xed\x61",
      //Dominio de confianza 
      L"\x44\x6f\x6d\x69\x6e\x69\x6f\x20\x64\x65\x20\x63\x6f\x6e\x66\x69\x61\x6e\x7a\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"volume-Display",
      L"attributeDisplayNames",
      //uNCName,Ruta de red 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x52\x75\x74\x61\x20\x64\x65\x20\x72\x65\x64",
      //uNCName,Ruta de acceso a la red 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x52\x75\x74\x61\x20\x64\x65\x20\x61\x63\x63\x65\x73\x6f\x20\x61\x20\x6c\x61\x20\x72\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"mSMQQueue-Display",
      L"classDisplayName",
      //Cola MSMQ 
      L"\x43\x6f\x6c\x61\x20\x4d\x53\x4d\x51",
      //Cola de MSMQ 
      L"\x43\x6f\x6c\x61\x20\x64\x65\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,Ad&ministrar...,RsAdmin.msc 
      L"\x30\x2c\x41\x64\x26\x6d\x69\x6e\x69\x73\x74\x72\x61\x72\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&Administrar...,RsAdmin.msc 
      L"\x30\x2c\x26\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x72\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"nTDSService-Display",
      L"classDisplayName",
      //Servicio de Active Directory 
      L"\x53\x65\x72\x76\x69\x63\x69\x6f\x20\x64\x65\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      //Servicios de Active Directory 
      L"\x53\x65\x72\x76\x69\x63\x69\x6f\x73\x20\x64\x65\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Principal de seguridad externa 
      L"\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x20\x64\x65\x20\x73\x65\x67\x75\x72\x69\x64\x61\x64\x20\x65\x78\x74\x65\x72\x6e\x61",
      //Entidad principal de seguridad externa 
      L"\x45\x6e\x74\x69\x64\x61\x64\x20\x70\x72\x69\x6e\x63\x69\x70\x61\x6c\x20\x64\x65\x20\x73\x65\x67\x75\x72\x69\x64\x61\x64\x20\x65\x78\x74\x65\x72\x6e\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );
   addChange
   (  guids[0],
      0x409,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber, International ISDN Number (Others) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x49\x53\x44\x4e\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      //internationalISDNNumber,International ISDN Number (Others) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x49\x53\x44\x4e\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Group Membership 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x75\x70\x20\x4d\x65\x6d\x62\x65\x72\x73\x68\x69\x70",
      //memberOf,Member Of 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x65\x72\x20\x4f\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Home Phone (Others) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x48\x6f\x6d\x65\x20\x50\x68\x6f\x6e\x65\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      //otherHomePhone,Home Phone Number (Others) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x48\x6f\x6d\x65\x20\x50\x68\x6f\x6e\x65\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Name 
      L"\x63\x6e\x2c\x4e\x61\x6d\x65",
      //dc,Name 
      L"\x64\x63\x2c\x4e\x61\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Group Membership 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x75\x70\x20\x4d\x65\x6d\x62\x65\x72\x73\x68\x69\x70",
      //memberOf,Member Of 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x65\x72\x20\x4f\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"nTDSService-Display",
      L"classDisplayName",
      //Service 
      L"\x53\x65\x72\x76\x69\x63\x65",
      //Active Directory Service 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x53\x65\x72\x76\x69\x63\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\constants.cpp ===
#include "headers.hxx"
#include "constants.hpp"
#include "global.hpp"
#include "AnalysisResults.hpp"
#include "CSVDSReader.hpp"
#include <set>

using namespace std;



// Burnslib globals

//This should be declared before any static String
DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;


HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"dspecup";

// Used to hold the latest error
String error;

// Used in WinGetVLFilePointer.
LARGE_INTEGER zero={0};


// Variables kept from analysis to repair
bool goodAnalysis=false;
AnalysisResults results;
String targetDomainControllerName;
String csvFileName,csv409Name;
CSVDSReader csvReaderIntl;
CSVDSReader csvReader409;
String rootContainerDn,ldapPrefix,domainName;
String completeDcName;

//other variables and constants

const long LOCALE409[] = {0x409,0};

const long LOCALEIDS[] =
{
   // a list of all the non-english locale IDs that we support
   
   0x401,
   0x404,
   0x405,
   0x406,
   0x407,
   0x408,
   0x40b,
   0x40c,
   0x40d,
   0x40e,
   0x410,
   0x411,
   0x412,
   0x413,
   0x414,
   0x415,
   0x416,
   0x419,
   0x41d,
   0x41f,
   0x804,
   0x816,
   0xc0a,
   0
};





void addChange
(
   const GUID                 guid,
   const long                 locale,
   const wchar_t              *object,
   const wchar_t              *property,
   const wchar_t              *firstArg,
   const wchar_t              *secondArg,
   const enum TYPE_OF_CHANGE  type
)
{
   sChange tempChange;

   tempChange.object=object;
   tempChange.property=property;
   tempChange.firstArg=firstArg;
   tempChange.secondArg=secondArg;
   tempChange.type=type;
   changes[guid][locale].push_back(tempChange);
}


allChanges changes;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\analysis.hpp ===
// Class to perform tha analisys
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios


#ifndef ANALYSIS_HPP
#define ANALYSIS_HPP




#include  "AnalysisResults.hpp"
#include  "dspecup.hpp"
#include  "constants.hpp"

class CSVDSReader;
struct sChangeList;


class Analysis
{

public:
   Analysis(   
               const             GUID guid_,
               const             CSVDSReader& csvReader409_,
               const             CSVDSReader& csvReaderIntl_,
               const             String& ldapPrefix_,
               const             String& rootContainerDn_,
               AnalysisResults   &res,
               const String      &reportName_=L"", 
               void              *caleeStruct_=NULL,
               progressFunction  stepIt_=NULL,
               progressFunction  totalSteps_=NULL
            );
   

   HRESULT run();

private:
 

   const CSVDSReader& csvReader409;
   const CSVDSReader& csvReaderIntl;
   String ldapPrefix;
   String rootContainerDn;
   AnalysisResults& results;
   String reportName;
   void *caleeStruct;
   progressFunction stepIt;
   progressFunction totalSteps;
   GUID guid;
   

  
   // add entry to result.createContainers if container is not present
   // also returns flag isPresent
   HRESULT 
   dealWithContainer
   (
      const long  locale,
      bool        &isPresent
   );

   // add entries to results.createW2KObjects and
   // and results.objectActions as necessary
   HRESULT 
   dealWithW2KObjects(const long locale);

   // sets  iDirObj with the Active Directory object 
   // corresponding to the locale and object
   HRESULT
   getADObj
   (
      const long locale,
      const String& object,
      SmartInterface<IDirectoryObject> &iDirObj
   );

   
   // adds ordAndGuid to the property if Guid is not already there.
   HRESULT 
   addGuid
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property, 
      const String         &ordAndGuid
   );

   // replaces ordAndGuidWin2K for  ordAndGuidWhistler.
   HRESULT 
   replaceGuid
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property, 
      const String         &ordAndGuidWin2K,
      const String         &ordAndGuidWhistler
   );

   // adds all csv values still not on the property
   HRESULT
   addAllCsvValues
   (
      IDirectoryObject     *iDirObj,
      const long           locale,
      const String         &object, 
      const String         &property
   );

   // adds value to the property if it is not already there. 
   HRESULT 
   addValue
   (
      IDirectoryObject     *iDirObj,
      const long           locale,
      const String         &object, 
      const String         &property,
      const String         &value
   );
   


   HRESULT 
   replaceW2KSingleValue
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &WhistlerStart,
      const String         &W2KStart
   );


   HRESULT 
   replaceW2KMultipleValue
   (
         IDirectoryObject     *iDirObj,
         const int            locale,
         const String         &object, 
         const String         &property,
         const String         &W2KCsvValue,
         const String         &WhistlerCsvValue
   );
   
   // removes ordAndGuid from the property if Guid is there. 
   HRESULT 
   removeGuid(
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &ordAndGuid);

   // set previousSuccessfulRun reading from ADSI
   HRESULT 
   setPreviousSuccessfullRun();

   // check all changes for the given locale
   HRESULT 
   checkChanges
   (
      const long locale,
      const changeList& changes
   ); 


   HRESULT
   getADFirstValue
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      String               &value
   );

   HRESULT
   isADStartValuePresent
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      const String         &valueStart,
      String               &value
   );

   HRESULT
   isADValuePresent
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      const String         &value
   );

   HRESULT
   getADGuid
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      const String         &guidValue,
      String               &guidFound
   );

   HRESULT
   removeExtraneous
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &keeper
   );

   HRESULT
   removeExtraneous
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &keeper,
      const String         &start1,
      const String         &start2
   );

   HRESULT
   removeExtraneousGUID
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &keeper,
      const String         &ordAndGuid1,
      const String         &ordAndGuid2
   );


   HRESULT 
   reportObjects
   (
      HANDLE file,
      const ObjectIdList &list,
      const String &header
   );


   HRESULT 
   reportContainers
   (
      HANDLE file,
      const LongList &list,
      const String &header
   );

   HRESULT 
   reportActions
   (
      HANDLE file,
      const ObjectActions &list,
      const String &header
   );

   HRESULT 
   reportValues
   (
      HANDLE file,
      const SingleValueList &list,
      const String &header
   );

   HRESULT
   createReport(const String& reportName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\constants.hpp ===
// Basic constants and structures
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#ifndef CONSTANTS_HPP
#define CONSTANTS_HPP

#include <stdlib.h>
#include <set>

struct AnalysisResults;
class CSVDSReader;

using namespace std;

// Variables kept from analysis to repair
extern bool goodAnalysis;
extern AnalysisResults results;
extern String targetDomainControllerName;
extern String completeDcName;
extern String csvFileName;
extern String csv409Name;
extern CSVDSReader csvReaderIntl;
extern CSVDSReader csvReader409;
extern String rootContainerDn;
extern String ldapPrefix;
extern String domainName;

// Used to hold the latest error
extern String error;

// Used in WinGetVLFilePointer. Declared in constants.cpp as ={0};
extern LARGE_INTEGER zero;

enum TYPE_OF_CHANGE 
{
   // NOP stands for no operation.
   // It gives an alternative way to limit the
   // enumeration of CHANGE_LIST
   NOP,
   ADD_ALL_CSV_VALUES, 
   ADD_VALUE,
   ADD_GUID, 
   REPLACE_W2K_SINGLE_VALUE, 
   REPLACE_W2K_MULTIPLE_VALUE,
   REMOVE_GUID,
   REPLACE_GUID,
   ADD_OBJECT

};

struct sChange
{
   String object;
   String property;
   String firstArg;
   String secondArg;
   TYPE_OF_CHANGE type;
};

typedef list < 
               sChange,
               Burnslib::Heap::Allocator< sChange > 
             > changeList;


typedef map <
               long, // locale
               changeList,
               less< long > ,
               Burnslib::Heap::Allocator< changeList > 
             > objectChanges;

// designed to be used as a less<GUID> operator in a map like 
// std::map< GUID,abc,GUIDLess<GUID> > mpGUID;
template<class T>
struct GUIDLess 
{
    bool operator()(const T& x, const T& y) const
    {
        if(x.Data1    != y.Data1)    return (x.Data1    < y.Data1);
        if(x.Data2    != y.Data2)    return (x.Data2    < y.Data2);
        if(x.Data3    != y.Data3)    return (x.Data3    < y.Data3);
        if(x.Data4[0] != y.Data4[0]) return (x.Data4[0] < y.Data4[0]);
        if(x.Data4[1] != y.Data4[1]) return (x.Data4[1] < y.Data4[1]);
        if(x.Data4[2] != y.Data4[2]) return (x.Data4[2] < y.Data4[2]);
        if(x.Data4[3] != y.Data4[3]) return (x.Data4[3] < y.Data4[3]);
        if(x.Data4[4] != y.Data4[4]) return (x.Data4[4] < y.Data4[4]);
        if(x.Data4[5] != y.Data4[5]) return (x.Data4[5] < y.Data4[5]);
        if(x.Data4[6] != y.Data4[6]) return (x.Data4[6] < y.Data4[6]);
        return (x.Data4[7] < y.Data4[7]);
    }
};


typedef map < 
                GUID,
                objectChanges,
                GUIDLess<GUID>,
                Burnslib::Heap::Allocator<objectChanges>
            > allChanges;

extern allChanges changes;


extern const long LOCALEIDS[];
extern const long LOCALE409[];

void addChange
(
   const GUID                 guid,
   const long                 locale,
   const wchar_t              *object,
   const wchar_t              *property,
   const wchar_t              *firstArg,
   const wchar_t              *secondArg,
   const enum TYPE_OF_CHANGE  type
);

// implemented in guids.cpp
void setChanges();

extern GUID guids[];


#endif;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\dspecup.hpp ===
// Dspecup.lib interface
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#ifndef DSPECUP_HPP
#define DSPECUP_HPP

extern "C"
{
   typedef void (*progressFunction)(long arg, void *calleeStruct);

   HRESULT 
   UpgradeDisplaySpecifiers 
   (
         PWSTR logFilesPath,
         GUID  *OperationGuid,
         BOOL dryRun,
         PWSTR *errorMsg=NULL,
         void *caleeStruct=NULL,
         progressFunction stepIt=NULL,
         progressFunction totalSteps=NULL
   );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\csvdsreader.cpp ===
#include "headers.hxx"
#include "CSVDSReader.hpp"
#include "resourceDspecup.h"
#include "constants.hpp"
#include "global.hpp"


#include <stdio.h> 
#include <crtdbg.h>



CSVDSReader::CSVDSReader():file(INVALID_HANDLE_VALUE)
{
   canCallGetNext=false;
}


HRESULT 
CSVDSReader::read(
                  const wchar_t  *fileName_,
                  const long *locales)
{
   
   LOG_FUNCTION(CSVDSReader::read);
   
   localeOffsets.clear();
   propertyPositions.clear();
   
   fileName=fileName_;
   
   HRESULT hr=S_OK;
   
   do
   {
      // fill localeOffsets and property positions
      if(!FS::FileExists(fileName)) 
      {
         error = String::format(IDS_COULD_NOT_FIND_FILE,
                                                   fileName.c_str());
         hr=E_FAIL;
         break;
      }
      
      
      hr=FS::CreateFile(fileName,file,GENERIC_READ,FILE_SHARE_READ);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      do
      {
         AnsiString unicodeId;
         hr=FS::Read(file, 2, unicodeId);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         if (unicodeId[0]!='\xFF' || unicodeId[1]!='\xFE')
         {
            error = String::format(IDS_INVALID_CSV_UNICODE_ID,
                                                   fileName.c_str());
            hr=E_FAIL;
            break;
         }

         hr=parseProperties();
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=parseLocales(locales);
         BREAK_ON_FAILED_HRESULT(hr);
         
      } while(0);
      
      if (FAILED(hr))
      {
         CloseHandle(file);
         file=INVALID_HANDLE_VALUE;
         break;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}




// Decode first line of the file building propertyPositions
// Expects file to be in the first valid file character (after
//   the unicode identifier)
HRESULT CSVDSReader::parseProperties()
{
   LOG_FUNCTION(CSVDSReader::parseProperties);
   
   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   
   do
   {
      
      String csvLine;
      hr=ReadLine(file,csvLine);
      // We are breaking for EOF_HRESULT too, since 
      // there should be more lines in the csv
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);

      hr = WinGetVLFilePointer(file, &startPosition);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      StringList tokens;
      size_t token_count = csvLine.tokenize(back_inserter(tokens),L",");
      ASSERT(token_count == tokens.size());
         
      StringList::iterator begin=tokens.begin();
      StringList::iterator end=tokens.end();
      
      
      long count=0;
      while( begin != end )
      {
         propertyPositions[*begin]=count++;
         begin++;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


// Fill localeOffsets with the starting position of all locales
// Expects file to be in the second line
// Expects the locale order to be the same as the one
// found in the file
HRESULT CSVDSReader::parseLocales(const long *locales)
{

   LOG_FUNCTION(CSVDSReader::parseLocales);

   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   do
   {
      
      long count=0;
      bool flagEof=false;

      while(locales[count]!=0 && !flagEof)
      {
         long locale=locales[count];
         
         String localeStr=String::format(L"CN=%1!3x!,", locale);
         
         LARGE_INTEGER pos;
         
         hr = WinGetVLFilePointer(file, &pos);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         String csvLine;
         hr=ReadLine(file,csvLine);
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         if(csvLine.length() > localeStr.length())
         {
            csvLine.erase(localeStr.size()+1);
            
            if( localeStr.icompare(&csvLine[1])==0 )
            {
               localeOffsets[locale]=pos;
               count++;
            }
         }
      }
      
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      if(locales[count]!=0)
      {
         error=String::format(IDS_MISSING_LOCALES,fileName.c_str());
         hr=E_FAIL;
         break;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}

// get the csv value starting with inValue to outValue
// returns S_FALSE if no value is found
HRESULT
CSVDSReader::getCsvValue
( 
   const long     locale,
   const wchar_t  *object, 
   const wchar_t  *property,
   const String   &inValue,
   String         &outValue
) const
{
   LOG_FUNCTION(CSVDSReader::getCsvValue);

   HRESULT hr=S_OK;
   outValue.erase();


   bool found=false;

   do
   {
      StringList values;
      hr=getCsvValues(locale,object,property,values);
      BREAK_ON_FAILED_HRESULT(hr);
   
      StringList::const_iterator begin,end;
      begin=values.begin();
      end=values.end();
      while(begin!=end && !found)
      {
         if (_wcsnicmp(begin->c_str(),inValue.c_str(),inValue.length())==0)
         {
            outValue=*begin;
            found=true;
         }
         begin++;
      }
   }
   while(0);

   if (!found)
   {
      hr=S_FALSE;
   }

   LOG_HRESULT(hr);
   return hr;
}


// return all values for a property in a given locale/object
HRESULT
CSVDSReader::getCsvValues
(
     const long     locale,
     const wchar_t  *object, 
     const wchar_t  *property,
     StringList     &values
) const
{
   LOG_FUNCTION(CSVDSReader::getCsvValues);

   // seek on locale
   // read sequentially until find object
   // call getPropertyValues on the line found to retrieve values
   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   do
   {
      
      String propertyString(property);
      
      mapOfPositions::const_iterator propertyPos = 
         propertyPositions.find(propertyString);
      
      if (propertyPos==propertyPositions.end())
      {
         error=String::format(IDS_PROPERTY_NOT_FOUND_IN_CSV,
            property,
            fileName.c_str());
         hr=E_FAIL;
         break;
      }
      
      String csvLine;
      hr=getObjectLine(locale,object,csvLine);
      BREAK_ON_FAILED_HRESULT(hr);
      
      mapOfProperties allValues;
      hr=getPropertyValues(csvLine,allValues);
      BREAK_ON_FAILED_HRESULT(hr);
      values=allValues[property];
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


// starting from the locale offset
// finds the object and returns its line in csvLine
HRESULT 
CSVDSReader::getObjectLine(   
                           const long     locale,
                           const wchar_t  *object,
                           String         &csvLine
                           ) const
{
   
   LOG_FUNCTION(CSVDSReader::getObjectLine);

   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   do
   {
     
      mapOfOffsets::const_iterator offset = 
         localeOffsets.find(locale);
      
      // locale must have been passed to read
      ASSERT(offset!=localeOffsets.end());
      
      String objectStr;
      
      objectStr=String::format(L"CN=%1,CN=%2!3x!",object,locale);
      
      hr=Win::SetFilePointerEx(file,offset->second,0,FILE_BEGIN);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      // first line is the container properties and since we want the
      // properties of an object we will ignore it
      
      bool flagEof=false;
      hr=ReadLine(file,csvLine);
      if(hr==EOF_HRESULT)
      {
         flagEof=true;
         hr=S_OK;
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      bool found=false;
      while(!found && !flagEof)
      {
         hr=ReadLine(file,csvLine);
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         if(csvLine.length() > objectStr.length())
         {
            String auxComp=csvLine.substr(1,objectStr.length());
            
            if( auxComp.icompare(objectStr)==0 )
            {
               found=true;
            }
         }
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      if(!found)
      {
         error = String::format(
            IDS_OBJECT_NOT_FOUND_IN_CSV,
            object,
            locale,
            fileName.c_str()
            );
         hr=E_FAIL;
         break;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}



HRESULT CSVDSReader::writeHeader(HANDLE  fileOut) const
{
   LOG_FUNCTION(CSVDSReader::writeHeader);
   ASSERT(fileOut!=INVALID_HANDLE_VALUE);

   HRESULT hr=S_OK;
   do
   {
      char suId[3]={'\xFF','\xFE',0};
      //uId solves ambiguous Write
      AnsiString uId(suId);
      hr=FS::Write(fileOut,uId);
      BREAK_ON_FAILED_HRESULT(hr);
      
      // 2 to skip the unicode identifier
      LARGE_INTEGER pos;
      pos.QuadPart=2;
      hr=Win::SetFilePointerEx(file,pos,0,FILE_BEGIN);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      String csvLine;
      hr=ReadLine(file,csvLine);
      // We are breaking for EOF_HRESULT too, since 
      // there should be more lines in the csv
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      hr=FS::WriteLine(fileOut,csvLine);
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
   
   
}

HRESULT
CSVDSReader::makeLocalesCsv
(
    HANDLE         fileOut,
    const   long  *locales
) const
{
   LOG_FUNCTION(CSVDSReader::makeLocalesCsv);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   ASSERT(fileOut!=INVALID_HANDLE_VALUE);
   
   do
   {
      
     
      LARGE_INTEGER posStartOut;
      hr = WinGetVLFilePointer(fileOut, &posStartOut);
      BREAK_ON_FAILED_HRESULT(hr);
      
      if (posStartOut.QuadPart==0)
      {
         hr=writeHeader(fileOut);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      long count=0;
      

      while(locales[count]!=0)
      {
         long locale=locales[count];
         mapOfOffsets::const_iterator offset;
         offset = localeOffsets.find(locale);
         
         // locale must have been passed to read
         ASSERT(offset!=localeOffsets.end());         

         hr=Win::SetFilePointerEx(file,offset->second,0,FILE_BEGIN);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         String localeStr=String::format(L"CN=%1!3x!,", locale);       
         
         bool flagEof=false;
         String csvLine;
         
         hr=ReadLine(file,csvLine);
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);

         // We know that the first line matches even if it ends with EOF
         hr=FS::WriteLine(fileOut,csvLine);
         BREAK_ON_FAILED_HRESULT(hr);
         
         bool newContainer=false;
         while
         ( 
            !flagEof && 
            !newContainer
         )
         {
            hr=ReadLine(file,csvLine);
            if(hr==EOF_HRESULT)
            {
               flagEof=true;
               hr=S_OK;
            }
            BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
            
            // We will deal with the line even if it ends with EOF
            size_t posComma=csvLine.find(L",");
            if(posComma!=String::npos)
            {
               String csvLoc=csvLine.substr(posComma+1,localeStr.length());
               if (csvLoc.icompare(localeStr) == 0)
               {
                  hr=FS::WriteLine(fileOut,csvLine);
                  BREAK_ON_FAILED_HRESULT(hr);
               }
               else
               {
                  newContainer=true;
               }
            }
            else
            {
               newContainer=true;
            }
         }; 
         count++;
      }  // while(locales[count]!=0)
      
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


HRESULT
CSVDSReader::makeObjectsCsv
(
    HANDLE              fileOut,
    const setOfObjects  &objects
) const
{

   LOG_FUNCTION(CSVDSReader::makeObjectsCsv);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   ASSERT(fileOut!=INVALID_HANDLE_VALUE);
   
   do
   {
      
      LARGE_INTEGER posStartOut;
      hr = WinGetVLFilePointer(fileOut, &posStartOut);
      BREAK_ON_FAILED_HRESULT(hr);
      
      if (posStartOut.QuadPart==0)
      {
         hr=writeHeader(fileOut);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      setOfObjects::const_iterator begin,end;
      begin=objects.begin();
      end=objects.end();
      
      while(begin!=end)
      {
         String csvLine;
         hr=getObjectLine( begin->second,
            begin->first.c_str(),
            csvLine);
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=FS::WriteLine(fileOut,csvLine);
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}

// auxiliar for getPropertyValues. 
// It is out of the class because it can be used elesewhere
String unquote(const String &src)
{
   String ret=src;
   ret.strip(String::BOTH);
   size_t len=ret.size();
   if(len>=2 && ret[0]==L'"' && ret[len-1]==L'"')
   {
      ret=ret.substr(1,len-2);
   }
   return ret;
}

// extract from line the value of all properties
HRESULT
CSVDSReader::getPropertyValues
(
   const String   &line, 
   mapOfProperties &properties
) const
{
   LOG_FUNCTION(CSVDSReader::getPropertyValues);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   ASSERT(!line.empty());
   
   do
   {
      StringVector objValues;
      const wchar_t *csr=line.c_str();
      const wchar_t *start=csr;

      while(*csr!=0)
      {
         if (*csr==L',')
         {
            objValues.push_back(unquote(String(start,csr)));
            csr++;
            start=csr;
         }
         else if (*csr==L'"')
         {
            // We are only advancing up to after the next quote
            csr++;
            while(*csr!=L'"' && *csr!=0) csr++;
            if (*csr==0)
            {
               error=String::format(IDS_QUOTES_NOT_CLOSED,fileName.c_str());
               hr=E_FAIL;
               break;
            }
            csr++;
         }
         else
         {
            csr++;
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
      objValues.push_back(unquote(String(start,csr)));
      
      if (objValues.size()!=propertyPositions.size())
      {
         error=String::format
               (
                  IDS_WRONG_NUMBER_OF_PROPERTIES,
                  objValues.size(),
                  propertyPositions.size(),
                  line.c_str(),
                  fileName.c_str()
               );;
         hr=E_FAIL;
         break;
      }

      properties.clear();
      mapOfPositions::iterator current=propertyPositions.begin();
      mapOfPositions::iterator end=propertyPositions.end();
      while(current!=end)
      {
         String &propValue=objValues[current->second];

         StringList values;
         if (!propValue.empty())
         {
            size_t cnt = propValue.tokenize(back_inserter(values),L";");
            ASSERT(cnt == values.size());
            
         }
         properties[current->first]=values;
         current++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}



// Sets the file pointer at the begining so that the next call to
// getNextObject will retrieve the first object.
// I did not take the usual getFirstObject approach, because
// I want to deal want to do something like:
// do
// {
//    hr=getNextObject(loc,obj,prop)
//    BREAK_ON_FAILED_HRESULT(hr);
//    if(hr==S_FALSE) flagEof=true;
//    if (loc==0) continue; // line is empty
//    // deal with line here
// } while(!flagEOF)
HRESULT 
CSVDSReader::initializeGetNext() const
{
   LOG_FUNCTION(CSVDSReader::initializeGetNext);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   do
   {
      hr=Win::SetFilePointerEx(file,startPosition,0,FILE_BEGIN);
      BREAK_ON_FAILED_HRESULT(hr);
      canCallGetNext=true;
   } while(0);
   
   LOG_HRESULT(hr);

   return hr;
}


// Get first object in the csv file returning it's name, locale
// and values for the properties in properties
// Returns S_FALSE for no more objects
HRESULT
CSVDSReader::getNextObject
(
   long &locale,
   String &object,
   mapOfProperties &properties
) const
{
   LOG_FUNCTION(CSVDSReader::getNextObject);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   ASSERT(canCallGetNext);

   
   locale=0;
   object.erase();

   bool flagEOF=false;
   
   do
   {
      String csvLine;
      hr=ReadLine(file,csvLine);
      if(hr==EOF_HRESULT)
      {
         flagEOF=true;
         if(csvLine.size()==0)
         {
            // we are done with success and EOF
            break;
         }
         
         hr=S_OK;
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);   

      size_t pos1stComma=csvLine.find(L',');
      ASSERT(pos1stComma!=String::npos);
      ASSERT(pos1stComma > 4);

      object=csvLine.substr(4,pos1stComma - 4);

      size_t pos2ndComma = csvLine.find(L',',pos1stComma+1);
      ASSERT(pos2ndComma!=String::npos);
      ASSERT(pos2ndComma > pos1stComma + 4);
      String strLocale=csvLine.substr
                       (
                           pos1stComma + 4,
                           pos2ndComma - pos1stComma - 4
                       );

      if (strLocale.icompare(L"DisplaySpecifiers")==0)
      {
         // This is a container line. 
         // The object that we got is actually the locale
         // and we have no object
         strLocale=object;
         object.erase();
      }
      
      String::ConvertResult result=strLocale.convert(locale,16);
      ASSERT(result==String::CONVERT_SUCCESSFUL);

      hr=getPropertyValues(csvLine,properties);
      
   } while(0);

   if(flagEOF) 
   {
      hr=S_FALSE;
      canCallGetNext=false;
   }

   LOG_HRESULT(hr);
   return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\csvdsreader.hpp ===
// Class to read csv files
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#ifndef CSVDSREADER_HPP
#define CSVDSREADER_HPP

#include <comdef.h>

#include <set>
#include <map>
#include <list>


using namespace std;





typedef set < 
               pair<String,long>,
               less< pair<String,long> > ,
               Burnslib::Heap::Allocator< pair<String,long> > 
            > setOfObjects;

typedef  map 
         <  
            long,
            LARGE_INTEGER,
            less<long>,
            Burnslib::Heap::Allocator<LARGE_INTEGER>
         > mapOfOffsets;

typedef  map
         <  
            String,
            long,
            less<String>,
            Burnslib::Heap::Allocator<long>
         > mapOfPositions;


typedef  map 
         <  
            String,     // Property
            StringList, // Values
            less<String>,
            Burnslib::Heap::Allocator<StringList>
         > mapOfProperties;





class CSVDSReader
{

   
private:
   mapOfOffsets localeOffsets;        // locale x offsets
   mapOfPositions propertyPositions;      // properties x position

   String fileName;
   HANDLE file;                              // csv file
   
   HRESULT parseProperties();

   HRESULT parseLocales(const long *locales);

   HRESULT 
      getObjectLine(   
      const long     locale,
      const wchar_t  *object,
      String         &csvLine) const;

   HRESULT 
   writeHeader(HANDLE  fileOut) const;

   LARGE_INTEGER startPosition; // keeps position after first line

   // extract from line the value of all properties
   HRESULT
   getPropertyValues
   (
      const String   &line, 
      mapOfProperties &properties
   ) const;

   bool mutable canCallGetNext;

public:
   CSVDSReader();

   // Sets the file pointer at the begining so that the next call to
   // getNextObject will retrieve the first object.
   HRESULT
   initializeGetNext() const;

   // Get first object in the csv file returning it's name, locale
   // and values for the properties in properties
   // Returns S_FALSE for no more objects
   HRESULT
   getNextObject
   (
      long &locale,
      String &object,
      mapOfProperties &properties
   ) const;
  
   // return all values for a property in a given locale/object
   HRESULT
   getCsvValues
   (
        const long     locale,
        const wchar_t  *object, 
        const wchar_t  *property,
        StringList     &values
   ) const;


   // gets the csv value starting with inValue to outValue
   // returns S_FALSE if no value is found
   HRESULT
   getCsvValue
   ( 
      const long     locale,
      const wchar_t  *object, 
      const wchar_t  *property,
      const String   &inValue,
      String         &outValue
   ) const;


   HRESULT
   makeLocalesCsv(
      HANDLE            fileOut,
      const long     *locales) const;


   HRESULT
   makeObjectsCsv(
      HANDLE              fileOut,
      const setOfObjects  &objects) const;


   virtual ~CSVDSReader()
   {
      if (file!=INVALID_HANDLE_VALUE) CloseHandle(file);
   }
   
   HRESULT 
   read(
         const wchar_t     *fileName,
         const long     *locales);



   
   const mapOfPositions& getProperties() const {return propertyPositions;};

   const String& getFileName() const {return fileName;}


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\global.hpp ===
// global functions and variables
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#ifndef GLOBAL_HPP
#define GLOBAL_HPP

using namespace std;

#define BREAK_ON_FAILED_HRESULT_ERROR(hr,error_) \
if (FAILED(hr))                     \
{                                   \
   error=error_;                    \
   break;                           \
}

typedef list <
               long,
               Burnslib::Heap::Allocator<long>
             > LongList;


////////////////////////

// Used in ReadLine
#define EOF_HRESULT Win32ToHresult(ERROR_HANDLE_EOF) 

// Used in WinGetVLFilePointer. Declared in global.cpp as ={0};
extern LARGE_INTEGER zero;

// Used in CSVDSReader and ReadLine
#define WinGetVLFilePointer(hFile, lpPositionHigh) \
         Win::SetFilePointerEx(hFile, zero, lpPositionHigh, FILE_CURRENT)



HRESULT
ReadLine
(
   HANDLE handle, 
   String& text,
   bool *endLineFound_=NULL
);

HRESULT 
ReadAllFile
(
   const String &fileName,
   String &fileStr
);

HRESULT
GetWorkTempFileName
(
   const wchar_t     *lpPrefixString,
   String            &name
);

void 
GetWorkFileName
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     *extension,
   String            &fileName
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\global.cpp ===
#include "headers.hxx"
#include "global.hpp"
#include "constants.hpp"
#include "resourceDspecup.h"
#include "AdsiHelpers.hpp"

//////////////// ReadLine 
#define CHUNK_SIZE 100

HRESULT
ReadLine
(
   HANDLE handle, 
   String& text,
   bool *endLineFound_/*=NULL*/
)
{
   LOG_FUNCTION(ReadLine); 
   ASSERT(handle != INVALID_HANDLE_VALUE);
   
   bool endLineFound=false;
   
   text.erase();
   
   // Acumulating chars read on text would cause the same
   // kind of reallocation and copy that text+=chunk will
   static wchar_t chunk[CHUNK_SIZE+1];
   HRESULT hr=S_OK;
   bool flagEof=false;
   
   do
   {
      LARGE_INTEGER pos;
      
      hr = WinGetVLFilePointer(handle,&pos);
      BREAK_ON_FAILED_HRESULT(hr);
      
      long nChunks=0;
      wchar_t *csr=NULL;
      
      while(!flagEof && !endLineFound)
      {
         DWORD bytesRead;
         
         hr = Win::ReadFile(
            handle,
            chunk,
            CHUNK_SIZE*sizeof(wchar_t),
            bytesRead,
            0);
         
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         
         BREAK_ON_FAILED_HRESULT(hr);

         if(bytesRead==0)
         {
            flagEof=true;
         }
         else
         {
         
            *(chunk+bytesRead/sizeof(wchar_t))=0;
         
            csr=wcschr(chunk,L'\n');
         
            if(csr!=NULL)
            {
               pos.QuadPart+= sizeof(wchar_t)*
                  ((nChunks * CHUNK_SIZE) + (csr - chunk)+1);
               hr=Win::SetFilePointerEx(
                  handle,
                  pos,
                  0,
                  FILE_BEGIN);
            
               BREAK_ON_FAILED_HRESULT(hr);
            
               *csr=0;
               endLineFound=true;
            }
         
            text+=chunk;
            nChunks++;
         }
      }
      
      BREAK_ON_FAILED_HRESULT(hr);

      //We know the length will fit in a long
      // and we want IA64 to build.
      long textLen=static_cast<long>(text.length());

      if(textLen!=0 && endLineFound && text[textLen-1]==L'\r')
      {
         text.erase(textLen-1,1);
      }
   
      if(endLineFound_ != NULL)
      {
         *endLineFound_=endLineFound;
      }

      if(flagEof)
      {
         hr=EOF_HRESULT;
      }
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


// Reads all the file to a string
HRESULT 
ReadAllFile
(
   const String &fileName,
   String &fileStr
)
{
   LOG_FUNCTION(ReadAllFile);

   HRESULT hr=S_OK;

   fileStr.erase();
   
   HANDLE file;
   hr=FS::CreateFile(fileName,
               file,
               GENERIC_READ);
   
   if(FAILED(hr))
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,fileName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      bool flagEof=false;
      while(!flagEof)
      {
         String line;
         hr=ReadLine(file,line);
         if(hr==EOF_HRESULT)
         {
            hr=S_OK;
            flagEof=true;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         fileStr+=line+L"\r\n";
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
   } while(0);

   if ( (fileStr.size() > 0) && (fileStr[0] == 0xfeff) )
   {
      fileStr.erase(0,1);
   }

   CloseHandle(file);

   LOG_HRESULT(hr);
   return hr;   
}


HRESULT
GetTempFileName
(  
  const wchar_t   *lpPathName,      // directory name
  const wchar_t   *lpPrefixString,  // file name prefix
  String          &name             // file name 
)
{
   LOG_FUNCTION(GetTempFileName);

   ASSERT(FS::PathExists(lpPathName));

   HRESULT hr=S_OK;
   do
   {
      if (!FS::PathExists(lpPathName))
      {
         hr=E_FAIL;
         error=String::format(IDS_COULD_NOT_FIND_PATH,lpPathName);
         break;
      }

      DWORD result;
      wchar_t lpName[MAX_PATH]={0};

      result=::GetTempFileName(lpPathName,lpPrefixString,0,lpName);
      
      if (result == 0) 
      {
         hr = Win::GetLastErrorAsHresult();
         error=String::format(IDS_COULD_NOT_GET_TEMP,lpPathName);
         break;
      }

      name=lpName;

   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}

// Retrieves a unique temporary file name
HRESULT 
GetWorkTempFileName
(
   const wchar_t     *lpPrefixString,
   String            &name
)
{
   LOG_FUNCTION(GetWorkTempFileName);

   HRESULT hr=S_OK;
   String path;
   do
   {
      hr=Win::GetTempPath(path);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      path=path.substr(0,path.size()-1);

      hr=GetTempFileName(path.c_str(),lpPrefixString,name);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}



// locate the file with the highest-numbered extension, then add 1 and
// return the result.
int
DetermineNextFileNumber
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     *extension
)
{
   LOG_FUNCTION(DetermineNextFileNumber);
   ASSERT(!dir.empty());
   ASSERT(!baseName.empty());

   int largest = 0;

   String filespec = dir + L"\\" + baseName + L".*."+ extension;

   WIN32_FIND_DATA findData;
   HANDLE ff = ::FindFirstFile(filespec.c_str(), &findData);

   if (ff != INVALID_HANDLE_VALUE)
   {
      for (;;)
      {
         String current = findData.cFileName;

         // grab the text between the dots: "nnn" in foo.nnn.ext

         // first dot

         size_t pos = current.find(L".");
         if (pos == String::npos)
         {
            continue;
         }

         String foundExtension = current.substr(pos + 1);

         // second dot

         pos = foundExtension.find(L".");
         if (pos == String::npos)
         {
            continue;
         }
   
         foundExtension = foundExtension.substr(0, pos);

         int i = 0;
         foundExtension.convert(i);
         largest = max(i, largest);

         if (!::FindNextFile(ff, &findData))
         {
            BOOL success = ::FindClose(ff);
            ASSERT(success);

            break;
         }
      }
   }

   // roll over after 255
   
   return (++largest & 0xFF);
}

// Retrieves a unique file name
void 
GetWorkFileName
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     *extension,
   String            &fileName
)
{
   LOG_FUNCTION(GetFileName);
   int logNumber = DetermineNextFileNumber(dir,baseName,extension);
   fileName = dir
               +  L"\\"
               +  baseName
               +  String::format(L".%1!03d!.", logNumber)
               +  extension;

   if (::GetFileAttributes(fileName.c_str()) != 0xFFFFFFFF)
   {
      // could exist, as the file numbers roll over

      BOOL success = ::DeleteFile(fileName.c_str());
      ASSERT(success);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\guids.inc ===
// This file is generated by preBuild.exe
// Copyright (c) 2001 Microsoft Corporation
// Nov 2001 lucios


GUID guids[]=
{
   {0x4444c516,0xf43a,0x4c12,{0x9c,0x4b,0xb5,0xc0,0x64,0x94,0x1d,0x61}},
   {0xffa5ee3c,0x1405,0x476d,{0xb3,0x44,0x7a,0xd3,0x7d,0x69,0xcc,0x25}},
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\dspecup.cpp ===
#include "headers.hxx"
#include "dspecup.hpp"
#include "Analysis.hpp"
#include "repair.hpp"
#include "AnalysisResults.hpp"
#include "resourceDspecup.h"
#include "CSVDSReader.hpp"
#include "constants.hpp"
#include "AdsiHelpers.hpp"
#include "guids.inc"

HRESULT
FindCsvFile(
            String& csvFilePath,
            String& csv409Path
           )
{
   LOG_FUNCTION(FindCsvFile);

   csvFilePath.erase();
   csv409Path.erase();
   
   HRESULT hr = S_OK;

   do
   {
      // look for dcpromo.csv and 409.csv file in system 
      // or current directory
      

      // check the default of
      // %windir%\system32\mui\dispspec\dcpromo.csv and
      // .\dcpromo.csv

      String csvname=L"dcpromo.csv";
      String sys32dir = Win::GetSystemDirectory();
      String csvPath  = sys32dir + L"\\debug\\adprep\\data\\" + csvname;

      if (FS::FileExists(csvPath))
      {
         csvFilePath = csvPath;
      }
      else
      {
         error=String::format(IDS_COULD_NOT_FIND_FILE,csvPath.c_str());
         hr=E_FAIL;
         break;
      }
      

      csvname=L"409.csv";
      csvPath  = sys32dir + L"\\debug\\adprep\\data\\" + csvname;
      
      if (FS::FileExists(csvPath))
      {
         csv409Path = csvPath;
      }
      else
      {
         error=String::format(IDS_COULD_NOT_FIND_FILE,csvPath.c_str());
         hr=E_FAIL;
         break;
      }
   }
   while(0);


   LOG_HRESULT(hr);
   LOG(csvFilePath);
   LOG(csv409Path);
   
   return hr;      
}


HRESULT 
InitializeADSI(
               const String   &targetDcName,
               String         &ldapPrefix,
               String         &rootContainerDn,
               String         &domainName,
               String         &completeDcName,
               SmartInterface<IADs>& rootDse
              )
{
   LOG_FUNCTION(InitializeADSI);

   HRESULT hr=S_OK;
   do
   {
      Computer targetDc(targetDcName);
      hr = targetDc.Refresh();

      if (FAILED(hr))
      {
         error = String::format(
               IDS_CANT_TARGET_MACHINE,
               targetDcName.c_str());
         break;
      }

      if (!targetDc.IsDomainController())
      {
         error=String::format(
               IDS_TARGET_IS_NOT_DC,
               targetDcName.c_str());
         hr=E_FAIL;
         break;
      }

      completeDcName = targetDc.GetActivePhysicalFullDnsName();
      ldapPrefix = L"LDAP://" + completeDcName + L"/";

      //
      // Find the DN of the configuration container.
      // 

      // Bind to the rootDSE object.  We will keep this binding handle
      // open for the duration of the analysis and repair phases in order
      // to keep a server session open.  If we decide to pass creds to the
      // AdsiOpenObject call in a later revision, then by keeping the
      // session open we will not need to pass the password to subsequent
      // AdsiOpenObject calls.
      
      hr = AdsiOpenObject<IADs>(ldapPrefix + L"RootDSE", rootDse);
      if (FAILED(hr))
      {
         error=String::format(
               IDS_UNABLE_TO_CONNECT_TO_DC,
               completeDcName.c_str());
         hr=E_FAIL;
         break;      
      }

      // read the configuration naming context.
      _variant_t variant;
      hr =
         rootDse->Get(
            AutoBstr(LDAP_OPATT_CONFIG_NAMING_CONTEXT_W),
            &variant);
      if (FAILED(hr))
      {
         LOG(L"can't read config NC");
                  
         error=String::format(IDS_UNABLE_TO_READ_DIRECTORY_INFO);
         break;   
      }

      String configNc = V_BSTR(&variant);

      ASSERT(!configNc.empty());   
      LOG(configNc);

      wchar_t *domain=wcschr(configNc.c_str(),L',');
      ASSERT(domain!=NULL);
      domainName=domain+1;

      rootContainerDn = L"CN=DisplaySpecifiers," + configNc;
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}


HRESULT 
GetInitialInformation(  
                        String &targetDomainControllerName,
                        String &csvFilename,
                        String &csv409Name
                     )
{
   LOG_FUNCTION(GetInitialInformation);

   HRESULT hr = S_OK;
   do
   {
      
      //
      // find the dcpromo.csv file to use
      //
   
      hr = FindCsvFile(csvFilename, csv409Name);
      BREAK_ON_FAILED_HRESULT(hr);

      //
      // Determine the target domain controller
      //

      if (targetDomainControllerName.empty())
      {
         // no target specified, default to the current machine
   
         targetDomainControllerName =
            Win::GetComputerNameEx(ComputerNameDnsFullyQualified);
   
         if (targetDomainControllerName.empty())
         {
            // no DNS name?  that's not right...
            LOG(L"no default DNS computer name found. Using netbios name.");
            

            targetDomainControllerName = 
               Win::GetComputerNameEx(ComputerNameNetBIOS);
            ASSERT(!targetDomainControllerName.empty());
         }
      }
   } 
   while (0);
   
   LOG_HRESULT(hr);
   return hr;
}


///////////////////////////////////////////////////////////////////
// Function: cchLoadHrMsg
//
// Given an HRESULT error,
// it loads the string for the error. It returns the # of characters returned
int cchLoadHrMsg( HRESULT hr, String &message )
{
   if(hr == S_OK) return 0;

   wchar_t *msgPtr = NULL;

   // Try from the system table
   int cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                           NULL, 
                           hr,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&msgPtr, 
                           0, 
                           NULL);


   if (!cch) 
   { 
      //try ads errors
      static HMODULE g_adsMod = 0;
      if (0 == g_adsMod)
      {
            g_adsMod = GetModuleHandle (L"activeds.dll");
      }

      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
                        g_adsMod, 
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPWSTR)&msgPtr, 
                        0, 
                        NULL);
   }

   if (!cch)
   {
      // Try NTSTATUS error codes

      hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(hr));

      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                           NULL, 
                           hr,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&msgPtr, 
                           0, 
                           NULL);
   }

   message.erase();

   if(cch!=0)
   {
      if(msgPtr==NULL) 
      {
         cch=0;
      }
      else
      {
         message=msgPtr;
         ::LocalFree(msgPtr);
      } 
   } 
   
   return cch;
}

// allocates error with src and a message formated from hr
void AllocError(HRESULT &hr,PWSTR *error,const String& src)
{
   ASSERT(error!=NULL);
   ASSERT(FAILED(hr));

   if (error==NULL) return; 

   // There is no use in formating a message if hr didn't fail
   if(!FAILED(hr)) return;
   
   String msg;
   
   if(hr!=E_FAIL)
   {
      // We ignore the error since it is possible that 
      // we don't find a message
      cchLoadHrMsg(hr,msg);
   }
   
   // Under any conditions(no mesage,E_FAIL or good message)
   // we print the hr. 
   msg+=String::format(L" (0x%1!x!).",hr);
   
   // we also add src
   msg=src+L" "+msg;


   *error=static_cast<PWSTR>(
                                 LocalAlloc
                                 (
                                    LMEM_FIXED,
                                    (msg.size()+1)*sizeof(wchar_t)
                                 )
                            );
   if(*error==NULL)
   {
      hr = Win32ToHresult(ERROR_NOT_ENOUGH_MEMORY);
   }
   else
   {
      wcscpy(*error,msg.c_str());
   }
   return;
}


HRESULT 
RunAnalysis
(
      GUID  guid,
      PWSTR logFilesPath,
      void *caleeStruct/*=NULL*/,
      progressFunction stepIt/*=NULL*/,
      progressFunction totalSteps/*=NULL*/
)
{
   LOG_FUNCTION(RunAnalysis);
   hResourceModuleHandle=::GetModuleHandle(NULL);
   HRESULT hr=S_OK;

   try
   {
      goodAnalysis=false;
      results.createContainers.clear();
      results.conflictingWhistlerObjects.clear();
      results.createWhistlerObjects.clear();
      results.createW2KObjects.clear();
      results.objectActions.clear();
      results.customizedValues.clear();
      results.extraneousValues.clear();

      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));
   

      do
      {
         String normalPath=FS::NormalizePath(logFilesPath);
         if (!FS::PathExists(normalPath) || FS::FileExists(normalPath))
         {
            hr=E_FAIL;
            error=String::load(IDS_NO_LOG_FILE_PATH);
            break;
         }

         hr=GetInitialInformation(
                                    targetDomainControllerName,
                                    csvFileName,
                                    csv409Name
                                 );

         BREAK_ON_FAILED_HRESULT(hr);

         hr=csvReaderIntl.read(csvFileName.c_str(),LOCALEIDS);
         BREAK_ON_FAILED_HRESULT(hr);
   
         hr=csvReader409.read(csv409Name.c_str(),LOCALE409);
         BREAK_ON_FAILED_HRESULT(hr);

         SmartInterface<IADs> rootDse(0);

         hr=InitializeADSI
            (
               targetDomainControllerName,
               ldapPrefix,
               rootContainerDn,
               domainName,
               completeDcName,
               rootDse
            );
         BREAK_ON_FAILED_HRESULT(hr);

         String reportName;

         GetWorkFileName(  
                              normalPath,
                              String::load(IDS_FILE_NAME_REPORT),
                              L"txt",
                              reportName
                        );

         Analysis analysis(
                              guid,
                              csvReader409, 
                              csvReaderIntl,
                              ldapPrefix,
                              rootContainerDn,
                              results,
                              reportName,
                              caleeStruct,
                              stepIt,
                              totalSteps
                           );
   
         hr=analysis.run();
         BREAK_ON_FAILED_HRESULT(hr);
      } while(0);

      CoUninitialize();

      if(SUCCEEDED(hr))
	  {
         goodAnalysis=true;
      }
   }
   catch( const std::bad_alloc& )
   {
     // Since we are in an out of memory condition.
     // we will not show allocate messages.
     hr=Win32ToHresult(ERROR_OUTOFMEMORY);
   }


   LOG_HRESULT(hr);
   return hr;

}




HRESULT 
RunRepair 
(
      PWSTR logFilesPath,
      void *caleeStruct/*=NULL*/,
      progressFunction stepIt/*=NULL*/,
      progressFunction totalSteps/*=NULL*/
)
{
   hResourceModuleHandle=::GetModuleHandle(NULL);
   LOG_FUNCTION(RunRepair);
   HRESULT hr=S_OK;


   try
   {
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      do
      {
         String normalPath=FS::NormalizePath(logFilesPath);
         if (!FS::PathExists(normalPath) || FS::FileExists(normalPath))
         {
            hr=E_FAIL;
            error=String::load(IDS_NO_LOG_FILE_PATH);
            break;
         }

         if (!goodAnalysis)
         {
            hr=E_FAIL;
            error=String::load(IDS_NO_ANALYSIS);
            break;
         }

         String ldiffName;

         GetWorkFileName(
                              normalPath,
                              String::load(IDS_FILE_NAME_LDIF_ACTIONS),
                              L"ldf",
                              ldiffName
                        );
         BREAK_ON_FAILED_HRESULT(hr);

         String csvName;

         GetWorkFileName(
                              normalPath,
                              String::load(IDS_FILE_NAME_CSV_ACTIONS),
                              L"csv",
                              csvName
                        );
         BREAK_ON_FAILED_HRESULT(hr);
   
         String saveName;

         GetWorkFileName(
                              normalPath,
                              String::load(IDS_FILE_NAME_UNDO),
                              L"ldf",
                              saveName
                        );

         BREAK_ON_FAILED_HRESULT(hr);

         String logPath;

         Repair repair
         (
            csvReader409, 
            csvReaderIntl,
            domainName,
            rootContainerDn,
            results,
            ldiffName,
            csvName,
            saveName,
            normalPath,
            completeDcName,
            caleeStruct,
            stepIt,
            totalSteps
          );

         hr=repair.run();
         BREAK_ON_FAILED_HRESULT(hr);
      } while(0);

	  CoUninitialize();
   }
   catch( const std::bad_alloc& )
   {
     // Since we are in an out of memory condition.
     // we will not show allocate messages.
     hr=Win32ToHresult(ERROR_OUTOFMEMORY);
   }

   LOG_HRESULT(hr);
   return hr;
}

extern "C"
HRESULT 
UpgradeDisplaySpecifiers 
(
      PWSTR logFilesPath,
      GUID  *OperationGuid,
      BOOL dryRun,
      PWSTR *errorMsg,//=NULL
      void *caleeStruct,//=NULL
      progressFunction stepIt,//=NULL
      progressFunction totalSteps//=NULL
)
{
    LOG_FUNCTION(UpgradeDisplaySpecifiers);
    hResourceModuleHandle=::GetModuleHandle(NULL);
    HRESULT hr=S_OK;

    do
    {
        hr = ::CoInitialize(0);
        ASSERT(SUCCEEDED(hr));

        GUID guid;
        if(OperationGuid==NULL)
        {
          hr = E_INVALIDARG;
          error = String::format(IDS_NO_GUID);
          break;
        }

        guid=*OperationGuid;

        int sizeGuids=sizeof(guids)/sizeof(*guids);
        bool found=false;
        for(int t=0;(t<sizeGuids) && (!found);t++)
        {
            if (guids[t]==guid) found=true;
        }

        if(!found)
        {
          hr = E_INVALIDARG;
          error = String::format(IDS_NO_OPERATION_GUID);
          break;
        }

        hr=RunAnalysis(guid,logFilesPath,caleeStruct,stepIt,totalSteps);
        BREAK_ON_FAILED_HRESULT(hr);

        if(dryRun==false)
        {
            hr=RunRepair(logFilesPath,caleeStruct,stepIt,totalSteps);
            BREAK_ON_FAILED_HRESULT(hr);
        }
        CoUninitialize();

    } while(0);


	if(FAILED(hr))
	{
		AllocError(hr,errorMsg,error);
	}

    LOG_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\repair.cpp ===
#include "headers.hxx"


#include "repair.hpp"
#include "CSVDSReader.hpp"
#include "resourceDspecup.h"



Repair::Repair
   (
      const CSVDSReader&   csvReader409_,
      const CSVDSReader&   csvReaderIntl_,
      const String&        domain_,
      const String&        rootContainerDn_,
      AnalysisResults&     res,
      const String&        ldiffName_,
      const String&        csvName_,
      const String&        saveName_,
      const String&        logPath_,
      const String&        completeDcName_,
      void                 *caleeStruct_/*=NULL*/,
      progressFunction     stepIt_/*=NULL*/,
      progressFunction     totalSteps_/*=NULL*/
   )
   :
   results(res),
   domain(domain_),
   rootContainerDn(rootContainerDn_),
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   ldiffName(ldiffName_),
   csvName(csvName_),
   saveName(saveName_),
   logPath(logPath_),
   completeDcName(completeDcName_),
   caleeStruct(caleeStruct_),
   stepIt(stepIt_),
   totalSteps(totalSteps_)
{
   LOG_CTOR(Repair);
   ASSERT(!domain.empty());
   ASSERT(!rootContainerDn.empty());
   ASSERT(!ldiffName.empty());
   ASSERT(!csvName.empty());
   ASSERT(!saveName.empty());
   ASSERT(!logPath.empty());
};


void Repair::setProgress()
{
   // We know the numbers bellow will fit in a long
   // and we want IA64 to build
   csvActions = static_cast<long>
                (
                  results.createContainers.size() +
                  results.createW2KObjects.size() +
                  results.createWhistlerObjects.size()
                );
                     

   
   ldiffActions = static_cast<long>
                  (
                     results.objectActions.size() + 
                     results.extraneousValues.size()
                  );



   // We have three main tasks: 
   //   1) building the csv and ldif files to make the changes
   //        (buildCsv, buildChangeLdif)
   //   2) saving the ldif files with objects that will change
   //        (buildSaveLdif)
   //   3) running the csv and ldif files that will actually make
   //          the changes 
   //       (runCsvOrLdif for the buildCsv and buildChangeLdif files)
   // For simplification, The two first tasks will be half of
   // the total work and the the last will be the other half.
   //
   // For task 1, each csv action takes 10 times an ldiff action.
   //
   // Each task 2 action is an ldif export that will be supposed
   // to take 5 times more than an ldif import, since it has to
   // call ldiffde to get each object.
   //
   // The total progress for 1) is 
   //    t1=csvActions*10 + ldiffActions
   // The progress for 2) is t2=5*ldiffActions
   // The progress for 3) is a proportional division of
   //    t1+t2 between csvActions and ldiffActions that will add
   //    up to t1
   //    t3 =  (t1+t2)*csvActions/(csvactions+ldiffActions) +
   //          (t1+t2)*ldiffActions/(csvactions+ldiffActions)

   if(csvActions + ldiffActions == 0)
   {
      // We don't want to update the page if there are no
      // actions
      totalSteps=NULL;
      stepIt=NULL;
   }
   else
   {
      csvBuildStep=10;
      ldiffBuildStep=1;
      ldiffSaveStep=10;

      long totalProgress = csvBuildStep * csvActions + 
                           ldiffBuildStep * ldiffActions +
                           ldiffSaveStep * ldiffActions;
      // totalProgress is accounting for task 1 and 2

      csvRunStep = totalProgress * csvActions /
                              (csvActions+ldiffActions);
      
      ldiffRunStep = totalProgress - csvRunStep;

      // now we compute the total time
      totalProgress*=2;
      
      if(totalSteps!=NULL)
      {
         totalSteps(totalProgress,caleeStruct);
      }
   }

}


HRESULT 
Repair::run()
{
   LOG_FUNCTION(Repair::run);


   setProgress();

   HRESULT hr=S_OK;

   do
   {
      // First we build the csv. If we can't build it
      // we don't want to run the LDIF and delete
      // the recereate objects
      if (csvActions != 0)
      {  
         hr=buildCsv();
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // Now we save the current objects and then
      // create and run the LDIF
      if ( ldiffActions !=0 )
      {
         // If we can't save we definatelly don't 
         // want to change anything
         hr=buildSaveLdif();
         BREAK_ON_FAILED_HRESULT(hr);

         // buildChangeLdif will build the Ldif that
         // will change the objects saved in
         // buildSaveLdif
         hr=buildChangeLdif();
         BREAK_ON_FAILED_HRESULT(hr);

         
         GetWorkFileName(
                           logPath,
                           String::load(IDS_FILE_NAME_LDIF_LOG),
                           L"txt",
                           ldifLog
                        );
         // runs the Ldif built in buildChangeLdif
         hr=runCsvOrLdif(LDIF,IMPORT,ldiffName,L"",ldifLog);
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffRunStep,caleeStruct);
         }
      }

      // Finally, we run the csv
      if (csvActions!=0)
      {  
         String opt=L"-c DOMAINPLACEHOLDER \"" + domain + L"\"";

         GetWorkFileName
         (
            logPath,
            String::load(IDS_FILE_NAME_CSV_LOG),
            L"txt",
            csvLog
         );
         hr=runCsvOrLdif(CSV,IMPORT,csvName,opt,csvLog);
         BREAK_ON_FAILED_HRESULT(hr);
         if(stepIt!=NULL) 
         {
            stepIt(csvRunStep,caleeStruct);
         }

      }
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



// Get the export results of a single object
HRESULT
Repair::getLdifExportedObject(
                                const long locale,
                                const String &object,
                                String &objectLines
                             )
{
   LOG_FUNCTION(Repair::getLdifExportedObject);
   
   ASSERT(!object.empty());
   ASSERT(locale > 0);
   objectLines.erase();
   
   HRESULT hr=S_OK;

   do
   {
      String dn= L"CN=" + object + 
                 String::format(L",CN=%1!3x!,", locale) +
                 rootContainerDn;
      
      String opt=L"-o ObjectGuid -d \"" + dn + L"\"";

      String tempName;
      hr=GetWorkTempFileName(L"TMP",tempName);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=runCsvOrLdif(LDIF,EXPORT,tempName,opt);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=ReadAllFile(tempName,objectLines);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=Win::DeleteFile(tempName);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);
   
   
   LOG_HRESULT(hr);
   return hr;
}

// buildSaveLdif will save information on
// all objects that will be changed
// or deleted in runChangeLdif.
// This includes information on:
//    results.objectActions
HRESULT 
Repair::buildSaveLdif()
{
   LOG_FUNCTION(Repair::buildSaveLdif);

   HRESULT hr=S_OK;

   HANDLE file;
   
   hr=FS::CreateFile(saveName,
                     file,
                     GENERIC_WRITE);
   
   if (FAILED(hr))
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,saveName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      String objectLines;

      ObjectActions::iterator beginObj=results.objectActions.begin();
      ObjectActions::iterator endObj=results.objectActions.end();

      while(beginObj!=endObj) 
      {         
         String dn= L"dn: CN=" + beginObj->first.object + 
           String::format(L",CN=%1!3x!,", beginObj->first.locale) +
           rootContainerDn + L"\r\nchangetype: delete\r\n";

         hr=FS::WriteLine(file,dn);
         BREAK_ON_FAILED_HRESULT(hr);

         hr=getLdifExportedObject( 
                                    beginObj->first.locale,
                                    beginObj->first.object,
                                    objectLines
                                  );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=FS::WriteLine(file,objectLines);
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffSaveStep,caleeStruct);
         }
         beginObj++;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      beginObj=results.extraneousValues.begin();
      endObj=results.extraneousValues.end();
      while(beginObj!=endObj) 
      {
         ObjectId tempObj(
                           beginObj->first.locale,
                           String(beginObj->first.object)
                         );
         if( 
            results.objectActions.find(tempObj) == 
            results.objectActions.end()
           )
         {
            String dn= L"dn: CN=" + beginObj->first.object + 
               String::format(L",CN=%1!3x!,", beginObj->first.locale) +
               rootContainerDn + L"\r\nchangetype: delete\r\n";

            hr=FS::WriteLine(file,dn);
            BREAK_ON_FAILED_HRESULT(hr);

            hr=getLdifExportedObject( 
                                       beginObj->first.locale,
                                       beginObj->first.object,
                                       objectLines
                                     );
            BREAK_ON_FAILED_HRESULT(hr);

            hr=FS::WriteLine(file,objectLines);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if(stepIt!=NULL) 
         {
            stepIt(ldiffSaveStep,caleeStruct);
         }
         beginObj++;
      }
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   CloseHandle(file);

   LOG_HRESULT(hr);
   return hr;
}



HRESULT
Repair::makeObjectsLdif(HANDLE file,ObjectIdList &objects)
{
   LOG_FUNCTION(Repair::makeObjectsLdif);
   HRESULT hr=S_OK;

   do
   {
      ObjectIdList::iterator begin,end;
      
      String header;

      begin=objects.begin();
      end=objects.end();
      while(begin!=end)
      {
         header= L"\r\ndn: CN=" + begin->object + 
                 String::format(L",CN=%1!3x!,", begin->locale) +
                 rootContainerDn;
         hr=FS::WriteLine(file,header);
         BREAK_ON_FAILED_HRESULT(hr);

         hr=FS::WriteLine(file,L"changetype: delete");
         BREAK_ON_FAILED_HRESULT(hr);

         begin++;
         if(stepIt!=NULL) 
         {
            stepIt(ldiffBuildStep,caleeStruct);
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


// buildChangeLdif wil build the Ldif that
// will change the objects saved im
// buildSaveLdif
HRESULT 
Repair::buildChangeLdif()
{
   LOG_FUNCTION(Repair::buildChangeLdif);

   HRESULT hr=S_OK;

   HANDLE file;
   
   hr=FS::CreateFile(ldiffName,
                     file,
                     GENERIC_WRITE);
   
   if (FAILED(hr))
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,ldiffName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      String header;
      String line;

      ObjectActions::iterator beginObj=results.objectActions.begin();
      ObjectActions::iterator endObj=results.objectActions.end();

      while(beginObj!=endObj) 
      {
         header= L"\r\ndn: CN=" + beginObj->first.object + 
                 String::format(L",CN=%1!3x!,", beginObj->first.locale) +
                 rootContainerDn;
         hr=FS::WriteLine(file,header);
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=FS::WriteLine(file,L"changetype: ntdsSchemaModify");
         BREAK_ON_FAILED_HRESULT(hr);
         

         PropertyActions::iterator beginAct=beginObj->second.begin();
         PropertyActions::iterator endAct=beginObj->second.end();

         while(beginAct!=endAct)
         {
            
            if(!beginAct->second.delValues.empty())
            {
               line = L"delete: " + beginAct->first;
               hr=FS::WriteLine(file,line);
               BREAK_ON_FAILED_HRESULT(hr);
               
               StringList::iterator 
                  beginDel = beginAct->second.delValues.begin();
               StringList::iterator 
                  endDel = beginAct->second.delValues.end();
               while(beginDel!=endDel)
               {
                  line = beginAct->first + L": " + *beginDel;
                  hr=FS::WriteLine(file,line);
                  BREAK_ON_FAILED_HRESULT(hr);

                  beginDel++;
               }
               BREAK_ON_FAILED_HRESULT(hr); 

               hr=FS::WriteLine(file,L"-");
               BREAK_ON_FAILED_HRESULT(hr);
            }

            if(!beginAct->second.addValues.empty())
            {
               line = L"add: " + beginAct->first;
               hr=FS::WriteLine(file,line);
               BREAK_ON_FAILED_HRESULT(hr);
               
               StringList::iterator 
                  beginAdd = beginAct->second.addValues.begin();
               StringList::iterator 
                  endAdd = beginAct->second.addValues.end();
               while(beginAdd!=endAdd)
               {
                  line = beginAct->first + L": " + *beginAdd;
                  hr=FS::WriteLine(file,line);
                  BREAK_ON_FAILED_HRESULT(hr);

                  beginAdd++;
               }
               BREAK_ON_FAILED_HRESULT(hr);

               hr=FS::WriteLine(file,L"-");
               BREAK_ON_FAILED_HRESULT(hr);
            }

            beginAct++;
         } // while(beginAct!=endAct)
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffBuildStep,caleeStruct);
         }
         beginObj++;
      } // while(beginObj!=endObj)
      
      BREAK_ON_FAILED_HRESULT(hr);

      // Now we will add actions to remove the extraneous objects
      beginObj=results.extraneousValues.begin();
      endObj=results.extraneousValues.end();
      while(beginObj!=endObj) 
      {

         header= L"\r\ndn: CN=" + beginObj->first.object + 
           String::format(L",CN=%1!3x!,", beginObj->first.locale) +
           rootContainerDn;

         hr=FS::WriteLine(file,header);
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=FS::WriteLine(file,L"changetype: ntdsSchemaModify");
         BREAK_ON_FAILED_HRESULT(hr);

         PropertyActions::iterator beginAct=beginObj->second.begin();
         PropertyActions::iterator endAct=beginObj->second.end();

         while(beginAct!=endAct)
         {
            if(!beginAct->second.delValues.empty())
            {
               line = L"delete: " + beginAct->first;
               hr=FS::WriteLine(file,line);
               BREAK_ON_FAILED_HRESULT(hr);
               
               StringList::iterator 
                  beginDel = beginAct->second.delValues.begin();
               StringList::iterator 
                  endDel = beginAct->second.delValues.end();
               while(beginDel!=endDel)
               {
                  line = beginAct->first + L": " + *beginDel;
                  hr=FS::WriteLine(file,line);
                  BREAK_ON_FAILED_HRESULT(hr);

                  beginDel++;
               }
               BREAK_ON_FAILED_HRESULT(hr); 

               hr=FS::WriteLine(file,L"-");
               BREAK_ON_FAILED_HRESULT(hr);
            } //if(!beginAct->second.delValues.empty())
            beginAct++;
         } // while(beginAct!=endAct)
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffBuildStep,caleeStruct);
         }
         beginObj++;
      } // while(beginObj!=endObj)

      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   CloseHandle(file);
   
   LOG_HRESULT(hr);
   return hr;
}



HRESULT
Repair::makeObjectsCsv(HANDLE file,ObjectIdList &objects)
{
   LOG_FUNCTION(Repair::makeObjectsCsv);
   HRESULT hr=S_OK;

   do
   {
      ObjectIdList::iterator begin,end;

      begin=objects.begin();
      end=objects.end();
      while(begin!=end)
      {
         long locale=begin->locale;
         const CSVDSReader &csvReader=(locale==0x409)?
                                       csvReader409:
                                       csvReaderIntl;
      
         setOfObjects tempObjs;
         pair<String,long> tempObj;
         tempObj.first=begin->object;
         tempObj.second=begin->locale;
         tempObjs.insert(tempObj);


         hr=csvReader.makeObjectsCsv(file,tempObjs);
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
         if(stepIt!=NULL) 
         {
            stepIt(csvBuildStep,caleeStruct);
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


// buildCsv creates a CSV with:
//       results.createContainers, 
//       results.createW2KObjects 
//       results.createWhistlerObjects
HRESULT 
Repair::buildCsv()
{
   LOG_FUNCTION(Repair::buildCsv);
   
   HANDLE file;

   HRESULT hr=S_OK;
   
   hr=FS::CreateFile(csvName,
                     file,
                     GENERIC_WRITE);
   
   if (FAILED(hr))
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,csvName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      
      LongList::iterator bgCont,endCont;
      bgCont=results.createContainers.begin();
      endCont=results.createContainers.end();

      while(bgCont!=endCont)
      {
         long locale=*bgCont;
         const CSVDSReader &csvReader=(locale==0x409)?
                                       csvReader409:
                                       csvReaderIntl;
         long locales[2]={locale,0L};
         hr=csvReader.makeLocalesCsv(file,locales);
         BREAK_ON_FAILED_HRESULT(hr);
         bgCont++;
         if(stepIt!=NULL) 
         {
            stepIt(csvBuildStep,caleeStruct);
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);

      hr=makeObjectsCsv(file,results.createW2KObjects);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=makeObjectsCsv(file,results.createWhistlerObjects);
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   CloseHandle(file);
   
   LOG_HRESULT(hr);
   return hr;
}



// This finction will run csvde or ldifde(whichExe)
// to import or export (inOut) file. The options specified
// are -u for unicode, -j for the log/err path -f for the file
// -i if import and the extraOptions.
// The log file will be renamed for logFileArg(if !empty)
// If an error file is generated it will be renamed.
HRESULT 
Repair::runCsvOrLdif(
                        csvOrLdif whichExe,
                        importExport inOut,
                        const String& file,
                        const String& extraOptions,//=L""
                        const String& logFileArg//=L""
                    )
{

   LOG_FUNCTION2(Repair::runCsvOrLdif,file.c_str());

   String baseName = (whichExe==LDIF) ? L"LDIF" : L"CSV";
   String exeName = baseName + L"de.exe";
   String options = (inOut==IMPORT) ? L"-i " + extraOptions : extraOptions;
   String operation = (inOut==IMPORT) ? L"importing" : L"exporting";
  
   HRESULT hr=S_OK;
   do
   {

      String sys32dir = Win::GetSystemDirectory();
      String wholeName = sys32dir + L"\\" + exeName;

      if (!FS::FileExists(wholeName))
      {
         error=String::format(IDS_EXE_NOT_FOUND,wholeName.c_str());
         hr=E_FAIL;
         break;
      }

      if (inOut==IMPORT && !FS::FileExists(file))
      {
         hr=E_FAIL;
         error=String::format(IDS_COULD_NOT_FIND_FILE,file.c_str());
         break;
      }

      String commandLine = L"\"" + wholeName + L"\" " +
                           options +
                           L" -u -f \"" + 
                           file + 
                           L"\" -j \"" + 
                           logPath + L"\" " +
                           L"-s " + completeDcName;

      STARTUPINFO si={0};
      PROCESS_INFORMATION pi={0};
      GetStartupInfo(&si);

      String curDir=L"";

      String errFile=logPath + L"\\" + baseName + L".err";
      String logFile=logPath + L"\\" + baseName + L".log";
      
      if(FS::FileExists(errFile))
      {
         hr=Win::DeleteFile(errFile);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,errFile);
      }

      if(FS::FileExists(logFile))
      {
         hr=Win::DeleteFile(logFile);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,logFile);
      }

      hr=Win::CreateProcess
              (
                  commandLine,
                  NULL,    // lpProcessAttributes
                  NULL,    // lpThreadAttributes
                  false,   // dwCreationFlags 
                  NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,// fdwCreate 
                  NULL,    // lpEnvironment 
                  curDir,  // lpEnvironment 
                  si,     // [in] lpStartupInfo 
                  pi      // [out] pProcessInformation
              );
      
      BREAK_ON_FAILED_HRESULT_ERROR(hr,
         String::format(IDS_COULD_NOT_START_EXE,commandLine.c_str()));

      do
      {

         DWORD resWait;
         hr=Win::WaitForSingleObject(pi.hProcess,INFINITE,resWait);
         
         // Log operation and break in case FAILED(hr)
         if(FAILED(hr))
         {
             error=String::format(IDS_ERROR_WAITING_EXE,commandLine.c_str());
             break;
         }

         if(!logFileArg.empty())
         {
            hr=FS::MoveFile(logFile.c_str(), logFileArg.c_str());
            if(FAILED(hr))
            {
               error=String::format(IDS_COULD_NOT_MOVE_FILE,
                           logFile.c_str(), logFileArg.c_str());
               break;
            }
         }

         DWORD resExit;
         hr=Win::GetExitCodeProcess(pi.hProcess,resExit);
         // Log operation and break in case FAILED(hr)
         if(FAILED(hr))
         {
             error=String::format
             (
                IDS_ERROR_GETTING_EXE_RETURN,
                commandLine.c_str()
             );
             break;
         }

         if(resExit!=0)
         {
            error=String::format
            (
                IDS_ERROR_EXECUTING_EXE,
                resExit,
                commandLine.c_str()
            );
            
            String betterErrFile;
            GetWorkFileName
            (
               logPath,
               String::load(
                              (whichExe==LDIF) ? 
                              IDS_FILE_NAME_LDIF_ERROR : 
                              IDS_FILE_NAME_CSV_ERROR
                           ),
               L"txt",
               betterErrFile
            );

            hr=FS::MoveFile(errFile.c_str(), betterErrFile.c_str());
            if(FAILED(hr))
            {
               error += String::format(IDS_COULD_NOT_MOVE_FILE,
                           errFile.c_str(), betterErrFile.c_str());
               break;
            }

            error+=String::format
                        (
                           IDS_SEE_ERROR_FILE,
                           betterErrFile.c_str()
                        );
            hr=E_FAIL;
            break;
         }
      } while(0);


      CloseHandle(pi.hProcess);
      CloseHandle(pi.hThread);

   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\adsihelpers.hpp ===
// ADSI Helper functions
//
// Copyright (c) 2001 Microsoft Corporation
//
// 1 Mar 2001 sburns



#ifndef ADSIHELPERS_HPP_INCLUDED
#define ADSIHELPERS_HPP_INCLUDED



// CODEWORK: consider putting this, and some of the more general purpose
// adsi goodies from admin\snapin\localsec\src\adsi.hpp|.cpp into an
// adsi header in burnslib.



// Template function that actually calls ADsOpenObject.
//
// Interface - The IADsXXX interface of the object to be bound.
//
// path - in, The ADSI path of the object to be bound.
//
// ptr - out, A null smart pointer to be bound to the interface of the object.

template <class Interface>
HRESULT
AdsiOpenObject(
   const String&              path,
   SmartInterface<Interface>& ptr)
{
   LOG_FUNCTION2(AdsiOpenObject, path);
   ASSERT(!path.empty());

   Interface* p = 0;
   HRESULT hr =
      ::ADsOpenObject(
         path.c_str(),
         0,
         0,
         ADS_SECURE_AUTHENTICATION,         
         __uuidof(Interface),
         reinterpret_cast<void**>(&p));
   if (SUCCEEDED(hr))
   {
      ptr.Acquire(p);
   }

   LOG_HRESULT(hr);
   
   return hr;
}



#endif   // ADSIHELPERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\setchanges.cpp ===
// This file is generated by preBuild.exe
// Copyright (c) 2001 Microsoft Corporation
// Nov 2001 lucios


#include "headers.hxx"

void setChanges0();
void setChanges1();

void setChanges()
{
    setChanges0();
    setChanges1();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\setreplacements.cpp ===
// This file is generated by W2KRepl.exe
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#include "headers.hxx"
#include "constants.hpp"

void setGlobalChanges0()
{
   addChange
   (  guids[0],
      -1,
      L"DS-UI-Default-Settings",
      L"msDS-FilterContainers",
      L"",
      L"",
      ADD_ALL_CSV_VALUES
   );

   addChange
   (  guids[0],
      -1,
      L"DS-UI-Default-Settings",
      L"msDS-Non-Security-Group-Extra-Classes",
      L"",
      L"",
      ADD_ALL_CSV_VALUES
   );

   addChange
   (  guids[0],
      -1,
      L"DS-UI-Default-Settings",
      L"dSUIAdminNotification",
      L"2,{a00e1768-4a9b-4d97-afc6-99d329f605f2}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"computer-Display",
      L"adminPropertyPages",
      L"7,{B52C1E50-1DD2-11D1-BC43-00C04FC31FD3}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"organizationalUnit-Display",
      L"adminPropertyPages",
      L"6,{FA3E1D55-16DF-446d-872E-BD04D4F39C93}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"container-Display",
      L"adminContextMenu",
      L"3,{EEBD2F15-87EE-4F93-856F-6AD7E31787B3}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"container-Display",
      L"adminContextMenu",
      L"4,{AB790AA1-CDC1-478a-9351-B2E05CFCAD09}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"adminPropertyPages",
      L"1,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"1,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"adminPropertyPages",
      L"3,{4e40f770-369c-11d0-8922-00a024ab2dbb}",
      L"",
      REMOVE_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"shellPropertyPages",
      L"1,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"1,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );


   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"contextMenu",
      L"0,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"0,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );   

   

   addChange
   (  guids[0],
      -1,
      L"pKICertificateTemplate-Display",
      L"adminContextMenu",
      L"0,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
      L"0,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
      REPLACE_GUID
   );   

   addChange
   (  guids[0],
      -1,
      L"default-Display",
      L"adminMultiselectPropertyPages",
      L"1,{50d30563-9911-11d1-b9af-00c04fd8d5b0}",
      L"",
      ADD_GUID
   );

   addChange
   (  guids[0],
      -1,
      L"default-Display",
      L"extraColumns",
      L"",
      L"",
      ADD_ALL_CSV_VALUES
   );

   addChange
   (  guids[0],
      -1,
      L"user-Display",
      L"adminMultiselectPropertyPages",
      L"1,{50d30564-9911-11d1-b9af-00c04fd8d5b0}",
      L"",
      ADD_GUID
   );  
   
   addChange
   (  guids[0],
      -1,
      L"user-Display",
      L"adminPropertyPages",
      L"9,{FA3E1D55-16DF-446d-872E-BD04D4F39C93}", 
      L"",
      ADD_GUID
   );

};


void setReplacementChanges0()
{

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x62a\x639\x644\x64a\x642",
      //comment,??????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x627\x644\x62a\x639\x644\x64a\x642",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //directReports,????????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x645\x631\x624\x648\x633\x648\x646",
      //directReports,???????? ???????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x62a\x642\x627\x631\x64a\x631\x20\x627\x644\x645\x628\x627\x634\x631\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,????? ???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x64a\x629\x20\x627\x644\x645\x62c\x645\x648\x639\x629",
      //memberOf,??? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x20\x641\x64a",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,??? ?????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633",
      //primaryTelexNumber,??? ??????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //sn,????? ?????? 
      L"\x73\x6e\x2c\x627\x644\x627\x633\x645\x20\x627\x644\x623\x62e\x64a\x631",
      //sn,??? ??????? 
      L"\x73\x6e\x2c\x627\x633\x645\x20\x627\x644\x639\x627\x626\x644\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633\x20\x28\x622\x62e\x631\x29",
      //telexNumber,??? ??????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633\x20\x28\x622\x62e\x631\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"group-Display",
      L"classDisplayName",
      //???????? 
      L"\x627\x644\x645\x62c\x645\x648\x639\x629",
      //?????? 
      L"\x645\x62c\x645\x648\x639\x629",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,????? 
      L"\x63\x6e\x2c\x627\x644\x627\x633\x645",
      //dc,????? 
      L"\x64\x63\x2c\x627\x644\x627\x633\x645",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x62a\x639\x644\x64a\x642",
      //comment,??????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x627\x644\x62a\x639\x644\x64a\x642",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //directReports,????????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x645\x631\x624\x648\x633\x648\x646",
      //directReports,???????? ???????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x627\x644\x62a\x642\x627\x631\x64a\x631\x20\x627\x644\x645\x628\x627\x634\x631\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,????? ???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x64a\x629\x20\x627\x644\x645\x62c\x645\x648\x639\x629",
      //memberOf,??? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x639\x636\x648\x20\x641\x64a",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,??? ?????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633",
      //primaryTelexNumber,??? ??????? 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //sn,????? ?????? 
      L"\x73\x6e\x2c\x627\x644\x627\x633\x645\x20\x627\x644\x623\x62e\x64a\x631",
      //sn,??? ??????? 
      L"\x73\x6e\x2c\x627\x633\x645\x20\x627\x644\x639\x627\x626\x644\x629",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x643\x633\x20\x28\x622\x62e\x631\x29",
      //telexNumber,??? ??????? (???) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x631\x642\x645\x20\x627\x644\x62a\x644\x64a\x643\x633\x20\x28\x622\x62e\x631\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"contact-Display",
      L"classDisplayName",
      //??? ??????? 
      L"\x62c\x647\x629\x20\x627\x644\x627\x62a\x635\x627\x644",
      //????? 
      L"\x627\x62a\x635\x627\x644",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //contactName,??? ??????? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x62c\x647\x629\x20\x627\x644\x627\x62a\x635\x627\x644",
      //contactName,????? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x627\x62a\x635\x627\x644",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //description,????? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x62a\x639\x644\x64a\x642",
      //description,??????? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x627\x644\x62a\x639\x644\x64a\x642",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"nTDSSettings-Display",
      L"classDisplayName",
      //????????? 
      L"\x627\x644\x625\x639\x62f\x627\x62f\x627\x62a",
      //??????? 
      L"\x625\x639\x62f\x627\x62f\x627\x62a",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,?&????...,RsAdmin.msc 
      L"\x30\x2c\x625\x26\x62f\x627\x631\x629\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&?????...,RsAdmin.msc 
      L"\x30\x2c\x26\x625\x62f\x627\x631\x629\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //????? ???????? ??? ??????? 
      L"\x62d\x627\x648\x64a\x629\x20\x627\x644\x646\x642\x644\x64a\x627\x62a\x20\x628\x64a\x646\x20\x627\x644\x645\x648\x627\x642\x639",
      //????? ????? ??? ??????? 
      L"\x62d\x627\x648\x64a\x629\x20\x627\x644\x646\x642\x644\x20\x628\x64a\x646\x20\x627\x644\x645\x648\x627\x642\x639",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x401,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5099\x8a3b",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x8a3b\x89e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ?????? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x53ef\x8fa8\x5225\x7684\x540d\x7a31",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x5225\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7fa4\x7d44\x7d44\x54e1\x8cc7\x683c",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x96b8\x5c6c\x65bc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5165\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4e4b\x524d\x7248\x672c\x29",
      //samAccountName,???? (Windows 2000 ??) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5165\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x524d\x7248\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ?????? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x53ef\x8fa8\x5225\x7684\x540d\x7a31",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x5225\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //member,?? 
      L"\x6d\x65\x6d\x62\x65\x72\x2c\x7d44\x54e1",
      //member,?? 
      L"\x6d\x65\x6d\x62\x65\x72\x2c\x6210\x54e1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7fa4\x7d44\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4e4b\x524d\x7248\x672c\x29",
      //samAccountName,???? (Windows 2000 ??) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7fa4\x7d44\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x524d\x7248\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x540d\x7a31",
      //dc,?? 
      L"\x64\x63\x2c\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5099\x8a3b",
      //comment,?? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x8a3b\x89e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ?????? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x53ef\x8fa8\x5225\x7684\x540d\x7a31",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x5225\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7fa4\x7d44\x7d44\x54e1\x8cc7\x683c",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x96b8\x5c6c\x65bc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"contact-Display",
      L"classDisplayName",
      //??? 
      L"\x806f\x7d61\x4eba",
      //??? 
      L"\x9023\x7d61\x4eba",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"computer-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x96fb\x8166\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4e4b\x524d\x7248\x672c\x29",
      //samAccountName,???? (Windows 2000 ??) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x96fb\x8166\x540d\x7a31\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x524d\x7248\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x806f\x7d61\x4eba",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x9023\x7d61\x4eba",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x5099\x8a3b",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8a3b\x89e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaReady,???? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x53ef\x7528\x7d19\x5f35",
      //printMediaReady,????? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x53ef\x4f7f\x7528\x7d19\x5f35",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMemory,?????? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x5b89\x88dd\x7684\x8a18\x61b6\x9ad4",
      //printMemory,??????? 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x5df2\x5b89\x88dd\x7684\x8a18\x61b6\x9ad4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printOwner,????? 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x64c1\x6709\x4eba\x540d\x7a31",
      //printOwner,????? 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x64c1\x6709\x8005\x540d\x7a31",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"nTDSSettings-Display",
      L"classDisplayName",
      //?? 
      L"\x8a2d\x5b9a",
      //??? 
      L"\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"nTFRSSettings-Display",
      L"classDisplayName",
      //FRS ?? 
      L"\x46\x52\x53\x20\x8a2d\x5b9a",
      //FRS ??? 
      L"\x46\x52\x53\x20\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"licensingSiteSettings-Display",
      L"classDisplayName",
      //?????? 
      L"\x6388\x6b0a\x7db2\x7ad9\x8a2d\x5b9a",
      //??????? 
      L"\x6388\x6b0a\x7db2\x7ad9\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"nTDSSiteSettings-Display",
      L"classDisplayName",
      //???? 
      L"\x7ad9\x53f0\x8a2d\x5b9a",
      //????? 
      L"\x7ad9\x53f0\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"organizationalUnit-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"container-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"rpcContainer-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"trustedDomain-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"volume-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"mSMQSettings-Display",
      L"classDisplayName",
      //MSMQ ?? 
      L"\x4d\x53\x4d\x51\x20\x8a2d\x5b9a",
      //MSMQ ??? 
      L"\x4d\x53\x4d\x51\x20\x8a2d\x5b9a\x503c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"default-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"foreignSecurityPrincipal-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"pKICertificateTemplate-Display",
      L"attributeDisplayNames",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x8aaa\x660e",
      //description,?? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x63cf\x8ff0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x404,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //c,Zkratka sttu 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x73\x74\xe1\x74\x75",
      //c,Zkratka zeme 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x7a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //co,Stt 
      L"\x63\x6f\x2c\x53\x74\xe1\x74",
      //co,Zeme 
      L"\x63\x6f\x2c\x5a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,Jmno podle protokol X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f\x20\x70\x6f\x64\x6c\x65\x20\x70\x72\x6f\x74\x6f\x6b\x6f\x6c\x20\x58\x35\x30\x30",
      //distinguishedName,Rozliujc nzev X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x52\x6f\x7a\x6c\x69\x161\x75\x6a\xed\x63\xed\x20\x6e\xe1\x7a\x65\x76\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //division,Divize 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x7a\x65",
      //division,Oddelen 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x4f\x64\x64\x11b\x6c\x65\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,ID zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x44\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      //employeeID,Identifikacn cslo zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x6b\x61\x10d\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,Generacn prpona 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x10d\x6e\xed\x20\x70\x159\xed\x70\x6f\x6e\x61",
      //generationQualifier,Prpona za jmnem 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x50\x159\xed\x70\x6f\x6e\x61\x20\x7a\x61\x20\x6a\x6d\xe9\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //givenName,Krestn jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4b\x159\x65\x73\x74\x6e\xed\x20\x6a\x6d\xe9\x6e\x6f",
      //givenName,Jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //homePhone,Telefonn cslo domu 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f",
      //homePhone,Telefon (domu) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x28\x64\x6f\x6d\x16f\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //initials,Inicily 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79",
      //initials,Inicily dalch jmen 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79\x20\x64\x61\x6c\x161\xed\x63\x68\x20\x6a\x6d\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Mezinrodn cslo ISDN (dal csla) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //internationalISDNNumber,Mezinrodn cslo ISDN (ostatn) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,Elektronick adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61",
      //mail,E-mailov adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Clenstv ve skupinch 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x10c\x6c\x65\x6e\x73\x74\x76\xed\x20\x76\x65\x20\x73\x6b\x75\x70\x69\x6e\xe1\x63\x68",
      //memberOf,Je clenem 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\x65\x20\x10d\x6c\x65\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,Cslo mobilnho telefonu 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75",
      //mobile,Mobiln telefon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Cslo faxu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x66\x61\x78\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherFacsimileTelephoneNumber,Faxov cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6f\x76\xe9\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefonn cslo domu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherHomePhone,Telefon domu (ostatn) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x64\x6f\x6d\x16f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefonn cslo IP (dal csla) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherIpPhone,Telefonn cslo IP (ostatn) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,Elektronick adresa (dal adresy) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //otherMailbox,E-mailov adresa (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,Cslo mobilnho telefonu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherMobile,Mobiln telefon (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,Cslo opertoru (dal csla) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherPager,Cslo opertoru (ostatn) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefonn cslo (dal csla) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherTelephone,Telefonn cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,Funkce 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      //personalTitle,Nzev 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Umsten kancelre 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x6b\x61\x6e\x63\x65\x6c\xe1\x159\x65",
      //physicalDeliveryOfficeName,Umsten pracovite 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x70\x72\x61\x63\x6f\x76\x69\x161\x74\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //postalCode,Potovn smerovac cslo 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x73\x6d\x11b\x72\x6f\x76\x61\x63\xed\x20\x10d\xed\x73\x6c\x6f",
      //postalCode,PSC 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x53\x10c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //postOfficeBox,PO Box 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x4f\x20\x42\x6f\x78",
      //postOfficeBox,Potovn prihrdka 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x70\x159\x69\x68\x72\xe1\x64\x6b\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,Cslo dlnopisu 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75",
      //primaryTelexNumber,Dlnopis 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Prihlaovac jmno (pred Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x50\x159\x69\x68\x6c\x61\x161\x6f\x76\x61\x63\xed\x20\x6a\x6d\xe9\x6e\x6f\x20\x28\x70\x159\x65\x64\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Prihlaovac jmno (pro systmy star ne Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x50\x159\x69\x68\x6c\x61\x161\x6f\x76\x61\x63\xed\x20\x6a\x6d\xe9\x6e\x6f\x20\x28\x70\x72\x6f\x20\x73\x79\x73\x74\xe9\x6d\x79\x20\x73\x74\x61\x72\x161\xed\x20\x6e\x65\x17e\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //streetAddress,Ulice 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x55\x6c\x69\x63\x65",
      //streetAddress,Adresa 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,Cslo dlnopisu (dal csla) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //telexNumber,Dlnopis (ostatn) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //title,Nzev funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x66\x75\x6e\x6b\x63\x65",
      //title,Funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW (dal adresy) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //url,Webov adresa (ostatn) 
      L"\x75\x72\x6c\x2c\x57\x65\x62\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //displayName,Zobrazovan jmno 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xe9\x20\x6a\x6d\xe9\x6e\x6f",
      //displayName,Zobrazovan nzev 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xfd\x20\x6e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresa strnky v sti WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //wWWHomePage,Adresa strnky WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //c,Zkratka sttu 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x73\x74\xe1\x74\x75",
      //c,Zkratka zeme 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x7a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,Jmno podle protokol X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f\x20\x70\x6f\x64\x6c\x65\x20\x70\x72\x6f\x74\x6f\x6b\x6f\x6c\x20\x58\x35\x30\x30",
      //distinguishedName,Rozliujc nzev X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x52\x6f\x7a\x6c\x69\x161\x75\x6a\xed\x63\xed\x20\x6e\xe1\x7a\x65\x76\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Umsten kancelre 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x6b\x61\x6e\x63\x65\x6c\xe1\x159\x65",
      //physicalDeliveryOfficeName,Umsten pracovite 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x70\x72\x61\x63\x6f\x76\x69\x161\x74\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Nzev skupiny (pred Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x73\x6b\x75\x70\x69\x6e\x79\x20\x28\x70\x159\x65\x64\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nzev skupiny (pro systmy star ne Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x73\x6b\x75\x70\x69\x6e\x79\x20\x28\x70\x72\x6f\x20\x73\x79\x73\x74\xe9\x6d\x79\x20\x73\x74\x61\x72\x161\xed\x20\x6e\x65\x17e\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW (dal adresy) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //url,Webov adresa (ostatn) 
      L"\x75\x72\x6c\x2c\x57\x65\x62\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresa strnky v sti WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //wWWHomePage,Adresa strnky WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Jmno 
      L"\x63\x6e\x2c\x4a\x6d\xe9\x6e\x6f",
      //dc,Jmno 
      L"\x64\x63\x2c\x4a\x6d\xe9\x6e\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,Zkratka sttu 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x73\x74\xe1\x74\x75",
      //c,Zkratka zeme 
      L"\x63\x2c\x5a\x6b\x72\x61\x74\x6b\x61\x20\x7a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //co,Stt 
      L"\x63\x6f\x2c\x53\x74\xe1\x74",
      //co,Zeme 
      L"\x63\x6f\x2c\x5a\x65\x6d\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //displayName,Zobrazovan jmno 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xe9\x20\x6a\x6d\xe9\x6e\x6f",
      //displayName,Zobrazovan nzev 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5a\x6f\x62\x72\x61\x7a\x6f\x76\x61\x6e\xfd\x20\x6e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,Jmno podle protokol X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f\x20\x70\x6f\x64\x6c\x65\x20\x70\x72\x6f\x74\x6f\x6b\x6f\x6c\x20\x58\x35\x30\x30",
      //distinguishedName,Rozliujc nzev X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x52\x6f\x7a\x6c\x69\x161\x75\x6a\xed\x63\xed\x20\x6e\xe1\x7a\x65\x76\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,Divize 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x7a\x65",
      //division,Oddelen 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x4f\x64\x64\x11b\x6c\x65\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,ID zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x44\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      //employeeID,Identifikacn cslo zamestnance 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x6b\x61\x10d\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x7a\x61\x6d\x11b\x73\x74\x6e\x61\x6e\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,Generacn prpona 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x10d\x6e\xed\x20\x70\x159\xed\x70\x6f\x6e\x61",
      //generationQualifier,Prpona za jmnem 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x50\x159\xed\x70\x6f\x6e\x61\x20\x7a\x61\x20\x6a\x6d\xe9\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //givenName,Krestn jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4b\x159\x65\x73\x74\x6e\xed\x20\x6a\x6d\xe9\x6e\x6f",
      //givenName,Jmno 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4a\x6d\xe9\x6e\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePhone,Telefonn cslo domu 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f",
      //homePhone,Telefon (domu) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x28\x64\x6f\x6d\x16f\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //initials,Inicily 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79",
      //initials,Inicily dalch jmen 
      L"\x69\x6e\x69\x74\x69\x61\x6c\x73\x2c\x49\x6e\x69\x63\x69\xe1\x6c\x79\x20\x64\x61\x6c\x161\xed\x63\x68\x20\x6a\x6d\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Mezinrodn cslo ISDN (dal csla) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //internationalISDNNumber,Mezinrodn cslo ISDN (ostatn) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4d\x65\x7a\x69\x6e\xe1\x72\x6f\x64\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x53\x44\x4e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,Elektronick adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61",
      //mail,E-mailov adresa 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Clenstv ve skupinch 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x10c\x6c\x65\x6e\x73\x74\x76\xed\x20\x76\x65\x20\x73\x6b\x75\x70\x69\x6e\xe1\x63\x68",
      //memberOf,Je clenem 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\x65\x20\x10d\x6c\x65\x6e\x65\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,Cslo mobilnho telefonu 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75",
      //mobile,Mobiln telefon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Cslo faxu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x66\x61\x78\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherFacsimileTelephoneNumber,Faxov cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6f\x76\xe9\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefonn cslo domu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x64\x6f\x6d\x16f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherHomePhone,Telefon domu (ostatn) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x20\x64\x6f\x6d\x16f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefonn cslo IP (dal csla) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherIpPhone,Telefonn cslo IP (ostatn) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x49\x50\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,Elektronick adresa (dal adresy) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x63\x6b\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //otherMailbox,E-mailov adresa (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,Cslo mobilnho telefonu (dal csla) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x10c\xed\x73\x6c\x6f\x20\x6d\x6f\x62\x69\x6c\x6e\xed\x68\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherMobile,Mobiln telefon (ostatn) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x6c\x6e\xed\x20\x74\x65\x6c\x65\x66\x6f\x6e\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,Cslo opertoru (dal csla) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherPager,Cslo opertoru (ostatn) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x6f\x70\x65\x72\xe1\x74\x6f\x72\x75\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefonn cslo (dal csla) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //otherTelephone,Telefonn cslo (ostatn) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\xed\x20\x10d\xed\x73\x6c\x6f\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,Funkce 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      //personalTitle,Nzev 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Umsten kancelre 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x6b\x61\x6e\x63\x65\x6c\xe1\x159\x65",
      //physicalDeliveryOfficeName,Umsten pracovite 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x55\x6d\xed\x73\x74\x11b\x6e\xed\x20\x70\x72\x61\x63\x6f\x76\x69\x161\x74\x11b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //postalCode,Potovn smerovac cslo 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x73\x6d\x11b\x72\x6f\x76\x61\x63\xed\x20\x10d\xed\x73\x6c\x6f",
      //postalCode,PSC 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x50\x53\x10c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //postOfficeBox,PO Box 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x4f\x20\x42\x6f\x78",
      //postOfficeBox,Potovn prihrdka 
      L"\x70\x6f\x73\x74\x4f\x66\x66\x69\x63\x65\x42\x6f\x78\x2c\x50\x6f\x161\x74\x6f\x76\x6e\xed\x20\x70\x159\x69\x68\x72\xe1\x64\x6b\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryTelexNumber,Cslo dlnopisu 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75",
      //primaryTelexNumber,Dlnopis 
      L"\x70\x72\x69\x6d\x61\x72\x79\x54\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //streetAddress,Ulice 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x55\x6c\x69\x63\x65",
      //streetAddress,Adresa 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,Cslo dlnopisu (dal csla) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x10c\xed\x73\x6c\x6f\x20\x64\xe1\x6c\x6e\x6f\x70\x69\x73\x75\x20\x28\x64\x61\x6c\x161\xed\x20\x10d\xed\x73\x6c\x61\x29",
      //telexNumber,Dlnopis (ostatn) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x44\xe1\x6c\x6e\x6f\x70\x69\x73\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,Nzev funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x66\x75\x6e\x6b\x63\x65",
      //title,Funkce 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x6b\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW (dal adresy) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57\x20\x28\x64\x61\x6c\x161\xed\x20\x61\x64\x72\x65\x73\x79\x29",
      //url,Webov adresa (ostatn) 
      L"\x75\x72\x6c\x2c\x57\x65\x62\x6f\x76\xe1\x20\x61\x64\x72\x65\x73\x61\x20\x28\x6f\x73\x74\x61\x74\x6e\xed\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresa strnky v sti WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //wWWHomePage,Adresa strnky WWW 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Nzev poctace (pred Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x70\x6f\x10d\xed\x74\x61\x10d\x65\x20\x28\x70\x159\x65\x64\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nzev poctace (pro systmy star ne Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x70\x6f\x10d\xed\x74\x61\x10d\x65\x20\x28\x70\x72\x6f\x20\x73\x79\x73\x74\xe9\x6d\x79\x20\x73\x74\x61\x72\x161\xed\x20\x6e\x65\x17e\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //uNCName,Nzev ste 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x4e\xe1\x7a\x65\x76\x20\x73\xed\x74\x11b",
      //uNCName,Stov nzev 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x53\xed\x165\x6f\x76\xfd\x20\x6e\xe1\x7a\x65\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Inventrn cslo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x76\x65\x6e\x74\xe1\x72\x6e\xed\x20\x10d\xed\x73\x6c\x6f",
      //assetNumber,Evidencn cslo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x45\x76\x69\x64\x65\x6e\x10d\x6e\xed\x20\x10d\xed\x73\x6c\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printCollate,Podpora kompletovn kopi 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x6b\x6f\x6d\x70\x6c\x65\x74\x6f\x76\xe1\x6e\xed\x20\x6b\x6f\x70\x69\xed",
      //printCollate,Podporuje skldn 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x73\x6b\x6c\xe1\x64\xe1\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printColor,Podpora barevnho tisku 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x62\x61\x72\x65\x76\x6e\xe9\x68\x6f\x20\x74\x69\x73\x6b\x75",
      //printColor,Podporuje barevn tisk 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x62\x61\x72\x65\x76\x6e\xfd\x20\x74\x69\x73\x6b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Podpora oboustrannho tisku 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x6f\x62\x6f\x75\x73\x74\x72\x61\x6e\x6e\xe9\x68\x6f\x20\x74\x69\x73\x6b\x75",
      //printDuplexSupported,Podporuje oboustrann tisk 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x6f\x62\x6f\x75\x73\x74\x72\x61\x6e\x6e\xfd\x20\x74\x69\x73\x6b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMemory,Nainstalovan pamet 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x4e\x61\x69\x6e\x73\x74\x61\x6c\x6f\x76\x61\x6e\xe1\x20\x70\x61\x6d\x11b\x165",
      //printMemory,Instalovan pamet 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x6d\x6f\x72\x79\x2c\x49\x6e\x73\x74\x61\x6c\x6f\x76\x61\x6e\xe1\x20\x70\x61\x6d\x11b\x165",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printPagesPerMinute,Strany za minutu 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x53\x74\x72\x61\x6e\x79\x20\x7a\x61\x20\x6d\x69\x6e\x75\x74\x75",
      //printPagesPerMinute,Strnky za minutu 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x53\x74\x72\xe1\x6e\x6b\x79\x20\x7a\x61\x20\x6d\x69\x6e\x75\x74\x75",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printStaplingSupported,Podpora sevn 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x61\x20\x73\x65\x161\xed\x76\xe1\x6e\xed",
      //printStaplingSupported,Podporuje sevn 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x50\x6f\x64\x70\x6f\x72\x75\x6a\x65\x20\x73\x65\x161\xed\x76\xe1\x6e\xed",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adresa strnky v sti WWW 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x76\x20\x73\xed\x74\x69\x20\x57\x57\x57",
      //url,Adresa strnky WWW 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x61\x20\x73\x74\x72\xe1\x6e\x6b\x79\x20\x57\x57\x57",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"siteLink-Display",
      L"classDisplayName",
      //Propojen ste 
      L"\x50\x72\x6f\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\x11b",
      //Spojen st 
      L"\x53\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\xed",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //Most pro propojen ste 
      L"\x4d\x6f\x73\x74\x20\x70\x72\x6f\x20\x70\x72\x6f\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\x11b",
      //Most spojen st 
      L"\x4d\x6f\x73\x74\x20\x73\x70\x6f\x6a\x65\x6e\xed\x20\x73\xed\x74\xed",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"nTFRSSubscriber-Display",
      L"classDisplayName",
      //Odberatel sluby FRS 
      L"\x4f\x64\x62\x11b\x72\x61\x74\x65\x6c\x20\x73\x6c\x75\x17e\x62\x79\x20\x46\x52\x53",
      //castnk sluby FRS 
      L"\xda\x10d\x61\x73\x74\x6e\xed\x6b\x20\x73\x6c\x75\x17e\x62\x79\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //Organizacn tvar 
      L"\x4f\x72\x67\x61\x6e\x69\x7a\x61\x10d\x6e\xed\x20\xfa\x74\x76\x61\x72",
      //Organizacn jednotka 
      L"\x4f\x72\x67\x61\x6e\x69\x7a\x61\x10d\x6e\xed\x20\x6a\x65\x64\x6e\x6f\x74\x6b\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"rpcContainer-Display",
      L"classDisplayName",
      //Sluba RPC 
      L"\x53\x6c\x75\x17e\x62\x61\x20\x52\x50\x43",
      //Sluby RPC 
      L"\x53\x6c\x75\x17e\x62\x79\x20\x52\x50\x43",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQConfiguration-Display",
      L"classDisplayName",
      //Konfigurace fronty MSMQ 
      L"\x4b\x6f\x6e\x66\x69\x67\x75\x72\x61\x63\x65\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Konfigurace MSMQ 
      L"\x4b\x6f\x6e\x66\x69\x67\x75\x72\x61\x63\x65\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //Rozlehl st fronty MSMQ 
      L"\x52\x6f\x7a\x6c\x65\x68\x6c\xe1\x20\x73\xed\x165\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Rozlehl st MSMQ 
      L"\x52\x6f\x7a\x6c\x65\x68\x6c\xe1\x20\x73\xed\x165\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //Inovovan uivatel fronty MSMQ 
      L"\x49\x6e\x6f\x76\x6f\x76\x61\x6e\xfd\x20\x75\x17e\x69\x76\x61\x74\x65\x6c\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Aktualizovan uivatel MSMQ 
      L"\x41\x6b\x74\x75\x61\x6c\x69\x7a\x6f\x76\x61\x6e\xfd\x20\x75\x17e\x69\x76\x61\x74\x65\x6c\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"mSMQSettings-Display",
      L"classDisplayName",
      //Nastaven fronty MSMQ 
      L"\x4e\x61\x73\x74\x61\x76\x65\x6e\xed\x20\x66\x72\x6f\x6e\x74\x79\x20\x4d\x53\x4d\x51",
      //Nastaven MSMQ 
      L"\x4e\x61\x73\x74\x61\x76\x65\x6e\xed\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"remoteStorageServicePoint-Display",
      L"classDisplayName",
      //Sluba vzdlen pameti 
      L"\x53\x6c\x75\x17e\x62\x61\x20\x76\x7a\x64\xe1\x6c\x65\x6e\xe9\x20\x70\x61\x6d\x11b\x74\x69",
      //Sluba Remote Storage 
      L"\x53\x6c\x75\x17e\x62\x61\x20\x52\x65\x6d\x6f\x74\x65\x20\x53\x74\x6f\x72\x61\x67\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"sitesContainer-Display",
      L"classDisplayName",
      //Kontejner st 
      L"\x4b\x6f\x6e\x74\x65\x6a\x6e\x65\x72\x20\x73\xed\x74\xed",
      //Konejner ste 
      L"\x4b\x6f\x6e\x65\x6a\x6e\x65\x72\x20\x73\xed\x74\x11b",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Kontejner mezistovch prenosu 
      L"\x4b\x6f\x6e\x74\x65\x6a\x6e\x65\x72\x20\x6d\x65\x7a\x69\x73\xed\x165\x6f\x76\xfd\x63\x68\x20\x70\x159\x65\x6e\x6f\x73\x16f",
      //Kontejner mezistovho prenosu 
      L"\x4b\x6f\x6e\x74\x65\x6a\x6e\x65\x72\x20\x6d\x65\x7a\x69\x73\xed\x165\x6f\x76\xe9\x68\x6f\x20\x70\x159\x65\x6e\x6f\x73\x75",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Ciz duveryhodn objekt 
      L"\x43\x69\x7a\xed\x20\x64\x16f\x76\x11b\x72\x79\x68\x6f\x64\x6e\xfd\x20\x6f\x62\x6a\x65\x6b\x74",
      //Ciz objekty zabezpecen 
      L"\x43\x69\x7a\xed\x20\x6f\x62\x6a\x65\x6b\x74\x79\x20\x7a\x61\x62\x65\x7a\x70\x65\x10d\x65\x6e\xed",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x405,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Privatadresse 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x50\x72\x69\x76\x61\x74\x61\x64\x72\x65\x73\x73\x65",
      //homePostalAddress,Adresse (privat) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x28\x70\x72\x69\x76\x61\x74\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskab 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x62",
      //memberOf,Medlem af 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //info,Bemrkninger 
      L"\x69\x6e\x66\x6f\x2c\x42\x65\x6d\xe6\x72\x6b\x6e\x69\x6e\x67\x65\x72",
      //info,Noter 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Kontor 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72",
      //physicalDeliveryOfficeName,Kontoradresse 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72\x61\x64\x72\x65\x73\x73\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //title,Jobtitel 
      L"\x74\x69\x74\x6c\x65\x2c\x4a\x6f\x62\x74\x69\x74\x65\x6c",
      //title,Stilling 
      L"\x74\x69\x74\x6c\x65\x2c\x53\x74\x69\x6c\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Adresse p Webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      //url,Adresse p webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,Logon p arbejdsstationer 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x4c\x6f\x67\x6f\x6e\x20\x70\xe5\x20\x61\x72\x62\x65\x6a\x64\x73\x73\x74\x61\x74\x69\x6f\x6e\x65\x72",
      //userWorkstations,Log p arbejdsstationer 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x4c\x6f\x67\x20\x70\xe5\x20\x61\x72\x62\x65\x6a\x64\x73\x73\x74\x61\x74\x69\x6f\x6e\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse p Websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //wWWHomePage,Adresse p websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //info,Bemrkninger 
      L"\x69\x6e\x66\x6f\x2c\x42\x65\x6d\xe6\x72\x6b\x6e\x69\x6e\x67\x65\x72",
      //info,Noter 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Kontor 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72",
      //physicalDeliveryOfficeName,Kontoradresse 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72\x61\x64\x72\x65\x73\x73\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Adresse p Webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      //url,Adresse p webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse p Websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //wWWHomePage,Adresse p websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Navn 
      L"\x63\x6e\x2c\x4e\x61\x76\x6e",
      //dc,Navn 
      L"\x64\x63\x2c\x4e\x61\x76\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Privatadresse 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x50\x72\x69\x76\x61\x74\x61\x64\x72\x65\x73\x73\x65",
      //homePostalAddress,Adresse (privat) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x28\x70\x72\x69\x76\x61\x74\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //info,Bemrkninger 
      L"\x69\x6e\x66\x6f\x2c\x42\x65\x6d\xe6\x72\x6b\x6e\x69\x6e\x67\x65\x72",
      //info,Noter 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskab 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x62",
      //memberOf,Medlem af 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Kontor 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72",
      //physicalDeliveryOfficeName,Kontoradresse 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x4b\x6f\x6e\x74\x6f\x72\x61\x64\x72\x65\x73\x73\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,Jobtitel 
      L"\x74\x69\x74\x6c\x65\x2c\x4a\x6f\x62\x74\x69\x74\x65\x6c",
      //title,Stilling 
      L"\x74\x69\x74\x6c\x65\x2c\x53\x74\x69\x6c\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Adresse p Webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      //url,Adresse p webside (andre) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x69\x64\x65\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse p Websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //wWWHomePage,Adresse p websted 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adresse p Websted 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x57\x65\x62\x73\x74\x65\x64",
      //url,Adresse p websted 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x70\xe5\x20\x77\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"site-Display",
      L"classDisplayName",
      //Omrde 
      L"\x4f\x6d\x72\xe5\x64\x65",
      //Websted 
      L"\x57\x65\x62\x73\x74\x65\x64",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //MSMQ Enterprise 
      L"\x4d\x53\x4d\x51\x20\x45\x6e\x74\x65\x72\x70\x72\x69\x73\x65",
      //MSMQ-netvrk 
      L"\x4d\x53\x4d\x51\x2d\x6e\x65\x74\x76\xe6\x72\x6b",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"nTDSService-Display",
      L"classDisplayName",
      //Active Directory-tjeneste 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x2d\x74\x6a\x65\x6e\x65\x73\x74\x65",
      //Tjenesten Active Directory 
      L"\x54\x6a\x65\x6e\x65\x73\x74\x65\x6e\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x406,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationale ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      //internationalISDNNumber,Intl. ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppenmitgliedschaft 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6e\x6d\x69\x74\x67\x6c\x69\x65\x64\x73\x63\x68\x61\x66\x74",
      //memberOf,Mitglied von 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x74\x67\x6c\x69\x65\x64\x20\x76\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Internationale ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      //primaryInternationalISDNNumber,Intl. ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Anmeldename (fr Windows NT 3.5x/4.0) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x6e\x6d\x65\x6c\x64\x65\x6e\x61\x6d\x65\x20\x28\x66\xfc\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x33\x2e\x35\x78\x2f\x34\x2e\x30\x29",
      //samAccountName,Anmeldename (Pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x6e\x6d\x65\x6c\x64\x65\x6e\x61\x6d\x65\x20\x28\x50\x72\xe4\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Gruppenname (fr Windows NT 3.5x/4.0) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x75\x70\x70\x65\x6e\x6e\x61\x6d\x65\x20\x28\x66\xfc\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x33\x2e\x35\x78\x2f\x34\x2e\x30\x29",
      //samAccountName,Gruppenname (Pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x75\x70\x70\x65\x6e\x6e\x61\x6d\x65\x20\x28\x50\x72\xe4\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Name 
      L"\x63\x6e\x2c\x4e\x61\x6d\x65",
      //dc,Name 
      L"\x64\x63\x2c\x4e\x61\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationale ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      //internationalISDNNumber,Intl. ISDN-Nummer (Andere) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72\x20\x28\x41\x6e\x64\x65\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppenmitgliedschaft 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6e\x6d\x69\x74\x67\x6c\x69\x65\x64\x73\x63\x68\x61\x66\x74",
      //memberOf,Mitglied von 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x74\x67\x6c\x69\x65\x64\x20\x76\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Internationale ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x65\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      //primaryInternationalISDNNumber,Intl. ISDN-Nummer 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x6c\x2e\x20\x49\x53\x44\x4e\x2d\x4e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Computername (fr Windows NT 3.5x/4.0) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x6d\x65\x20\x28\x66\xfc\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x33\x2e\x35\x78\x2f\x34\x2e\x30\x29",
      //samAccountName,Computername (Pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x6d\x65\x20\x28\x50\x72\xe4\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //cn,Name des Verzeichnisdienstes 
      L"\x63\x6e\x2c\x4e\x61\x6d\x65\x20\x64\x65\x73\x20\x56\x65\x72\x7a\x65\x69\x63\x68\x6e\x69\x73\x64\x69\x65\x6e\x73\x74\x65\x73",
      //cn,Verzeichnisdienstname 
      L"\x63\x6e\x2c\x56\x65\x72\x7a\x65\x69\x63\x68\x6e\x69\x73\x64\x69\x65\x6e\x73\x74\x6e\x61\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //location,Pfad 
      L"\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x2c\x50\x66\x61\x64",
      //location,Ort 
      L"\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x2c\x4f\x72\x74",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Untersttzt doppelseitiges Drucken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x55\x6e\x74\x65\x72\x73\x74\xfc\x74\x7a\x74\x20\x64\x6f\x70\x70\x65\x6c\x73\x65\x69\x74\x69\x67\x65\x73\x20\x44\x72\x75\x63\x6b\x65\x6e",
      //printDuplexSupported,Untersttzt beidseitiges Drucken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x55\x6e\x74\x65\x72\x73\x74\xfc\x74\x7a\x74\x20\x62\x65\x69\x64\x73\x65\x69\x74\x69\x67\x65\x73\x20\x44\x72\x75\x63\x6b\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"nTDSDSA-Display",
      L"classDisplayName",
      //Einstellungen des Domnencontrollers 
      L"\x45\x69\x6e\x73\x74\x65\x6c\x6c\x75\x6e\x67\x65\x6e\x20\x64\x65\x73\x20\x44\x6f\x6d\xe4\x6e\x65\x6e\x63\x6f\x6e\x74\x72\x6f\x6c\x6c\x65\x72\x73",
      //Domnencontrollereinstellungen 
      L"\x44\x6f\x6d\xe4\x6e\x65\x6e\x63\x6f\x6e\x74\x72\x6f\x6c\x6c\x65\x72\x65\x69\x6e\x73\x74\x65\x6c\x6c\x75\x6e\x67\x65\x6e",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"trustedDomain-Display",
      L"classDisplayName",
      //Vertrauenswrdige Domne 
      L"\x56\x65\x72\x74\x72\x61\x75\x65\x6e\x73\x77\xfc\x72\x64\x69\x67\x65\x20\x44\x6f\x6d\xe4\x6e\x65",
      //Vertraute Domne 
      L"\x56\x65\x72\x74\x72\x61\x75\x74\x65\x20\x44\x6f\x6d\xe4\x6e\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,Ver&walten...,RsAdmin.msc 
      L"\x30\x2c\x56\x65\x72\x26\x77\x61\x6c\x74\x65\x6e\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&Verwalten...,RsAdmin.msc 
      L"\x30\x2c\x26\x56\x65\x72\x77\x61\x6c\x74\x65\x6e\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Fremder Sicherheitsprincipal 
      L"\x46\x72\x65\x6d\x64\x65\x72\x20\x53\x69\x63\x68\x65\x72\x68\x65\x69\x74\x73\x70\x72\x69\x6e\x63\x69\x70\x61\x6c",
      //Fremder Sicherheitsprinzipal 
      L"\x46\x72\x65\x6d\x64\x65\x72\x20\x53\x69\x63\x68\x65\x72\x68\x65\x69\x74\x73\x70\x72\x69\x6e\x7a\x69\x70\x61\x6c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x407,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //directReports,?esa a?afe??e??? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3b1\x3bd\x3b1\x3c6\x3b5\x3c1\x3cc\x3bc\x3b5\x3bd\x3bf\x3b9",
      //directReports,?esa ?pe?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3c5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3b9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //division,???d?? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x39a\x3bb\x3ac\x3b4\x3bf\x3c2",
      //division,???a? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x3a4\x3bf\x3bc\x3ad\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,??a?????st??? ?pa?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3c5\x3c0\x3b1\x3bb\x3bb\x3ae\x3bb\x3bf\x3c5",
      //employeeID,??a?????st??? e??a?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3b5\x3c1\x3b3\x3b1\x3b6\x3bf\x3bc\x3ad\x3bd\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,?????????e?? p???ea 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x394\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3bf\x3cd\x3bc\x3b5\x3bd\x3bf\x20\x3c0\x3c1\x3cc\x3b8\x3b5\x3bc\x3b1",
      //generationQualifier,?p???a d???????a? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x395\x3c0\x3af\x3b8\x3b7\x3bc\x3b1\x20\x3b4\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3af\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //homeDrive,????a ???da d?s??? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x39a\x3cd\x3c1\x3b9\x3b1\x20\x3bc\x3bf\x3bd\x3ac\x3b4\x3b1\x20\x3b4\x3af\x3c3\x3ba\x3bf\x3c5",
      //homeDrive,?e?t???? ???da d?s??? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x39a\x3b5\x3bd\x3c4\x3c1\x3b9\x3ba\x3ae\x20\x3bc\x3bf\x3bd\x3ac\x3b4\x3b1\x20\x3b4\x3af\x3c3\x3ba\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,??e?t?????? d?e????s? 
      L"\x6d\x61\x69\x6c\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7",
      //mail,??e????s? ??e?t??????? ta??d??e??? 
      L"\x6d\x61\x69\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //manager,????st?e??? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a0\x3c1\x3bf\x3ca\x3c3\x3c4\x3ac\x3bc\x3b5\x3bd\x3bf\x3c2",
      //manager,?pe?????? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,????? ??da? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3bf\x3bc\x3ac\x3b4\x3b1\x3c2",
      //memberOf,????? t?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3c4\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,?????? ????t?? t??ef???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5",
      //mobile,?????? ????t?? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,????f??? ????a? (???a) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x3a4\x3b7\x3bb\x3ad\x3c6\x3c9\x3bd\x3bf\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b1\x29",
      //otherHomePhone,?????? t??ef???? ????a? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,??e?t?????? d?e????s? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //otherMailbox,??e????s? ??e?t??????? ta??d??e??? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? ????t?? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherMobile,?????? ????t?? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,?????? ??a ap?st??? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherPager,?????? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //pager,?????? ??a ap?st??? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      //pager,?????? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //postalCode,?a??d?????? ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b9\x3ba\x3cc\x3c2\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      //postalCode,?a?. ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x2e\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,???a s??des?? ???st? (p??? ta Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x38c\x3bd\x3bf\x3bc\x3b1\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2\x20\x3c7\x3c1\x3ae\x3c3\x3c4\x3b7\x20\x28\x3c0\x3c1\x3b9\x3bd\x20\x3c4\x3b1\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,???a s??des?? (p??? ta Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x38c\x3bd\x3bf\x3bc\x3b1\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2\x20\x28\x3c0\x3c1\x3b9\x3bd\x20\x3c4\x3b1\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,S??des? sta??? e??as?a? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x3a3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x20\x3c3\x3c4\x3b1\x3b8\x3bc\x3ce\x3bd\x20\x3b5\x3c1\x3b3\x3b1\x3c3\x3af\x3b1\x3c2",
      //userWorkstations,Sta??? e??as?a? s??des?? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x3a3\x3c4\x3b1\x3b8\x3bc\x3bf\x3af\x20\x3b5\x3c1\x3b3\x3b1\x3c3\x3af\x3b1\x3c2\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"group-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"group-Display",
      L"attributeDisplayNames",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //dc,???a 
      L"\x64\x63\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //directReports,?esa a?afe??e??? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3b1\x3bd\x3b1\x3c6\x3b5\x3c1\x3cc\x3bc\x3b5\x3bd\x3bf\x3b9",
      //directReports,?esa ?pe?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x386\x3bc\x3b5\x3c3\x3b1\x20\x3c5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3b9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,???d?? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x39a\x3bb\x3ac\x3b4\x3bf\x3c2",
      //division,???a? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x3a4\x3bf\x3bc\x3ad\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,??a?????st??? ?pa?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3c5\x3c0\x3b1\x3bb\x3bb\x3ae\x3bb\x3bf\x3c5",
      //employeeID,??a?????st??? e??a?????? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x391\x3bd\x3b1\x3b3\x3bd\x3c9\x3c1\x3b9\x3c3\x3c4\x3b9\x3ba\x3cc\x20\x3b5\x3c1\x3b3\x3b1\x3b6\x3bf\x3bc\x3ad\x3bd\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,?????????e?? p???ea 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x394\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3bf\x3cd\x3bc\x3b5\x3bd\x3bf\x20\x3c0\x3c1\x3cc\x3b8\x3b5\x3bc\x3b1",
      //generationQualifier,?p???a d???????a? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x395\x3c0\x3af\x3b8\x3b7\x3bc\x3b1\x20\x3b4\x3b7\x3bc\x3b9\x3bf\x3c5\x3c1\x3b3\x3af\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //internationalISDNNumber,??e???? a????? ISDN (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x394\x3b9\x3b5\x3b8\x3bd\x3ae\x3c2\x20\x3b1\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x49\x53\x44\x4e\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,??e?t?????? d?e????s? 
      L"\x6d\x61\x69\x6c\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7",
      //mail,??e????s? ??e?t??????? ta??d??e??? 
      L"\x6d\x61\x69\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //manager,????st?e??? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a0\x3c1\x3bf\x3ca\x3c3\x3c4\x3ac\x3bc\x3b5\x3bd\x3bf\x3c2",
      //manager,?pe?????? 
      L"\x6d\x61\x6e\x61\x67\x65\x72\x2c\x3a5\x3c0\x3b5\x3cd\x3b8\x3c5\x3bd\x3bf\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,????? ??da? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3bf\x3bc\x3ac\x3b4\x3b1\x3c2",
      //memberOf,????? t?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x39c\x3ad\x3bb\x3bf\x3c2\x20\x3c4\x3bf\x3c5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,?????? ????t?? t??ef???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5",
      //mobile,?????? ????t?? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherFacsimileTelephoneNumber,?????? fa? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c6\x3b1\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,????f??? ????a? (???a) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x3a4\x3b7\x3bb\x3ad\x3c6\x3c9\x3bd\x3bf\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b1\x29",
      //otherHomePhone,?????? t??ef???? ????a? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x3bf\x3b9\x3ba\x3af\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherIpPhone,?????? t??ef???? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x49\x50\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,??e?t?????? d?e????s? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x397\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3ae\x20\x3b4\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //otherMailbox,??e????s? ??e?t??????? ta??d??e??? (???e?) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b7\x3bb\x3b5\x3ba\x3c4\x3c1\x3bf\x3bd\x3b9\x3ba\x3bf\x3cd\x20\x3c4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b5\x3af\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? ????t?? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherMobile,?????? ????t?? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3ba\x3b9\x3bd\x3b7\x3c4\x3bf\x3cd\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,?????? ??a ap?st??? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherPager,?????? t??ee?d?p???s?? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //otherTelephone,?????? t??ef???? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3c6\x3ce\x3bd\x3bf\x3c5\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //pager,?????? ??a ap?st??? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3b3\x3b9\x3b1\x20\x3b1\x3c0\x3bf\x3c3\x3c4\x3bf\x3bb\x3ae\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      //pager,?????? t??ee?d?p???s?? 
      L"\x70\x61\x67\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3b7\x3bb\x3b5\x3b5\x3b9\x3b4\x3bf\x3c0\x3bf\x3af\x3b7\x3c3\x3b7\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //postalCode,?a??d?????? ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x3c5\x3b4\x3c1\x3bf\x3bc\x3b9\x3ba\x3cc\x3c2\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      //postalCode,?a?. ??d??a? 
      L"\x70\x6f\x73\x74\x61\x6c\x43\x6f\x64\x65\x2c\x3a4\x3b1\x3c7\x2e\x20\x3ba\x3ce\x3b4\x3b9\x3ba\x3b1\x3c2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x3ac\x3bb\x3bb\x3bf\x3b9\x29",
      //telexNumber,?????? t??e? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x391\x3c1\x3b9\x3b8\x3bc\x3cc\x3c2\x20\x3c4\x3ad\x3bb\x3b5\x3be\x20\x28\x386\x3bb\x3bb\x3bf\x3b9\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x3ac\x3bb\x3bb\x3b5\x3c2\x29",
      //url,??e????s? ?st?se??da? (???e?) 
      L"\x75\x72\x6c\x2c\x394\x3b9\x3b5\x3cd\x3b8\x3c5\x3bd\x3c3\x3b7\x20\x3b9\x3c3\x3c4\x3bf\x3c3\x3b5\x3bb\x3af\x3b4\x3b1\x3c2\x20\x28\x386\x3bb\x3bb\x3b5\x3c2\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"computer-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printerName,???atep???? 
      L"\x70\x72\x69\x6e\x74\x65\x72\x4e\x61\x6d\x65\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //printerName,???a 
      L"\x70\x72\x69\x6e\x74\x65\x72\x4e\x61\x6d\x65\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"nTFRSReplicaSet-Display",
      L"classDisplayName",
      //S????? ??p???a? FRS 
      L"\x3a3\x3cd\x3bd\x3bf\x3bb\x3bf\x20\x3c1\x3ad\x3c0\x3bb\x3b9\x3ba\x3b1\x3c2\x20\x46\x52\x53",
      //S????? ?ep???a? FRS 
      L"\x3a3\x3cd\x3bd\x3bf\x3bb\x3bf\x20\x3c1\x3b5\x3c0\x3bb\x3af\x3ba\x3b1\x3c2\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"organizationalUnit-Display",
      L"attributeDisplayNames",
      //ou,???atep???? 
      L"\x6f\x75\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //ou,???a 
      L"\x6f\x75\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"container-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"rpcContainer-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"trustedDomain-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"trustedDomain-Display",
      L"classDisplayName",
      //?p?st?? t??a? 
      L"\x388\x3bc\x3c0\x3b9\x3c3\x3c4\x3bf\x3c2\x20\x3c4\x3bf\x3bc\x3ad\x3b1\x3c2",
      //????p?st?? t??a? 
      L"\x391\x3be\x3b9\x3cc\x3c0\x3b9\x3c3\x3c4\x3bf\x3c2\x20\x3c4\x3bf\x3bc\x3ad\x3b1\x3c2",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"volume-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"mSMQConfiguration-Display",
      L"classDisplayName",
      //?a??et??? MSMQ 
      L"\x3a0\x3b1\x3c1\x3ac\x3bc\x3b5\x3c4\x3c1\x3bf\x3b9\x20\x4d\x53\x4d\x51",
      //????s? pa?a?t??? MSMQ 
      L"\x3a1\x3cd\x3b8\x3bc\x3b9\x3c3\x3b7\x20\x3c0\x3b1\x3c1\x3b1\x3bc\x3ad\x3c4\x3c1\x3c9\x3bd\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //?ta????? MSMQ 
      L"\x395\x3c4\x3b1\x3b9\x3c1\x3b9\x3ba\x3cc\x20\x4d\x53\x4d\x51",
      //?ta??e?a MSMQ 
      L"\x395\x3c4\x3b1\x3b9\x3c1\x3b5\x3af\x3b1\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //????????s? s??des?? MSMQ 
      L"\x394\x3c1\x3bf\x3bc\x3bf\x3bb\x3cc\x3b3\x3b7\x3c3\x3b7\x20\x3c3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x3c2\x20\x4d\x53\x4d\x51",
      //S??des? d???????s?? MSMQ 
      L"\x3a3\x3cd\x3bd\x3b4\x3b5\x3c3\x3b7\x20\x3b4\x3c1\x3bf\x3bc\x3bf\x3bb\x3cc\x3b3\x3b7\x3c3\x3b7\x3c2\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,&??a?e???s?...,RsAdmin.msc 
      L"\x30\x2c\x26\x394\x3b9\x3b1\x3c7\x3b5\x3af\x3c1\x3b9\x3c3\x3b7\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,??a&?e???s?...,RsAdmin.msc 
      L"\x30\x2c\x394\x3b9\x3b1\x26\x3c7\x3b5\x3af\x3c1\x3b9\x3c3\x3b7\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"remoteStorageServicePoint-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"default-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"foreignSecurityPrincipal-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"pKICertificateTemplate-Display",
      L"attributeDisplayNames",
      //cn,???atep???? 
      L"\x63\x6e\x2c