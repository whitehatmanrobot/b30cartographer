f (PackedKeyPack != NULL)
    {
        KdcFreeEncodedData(PackedKeyPack);
    }
    if (PackedAuthenticator != NULL)
    {
        KdcFreeEncodedData(PackedAuthenticator);
    }
    if (ClientKey != NULL)
    {
        CryptDestroyKey(ClientKey);
    }
    if (CertContext != NULL)
    {
        CertFreeCertificateContext(CertContext);
    }
    if(KdcCert)
    {
        CertFreeCertificateContext(KdcCert);
    }
    if (EncryptedKeyPack != NULL)
    {
        MIDL_user_free(EncryptedKeyPack);
    }
    if (EtypeArray != NULL)
    {
        MIDL_user_free(EtypeArray);
    }
    KerbFreeCertificateList(
        CertList
        );
    KerbFreeKey(&TempKey);
    if (PackedKey != NULL)
    {
        MIDL_user_free(PackedKey);
    }
    if (PackedPkAsRep != NULL)
    {
        if (PackedPkAsRep->value.preauth_data.value != NULL)
        {
            MIDL_user_free(PackedPkAsRep->value.preauth_data.value);
        }
        MIDL_user_free(PackedPkAsRep);
    }

    KerbFreeString(&ClientKdcName);
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcMyStoreWaitHandler
//
//  Synopsis:   Retrieves a copy of the KDC cert
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcMyStoreWaitHandler(
    PVOID pVoid,
    BOOLEAN fTimeout
    )
{

    PCCERT_CONTEXT Certificate = NULL, OldCertificate = NULL, Candidate = NULL;
    CERT_CHAIN_POLICY_STATUS  FinalChainStatus = {0};
    KERB_EXT_ERROR            DummyError;

    KERBERR KerbErr;
    BOOLEAN Found = FALSE;
    ULONG   PropertySize = 0;

    // Diagnostic: When's the last time this event fired?
    GetSystemTimeAsFileTime((PFILETIME) &KdcLastChangeEventTime);
    
    //
    // This was triggered by a timeout, so disable the store notification
    // for now...
    //
    if (fTimeout)
    {
        if (!CertControlStore(
                    KdcCertStore,                // in, the store to be controlled
                    0,                           // in, not used.
                    CERT_STORE_CTRL_CANCEL_NOTIFY,
                    &KdcCertStoreChangeEvent
                    ))
        {
            D_DebugLog((DEB_ERROR, "CertControlStore (cancel notify) failed - %x\n", GetLastError()));
        }
    }

    D_DebugLog((DEB_T_PKI, "Triggering KdcMyStoreWaitHandler()\n"));


    //
    // Resync store
    //
    CertControlStore(
                KdcCertStore,               // in, the store to be controlled
                0,                          // in, not used.
                CERT_STORE_CTRL_RESYNC,     // in, control action type
                NULL                        // Just resync store
                );


    RtlEnterCriticalSection(&KdcGlobalCertCritSect);


    // Our my store changed, so we need to find the cert again.
    if(GlobalKdcCert)
    {
        OldCertificate = CertDuplicateCertificateContext(GlobalKdcCert);
        KerbErr = KdcCheckCertificate(
                     GlobalKdcCert,
                     &DummyError,
                     &FinalChainStatus,
                     TRUE // this is a kdc certificate
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            CertFreeCertificateContext(GlobalKdcCert);
            GlobalKdcCert = NULL;
        }
        else
        {
            // certificate is good!
            // However, it may have been deleted, so
            // verify its existance
            while ((Certificate = CertEnumCertificatesInStore(
                                        KdcCertStore,
                                        Certificate)) != NULL)
            {
                if (CertCompareCertificate(
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            GlobalKdcCert->pCertInfo,
                            Certificate->pCertInfo
                            ))
                {
                    Found = TRUE;
                    break; // still there
                }
            }

            if (NULL != Certificate)
            {
                CertFreeCertificateContext(Certificate);
                Certificate = NULL;
            }

            if (Found)
            {
                goto Rearm;
            }

            CertFreeCertificateContext(GlobalKdcCert);
            GlobalKdcCert = NULL;
        }
    }

    if (NULL == GlobalKdcCert)
    {
        //
        // Enumerate all the certificates looking for the one we want
        //
        while ((Certificate = CertEnumCertificatesInStore(
                                            KdcCertStore,
                                            Certificate)) != NULL)
        {
            CERT_CHAIN_POLICY_STATUS TempStatus;

            //
            // Check to see if the certificate is the one we want
            //
            if (!CertGetCertificateContextProperty(
                Certificate,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,                           // no data
                &PropertySize))
            {
                continue;
            }
     
            //
            // Make sure the cert we selected was "good"
            //
            KerbErr = KdcCheckCertificate(
                            Certificate,
                            &DummyError,
                            &TempStatus,
                            TRUE // this is a kdc certificate
                            );


            if (!KERB_SUCCESS(KerbErr))
            {
                //
                // Hack - lots of times we can't find a CRL, but we have a "mostly"
                //        valid certificate.
                //
                if (TempStatus.dwError == CRYPT_E_REVOCATION_OFFLINE)
                {
                    if ( Candidate != NULL )
                    {
                        CertFreeCertificateContext(Candidate);
                    }

                    Candidate = CertDuplicateCertificateContext(Certificate);
                    D_DebugLog((DEB_ERROR, "Revocation offline - using somewhat good certificate\n"));
                }

                continue;
            }

            break;
        }
    }

    // Couldn't find a good certificate!
    if (NULL == Certificate)
    {

        //
        // Keep the old one... We might just be getting an offline CA
        //
        if (OldCertificate != NULL || Candidate != NULL)
        {

            if (OldCertificate)
            {
                D_DebugLog((DEB_T_PKI, "Re-using old certificate\n"));
                GlobalKdcCert = OldCertificate;
                OldCertificate = NULL;
            }
            else
            {
                GlobalKdcCert = Candidate;
                Candidate = NULL;
            }

            ReportServiceEvent(
                    EVENTLOG_WARNING_TYPE,
                    KDCEVENT_INVALID_KDC_CERTIFICATE,
                    sizeof(FinalChainStatus) - sizeof(void*),  // don't need ptr.
                    &FinalChainStatus,
                    0
                    );
            
        }
        else
        //
        // Never had one...
        //
        {
            DebugLog((DEB_ERROR, "No valid KDC certificate was available\n"));
            GlobalKdcCert = NULL;
        }
    }
    else
    {
        D_DebugLog((DEB_T_PKI, "Picked new KDC certificate\n"));
        GlobalKdcCert = Certificate;
    }


Rearm:

    if (OldCertificate != NULL)
    {
        CertFreeCertificateContext(OldCertificate);
    }

    if (Candidate != NULL)
    {
        CertFreeCertificateContext(Candidate);
    }


    RtlLeaveCriticalSection(&KdcGlobalCertCritSect);

    //
    // This was moved here because of race conditions associated w/ my store
    // chain building, where the event was getting fired rapidly, leading
    // us to loose notification, and thus- the re-arm.
    //


    CertControlStore(
        KdcCertStore,                       // in, the store to be controlled
        0,                                  // in, not used.
        CERT_STORE_CTRL_NOTIFY_CHANGE,      // in, control action type
        &KdcCertStoreChangeEvent            // in, the handle of the event
        );




}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetKdcCertificate
//
//  Synopsis:   Retrieves a copy of the KDC cert
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcGetKdcCertificate(
                     PCCERT_CONTEXT *KdcCert
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(!KdcGlobalCertCritSectInitialized)
    {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
    RtlEnterCriticalSection(&KdcGlobalCertCritSect);


    if (GlobalKdcCert == NULL)
    {
        DebugLog((DEB_WARN,"Unable to find KDC certificate in KDC store\n"));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

    // Increment the ref count, so if we change certs while the caller of this
    // is still using this cert, we won't delete it out from under.

    *KdcCert = CertDuplicateCertificateContext(GlobalKdcCert);
    if(*KdcCert == NULL)
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

Cleanup:


    RtlLeaveCriticalSection(&KdcGlobalCertCritSect);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeCerts
//
//  Synopsis:   Initializes data for cert handling
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcInitializeCerts(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;
    LPSTR TempString = NULL, StringCopy = NULL, EndPtr = NULL;
    ULONG TenHours;


    TenHours = (ULONG) 1000 * 60 * 60 * 10;

    Status = RtlInitializeCriticalSection(&KdcGlobalCertCritSect);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KdcGlobalCertCritSectInitialized = TRUE;

    if (!CryptAcquireContext(
            &KdcClientProvider,
            NULL,               // default container
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT
            ))
    {
        Status = GetLastError();
        DebugLog((DEB_ERROR,"Failed to acquire client crypt context: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Open the KDC store to get the KDC cert
    //

    KdcCertStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    0,                  // no encoding
                    NULL,               // no provider
                    CERT_STORE_OPEN_EXISTING_FLAG |
                    CERT_STORE_NO_CRYPT_RELEASE_FLAG |
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    KDC_PRIVATE_MY_STORE
                    );
    if (KdcCertStore == NULL)
    {
        Status = GetLastError();
        DebugLog((DEB_ERROR,"Failed to open %ws store: 0x%x\n", KDC_PRIVATE_MY_STORE,Status));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }


    // Create an auto-reset event that is to be signaled when
    // the my store is changed.  This event is initialized to Signaled
    // so that on first call to get a cert, we assume the my store is changed
    // and do all the work.

    KdcCertStoreChangeEvent = CreateEvent(
                                            NULL,
                                            FALSE,
                                            FALSE,
                                            NULL);

    if(NULL == KdcCertStoreChangeEvent)
    {
        Status = GetLastError();
        goto Cleanup;
    }


    if (! RegisterWaitForSingleObject(&KdcCertStoreWait,
                                      KdcCertStoreChangeEvent,
                                      KdcMyStoreWaitHandler,
                                      NULL,
                                      TenHours,
                                      WT_EXECUTEDEFAULT
                                      ))
    {
        Status = GetLastError();
        goto Cleanup;
    }


    //  Arm the cert store for change notification
    //  CERT_CONTROL_STORE_NOTIFY_CHANGE.

    if(!CertControlStore(
        KdcCertStore,                    // The store to be controlled
        0,                             // Not used
        CERT_STORE_CTRL_NOTIFY_CHANGE, // Control action type
        &KdcCertStoreChangeEvent))                      // Points to the event handle.
                                       //  When a change is detected,
                                       //  a signal is written to the
                                       //  space pointed to by
                                       //  hHandle.
    {
        // Notification is not avaialble, so kill the Event
        Status = GetLastError();
        goto Cleanup;
    }


    //
    // Initialize the object IDs
    //

    Index = 0;
    StringCopy = (LPSTR) MIDL_user_allocate(strlen(KERB_PKINIT_SIGNATURE_OID)+1);
    if (StringCopy == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    //
    // Scan the string for every '.' separated number
    //

    strcpy(
        StringCopy,
        KERB_PKINIT_SIGNATURE_OID
        );

    TempString = StringCopy;
    EndPtr = TempString;

    while (TempString != NULL)
    {
        ULONG Temp;

        while (*EndPtr != '\0' && *EndPtr != '.')
        {
            EndPtr++;
        }
        if (*EndPtr == '.')
        {
            *EndPtr = '\0';
            EndPtr++;
        }
        else
        {
            EndPtr = NULL;
        }

        sscanf(TempString,"%u",&Temp);
        KdcSignatureAlg[Index].value = (USHORT) Temp;
        KdcSignatureAlg[Index].next = &KdcSignatureAlg[Index+1];
        Index++;


        TempString = EndPtr;


    }
    DsysAssert(Index != 0);
    KdcSignatureAlg[Index-1].next = NULL;
    MIDL_user_free(StringCopy);
    StringCopy = NULL;



Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcCleanupCerts(FALSE);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCleanupCerts
//
//  Synopsis:   Cleans up data associated with certificate handling
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcCleanupCerts(
    IN BOOLEAN CleanupScavenger
    )
{

    HANDLE WaitHandle;


    //
    // Pete code used to hold the critsec in the callback.
    //
    if(KdcCertStoreWait)
    {
        WaitHandle = (HANDLE) InterlockedExchangePointer(&KdcCertStoreWait,NULL);
        UnregisterWaitEx(WaitHandle, INVALID_HANDLE_VALUE);
    }


    if(KdcGlobalCertCritSectInitialized)
    {
        RtlEnterCriticalSection(&KdcGlobalCertCritSect);
    }

    if (GlobalKdcCert != NULL)
    {
        CertFreeCertificateContext(
            GlobalKdcCert
            );
       GlobalKdcCert = NULL;
    }

    if (KdcCertStore != NULL)
    {
        CertCloseStore(
            KdcCertStore,
            CERT_CLOSE_STORE_FORCE_FLAG
            );
        KdcCertStore = NULL;
    }

    if(KdcCertStoreChangeEvent)
    {
        CloseHandle(KdcCertStoreChangeEvent);
        KdcCertStoreChangeEvent = NULL;
    }

    if (KdcClientProvider != NULL)
    {
        CryptReleaseContext(
            KdcClientProvider,
            0   // no flags
            );
        KdcClientProvider = NULL;
    }



    if(KdcGlobalCertCritSectInitialized)
    {
        RtlLeaveCriticalSection(&KdcGlobalCertCritSect);

        RtlDeleteCriticalSection(&KdcGlobalCertCritSect);
        KdcGlobalCertCritSectInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\restrict.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        restrict.cxx
//
// Contents:    Logon restriction code
//    This routine is called only on the KDC (not in kerberos)
//
//
// History:      4-Aug-1996     MikeSw          Created from tickets.cxx
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"

#include "fileno.h"
#define FILENO FILENO_RESTRICT


extern SAMPR_HANDLE GlobalAccountDomainHandle;


//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckLogonRestrictions
//
//  Synopsis:   Checks logon restrictions for an account
//
//  Effects:
//
//  Arguments:  UserHandle - handle to a user
//              Workstation - Name of client's workstation
//              SecondsToLogon - Receives logon duration in seconds
//
//  Requires:
//
//  Returns:    kerberos errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCheckLogonRestrictions(
    IN OPTIONAL PVOID UserHandle,
    IN PUNICODE_STRING Workstation,
    IN PUSER_ALL_INFORMATION UserAll,
    IN ULONG LogonRestrictionsFlags,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PNTSTATUS RetStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    LARGE_INTEGER KickoffTime;
    LARGE_INTEGER CurrentTime;
    PLARGE_INTEGER TempTime;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    //
    // The Administrator can be locked out  #248363
    // We need to check Lockout before PW_Expired or PW_MustChange
    //

    if (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
    {
        BOOL LockOut = TRUE;

        if (UserAll->UserId == DOMAIN_USER_RID_ADMIN)
        {
                PSAMPR_DOMAIN_INFO_BUFFER DomainPasswordInfo = NULL;

                D_DebugLog((DEB_TRACE,"KLIN(%x) Admin reached lockout limit - check sys properties\n",
                          KLIN(FILENO,__LINE__)));

                Status = SamrQueryInformationDomain(
                            GlobalAccountDomainHandle,
                            DomainPasswordInformation,
                            &DomainPasswordInfo );
                if (!NT_SUCCESS(Status))
                {
                    Status = STATUS_INTERNAL_ERROR;
                    goto Cleanup;
                }
                if( ((DOMAIN_PASSWORD_INFORMATION *)DomainPasswordInfo)->PasswordProperties & DOMAIN_LOCKOUT_ADMINS)
                {

                    D_DebugLog((DEB_TRACE,"KLIN(%x) Domain admin lockout enabled\n",
                              KLIN(FILENO,__LINE__)));
                        //
                        // get the safeboot mode - do not lockout Admin if in safeboot mode
                        //

                        if (KdcGlobalGlobalSafeBoot)
                        {
                            D_DebugLog((DEB_TRACE,"KLIN(%x) KDC in SafeBoot - no admin lockout\n",
                                      KLIN(FILENO,__LINE__)));
                            LockOut = FALSE;
                        }
                        
                } else
                {
                    D_DebugLog((DEB_TRACE,"KLIN(%x) Domain admin lockout disabled\n",
                              KLIN(FILENO,__LINE__)));
                    LockOut = FALSE;
                }
                SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainPasswordInfo,
                                                   DomainPasswordInformation );
        }

        if (LockOut) {
            Status = STATUS_ACCOUNT_LOCKED_OUT;
            goto Cleanup;
        }
    }

    //
    // Check the restrictions SAM doesn't:
    //

    TempTime = (PLARGE_INTEGER) &UserAll->AccountExpires;
    if ((TempTime->QuadPart != 0) &&
        (TempTime->QuadPart < CurrentTime.QuadPart))
    {
        Status = STATUS_ACCOUNT_EXPIRED;
        goto Cleanup;
    }

    //
    // For user accounts, check if the password has expired.
    //

    if (((LogonRestrictionsFlags & KDC_RESTRICT_IGNORE_PW_EXPIRATION) == 0) &&
        ((UserAll->UserAccountControl & USER_NORMAL_ACCOUNT) != 0))
    {
        TempTime = (PLARGE_INTEGER) &UserAll->PasswordMustChange;

        if (TempTime->QuadPart < CurrentTime.QuadPart)
        {
            if (TempTime->QuadPart == 0)
            {
                Status = STATUS_PASSWORD_MUST_CHANGE;
            }
            else
            {
                Status = STATUS_PASSWORD_EXPIRED;
            }
            goto Cleanup;
        }
    }

    if ((UserAll->UserAccountControl & USER_ACCOUNT_DISABLED))
    {
        Status = STATUS_ACCOUNT_DISABLED;
        goto Cleanup;
    }

    if ((UserAll->UserAccountControl & USER_SMARTCARD_REQUIRED) &&
        ((LogonRestrictionsFlags & KDC_RESTRICT_PKINIT_USED) == 0))
    {
        Status = STATUS_SMARTCARD_LOGON_REQUIRED;
        goto Cleanup;
    }

    if ((LogonRestrictionsFlags & KDC_RESTRICT_SAM_CHECKS) == 0)
    {

        DsysAssert(UserHandle); // don't need this unless we're doing SAM checks.

        Status = SamIAccountRestrictions(
                    UserHandle,
                    Workstation,
                    &UserAll->WorkStations,
                    &UserAll->LogonHours,
                    LogoffTime,
                    &KickoffTime
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

Cleanup:

    *RetStatus = Status;
    switch(Status)
    {
    case STATUS_SUCCESS:
        KerbErr = KDC_ERR_NONE;
        break;
    case STATUS_ACCOUNT_EXPIRED:    // See bug #23456
    case STATUS_ACCOUNT_LOCKED_OUT:
    case STATUS_ACCOUNT_DISABLED:
    case STATUS_INVALID_LOGON_HOURS:
    case STATUS_LOGIN_TIME_RESTRICTION:
    case STATUS_LOGIN_WKSTA_RESTRICTION:
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        break;
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_PASSWORD_MUST_CHANGE:
        KerbErr = KDC_ERR_KEY_EXPIRED;
        break;
    default:
        KerbErr = KDC_ERR_POLICY;
    }
    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\rpcif.cxx ===
//+-----------------------------------------------------------------------
//
// File:        RPCIF.CXX
//
// Contents:    RPC Interface specific functions
//
//
// History:     23 Feb 92   RichardW    Created
//
// BUG 453652:      Socket errors are tranlated to STATUS_OBJECT_NAME_NOT_FOUND
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "rpcif.h"
extern "C" {
#include <kdcdbg.h>
}


#define MAX_EXPR_LEN        50
////////////////////////////////////////////////////////////////////
//
//  Name:       RET_IF_ERROR
//
//  Synopsis:   Evaluates an expression, returns from the caller if error.
//
//  Arguments:  l    - Error level to print error message at.
//              e    - expression to evaluate
//
// NOTE: THIS MACRO WILL RETURN FROM THE CALLING FUNCTION ON ERROR!!!!
//
// This will execute the expression (e), and check the return code.  If the
// return code indicates a failure, it prints an error message and returns
// from the calling function.
//
#define RET_IF_ERROR(l,e)                                           \
    {   ULONG X_hr_XX__=(e) ;                                       \
        if (X_hr_XX__ != ERROR_SUCCESS) {                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == %d\n"      \
                            :                                       \
                                "%s(%d):\n\t %.*s == %d\n"          \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
            return(I_RpcMapWin32Status(X_hr_XX__));                 \
        }                                                           \
    }




////////////////////////////////////////////////////////////////////
//
//  Name:       WARN_IF_ERROR
//
//  Synopsis:   Evaluates an expression, prints warning if error.
//
//  Arguments:  l    - Error level to print warning at.
//              e    - expression to evaluate
//
//  Notes:      This calls DebugLog(()) to print.  In retail, it just
//              evaluates the expression.
//
#if DBG
#define WARN_IF_ERROR(l,e)                                          \
    {   ULONG X_hr_XX__=(e) ;                                       \
        if (X_hr_XX__ != ERROR_SUCCESS) {                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == %d\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == %d\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
        }                                                           \
    }
#else
#define WARN_IF_ERROR(l,e)  (e)
#endif




//+-------------------------------------------------------------------------
//
//  Function:   StartAllProtSeqs
//
//  Synopsis:   Checks which protocols are running and then starts those
//              protocols for the three KDC interfaces: kdc, locator, privilege
//              server.  It will, if USE_SECURE_RPC is defined, establish
//              credentials for the KDC.. Does not register interfaces.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


HRESULT
StartAllProtSeqs()
{
    TRACE(KDC, StartAllProtSeqs, DEB_FUNCTION);

    // Use all but ncacn_np. We'd like not to use LRPC as well, but
    // first spmgr and the security packages would have to be
    // changed. So, we live with it.

    DWORD dwErr;


    dwErr = RpcServerUseProtseq(L"ncalrpc",
                MAX_CONCURRENT_CALLS,
                0);

    if(dwErr)
    {
        DebugLog((DEB_ERROR, "UseProtseq failed %ws %d\n",
                  L"ncalrpc", dwErr));
    }

    dwErr = RpcServerUseProtseq(L"ncacn_ip_tcp",
                MAX_CONCURRENT_CALLS,
                0);

    if(dwErr)
    {
        DebugLog((DEB_ERROR, "UseProtseq failed %ws %d\n",
                  L"ncalrpc", dwErr));
    }



    return(STATUS_SUCCESS);

}



//+-------------------------------------------------------------------------
//
//  Function:   RegsiterKdcEps
//
//  Synopsis:   Registers Eps for the KDC and locator interfaces
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
HRESULT
RegisterKdcEps()
{
    TRACE(KDC, RegisterKdcEps, DEB_FUNCTION);

    RPC_BINDING_VECTOR  *   ppvVector;

    RET_IF_ERROR(DEB_ERROR, RpcServerInqBindings(&ppvVector));

    RET_IF_ERROR(DEB_ERROR, RpcEpRegister(KdcDebug_ServerIfHandle, ppvVector, 0, L"")) ;
    RET_IF_ERROR(DEB_ERROR, RpcServerRegisterIf(KdcDebug_ServerIfHandle, 0, 0)) ;


    RpcBindingVectorFree(&ppvVector);
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   UnRegsiterKdcEps
//
//  Synopsis:   UnRegisters Eps for the KDC and locator interfaces
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
HRESULT
UnRegisterKdcEps()
{
    TRACE(KDC, RegisterKdcEps, DEB_FUNCTION);

    RPC_BINDING_VECTOR  *   ppvVector;

    RET_IF_ERROR(DEB_ERROR, RpcServerInqBindings(&ppvVector));

    WARN_IF_ERROR(DEB_ERROR, RpcServerUnregisterIf(KdcDebug_ServerIfHandle, 0, 0)) ;


    RpcBindingVectorFree(&ppvVector);
    return(STATUS_SUCCESS);
}




void *
MIDL_user_allocate(size_t size)
{
//    TRACE(KDC, MIDL_user_allocate, DEB_FUNCTION);

    PVOID pvMem;

    //
    // The ASN.1 marshalling code may allocate odd sizes that can't be
    // encrypted with a block cipher. By rounding up the size to 8 we can
    // handle block sizes up to 8 bytes.
    //

    pvMem = RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                ROUND_UP_COUNT(size,8)
                );

    if ( pvMem == NULL )
    {
        DebugLog((DEB_ERROR, "MIDL allocate failed\n"));
    }
    else
    {
        RtlZeroMemory(pvMem, ROUND_UP_COUNT(size,8));
    }

    return(pvMem);


}

void
MIDL_user_free(void * ptr)
{
//    TRACE(KDC, MIDL_user_free, DEB_FUNCTION);

    RtlFreeHeap(RtlProcessHeap(),0, ptr);

}

extern "C"
void
KdcFreeMemory(void * ptr)
{
    KdcFreeEncodedData(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\rpcif.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcif.h
//
// Contents:    RPC interface support functions
//
//
// History:     20-May-1996     Labeled         MikeSw
//
//------------------------------------------------------------------------

#ifndef __RPCIF_H__
#define __RPCIF_H__

// #define USE_SECURE_RPC

#define MAX_CONCURRENT_CALLS 10

NTSTATUS   StartRPC(LPTSTR, LPTSTR);
NTSTATUS   StartAllProtSeqs(void);
NTSTATUS   StopRPC(void);
NTSTATUS   SetAuthData();
NTSTATUS RegisterKdcEps();
NTSTATUS UnRegisterKdcEps();

NTSTATUS   RpcTransportNameRegister();
NTSTATUS   RpcTransportNameDeRegister();
BOOLEAN    RpcTransportCheckRegistrations();
LPSTR   RpcString(LPSTR);
SECURITY_STATUS   RPC_SECNTSTATUS(ULONG);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\secdata.cxx ===
//+-----------------------------------------------------------------------
//
// File:        secdata.cxx
//
// Contents:    Global data and methods on it.
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include <kpasswd.h>

///////////////////////////////////////////////////////////////
//
//
// Global data
//

// This is all the security information that gets cached.

CSecurityData SecData;

CAuthenticatorList * Authenticators;
CAuthenticatorList * ReplayDetect;



///////////////////////////////////////////////////////////////
//
//
// Prototypes
//



fLsaPolicyChangeNotificationCallback KdcPolicyChangeCallback;




//+-------------------------------------------------------------------------
//
//  Function:   KdcPolicyChangeCallBack
//
//  Synopsis:   Function that gets called when policy changes
//
//  Effects:    Changes policy variables
//
//  Arguments:  MonitorInfoClass - class of data that changed
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcPolicyChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status;
    WCHAR Class[10];

    TRACE(KDC, KdcPolicyChangeCallBack, DEB_FUNCTION);

    Status = SecData.ReloadPolicy(MonitorInfoClass);

    if (!NT_SUCCESS(Status))
    {
        _itow(MonitorInfoClass, Class, 10 );

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_POLICY_UPDATE_FAILED,
            sizeof(NTSTATUS),
            &Status,
            1,                  // number of strings
            Class
            );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::ReloadPolicy
//
//  Synopsis:   Reloads a particular piece of policy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CSecurityData::ReloadPolicy(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_DOMAIN_INFORMATION DomainPolicy = NULL;
    PLSAPR_POLICY_INFORMATION LocalPolicy = NULL;
    WCHAR Class[10];

    TRACE(KDC, CSecurityData::ReloadPolicy, DEB_FUNCTION);

    //
    // Ignore changes to non-kerberos ticket information
    //

    switch(MonitorInfoClass) {
    case PolicyNotifyDomainKerberosTicketInformation:

        Status = LsarQueryDomainInformationPolicy(
                    GlobalPolicyHandle,
                    PolicyDomainKerberosTicketInformation,
                    &DomainPolicy
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        break;
    case PolicyNotifyAuditEventsInformation:
        Status = LsarQueryInformationPolicy(
                    GlobalPolicyHandle,
                    PolicyAuditEventsInformation,
                    &LocalPolicy
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        break;
    default:
        return(STATUS_SUCCESS);
    }

    //
    // Update the changed information in the KDCs global data structures.
    //
    //
    // Current policy defaults, see KirkSol/JBrezak
    // [Kerberos Policy]
    // MaxTicketAge=10 ;Maximum User Ticket Lifetime (hours)
    // MaxRenewAge=7   ;Maximum lifetime that a user tickeet can be renewed (days)
    // MaxServiceAge=60    ;Maximum Service Ticket Lifetime (minutes)
    // MaxClockSkew=5  ;Maximum tolerance for synchronization of computer clocks (minutes)
    // TicketValidateClient=1  ;Enforce user logon restrictions

    WriteLock();
    switch(MonitorInfoClass) {
    case PolicyNotifyDomainKerberosTicketInformation:

        DebugLog((DEB_TRACE, "MaxServiceTicketAge : %x\n", DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge.QuadPart));
        DebugLog((DEB_TRACE, "MaxTicketAge : %x\n", DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge.QuadPart));
        DebugLog((DEB_TRACE, "MaxRenewAge : %x\n", DomainPolicy->PolicyDomainKerbTicketInfo.MaxRenewAge.QuadPart));
        DebugLog((DEB_TRACE, "MaxClockSkew : %x\n", DomainPolicy->PolicyDomainKerbTicketInfo.MaxClockSkew.QuadPart));

        // Validate parameters

        if ((DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge.QuadPart <= (LONGLONG) -1) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge.QuadPart <= (LONGLONG) -1) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxRenewAge.QuadPart <= (LONGLONG) -1) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxClockSkew.QuadPart <= (LONGLONG) -1)  ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge.QuadPart == (LONGLONG) 0) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge.QuadPart == (LONGLONG) 0) )

        {
            _itow(MonitorInfoClass, Class, 10 );

            DebugLog((DEB_ERROR, "Policy update failed!\n"));
            
            ReportServiceEvent(
                EVENTLOG_ERROR_TYPE,
                KDCEVENT_POLICY_UPDATE_FAILED,
                sizeof(NTSTATUS),
                &Status,
                1,                  // number of strings
                Class
                );
        }
        else
        {

            _KDC_TgsTicketLifespan = DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge;
            _KDC_TgtTicketLifespan = DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge;
            _KDC_TicketRenewSpan = DomainPolicy->PolicyDomainKerbTicketInfo.MaxRenewAge;
                                                                                             
            //
            // never allow the skew window to drop down to zero, which prevents 
            // logon locally to the DC. The allowed skew window is at least 
            // 10 seconds for now
            //

            SkewTime.QuadPart = max(DomainPolicy->PolicyDomainKerbTicketInfo.MaxClockSkew.QuadPart, 10 * 10000000);
        }

        // Update domain policy flags. Don't depend on the flags keeping in sync
        // with the kerberos internal flags

        if ( DomainPolicy->PolicyDomainKerbTicketInfo.AuthenticationOptions &
             POLICY_KERBEROS_VALIDATE_CLIENT)
        {
            _KDC_Flags |= AUTH_REQ_VALIDATE_CLIENT;
        }
        else
        {
            _KDC_Flags &= ~AUTH_REQ_VALIDATE_CLIENT;
        }

        break;
    case PolicyNotifyAuditEventsInformation:

        if ((LocalPolicy->PolicyAuditEventsInfo.AuditingMode) &&
            (LocalPolicy->PolicyAuditEventsInfo.MaximumAuditEventCount > AuditCategoryAccountLogon))
        {


            if (LocalPolicy->PolicyAuditEventsInfo.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_SUCCESS )
            {
                _KDC_AuditEvents |= KDC_AUDIT_AS_SUCCESS | KDC_AUDIT_TGS_SUCCESS | KDC_AUDIT_MAP_SUCCESS;
            }
            else
            {
                _KDC_AuditEvents &= ~(KDC_AUDIT_AS_SUCCESS | KDC_AUDIT_TGS_SUCCESS | KDC_AUDIT_MAP_SUCCESS);
            }

            if (LocalPolicy->PolicyAuditEventsInfo.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_FAILURE )
            {
                _KDC_AuditEvents |= KDC_AUDIT_AS_FAILURE | KDC_AUDIT_TGS_FAILURE | KDC_AUDIT_MAP_FAILURE;
            }
            else
            {
                _KDC_AuditEvents &= ~(KDC_AUDIT_AS_FAILURE | KDC_AUDIT_TGS_FAILURE | KDC_AUDIT_MAP_FAILURE);
            }
        }

        break;
    }
    Unlock();

Cleanup:
    if (DomainPolicy != NULL)
    {
        LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
                    PolicyDomainKerberosTicketInformation,
                    DomainPolicy);
    }
    if (LocalPolicy != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyAuditEventsInformation,
                    LocalPolicy);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::SetForestRoot
//
//  Synopsis:   Sets the forest root
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CSecurityData::SetForestRoot(
    IN PUNICODE_STRING NewForestRoot
    )
{

    NTSTATUS Status;
    UNICODE_STRING Temp;

    WriteLock();

    RtlCopyMemory(
        &Temp,
        &_ForestRoot,
        sizeof(UNICODE_STRING)
        );


    Status = KerbDuplicateString(
                &_ForestRoot,
                NewForestRoot
                );

    // on alloc failure, just keep old version as it will never change
    if (!NT_SUCCESS(Status))
    {
        RtlCopyMemory(
            &_ForestRoot,
            &Temp,
            sizeof(UNICODE_STRING)
            );
    }
    else
    {
        KerbFreeString(&Temp);
    }

    _KDC_IsForestRoot = IsOurRealm(&_ForestRoot);

    Unlock();

    return Status;
}


////////////////////////////////////////////////////////////////////
//
//  Name:       CSecurityData::CSecurityData
//
//  Synopsis:   Constructor.
//
//  Arguments:  <none>
//
//  Notes:      .
//
CSecurityData::CSecurityData()
{
    TRACE(KDC, CSecurityData::CSecurityData, DEB_FUNCTION);

    RtlInitUnicodeString(
        &_MachineName,
        NULL
        );

    RtlInitUnicodeString(
        &_SamMachineName,
        NULL
        );

    RtlInitUnicodeString(
        &_MachineUpn,
        NULL
        );
    RtlInitUnicodeString(
        &_RealmName,
        NULL
        );
    RtlInitUnicodeString(
        &_KDC_Name,
        NULL
        );

    RtlInitUnicodeString(
        &_KDC_FullName,
        NULL
        );

    RtlInitUnicodeString(
        &_KDC_FullDnsName,
        NULL
        );

    RtlInitUnicodeString(
        &_KDC_FullKdcName,
        NULL
        );

    RtlInitUnicodeString(
         &_ForestRoot,
         NULL
         );


    _KerbRealmName = NULL;
    _KerbDnsRealmName = NULL;

    _KrbtgtServiceName = NULL;
    _KpasswdServiceName = NULL;

    RtlZeroMemory(
        &_KrbtgtTicketInfo,
        sizeof(KDC_TICKET_INFO)
        );
    _KrbtgtTicketInfoValid = FALSE;
    _KDC_CrossForestEnabled = FALSE;
    _KDC_IsForestRoot = FALSE;
    _fMonitorInitialized = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::InitLock
//
//  Synopsis:   Initializes the lock in the CSecurityData class.
//
//  Effects:
//
//  Arguments:  (none)
//
//  Returns:    STATUS_SUCCESS or error code
//
//  History:    2001-07-02  JSchwart  created
//
//  Notes:      This must be called before any other method of CSecurityData.
//              It needs to be separate from Init since SAM can call KDC routines
//              that use the global SecData before Init has been called in the
//              KDC ServiceMain.
//
//----------------------------------------------------------------------------

NTSTATUS
CSecurityData::InitLock(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(!_fMonitorInitialized);

    __try {
        RtlInitializeResource(&_Monitor);
    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if (NT_SUCCESS(Status))
    {
        _fMonitorInitialized = TRUE;
    }

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::Init
//
//  Synopsis:   Initializes the global data.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Returns:    STATUS_SUCCESS or error code
//
//  Signals:    May raise exception on out of memory.
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:      This must be called after InitLock and before any other
//              method of CSecurityData.  It gets data from the registry, the
//              domain object, and the kdc.ini file.
//
//----------------------------------------------------------------------------

NTSTATUS
CSecurityData::Init()
{
    TRACE(KDC, CSecurityData::Init, DEB_FUNCTION);

    NTSTATUS Status;
    UNICODE_STRING TempString;
    WCHAR TempMachineName[CNLEN+1];
    ULONG MachineNameLength = CNLEN+1;
    LARGE_INTEGER MaxAuthenticatorAge;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    UNICODE_STRING KadminName;
    UNICODE_STRING ChangePwName;


    D_DebugLog(( DEB_TRACE, "Entered CSecurityData::Init()\n" ));

    DsysAssert(_fMonitorInitialized);

    //
    // Get the domain name and ID from the registry
    //

    Status = KerbDuplicateString(
                &_RealmName,
                &GlobalDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &_KerbRealmName,
                        &GlobalDomainName)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Construct the KDC Name from the realm and the suffix.
    //


    RtlInitUnicodeString(
        &TempString,
        KDC_PRINCIPAL_NAME
        );

    Status = KerbDuplicateString(
                &_KDC_Name,
                &TempString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }



    if (!GetComputerName(
            TempMachineName,
            &MachineNameLength
            ))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &TempString,
        TempMachineName
        );
    Status = KerbDuplicateString(
                &_MachineName,
                &TempString
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &PolicyInfo
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // WAS BUG: this DNS name may have a trailing '.' - if so, strip it off
    //

    if (PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Length >= sizeof(WCHAR))
    {
        if (PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Buffer[ -1 + PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Length / sizeof(WCHAR) ] == L'.')
        {
            PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Length -= sizeof(WCHAR);
        }
    }


    Status = KerbDuplicateString(
                &_DnsRealmName,
                (PUNICODE_STRING) &PolicyInfo->PolicyDnsDomainInfo.DnsDomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlUpcaseUnicodeString(
                &_DnsRealmName,
                &_DnsRealmName,
                FALSE
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &_KerbDnsRealmName,
                        &_DnsRealmName)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Build a sam style machine name
    //
    _SamMachineName.Length = _MachineName.Length + sizeof(WCHAR);
    _SamMachineName.MaximumLength = _SamMachineName.Length + sizeof(WCHAR);
    _SamMachineName.Buffer = (LPWSTR) MIDL_user_allocate(_SamMachineName.MaximumLength);
    if (_SamMachineName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        _SamMachineName.Buffer,
        _MachineName.Buffer,
        _MachineName.Length
        );
    _SamMachineName.Buffer[_MachineName.Length / sizeof(WCHAR)] = L'$';
    _SamMachineName.Buffer[_SamMachineName.Length / sizeof(WCHAR)] = L'\0';


    //
    // Build the machine UPN: machinename$@dns.domain.name
    //

    _MachineUpn.Length = _MachineName.Length + 2 * sizeof(WCHAR) + _DnsRealmName.Length;
    _MachineUpn.MaximumLength = _MachineUpn.Length + sizeof(WCHAR);
    _MachineUpn.Buffer = (LPWSTR) MIDL_user_allocate(_MachineUpn.MaximumLength);
    if (_MachineUpn.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        _MachineUpn.Buffer,
        _MachineName.Buffer,
        _MachineName.Length
        );
    _MachineUpn.Buffer[_MachineName.Length / sizeof(WCHAR)] = L'$';
    _MachineUpn.Buffer[1+_MachineName.Length / sizeof(WCHAR)] = L'@';
    RtlCopyMemory(
        _MachineUpn.Buffer + _MachineName.Length / sizeof(WCHAR) + 2 ,
        _DnsRealmName.Buffer,
        _DnsRealmName.Length
        );
    _MachineUpn.Buffer[_MachineUpn.Length / sizeof(WCHAR)] = L'\0';

    if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &_RealmName,
                &_KDC_Name,
                &_KDC_FullName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &_DnsRealmName,
                &_KDC_Name,
                &_KDC_FullDnsName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Build the full kdc name - a kerberos style name
    //

    _KDC_FullKdcName.Length = _KDC_Name.Length + _DnsRealmName.Length + sizeof(WCHAR);
    _KDC_FullKdcName.MaximumLength = _KDC_FullKdcName.Length + sizeof(WCHAR);
    _KDC_FullKdcName.Buffer = (LPWSTR) MIDL_user_allocate(_KDC_FullDnsName.MaximumLength);
    if (_KDC_FullKdcName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    RtlCopyMemory(
        _KDC_FullKdcName.Buffer,
        _KDC_Name.Buffer,
        _KDC_Name.Length
        );
    _KDC_FullKdcName.Buffer[_KDC_Name.Length / sizeof(WCHAR)] = L'/';
    RtlCopyMemory(
        _KDC_FullKdcName.Buffer + 1 + _KDC_Name.Length / sizeof(WCHAR),
        _DnsRealmName.Buffer,
        _DnsRealmName.Length
        );
    _KDC_FullKdcName.Buffer[_KDC_FullKdcName.Length / sizeof(WCHAR)] = L'\0';


    D_DebugLog((DEB_TRACE, "_KDC_Name='%wZ', MachineName='%wZ'\n",
                &_KDC_Name,
                &_MachineName ));

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &_DnsRealmName,
                &_KDC_Name,
                KRB_NT_SRV_INST,
                &_KrbtgtServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // Build the kdc name for kadmin/changepw.
    //

    RtlInitUnicodeString(
        &KadminName,
        KERB_KPASSWD_NAME
        );
    RtlInitUnicodeString(
        &ChangePwName,
        L"changepw"
        );

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &ChangePwName,
                &KadminName,
                KRB_NT_SRV_INST,
                &_KpasswdServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LoadParameters(GlobalAccountDomainHandle);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load parameters: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Create the authenticators.
    //
    
    //
    // In reality, set skew time to 5 minutes and same for authenticators.
    //
    
    SkewTime.QuadPart = (LONGLONG) 10000000 * 60 * 5;   
    MaxAuthenticatorAge = SkewTime;

    //
    // Create the authenticator list
    //

    Authenticators = new CAuthenticatorList( MaxAuthenticatorAge, 1 );
    if (Authenticators == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = Authenticators->Init();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Setup a list to track failed requests - we don't fail the
    // same request twice for the timeout time
    //

    ReplayDetect = new CAuthenticatorList( MaxAuthenticatorAge, 1 );
    if (ReplayDetect == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = ReplayDetect->Init();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Setup a list to track potential canidates for fwd'ing to PDC
    //
    Status = AsNegCacheInit();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Register for policy callbacks
    //

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                KdcPolicyChangeCallBack,
                PolicyNotifyDomainKerberosTicketInformation
                );

    if (NT_SUCCESS(Status))
    {
        Status = LsaIRegisterPolicyChangeNotificationCallback(
                    KdcPolicyChangeCallBack,
                    PolicyNotifyAuditEventsInformation
                    );

    }
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to register for policy changes: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = UpdateKrbtgtTicketInfo();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:
    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            PolicyInfo
            );
    }
    return(Status);

}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::Cleanup
//
//  Synopsis:   Cleans up the object
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
CSecurityData::Cleanup()
{
    TRACE(KDC, CSecurityData::Cleanup, DEB_FUNCTION);


    _KrbtgtTicketInfoValid = FALSE;

    KerbFreeString(&_RealmName);
    KerbFreeString(&_KDC_Name);
    KerbFreeString(&_KDC_FullName);
    KerbFreeString(&_KDC_FullDnsName);
    KerbFreeString(&_KDC_FullKdcName);
    KerbFreeString(&_MachineName);
    KerbFreeString(&_SamMachineName);
    KerbFreeString(&_MachineUpn);
    KerbFreeString(&_DnsRealmName);
    KerbFreeRealm(&_KerbRealmName);
    KerbFreeRealm(&_KerbDnsRealmName);
    KerbFreeKdcName(&_KrbtgtServiceName);
    KerbFreeKdcName(&_KpasswdServiceName);

    if (Authenticators != NULL)
    {
        delete Authenticators;
        Authenticators = NULL;
    }
    if (ReplayDetect != NULL)
    {
        delete ReplayDetect;
        ReplayDetect = NULL;
    }

    LsaIUnregisterAllPolicyChangeNotificationCallback(
        KdcPolicyChangeCallBack
        );

}


//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSecurityData::~CSecurityData()
{
    TRACE(KDC, CSecurityData::~CSecurityData, DEB_FUNCTION);

    Cleanup();

    //
    // This doesn't happen during Cleanup() because we want to
    // make sure it only happens once.
    //

    if (_fMonitorInitialized)
    {
        RtlDeleteResource(&_Monitor);
    }
}


NTSTATUS
CSecurityData::LoadParameters(SAMPR_HANDLE DomainHandle)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER OneHour, EightHours, TenHours;
    TRACE(KDC, CSecurityData::LoadParameters, DEB_FUNCTION);

    OneHour.QuadPart = (LONGLONG) 10000000 * 60 * 60 * 1;
    EightHours.QuadPart = (LONGLONG) 10000000 * 60 * 60 * 8;
    TenHours.QuadPart = (LONGLONG) 10000000 * 60 * 60 * 10;

    // New internal defaults according to JBrezak. 7/28/99
    //
    // Initialize Tgt lifetime to 10 hours.
    //

    _KDC_TgtTicketLifespan = TenHours;

    //
    // Initialize ticket max renew time to one hour.
    //

    _KDC_TicketRenewSpan = OneHour;

    //
    // Initialize Tgs lifetime to one hour.
    //

    _KDC_TgsTicketLifespan = OneHour;

    //
    // Initialize domain password replication skew tolerance to 60 minutes.
    //

    _KDC_DomainPasswordReplSkew.QuadPart = (LONGLONG) 60*60*10000000;

    //
    // Initialize restriciton lifetime to 20 minutes
    //

    _KDC_RestrictionLifetime.QuadPart = (LONGLONG) 20*60*10000000;

    //
    // Default authentication flags
    //

    _KDC_Flags = AUTH_REQ_ALLOW_FORWARDABLE |
                 AUTH_REQ_ALLOW_PROXIABLE |
                 AUTH_REQ_ALLOW_RENEWABLE |
                 AUTH_REQ_ALLOW_NOADDRESS |
                 AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY |
                 AUTH_REQ_ALLOW_VALIDATE |
                 AUTH_REQ_VALIDATE_CLIENT |
                 AUTH_REQ_OK_AS_DELEGATE |
                 AUTH_REQ_ALLOW_S4U_DELEGATE;

    _KDC_AuditEvents = 0;

    //
    // Get kerberos policy information
    //

    Status = ReloadPolicy(
                PolicyNotifyDomainKerberosTicketInformation
                );
    if (!NT_SUCCESS(Status))
    {
        if ((Status != STATUS_NOT_FOUND) && (Status != STATUS_OBJECT_NAME_NOT_FOUND))
        {
            DebugLog((DEB_ERROR,"Failed to reload kerberos ticket policy: 0x%x\n",Status));
            goto Cleanup;
        }
        Status = STATUS_SUCCESS;
    }

    //
    // Get audit information
    //

    Status = ReloadPolicy(
                PolicyNotifyAuditEventsInformation
                );

    if (!NT_SUCCESS(Status))
    {
        if (Status != STATUS_NOT_FOUND)
        {
            DebugLog((DEB_ERROR,"Failed to query audit event info: 0x%x\n",Status));
            goto Cleanup;
        }
        Status = STATUS_SUCCESS;
    }

Cleanup:

#if DBG
    DebugShowState();
#endif

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::GetKrbtgtTicketInfo
//
//  Synopsis:   Duplicates ticket info for krbtgt account
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
CSecurityData::GetKrbtgtTicketInfo(
    OUT PKDC_TICKET_INFO TicketInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG CredentialSize;

    RtlZeroMemory(
        TicketInfo,
        sizeof(KDC_TICKET_INFO)
        );

    ReadLock();
    if (!_KrbtgtTicketInfoValid)
    {
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Duplicate the cached copy of the KRBTGT information
    //

    *TicketInfo = _KrbtgtTicketInfo;
    TicketInfo->Passwords = NULL;
    TicketInfo->OldPasswords = NULL;
    TicketInfo->TrustSid = NULL;
    TicketInfo->AccountName.Buffer = NULL;

    if (!NT_SUCCESS(KerbDuplicateString(
        &TicketInfo->AccountName,
        &_KrbtgtTicketInfo.AccountName
        )))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KdcDuplicateCredentials(
                    &TicketInfo->Passwords,
                    &CredentialSize,
                    _KrbtgtTicketInfo.Passwords,
                    FALSE                               // don't marshall
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KdcDuplicateCredentials(
                    &TicketInfo->OldPasswords,
                    &CredentialSize,
                    _KrbtgtTicketInfo.OldPasswords,
                    FALSE                               // don't marshall
                    );

Cleanup:

    Unlock();

    if (!KERB_SUCCESS(KerbErr))
    {
        FreeTicketInfo(TicketInfo);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::UpdateKrbtgtTicketInfo
//
//  Synopsis:   Triggers an update of the krbtgt ticket info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CSecurityData::UpdateKrbtgtTicketInfo(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KDC_TICKET_INFO NewTicketInfo = {0};
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    KERB_EXT_ERROR ExtendedError; // dummy var

    WriteLock();
    _KrbtgtTicketInfoValid = FALSE;

    KerbErr = KdcGetTicketInfo(
                SecData.KdcServiceName(),
                0,              // no lookup flags
                FALSE,          // do not restrict user accounts (user2user)
                NULL,           // no principal name
                NULL,           // no realm
                &NewTicketInfo,
                &ExtendedError, // dummy
                NULL,           // no user handle
                USER_ALL_PASSWORDLASTSET,
                0L,             // no extended fields
                &UserInfo,
                NULL            // no group membership
                );

    if (KERB_SUCCESS(KerbErr))
    {
        FreeTicketInfo(
            &_KrbtgtTicketInfo
            );
        _KrbtgtTicketInfo = NewTicketInfo;
        _KrbtgtTicketInfoValid = TRUE;
        _KrbtgtPasswordLastSet = UserInfo->I1.PasswordLastSet;

        SamIFree_UserInternal6Information( UserInfo );
    }
    else
    {
        Status = KerbMapKerbError(KerbErr);
    }
    Unlock();
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAccountChangeNotificationRoutine
//
//  Synopsis:   Receives notification of changes to interesting accounts
//
//  Effects:    updatees cached krbtgt information
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // We are only interested in the krbtgt account
    //

    if (ObjectRid != DOMAIN_USER_RID_KRBTGT)
    {
        return(STATUS_SUCCESS);
    }

    Status = SecData.UpdateKrbtgtTicketInfo();
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to update krbtgt ticket info: 0x%x\n",Status));
    }

    return(Status);
}


#if DBG
////////////////////////////////////////////////////////////////////////////
//
//  Some debugging functions.
//
void
CSecurityData::DebugShowState(void)
{
    TRACE(KDC, CSecurityData::DebugShowState, DEB_FUNCTION);

    PrintTime(DEB_TRACE, "  TGT Ticket lifespan\t",  &_KDC_TgtTicketLifespan );
    PrintTime(DEB_TRACE, "  Ticket Renew Span\t",&_KDC_TicketRenewSpan );
    D_DebugLog((DEB_TRACE, "  Blank Addresses?\t%s\n",(_KDC_Flags & AUTH_REQ_ALLOW_NOADDRESS ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Proxies?       \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_PROXIABLE ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Renewable?     \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_RENEWABLE ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Postdated?     \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_POSTDATE ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Forwardable?   \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_FORWARDABLE ? "Yes" : "No")));

}

NTSTATUS
CSecurityData::DebugGetState(   DWORD     * KDCFlags,
                                TimeStamp * MaxLifespan,
                                TimeStamp * MaxRenewSpan)
{
    TRACE(KDC, CSecurityData::DebugGetState, DEB_FUNCTION);

    *KDCFlags = _KDC_Flags;
    *MaxLifespan = _KDC_TgtTicketLifespan;
    *MaxRenewSpan = _KDC_TicketRenewSpan;
    return(STATUS_SUCCESS);
}

NTSTATUS
CSecurityData::DebugSetState(   DWORD       KDCFlags,
                                TimeStamp   MaxLifespan,
                                TimeStamp   MaxRenewSpan)
{
    TRACE(KDC, CSecurityData::DebugSetState, DEB_FUNCTION);

    _KDC_Flags           = KDC_AUTH_STATE(KDCFlags);
    _KDC_AuditEvents     = KDC_AUDIT_STATE(KDCFlags);
    _KDC_TgtTicketLifespan  = MaxLifespan;
    _KDC_TicketRenewSpan = MaxRenewSpan;
    return(STATUS_SUCCESS);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\sockutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.h
//
// Contents:    Prototypes and types for KDC socket utility functions
//
//
// History:     12-July-1996    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __SOCKUTIL_H__
#define __SOCKUTIL_H__

#include <winsock2.h>
#include <atq.h>

typedef struct _KDC_ATQ_CONTEXT {
    LIST_ENTRY Next;
    ULONG References;
    PATQ_CONTEXT AtqContext;
    PVOID EndpointContext;
    OVERLAPPED * lpo;
    SOCKADDR Address;
    SOCKADDR LocalAddress;
    PBYTE WriteBuffer;
    ULONG WriteBufferLength;
    ULONG Flags;
    ULONG UsedBufferLength;
    ULONG BufferLength;
    ULONG ExpectedMessageSize;
    PUCHAR Buffer;
} KDC_ATQ_CONTEXT, *PKDC_ATQ_CONTEXT;

#define KDC_ATQ_WRITE_CONTEXT   0x1
#define KDC_ATQ_READ_CONTEXT    0x2
#define KDC_ATQ_SOCKET_CLOSED   0x4
#define KDC_ATQ_SOCKET_USED     (KDC_ATQ_WRITE_CONTEXT | KDC_ATQ_READ_CONTEXT)
#define KDC_MAX_BUFFER_LENGTH 0x20000        // maximum size receive buffer = 128k


NTSTATUS
KdcInitializeSockets(
    VOID
    );

NTSTATUS
KdcShutdownSockets(
    VOID
    );

#endif // __SOCKUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\tktutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tktutil.cxx
//
//  Contents:   
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------


// Place any local #includes files here.

#include "kdcsvr.hxx"
extern "C"
{
#include <dns.h>                // DNS_MAX_NAME_LENGTH
#include <ntdsa.h>              // CrackSingleName
#include <ntdsapip.h>           // DS_USER_PRINCIPAL_NAME_ONLY
}

#include <userall.h>

#include "refer.h"

#define FILENO FILENO_TKTUTIL
#define KDC_WSZ_GC              L"gc"
#define KDC_GC_NAMEPARTS        3

//#define DONT_SUPPORT_OLD_TYPES_KDC 1

//
// Static data
//

//
// Fudge factor for comparing timestamps, because network clocks may
// be out of sync.
// Note: The lowpart is first!
//

LARGE_INTEGER SkewTime;

//
// Mapping table for nametypes
//

WCHAR * KdcGlobalNameTypes[] =
{
    L"DS_UNKNOWN_NAME",
    L"DS_FQDN_1779_NAME",
    L"DS_NT4_ACCOUNT_NAME",
    L"DS_DISPLAY_NAME",
    NULL,
    NULL,
    L"DS_UNIQUE_ID_NAME",
    L"DS_CANONICAL_NAME",
    L"DS_USER_PRINCIPAL_NAME",
    L"DS_CANONICAL_NAME_EX",
    L"DS_SERVICE_PRINCIPAL_NAME",
    L"DS_SID_OR_SID_HISTORY_NAME",
    L"DS_DNS_DOMAIN_NAME",
};

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildNt4Name
//
//  Synopsis:   Construct an NT4 style name for an account by separating
//              the name into a principal & domain name, converting the
//              domain name to netbios, and then creating "domain\user" name.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildNt4Name(
    OUT LPWSTR * Nt4Name,
    OUT PUNICODE_STRING OutputRealm,
    IN PUNICODE_STRING Upn
    )
{
    ULONG Index;
    KERBERR KerbErr = KDC_ERR_NONE;
    LPWSTR OutputName = NULL;
    PKDC_DOMAIN_INFO DomainInfo = NULL;
    UNICODE_STRING RealmName;
    UNICODE_STRING PrincipalName;

    TRACE(KDC, KdcBuildNt4Name, DEB_FUNCTION);

    //
    // Find the first backslash or '@', or '.' in the name
    //

    RtlInitUnicodeString(
        OutputRealm,
        NULL
        );
    *Nt4Name = NULL;

    for (Index = Upn->Length/sizeof(WCHAR) - 1; Index > 0 ; Index-- )
    {
        if (Upn->Buffer[Index] == L'@')
        {
            break;
        }
    }

    if (Index == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Pull out the realm name and look it up in the list of domains
    //

    PrincipalName = *Upn;
    PrincipalName.Length = (USHORT) Index * sizeof(WCHAR);
    PrincipalName.MaximumLength = (USHORT) Index * sizeof(WCHAR);


    RealmName.Buffer = &Upn->Buffer[Index+1];
    RealmName.Length = (USHORT) (Upn->Length - (Index + 1) * sizeof(WCHAR));
    RealmName.MaximumLength = RealmName.Length;

    KdcLockDomainList();

    KerbErr = KdcLookupDomainName(
                &DomainInfo,
                &RealmName,
                &KdcDomainList
                );
    KdcUnlockDomainList();

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // We need a netbios name
    //

    if (DomainInfo->NetbiosName.Length == 0)
    {
        //
        // Copy out the realm name so we can return a non-authoritative referral
        //

        if (!NT_SUCCESS(KerbDuplicateString(
                OutputRealm,
                &DomainInfo->DnsName
                )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        KerbErr = KDC_ERR_WRONG_REALM;
        goto Cleanup;
    }

    //
    // now build the output name
    //

    OutputName = (LPWSTR) MIDL_user_allocate(DomainInfo->NetbiosName.Length + PrincipalName.Length + 2 * sizeof(WCHAR));
    if (OutputName == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        OutputName,
        DomainInfo->NetbiosName.Buffer,
        DomainInfo->NetbiosName.Length
        );
    OutputName[DomainInfo->NetbiosName.Length/sizeof(WCHAR)] = L'\\';
    RtlCopyMemory(
        OutputName + DomainInfo->NetbiosName.Length/sizeof(WCHAR) + 1,
        PrincipalName.Buffer,
        PrincipalName.Length
        );
    OutputName[1 + (PrincipalName.Length + DomainInfo->NetbiosName.Length)/sizeof(WCHAR)] = L'\0';

    *Nt4Name = OutputName;
    OutputName = NULL;
Cleanup:

    if (DomainInfo != NULL)
    {
        KdcDereferenceDomainInfo( DomainInfo );
    }
    if (OutputName != NULL)
    {
        MIDL_user_free( OutputName );
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeS4UTicketInfo
//
//  Synopsis:   Frees ticket info used in processing S4UProxy and S4USelf
//              requests.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//---
VOID
KdcFreeS4UTicketInfo(PKDC_S4U_TICKET_INFO S4UTicketInfo)
{
    TRACE(KDC, KdcFreeTgsTicketInfo, DEB_FUNCTION);
    if (S4UTicketInfo == NULL)
    {
        return;
    }

    KerbFreeKdcName( &S4UTicketInfo->RequestorServiceName );
    KerbFreeString( &S4UTicketInfo->RequestorServiceRealm );
    FreeTicketInfo( &S4UTicketInfo->RequestorTicketInfo );
    KerbFreeString( &S4UTicketInfo->TargetName );
    KerbFreeKdcName( &S4UTicketInfo->PACCName );
    KerbFreeString( &S4UTicketInfo->PACCRealm );
    KerbFreeKey( &S4UTicketInfo->EvidenceTicketKey );

    //
    // The evidence ticket is just a pointer to the source
    // ticket when doing S4USelf.  Otherwise, we unpacked it, and we've
    // got to free the memory.
    //
    if (( S4UTicketInfo->EvidenceTicket != NULL ) &&
        (( S4UTicketInfo->Flags & TI_FREETICKET ) != 0))
    {
        KerbFreeTicket( S4UTicketInfo->EvidenceTicket );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeU2UTicketInfo
//
//  Synopsis:  Frees ticket info used for U2U
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//---
VOID
KdcFreeU2UTicketInfo(PKDC_U2U_TICKET_INFO U2UTicketInfo)
{
    TRACE(KDC, KdcFreeTgsTicketInfo, DEB_FUNCTION);

    if (U2UTicketInfo == NULL)
    {
        return;
    }

    if ( U2UTicketInfo->Tgt )
    {
        KerbFreeTicket( U2UTicketInfo->Tgt );
    }

    KerbFreeKdcName( &U2UTicketInfo->TgtCName );
    KerbFreeString( &U2UTicketInfo->TgtCRealm );
    FreeTicketInfo( &U2UTicketInfo->TgtTicketInfo );
    KerbFreeKdcName( &U2UTicketInfo->cName );
    KerbFreeString( &U2UTicketInfo->cRealm );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcMatchCrossForestName
//
//  Synopsis:   Builds a list of the supplemental credentials and then
//              encrypts it with the supplied key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcMatchCrossForestName(
    IN PKERB_INTERNAL_NAME Principal,
    OUT PUNICODE_STRING RealmName
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    LSA_ROUTING_MATCH_TYPE  MatchType;
    KERBERR                 KerbErr = KDC_ERR_NONE;
    UNICODE_STRING          UnicodePrincipal = {0};

    TRACE(KDC, KdcMatchCrossForestName, DEB_FUNCTION);

    switch (Principal->NameType)
    {
    case KRB_NT_ENTERPRISE_PRINCIPAL:
        MatchType = RoutingMatchUpn;
        break;
    case KRB_NT_SRV_INST:
        MatchType = RoutingMatchSpn;
        break;
    default:

        return KRB_ERR_GENERIC;
    }

    KerbErr = KerbConvertKdcNameToString(
                    &UnicodePrincipal,
                    Principal,
                    NULL
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Can we match the SPN / UPN to external name space (realm)
    //
    Status = LsaIForestTrustFindMatch(
                    MatchType,
                    &UnicodePrincipal,
                    RealmName
                    );


    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "LsaIForestTrustFindMatch failed - %x\n",Status));
        goto Cleanup;
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
    }

    KerbFreeString(&UnicodePrincipal);

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCrackNameAtGC
//
//  Synopsis:   Cracks a name at a GC by first looking it up for
//              UPN/SPN and then constructing an NT4-style name to lookup
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCrackNameAtGC(
    IN PUNICODE_STRING Upn,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN ULONG KdcNameFlags,
    IN BOOLEAN bRestrictUserAccounts,
    IN BOOLEAN UseLocalHack,
    OUT PUNICODE_STRING RealmName,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN Referral,
    OUT PBOOLEAN CrossForest,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * UserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    LPWSTR NullTerminatedName = NULL;
    UNICODE_STRING CrackedDomain = {0};
    UNICODE_STRING LocalCrackedString = {0};
    LPWSTR CrackedDnsDomain = NULL;
    ULONG CrackedDomainLength = (DNS_MAX_NAME_LENGTH+1);
    LPWSTR CrackedName = NULL;
    ULONG CrackedNameLength = (UNLEN+DNS_MAX_NAME_LENGTH + 2);
    ULONG CrackError = 0;
    BOOLEAN Retry = TRUE;
    BOOLEAN ReferToRoot = FALSE, UsedHack = FALSE;
    ULONG NameFlags = DS_NAME_FLAG_TRUST_REFERRAL | DS_NAME_FLAG_GCVERIFY;
    UNICODE_STRING ForestRoot = {0};
    ULONG NameType;
    TRACE(KDC, KdcCrackNameAtGC, DEB_FUNCTION);

    if ( KdcNameFlags & KDC_NAME_S4U_CLIENT )
    {
        //
        // For S4U requests, the name is looked up by both UPN and AltSecId
        //

        NameType = DS_USER_PRINCIPAL_NAME_AND_ALTSECID;
    }
    else if ( KdcNameFlags & ( KDC_NAME_CLIENT | KDC_NAME_UPN_TARGET ))
    {
        //
        // For all other name and UPN, only UPN name will do (no AltSecId)
        //

        NameType = DS_USER_PRINCIPAL_NAME;
    }
    else
    {
        NameType = DS_SERVICE_PRINCIPAL_NAME;
    }

    *Authoritative = TRUE;

#ifdef notyet
    //
    // Check to see if the name is the machine name, and if so, don't try to
    // go to the GC.
    //

    if ((NameType == DS_USER_PRINCIPAL_NAME) &&
        RtlEqualUnicodeString(
            SecData.MachineUpn(),
            Upn,
            TRUE                        // case insensitive
            ))
    {
        DebugLog((DEB_ERROR,"Trying to lookup machine upn %wZ on GC - failing early\n",
            Upn));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }
#endif

    CrackedDnsDomain = (LPWSTR) MIDL_user_allocate(CrackedDomainLength * sizeof( WCHAR ));
    if (CrackedDnsDomain == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    CrackedName = (LPWSTR) MIDL_user_allocate(CrackedNameLength * sizeof ( WCHAR ));
    if (CrackedName == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // We can only retry for user principal names, which have a simple
    // structure.
    //

    if (NameType != DS_USER_PRINCIPAL_NAME)
    {
        Retry = FALSE;
    }

    //
    // So we didn't find the account locally. Now try the GC.
    //

    NullTerminatedName = KerbBuildNullTerminatedString(
                            Upn
                            );

    if (NullTerminatedName == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If we are in a recursive state, then we need to *not* go to
    // the GC, and try the crack locally.  This is because we'll go in
    // to a recursive tailspin and die.  this is a hack to escape this
    // situation until we work out a better soln. with DS folks.
    //

    if ( UseLocalHack )
    {    
        if (CrackedDnsDomain != NULL)
        {
            MIDL_user_free(CrackedDnsDomain);
        }

        if (CrackedName !=NULL)
        {
            MIDL_user_free(CrackedName);
        }

        //
        // note : these are guaranteed to be '\0' terminated.
        //
        CrackedDnsDomain = PrincipalName->Names[2].Buffer;
        CrackedName = PrincipalName->Names[1].Buffer;
        UsedHack = TRUE;

        DebugLog(( DEB_WARN, "Special case hack of %ws to '%ws' at domain '%ws'\n",
                   NullTerminatedName, CrackedName, CrackedDnsDomain ));

        Status = STATUS_SUCCESS ;
        CrackError = DS_NAME_NO_ERROR ;
        goto LocalHack ;
    }

Retry:

    Status = CrackSingleName(
                NameType,
                NameFlags,
                NullTerminatedName,
                DS_UNIQUE_ID_NAME,
                &CrackedDomainLength,
                CrackedDnsDomain,
                &CrackedNameLength,
                CrackedName,
                &CrackError
                );

LocalHack:

    if ((Status != STATUS_SUCCESS) ||
        ( ( CrackError != DS_NAME_NO_ERROR ) &&
        ( CrackError != DS_NAME_ERROR_DOMAIN_ONLY ) &&
        ( CrackError != DS_NAME_ERROR_TRUST_REFERRAL)) )
    {
        //
        // If the name is a duplicate, log an event
        //

        if (CrackError == DS_NAME_ERROR_NOT_UNIQUE)
        {
            WCHAR LookupType[10];
            WCHAR * LookupTypeStr;

            if (( NameType < sizeof( KdcGlobalNameTypes ) / sizeof( KdcGlobalNameTypes[0] )) &&
                ( KdcGlobalNameTypes[NameType] != NULL ))
            {
                LookupTypeStr = KdcGlobalNameTypes[NameType];
            }
            else
            {
                swprintf(LookupType,L"%d",(ULONG) NameType);
                LookupTypeStr = LookupType;
            }

            ReportServiceEvent(
                EVENTLOG_ERROR_TYPE,
                KDCEVENT_NAME_NOT_UNIQUE,
                0,
                NULL,
                2,
                NullTerminatedName,
                LookupTypeStr
                );
        }

        //
        // If we're in the root domain, we could be getting asked for a
        // name outside our forest.  Look now, and attempt to
        // create the ticket info for that external target realm
        //

        if (SecData.IsForestRoot() && SecData.IsCrossForestEnabled())
        {
            KerbErr = KdcMatchCrossForestName(
                            PrincipalName,
                            &CrackedDomain
                            );

            if (KERB_SUCCESS(KerbErr))
            {
                D_DebugLog((DEB_T_TICKETS, "xforest lookup directly - %wZ\n", &CrackedDomain)); // fester:  dumb down to DEB_T_TICKETS
                *CrossForest = TRUE;
            }
        }

        DebugLog((DEB_WARN,"Failed to resolve name %ws: 0x%x, %d\n",
                  NullTerminatedName,  Status ,CrackError ));

        if (Retry)
        {
            MIDL_user_free(NullTerminatedName);
            NullTerminatedName = NULL;

            KerbErr = KdcBuildNt4Name(
                        &NullTerminatedName,
                        &CrackedDomain,
                        Upn
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                //
                // If we got a wrong realm error, then we can return
                // a non-authorititive answer
                //
                if (KerbErr == KDC_ERR_WRONG_REALM)
                {
                    *Authoritative = FALSE;
                    KerbErr = KDC_ERR_NONE;
                }
                else
                {
                    goto Cleanup;
                }
            }
            else
            {
                NameType = DS_NT4_ACCOUNT_NAME;
                Retry = FALSE;

                //
                // Reset lengths
                //

                CrackedDomainLength = (DNS_MAX_NAME_LENGTH+1);
                CrackedNameLength = (UNLEN+DNS_MAX_NAME_LENGTH + 2);
                goto Retry;
            }
        }
        else
        {
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }
    }
    else if (CrackError == DS_NAME_ERROR_TRUST_REFERRAL)
    {
        //
        //  We got a Xforest referral, go to Root domain
        //

        D_DebugLog((DEB_T_TICKETS, "CrackName forest res- %S\n", CrackedDnsDomain));
        RtlInitUnicodeString(
            &CrackedDomain,
            CrackedDnsDomain
            );

        *CrossForest = TRUE;
    }
    else
    {
        //
        // Success...
        //
        D_DebugLog((DEB_T_TICKETS, "CrackName local - %S\n", CrackedDnsDomain));
        RtlInitUnicodeString(
            &CrackedDomain,
            CrackedDnsDomain
            );
    }

    //
    // Decide whether we can open the account locally.
    //

    if (SecData.IsOurRealm( &CrackedDomain ))
    {
        *Referral = FALSE;

        RtlInitUnicodeString(
            &LocalCrackedString,
            CrackedName
            );

        KerbErr = KdcGetTicketInfo(
                      &LocalCrackedString,
                      SAM_OPEN_BY_GUID,
                      bRestrictUserAccounts,
                      NULL,
                      NULL,
                      TicketInfo,
                      pExtendedError,
                      UserHandle,
                      WhichFields,
                      ExtendedFields,
                      UserInfo,
                      GroupMembership
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        //
        // For UPNs (client) referrals, we don't really need the referral
        // information at this stage.  Just returned the domain from
        // CrackSingleName() after checking that its a name we know about.
        //
        if ((KdcNameFlags & KDC_NAME_CLIENT) != 0)
        {
            D_DebugLog((DEB_T_TICKETS, "Generating UPN referral\n"));
            KerbDuplicateString(
                 RealmName,
                 &CrackedDomain
                 );

            //
            // If this wasn't a cross forest routing hint, then we must
            // know about the target domain. If it didn't exist in our
            // routing tables, we should fail.
            //

            if (!( *CrossForest ))
            {
                KerbErr = KdcFindReferralTarget(
                            TicketInfo,
                            RealmName,
                            pExtendedError,
                            &CrackedDomain,
                            FALSE,                          // not need ExactMatch
                            KdcNameFlags
                            );

                if (!KERB_SUCCESS(KerbErr))
                {
                    //
                    // Hack for broken trust recursion.
                    //
                    if (KerbErr == KDC_ERR_NO_TRUST_PATH)
                    {
                        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
                    }

                    D_DebugLog((DEB_T_TICKETS, "Got UPN w/ uknown trust path %x\n", KerbErr));
                    goto Cleanup;
                }
            }
        }
        else
        {
            //
            // This is either a UPN target (e.g. U2U), or this is an SPN
            // target.  In both cases, return the Xrealm keys we need.
            //
            D_DebugLog((DEB_T_TICKETS, "Generating SPN / UPN target referral\n"));

            //
            // Go to the root domain of our forest when we detect we need to go
            // xforest.
            //
            ReferToRoot = (((KdcNameFlags & ( KDC_NAME_SERVER | KDC_NAME_UPN_TARGET )) != 0) &&
                           (!SecData.IsForestRoot()) &&
                           (*CrossForest));

            if ( ReferToRoot )
            {
                Status = SecData.GetKdcForestRoot(&ForestRoot);

                if (!NT_SUCCESS(Status))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }

            KerbErr = KdcFindReferralTarget(
                        TicketInfo,
                        RealmName,
                        pExtendedError,
                        (ReferToRoot ? &ForestRoot : &CrackedDomain),
                        FALSE,                          // not need ExactMatch
                        KdcNameFlags
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                //
                // Hack for broken trust recursion.
                //

                if (KerbErr == KDC_ERR_NO_TRUST_PATH)
                {
                    KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
                }

                goto Cleanup;
            }

            //
            // Mark our referral realm as the cracked domain
            //

            if (ReferToRoot)
            {
                KerbFreeString(&ForestRoot);
                KerbFreeString(RealmName);
                KerbDuplicateString(
                    RealmName,
                    &CrackedDomain
                    );
            }
        }

        //
        // Everything worked, we found the referral target in our trust (or
        // a cross forest routing hint).
        //

        *Referral = TRUE;
    }

Cleanup:

    if (ReferToRoot && ForestRoot.Buffer != NULL )
    {
        KerbFreeString(&ForestRoot);
    }

    if (!UsedHack)
    {
        if (CrackedDnsDomain != NULL)
        {
            MIDL_user_free(CrackedDnsDomain);
        }
        if (CrackedName !=NULL)
        {
            MIDL_user_free(CrackedName);
        }
    }

    if (!*Authoritative)
    {
        KerbFreeString(&CrackedDomain);
    }

    if (NullTerminatedName != NULL)
    {
        MIDL_user_free(NullTerminatedName);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcRecursing
//
//  Synopsis:   Determines if we've started to recurse, and whether 
//              or not its ok to continue.
//
//  Effects:    
//
//  Arguments:  PrincipalName - name to normalize
//              PrincipalRealm - Realm that issued principal name
//              RequestRealm - Realm field of a KDC request
//              NameFlags - flags about name, may be:
//                      KDC_NAME_CLIENT or KDC_NAME_SERVER
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN 
KdcRecursing(
   IN PKERB_INTERNAL_NAME PrincipalName,
   IN OUT PBOOLEAN UseLocalHack
   )
{

    BOOLEAN fRet = FALSE;     
    UNICODE_STRING GCString;  
    SECPKG_CALL_INFO CallInfo;

    *UseLocalHack = FALSE;    


     if ( LsaIGetCallInfo( &CallInfo ) )
     {
        if ( CallInfo.Attributes & SECPKG_CALL_RECURSIVE )
        {
            //
            // This problem occurs when trying to crack a name of type:
            // gc/dc.domain/domain.  We're recursive, & trying to contact
            // a gc, so make some assumptions about the name.
            //
            RtlInitUnicodeString(
                &GCString,
                KDC_WSZ_GC
                );
            
            if (( PrincipalName->NameCount == KDC_GC_NAMEPARTS ) && 
                ( RtlEqualUnicodeString( &GCString, &PrincipalName->Names[0], TRUE )))
            {
                *UseLocalHack = TRUE;
            }
            else
            {
                fRet = TRUE;
            }
        }
     }           

     return fRet;
}







//+-------------------------------------------------------------------------
//
//  Function:   KdcNormalize
//
//  Synopsis:   Takes an input name and returns the appropriate ticket
//              information or referral information for that name
//
//  Effects:    If the name is not local, it may call the GC
//
//  Arguments:  PrincipalName - name to normalize
//              PrincipalRealm - Realm that issued principal name
//              RequestRealm - Realm field of a KDC request
//              NameFlags - flags about name, may be:
//                      KDC_NAME_CLIENT or KDC_NAME_SERVER
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcNormalize(
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PUNICODE_STRING PrincipalRealm,
    IN OPTIONAL PUNICODE_STRING RequestRealm,
    IN OPTIONAL PUNICODE_STRING  TgtClientRealm,
    IN ULONG NameFlags,
    IN BOOLEAN bRestrictUserAccounts,
    OUT PBOOLEAN Referral,
    OUT PUNICODE_STRING RealmName,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR  pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * UserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    BOOLEAN BuildUpn = FALSE;
    BOOLEAN CheckUpn = FALSE;
    BOOLEAN CheckSam = FALSE;
    BOOLEAN CheckGC = FALSE;
    BOOLEAN Reparse = FALSE;
    BOOLEAN DoLocalHack = FALSE;
    BOOLEAN Authoritative = TRUE;
    BOOLEAN CheckForInterDomain = FALSE;
    BOOLEAN ExactMatch = FALSE;
    BOOLEAN CrossForest = FALSE;
    BOOLEAN CheckForCrossForestTgt = FALSE;
    UNICODE_STRING OutputPrincipal = {0};
    UNICODE_STRING OutputRealm = {0};
    UNICODE_STRING InputName = {0};
    ULONG Index;
    UNICODE_STRING LocalPrincipalName = {0};
    UNICODE_STRING Upn = {0};


    TRACE(KDC, KdcNormalize, DEB_FUNCTION);

    *Referral = FALSE;

    if (!ARGUMENT_PRESENT(PrincipalName))
    {
        DebugLog((DEB_ERROR, "KdcNormalize: Null PrincipalName. Failing\n"));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Make sure the name is not zero length
    //

    if ((PrincipalName->NameCount == 0) ||
        (PrincipalName->Names[0].Length == 0))
    {
        DebugLog((DEB_ERROR, "KdcNormalize trying to crack zero length name. failing\n"));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    D_DebugLog((DEB_T_PAPI, "KdcNormalize [entering] normalizing name, WhichFields %#x, ExtendedFields %#x, PrincipalName ", WhichFields, ExtendedFields));
    D_KerbPrintKdcName((DEB_T_PAPI, PrincipalName));

    //
    // Check if we should look at the GC
    //

    if ((NameFlags & KDC_NAME_CHECK_GC) != 0)
    {
         CheckGC = TRUE;
    }


   
    switch(PrincipalName->NameType)
    {
    //
    //
    // We shouldn't see these types, ever !
    //
    case KRB_NT_PRINCIPAL_AND_ID:
    case KRB_NT_SRV_INST_AND_ID:

        //
        // Get the sid from the name
        //

        DsysAssert(FALSE); // these shouldn't be used anymore....

    default:
    case KRB_NT_UNKNOWN:
        //
        // Drop through to more interesting name types
        //

    case KRB_NT_SRV_HST:
    case KRB_NT_SRV_INST:
    case KRB_NT_PRINCIPAL:
        //
        // Principal names are just sam names
        //
        if (PrincipalName->NameCount == 1)
        {
            //
            // If the client supplied our realm name, check SAM - otherwise just
            // check for a UPN
            //

            if (SecData.IsOurRealm(RequestRealm))
            {
                D_DebugLog((DEB_TRACE, "KdcNormalize checking sam for request realm %wZ\n", RequestRealm));
                CheckSam = TRUE;
            }

            //
            // If we don't find it in SAM, build a UPN and look it up.
            //

            CheckUpn = TRUE;
            BuildUpn = TRUE;
            OutputPrincipal = PrincipalName->Names[0];

            if (ARGUMENT_PRESENT(RequestRealm))
            {
                OutputRealm = *RequestRealm;
            }
            else
            {
                OutputRealm = *SecData.KdcDnsRealmName();
            }
            break;
        }

        //
        // Drop through
        //

        //
        // Check to see if these are the 'krbtgt' account
        //

        if ((PrincipalName->NameCount == 2) &&
            RtlEqualUnicodeString(
                &PrincipalName->Names[0],
                SecData.KdcServiceName(),
                TRUE))                          // case insensitive
        {
            //
            // Check if this is for a different domain - if it is for our
            // domain but the principal domain is different, swap the
            // domain name.
            //

            if (ARGUMENT_PRESENT(PrincipalRealm) &&
                SecData.IsOurRealm(
                    &PrincipalName->Names[1]))
            {
                OutputRealm = *PrincipalRealm;
            }
            else
            {
                OutputRealm = PrincipalName->Names[1];
            }

            //
            // Strip trailing "."
            //

            if ((OutputRealm.Length > 0)  &&
                (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
            {
                OutputRealm.Length -= sizeof(WCHAR);
            }

            if (!SecData.IsOurRealm(
                    &OutputRealm
                    ))
            {
                CheckForInterDomain = TRUE;

                //
                // Some krbtgt names may be the result of going cross forest.
                // We may not generate the proper SPN in this case, because
                // we'll naturally check it as krbtgt/otherdomain@ourdomain.
                // If we're referring outside of our trust knowledge, this will
                // fail, so just use the SPN alone.
                //
                CheckForCrossForestTgt = TRUE;
            }
            else
            {
                CheckSam = TRUE;
            }

            OutputPrincipal = PrincipalName->Names[0];
            break;
        }

        //
        // Drop through
        //

    case KRB_NT_SRV_XHST:

        //
        // These names can't be SAM names ( SAM doesn't support this name
        // type) and can't be interdomain (or it would have be caught up
        // above).
        //
        // Check this name as a upn/spn.
        //

        CheckUpn = TRUE;
        BuildUpn = TRUE;

        break;
    case KRB_NT_ENT_PRINCIPAL_AND_ID:

        //
        // Get the sid from the name
        //
        DsysAssert(FALSE); // these shouldn't be used anymore....
    case KRB_NT_ENTERPRISE_PRINCIPAL:
        if (PrincipalName->NameCount != 1)
        {
            DebugLog((DEB_ERROR, "KdcNormalize enterprise name with more than one name part!\n"));
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            break;
        }
        OutputPrincipal = PrincipalName->Names[0];

        CheckUpn = TRUE;

        //
        // If the name wasn't found as a UPN/SPN, reparse and try
        // in SAM
        //

        InputName = PrincipalName->Names[0];
        Reparse = TRUE;
        CheckSam = TRUE;


        //
        // Check for these on the GC
        //

        OutputRealm = *SecData.KdcDnsRealmName();
        break;

    case KRB_NT_MS_PRINCIPAL_AND_ID:

        //
        // Get the sid from the name
        //
        DsysAssert(FALSE); // these shouldn't be used anymore....

    case KRB_NT_MS_PRINCIPAL:
        //
        // These are domainname \ username names
        //
        if (PrincipalName->NameCount > 2)
        {
            DebugLog((DEB_ERROR, "KdcNormalize MS principal has more than two name parts:"));
            KerbPrintKdcName(DEB_ERROR, PrincipalName);

            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }

        //
        // Never check the GC for these names
        //

        CheckGC = FALSE;

        //
        // If there are two names, the first one is the principal, the second
        // is the realm
        //

        if (PrincipalName->NameCount == 2)
        {
            DebugLog((DEB_WARN, "KdcNormalize client sent 2-part MS principalname!\n"));
            OutputPrincipal = PrincipalName->Names[0];
            OutputRealm = PrincipalName->Names[1];

            //
            // Strip trailing "."
            //

            if ((OutputRealm.Length > 0)  &&
                (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
            {
                OutputRealm.Length -= sizeof(WCHAR);
            }
        }
        else
        {
            InputName = PrincipalName->Names[0];
            Reparse = TRUE;
        }
        break;

    case KRB_NT_UID:
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        DebugLog((DEB_WARN, "KdcNormalize unsupported name type: %d\n", PrincipalName->NameType));
        goto Cleanup;
    }


    //
    // Determine our recursion state - we shouldn't be tanking
    //
    if (KdcRecursing( PrincipalName, &DoLocalHack ))
    {
        D_DebugLog((DEB_ERROR, "Recursing :\n"));
        D_KerbPrintKdcName((DEB_ERROR, PrincipalName));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

#if DBG

    if ( DoLocalHack )
    {
        DebugLog((DEB_ERROR, "Doing Local hack\n"));
    }

#endif
                     

    //
    // If we are supposed to reparse, then the name contains a name that we
    // have to process. Look for '@' and '\' separators.
    //

    if (Reparse)
    {
        DsysAssert(InputName.Length > 0);

        //
        // Find the first backslash or '@', or '.' in the name
        //

        for (Index = InputName.Length/sizeof(WCHAR) - 1; Index > 0 ; Index-- )
        {
            if ((InputName.Buffer[Index] == L'\\') ||
                (InputName.Buffer[Index] == L'@'))
            {
                break;
            }
        }

        //
        // If the name did not have one of those two separators, it
        // must have been of the form "name"
        //

        if (Index == 0)
        {
            OutputRealm = *SecData.KdcDnsRealmName();
            OutputPrincipal = InputName;

            //
            // Lookup this name in SAM.
            //

            CheckSam = TRUE;
        }
        else
        {
            //
            // The name had a '\' or an '@', so pick appart the two
            // pieces.
            //

            //
            // If the separator was an '@' then the second part of the name
            // is the realm. If it was an '\' then the first part is the
            // realm.
            //

            if (InputName.Buffer[Index] == L'@')
            {
                OutputPrincipal = InputName;
                OutputPrincipal.Length = (USHORT) Index * sizeof(WCHAR);
                OutputPrincipal.MaximumLength = (USHORT) Index * sizeof(WCHAR);

                OutputRealm.Buffer = &InputName.Buffer[Index+1];
                OutputRealm.Length = (USHORT) (InputName.Length - (Index + 1) * sizeof(WCHAR));
                OutputRealm.MaximumLength = OutputRealm.Length;

                //
                // Strip off a trailing '.'
                //

                if ((OutputRealm.Length > 0)  &&
                    (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
                {
                    OutputRealm.Length -= sizeof(WCHAR);
                }
            }
            else
            {
                DsysAssert(InputName.Buffer[Index] == L'\\');

                OutputRealm = InputName;
                OutputRealm.Length = (USHORT) Index * sizeof(WCHAR);
                OutputRealm.MaximumLength = (USHORT) Index * sizeof(WCHAR);

                OutputPrincipal.Buffer = &InputName.Buffer[Index+1];
                OutputPrincipal.Length = (USHORT) (InputName.Length - (Index + 1) * sizeof(WCHAR));
                OutputPrincipal.MaximumLength = OutputPrincipal.Length;
            }
        }

        if ((OutputRealm.Length > 0)  &&
            (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
        {
            OutputRealm.Length -= sizeof(WCHAR);
        }

        //
        // If the domain portion is not for our domain, don't check sam
        //

        if (!SecData.IsOurRealm(
                &OutputRealm
                ))

        {
            CheckForInterDomain = TRUE;
            CheckSam = FALSE;
        }
        else
        {
            //
            // If we don't have a separate realm for the name,
            // check for interdomain. This is because cross-realm
            // requests have our own realm name in the name but
            // another realm name in the domain.
            //

            if (RtlEqualUnicodeString(
                    &OutputPrincipal,
                    SecData.KdcServiceName(),
                    TRUE
                    ))
            {
                if (ARGUMENT_PRESENT(PrincipalRealm))
                {
                    //
                    // Try the supplied realm. If it is present, and points
                    // to a different domain, lookup up interdomain
                    //

                    OutputRealm = *PrincipalRealm;
                    if (!SecData.IsOurRealm(
                            &OutputRealm
                            ))
                    {
                        CheckForInterDomain = TRUE;
                        CheckSam = FALSE;
                    }
                    else
                    {
                        CheckSam = TRUE;
                    }
                }
                else
                {
                    CheckSam = TRUE;
                }
            }
            else
            {
                CheckSam = TRUE;
            }
        }
    }

    // We could end up with CheckUpn and BuildUpn with both client names
    // and spns. We need to allow spns of the type
    // service/hostname to be looked up in sam (without appending an @realm
    // to it). If KDC_NAME_SERVER is passed, it must be an spn, so, we
    // don't add the @realm

    if (CheckUpn)
    {
        D_DebugLog((DEB_T_TICKETS, "KdcNormalize checking UPN\n"));

        if (BuildUpn && ((NameFlags & KDC_NAME_SERVER) == 0))
        {
            D_DebugLog((DEB_T_TICKETS, "KdcNormalize building UPN\n"));
            KerbErr = KerbConvertKdcNameToString(
                        &Upn,
                        PrincipalName,
                        ARGUMENT_PRESENT(RequestRealm) ? RequestRealm : SecData.KdcDnsRealmName()
                        );
        }
        else
        {
            KerbErr = KerbConvertKdcNameToString(
                        &Upn,
                        PrincipalName,
                        NULL            // no realm name
                        );
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        D_DebugLog((DEB_T_TICKETS, "KdcNormalize Lookup up upn/spn %wZ\n", &Upn));

        KerbErr = KdcGetTicketInfo(
                    &Upn,
                    (NameFlags & KDC_NAME_SERVER) ? SAM_OPEN_BY_SPN : SAM_OPEN_BY_UPN,
                    bRestrictUserAccounts,
                    NULL,               // no principal name
                    NULL,               // no realm name,
                    TicketInfo,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Some errors aren't recoverable
        //

        if ((KerbErr == KDC_ERR_MUST_USE_USER2USER) ||
            (KerbErr == KDC_ERR_SVC_UNAVAILABLE))
        {
            goto Cleanup;
        }
    }

    //
    // Next check for sam account names, as some of these may later be looked
    // up as UPNs
    //

    if (CheckSam)
    {
        D_DebugLog((DEB_T_TICKETS, "KdcNormalize checking name in SAM\n"));

        KerbErr = KdcGetTicketInfo(
                    &OutputPrincipal,
                    0,                  // no lookup flags means sam name
                    bRestrictUserAccounts,
                    NULL,               // no principal name
                    NULL,               // no realm name,
                    TicketInfo,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Some errors aren't recoverable
        //

        if ((KerbErr == KDC_ERR_MUST_USE_USER2USER) ||
            (KerbErr == KDC_ERR_SVC_UNAVAILABLE))
        {
            goto Cleanup;
        }
    }

    //
    // Now, depending on which flags are set, try to do different things.
    //

    if (CheckForInterDomain)
    {
        D_DebugLog((DEB_T_TICKETS, "KdcNormalize checking name interdomain\n"));

        //
        // If the target name is not KRBTGT, this must be a referral.
        //

        if (!RtlEqualUnicodeString(
                &OutputPrincipal,
                SecData.KdcServiceName(),
                TRUE))                          // case insensitive
        {
            *Referral = TRUE;

        }
        if ((NameFlags & KDC_NAME_FOLLOW_REFERRALS) == 0)
        {
            //
            // We need an exact match on the domain name
            //

            if (*Referral)
            {
                DebugLog((DEB_ERROR, "KdcNormalize client asked for principal in another realm but no referrals!\n"));
                KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
                goto Cleanup;
            }

            //
            // We also only accept the krbtgt account name
            //

            ExactMatch = TRUE;
        }

        KerbErr = KdcFindReferralTarget(
                    TicketInfo,
                    RealmName,
                    pExtendedError,
                    &OutputRealm,
                    ExactMatch,
                    NameFlags
                    );

        if (KERB_SUCCESS(KerbErr))
        {       
            
            //
            // Hmmm. If the TGT's client isn't from our realm, and we picked up
            // a non-transitive trust, then this is the wrong path to take.
            // Toss this info, and continue to see if we can go through 
            // an xforest routing hint.
            // 
            if (ARGUMENT_PRESENT( TgtClientRealm ) && !SecData.IsOurRealm( TgtClientRealm ) && 
               ((TicketInfo->fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST) == 0))
            {
                DebugLog((DEB_ERROR, "Client outside of our realm is attempting to transit\n"));
                DebugLog((DEB_ERROR, "Trying xforest?\n"));
                FreeTicketInfo( TicketInfo ); 
                KerbFreeString( RealmName );
            }
            else
            {            
            
                //
                // If the output realm & the realm we asked for is different,
                // this is a referral (meaning an we don't have a password
                // for the principal name on this machine)
                //
    
                if (!KerbCompareUnicodeRealmNames(
                        RealmName,
                        &OutputRealm
                        ))
                {
                    *Referral = TRUE;
                }

                goto Cleanup;
            }
        }

    }

    if (CheckGC)
    {

        //
        // If the caller doesn't want us to follow referrals, fail here.
        //

        if ((NameFlags & KDC_NAME_FOLLOW_REFERRALS) == 0)
        {
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }

        if (Upn.Buffer == NULL )
        {
            //
            // Build the UPN here.  No reason to build it for tgt accounts.
            //
            if (!CheckForCrossForestTgt)
            {             
                KerbErr = KerbConvertKdcNameToString(
                            &Upn,
                            PrincipalName,
                            ARGUMENT_PRESENT(RequestRealm) ? RequestRealm : SecData.KdcDnsRealmName()
                            );
            }
            else
            {
                KerbErr = KerbConvertKdcNameToString(
                                &Upn,
                                PrincipalName,
                                NULL            // no realm name
                                );
            }

            D_DebugLog((DEB_T_TICKETS, "KdcNormalize building UPN\n"));


            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }
        DsysAssert(Upn.Buffer != NULL);
        D_DebugLog((DEB_T_TICKETS, "KdcNormalize checking name %wZ in GC\n", &Upn));


        //
        // This will allow us to open sam locally as well
        //

        KerbErr = KdcCrackNameAtGC(
                    &Upn,
                    PrincipalName,
                    NameFlags,
                    bRestrictUserAccounts,
                    DoLocalHack,
                    RealmName,
                    TicketInfo,
                    &Authoritative,
                    Referral,
                    &CrossForest,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );

        if (KERB_SUCCESS( KerbErr ))
        {
            D_DebugLog((DEB_T_TICKETS, "Found name in GC\n"));
            goto Cleanup;
        }

        //
        // LAST CHANCE :)
        //
        // This could be an interdomain TGT, potentialy w/ a target outside of our
        // forest.  Use the crackname call to determine whether or not to
        // allow the call to proceed.  If so, go to our root domain.
        //
        if ( CheckForCrossForestTgt && !DoLocalHack )
        {
            D_DebugLog((DEB_T_TICKETS, "Checking XForest krbtgt\n"));
            KerbErr = KdcCheckForCrossForestReferral(
                            TicketInfo,
                            RealmName,
                            pExtendedError,
                            &OutputRealm,
                            NameFlags
                            );

            if (KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_T_TICKETS, "KdcNormalize got referral (%wZ) destined for x forest - %wZ\n", RealmName,&OutputRealm));
                *Referral = TRUE;
                goto Cleanup;
            }
        }
    }

    KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;

Cleanup:

    KerbFreeString(
        &Upn
        );
    KerbFreeString(
        &LocalPrincipalName
        );

    if (KerbErr == KDC_ERR_C_PRINCIPAL_UNKNOWN)
    {
        if ((NameFlags & KDC_NAME_SERVER) != 0)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        }
    }

    
    D_DebugLog((DEB_T_PAPI, "KdcNormalize returning %#x\n", KerbErr));

    return (KerbErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTimeStamps
//
//  Synopsis:   Gets the current time and clock skew envelope.
//
//  Arguments:  [ptsFudge]    -- (in) amount of clock skew to allow.
//              [ptsNow]      -- (out) the current time
//              [ptsNowPlus]  -- (out) the current time plus the skew.
//              [ptsNowMinus] -- (out) the current time less the skew
//
//  History:    4-23-93   WadeR   Created
//
//----------------------------------------------------------------------------
void
GetTimeStamps(  IN  PLARGE_INTEGER ptsFudge,
                OUT PLARGE_INTEGER ptsNow,
                OUT PLARGE_INTEGER ptsNowPlus,
                OUT PLARGE_INTEGER ptsNowMinus )
{
    TRACE(KDC, GetTimeStamps, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME) ptsNow );
    ptsNowPlus->QuadPart = ptsNow->QuadPart + ptsFudge->QuadPart;
    ptsNowMinus->QuadPart = ptsNow->QuadPart - ptsFudge->QuadPart;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildTicketTimesAndFlags
//
//  Synopsis:   Computes the times and flags for a new ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildTicketTimesAndFlags(
    IN ULONG ClientPolicyFlags,
    IN ULONG ServerPolicyFlags,
    IN PLARGE_INTEGER DomainTicketLifespan,
    IN PLARGE_INTEGER DomainTicketRenewspan,
    IN OPTIONAL PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OPTIONAL PLARGE_INTEGER LogoffTime,
    IN OPTIONAL PLARGE_INTEGER AccountExpiry,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OUT PKERB_ENCRYPTED_TICKET Ticket,
    IN OUT OPTIONAL PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    LARGE_INTEGER RequestEndTime;
    LARGE_INTEGER RequestStartTime;
    LARGE_INTEGER RequestRenewTime;

    LARGE_INTEGER SourceEndTime;
    LARGE_INTEGER SourceRenewTime;
    LARGE_INTEGER SourceStartTime;
    ULONG SourceTicketFlags = 0;
    ULONG FinalTicketFlags = 0;
    ULONG KdcOptions = 0;

    LARGE_INTEGER FinalEndTime;
    LARGE_INTEGER FinalStartTime;
    LARGE_INTEGER FinalRenewTime;
    LARGE_INTEGER LocalLogoffTime;
    BOOLEAN Renewable = FALSE;

    LARGE_INTEGER CurrentTime;

    TRACE(KDC, KdcBuildTicketTimesAndFlags, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    FinalEndTime.QuadPart = 0;
    FinalStartTime.QuadPart = 0;
    FinalRenewTime.QuadPart = 0;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    D_DebugLog((DEB_T_TICKETS, "KdcBuildTicketTimesAndFlags ClientPolicyFlags %#x, ServerPolicyFlags %#x, KdcOptions %#x\n",
        ClientPolicyFlags, ServerPolicyFlags, KdcOptions));

    //
    // Get the force logoff time
    //

    if (ARGUMENT_PRESENT(LogoffTime))
    {
        LocalLogoffTime = *LogoffTime;
    }
    else
    {
        LocalLogoffTime = tsInfinity;
    }

    //
    // Get the request times out of the request
    //

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_starttime_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestStartTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
            NULL
            );
    }
    else
    {
        RequestStartTime.QuadPart = 0;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &RequestEndTime,
        &RequestBody->endtime,
        NULL
        );

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_renew_until_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestRenewTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
            NULL
            );
    }
    else
    {
        RequestRenewTime.QuadPart = 0;
    }

    //
    // Get the times out of the source ticket (if present)
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceStartTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_starttime,
                NULL
                );
        }
        else
        {
            SourceStartTime.QuadPart = 0;
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &SourceEndTime,
            &SourceTicket->endtime,
            NULL
            );

        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceRenewTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_renew_until,
                NULL
                );
        }
        else
        {
            SourceRenewTime.QuadPart = 0;
        }
        SourceTicketFlags = KerbConvertFlagsToUlong(&SourceTicket->flags);
        D_DebugLog((DEB_T_TICKETS, "KdcBuildTicketTimesAndFlags SourceTicketFlags %#x\n", SourceTicketFlags));
    }
    else
    {
        //
        // Set the maximums in this case, which is probably an AS request.
        //

        SourceStartTime = CurrentTime;
        SourceEndTime = tsInfinity;
        SourceRenewTime = tsInfinity;
        SourceTicketFlags = 0;

        //
        // Fill in the source flags from what the client policy & domain policy
        // allow
        //

        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_FORWARDABLE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_PROXIABLE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_POSTDATE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_RENEWABLE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_renewable;
        }
        D_DebugLog((DEB_T_TICKETS, "KdcBuildTicketTimesAndFlags SourceTicketFlags %#x by ClientPolicyFlags\n", SourceTicketFlags));
    }

    //
    // Start computing the flags, from algorithm in RFC1510 appendix A.6
    //

    //
    // Delegation flags
    //

    if ((ServerPolicyFlags & AUTH_REQ_OK_AS_DELEGATE) != 0)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_ok_as_delegate;
    }

    //
    // Forward flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_forwardable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_FORWARDABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        else
        {
            DebugLog((DEB_ERROR, "Asked for forwardable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }


    if (KdcOptions & KERB_KDC_OPTIONS_forwarded)
    {
        if (( KdcIssueForwardedTickets ) &&
            ( SourceTicketFlags & KERB_TICKET_FLAGS_forwardable ) &&
            ( ServerPolicyFlags & AUTH_REQ_ALLOW_FORWARDABLE ))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
        }
        else
        {
            DebugLog((DEB_ERROR, "Asked for forwarded but not allowed\n"));
            if ( !KdcIssueForwardedTickets )
            {
                DebugLog((DEB_TRACE, "Forwarded protection ON\n"));
            }
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (SourceTicketFlags & KERB_TICKET_FLAGS_forwarded)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
    }

    //
    // preauth flags
    //

    if (SourceTicketFlags & KERB_TICKET_FLAGS_pre_authent)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_pre_authent;
    }

    //
    // Proxy flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_proxiable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_PROXIABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        else
        {
            DebugLog((DEB_ERROR, "Asked for proxiable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_proxy)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_PROXIABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxy;
        }
        else
        {
            DebugLog((DEB_ERROR, "Asked for proxy but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    //
    // Postdate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_allow_postdate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_POSTDATE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        else
        {
            DebugLog((DEB_ERROR, "KdcBuildTicketTimesAndFlags asked for allow_postdate but not allowed: "
                "KdcOptions %#x, SourceTicketFlags %#x, ServerPolicyFlags %#x\n",
                KdcOptions, SourceTicketFlags, ServerPolicyFlags));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_postdated)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_POSTDATE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_postdated | KERB_TICKET_FLAGS_invalid;

            //
            // Start time is required here
            //

            if (RequestStartTime.QuadPart == 0)
            {
                DebugLog((DEB_ERROR, "KdcBuildTicketTimesAndFlags asked for postdate but start time not present: "
                    "KdcOptions %#x, SourceTicketFlags %#x, ServerPolicyFlags %#x\n",
                    KdcOptions, SourceTicketFlags, ServerPolicyFlags));
                KerbErr = KDC_ERR_CANNOT_POSTDATE;
                goto Cleanup;
            }
        }
        else
        {
            KerbErr = (SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) 
                       ?  KDC_ERR_POLICY : KDC_ERR_CANNOT_POSTDATE;
            DebugLog((DEB_ERROR, "KdcBuildTicketTimesAndFlags asked for postdated but not allowed: "
                "KdcOptions %#x, SourceTicketFlags %#x, ServerPolicyFlags %#x, KerbErr %#x\n",
                KdcOptions, SourceTicketFlags, ServerPolicyFlags, KerbErr));

            goto Cleanup;
        }
    }

    //
    // Validate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_invalid) == 0)
        {
            DebugLog((DEB_ERROR, "Trying to validate a valid ticket\n"));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
        if ((SourceStartTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart < CurrentTime.QuadPart - SkewTime.QuadPart))
        {
            DebugLog((DEB_ERROR, "Trying to validate a ticket before it is valid\n"));
            KerbErr = KRB_AP_ERR_TKT_NYV;
            goto Cleanup;
        }
    }

    //
    // Start filling in time fields
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        //
        // For S4UProxy, we need to use the authtime from the evidence ticket.
        // This ensures that the PAC_CLIENT_INFO (aka PAC verifier) remains
        // constant, and correct.
        //
        if ( ARGUMENT_PRESENT(S4UTicketInfo) &&
           ( S4UTicketInfo->Flags & TI_PRXY_REQUESTOR_THIS_REALM))
        {
            Ticket->authtime = S4UTicketInfo->EvidenceTicket->authtime;
        }
        else
        {
            Ticket->authtime = SourceTicket->authtime;
        }
    }
    else
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->authtime,
            NULL,
            &CurrentTime
            );
    }

    //
    // The times are computed differently for renewing a ticket and for
    // getting a new ticket.
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_renew) != 0)
    {
        if ((SourceRenewTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart == 0) ||
            ((SourceTicketFlags & KERB_TICKET_FLAGS_renewable) == 0) ||
            ((ServerPolicyFlags & AUTH_REQ_ALLOW_RENEWABLE) == 0))
        {
            DebugLog((DEB_ERROR,"Trying to renew a non-renewable ticket or against policy\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Make sure the renew time is in the future
        //

        if (SourceRenewTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew a ticket past its renew time\n"));
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
            goto Cleanup;
        }

        //
        // Make sure the end time is not in the past
        //

        if (SourceEndTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew an expired ticket\n"));
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
            goto Cleanup;
        }
        FinalStartTime = CurrentTime;

        //
        // The end time is the minimum of the current time plus lifespan
        // of the old ticket and the renew until time of the old ticket
        //

        FinalEndTime.QuadPart = CurrentTime.QuadPart + (SourceEndTime.QuadPart - SourceStartTime.QuadPart);
        if (FinalEndTime.QuadPart > SourceRenewTime.QuadPart)
        {
            FinalEndTime = SourceRenewTime;
        }
        FinalRenewTime = SourceRenewTime;
        FinalTicketFlags = SourceTicketFlags;

#if DBG
        D_DebugLog((DEB_T_TIME, "KdcBuildTicketTimesAndFlags Renewal ticket time info\n"));
        PrintTime(DEB_T_TIME, "  FinalRenewTime =", &FinalRenewTime);
        PrintTime(DEB_T_TIME, "  FinalEndTime =", &FinalEndTime);
        PrintTime(DEB_T_TIME, "  SourceEndTime =", &SourceEndTime);
        PrintTime(DEB_T_TIME, "  SourceRenewTime =", &SourceRenewTime);
#endif

        Renewable = TRUE;
    }
    else
    {
        //
        // Compute start and end times for normal tickets
        //

        //
        // Set the start time
        //

        if (RequestStartTime.QuadPart == 0)
        {
            FinalStartTime = CurrentTime;
        }
        else
        {
            FinalStartTime = RequestStartTime;
        }

        //
        // Set the end time
        //

        if (RequestEndTime.QuadPart == 0)
        {
            FinalEndTime = tsInfinity;
        }
        else
        {
            FinalEndTime = RequestEndTime;
        }

        if (FinalEndTime.QuadPart > SourceEndTime.QuadPart)
        {
            FinalEndTime = SourceEndTime;
        }

        if (FinalEndTime.QuadPart > CurrentTime.QuadPart + DomainTicketLifespan->QuadPart)
        {
            FinalEndTime.QuadPart = CurrentTime.QuadPart + DomainTicketLifespan->QuadPart;
        }

        //
        // Check for renewable-ok
        //

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable_ok) &&
            (FinalEndTime.QuadPart < RequestEndTime.QuadPart) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable))
        {
            KdcOptions |= KERB_KDC_OPTIONS_renewable;
            RequestRenewTime = RequestEndTime;

            //
            // Make sure that the source ticket had a renewtime (it
            // should because it is renewable)
            //

            DsysAssert(SourceRenewTime.QuadPart != 0);
            if (RequestRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                RequestRenewTime = SourceRenewTime;
            }
        }
    }

    if (!Renewable)
    {
        //
        // Compute renew times
        //

        if (RequestRenewTime.QuadPart == 0)
        {
            RequestRenewTime = tsInfinity;
        }

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_RENEWABLE))
        {
            FinalRenewTime = RequestRenewTime;
            if (FinalRenewTime.QuadPart > FinalStartTime.QuadPart + DomainTicketRenewspan->QuadPart)
            {
                FinalRenewTime.QuadPart = FinalStartTime.QuadPart + DomainTicketRenewspan->QuadPart;
            }

            DsysAssert(SourceRenewTime.QuadPart != 0);

            if (FinalRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                FinalRenewTime = SourceRenewTime;
            }
            FinalTicketFlags |= KERB_TICKET_FLAGS_renewable;

        }
        else
        {
            FinalRenewTime.QuadPart = 0;
        }
    }

    //
    // more on postdating
    //

    if (FinalStartTime.QuadPart > CurrentTime.QuadPart + SkewTime.QuadPart)
    {
        if ( ! ( (FinalTicketFlags & KERB_TICKET_FLAGS_may_postdate)
                 && (FinalTicketFlags & KERB_TICKET_FLAGS_postdated)
                 && (FinalTicketFlags & KERB_TICKET_FLAGS_invalid) ) )
        {
            DebugLog((DEB_ERROR, "KdcBuildTicketTimesAndFlags postdate CANNOT_POSTDATE: "
                "KdcOptions %#x, SourceTicketFlags %#x, SourceTicketFlags %#x, "
                "FinalStartTime %#I64x, CurrentTime %#I64x, SkewTime %#I64x\n",
                KdcOptions, SourceTicketFlags, ServerPolicyFlags,
                FinalStartTime.QuadPart, CurrentTime.QuadPart, SkewTime.QuadPart));

            KerbErr = KDC_ERR_CANNOT_POSTDATE;
        }
        else
        {
            DebugLog((DEB_ERROR, "KdcBuildTicketTimesAndFlags postdate ERR_POLICY: "
                "KdcOptions %#x, SourceTicketFlags %#x, SourceTicketFlags %#x, "
                "FinalStartTime %#I64x, CurrentTime %#I64x, SkewTime %#I64x\n",
                KdcOptions, SourceTicketFlags, ServerPolicyFlags,
                FinalStartTime.QuadPart, CurrentTime.QuadPart, SkewTime.QuadPart));

            KerbErr = KDC_ERR_POLICY; // do not allow postdating
        }
        FILL_EXT_ERROR_EX2(ExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Make sure the final ticket is valid
    //

    if (FinalStartTime.QuadPart > FinalEndTime.QuadPart)
    {
        DebugLog((DEB_ERROR, "Client asked for endtime before starttime\n"));
        KerbErr = KDC_ERR_NEVER_VALID;
        FILL_EXT_ERROR_EX(ExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Incorporate the logoff time (according to logon hours) by reseting
    // both the final end time and final renew time
    //

    if (FinalEndTime.QuadPart > LocalLogoffTime.QuadPart)
    {
        FinalEndTime.QuadPart = LocalLogoffTime.QuadPart;
    }

    if (FinalRenewTime.QuadPart > LocalLogoffTime.QuadPart)
    {
        FinalRenewTime.QuadPart = LocalLogoffTime.QuadPart;
    }

    //
    //  Tickets good only until acct expires.
    //  We make the assumption that the sam has
    //  already checked this against the current time
    //  when we're checking the logon restrictions.
    //
    if ((ARGUMENT_PRESENT(AccountExpiry) &&
         (AccountExpiry->QuadPart != 0 )))
    {
        if (FinalEndTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalEndTime.QuadPart = AccountExpiry->QuadPart;
        }


        if (FinalRenewTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalRenewTime.QuadPart = AccountExpiry->QuadPart;
        }
    }

    //
    // Fill in the times in the ticket
    //

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->KERB_ENCRYPTED_TICKET_starttime,
        NULL,
        &FinalStartTime
        );
    Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->endtime,
        NULL,
        &FinalEndTime
        );

    if (FinalRenewTime.QuadPart != 0)
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->KERB_ENCRYPTED_TICKET_renew_until,
            NULL,
            &FinalRenewTime
            );
        Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_renew_until_present;
    }

    //
    // Finally, get the remainder ticket flags, based on S4U logic, if needed.
    //
    // TBD: Set the right flags for proxy requests.
    //
    if ( ARGUMENT_PRESENT( S4UTicketInfo ) &&
       (( S4UTicketInfo->Flags & TI_S4USELF_INFO ) != 0))
    {
        //
        // If the client account is sensitive, turn off fwdable bit
        //
        if (( S4UTicketInfo->Flags & TI_SENSITIVE_CLIENT_ACCOUNT ) != 0)
        {
            FinalTicketFlags &= ~KERB_TICKET_FLAGS_forwardable;
            D_DebugLog((DEB_ERROR, "S4U - Turning off fwdable flag (client restriction)\n"));
        }
        else if ((( S4UTicketInfo->Flags & TI_TARGET_OUR_REALM ) != 0) &&
                 (( ServerPolicyFlags & AUTH_REQ_ALLOW_S4U_DELEGATE ) == 0))
        {
            //
            // If the server is in our realm, it must have T2A4D bit set.
            //
            FinalTicketFlags &= ~KERB_TICKET_FLAGS_forwardable;
            D_DebugLog((DEB_ERROR, "S4U - Turning off fwdable flag (svr restriction)\n"));
        }

    }

    //
    // Copy in the flags
    //

    DsysAssert(Ticket->flags.length == sizeof(ULONG) * 8);
    *((PULONG) Ticket->flags.value) = KerbConvertUlongToFlagUlong(FinalTicketFlags);

Cleanup:

#if DBG
        DebugLog((DEB_T_TIME, "KdcBuildTicketTimesAndFlags Final Ticket Flags %#x, times -\n", FinalTicketFlags));
        PrintTime(DEB_T_TIME, "  RequestRenewTime =", &RequestRenewTime);
        PrintTime(DEB_T_TIME, "  RequestEndTime =", &RequestEndTime);
        PrintTime(DEB_T_TIME, "  RequestStartTime =", &RequestStartTime);
        PrintTime(DEB_T_TIME, "  FinalRenewTime =", &FinalRenewTime);
        PrintTime(DEB_T_TIME, "  FinalEndTime =", &FinalEndTime);
        PrintTime(DEB_T_TIME, "  FinalStartTime =", &FinalStartTime);
        PrintTime(DEB_T_TIME, "  SourceRenewTime =", &SourceRenewTime);
        PrintTime(DEB_T_TIME, "  SourceEndTime =", &SourceEndTime);
        PrintTime(DEB_T_TIME, "  SourceStartTime =", &SourceStartTime);
#endif

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetUserKeys
//
//  Synopsis:   retrieves user keys
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcGetUserKeys(
    IN SAMPR_HANDLE UserHandle,
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    OUT PKERB_STORED_CREDENTIAL * Passwords,
    OUT PKERB_STORED_CREDENTIAL * OldPasswords,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    PKERB_STORED_CREDENTIAL Keys = NULL;
    PKERB_STORED_CREDENTIAL StoredCreds = NULL;
    PKERB_STORED_CREDENTIAL Cred64 = NULL;
    ULONG CredentialSize = 0;
    ULONG NewCredentialCount = 0;
    ULONG NewCredentialSize = 0;
    ULONG Index, CredentialIndex = 0, Offset;
    USHORT Flags = 0;
    PUCHAR Base;
    BOOLEAN UseStoredCreds = FALSE, UnMarshalledCreds = FALSE;
    PCRYPTO_SYSTEM NullCryptoSystem = NULL;
    BOOLEAN UseBuiltins = TRUE;
    PNT_OWF_PASSWORD OldNtPassword = NULL;
    PNT_OWF_PASSWORD OldNtPasswordSecond = NULL;
    NT_OWF_PASSWORD OldPasswordData = {0};             // Previous password (from current)
    NT_OWF_PASSWORD OldPasswordDataSecond = {0};       // Password history two previous (from current)
    PUSER_ALL_INFORMATION UserAll = &UserInfo->I1;

    TRACE(KDC, KdcGetUserKeys, DEB_FUNCTION);


    //
    // First get any primary credentials
    //

    Status = SamIRetrievePrimaryCredentials(
                UserHandle,
                &GlobalKerberosName,
                (PVOID *) &StoredCreds,
                &CredentialSize
                );

    //
    // if there is not value, it's O.K we will default to using
    // Builtin credentials
    //

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==Status)
    {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to retrieve primary credentials: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // We need to unmarshall these creds from the DS
    // They'll be stored in 32 bit format, but we've
    // got to put them into 64 bit format.
    // KerbUnpack32BitStoredCredential()
    //
#ifdef _WIN64

    Status = KdcUnpack32BitStoredCredential(
                  (PKERB_STORED_CREDENTIAL32) StoredCreds,
                  &Cred64,
                  &CredentialSize
                  );

    if (!NT_SUCCESS(Status))
    {
       DebugLog((DEB_ERROR, "Failed to unpack 32bit stored credential, contact Todds - %x\n", Status));
       DsysAssert(FALSE); // FATAL - If we ever fail above, contact Todds
       goto Cleanup;
    }

    if (NULL != StoredCreds)
    {
       LocalFree(StoredCreds);
       StoredCreds = Cred64;
       UnMarshalledCreds = TRUE; // diff't allocator
    }

#endif

    //
    // First compute the current passwords
    //

    //
    // Figure out the size of the stored credentials
    //
    if ((UserAll->UserAccountControl & USER_USE_DES_KEY_ONLY) != 0)
    {
        UseBuiltins = FALSE;
    }


    if ((StoredCreds != NULL) &&
        (CredentialSize > sizeof(KERB_STORED_CREDENTIAL) &&
        (StoredCreds->Revision == KERB_PRIMARY_CRED_REVISION) &&
        (CredentialSize > (sizeof(KERB_STORED_CREDENTIAL)
                            - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA))
                            + StoredCreds->CredentialCount * sizeof(KERB_KEY_DATA)
                            ))) &&
        (StoredCreds->DefaultSalt.Length + (ULONG_PTR) StoredCreds->DefaultSalt.Buffer <= CredentialSize ))
    {
        UseStoredCreds = TRUE;
        Flags = StoredCreds->Flags;

        NewCredentialSize += StoredCreds->DefaultSalt.Length;

        for (Index = 0; Index < StoredCreds->CredentialCount ; Index++ )
        {
            //
            // Validat the offsets
            //

            if ((StoredCreds->Credentials[Index].Key.keyvalue.length +
                  (ULONG_PTR) StoredCreds->Credentials[Index].Key.keyvalue.value <= CredentialSize )
                  &&
                (StoredCreds->Credentials[Index].Salt.Length +
                (ULONG_PTR) StoredCreds->Credentials[Index].Salt.Buffer <= CredentialSize ))

            {
                NewCredentialCount++;
                NewCredentialSize += sizeof(KERB_KEY_DATA) +
                    StoredCreds->Credentials[Index].Key.keyvalue.length +
                    StoredCreds->Credentials[Index].Salt.Length;
            }
            else
            {
                LPWSTR Buff = NULL;

                DebugLog((DEB_ERROR,"Corrupt credentials for user %wZ\n",
                    &UserAll->UserName ));

                DsysAssert(FALSE);

                Buff = KerbBuildNullTerminatedString(&UserAll->UserName);
                if (NULL == Buff)
                {
                   break;
                }

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_CORRUPT_CREDENTIALS,
                    0,                              // no raw data
                    NULL,                   // no raw data
                    1,                              // number of strings
                    Buff
                    );

                UseStoredCreds = FALSE;
                NewCredentialCount = 0;
                NewCredentialSize = 0;

                if (NULL != Buff)
                {
                   MIDL_user_free(Buff);
                }

                break;
            }
        }
    }

    //
    // If the password length is the size of the OWF password, use it as the
    // key. Otherwise hash it. This is for the case where not password is
    // set.
    //

    if (UseBuiltins)
    {
        //
        // Add a key for RC4_HMAC_NT
        //

        if (UserAll->NtPasswordPresent)
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC

        //
        // Add a key for RC4_HMAC_OLD & MD4_RC4
        if (UserAll->NtPasswordPresent)
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

        }
#endif

        //
        // if there is no password, treat it as blank
        //

        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;
        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC
        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;
        }
#endif
    }

    //
    // Add a key for the null crypto system
    //

    Status = CDLocateCSystem(
                KERB_ETYPE_NULL,
                &NullCryptoSystem
                );
    if (NT_SUCCESS(Status))
    {
        NewCredentialSize += sizeof(KERB_KEY_DATA) + NullCryptoSystem->KeySize;
        NewCredentialCount++;
    }

    //
    // Add the space for the base structure
    //

    NewCredentialSize += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));

    //
    // Allocate space for the credentials and start filling them in
    //

    Keys = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(NewCredentialSize);
    if (Keys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        Keys,
        NewCredentialSize
        );

    Offset = sizeof(KERB_STORED_CREDENTIAL) -
             (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
             NewCredentialCount * sizeof(KERB_KEY_DATA);

    Base = (PUCHAR) Keys;

    Keys->CredentialCount = (USHORT) NewCredentialCount;
    Keys->OldCredentialCount = 0;
    Keys->Revision = KERB_PRIMARY_CRED_REVISION;
    Keys->Flags = Flags;

    //
    // Add the credentials built from the OWF passwords first.
    //

    if (UseBuiltins)
    {
        //
        // Create the key for RC4_HMAC_NT
        //

        if (UserAll->NtPasswordPresent)
        {
            RtlCopyMemory(
                Base+Offset,
                UserAll->NtPassword.Buffer,
                UserAll->NtPassword.Length
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_HMAC_NT
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Offset += UserAll->NtPassword.Length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);
            CredentialIndex++;
        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC
        //
        // Create the key for RC4_HMAC_OLD
        //

        if (UserAll->NtPasswordPresent)
        {
            RtlCopyMemory(
                Base+Offset,
                UserAll->NtPassword.Buffer,
                UserAll->NtPassword.Length
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        (ULONG) KERB_ETYPE_RC4_HMAC_OLD
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
            Offset += UserAll->NtPassword.Length;
            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            CredentialIndex++;

            RtlCopyMemory(
                Base+Offset,
                UserAll->NtPassword.Buffer,
                UserAll->NtPassword.Length
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        (ULONG) KERB_ETYPE_RC4_MD4
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
            Offset += UserAll->NtPassword.Length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);
            CredentialIndex++;
        }
#endif

        //
        // If no passwords were present, add the null password
        //

        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            KERB_ENCRYPTION_KEY TempKey;
            UNICODE_STRING NullString;
            RtlInitUnicodeString(
                &NullString,
                NULL
                );
            KerbErr = KerbHashPassword(
                        &NullString,
                        KERB_ETYPE_RC4_HMAC_NT,
                        &TempKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Keys->Credentials[CredentialIndex].Key = TempKey;
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;
            RtlCopyMemory(
                Base+Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            CredentialIndex++;
            KerbFreeKey(&TempKey);

        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC
        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            KERB_ENCRYPTION_KEY TempKey;
            UNICODE_STRING NullString;
            RtlInitUnicodeString(
                &NullString,
                NULL
                );
            KerbErr = KerbHashPassword(
                        &NullString,
                        (ULONG) KERB_ETYPE_RC4_HMAC_OLD,
                        &TempKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Keys->Credentials[CredentialIndex].Key = TempKey;
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;
            RtlCopyMemory(
                Base+Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            CredentialIndex++;
            KerbFreeKey(&TempKey);

            KerbErr = KerbHashPassword(
                        &NullString,
                        (ULONG) KERB_ETYPE_RC4_MD4,
                        &TempKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Keys->Credentials[CredentialIndex].Key = TempKey;
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;
            RtlCopyMemory(
                Base+Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;
            CredentialIndex++;
            KerbFreeKey(&TempKey);
        }

#endif
    }
    //
    // Add the null crypto system
    //

    if (NullCryptoSystem != NULL)
    {
        UNICODE_STRING NullString;
        RtlInitUnicodeString(
            &NullString,
            NULL
            );

        Status = NullCryptoSystem->HashString(
                    &NullString,
                    Base+Offset
                    );
        DsysAssert(NT_SUCCESS(Status));

        Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base+Offset;
        Keys->Credentials[CredentialIndex].Key.keyvalue.length = NullCryptoSystem->KeySize;
        Keys->Credentials[CredentialIndex].Key.keytype = KERB_ETYPE_NULL;

        Offset += NullCryptoSystem->KeySize;

        CredentialIndex++;
    }

    //
    // Now add the stored passwords
    //

    if (UseStoredCreds)
    {
        //
        // Copy the default salt
        //

        if (StoredCreds->DefaultSalt.Buffer != NULL)
        {
            Keys->DefaultSalt.Buffer = (LPWSTR) (Base+Offset);

            RtlCopyMemory(
                Base + Offset,
                (PBYTE) StoredCreds->DefaultSalt.Buffer + (ULONG_PTR) StoredCreds,
                StoredCreds->DefaultSalt.Length
                );
            Offset += StoredCreds->DefaultSalt.Length;
            Keys->DefaultSalt.Length = Keys->DefaultSalt.MaximumLength = StoredCreds->DefaultSalt.Length;
        }

        for (Index = 0; Index < StoredCreds->CredentialCount ; Index++ )
        {
            //
            // Copy the key
            //

            Keys->Credentials[CredentialIndex] = StoredCreds->Credentials[Index];
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base+Offset;
            RtlCopyMemory(
                Keys->Credentials[CredentialIndex].Key.keyvalue.value,
                StoredCreds->Credentials[Index].Key.keyvalue.value + (ULONG_PTR) StoredCreds,
                StoredCreds->Credentials[Index].Key.keyvalue.length
                );
            Offset += StoredCreds->Credentials[Index].Key.keyvalue.length;

            //
            // Copy the salt
            //

            if (StoredCreds->Credentials[Index].Salt.Buffer != NULL)
            {
                Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base+Offset);

                RtlCopyMemory(
                    Base + Offset,
                    (PBYTE) StoredCreds->Credentials[Index].Salt.Buffer + (ULONG_PTR) StoredCreds,
                    StoredCreds->Credentials[Index].Salt.Length
                    );
                Offset += StoredCreds->Credentials[Index].Salt.Length;
                Keys->Credentials[CredentialIndex].Salt.Length =
                    Keys->Credentials[CredentialIndex].Salt.MaximumLength =
                        StoredCreds->Credentials[Index].Salt.Length;
            }

            CredentialIndex++;
        }
    }

    DsysAssert(CredentialIndex == NewCredentialCount);
    DsysAssert(Offset == NewCredentialSize);
    *Passwords = Keys;
    Keys = NULL;


    //
    // Now compute the old passwords
    //

    //
    // Figure out the size of the stored credentials
    //

    NewCredentialCount = 0;
    NewCredentialSize = 0;
    CredentialIndex = 0;

    if ((StoredCreds != NULL) &&
        (CredentialSize > sizeof(KERB_STORED_CREDENTIAL) &&
        (StoredCreds->Revision == KERB_PRIMARY_CRED_REVISION) &&
        (CredentialSize > (sizeof(KERB_STORED_CREDENTIAL)
                            - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA))
                            + (StoredCreds->OldCredentialCount + StoredCreds->CredentialCount) * sizeof(KERB_KEY_DATA)
                            ))))
    {
        UseStoredCreds = TRUE;
        Flags = StoredCreds->Flags;

        for (Index = 0; Index < StoredCreds->OldCredentialCount ; Index++ )
        {
            if (StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length +
                (ULONG_PTR) StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.value <=
                 CredentialSize )
            {
                NewCredentialCount++;
                NewCredentialSize += sizeof(KERB_KEY_DATA) +
                    StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length;
            }
            else
            {
                LPWSTR Buff = NULL;

                DebugLog((DEB_ERROR,"Corrupt credentials for user %wZ\n",
                    &UserAll->UserName ));

                DsysAssert(FALSE);

                Buff = KerbBuildNullTerminatedString(&UserAll->UserName);
                if (NULL == Buff)
                {
                   break;
                }

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_CORRUPT_CREDENTIALS,
                    0,                              // no raw data
                    NULL,                   // no raw data
                    1,                              // number of strings
                    Buff
                    );

                if (NULL != Buff)
                {
                   MIDL_user_free(Buff);
                }

                UseStoredCreds = FALSE;
                NewCredentialCount = 0;
                NewCredentialSize = 0;
                break;
            }
        }
    }

    //
    // If the password length is the size of the OWF password, use it as the
    // key. Otherwise hash it. This is for the case where not password is
    // set.
    //
    // The Password histroy is appended to a SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE structure.
    // After this structure, there is blocks of 16 bytes for each password.  The first password is
    // the current password.  The following blocks (if any) is the history of passwords.
    //
    // The index looks strange (PENCRYPTED_NT_OWF_PASSWORD) (PrivateData + 1) + 1
    //    the (PrivateData + 1) points to after the SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE header
    //    and the final + 1   skips over the current password in the password history

    if (UseBuiltins)
    {
        PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PrivateData;

        if (UserAll->PrivateData.Length >= sizeof(SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE))
        {
            PrivateData= (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE) UserAll->PrivateData.Buffer;
            if (PrivateData->DataType == SamPrivateDataPassword)
            {
                //
                // The old password is the 2nd entry
                //
                if (PrivateData->NtPasswordHistory.Length >= 2* sizeof(ENCRYPTED_NT_OWF_PASSWORD))
                {
                    //
                    // Decrypt the old password with the RID. The history starts
                    // at the first byte after the structure.
                    //

                    Status = RtlDecryptNtOwfPwdWithIndex(
                                (PENCRYPTED_NT_OWF_PASSWORD) (PrivateData + 1) + 1,
                                (PLONG)&UserAll->UserId,
                                &OldPasswordData
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        DebugLog((DEB_ERROR,"Failed to decrypt old password: 0x%x\n",Status));
                        KerbErr = KRB_ERR_GENERIC;
                        goto Cleanup;
                    }
                    OldNtPassword = &OldPasswordData ;

                    // Now check for the second previous password - this will be the third password in history
                    if (PrivateData->NtPasswordHistory.Length >= 3 * sizeof(ENCRYPTED_NT_OWF_PASSWORD))
                    {
                        //
                        // Decrypt the old password with the RID. The history starts
                        // at the first byte after the structure.
                        //

                        Status = RtlDecryptNtOwfPwdWithIndex(
                                    (PENCRYPTED_NT_OWF_PASSWORD) (PrivateData + 1) + 2,
                                    (PLONG)&UserAll->UserId,
                                    &OldPasswordDataSecond
                                    );
                        if (!NT_SUCCESS(Status))
                        {
                            DebugLog((DEB_ERROR,"Failed to decrypt second previous password: 0x%x\n",Status));
                            KerbErr = KRB_ERR_GENERIC;
                            goto Cleanup;
                        }
                        OldNtPasswordSecond = &OldPasswordDataSecond;
                    }
                }
            }
        }
        if (OldNtPassword != NULL)
        {
            //
            // Add an RC4_HMAC_NT key
            //

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

            if (OldNtPasswordSecond != NULL)
            {
                //
                // Add an RC4_HMAC_NT key for the second previous password
                //

                NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
                NewCredentialCount++;
            }


#ifndef DONT_SUPPORT_OLD_TYPES_KDC

            //
            // Add a key for RC4_HMAC_OLD & RC4_MD4
            //

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);

            NewCredentialCount++;
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);

            NewCredentialCount++;
#endif
        }
    }

    //
    // Add the space for the base structure
    //

    NewCredentialSize += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));

    //
    // Allocate space for the credentials and start filling them in
    //

    Keys = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(NewCredentialSize);
    if (Keys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        Keys,
        NewCredentialSize
        );

    Offset = sizeof(KERB_STORED_CREDENTIAL) -
             (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
             NewCredentialCount * sizeof(KERB_KEY_DATA);

    Base = (PUCHAR) Keys;

    Keys->CredentialCount = (USHORT) NewCredentialCount;
    Keys->OldCredentialCount = 0;
    Keys->Revision = KERB_PRIMARY_CRED_REVISION;
    Keys->Flags = Flags;

    //
    // Add the credentials built from the OWF passwords first. We don't
    // include a blank password or the null crypt system because they
    // were present in the normal password
    //

    if (UseBuiltins)
    {
        //
        // Create the key for RC4_HMAC_NT
        //

        if (OldNtPassword != NULL)
        {

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            RtlCopyMemory(
                Base+Offset,
                OldNtPassword,
                NT_OWF_PASSWORD_LENGTH
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex++].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_HMAC_NT
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            // We don't know any other way to get the old password length. If
            // it was present, it must be sizeof(NT_OWF_PASSWORD)

            Offset += sizeof(NT_OWF_PASSWORD);


            if (OldNtPasswordSecond != NULL)
            {

                //
                // Set an empty salt for this key for the second previous password
                //

                Keys->Credentials[CredentialIndex].Salt.Length = 0;
                Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
                Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

                RtlCopyMemory(
                    Base+Offset,
                    OldNtPasswordSecond,
                    NT_OWF_PASSWORD_LENGTH
                    );



                KerbErr = KerbCreateKeyFromBuffer(
                            &Keys->Credentials[CredentialIndex++].Key,
                            Base+Offset,
                            UserAll->NtPassword.Length,
                            KERB_ETYPE_RC4_HMAC_NT
                            );
                if (!KERB_SUCCESS(KerbErr))
                {
                    goto Cleanup;
                }

                // We don't know any other way to get the old password length. If
                // it was present, it must be sizeof(NT_OWF_PASSWORD)

                Offset += sizeof(NT_OWF_PASSWORD);
            }

#ifndef DONT_SUPPORT_OLD_TYPES_KDC
            //
            // Create the key for RC4_HMAC_OLD
            //

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            RtlCopyMemory(
                Base+Offset,
                OldNtPassword,
                NT_OWF_PASSWORD_LENGTH
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex++].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        (ULONG) KERB_ETYPE_RC4_HMAC_OLD
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            // We don't know any other way to get the old password length. If
            // it was present, it must be sizeof(NT_OWF_PASSWORD)

            Offset += sizeof(NT_OWF_PASSWORD);

            //
            // Create the key for RC4_HMAC_OLD
            //

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            RtlCopyMemory(
                Base+Offset,
                OldNtPassword,
                NT_OWF_PASSWORD_LENGTH
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex++].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        (ULONG) KERB_ETYPE_RC4_MD4
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            // We don't know any other way to get the old password length. If
            // it was present, it must be sizeof(NT_OWF_PASSWORD)

            Offset += sizeof(NT_OWF_PASSWORD);

#endif

        }
    }
    //
    // Now add the stored passwords
    //

    if (UseStoredCreds)
    {
        for (Index = 0; Index < StoredCreds->OldCredentialCount ; Index++ )
        {
            Keys->Credentials[CredentialIndex] = StoredCreds->Credentials[StoredCreds->CredentialCount + Index];
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base+Offset;
            RtlCopyMemory(
                Keys->Credentials[CredentialIndex].Key.keyvalue.value,
                StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.value + (ULONG_PTR) StoredCreds,
                StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length
                );
            Offset += StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length;

            //
            // Note - don't use salt here.
            //

            CredentialIndex++;
        }
    }

    DsysAssert(CredentialIndex == NewCredentialCount);
    DsysAssert(Offset == NewCredentialSize);
    *OldPasswords = Keys;
    Keys = NULL;

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (StoredCreds != NULL)
    {
        if (!UnMarshalledCreds)
        {
           LocalFree(StoredCreds);
        }
        else
        {
           MIDL_user_free(Cred64);
        }
    }

    if (Keys != NULL)
    {
        MIDL_user_free(Keys);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateCredentials
//
//  Synopsis:   Copies a set of credentials (passwords)
//
//  Effects:    allocates output with MIDL_user_allocate
//
//  Arguments:  NewCredentials - recevies new set of credentials
//              OldCredentials - contains credentials to copy
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcDuplicateCredentials(
    OUT PKERB_STORED_CREDENTIAL * NewCredentials,
    OUT PULONG ReturnCredentialSize,
    IN PKERB_STORED_CREDENTIAL OldCredentials,
    IN BOOLEAN MarshallKeys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_STORED_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;
    USHORT Index;
    PBYTE Where;
    LONG_PTR Offset;

    TRACE(KDC, KdcDuplicateCredentials, DEB_FUNCTION);

    //
    // If there were no credentials, so be it. We can live with that.
    //

    if (OldCredentials == NULL)
    {
        *NewCredentials = NULL;
        goto Cleanup;
    }

    //
    // Calculate the size of the new credentials by summing the size of
    // the base structure plus the keys
    //

    CredentialSize = sizeof(KERB_STORED_CREDENTIAL)
                        - ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)
                        + OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
                        + OldCredentials->DefaultSalt.Length;
    for ( Index = 0;
          Index < OldCredentials->CredentialCount + OldCredentials->OldCredentialCount  ;
          Index++ )
    {
        CredentialSize += OldCredentials->Credentials[Index].Key.keyvalue.length +
                          OldCredentials->Credentials[Index].Salt.Length;
    }

    //
    // Allocate the new credential and copy over the old credentials
    //


    Credential = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredentialSize);
    if (Credential == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Credential->Revision = OldCredentials->Revision;
    Credential->Flags = OldCredentials->Flags;
    Credential->CredentialCount = OldCredentials->CredentialCount;
    Credential->OldCredentialCount = OldCredentials->OldCredentialCount;

    //
    // Set the offset for data to be after the last array element
    //

    RtlCopyMemory(
        &Credential->Credentials[0],
        &OldCredentials->Credentials[0],
        OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
        );

    Where = (PBYTE) &Credential->Credentials[Credential->CredentialCount];

    if (MarshallKeys)
    {
        Offset = (LONG_PTR) Credential;
    }
    else
    {
        Offset = 0;
    }

    Credential->DefaultSalt = OldCredentials->DefaultSalt;
    if (Credential->DefaultSalt.Buffer != NULL)
    {
        Credential->DefaultSalt.Buffer = (LPWSTR) (Where - Offset);
        RtlCopyMemory(
            Where,
            OldCredentials->DefaultSalt.Buffer,
            Credential->DefaultSalt.Length
            );
        Where +=  Credential->DefaultSalt.Length;
    }

    for ( Index = 0;
          Index < OldCredentials->CredentialCount + OldCredentials->OldCredentialCount  ;
          Index++ )
    {
        Credential->Credentials[Index] = OldCredentials->Credentials[Index];
        Credential->Credentials[Index].Key.keyvalue.value = (Where - Offset);
        RtlCopyMemory(
            Where,
            OldCredentials->Credentials[Index].Key.keyvalue.value,
            OldCredentials->Credentials[Index].Key.keyvalue.length
            );
        Where += OldCredentials->Credentials[Index].Key.keyvalue.length;

        if (Credential->Credentials[Index].Salt.Buffer != NULL)
        {
            Credential->Credentials[Index].Salt.Buffer = (LPWSTR) (Where - Offset);

            RtlCopyMemory(
                Where,
                OldCredentials->Credentials[Index].Salt.Buffer,
                OldCredentials->Credentials[Index].Salt.Length
                );
            Where += OldCredentials->Credentials[Index].Salt.Length;
        }
    }
    DsysAssert(Where - (PUCHAR) Credential == (LONG) CredentialSize);

    *NewCredentials = Credential;
    Credential = NULL;
    *ReturnCredentialSize = CredentialSize;

Cleanup:
    if (Credential != NULL)
    {
        MIDL_user_free(Credential);
    }
    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KdcGetTicketInfo
//
//  Synopsis:   Gets the info needed to build a ticket for a principal
//              using name of the principal.
//
//
//  Effects:
//
//  Arguments:  Name --  (in)  Normalized of principal
//              LookupFlags - Flags for SamIGetUserLogonInformation
//              PrincipalName - (in) non-normalized principal name
//              Realm - (in) client realm, to be used when mapping principals
//                      from another domain onto accounts in this one.
//              TicketInfo --  (out) Ticket info.
//              pExtendedError -- (out) Extended error
//              UserHandle - receives handle to the user
//              WhichFields - optionally specifies additional fields to fetch for RetUserInfo
//              ExtendedFields - optionally specifies extended fields to fetch for RetUserInfo
//              RetUserInfo - Optionally receives the user all info structure
//              GroupMembership - Optionally receives the user's group membership
//
//  Returns:    KerbErr
//
//  Algorithm:
//
//  History:    10-Nov-93   WadeR          Created
//              22-Mar-95   SuChang        Modified to use RIDs
//
//
//----------------------------------------------------------------------------

KERBERR
KdcGetTicketInfo(
    IN PUNICODE_STRING GenericUserName,
    IN ULONG LookupFlags,
    IN BOOLEAN bRestrictUserAccounts,
    IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * RetUserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    KERBERR KerbErr = KDC_ERR_NONE;
    SID_AND_ATTRIBUTES_LIST LocalMembership;
    SAMPR_HANDLE LocalUserHandle = NULL;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    PUSER_ALL_INFORMATION UserAll;
    GUID testGuid = {0};
    UNICODE_STRING TUserName = {0};
    PUNICODE_STRING UserName = NULL;
    UNICODE_STRING AlternateName = {0};
    UNICODE_STRING TempString = {0};
    BOOL IsValidGuid = FALSE;

    TRACE(KDC, GetTicketInfo, DEB_FUNCTION);

    D_DebugLog((DEB_T_PAPI, "KdcGetTicketInfo [entering] bRestrictUserAccounts %s, WhichFields %#x, ExtendedFields %#x, GenericUserName %wZ, LookupFlags %#x, PrincipalName ",
                bRestrictUserAccounts ? "true" : "false", WhichFields, ExtendedFields, GenericUserName, LookupFlags));
    D_KerbPrintKdcName((DEB_T_PAPI, PrincipalName));

    //
    // Add the fields we are going to require locally to the WhichFields parameter
    //

    WhichFields |=
        USER_ALL_KDC_GET_USER_KEYS |
        USER_ALL_PASSWORDMUSTCHANGE |
        USER_ALL_USERACCOUNTCONTROL |
        USER_ALL_USERID |
        USER_ALL_USERNAME;

    ExtendedFields |=
        USER_EXTENDED_FIELD_KVNO |                 // passwd version raid #306501
        USER_EXTENDED_FIELD_LOCKOUT_THRESHOLD;     // for individual account lockout rather than domain wide

    TUserName = *GenericUserName;
    UserName = &TUserName;

    RtlZeroMemory(TicketInfo, sizeof(KDC_TICKET_INFO));
    RtlZeroMemory(&LocalMembership, sizeof(SID_AND_ATTRIBUTES_LIST));

    if (ARGUMENT_PRESENT( RetUserInfo ))
    {
        *RetUserInfo = NULL;
    }

    if (!ARGUMENT_PRESENT(GroupMembership))
    {
        LookupFlags |= SAM_NO_MEMBERSHIPS;
    }

    //
    // If this is the krbtgt account, use the cached version
    //

    if (!ARGUMENT_PRESENT(UserHandle) &&
        !ARGUMENT_PRESENT(RetUserInfo) &&
        !ARGUMENT_PRESENT(GroupMembership) &&
        (KdcState == Running) &&
        RtlEqualUnicodeString(
            SecData.KdcServiceName(),
            UserName,
            TRUE        // case insensitive
            ))
    {
        //
        // Duplicate the cached copy of the KRBTGT information
        //

        D_DebugLog((DEB_T_TICKETS, "KdcGetTicketInfo using cached ticket info for krbtgt account\n"));

        KerbErr = SecData.GetKrbtgtTicketInfo(
                        TicketInfo
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // If we cracked this name at a dc, and it's the same domain, we will
    // not be able to generate a referral ticket. So, we need to be able
    // to open the sam locally. Further more, crack name and sam lookups
    // are much faster with guids (even though we have to do the string
    // to guid operation.
    //

    if (LookupFlags & SAM_OPEN_BY_GUID)
    {
        if (IsValidGuid = IsStringGuid(UserName->Buffer, &testGuid))
        {
            UserName->Buffer = (LPWSTR)&testGuid;
        }
    }

    //
    // The caller may provide an empty user name so as to force the lookup
    // using the AltSecId. This is used when mapping names from an MIT realm
    //

    if (UserName->Length > 0)
    {
        //
        // Open the user account
        //

        #if DBG

        if (IsValidGuid)
        {
            D_KerbPrintGuid(DEB_TRACE, "KdcGetTicketInfo account is Guid ", &testGuid);
        }

        #endif

        Status = SamIGetUserLogonInformation2(
                    GlobalAccountDomainHandle,
                    LookupFlags,
                    UserName,
                    WhichFields,
                    ExtendedFields,
                    &UserInfo,
                    &LocalMembership,
                    &LocalUserHandle
                    );

        //
        // WASBUG: For now, if we couldn't find the account try again
        // with a '$' at the end (if there wasn't one already)
        //

        if (((Status == STATUS_NOT_FOUND) ||
            (Status == STATUS_NO_SUCH_USER)) &&
            (!IsValidGuid) &&
            ((LookupFlags & ~SAM_NO_MEMBERSHIPS) == 0) &&
            (UserName->Length >= sizeof(WCHAR)) &&
            (UserName->Buffer[UserName->Length/sizeof(WCHAR)-1] != L'$'))
        {
            Status = KerbDuplicateString(
                        &TempString,
                        UserName
                        );
            if (!NT_SUCCESS(Status))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
            DsysAssert(TempString.MaximumLength >= TempString.Length + sizeof(WCHAR));
            TempString.Buffer[TempString.Length/sizeof(WCHAR)] = L'$';
            TempString.Length += sizeof(WCHAR);

            D_DebugLog((DEB_TRACE, "Account not found ,trying machine account %wZ\n",
                &TempString ));

            Status = SamIGetUserLogonInformation2(
                        GlobalAccountDomainHandle,
                        LookupFlags,
                        &TempString,
                        WhichFields,
                        ExtendedFields,
                        &UserInfo,
                        &LocalMembership,
                        &LocalUserHandle
                        );
        }
    }

    //
    // If we still can't find the account, try the altsecid using
    // the supplied principal name.
    //

    if (((Status == STATUS_NOT_FOUND) || (Status == STATUS_NO_SUCH_USER)) &&
        ARGUMENT_PRESENT(PrincipalName) )
    {
        KerbErr = KerbBuildAltSecId(
                    &AlternateName,
                    PrincipalName,
                    Realm,
                    NULL                // no unicode realm name
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_TRACE,"User account not found, trying alternate id: %wZ\n",&AlternateName ));
            LookupFlags |= SAM_OPEN_BY_ALTERNATE_ID,

            Status = SamIGetUserLogonInformation2(
                        GlobalAccountDomainHandle,
                        LookupFlags,
                        &AlternateName,
                        WhichFields,
                        ExtendedFields,
                        &UserInfo,
                        &LocalMembership,
                        &LocalUserHandle
                        );
        }
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_T_TICKETS,"Could not open User %wZ: 0x%x\n",
            UserName,
            Status
            ));

        if ((Status == STATUS_NO_SUCH_USER) || (Status == STATUS_NOT_FOUND) ||
            (Status == STATUS_OBJECT_NAME_NOT_FOUND))
        {
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        }
        else if (Status == STATUS_NO_LOGON_SERVERS)
        {
            //If there's no GC, this sam call returns STATUS_NO_LOGON_SERVERS
            //and we should return this to the client. see bug 226073
            FILL_EXT_ERROR(pExtendedError, Status,FILENO, __LINE__);
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        }
        else if (Status != STATUS_INVALID_SERVER_STATE)
        {
            WCHAR LookupType[10];
            WCHAR * LookupTypeStr;
            WCHAR AccountName[MAX_PATH+1];
            PUNICODE_STRING LookupName = NULL;


            if (AlternateName.Buffer != NULL)
            {
                LookupName = &AlternateName;
            }
            else if (TempString.Buffer != NULL)
            {
                LookupName = &TempString;
            }
            else
            {
                LookupName = UserName;
            }
            if (LookupName->Length < MAX_PATH * sizeof(WCHAR))
            {
                RtlCopyMemory(
                    AccountName,
                    LookupName->Buffer,
                    LookupName->Length
                    );
                AccountName[LookupName->Length/sizeof(WCHAR)] = L'\0';
            }
            else
            {
                RtlCopyMemory(
                    AccountName,
                    LookupName->Buffer,
                    MAX_PATH * sizeof(WCHAR)
                    );
                AccountName[MAX_PATH] = L'\0';
            }

            //
            // Log name collisions separately to provide
            // more information
            //

            if (Status == STATUS_OBJECT_NAME_COLLISION)
            {
                DS_NAME_FORMAT NameFormat = DS_UNKNOWN_NAME;
                if ((LookupFlags & SAM_OPEN_BY_UPN) != 0)
                {
                    NameFormat = DS_USER_PRINCIPAL_NAME;
                }
                else if ((LookupFlags & SAM_OPEN_BY_SPN) != 0)
                {
                    NameFormat = DS_SERVICE_PRINCIPAL_NAME;
                }

                //
                // Potentially deadly error, pass back to caller.
                //
                FILL_EXT_ERROR_EX(pExtendedError, Status,FILENO, __LINE__);

                if (( NameFormat < sizeof( KdcGlobalNameTypes ) / sizeof( KdcGlobalNameTypes[0] )) &&
                    ( KdcGlobalNameTypes[NameFormat] != NULL ))
                {
                    LookupTypeStr = KdcGlobalNameTypes[NameFormat];
                }
                else
                {
                    swprintf(LookupType,L"%d",(ULONG) NameFormat);
                    LookupTypeStr = LookupType;
                }

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_NAME_NOT_UNIQUE,
                    0,
                    NULL,
                    2,
                    AccountName,
                    LookupTypeStr
                    );

                KerbErr = KDC_ERR_PRINCIPAL_NOT_UNIQUE;
            }
            else
            {
                swprintf(LookupType,L"0x%x",LookupFlags);

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_SAM_CALL_FAILED,
                    sizeof(NTSTATUS),
                    &Status,
                    2,
                    AccountName,
                    LookupType
                    );

                KerbErr = KRB_ERR_GENERIC;
            }
        }
        else
        {
           // Potentially deadly error, pass back to caller.
           FILL_EXT_ERROR_EX(pExtendedError, Status,FILENO, __LINE__);
           KerbErr = KRB_ERR_GENERIC;
        }
        goto Cleanup;
    }

    D_DebugLog((DEB_T_TICKETS, "KdcGetTicketInfo getting user keys\n"));

    //
    // if an account does not have at one SPNs registered, it is an user
    // account and enforce user2user
    //

    if (bRestrictUserAccounts && ((UserInfo->I1.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) == 0))
    {
        if ((ExtendedFields & USER_EXTENDED_FIELD_SPN) == 0)
        {
            DebugLog((DEB_ERROR, "KdcGetTicketInfo can't restrict user accounts if USER_EXTENDED_FIELD_SPN is not requested\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        if ((UserInfo->RegisteredSPNs == NULL) || (UserInfo->RegisteredSPNs->NumSPNs == 0))
        {
            DebugLog((DEB_ERROR, "KdcVerifyKdcRequest must use user2user UserAccountControl %#x, GenericUserName %wZ, PrincipalName: ",
                      UserInfo->I1.UserAccountControl, GenericUserName));
            KerbPrintKdcName(DEB_ERROR, PrincipalName);
            KerbErr = KDC_ERR_MUST_USE_USER2USER;
            goto Cleanup;
        }
    }

    UserAll = &UserInfo->I1;

    KerbErr = KdcGetUserKeys(
                LocalUserHandle,
                UserInfo,
                &TicketInfo->Passwords,
                &TicketInfo->OldPasswords,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to get user keys: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    if (!NT_SUCCESS(KerbDuplicateString(
                        &TicketInfo->AccountName,
                        &UserAll->UserName )))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if ((UserAll->UserAccountControl & USER_TRUSTED_FOR_DELEGATION) != 0)
    {
        TicketInfo->fTicketOpts |= AUTH_REQ_OK_AS_DELEGATE;
    }

    if ((UserAll->UserAccountControl & USER_NOT_DELEGATED) == 0)
    {
        TicketInfo->fTicketOpts |= AUTH_REQ_ALLOW_FORWARDABLE | AUTH_REQ_ALLOW_PROXIABLE;
    }

    if ((UserAll->UserAccountControl & USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) != 0)
    {
        TicketInfo->fTicketOpts |= AUTH_REQ_ALLOW_S4U_DELEGATE;
    }

    TicketInfo->fTicketOpts |=  AUTH_REQ_ALLOW_RENEWABLE |
                                AUTH_REQ_ALLOW_NOADDRESS |
                                AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY |
                                AUTH_REQ_ALLOW_VALIDATE;
    //
    // These flags aren't turned on by default:
    //      AUTH_REQ_VALIDATE_CLIENT
    //

    //
    // Mask with the domain policy flags
    //

    TicketInfo->fTicketOpts &= SecData.KdcFlags();

    TicketInfo->PasswordExpires = UserAll->PasswordMustChange;
    TicketInfo->PasswordVersion = UserInfo->KeyVersionNumber;    // Raid #306501
    TicketInfo->LockoutThreshold = UserInfo->LockoutThreshold;    // account lockout

    TicketInfo->UserAccountControl = UserAll->UserAccountControl;
    TicketInfo->UserId = UserAll->UserId;

    if (ARGUMENT_PRESENT(RetUserInfo))
    {
        *RetUserInfo = UserInfo;
        UserInfo = NULL;
    }
    if (ARGUMENT_PRESENT(GroupMembership))
    {
        *GroupMembership = LocalMembership;
        RtlZeroMemory(
            &LocalMembership,
            sizeof(SID_AND_ATTRIBUTES_LIST)
            );
    }

    if (ARGUMENT_PRESENT(UserHandle))
    {
        *UserHandle = LocalUserHandle;
        LocalUserHandle = NULL;
    }

Cleanup:

    KerbFreeString( &TempString );
    KerbFreeString( &AlternateName );

    SamIFree_UserInternal6Information( UserInfo );

    if (LocalUserHandle != NULL)
    {
        SamrCloseHandle(&LocalUserHandle);
    }

    SamIFreeSidAndAttributesList( &LocalMembership );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        FreeTicketInfo( TicketInfo );
        RtlZeroMemory(TicketInfo, sizeof(KDC_TICKET_INFO));
    }

    D_DebugLog((DEB_T_PAPI, "KdcGetTicketInfo returning %#x\n", KerbErr));

    return KerbErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeTicketInfo
//
//  Synopsis:   Frees a KDC_TICKET_INFO structure
//
//  Effects:
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:
//
//  History:    22-Mar-95       SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
FreeTicketInfo(
    IN  PKDC_TICKET_INFO TicketInfo
    )
{
    TRACE(KDC, FreeTicketInfo, DEB_FUNCTION);

    if (ARGUMENT_PRESENT(TicketInfo))
    {
        KerbFreeString(
            &TicketInfo->AccountName
            );

        KerbFreeString(
            &TicketInfo->TrustedForest
            );

        if (TicketInfo->Passwords != NULL)
        {
            MIDL_user_free(TicketInfo->Passwords);
            TicketInfo->Passwords = NULL;
        }
        if (TicketInfo->OldPasswords != NULL)
        {
            MIDL_user_free(TicketInfo->OldPasswords);
            TicketInfo->OldPasswords = NULL;
        }
        if (TicketInfo->TrustSid != NULL)
        {
            MIDL_user_free(TicketInfo->TrustSid);
            TicketInfo->TrustSid = NULL;
        }
    }
}




//--------------------------------------------------------------------
//
//  Name:       BuildReply
//
//  Synopsis:   Extracts reply information from an internal ticket
//
//  Arguments:  pkitTicket  - (in) ticket data comes from
//              dwNonce     - (in) goes into the reply
//              pkrReply    - (out) reply that is built
//
//  Notes:      BUG 456265: Need to set tsKeyExpiry properly.
//              See 3.1.3, 3.3.3 of the Kerberos V5 R5.2 spec
//              tsKeyExpiry is zero for GetTGSTicket, and the
//              expiry time of the client's key for GetASTicket.
//
//--------------------------------------------------------------------

KERBERR
BuildReply(
    IN OPTIONAL PKDC_TICKET_INFO ClientInfo,
    IN ULONG Nonce,
    IN PKERB_PRINCIPAL_NAME ServerName,
    IN KERB_REALM ServerRealm,
    IN OPTIONAL PKERB_HOST_ADDRESSES HostAddresses,
    IN PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY ReplyMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;
    KERB_ENCRYPTED_KDC_REPLY ReplyBody;
    LARGE_INTEGER CurrentTime;

    TRACE(KDC, BuildReply, DEB_FUNCTION);

    RtlZeroMemory(
        &ReplyBody,
        sizeof(KERB_ENCRYPTED_KDC_REPLY)
        );

    //
    // Use the same flags field
    //

    ReplyBody.flags = ReplyMessage->flags;



    ReplyBody.session_key = EncryptedTicket->key;


    ReplyBody.last_request = (PKERB_LAST_REQUEST) MIDL_user_allocate(sizeof(KERB_LAST_REQUEST));
    if (ReplyBody.last_request == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        ReplyBody.last_request,
        sizeof(KERB_LAST_REQUEST)
        );

    ReplyBody.last_request->next = NULL;
    ReplyBody.last_request->value.last_request_type = 0;
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    KerbConvertLargeIntToGeneralizedTime(
        &ReplyBody.last_request->value.last_request_value,
        NULL,           // no usec
        &CurrentTime
        );

    ReplyBody.nonce = Nonce;

    DsysAssert((ReplyBody.flags.length == EncryptedTicket->flags.length) &&
               (ReplyBody.flags.length== 8 * sizeof(ULONG)));

    //
    // Assign the flags over
    //

    *((PULONG)ReplyBody.flags.value) = *((PULONG)EncryptedTicket->flags.value);

    if (ARGUMENT_PRESENT(ClientInfo))
    {

        KerbConvertLargeIntToGeneralizedTime(
            &ReplyBody.key_expiration,
            NULL,
            &ClientInfo->PasswordExpires
            );
        ReplyBody.bit_mask |= key_expiration_present;
    }

    //
    // Fill in the times
    //

    ReplyBody.authtime = EncryptedTicket->authtime;
    ReplyBody.endtime = EncryptedTicket->endtime;

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_starttime =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_starttime;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_starttime_present;

    }

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_renew_until =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_renew_until;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_renew_until_present;
    }

    ReplyBody.server_realm = ServerRealm;

    ReplyBody.server_name = *ServerName;

    //
    // Fill in the host addresses
    //


    if (HostAddresses != NULL)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_client_addresses = HostAddresses;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_client_addresses_present;
    }

    *ReplyMessage = ReplyBody;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (ReplyBody.last_request != NULL)
        {
            MIDL_user_free(ReplyBody.last_request);
            ReplyBody.last_request = NULL;
        }

    }

    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildSupplementalCredentials
//
//  Synopsis:   Builds a list of the supplemental credentials and then
//              encrypts it with the supplied key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcBuildSupplementalCredentials(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER * EncryptedCreds
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PBYTE Credentials = NULL;
    ULONG CredentialSize = 0;
    KERB_ENCRYPTED_DATA EncryptedData = {0};
    PPAC_CREDENTIAL_INFO CredInfo = NULL;
    PPAC_INFO_BUFFER ReturnCreds = NULL;
    ULONG ReturnCredSize;

    Status = PAC_BuildCredentials(
                (PSAMPR_USER_ALL_INFORMATION)&UserInfo->I1,
                &Credentials,
                &CredentialSize
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                CredentialKey->keytype,
                CredentialSize,
                &EncryptedData.cipher_text.length,
                &EncryptedData.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                &EncryptedData,
                CredentialSize,
                Credentials,
                KERB_NO_KEY_VERSION,
                KERB_NON_KERB_SALT,
                CredentialKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Compute the size of the blob returned
    //

    ReturnCredSize = sizeof(PAC_INFO_BUFFER) +
                        FIELD_OFFSET(PAC_CREDENTIAL_INFO, Data) +
                        EncryptedData.cipher_text.length ;

    ReturnCreds = (PPAC_INFO_BUFFER) MIDL_user_allocate(ReturnCredSize);
    if (ReturnCreds == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    //
    // Fill in the outer structure
    //

    ReturnCreds->ulType = PAC_CREDENTIAL_TYPE;
    ReturnCreds->cbBufferSize = ReturnCredSize - sizeof(PAC_INFO_BUFFER);
    ReturnCreds->Data = (PBYTE) (ReturnCreds + 1);
    CredInfo = (PPAC_CREDENTIAL_INFO) ReturnCreds->Data;

    //
    // Fill in the inner structure
    //

    CredInfo->EncryptionType = EncryptedData.encryption_type;
    if (EncryptedData.bit_mask & version_present)
    {
        CredInfo->Version = EncryptedData.version;
    }
    else
    {
        CredInfo->Version = 0;
    }

    RtlCopyMemory(
        CredInfo->Data,
        EncryptedData.cipher_text.value,
        EncryptedData.cipher_text.length
        );

    *EncryptedCreds = ReturnCreds;
    ReturnCreds = NULL;

Cleanup:
    if (Credentials != NULL)
    {
        MIDL_user_free(Credentials);
    }
    if (ReturnCreds != NULL)
    {
        MIDL_user_free(ReturnCreds);
    }
    if (EncryptedData.cipher_text.value != NULL)
    {
        MIDL_user_free(EncryptedData.cipher_text.value);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPacVerifier
//
//  Synopsis:   Builds a verifier for the PAC. This structure ties the
//              PAC to the ticket by including the client name and
//              ticket authime in the PAC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcBuildPacVerifier(
    IN PTimeStamp ClientId,
    IN PUNICODE_STRING ClientName,
    OUT PPAC_INFO_BUFFER * Verifier
    )
{
    ULONG ReturnVerifierSize = 0;
    PPAC_CLIENT_INFO ClientInfo = NULL;
    PPAC_INFO_BUFFER ReturnVerifier = NULL;

    //
    // Compute the size of the blob returned
    //
    ReturnVerifierSize = sizeof(PAC_INFO_BUFFER) + sizeof(PAC_CLIENT_INFO) +
                        ClientName->Length - sizeof(WCHAR) * ANYSIZE_ARRAY;

    ReturnVerifier = (PPAC_INFO_BUFFER) MIDL_user_allocate(ReturnVerifierSize);
    if (ReturnVerifier == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    //
    // Fill in the outer structure
    //

    ReturnVerifier->ulType = PAC_CLIENT_INFO_TYPE;
    ReturnVerifier->cbBufferSize = ReturnVerifierSize - sizeof(PAC_INFO_BUFFER);
    ReturnVerifier->Data = (PBYTE) (ReturnVerifier + 1);
    ClientInfo = (PPAC_CLIENT_INFO) ReturnVerifier->Data;
    ClientInfo->ClientId = *ClientId;
    ClientInfo->NameLength = ClientName->Length;
    RtlCopyMemory(
        ClientInfo->Name,
        ClientName->Buffer,
        ClientName->Length
        );
    *Verifier = ReturnVerifier;

    return(KDC_ERR_NONE);
}


//+---------------------------------------------------------------------------
//
//  Name:       KdcIsOurDomain
//
//  Synopsis:   Tells us if this sid is from our domain.
//
//  Arguments:
//
//
//+---------------------------------------------------------------------------


BOOLEAN
KdcIsOurDomain( 
    IN PSID InputSid,
    OUT PULONG Rid
    )
{
    BOOLEAN fRet = FALSE; 
    SID *Sid = (SID*) InputSid;  
    
    Sid->SubAuthorityCount--;
    
    if (RtlEqualSid( Sid, GlobalDomainSid ))
    {   
        D_DebugLog((DEB_T_PAC, "%p\n", Sid));
        D_DebugLog((DEB_T_PAC, "%p add subauthority %i\n", &Sid->SubAuthority[Sid->SubAuthorityCount], Sid->SubAuthorityCount));
        *Rid = Sid->SubAuthority[Sid->SubAuthorityCount];

        D_DebugLog((DEB_T_PAC, "Rid %x\n", (*Rid)));
        fRet = TRUE;
    }
    
    Sid->SubAuthorityCount++;                  
                   
    
    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Name:       GetPacAndSuppCred
//
//  Synopsis:
//
//  Arguments:
//
//  Notes:      ppPac is allocated using CoTaskMemAlloc and
//              ppadlSuppCreds is allocated using operator 'new'.
//
//+---------------------------------------------------------------------------

KERBERR
GetPacAndSuppCred(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PSID_AND_ATTRIBUTES_LIST GroupMembership,
    IN ULONG SignatureSize,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    IN OPTIONAL PTimeStamp ClientId,
    IN OPTIONAL PUNICODE_STRING ClientName,
    OUT PPACTYPE * Pac,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    PPACTYPE NewPac = NULL;
    PPAC_INFO_BUFFER Credentials[2];
    ULONG AdditionalDataCount = 0;
    
    
    ULONG ExtraSidCount = 0, GroupCount = 0, Rid;
    
    SID_AND_ATTRIBUTES_LIST ExtraSidList = {0};
    PSID_AND_ATTRIBUTES ExtraSids = NULL;
    SAMPR_GET_GROUPS_BUFFER GroupsBuffer = {0};
    PGROUP_MEMBERSHIP Groups = NULL;


    TRACE(KDC, GetPACandSuppCred, DEB_FUNCTION);

    RtlZeroMemory(
        Credentials,
        sizeof(Credentials)
        );

    *Pac = NULL;

    D_DebugLog((DEB_T_PAC,
        "GetPacAndSuppCred User %wZ, FullName %wZ, Upn %wZ, UserId %#x, UserAccountControl %#x, ExtendedFields %#x, WhichFields %#x\n",
        &UserInfo->I1.UserName,
        &UserInfo->I1.FullName,
        &UserInfo->UPN,
        &UserInfo->I1.UserId,
        UserInfo->I1.UserAccountControl,
        UserInfo->ExtendedFields,
        UserInfo->I1.WhichFields));

    if (ARGUMENT_PRESENT(CredentialKey) &&
        (CredentialKey->keyvalue.value != NULL) )
    {
        KerbErr = KdcBuildSupplementalCredentials(
                    UserInfo,
                    CredentialKey,
                    &Credentials[AdditionalDataCount]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        AdditionalDataCount++;
    }

    if (ARGUMENT_PRESENT(ClientId))
    {
        KerbErr = KdcBuildPacVerifier(
                    ClientId,
                    ClientName,
                    &Credentials[AdditionalDataCount]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }  

        AdditionalDataCount++;
    }

    //
    // Now we have to build up our PSAMPR_GET_GROUPS buffer.  This is 
    // meant to reduce the overall PAC size.   Be pessimistic about the buffer size 
    // we'll need.
    //
    SafeAllocaAllocate( Groups, ( GroupMembership->Count * sizeof(GROUP_MEMBERSHIP) ));     
    if ( Groups == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    SafeAllocaAllocate( ExtraSids, ( GroupMembership->Count * sizeof(SID_AND_ATTRIBUTES) ));
    if ( ExtraSids == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }     


    for ( ULONG i = 0 ; i < GroupMembership->Count ; i++ )
    {  
        //
        // If this is in our domain, add it to the Groups.
        //
        if ( KdcIsOurDomain( GroupMembership->SidAndAttributes[i].Sid, &Rid ))
        {                                                                     
            D_DebugLog((DEB_T_PAC, "Adding %i from %p\n", Rid, GroupMembership->SidAndAttributes[i].Sid ));
            Groups[GroupCount].RelativeId = Rid;
            Groups[GroupCount].Attributes = GroupMembership->SidAndAttributes[i].Attributes;
            GroupCount++;
        }
        else
        {   
            D_DebugLog(( DEB_T_PAC, "Adding %p to extrasids\n", GroupMembership->SidAndAttributes[i].Sid )); 
            ExtraSids[ExtraSidCount] = GroupMembership->SidAndAttributes[i];
            ExtraSidCount++;
        }

    }
    
    GroupsBuffer.Groups = Groups;
    GroupsBuffer.MembershipCount = GroupCount;
    
    ExtraSidList.SidAndAttributes = ExtraSids;
    ExtraSidList.Count = ExtraSidCount;
    
    //
    // NOTE: this is o.k. because we don't lock the secdata while acecssing
    // the machine name
    //
    Status = PAC_Init(
                (PSAMPR_USER_ALL_INFORMATION)&UserInfo->I1,
                &GroupsBuffer,
                &ExtraSidList,
                GlobalDomainSid,
                &GlobalDomainName,
                SecData.MachineName(),
                SignatureSize,
                AdditionalDataCount,
                Credentials,
                &NewPac
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to init pac: 0x%x\n",Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    *Pac = NewPac;
    NewPac = NULL;


Cleanup:


    while (AdditionalDataCount > 0)
    {
        if (Credentials[--AdditionalDataCount] != NULL)
        {
            MIDL_user_free(Credentials[AdditionalDataCount]);
        }
    }

    SafeAllocaFree( Groups );
    SafeAllocaFree( ExtraSids );

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }


    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeInternalTicket
//
//  Synopsis:   frees a constructed ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeInternalTicket(
    IN PKERB_TICKET Ticket
    )
{
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    TRACE(KDC, KdcFreeInternalTicket, DEB_FUNCTION);

    if (EncryptedTicket != NULL)
    {
        KerbFreeKey(
            &EncryptedTicket->key
            );
        KerbFreePrincipalName(&EncryptedTicket->client_name);
        KerbFreeRealm(&EncryptedTicket->client_realm);
        if (EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL)
        {
            KerbFreeAuthData(EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data);
        }
        if (EncryptedTicket->transited.contents.value != NULL)
        {
            MIDL_user_free(EncryptedTicket->transited.contents.value);
            EncryptedTicket->transited.contents.value = 0;
            EncryptedTicket->transited.contents.length = 0;
        }
        Ticket->encrypted_part.cipher_text.value = NULL;
        Ticket->encrypted_part.cipher_text.length = 0;
    }

    KerbFreePrincipalName(
        &Ticket->server_name
        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReply
//
//  Synopsis:   frees a kdc reply
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeKdcReply(
    IN PKERB_KDC_REPLY Reply
    )
{
    TRACE(KDC, KdcFreeKdcReply, DEB_FUNCTION);

    KerbFreePrincipalName(&Reply->ticket.server_name);

    if (Reply->ticket.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->ticket.encrypted_part.cipher_text.value);
    }

    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
    }
    if (Reply->KERB_KDC_REPLY_preauth_data != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST) Reply->KERB_KDC_REPLY_preauth_data);
    }


}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReplyBody
//
//  Synopsis:   frees a constructed KDC reply body
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcFreeKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody
    )
{

    TRACE(KDC, KdcFreeKdcReplyBody, DEB_FUNCTION);

    //
    // The names & the session key are just pointers into the ticket,
    // so they don't need to be freed.
    //

    if (ReplyBody->last_request != NULL)
    {
        MIDL_user_free(ReplyBody->last_request);
        ReplyBody->last_request = NULL;
    }
    ReplyBody->KERB_ENCRYPTED_KDC_REPLY_client_addresses = NULL;

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyTgsChecksum
//
//  Synopsis:   Verify the checksum on a TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyTgsChecksum(
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_CHECKSUM OldChecksum
    )
{
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_CHECKSUM Checksum = {0};


    Status = CDLocateCheckSum(
                OldChecksum->checksum_type,
                &ChecksumFunction
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Allocate enough space for the checksum
    //

    Checksum.checksum.value = (PUCHAR) MIDL_user_allocate(ChecksumFunction->CheckSumSize);
    if (Checksum.checksum.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Checksum.checksum.length = ChecksumFunction->CheckSumSize;

    //
    // Initialize the checksum
    //

    if ((OldChecksum->checksum_type == KERB_CHECKSUM_REAL_CRC32) ||
        (OldChecksum->checksum_type == KERB_CHECKSUM_CRC32))
    {
        if (ChecksumFunction->Initialize)
        {
            Status = ChecksumFunction->Initialize(
                        0,
                        &CheckBuffer
                        );


        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
    }
    else
    {
        if (NULL != ChecksumFunction->InitializeEx2)
        {
            Status = ChecksumFunction->InitializeEx2(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        OldChecksum->checksum.value,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else if (ChecksumFunction->InitializeEx)
        {
            Status = ChecksumFunction->InitializeEx(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbPackData(
                        RequestBody,
                        KERB_MARSHALLED_REQUEST_BODY_PDU,
                        &MarshalledRequestBody.BufferSize,
                        &MarshalledRequestBody.Buffer
                        );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now checksum the buffer
    //

    ChecksumFunction->Sum(
        CheckBuffer,
        MarshalledRequestBody.BufferSize,
        MarshalledRequestBody.Buffer
        );

    ChecksumFunction->Finalize(
        CheckBuffer,
        Checksum.checksum.value
        );

    //
    // Now compare
    //

    if ((OldChecksum->checksum.length != Checksum.checksum.length) ||
        !RtlEqualMemory(
            OldChecksum->checksum.value,
            Checksum.checksum.value,
            Checksum.checksum.length
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on TGS request body did not match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:
    if (CheckBuffer != NULL)
    {
        ChecksumFunction->Finish(&CheckBuffer);
    }
    if (MarshalledRequestBody.Buffer != NULL)
    {
        MIDL_user_free(MarshalledRequestBody.Buffer);
    }
    if (Checksum.checksum.value != NULL)
    {
        MIDL_user_free(Checksum.checksum.value);
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyKdcRequest
//
//  Synopsis:   Verifies that the AP request accompanying a TGS or PAC request
//              is valid.
//
//  Effects:
//
//  Arguments:  ApRequest - The AP request to verify
//              UnmarshalledRequest - The unmarshalled request,
//                      returned to avoid needing to
//              EncryptedTicket - Receives the ticket granting  ticket
//              SessionKey - receives the key to use in the reply
//
//  Requires:
//
//  Returns:    kerberos errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyKdcRequest(
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN BOOLEAN IsKdcRequest,
    OUT OPTIONAL PKERB_AP_REQUEST * UnmarshalledRequest,
    OUT OPTIONAL PKERB_AUTHENTICATOR * UnmarshalledAuthenticator,
    OUT PKERB_ENCRYPTED_TICKET *EncryptedTicket,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY ServerKey,
    OUT PKDC_TICKET_INFO ServerTicketInfo,
    OUT PBOOLEAN UseSubKey,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AP_REQUEST Request = NULL;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;
    UNICODE_STRING LocalServerRealm = {0};
    UNICODE_STRING ServerRealm;
    PKERB_ENCRYPTION_KEY KeyToUse;
    BOOLEAN Referral = FALSE;

    TRACE(KDC, KdcVerifyKdcRequest, DEB_FUNCTION);

    ServerRealm.Buffer = NULL;

    //
    // First unpack the KDC request.
    //

    KerbErr = KerbUnpackApRequest(
                RequestMessage,
                RequestSize,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to unpack KDC request: 0x%x\n", KerbErr));
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &Request->ticket.server_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                &ServerRealm,
                &Request->ticket.realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    //
    // Get ticket info for the server
    //

    KerbErr = KdcNormalize(
                ServerName,
                &ServerRealm,
                &ServerRealm,
                NULL,
                KDC_NAME_SERVER | KDC_NAME_INBOUND,
                FALSE,                   // do not restrict user accounts (user2user)
                &Referral,
                &LocalServerRealm,
                ServerTicketInfo,
                pExtendedError,
                NULL,                    // no user handle
                0L,                      // no fields to fetch
                0L,                      // no extended fileds to fetch
                NULL,                    // no user all
                NULL                     // no group membership
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "KdcVerifyKdcRequest failed to get TGS ticket to service in another realm %#x: ", KerbErr));
        KerbPrintKdcName(DEB_WARN, ServerName);
        goto Cleanup;
    }

    //
    // Now Check the ticket
    //

Retry:

    KeyToUse = KerbGetKeyFromList(
                    ServerTicketInfo->Passwords,
                    Request->ticket.encrypted_part.encryption_type
                    );

    if (KeyToUse == NULL)
    {
        DebugLog((DEB_ERROR,"Server does not have proper key to decrypt ticket: 0x%x\n",
            Request->ticket.encrypted_part.encryption_type ));

        //
        // If this is our second attempt, do not overwrite the error code we had
        //

        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        }

        goto Cleanup;
    }

    //
    // We don't need to supply a service name or service because we've looked up
    // the account locally.
    //

    KerbErr = KerbCheckTicket(
                &Request->ticket,
                &Request->authenticator,
                KeyToUse,
                Authenticators,
                &SkewTime,
                0,                      // zero service names
                NULL,                   // any service
                NULL,
                TRUE,            // must check for clock_skew per RFC  bug #322448 & 385404 (time skew only)
                IsKdcRequest,
                &EncryptPart,
                &Authenticator,
                NULL,
                SessionKey,
                UseSubKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to check ticket : 0x%x for",KerbErr));
        KerbPrintKdcName(DEB_ERROR, ServerName);

        //
        // If an old password is available, give it a try. We remove the
        // current password & put the old password in here.
        //

        if (ServerTicketInfo->OldPasswords && (KerbErr == KRB_AP_ERR_MODIFIED))
        {
            MIDL_user_free(ServerTicketInfo->Passwords);
            ServerTicketInfo->Passwords = ServerTicketInfo->OldPasswords;
            ServerTicketInfo->OldPasswords = NULL;
            goto Retry;
        }


        //
        //  Here's the case where we're trying to use an expired TGT.  Have
        // the client retry using a new TGT
        //
        if (KerbErr == KRB_AP_ERR_TKT_EXPIRED)
        {
            FILL_EXT_ERROR_EX(pExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        }

        goto Cleanup;
    }

    //
    // Verify the address from the ticket
    //
    // NOTE: the check mandated by RFC1510 can be thwarted by a registry setting
    //       (KdcDontCheckAddresses) to allow seamless operation through NATs
    //

    if ((EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) &&
        ARGUMENT_PRESENT(ClientAddress) &&
        !KdcDontCheckAddresses)
    {
        ULONG TicketFlags = KerbConvertFlagsToUlong(&EncryptPart->flags);

        //
        // Only check initial tickets
        //

        if ((TicketFlags & (KERB_TICKET_FLAGS_forwarded | KERB_TICKET_FLAGS_proxy)) == 0)
        {
            if ( !KerbVerifyClientAddress(
                      ClientAddress,
                      EncryptPart->KERB_ENCRYPTED_TICKET_client_addresses ))
            {
                KerbErr = KRB_AP_ERR_BADADDR;
                DebugLog((DEB_ERROR,"Client sent request with wrong address\n"));
                goto Cleanup;
            }
        }
    }

    //
    // Verify that if the server is a trusted domain account, that it is an
    // acceptable ticket (transitively). Verify that for non transitive
    // trust the client realm is the same as the requesting ticket realm
    //

    if (((ServerTicketInfo->fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST) == 0) &&
         (ServerTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT))
    {
        if (!KerbCompareRealmNames(
                &EncryptPart->client_realm,
                &Request->ticket.realm
                ))
        {
            //
            // Could be a S4USelf request, in which case, we're looping back to local domain
            //
            if (!SecData.IsOurRealm(&EncryptPart->client_realm))
            {
                DebugLog((DEB_WARN, "KdcVerifyKdcRequest client from realm %s attempted to access non transitve trust via %s : illegal\n",
                    &EncryptPart->client_realm,
                    &Request->ticket.realm
                    ));
    
                KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
                goto Cleanup;
            }
        }
    }

    //
    // If the caller wanted the server key, return it here.
    //

    if (ServerKey != NULL)
    {
        KerbErr = KerbDuplicateKey(
                    ServerKey,
                    KeyToUse
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    *EncryptedTicket = EncryptPart;
    EncryptPart = NULL;
    if (ARGUMENT_PRESENT(UnmarshalledRequest))
    {
        *UnmarshalledRequest = Request;
        Request = NULL;
    }
    if (ARGUMENT_PRESENT(UnmarshalledAuthenticator))
    {
        *UnmarshalledAuthenticator = Authenticator;
        Authenticator = NULL;
    }

Cleanup:
    KerbFreeApRequest(Request);
    KerbFreeString(&LocalServerRealm);
    KerbFreeKdcName(&ServerName);
    KerbFreeString(&ServerRealm);
    KerbFreeAuthenticator(Authenticator);
    KerbFreeTicket(EncryptPart);

    return(KerbErr);
}

#if DBG

void
PrintRequest( ULONG ulDebLevel, PKERB_KDC_REQUEST_BODY Request )
{
    TRACE(KDC, PrintRequest, DEB_FUNCTION);
}

void
PrintTicket( ULONG ulDebLevel,
             char * pszMessage,
             PKERB_TICKET pkitTicket)
{
    TRACE(KDC, PrintTicket, DEB_FUNCTION);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\sockutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.cxx
//
// Contents:    Server support routines for sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "sockutil.h"
extern "C"
{
#include <atq.h>
}
#include <issched.hxx>

#define KDC_KEY                         "System\\CurrentControlSet\\Services\\kdc"
#define KDC_PARAMETERS_KEY KDC_KEY      "\\parameters"
#define KDC_MAX_ACCEPT_BUFFER           5000
#define KDC_MAX_ACCEPT_OUTSTANDING      16
#define KDC_ACCEPT_TIMEOUT              100
#define KDC_LISTEN_BACKLOG              10
 
BOOLEAN KdcSocketsInitialized = FALSE;
PVOID KdcEndpoint = NULL;
PVOID KpasswdEndpoint = NULL;
RTL_CRITICAL_SECTION KdcAtqContextLock;
LIST_ENTRY KdcAtqContextList;

NTSTATUS
KdcInitializeDatagramSockets(
    VOID
    );

NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    );

KERBERR
KdcAtqRetrySocketRead(
    IN PKDC_ATQ_CONTEXT Context,
    IN ULONG NewBytes
    );

//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqCloseSocket
//
//  Synopsis:   Wrapper to close socket to avoid socket leaks
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcAtqCloseSocket(
    IN PKDC_ATQ_CONTEXT Context
    )
{
    D_DebugLog ((DEB_T_SOCK, "Closing socket for %p\n", Context));

    AtqCloseSocket((PATQ_CONTEXT) Context->AtqContext, FALSE);
    Context->Flags |= KDC_ATQ_SOCKET_CLOSED;
}                                           


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqReferenceContext
//
//  Synopsis:   References a kdc ATQ context by one
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcReferenceContext(
    IN PKDC_ATQ_CONTEXT KdcContext
#if DBG
    , IN UINT Line
#endif
    )
{
    D_DebugLog ((DEB_T_SOCK, "Referencing KdcContext %p on line %d\n", KdcContext, Line));
    RtlEnterCriticalSection(&KdcAtqContextLock);
    KdcContext->References++;
    RtlLeaveCriticalSection(&KdcAtqContextLock);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqDereferenceContext
//
//  Synopsis:   Dereferences a context & unlinks & frees it when the
//              ref count goes to zero
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if this was the last release and the object was unlinked
//              and deleted, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcDereferenceContext(
    IN PKDC_ATQ_CONTEXT KdcContext
#if DBG
    ,
    IN UINT Line
#endif
    )
{
    BOOLEAN Deleted = FALSE;

    D_DebugLog ((DEB_T_SOCK, "Dereferencing KdcContext 0x%p on line %d\n", KdcContext, Line));

    DsysAssert( KdcContext );
    DsysAssert( KdcContext->References > 0 );

    RtlEnterCriticalSection(&KdcAtqContextLock);
    KdcContext->References--;

    if (KdcContext->References == 0)
    {
        Deleted = TRUE;
        RemoveEntryList(
            &KdcContext->Next
            );
    }

    RtlLeaveCriticalSection(&KdcAtqContextLock);

    if (Deleted)
    {
        if (((KdcContext->Flags &  KDC_ATQ_SOCKET_USED) != 0) &&
            ((KdcContext->Flags & KDC_ATQ_SOCKET_CLOSED) == 0))
        {   
            KdcAtqCloseSocket( KdcContext );
        }                                
        
        D_DebugLog ((DEB_T_SOCK, "Deleting KdcContext %p\n", KdcContext));
        AtqFreeContext( (PATQ_CONTEXT) KdcContext->AtqContext, TRUE );

        if (KdcContext->WriteBuffer != NULL)
        {
            KdcFreeEncodedData(KdcContext->WriteBuffer);
        }

        if (KdcContext->Buffer != NULL)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, KdcContext->Buffer);
        }

        MIDL_user_free(KdcContext);
    }
   
    return(Deleted);
}


#if DBG
#define KdcAtqReferenceContext( _Context ) KdcReferenceContext( _Context, __LINE__ )
#define KdcAtqDereferenceContext( _Context ) KdcDereferenceContext( _Context, __LINE__ )
#else
#define KdcAtqReferenceContext( _Context ) KdcReferenceContext( _Context )
#define KdcAtqDereferenceContext( _Context ) KdcDereferenceContext( _Context )
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqCreateContext
//
//  Synopsis:   Creates & links an ATQ context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKDC_ATQ_CONTEXT
KdcAtqCreateContext(
    IN PATQ_CONTEXT AtqContext,
    IN PVOID EndpointContext,
    IN LPOVERLAPPED lpo,
    IN PSOCKADDR ClientAddress,
    IN PSOCKADDR ServerAddress
    )
{
    PKDC_ATQ_CONTEXT KdcContext;

    if (!KdcSocketsInitialized)
    {
        return(NULL);
    }

    KdcContext = (PKDC_ATQ_CONTEXT) MIDL_user_allocate(sizeof(KDC_ATQ_CONTEXT));
    if (KdcContext != NULL)
    {
        KdcContext->References = 1; // Keepalive reference count
        KdcContext->AtqContext = AtqContext;
        KdcContext->EndpointContext = EndpointContext;
        KdcContext->lpo = lpo;
        KdcContext->Address = *ClientAddress;
        KdcContext->LocalAddress = *ServerAddress;
        KdcContext->WriteBuffer = NULL;
        KdcContext->WriteBufferLength = 0;
        KdcContext->Flags = KDC_ATQ_WRITE_CONTEXT;
        KdcContext->UsedBufferLength = 0;
        KdcContext->BufferLength = 0;
        KdcContext->ExpectedMessageSize = 0;
        KdcContext->Buffer = NULL;

        RtlEnterCriticalSection( &KdcAtqContextLock );
        InsertHeadList(&KdcAtqContextList, &KdcContext->Next);
        RtlLeaveCriticalSection( &KdcAtqContextLock );
    }

    D_DebugLog ((DEB_T_SOCK, "Creating KdcContext %p\n", KdcContext));

    return(KdcContext);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqConnectEx
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcAtqConnectEx(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{
    KERBERR KerbErr;
    PKDC_ATQ_CONTEXT KdcContext = NULL;
    PATQ_CONTEXT AtqContext = (PATQ_CONTEXT) Context;
    SOCKADDR * LocalAddress = NULL;
    SOCKADDR * RemoteAddress = NULL;
    SOCKET NewSocket = INVALID_SOCKET;
    PKDC_GET_TICKET_ROUTINE EndpointFunction = NULL;
    PVOID Buffer;

    TRACE(KDC, KdcAtqConnectEx, DEB_FUNCTION);

    //
    // Turning on hard closes on sockets.  We believe that we properly send
    // all the data to the client prior to closing the connection, otherwise
    // this won't work.
    //

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_ABORTIVE_CLOSE,
        TRUE
        );

    if ((CompletionStatus != NO_ERROR) || !KdcSocketsInitialized || !lpo )
    {
        D_DebugLog((DEB_T_SOCK, "ConnectEx: CompletionStatus = 0x%x\n", CompletionStatus));
        AtqCloseSocket( AtqContext, TRUE );
        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n", AtqContext));
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    //
    // Get the address information including the first write buffer
    //

    AtqGetAcceptExAddrs(
        AtqContext,
        &NewSocket,
        &Buffer,
        (PVOID *) &EndpointFunction,
        &LocalAddress,
        &RemoteAddress
        );

    //
    // New connection requests are guaranteed to always come in with BytesWritten == 0
    //

    DsysAssert( BytesWritten == 0 );

    //
    // If the remote address is port 88 or 464, don't respond, as we don't
    // want to be vulnerable to a loopback attack.
    //

    if ((((SOCKADDR_IN *) RemoteAddress)->sin_port == KERB_KDC_PORT) ||
        (((SOCKADDR_IN *) RemoteAddress)->sin_port == KERB_KPASSWD_PORT))
    {
        //
        // Just free up the context so it can be reused.
        //
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    //
    // Create a context
    //

    KdcContext = KdcAtqCreateContext(
                    AtqContext,
                    EndpointFunction,
                    lpo,
                    RemoteAddress,
                    LocalAddress
                    );

    if (KdcContext == NULL)
    {
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    //
    // Associate "our" KDC context with "their" ATQ context
    //

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_COMPLETION_CONTEXT,
        (ULONG_PTR) KdcContext
        );  
    
    //
    // Set the timeout for IOs on this context until the first byte of data is received
    // This timeout is shorter than the "subsequent" timeout to prevent
    // too many open and idle connections against the KDC
    //

    D_DebugLog((DEB_T_SOCK, "KdcAtqConnectEx: set timeout for KdcContext %p to KdcNewConnectionTimeout %#x\n", KdcContext, KdcNewConnectionTimeout));

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_TIMEOUT,
        KdcNewConnectionTimeout
        );

    //
    // Post a read right away - we expect the client to send us the request now
    //

    KerbErr = KdcAtqRetrySocketRead(
                  KdcContext,
                  0
                  );

    //
    // At this point, ownership of KdcContext was taken over by ATQ
    // If there was an error, the socket was closed and the context deleted
    //

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqIoCompletion
//
//  Synopsis:   Callback routine for an io completion on a TCP socket
//              for the KDC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The reference count when this routine is called should always
//              be equal to 2 (one keepalive ref count and one ref count for
//              the outstanding IO operation).  Note that this is a 'should'
//              and therefore there are no asserts in the code.
//
//              When the routine is left, either another IO operation was
//              enqueued (in which case the refcount is again 2) or the
//              connection has been closed (in which case the context is destroyed)
//
//--------------------------------------------------------------------------

VOID
KdcAtqIoCompletion(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{
    PKDC_ATQ_CONTEXT KdcContext;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKDC_GET_TICKET_ROUTINE EndpointFunction = NULL;

    TRACE(KDC,KdcAtqIoCompletion, DEB_FUNCTION);

    if (Context == NULL)
    {
        return;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((BytesWritten == 0) && (CompletionStatus == NO_ERROR))
    {
        CompletionStatus = WSAECONNABORTED;
    }

    KdcContext = (PKDC_ATQ_CONTEXT) Context;

    if ((CompletionStatus != NO_ERROR) || (lpo == NULL) || !KdcSocketsInitialized)
    {
        //
        // This includes timeout processing (CompletionStatus == ERROR_SEM_TIMEOUT)
        //

        D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion: CompletionStatus = 0x%x\n", CompletionStatus));
        D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion: lpo = %p\n", lpo));

        KdcAtqCloseSocket( KdcContext );

        //
        // If the overlapped structure is not null, then there is an
        // outstanding IO that just completed, so dereference the context
        // to remove that i/o. Otherwise leave the reference there, as we will
        // probably be called back when the io terminates.
        //

        if (lpo != NULL)
        {
            //
            // Drop the keepalive ref count - the connection has been closed
            //    

            KdcAtqDereferenceContext(KdcContext);
            goto Cleanup;
        }
        else
        {
            //
            // The keepalive refcount will be dropped when the outstanding IO
            // completes (now with an error, since the socket has been closed)
            //
            D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion context %p not dereferenced because lpo is NULL, CompletionStatus is 0x%x\n", KdcContext, CompletionStatus));
            goto CleanupNoRelease;
        }
    }

    //
    // NOTE: after reading or writing to a context, the context should
    // not be touched because a completion may have occurred on another
    // thread that may delete the context.
    //

    if ((KdcContext->Flags & KDC_ATQ_READ_CONTEXT) != 0)
    {
        KERBERR KerbErr;

        D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion: %d bytes read\n", BytesWritten));

        //
        // Read the number of bytes off the front of the message
        //

        if (KdcContext->UsedBufferLength == 0)
        {
            if (BytesWritten >= sizeof(ULONG))
            {
                KdcContext->ExpectedMessageSize = ntohl(*(PULONG)KdcContext->Buffer) + sizeof( ULONG );
                D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion: Expected msg size = %d\n", KdcContext->ExpectedMessageSize));

                //
                // Set the timeout for IOs on this context until the first byte of data is received
                //

                D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion: first completion, increasing timeout for KdcContext %p to KdcExistingConnectionTimeout %#x\n", KdcContext, KdcExistingConnectionTimeout));

                AtqContextSetInfo(
                    KdcContext->AtqContext,
                    ATQ_INFO_TIMEOUT,
                    KdcExistingConnectionTimeout
                    );
            }
            else
            {
                //
                // Blow away this connection - we require at least 4 bytes upfront
                //

                D_DebugLog((DEB_T_SOCK, "KdcAtqIoCompletion ERROR: Read completion on context %p with less than 4 bytes!\n", KdcContext));
                KdcAtqCloseSocket(KdcContext);

                //
                // Drop the keepalive ref count
                //

                KdcAtqDereferenceContext( KdcContext );

                goto Cleanup;
            }
        }

        if ( KdcContext->UsedBufferLength + BytesWritten < KdcContext->ExpectedMessageSize )
        {
            //
            // This will either enqueue another I/O on this context and bump
            // up the ref count, or, on failure, close the socket and drop
            // the keepalive ref count
            //

            KerbErr = KdcAtqRetrySocketRead(
                          KdcContext,
                          BytesWritten
                          );

            goto Cleanup;
        }

        //
        // There is a buffer, so use it to do the KDC thang.
        //

        KdcContext->lpo = lpo;
        InputMessage.BufferSize = (KdcContext->UsedBufferLength + BytesWritten) - sizeof(ULONG);
        InputMessage.Buffer = KdcContext->Buffer + sizeof(ULONG);
        OutputMessage.Buffer = NULL;

        EndpointFunction = (PKDC_GET_TICKET_ROUTINE) KdcContext->EndpointContext;

        KerbErr = EndpointFunction(
                      &KdcContext,
                      &KdcContext->Address,
                      &KdcContext->LocalAddress,
                      &InputMessage,
                      &OutputMessage
                      );

        if ((KerbErr != KDC_ERR_NONE) || (OutputMessage.BufferSize != 0))
        {
            //
            // We expect at least some level of message validity before 
            // we'll return anything.
            //
            if (KerbErr == KDC_ERR_NO_RESPONSE)
            {
                // TBD:  Log an "attack" event here.
                KdcAtqCloseSocket(KdcContext);

                //
                // Drop the keepalive ref count
                //
                KdcAtqDereferenceContext(KdcContext);
            }
            else
            {
                ULONG NetworkSize;
                WSABUF Buffers[2];

                NetworkSize = htonl(OutputMessage.BufferSize);

                Buffers[0].len = sizeof(DWORD);
                Buffers[0].buf = (PCHAR) &NetworkSize;

                Buffers[1].len = OutputMessage.BufferSize;
                Buffers[1].buf = (PCHAR) OutputMessage.Buffer;
                KdcContext->WriteBufferLength = OutputMessage.BufferSize;
                KdcContext->WriteBuffer = OutputMessage.Buffer;

                OutputMessage.Buffer = NULL;

                //      
                // If there was no output message, don't send one.
                //              

                KdcContext->Flags |= KDC_ATQ_WRITE_CONTEXT;
                KdcContext->Flags &= ~KDC_ATQ_READ_CONTEXT;

                //              
                // Refernce the context for the write.
                //                      

                KdcAtqReferenceContext(KdcContext);

                if (!AtqWriteSocket(
                         KdcContext->AtqContext,
                         Buffers,
                         2,
                         lpo
                         ))
                {
                    DebugLog((DEB_ERROR, "Failed to write KDC reply: 0x%x\n", GetLastError()));
                    KdcAtqCloseSocket(  KdcContext );

                    //
                    // Remove the reference we have just applied
                    //
                    KdcAtqDereferenceContext(KdcContext);

                    //
                    // Drop the keepalive ref count
                    //
                    KdcAtqDereferenceContext(KdcContext);
                }
            }

            if (OutputMessage.Buffer != NULL)
            {
                KdcFreeEncodedData(OutputMessage.Buffer);
            }
        }
        else
        {
            //
            // Bizarre situation - nothing to send to the client
            // In the kerberos world, this connection has no business existing
            //
            DebugLog((DEB_ERROR, "Endpoint function returned but nothing to send, Context = %p\n", Context ));
            KdcAtqCloseSocket(  KdcContext );

            //
            // Drop the keepalive ref count
            //
            KdcAtqDereferenceContext(KdcContext);
        }
    }
    else
    {
        D_DebugLog((DEB_T_SOCK, "IoCompletion: %d bytes written\n", BytesWritten));

        KdcContext->Flags |= KDC_ATQ_READ_CONTEXT;
        KdcContext->Flags &= ~KDC_ATQ_WRITE_CONTEXT;

        //
        // Reset the buffer for a brand new read
        //

        KdcContext->UsedBufferLength = 0;
        KdcContext->ExpectedMessageSize = 0;

        if (KdcContext->WriteBuffer != NULL)
        {
            KdcFreeEncodedData(KdcContext->WriteBuffer);

            KdcContext->WriteBuffer = NULL;
        }

        //
        // Reference the context for the read
        //

        KdcAtqReferenceContext(KdcContext);

        if (!AtqReadFile(
                 KdcContext->AtqContext,
                 KdcContext->Buffer,
                 KdcContext->BufferLength,
                 lpo
                 ))
        {
            DebugLog((DEB_ERROR, "Failed to read file for %d bytes: 0x%x\n", KERB_MAX_KDC_REQUEST_SIZE,GetLastError()));
            KdcAtqCloseSocket(  KdcContext );

            //
            // Dereference the reference we just added
            //

            KdcAtqDereferenceContext(KdcContext);

            //
            // Drop the keepalive ref count
            //

            KdcAtqDereferenceContext(KdcContext);
        }
    }

Cleanup:

    //
    // Drop the reference count associated with an outstanding I/O operation
    //

    KdcAtqDereferenceContext(KdcContext);

CleanupNoRelease:

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqRetrySocketRead
//
//  Synopsis:   Retries a read if not all the data was read
//
//  Effects:    posts an AtqReadSocket
//              Closes and dereferences the context on error
//
//  Arguments:  Context - The KDC context to retry the read on
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcAtqRetrySocketRead(
    IN PKDC_ATQ_CONTEXT KdcContext,
    IN ULONG NewBytes
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PBYTE NewBuffer = NULL;
    ULONG NewBufferLength;

    D_DebugLog(( DEB_T_SOCK, "RetrySocketRead:  Expected size = %#x, current size %#x\n",
                KdcContext->ExpectedMessageSize,
                KdcContext->UsedBufferLength));

    if (KdcContext->ExpectedMessageSize != 0)
    {
        NewBufferLength = KdcContext->ExpectedMessageSize;
    }
    else
    {
        //
        // Set max buffer length at 128k
        //
        if (KdcContext->BufferLength < KDC_MAX_BUFFER_LENGTH)
        {
            NewBufferLength = KdcContext->BufferLength + KERB_MAX_KDC_REQUEST_SIZE;
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    if (NewBufferLength > KDC_MAX_BUFFER_LENGTH)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If the expected message size doesn't fit in the current buffer,
    // allocate a new one.
    //

    if (NewBufferLength > KdcContext->BufferLength)
    {
        D_DebugLog(( DEB_T_SOCK, "Allocating a new buffer for context %p\n", KdcContext ));

        //
        // Do not use MIDL_user_allocate here since that would zero the memory
        // out which amounts to waste of CPU cycles
        //

        NewBuffer = (PBYTE)RtlAllocateHeap(
                               RtlProcessHeap(),
                               0,
                               NewBufferLength
                               );

        if (NewBuffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // we resized while the buffer was in use.  Copy the data and touch up
        // the pointers below
        //

        RtlCopyMemory(
            NewBuffer,
            KdcContext->Buffer,
            KdcContext->BufferLength
            );
  
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            KdcContext->Buffer
            );

        KdcContext->Buffer = NewBuffer;
        KdcContext->BufferLength = NewBufferLength;
        NewBuffer = NULL;
    }

    KdcContext->UsedBufferLength += NewBytes;
    KdcContext->Flags |= KDC_ATQ_READ_CONTEXT;
    KdcContext->Flags &= ~(KDC_ATQ_WRITE_CONTEXT);

    //
    // Reference the context for the read
    //

    KdcAtqReferenceContext(KdcContext);

    if (!AtqReadFile(
             KdcContext->AtqContext,
             (PUCHAR) KdcContext->Buffer + KdcContext->UsedBufferLength,
             KdcContext->BufferLength - KdcContext->UsedBufferLength,
             KdcContext->lpo
             ))
    {
        DebugLog((DEB_ERROR, "Failed to read file for %d bytes: 0x%x\n", KdcContext->BufferLength - KdcContext->UsedBufferLength, GetLastError()));
        
        //
        // Dereference the reference we just added
        //

        KdcAtqDereferenceContext(KdcContext);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;                           
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Closing connection to %p due to RetrySocketRead error\n", KdcContext));
        KdcAtqCloseSocket( KdcContext );

        //
        // Drop the keepalive ref count
        //

        KdcAtqDereferenceContext(KdcContext);
    }
    
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeSockets
//
//  Synopsis:   Initializes the KDCs socket handling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcInitializeSockets(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATQ_ENDPOINT_CONFIGURATION EndpointConfig;
    BOOLEAN AtqInitCalled = FALSE;
    BOOLEAN ContextLockInited = FALSE;

    TRACE(KDC,KdcInitializeSockets, DEB_FUNCTION);

    //
    // Initialize the asynchronous thread queue.
    //

    if (!AtqInitialize(0)) 
    {
        DebugLog((DEB_ERROR, "Failed to initialize ATQ\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    AtqInitCalled = TRUE;

    Status = RtlInitializeCriticalSection(&KdcAtqContextLock);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    ContextLockInited = TRUE;

    InitializeListHead(&KdcAtqContextList);

    //
    // Create the KDC endpoint
    //

    EndpointConfig.ListenPort = KERB_KDC_PORT;
    EndpointConfig.fDatagram = FALSE;
    EndpointConfig.fReverseQueuing = FALSE; // ignored (datagram only)
    EndpointConfig.cbDatagramWSBufSize = 0; // ignored (datagram only)
    EndpointConfig.fLockDownPort = TRUE;
    EndpointConfig.IpAddress = INADDR_ANY;
    EndpointConfig.cbAcceptExRecvBuffer = 0; // do not wait for data to be received
                                             // prior to notifying us of a new connection
    EndpointConfig.nAcceptExOutstanding = KDC_MAX_ACCEPT_OUTSTANDING;
    EndpointConfig.AcceptExTimeout = (unsigned long)-1;  // Forever;
    EndpointConfig.pfnConnect = NULL;
    EndpointConfig.pfnConnectEx = KdcAtqConnectEx;
    EndpointConfig.pfnIoCompletion = KdcAtqIoCompletion;

    KdcEndpoint = AtqCreateEndpoint(
                      &EndpointConfig,
                      KdcGetTicket
                      );

    if (KdcEndpoint == NULL)
    {
        DebugLog((DEB_ERROR, "Failed to create ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(KdcEndpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Create the KPASSWD endpoint
    //

    EndpointConfig.ListenPort = KERB_KPASSWD_PORT;

    KpasswdEndpoint = AtqCreateEndpoint(
                          &EndpointConfig,
                          KdcChangePassword
                          );

    if (KpasswdEndpoint == NULL)
    {
        DebugLog((DEB_ERROR, "Failed to create ATQ endpoint for kpasswd\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(KpasswdEndpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Successfully started ATQ listening for kpasswd\n"));

    Status = KdcInitializeDatagramSockets( );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KdcSocketsInitialized = TRUE;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (KdcEndpoint != NULL)
        {
            (VOID) AtqStopEndpoint( KdcEndpoint );
            (VOID) AtqCloseEndpoint( KdcEndpoint );
            KdcEndpoint = NULL;
        }

        if (KpasswdEndpoint != NULL)
        {
            (VOID) AtqStopEndpoint( KpasswdEndpoint );
            (VOID) AtqCloseEndpoint( KpasswdEndpoint );
            KpasswdEndpoint = NULL;
        }

        if ( ContextLockInited ) {

            RtlDeleteCriticalSection( &KdcAtqContextLock );
        }

        if (AtqInitCalled)
        {
            AtqTerminate();
        }
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownSockets
//
//  Synopsis:   Shuts down the KDC socket handling code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcShutdownSockets(
    VOID
    )
{
    PKDC_ATQ_CONTEXT Context;
    PLIST_ENTRY ListEntry;
    BOOLEAN KdcSocketsWasInitialized = KdcSocketsInitialized;

    TRACE(KDC,KdcShutdownSockets, DEB_FUNCTION);

    if (!KdcSocketsInitialized)
    {
        return(STATUS_SUCCESS);
    }

    //
    // Go through the list of contexts and close them all.
    //

    RtlEnterCriticalSection( &KdcAtqContextLock );

    KdcSocketsInitialized = FALSE;

    for (ListEntry = KdcAtqContextList.Flink;
        (ListEntry != &KdcAtqContextList) && (ListEntry != NULL) ;
        ListEntry = ListEntry->Flink )
    {
        Context = CONTAINING_RECORD(ListEntry, KDC_ATQ_CONTEXT, Next);

        //
        // If this is a read or write context, free close the associated
        // socket. (Endpoint contexts don't have sockets).
        //

        if (Context->Flags & ( KDC_ATQ_WRITE_CONTEXT | KDC_ATQ_READ_CONTEXT))
        {
            KdcAtqCloseSocket( Context );
        }
    }

    RtlLeaveCriticalSection( &KdcAtqContextLock );

    if (KdcEndpoint != NULL)
    {
        (VOID) AtqStopEndpoint( KdcEndpoint );
        (VOID) AtqCloseEndpoint( KdcEndpoint );
        KdcEndpoint = NULL;
    }

    if (KpasswdEndpoint != NULL)
    {
        (VOID) AtqStopEndpoint( KpasswdEndpoint );
        (VOID) AtqCloseEndpoint( KpasswdEndpoint );
        KpasswdEndpoint = NULL;
    }

    KdcShutdownDatagramSockets();

    if (KdcSocketsWasInitialized)
    {
        if (!AtqTerminate())
        {
            DebugLog((DEB_ERROR, "Failed to terminate ATQ!!!\n"));
        }

        RtlDeleteCriticalSection(&KdcAtqContextLock);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\utest\kdcdbg_c_stub.c ===
#include "kdcdbg_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\transit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.h
//
// Contents:    Prototypes for transited realm encoding
//
//
// History:     2-April-1997    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __TRANSIT_H__
#define __TRANSIT_H__

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN PUNICODE_STRING OurRealm
    );

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    );


#endif // __TRANSIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\utest\kdctest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ticktest.cxx
//
//  Contents:   KDC Ticket granting service test code.
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
#include <stdio.h>
#include <stdlib.h>
#include <kerbcomm.h>
#include <kerbcred.h>
extern "C"
{
#include <dsgetdc.h>
#include <kdcdbg.h>
}

UNICODE_STRING ClientName;
UNICODE_STRING ServiceName;
UNICODE_STRING ClientRealm;
UNICODE_STRING ServiceRealm;
UNICODE_STRING ClientPassword;
UNICODE_STRING ServicePassword;
UNICODE_STRING KdcName;
WCHAR KdcNameString[100];
ULONG AddressType = DS_NETBIOS_ADDRESS;
ULONG CryptType = KERB_ETYPE_RC4_MD4;
PVOID KdcBinding;

BOOLEAN
BindToKdc()
{
    ULONG NetStatus;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;

    if (KdcName.Buffer == NULL)
    {
        //
        // No kdc specified, use DSGetDCName
        //

        NetStatus = DsGetDcName(
                        NULL,
                        ClientRealm.Buffer,
                        NULL,
                        NULL,
                        DS_KDC_REQUIRED,
                        &DcInfo
                        );
        if (NetStatus != NO_ERROR)
        {
            printf("DsGetDcName returned %d\n",NetStatus);
            return(FALSE);
        }

        RtlInitUnicodeString(
            &KdcName,
            DcInfo->DomainControllerAddress+2
            );

        AddressType = DcInfo->DomainControllerAddressType;


    }
        return(TRUE);

}


BOOLEAN
GetAnAsTicket(
    IN PUNICODE_STRING ServerName,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PKERB_KDC_REPLY * Reply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_ENCRYPTION_KEY UserKey;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody;
    ULONG CryptArray[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptArraySize;
    UNICODE_STRING FullServiceName;
    UNICODE_STRING FullClientName;
    PKERB_ERROR ErrorMessage = NULL;
    LARGE_INTEGER TempTime;
    ULONG KdcFlagOptions = 0;
    ULONG KdcOptions = 0;
    BOOLEAN DoingSomething = FALSE;


    RtlZeroMemory(
        &OutputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );

    RtlZeroMemory(
        &InputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );



    //
    // Build the request
    //

    RtlZeroMemory(
        &Request,
        sizeof( KERB_KDC_REQUEST )
        );
    RequestBody = &Request.request_body;

    KdcOptions =
                            KERB_KDC_OPTIONS_forwardable |
                            KERB_KDC_OPTIONS_proxiable |
                            KERB_KDC_OPTIONS_renewable |
                            KERB_KDC_OPTIONS_renewable_ok;

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    RequestBody->nonce = 3;

    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );


    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    TempTime.QuadPart = 0;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    //
    // Build crypt vector.
    //

    CryptArraySize = KERB_MAX_CRYPTO_SYSTEMS;
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // BUGBUG: don't build pre-auth data
    //


    KerbBuildFullServiceName(
        &ClientRealm,
        ServerName,
        &FullServiceName
        );

    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                    &FullServiceName,
                    KRB_NT_MS_PRINCIPAL
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;

    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;
    KerbBuildFullServiceName(
        &ClientRealm,
        &ClientName,
        &FullClientName
        );
    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &FullClientName,
                KRB_NT_MS_PRINCIPAL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert unicde string to realm: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_AS_REQ;


    KerbErr = KerbPackAsRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    Status = KerbCallKdc(
                &KdcName,
                AddressType,
                10,
                TRUE,
                &InputMessage,
                &OutputMessage
                );


    if (!NT_SUCCESS(Status))
    {
        printf("KerbCallKdc failed: 0x%x\n",Status);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbUnpackAsReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);

        KerbErr = KerbUnpackKerbError(
                    OutputMessage.Buffer,
                    OutputMessage.BufferSize,
                    &ErrorMessage
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get AS ticket: 0x%x\n",ErrorMessage->error_code);
            KerbErr = (KERBERR) ErrorMessage->error_code;
        }
        goto Cleanup;
    }

    KerbErr = KerbHashPassword(
                &ClientPassword,
                (*Reply)->encrypted_part.encryption_type,
                &UserKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to hash password with 0x%x alg\n",(*Reply)->encrypted_part.encryption_type);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &(*Reply)->encrypted_part,
                &UserKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    *Ticket = (*Reply)->ticket;

Cleanup:

    //
    // BUGBUG: memory leak here
    //

    if (KERB_SUCCESS(KerbErr))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOLEAN
GetATgsTicket(
    IN PKERB_TICKET TicketGrantingTicket,
    IN PKERB_ENCRYPTED_KDC_REPLY TgtReplyBody,
    IN PKERB_KDC_REPLY TgtReply,
    IN BOOLEAN Renew,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PKERB_KDC_REPLY * Reply
    )
{
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    UNICODE_STRING FullServiceName;
    PKERB_INTERNAL_NAME FullClientName;
    KERBERR KerbErr;
    KERB_PA_DATA_LIST  PaData;
    ULONG CryptArray[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKERB_ERROR ErrorMessage = NULL;
    ULONG NameType;
    ULONG KdcFlagOptions = 0;
    ULONG KdcOptions = 0;




    //
    // Build the request
    //

    RtlZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );

    KdcOptions = KERB_KDC_OPTIONS_forwardable |
                          KERB_KDC_OPTIONS_proxiable |
                          KERB_KDC_OPTIONS_renewable |
                          KERB_KDC_OPTIONS_renewable_ok;
    if (Renew)
    {
        KdcOptions |= KERB_KDC_OPTIONS_renew;
    }


    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;



    RequestBody->nonce = 4;

    //
    // Build an AP request inside an encrypted data structure.
    //

    KerbConvertPrincipalNameToKdcName(
        &FullClientName,
        &TgtReply->client_name
        );

    PaData.next = NULL;
    PaData.value.preauth_data_type = KRB5_PADATA_TGS_REQ;

    KerbErr = KerbCreateApRequest(
                FullClientName,
                &ClientRealm,
                &TgtReplyBody->session_key,
                NULL,                           // no sub session key
                5,                              // nonce
                TicketGrantingTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                NULL,                           // server time
                TRUE,                           // KDC request
                (PULONG) &PaData.value.preauth_data.length,
                &PaData.value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.KERB_KDC_REQUEST_preauth_data = &PaData;
    Request.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    KerbErr = KerbDuplicatePrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                    &TgtReply->client_name
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                &ServiceName,
                KRB_NT_MS_PRINCIPAL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;


    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );

    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;


    TempTime.LowPart  = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );



    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGS_REQ;


    KerbErr = KerbPackTgsRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Get the ticket.
    //

    OutputMessage.Buffer = NULL;
    OutputMessage.BufferSize = 0;
    KerbErr = (KERBERR) KerbCallKdc(
                            &KdcName,
                            AddressType,
                            10,
                            TRUE,
                            &InputMessage,
                            &OutputMessage
                            );


    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackTgsReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);
        KerbErr = KerbUnpackKerbError(
                    OutputMessage.Buffer,
                    OutputMessage.BufferSize,
                    &ErrorMessage
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get TGS ticket: 0x%x\n",ErrorMessage->error_code);
            KerbErr = (KERBERR) ErrorMessage->error_code;
        }

        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &(*Reply)->encrypted_part,
                &TgtReplyBody->session_key,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    *Ticket = (*Reply)->ticket;

Cleanup:
    //
    // BUGBUG: memory leak here
    //

    if (KERB_SUCCESS(KerbErr))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


BOOLEAN
UStringFromAnsi(
    OUT PUNICODE_STRING UnicodeString,
    IN LPSTR String
    )
{
    STRING AnsiString;

    RtlInitString(
        &AnsiString,
        String
        );
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(
                        UnicodeString,
                        &AnsiString,
                        TRUE
                        )))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

void
SetDefaultOpts()
{
    UNICODE_STRING TempString;
    STRING AnsiString;
    LPSTR String;

    KerbInitializeSockets(0x0101,5);

    //
    // Username
    //

    String = getenv( "USERNAME" );
    if (String == NULL)
    {
        String = "mikesw";
    }

    UStringFromAnsi(
        &ClientName,
        String
        );


    String = getenv( "USERDOMAIN" );
    if (String == NULL)
    {
        String = "NTDS";
    }

    UStringFromAnsi(
        &ClientRealm,
        String
        );

    UStringFromAnsi(
        &ServiceRealm,
        String
        );


}


VOID
SetPassword(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN UnixOnly
    )
{
    NTSTATUS Status;
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    handle_t        hBinding;
    sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return;
    }
    sc = RpcBindingFromStringBinding(pszBinding, &hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return;
    }
    sc = RpcEpResolveBinding(hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return;
    }

    Status = KDC_SetPassword(
                hBinding,
                UserName,
                PrincipalName,
                Password,
                UnixOnly ? KERB_PRIMARY_CRED_RFC1510_ONLY : 0
                );
    RpcBindingFree(&hBinding);
    printf("SetPassword returned 0x%x\n",Status);

}


BOOLEAN
BindToKdcRpc(
    handle_t * hBinding
    )
{
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    if (KdcName.Buffer == NULL)
    {
        sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    }
    else
    {
        sc = RpcStringBindingCompose(0, L"ncacn_ip_tcp",KdcNameString,NULL,
                0, &pszBinding);
    }
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return FALSE;
    }
    sc = RpcBindingFromStringBinding(pszBinding, hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return FALSE;
    }
    sc = RpcEpResolveBinding(*hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return FALSE;
    }
    return TRUE;

}

VOID
DumpKdc(
    VOID
    )
{
    NTSTATUS Status;
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    handle_t        hBinding;
    sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return;
    }
    sc = RpcBindingFromStringBinding(pszBinding, &hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return;
    }
    sc = RpcEpResolveBinding(hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return;
    }

    Status = KDC_Dump(
                hBinding
                );
    RpcBindingFree(&hBinding);

}


VOID
DumpKdcDomains( VOID )
{
    NTSTATUS Status;
    PKDC_DBG_DOMAIN_LIST DomainList = NULL;
    ULONG Index;

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_GetDomainList(
                hBinding,
                &DomainList
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed toget domain list: 0x%x\n",Status);
    }
    else
    {
         for (Index = 0; Index < DomainList->Count ; Index++ )
         {
             printf("Domain %d:\n",Index);
             printf("\tDnsName = %wZ\n",&DomainList->Domains[Index].DnsName);
             printf("\tNetbiosName = %wZ\n",&DomainList->Domains[Index].NetbiosName);
             printf("\tClosestRoute = %wZ\n",&DomainList->Domains[Index].ClosestRoute);
             printf("\tType = 0x%x, Attributes = 0x%x\n",DomainList->Domains[Index].Type, DomainList->Domains[Index].Attributes);
         }
    }

}

VOID
KdcNormalize(
    ULONG Flags,
    PKERB_DBG_INTERNAL_NAME Name
    )
{
    NTSTATUS Status;
    PKDC_DBG_DOMAIN_LIST DomainList = NULL;
    ULONG Index;

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_Normalize(
                hBinding,
                Name,
                Flags
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed toget domain list: 0x%x\n",Status);
    }
    else
    {
        printf("Success\n");
    }

}


VOID
KdcSetState(
    ULONG Lifetime,
    ULONG RenewTime
    )
{
    NTSTATUS Status;
    LARGE_INTEGER FudgeFactor = {0};

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_SetState(
                hBinding,
                0,              // no flags
                Lifetime,
                RenewTime,
                FudgeFactor
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set kdc options: 0x%x\n",Status);
    }
    else
    {
        printf("Success\n");
    }

}

void
Usage(char * Name)
{
    printf("%s\n",Name);
    printf("-cname, -sname : set client & service names\n");
    printf("-crealm, -srealm : set client & service realms\n");
    printf("-cpass, -spass : set client & service passwords\n");
    printf("-crypt : set encryption type\n");
    printf("-gettgt : get a TGT in client's realm, incompat. with -getas\n");
    printf("-getas : get an AS ticket to a service, incompat. with -gettgt\n");
    printf("-gettgs : get a TGS ticket to a service, requires a TGT\n");
    printf("-renew : renew last ticket acquired\n");
    printf("-dump : dump kdc heap trace\n");
    printf("-kdc : set kdc name\n");
    printf("-norm 0xFlags type name1 name2 name3 ... : normalize a name\n");
    printf("-domains : dump domain list\n");
    printf("-setstate lifespan renewspan : set ticket lifetime\n");
    printf("\n");
    printf("-setpass username principalname password  : sets KRB5 password\n");
}



void
__cdecl main(int argc, char *argv[])
{
    int Index;
    BOOLEAN GetAsTicket = FALSE;
    BOOLEAN GetTgsTicket = FALSE;
    BOOLEAN GetTgt = FALSE;
    BOOLEAN RenewTicket = FALSE;
    BOOLEAN SetPass = FALSE;
    BOOLEAN Dump = FALSE;
    BOOLEAN Normalize= FALSE;
    BOOLEAN DumpDomains = FALSE;
    BOOLEAN SetState = FALSE;
    ULONG Lifespan = 0;
    ULONG RenewSpan = 0;
    UNICODE_STRING UserName;
    UNICODE_STRING PrincipalName;
    UNICODE_STRING Password;
    STRING AnsiString;
    UNICODE_STRING AsServerName;
    PKERB_ENCRYPTED_KDC_REPLY AsReplyBody = NULL;
    PKERB_KDC_REPLY AsReply = NULL;
    KERB_TICKET AsTicket;

    PKERB_ENCRYPTED_KDC_REPLY TgsReplyBody = NULL;
    PKERB_KDC_REPLY TgsReply = NULL;
    KERB_TICKET TgsTicket;
    BOOLEAN UnixOnly = FALSE;
    KERB_DBG_INTERNAL_NAME Name = {0};
    ULONG Flags;
    UNICODE_STRING NameParts[20];
    WCHAR NameBuffers[20][100];
    ULONG Index2;


    SetDefaultOpts();

    for (Index = 1; Index < argc ; Index++ )
    {
        //
        // First the principal name features
        //

        if (!_stricmp(argv[Index],"-crealm"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientRealm,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-srealm"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }

            UStringFromAnsi(
                &ServiceRealm,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-cname"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientName,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-sname"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ServiceName,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-cpass"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientPassword,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-spass"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ServicePassword,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-crypt"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"%d",&CryptType);

        } else
        if (!_stricmp(argv[Index],"-gettgt"))
        {
            GetTgt = TRUE;
        } else
        if (!_stricmp(argv[Index],"-getas"))
        {
            GetAsTicket = TRUE;
        } else
        if (!_stricmp(argv[Index],"-gettgs"))
        {
            GetTgsTicket = TRUE;
        } else
        if (!_stricmp(argv[Index],"-renew"))
        {
            RenewTicket = TRUE;
        }
        else if (!_stricmp(argv[Index],"-setpass"))
        {
            if (Index+4 > argc)
            {
                printf("Not enough args: %d instead of %d\n", argc, Index+3);
                goto Usage;
            }
            SetPass = TRUE;
            UStringFromAnsi(
                &UserName,
                argv[++Index]
                );
            UStringFromAnsi(
                &PrincipalName,
                argv[++Index]
                );
            UStringFromAnsi(
                &Password,
                argv[++Index]
                );
        }
        else if (!_stricmp(argv[Index],"-dump"))
        {
            Dump = TRUE;
        }
        else if (!_stricmp(argv[Index],"-unix"))
        {
            UnixOnly = TRUE;
        }
        else if (!_stricmp(argv[Index],"-kdc"))
        {
            if (Index+2 > argc)
            {
                goto Usage;
            }
            mbstowcs(KdcNameString,argv[++Index],100);
            RtlInitUnicodeString(
                &KdcName,
                KdcNameString
                );
        }
        else if (!_stricmp(argv[Index],"-norm"))
        {
            Normalize = TRUE;
            if (Index+4 > argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"0x%x",&Flags);
            sscanf(argv[++Index],"%d",&Name.NameType);
            Name.NameCount = 0;
            Name.References = 0;
            Name.Names = NameParts;
            Index2 = 0;
            while (Index < argc-1)
            {
                mbstowcs(NameBuffers[Index2],argv[++Index],100);
                RtlInitUnicodeString(
                    &NameParts[Index2],
                    NameBuffers[Index2]
                    );
                Index2++;
                Name.NameCount++;
            }


        }
        else if (!_stricmp(argv[Index],"-domains"))
        {
            DumpDomains = TRUE;
        }
        else if (!_stricmp(argv[Index],"-setstate"))
        {
            if (Index+3 > argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"%d",&Lifespan);
            sscanf(argv[++Index],"%d",&RenewSpan);
            SetState = TRUE;
        }
        else {
            goto Usage;
        }


    }

    if (GetTgsTicket && !GetTgt)
    {
        printf("ERROR: Can't get a TGS ticket without a TGT\n");
        goto Usage;
    }

    if (GetAsTicket && GetTgt)
    {
        printf("ERROR: Can't get both an AS ticket and a TGT\n");
        goto Usage;
    }


    if (SetPass)
    {
        SetPassword( &UserName, &PrincipalName, &Password, UnixOnly );
        goto Cleanup;
    }
    if (Dump)
    {
        DumpKdc();
        goto Cleanup;
    }
    if (DumpDomains)
    {
        DumpKdcDomains();
        goto Cleanup;
    }

    if (SetState)
    {
        KdcSetState(
            Lifespan,
            RenewSpan
            );
        goto Cleanup;
    }
    if (Normalize)
    {
        KdcNormalize(
            Flags,
            &Name
            );
        goto Cleanup;
    }
    //
    // Bind to the KDC
    //

    if (!BindToKdc())
    {
        printf("ERROR: Failed to bind to KDC\n");
        goto Cleanup;
    }
    //
    // Now try to get the AS ticket
    //

    if (GetAsTicket)
    {
        AsServerName = ServiceName;
    }
    else if (GetTgt)
    {
        RtlInitUnicodeString(
            &AsServerName,
            KDC_PRINCIPAL_NAME
            );
    }

    if (!GetAnAsTicket(
            &AsServerName,
            &AsTicket,
            &AsReplyBody,
            &AsReply
            ))
    {
        printf("ERROR: Failed to get AS ticket\n");
        goto Cleanup;
    }
    else
    {
        printf("SUCCESS: got an AS ticket\n");
    }

    if (GetTgsTicket)
    {
        if (!GetATgsTicket(
                &AsTicket,
                AsReplyBody,
                AsReply,
                FALSE,          // don't renew
                &TgsTicket,
                &TgsReplyBody,
                &TgsReply))
        {
            printf("ERROR: Failed to get TGS ticket\n");
            goto Cleanup;
        }
        else
        {
            printf("SUCCESS: got a TGS ticket\n");
        }
    }
    if (Dump)
    {
        DumpKdc();
    }

    goto Cleanup;

Usage:
    Usage(argv[0]);

Cleanup:

    KerbCleanupTickets();

    return;
}



void *
MIDL_user_allocate( size_t cb )
{
    return LocalAlloc( 0, ROUND_UP_COUNT(cb,8) );
}

void
MIDL_user_free( void * pv )
{
    LocalFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\transit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.cxx
//
// Contents:    Code for compressing transitive realm list
//
//
// History:
//
//------------------------------------------------------------------------
#include "kdcsvr.hxx"
#include <alloca.h>

//+-----------------------------------------------------------------------
//
// Function:    KerbAppendString
//
// Synopsis:    Appends to unicode strings together and allocates the output
//
// Effects:
//
// Parameters:  Output - Output appended String
//              InputTail - Trailing portion of input
//              InputHead - Head potion of input
//
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------
NTSTATUS
KerbAppendString(
    OUT PUNICODE_STRING Output,
    IN PUNICODE_STRING InputTail,
    IN PUNICODE_STRING InputHead
    )
{
    Output->Buffer = NULL;
    Output->Length = InputHead->Length + InputTail->Length;
    if ((InputHead->Buffer == NULL) && (InputTail->Buffer == NULL))
    {
        Output->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }
    else
    {
        Output->MaximumLength = Output->Length + sizeof(WCHAR);
    }

    Output->Buffer = (LPWSTR) MIDL_user_allocate(Output->MaximumLength);
    if (Output->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        Output->Buffer,
        InputHead->Buffer,
        InputHead->Length
        );
    RtlCopyMemory(
        Output->Buffer + InputHead->Length / sizeof(WCHAR),
        InputTail->Buffer,
        InputTail->Length
        );
    Output->Buffer[Output->Length/sizeof(WCHAR)] = L'\0';
    return(STATUS_SUCCESS);
}


typedef enum _KERB_DOMAIN_COMPARISON {
    Above,
    Below,
    Equal,
    NotEqual
} KERB_DOMAIN_COMPARISON, *PKERB_DOMAIN_COMPARISON;

//+-----------------------------------------------------------------------
//
// Function:    KerbCompareDomains
//
// Synopsis:    Compares two domain names and returns whether one is a
//              prefix of the other, and the offset of the prefix.
//
// Effects:
//
// Parameters:
//
// Return:      Above - domain1 is a postfix of domain2
//              Below - domain2 is a postfix of domain1
//              Equal - the domains are equal
//              NotEqual - the domains are not equal and not above or below
//
// Notes:       This does not work for x-500 realm names (/foo/bar)
//
//------------------------------------------------------------------------

KERB_DOMAIN_COMPARISON
KerbCompareDomains(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2,
    OUT PULONG PostfixOffset
    )
{
    UNICODE_STRING TempString;

    if (Domain1->Length > Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain2->Length;
        TempString.Buffer = Domain1->Buffer + (Domain1->Length - Domain2->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain2,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain1->Length - Domain2->Length) / sizeof(WCHAR);
            return(Below);
        }
        else
        {
            return(NotEqual);
        }
    }
    else if (Domain1->Length < Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain1->Length;
        TempString.Buffer = Domain2->Buffer + (Domain2->Length - Domain1->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain1,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain2->Length - Domain1->Length) / sizeof(WCHAR);
            return(Above);
        }
        else
        {
            return(NotEqual);
        }

    }
    else if (RtlEqualUnicodeString(Domain1,Domain2, TRUE))
    {
        *PostfixOffset = 0;
        return(Equal);
    }
    else
    {
        return(NotEqual);
    }
}

//+-----------------------------------------------------------------------
//
// Function:    KdcExpandTranistedRealms
//
// Synopsis:    Expands the transited realm field into an array of realms
//
// Effects:     Allocates an array of realm names
//
// Parameters:  FullRealmList - receives the full list of realms
//              CountOfRealms - receveies the number of entries in the list
//              TranistedList - The transited field to expand
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG RealmCount;
    ULONG Index;
    ULONG RealmIndex;
    PUNICODE_STRING RealmList = NULL;
    UNICODE_STRING CurrentRealm;

    *FullRealmList = NULL;
    *CountOfRealms = 0;

    //
    // First count the number of realms in the tranisted list. We can do
    // this by counting the number of ',' in the list. Note: if the encoding
    // is compressed by using a null entry to include all domains in a path
    // up or down a hierarchy, this code will fail.
    //

    if (TransitedList->Length == 0)
    {
        return(KDC_ERR_NONE);
    }


    RealmCount = 1;
    for (Index = 0; Index < TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        if (TransitedList->Buffer[Index] == ',')
        {
            RealmCount++;

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
        }
    }

    //
    // We now have a the count of realms. Allocate an array of UNICODE_STRING
    // structures to hold the realms.
    //

    RealmList = (PUNICODE_STRING) MIDL_user_allocate(RealmCount * sizeof(UNICODE_STRING));
    if (RealmList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        RealmList,
        RealmCount * sizeof(UNICODE_STRING)
        );



    //
    // Now loop through and insert the full names of all the domains into
    // the list
    //

    RealmIndex = 0;
    CurrentRealm = *TransitedList;
    for (Index = 0; Index <= TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        //
        // If we hit the end of the string or found a ',', split off a
        // new realm.
        //

        if ((Index == TransitedList->Length / sizeof(WCHAR)) ||
            (TransitedList->Buffer[Index] == ',' ))
        {

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997:: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Length = CurrentRealm.MaximumLength =
                (USHORT)(&TransitedList->Buffer[Index] - CurrentRealm.Buffer) * sizeof(WCHAR);

            //
            // Check for a trailing '.' - if so, append it
            // to the parent
            //

            if (TransitedList->Buffer[Index-1] == '.')
            {
                //
                // This is a compressed name, so append it to the previous
                // name
                //
                if (RealmIndex == 0)
                {
                    DebugLog((DEB_ERROR,"First element in transited encoding has a trailing '.': %wZ\n",
                        TransitedList ));
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &RealmList[RealmIndex-1],
                        &CurrentRealm)))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if ((RealmIndex != 0) && (CurrentRealm.Buffer[0] == '/'))
            {
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &CurrentRealm,
                        &RealmList[RealmIndex-1]
                        )))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if (!NT_SUCCESS(KerbDuplicateString(
                    &RealmList[RealmIndex],
                    &CurrentRealm)))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Buffer =CurrentRealm.Buffer + 1 + CurrentRealm.Length/sizeof(WCHAR);
            RealmIndex++;
        }
    }
    DsysAssert(RealmIndex == RealmCount);

    *FullRealmList = RealmList;
    *CountOfRealms = RealmCount;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (RealmList != NULL)
        {
            for (RealmIndex = 0; RealmIndex < RealmCount ; RealmIndex++ )
            {
                KerbFreeString(&RealmList[RealmIndex]);
            }
            MIDL_user_free(RealmList);
        }
    }

    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcCompressTransitedRealms
//
// Synopsis:    Compresses an ordered list of realms by removing
//              redundant information.
//
// Effects:     Allocates an output string
//
// Parameters:  CompressedRealms - receives the compressed list of realms
//              RealmList - List of domains to compress
//              RealmCount - number of entries in realm list
//              NewRealm - new realm to add to the lsit
//              NewRealmIndex - Location before which to insert the new
//                      realm
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcCompressTransitedRealms(
    OUT PUNICODE_STRING CompressedRealms,
    IN PUNICODE_STRING RealmList,
    IN ULONG RealmCount,
    IN PUNICODE_STRING NewRealm,
    IN ULONG NewRealmIndex
    )
{
    UNICODE_STRING OutputRealms = {0};
    ULONG OutputRealmLength = 0;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    ULONG InsertionIndex;
    PWCHAR Where;
    PUNICODE_STRING PreviousName = NULL;
    PUNICODE_STRING CurrentName;
    ULONG PostfixOffset;
    UNICODE_STRING NameToAdd;

    RtlInitUnicodeString(
        CompressedRealms,
        NULL
        );

    //
    // Initialize all variables
    //

    Index = 0;
    CurrentName = NULL;
    InsertionIndex = NewRealmIndex;

    //
    // First, compute the length of compressed output realms
    //

    while (Index <= RealmCount)
    {
        PreviousName = CurrentName;

        //
        // If this is the index to insert, add the new realm
        //

        if (InsertionIndex == Index)
        {
            CurrentName = NewRealm;
        }
        else if (Index == RealmCount)
        {
            //
            // If we already added all the original realms, get out now
            //

            break;
        }
        else
        {
            CurrentName = &RealmList[Index];
        }

        NameToAdd = *CurrentName;

        //
        // If the previous name is above this one, lop off the postfix from
        // this name
        //

        if ((PreviousName != NULL) &&
            KerbCompareDomains(
                PreviousName,
                CurrentName,
                &PostfixOffset
                ) == Above)
        {
            NameToAdd.Length = (USHORT) PostfixOffset * sizeof(WCHAR);
        }

        if ( OutputRealmLength != 0 )
        {
            OutputRealmLength += sizeof( WCHAR );
        }

        OutputRealmLength += NameToAdd.Length;

        //
        // If we inserted the transited realm here, run through the loop
        // again with the same index.
        //

        if (InsertionIndex == Index)
        {
            InsertionIndex = 0xffffffff;
        }
        else
        {
            Index++;
        }
    }

    //
    // Account for the trailing NULL
    //

    OutputRealmLength += sizeof( WCHAR );

    //
    // Output must fit inside a UNICODE_STRING
    //

    if ( OutputRealmLength > MAXUSHORT )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Re-initialize all variables
    //

    Index = 0;
    CurrentName = NULL;
    InsertionIndex = NewRealmIndex;

    SafeAllocaAllocate( OutputRealms.Buffer, OutputRealmLength );

    if ( OutputRealms.Buffer == NULL ) {

        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    OutputRealms.MaximumLength = (USHORT)OutputRealmLength;
    OutputRealms.Length = 0;
    Where = OutputRealms.Buffer;

    //
    // Now, on to actual copying
    //

    while (Index <= RealmCount)
    {
        PreviousName = CurrentName;

        //
        // If this is the index to insert, add the new realm
        //

        if (InsertionIndex == Index)
        {
            CurrentName = NewRealm;
        }
        else if (Index == RealmCount)
        {
            //
            // If we already added all the original realms, get out now
            //

            break;
        }
        else
        {
            CurrentName = &RealmList[Index];
        }

        NameToAdd = *CurrentName;

        //
        // If the previous name is above this one, lop off the postfix from
        // this name
        //

        if ((PreviousName != NULL) &&
            KerbCompareDomains(
                PreviousName,
                CurrentName,
                &PostfixOffset
                ) == Above)
        {
            NameToAdd.Length = (USHORT) PostfixOffset * sizeof(WCHAR);
        }

        if (OutputRealms.Length != 0)
        {
            *Where++ = L',';
            OutputRealms.Length += sizeof(WCHAR);
        }

        DsysAssert(OutputRealms.Length + NameToAdd.Length < OutputRealms.MaximumLength);

        RtlCopyMemory(
            Where,
            NameToAdd.Buffer,
            NameToAdd.Length
            );

        Where += NameToAdd.Length/sizeof(WCHAR);
        OutputRealms.Length = OutputRealms.Length + NameToAdd.Length;

        //
        // If we inserted the transited realm here, run through the loop
        // again with the same index.
        //

        if (InsertionIndex == Index)
        {
            InsertionIndex = 0xffffffff;
        }
        else
        {
            Index++;
        }
    }

    *Where++ = L'\0';

    if (!NT_SUCCESS(KerbDuplicateString(
            CompressedRealms,
            &OutputRealms)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

Cleanup:

    SafeAllocaFree( OutputRealms.Buffer );

    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcInsertTransitedRealm
//
// Synopsis:    Inserts the referree's realm into the tranisted encoding
//              in a ticket. This uses domain-x500-compress which
//              eliminates redundant information when one domain is the
//              prefix or suffix of another.
//
// Effects:     Allocates output buffer
//
// Parameters:  NewTransitedField - receives the new tranisted field, to
//                      be freed with KerbFreeString
//              OldTransitedField - the existing transited frield.
//              ClientRealm - Realm of client (from ticket)
//              TransitedRealm - Realm of referring domain
//              OurRealm - Our realm name
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN PUNICODE_STRING OurRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING FullDomainList = NULL;
    ULONG CountOfDomains;
    ULONG NewEntryIndex = 0xffffffff;
    ULONG PostfixOffset;
    ULONG Index;
    KERB_DOMAIN_COMPARISON Comparison = NotEqual;
    KERB_DOMAIN_COMPARISON LastComparison;

    //
    // The first thing to do is to expand the existing transited field. This
    // is because the compression scheme does not allow new domains to simply
    // append or insert information - the encoding of existing realms
    // can change. For example, going from a domain to its parent means
    // that the original domain can be encoded as a prefix of the parent
    // whereas originally it was a name unto itself.
    //

    D_DebugLog((DEB_T_TRANSIT, "Inserted realm %wZ into list %wZ for client fomr %wZ\n",
        TransitedRealm, OldTransitedField, ClientRealm ));

    KerbErr = KdcExpandTransitedRealms(
                &FullDomainList,
                &CountOfDomains,
                OldTransitedField
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now loop through the domains. Based on the compression, we know that
    // higher up domains come first.
    //

    for (Index = 0; Index < CountOfDomains ; Index++ )
    {
        LastComparison = Comparison;

        Comparison = KerbCompareDomains(
                        TransitedRealm,
                        &FullDomainList[Index],
                        &PostfixOffset
                        );
        if (Comparison == Above)
        {
            //
            // If the new domain is above an existing domain, it gets inserted
            // before the existing domain because all the existing domains
            // are ordered from top to bottom
            //
            NewEntryIndex = Index;
            break;
        }
        else if (Comparison == Below)
        {
            //
            // There may be other domains below which are closer, so
            // store the result and continue.
            //
            LastComparison = Comparison;
        }
        else if (Comparison == NotEqual)
        {
            //
            // The domains aren't above or below each other. If the last
            // comparison was below, stick the domain underneath it.
            //
            if (LastComparison == Below)
            {
                NewEntryIndex = Index;
                break;
            }
        }
    }

    //
    // If we didn't find a place for it, stick it in at the end.
    //

    if (NewEntryIndex == 0xffffffff)
    {
        NewEntryIndex = Index;
    }

    //
    // Now build the new encoding
    //

    KerbErr = KdcCompressTransitedRealms(
                NewTransitedField,
                FullDomainList,
                CountOfDomains,
                TransitedRealm,
                NewEntryIndex
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    if (FullDomainList != NULL)
    {
        for (Index = 0; Index < CountOfDomains ; Index++ )
        {
            KerbFreeString(&FullDomainList[Index]);
        }
        MIDL_user_free(FullDomainList);
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\utest\ticktest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ticktest.cxx
//
//  Contents:   KDC Ticket granting service test code.
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------


#include <secpch2.hxx>
#pragma hdrstop
#include <stdio.h>
#include <authdata.hxx>
#include <kerbcomm.h>
#include <tostring.hxx>
extern "C" {
#include <winsock.h>
#include <kdc.h>
}


#include <kdcsvr.hxx>
#include <tktutil.hxx>


extern PWCHAR pwzKdcPasswd;
extern PWCHAR pwzPSPasswd;
extern PWCHAR pwzRealm;
extern PWCHAR pwzUserName;
extern PWCHAR pwzUserPasswd;
extern PWCHAR pwzTransport;
extern PWCHAR pwzEndPoint;
extern PWCHAR pwzAddress;
extern PWCHAR pwzClientAddress;
extern PWCHAR pwzKDC;
extern PWCHAR pwzPrivSvr;
extern PWCHAR pwzServiceName;

extern DWORD dwUserRID;
extern DWORD dwServiceRID;
extern DWORD dwKdcRID;
extern DWORD dwPrivSvrRID;

extern BOOL fGetAS;
extern BOOL fGetTGS;
extern BOOL fGetPAC;
extern BOOL fGetCTGT;
extern BOOL fGetServiceTkt;
extern BOOL fRenewSvc;
extern BOOL fTestTransitComp;
extern BOOL fTestReferal;
extern BOOL fPrintPACs;
extern BOOL fPrintTickets;
extern BOOL fVerbose;


enum BindTarget {KDC, KDCDBG};
enum CallType {GETTGS, GETAS};

handle_t
BindTo( BindTarget target,
        LPTSTR pszTransport,
        LPTSTR pszEndpoint,
        LPTSTR pszServer );


NTSTATUS
CheckPAData( const KERB_ENCRYPTION_KEY& kSessionKey, PKERB_PA_DATA pkdReply, enum CallType type );


//////////////////////////////////////////////////////////////////////////
//
// Socket client functions
//
//////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSockets
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

#define KERB_KDC_CALL_TIMEOUT           10


void
PrintFlags( const KERB_TICKET_FLAGS fFlags )
{
#define KerbFlagDef(x)      {#x, KERB_TICKET_FLAGS_ ## x}
    const static struct {
        char * FlagName;
        KERB_TICKET_FLAGS  Flag;
        } Flags[] = {
            KerbFlagDef( forwardable ),
            KerbFlagDef( forwarded ),
            KerbFlagDef( proxiable ),
            KerbFlagDef( proxy ),
            KerbFlagDef( may_postdate ),
            KerbFlagDef( postdated ),
            KerbFlagDef( invalid ),
            KerbFlagDef( renewable ),
            KerbFlagDef( initial ),
            KerbFlagDef( pre_authent ),
            KerbFlagDef( hw_authent ),
            KerbFlagDef( reserved )
        };
    const int cFlags = sizeof( Flags ) / sizeof( Flags[0] );

    for (int i=0; i<cFlags; i++)
    {
        if (fFlags & Flags[i].Flag)
        {
            printf("%s,", Flags[i].FlagName );
        }
    }
    printf("\b \n");
#undef KerbFlagDef
}


inline void
Print( const UNICODE_STRING& ssFoo )
{
    printf("%wZ", &ssFoo );
}

void
Print( const LARGE_INTEGER& tsFoo )
{
    UNICODE_STRING ssTime = TimeStampToString( tsFoo );
    printf("%wZ", &ssTime );
    KerbFreeString(&ssTime);
}

void
Print( const KERB_ENCRYPTION_KEY& kKey )
{
    printf("%d,%d,{",kKey.keytype, kKey.keyvalue.length);
    for (ULONG i=0; i<kKey.keyvalue.length; i++ )
    {
        printf("%02x ", kKey.keyvalue.value[i] );
    }
    printf("\b}");
}


void
Print( const PISID psid )
{
    WCHAR Buffer[512];
    UNICODE_STRING usFoo = {0, sizeof(Buffer), Buffer};
    RtlConvertSidToUnicodeString( &usFoo, psid, FALSE );
    printf("%wZ", &usFoo );
}


void
PrintTicket( PKERB_TICKET pktTicket,
             PWCHAR      pwzPasswd )
{
#ifdef notdef
    NTSTATUS               sc;
    PKERB_ENCRYPTED_TICKET pkitTicket;
    PKERB_TICKET pktTicketCopy;
    KERB_ENCRYPTION_KEY             kKey;

    UNICODE_STRING ssFoo;

    RtlInitUnicodeString( &ssFoo, pwzPasswd );

    KerbHashPassword(
        &ssFoo,
        KERB_ETYPE_RC4_MD4,
        &kKey
        );

    pktTicketCopy = (PKerbTicket) new BYTE [sizeof(SizeOfTicket( pktTicket )];
    RtlCopyMemory( pktTicketCopy, pktTicket, SizeOfTicket( pktTicket ) );

    sc = KerbUnpackTicket( pktTicketCopy, &kKey, &kitTicket );
    if (FAILED(sc))
    {
        printf("Couldn't decrypt ticket with password '%ws' (0x%X)\n",
                pwzPasswd, sc );
        return;
    }

    if (kitTicket.dwVersion != 5) {
        printf("\t*** dwVersion: 0x%lX\t\t*** not 5\n", kitTicket.dwVersion );
    } else {
        printf("\tdwVersion:\t%d",kitTicket.dwVersion );
    }
    printf("\n\tFlags: (0x%x):\t",kitTicket.kitEncryptPart.fTicketFlags );
    PrintFlags( kitTicket.kitEncryptPart.fTicketFlags );

    printf("\tInitialTicket:\t" );
    ::Print( kitTicket.gInitialTicket );
    printf("\n\tThisTicket:\t" );
    ::Print( kitTicket.gThisTicket );
    printf("\n\tIssuingRealm: \t" );
    ::Print( kitTicket.dsIssuingRealm );
    printf("\n\tServerName: \t" );
    ::Print( kitTicket.ServerName.accsid );

    printf("\n\tSessionKey: \t" );
    ::Print(kitTicket.kitEncryptPart.kSessionKey);

    printf("\n\tInitialRealm: \t" );
    ::Print( kitTicket.kitEncryptPart.dsInitialRealm );
    printf("\n\tPrincipal: \t" );
    ::Print( kitTicket.kitEncryptPart.Principal.accsid );

    printf("\n\ttsAuthentication:" );
    ::Print( kitTicket.kitEncryptPart.tsAuthentication );
    printf("\n\ttsStartTime:\t" );
    ::Print( kitTicket.kitEncryptPart.tsStartTime );
    printf("\n\ttsEndTime:\t" );
    ::Print( kitTicket.kitEncryptPart.tsEndTime );
    printf("\n\ttsRenewUntil:\t" );
    ::Print( kitTicket.kitEncryptPart.tsRenewUntil );

    printf("\n\tTransited: \t%ws", kitTicket.kitEncryptPart.tdTransited.pwzTransited );
    // printf("\n\tHostAddresses:\t%ws", kitTicket.kitEncryptPart.pkdHostAddresses );
    printf("\n");

    if (kitTicket.kitEncryptPart.pkdAuthorizationData)
    {
        ULONG j;
        BOOL fFoundSomething = FALSE;
        CAuthDataList* padlList = (CAuthDataList*)kitTicket.kitEncryptPart.pkdAuthorizationData->bPAData;
        CAuthData* padData;
        for (padData = padlList->FindFirst(Any);
             padData != NULL;
             padData = padlList->FindNext(padData, Any))
        {
            switch (padData->adtDataType)
            {
#if 0
            case Pac:
                {
                    printf("\tAuthorizationData (PAC):\n");

                    CPAC Pac;
                    ULONG cb = Pac.UnMarshal( (PBYTE) padData->abData );
                    if (cb <= padData->cbData )
                    {
                        if (fPrintPACs)
                            ::Print( Pac );
                        fFoundSomething = TRUE;
                        break;
                    }
                    else
                    {
                        printf("PAC didn't unmarshal correctly");
                    }
                }
#endif
            default:
                printf("\tAuthorizationData (Unknown: %d bytes):",
                       padData->cbData );
                for (j=0; j < padData->cbData; j++ ) {
                    printf("%x ", padData->abData[j] );
                }
                printf("\n" );
            }
        }

        if (!fFoundSomething)
        {
            printf("\tAuthorizationData (%d) : 0x", kitTicket.kitEncryptPart.pkdAuthorizationData->cbPAData );
            for (j=0; j < kitTicket.kitEncryptPart.pkdAuthorizationData->cbPAData; j++ ) {
                printf("%x ", ((PBYTE)kitTicket.kitEncryptPart.pkdAuthorizationData->bPAData)[j] );
            }
            printf("\n" );
        }
    }
#endif
}

int
PrintPAC( PEncryptedData pedPAC,
          PWCHAR         pwzKdcPasswd )
{
#ifdef notdef
    // Decrypt it again to print it out.
    PEncryptedData pedPacCopy =
        (PEncryptedData) new BYTE [ SizeOfEncryptedData( pedPAC ) ];
    memcpy( pedPacCopy, pedPAC, SizeOfEncryptedData( pedPAC ) );

    //
    // Find the PAC in the mess of credentials
    //

    CAuthData * pad = ((CAuthDataList*)pedPacCopy->ctCipher.bMessage)->FindFirst(Pac_2);
    if (pad == NULL)
    {
        printf("GetPAC's return didn't have a PAC in it.");
        return 1;
    }

    PEncryptedData pedRealPac = (PEncryptedData) pad->abData;

    //
    // Get the KDC's key, use it to decrypt pedNewPac
    //
    // Print out the resulting new pac.
    //
    // delete pedNewPac
    //


    NTSTATUS sc;
    UNICODE_STRING ssFoo;
    KERB_ENCRYPTION_KEY kKey;
    SRtlInitString( &ssFoo, pwzKdcPasswd );
    KerbHashPassword(
        &ssFoo,
        KERB_ETYPE_RC4_MD4,
        &kKey
        );

    sc = KIDecryptData(pedRealPac, &kKey );

    if (!NT_SUCCESS(sc))
    {
        printf("Couldn't decrypt PAC second time 0x%X\n", sc );
        return(1);
    }
#endif
    return(0);
}


NTSTATUS
CheckPAData( const KERB_ENCRYPTION_KEY& kSessionKey, PKERB_PA_DATA pkdReply, enum CallType type )
{
#ifdef notdef
    NTSTATUS err = 0;
    TimeStamp tsKdcTime, tsLocalTime, tsDiff;
    CAuthData * pad;
    CAuthDataList * padlList;

    if (pkdReply == 0)
    {
        printf("Nothing in the padata returned.\n");
        return(1);
    }

    //
    // This PAData should contain: Time
    // May contain: address info
    // May contain: old passwords
    //

    padlList = (CAuthDataList*) &pkdReply->bPAData[0];
    if (padlList->GetMaxSize() != pkdReply->cbPAData )
    {
        printf("Sizes are wrong for padata.\n");
        err = -1;
    }

    pad = padlList->FindFirst( Time );
    if (pad == NULL)
    {
        printf("Time not included in padata.");
        err = -1;
    }

    //sc = KIDecryptData( (PEncryptedData) pad->bData, &(KERB_ENCRYPTION_KEY&)kSessionKey );
    //if (FAILED(sc))
    //{
    //    printf("error 0x%X decrypting time.\n", sc );
    //    err = -1;
    //}
    //tsKdcTime = * (PTimeStamp) ((PEncryptedData) pad->abData)->ctCipherText.bMessage;
    tsKdcTime = * (PTimeStamp) pad->abData;
    GetCurrentTimeStamp( &tsLocalTime );
    if (tsKdcTime > tsLocalTime)
        tsDiff = tsKdcTime - tsLocalTime;
    else
        tsDiff = tsLocalTime - tsKdcTime;

    if (tsDiff.QuadPart > UInt32x32To64( 10000000ul, 15 ) )    // 15 seconds.
    {
        printf("Warning: the time at the KDC is " );
        Print( tsDiff );
        printf(" different.\n" );
    }

    //
    // Address info
    //

    //
    // Passwords
    //
#endif
    return(S_OK);
}


KERBERR
FooGetASTicket( IN  PVOID           hBinding,
                IN  PWCHAR          pwzUserName,
                IN  PWCHAR          pwzUserRealm,
                IN  PWCHAR          pwzServiceName,
                IN  PWCHAR          pwzUserPassword,
                IN  PWCHAR          pwzThisWorkstation,
                OUT PKERB_TICKET    pktTicket,
                OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody )

{
    NTSTATUS Status;
    KERBERR KerbErr;
    KERB_ENCRYPTION_KEY kUserKey;
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    PKERB_ENCRYPTED_DATA pedReply = 0;
    PULONG CryptArray = NULL;
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    UNICODE_STRING ssPass;
    UNICODE_STRING ssService;
    UNICODE_STRING ssRealm;
    UNICODE_STRING ssName;
    PKERB_KDC_REPLY Reply = NULL;

    RtlInitUnicodeString( &ssPass, pwzUserPasswd );
    KerbHashPassword(
        &ssPass,
        KERB_ETYPE_RC4_MD4,
        &kUserKey
        );


    RtlZeroMemory(
        &OutputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );

    RtlZeroMemory(
        &InputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );


    RtlInitUnicodeString(
        &ssService,
        pwzServiceName
        );
    RtlInitUnicodeString(
        &ssRealm,
        pwzUserRealm
        );
    RtlInitUnicodeString(
        &ssName,
        pwzUserName
        );

    //
    // Build the request
    //

    RtlZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );

    RequestBody->kdc_options =
                            KERB_KDC_OPTIONS_forwardable |
                            KERB_KDC_OPTIONS_proxiable |
                            KERB_KDC_OPTIONS_renewable |
                            KERB_KDC_OPTIONS_renewable_ok;
    RequestBody->nonce = 3;

    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );


    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    TempTime.QuadPart = 0;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );
    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, NULL );
    CryptArray =  new ULONG [ CryptArraySize ];
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Faield to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // BUGBUG: don't build pre-auth data
    //


    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->server_name,
                    &ssService
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;

    }

    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &ssName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ssRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert unicde string to realm: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_AS_REQ;


    KerbErr = KerbPackKdcRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    Status = KerbCallKdc(
                hBinding,
                &InputMessage,
                &OutputMessage
                );

    KerbErr = (KERBERR) Status;

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",Status);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                &Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &Reply->encrypted_part,
                &kUserKey,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }

#ifdef notdef
    sc = CheckPAData( pkrReply->kSessionKey, pkdReply, GETAS );
    if (FAILED(sc))
    {
        printf("Problem with PAData returned: 0x%X\n", sc );
        return(1);
    }
#endif

    *pktTicket = Reply->ticket;

Cleanup:
    //
    // BUGBUG: memory leak here
    //

    return(KerbErr);
}

KERBERR
FooGetTGSTicket(
    IN  PVOID hBinding,
    IN  PWCHAR pwzUserName,
    IN  PWCHAR pwzUserRealm,
    IN  PWCHAR pwzServiceName,
    IN  PKERB_TICKET pktTGTicket,
    IN  PKERB_ENCRYPTED_KDC_REPLY pkrTGTReply,
    IN  ULONG AuthDataSize,
    IN  PUCHAR AuthData,
    IN BOOLEAN Renew,
    OUT PKERB_TICKET pktTicket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    UNICODE_STRING ssService;
    UNICODE_STRING UserName;
    UNICODE_STRING UserRealm;
    KERBERR KerbErr;
    KERB_PA_DATA_LIST  PaData;
    PULONG CryptArray = NULL;
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKERB_KDC_REPLY Reply = NULL;
    KERB_ENCRYPTED_DATA EncAuthData;

    RtlZeroMemory(
        &EncAuthData,
        sizeof(KERB_ENCRYPTED_DATA)
        );

    RtlInitUnicodeString(
        &ssService,
        pwzServiceName
        );

    RtlInitUnicodeString(
        &UserName,
        pwzUserName
        );
    RtlInitUnicodeString(
        &UserRealm,
        pwzUserRealm
        );

    //
    // Build the request
    //

    RtlZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );
    RequestBody->kdc_options = KERB_KDC_OPTIONS_forwardable |
                          KERB_KDC_OPTIONS_proxiable |
                          KERB_KDC_OPTIONS_renewable |
                          KERB_KDC_OPTIONS_renewable_ok;

    if (Renew)
    {
        RequestBody->kdc_options |= KERB_KDC_OPTIONS_renew;
    }
    RequestBody->nonce = 4;

    //
    // Build an AP request inside an encrypted data structure.
    //

    PaData.next = NULL;
    PaData.value.preauth_data_type = PA_TGS_REQ;

    KerbErr = KerbCreateApRequest(
                &UserName,
                &UserRealm,
                &pkrTGTReply->session_key,
                5,                              // nonce
                pktTGTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                (PULONG) &PaData.value.preauth_data.length,
                &PaData.value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.KERB_KDC_REQUEST_preauth_data = &PaData;
    Request.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, NULL );
    CryptArray =  new ULONG [ CryptArraySize ];
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Faield to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                    &UserName
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &UserRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->server_name,
                &ssService
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );

    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;


    TempTime.LowPart  = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    if (ARGUMENT_PRESENT(AuthData))
    {
        ULONG EncryptionOverhead;

        KerbErr = KerbGetEncryptionOverhead(
                    pktTGTicket->encrypted_part.encryption_type,
                    &EncryptionOverhead,
                    NULL // BUGBUG
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get encryption overhead: 0x%x\n",KerbErr);
            goto Cleanup;
        }
        EncAuthData.cipher_text.length = AuthDataSize + EncryptionOverhead;
        EncAuthData.cipher_text.value = (PUCHAR) MIDL_user_allocate(EncAuthData.cipher_text.length);
        if (EncAuthData.cipher_text.value == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        KerbErr = KerbEncryptData(
                    &EncAuthData,
                    AuthDataSize,
                    AuthData,
                    pktTGTicket->encrypted_part.encryption_type,
                    &pkrTGTReply->session_key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to encrypt pac auth data: 0x%x\n",KerbErr);
            goto Cleanup;
        }


        RequestBody->enc_authorization_data = EncAuthData;
        RequestBody->bit_mask |= enc_authorization_data_present;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGS_REQ;


    KerbErr = KerbPackKdcRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Get the ticket.
    //

    OutputMessage.Buffer = NULL;
    OutputMessage.BufferSize = 0;
    KerbErr = (KERBERR) KerbCallKdc(
                            hBinding,
                            &InputMessage,
                            &OutputMessage
                            );


    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                &Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &Reply->encrypted_part,
                &pkrTGTReply->session_key,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }

#ifdef notdef
    sc = CheckPAData( pkrReply->kSessionKey, pkdReply, GETAS );
    if (FAILED(sc))
    {
        printf("Problem with PAData returned: 0x%X\n", sc );
        return(1);
    }
#endif

    *pktTicket = Reply->ticket;

Cleanup:

    if (EncAuthData.cipher_text.value != NULL)
    {
        MIDL_user_free(EncAuthData.cipher_text.value);
    }
    return(KerbErr);
}


KERBERR
FooGetPAC(
    PVOID hBinding,
    LPWSTR pwzUserName,
    LPWSTR pwzUserRealm,
    PKERB_TICKET PrivSvrTicket,
    PKERB_ENCRYPTED_KDC_REPLY PrivSvrReply,
    PULONG AuthDataSize,
    PUCHAR * PackedAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING UserName;
    UNICODE_STRING UserRealm;
    KERB_MESSAGE_BUFFER RequestMessage;
    KERB_MESSAGE_BUFFER ReplyMessage;
    PKERB_ENCRYPTED_DATA EncryptedPacMessage = NULL;

    ReplyMessage.Buffer = NULL;
    ReplyMessage.BufferSize = 0;

    RtlInitUnicodeString(
        &UserName,
        pwzUserName
        );
    RtlInitUnicodeString(
        &UserRealm,
        pwzUserRealm
        );

    KerbErr = KerbCreateApRequest(
                &UserName,
                &UserRealm,
                &PrivSvrReply->session_key,
                6,                              // nonce
                PrivSvrTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request for PAC: 0x%x\n",KerbErr);
        goto Cleanup;
    }

#ifdef notdef
    KerbErr = (KERBERR) GetPAC(
                hBinding,
                &RequestMessage,
                &ReplyMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to get pac : 0x%x\n",KerbErr);
        goto Cleanup;
    }
#endif
    //
    // Now decode pac
    //

    //
    // First unpack message into an encrypted data structure
    //

    KerbErr = KerbUnpackEncryptedData(
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                &EncryptedPacMessage
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack enc pac data: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Now decrypt into a packed authorization data
    //

    *PackedAuthData = (PUCHAR) MIDL_user_allocate(EncryptedPacMessage->cipher_text.length);
    if (*PackedAuthData == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbDecryptData(
                EncryptedPacMessage,
                &PrivSvrReply->session_key,
                AuthDataSize,
                *PackedAuthData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to decrypt pac auth data: 0x%x\n",KerbErr);
        goto Cleanup;
    }


Cleanup:
    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
    }
    if (EncryptedPacMessage != NULL)
    {
        MIDL_user_free(EncryptedPacMessage);
    }
    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
    }
    return(KerbErr);

}


KERBERR
FooCheckTicket(
    LPWSTR pwzUserName,
    LPWSTR pwzUserRealm,
    LPWSTR pwzServiceName,
    LPWSTR pwzServicePassword,
    PKERB_TICKET ServiceTicket,
    PKERB_ENCRYPTED_KDC_REPLY ServiceReply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING UserName;
    UNICODE_STRING UserRealm;
    UNICODE_STRING ServiceName;
    UNICODE_STRING ServicePassword;
    ULONG AuthDataSize;
    ULONG ApRequestSize;
    PUCHAR ApRequestMessage = NULL;
    PKERB_AP_REQUEST ApRequest = NULL;
    KERB_ENCRYPTION_KEY  ServiceKey;
    LARGE_INTEGER tsFudgeFactor;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    KERB_ENCRYPTION_KEY SessionKey;
    BOOLEAN UseSubKey;

    tsFudgeFactor.QuadPart = 300 * (LONGLONG) 10000000;
    CAuthenticatorList Authenticators( tsFudgeFactor );

    if (!NT_SUCCESS(Authenticators->Init())
    {
        return KERB_ERR_GENERIC;
    }

    RtlInitUnicodeString(
        &UserName,
        pwzUserName
        );
    RtlInitUnicodeString(
        &UserRealm,
        pwzUserRealm
        );

    RtlInitUnicodeString(
        &ServiceName,
        pwzServiceName
        );

    RtlInitUnicodeString(
        &ServicePassword,
        pwzServicePassword
        );

    KerbErr = KerbHashPassword(
                &ServicePassword,
                KERB_ETYPE_RC4_MD4,
                &ServiceKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbCreateApRequest(
                &UserName,
                &UserRealm,
                &ServiceReply->session_key,
                7,                              // nonce
                ServiceTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                &ApRequestSize,
                &ApRequestMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request for PAC: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackApRequest(
                ApRequestMessage,
                ApRequestSize,
                &ApRequest
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack ap request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbCheckTicket(
                &ApRequest->ticket,
                &ApRequest->authenticator,
                &ServiceKey,
                Authenticators,
                &tsFudgeFactor,
                &ServiceName,
                &EncryptPart,
                &Authenticator,
                &SessionKey,
                &UseSubKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to check ticket: 0x%x\n",KerbErr);
        goto Cleanup;
    }

Cleanup:
    if (ApRequest != NULL)
    {
        MIDL_user_free(ApRequest);
    }
    KerbFreeTicket(EncryptPart);
    KerbFreeAuthenticator(Authenticator);
    if (ApRequestMessage != NULL)
    {
        MIDL_user_free(ApRequestMessage);
    }
    return(KerbErr);

}

int
TicketTests()
{
    int ret = 0;

    ULONG cbAuthen = 0;
    NTSTATUS   sc;
    WCHAR ServiceName[100];
    UNICODE_STRING KdcName;
    PVOID SocketHandle = NULL;

    wcscpy(
        ServiceName,
        pwzRealm
        );
    wcscat(ServiceName,L"\\");
    wcscat(ServiceName,pwzUserName);

    sc = KerbInitializeSockets(
            0x0101,
            5
            );
    if (!NT_SUCCESS(sc))
    {
        printf("Failed to initialize sockets: 0x%x\n",sc);
        return((int) sc);
    }

    RtlInitUnicodeString(
        &KdcName,
        pwzAddress
        );

    sc = KerbBindSocket(
            &KdcName,
            &SocketHandle
            );

    if (!NT_SUCCESS(sc))
    {
        printf("KerbSocketBind failed: %0x%x\n",sc);
        return((int) sc);
    }
    __try
    {
        KERB_TICKET         ktASTicket;
        KERB_TICKET         ktPSTicket;
        KERB_TICKET         ktCTGTicket;
        KERB_TICKET         ktServTicket;
        KERB_TICKET         ktRenewServTicket;
        PKERB_ENCRYPTED_KDC_REPLY        pkrASReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrPSReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrCTGTReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrServReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrRenewServReply = NULL;
        ULONG AuthDataSize = 0;
        PUCHAR AuthData = NULL;
        LARGE_INTEGER tsPing;
        KERBERR KerbErr;
        ULONG               PingFlags = 0;

        handle_t hKDC = BindTo( KDC, pwzTransport, pwzEndPoint, pwzAddress );
        if (hKDC == 0 || hKDC == (handle_t)-1 )
        {
            printf("Error binding, quitting.\n" );
            ret = (1);
            goto Done;
        }

        sc = KDCPing( hKDC, &PingFlags, &tsPing );
        if (sc != 0)
        {
            printf("Error %d (0x%X) from KdcPing()\n", sc );
            ret = (1);
            goto Done;
        }

        if (fGetAS)
        {
            KerbErr = FooGetASTicket(
                            SocketHandle,
                            pwzUserName,
                            pwzRealm,
                            pwzKDC,
                            pwzUserPasswd,
                            pwzClientAddress,
                            &ktASTicket,
                            &pkrASReply );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Done;
            }

            if (fPrintTickets)
            {
                printf("Initial TGT:\n" );
                PrintTicket( &ktASTicket, pwzKdcPasswd );
            }
        }

        if (fGetTGS)
        {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   pwzPrivSvr,        // pwzServiceName
                                   &ktASTicket,       // ktTGTicket
                                   pkrASReply,        // krTGTReply
                                   0,
                                   NULL,              // no authorization
                                   FALSE,               // don't renew
                                   &ktPSTicket,      // ppktTicket
                                   &pkrPSReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Done;
            }

            if (fPrintTickets)
            {
                printf("Ticket to PS:\n" );
                PrintTicket( &ktPSTicket, pwzPSPasswd );
            }
        }
#ifdef notdef
        if (fGetPAC)
        {

            //
            // Get the PAC.
            //

            KerbErr = FooGetPAC(
                        SocketHandle,
                        pwzUserName,
                        pwzRealm,
                        &ktPSTicket,
                        pkrPSReply,
                        &AuthDataSize,
                        &AuthData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                printf("FooGetPAC() == 0x%X\n", KerbErr );
                goto Done;
            }
        }


        if (fGetCTGT)
        {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   pwzKDC,        // pwzServiceName
                                   &ktASTicket,       // ktTGTicket
                                   pkrASReply,        // krTGTReply
                                   AuthDataSize,
                                   AuthData,
                                   FALSE,               // don't renew
                                   &ktCTGTicket,      // ppktTicket
                                   &pkrCTGTReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to get TGT: 0x%x\n",KerbErr);
                goto Done;
            }

        }
#endif // notdef

        if (fGetServiceTkt)  {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   ServiceName,        // pwzServiceName
                                   &ktASTicket,       // ktTGTicket
                                   pkrASReply,        // krTGTReply
                                   0,
                                   NULL,                // no auth data
                                   FALSE,               // don't renew
                                   &ktServTicket,      // ppktTicket
                                   &pkrServReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Faield to get ticket to service: 0x%x\n",KerbErr);
                goto Done;
            }

            //
            // Now check the ticket.
            //

            KerbErr = FooCheckTicket(
                        pwzUserName,
                        pwzRealm,
                        ServiceName,            // service name
                        pwzUserPasswd,  /// service password
                        &ktServTicket,
                        pkrServReply
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed tocheck service ticket: 0x%x\n",KerbErr);
                goto Done;
            }

        }
        if (fRenewSvc)
        {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   ServiceName,        // pwzServiceName
                                   &ktServTicket,       // ktTGTicket
                                   pkrServReply,        // krTGTReply
                                   0,
                                   NULL,                // no auth data
                                   TRUE,
                                   &ktRenewServTicket,      // ppktTicket
                                   &pkrRenewServReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Faield to get ticket to service: 0x%x\n",KerbErr);
                goto Done;
            }

            //
            // Now check the ticket.
            //

            KerbErr = FooCheckTicket(
                        pwzUserName,
                        pwzRealm,
                        ServiceName,            // service name
                        pwzUserPasswd,  /// service password
                        &ktServTicket,
                        pkrServReply
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed tocheck service ticket: 0x%x\n",KerbErr);
                goto Done;
            }
        }

Done:
        ;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        printf("Exception 0x%x (%d) in ticktest.\n", GetExceptionCode(), GetExceptionCode() );
        ret = 5;
    }

    if (SocketHandle != NULL)
    {
        closesocket((SOCKET) SocketHandle);
    }
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\utest\prcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       prcache.cxx
//
//  Contents:   Principal cache handling code
//
//  Classes:    CPrincipalHandler
//
//  History:    4-02-93   WadeR   Created
//              04-Nov-93   WadeR   Updated to hold CLogonAccounts
//              08-Nov-93   WadeR   Removed altogether in favour of Account.dll caching.  Sigh.
//
//  Notes:      This is the principal cache code.
//
// When you first call GetASTicket, it passes in a flag indicating a logon is
// in progress.  This flag migrates to the created cache entry, and is passed
// out in the TicketInfo when you call GetTicketInfo().
//
// When you call TGSTicket with a PAC, it checks the flag.  If it's set, it
// calls LogonComplete(success).
//
// LogonComplete will clear the flag, and delete the entry from the cache.
//
// When the cache is full and another entry is needed the first pass looks for
// an entry that is not in the middle of a login.  If it finds one, then that
// is released, and used.  If it can't find one, it finds the oldest logon
// pending, and calls LogonComplete(fail) on it, and uses it.
//
// If ClearCache() attempts to remove an entry with a non-zero use count
// (indicating that someone has called GetLogonInfo and not ReleaseLogonInfo),
// that entry is tagged as invalid and left alone.  Once the use count goes
// down to zero, it will be discarded.
//
//  BUGBUG:     Need some form of notification from the Account code to
//              tell me that an account changed.  Also, need to defer
//              re-loading it if it's in use.
//
//  BUGBUG:    Should change Win4Assert to SafeAssert or ASSERT().
//
//  BUGBUG:    Should remove PrintSizes();
//
//----------------------------------------------------------------------------



// Get the common, global header files.
#include <secpch2.hxx>
#pragma hdrstop

// Place any local #includes files here.

#include "secdata.hxx"
#include <princpl.hxx>
#include <prcache.hxx>


///////////////////////////////////////////////////////////////
//
//
// Global data
//

CPrincipalHandler PrincipalCache;

const PWCHAR pwcKdcPrincipal = L"\\KDC";
const PWCHAR pwcPSPrincipal = L"\\PrivSvr";


// Constants to control cache size.  The cache will start out being
// CACHE_INITIALSIZE bytes (rounded down to a multiple of sizeof(CacheEntry)).
//
// When the cache needs to grow, it will grow by CACHE_GROW bytes (also
// rounded down).  When it is CACHE_SHRINK_THRESHOLD bytes larger than needed,
// it will shrink to become the minumum size needed plus CACHE_SHRINK bytes.
//
// Caveats:
//
// If CACHE_GROW > CACHE_SHRINK_THRESHOLD, every time the cache grows it will
// shrink again.  If CACHE_SHRINK >= CACHE_SHRINK_THRESHOLD, the cache will
// shrink over and over again, without changing size.  Finally, If
// CACHE_SHRINK_THRESHOLD < CACHE_INITIALSIZE then the cache will shrink on
// startup (which is not a smart thing to do).
//
// I suggest that CACHE_SHRINK_THRESHOLD >= 2 * CACHE_SHRINK
//                CACHE_SHRINK_THRESHOLD >= 2 * CACHE_GROW
//                CACHE_SHRINK_THRESHOLD >  CACHE_INITIALSIZE
//                          CACHE_SHRINK ~= CACHE_GROW
//
// Currently, sizeof( CacheEntry ) == 24 bytes.


#if 0
#define CACHE_INITIALSIZE       1024
#define CACHE_GROW               512
#define CACHE_SHRINK_THRESHOLD  1536
#define CACHE_SHRINK             512
#else
#pragma MEMO( Really tiny cache sizes for testing )
#define CACHE_INITIALSIZE       50
#define CACHE_GROW              25
#define CACHE_SHRINK_THRESHOLD  75
#define CACHE_SHRINK            25
#endif

//
// Flags for fCacheFlags.
//
// Note that CACHE_DOING_LOGON (flag for fCacheFlags) has the same value as
// DOING_LOGON (flag for TicketInfo::LogonSteps).
//
#define CACHE_DOING_LOGON       DOING_LOGON
#define CACHE_STICKY            0x00010000
#define CACHE_INVALID           0x00080000


//
// Helper functinons (only used by this file).
//


#define PrintSizes()  KdcDebug(( DEB_T_CACHE, "Line %d: cCache=%d, cMaxCacheSize=%d\n", \
                                            __LINE__, _cCache, _cCacheMaxSize ))


//+---------------------------------------------------------------------------
//
//  Function:   MapNameDRN
//
//  Synopsis:   Maps a name to a domain relative name
//
//  Effects:    may orphan memory (indicated by an error message)
//
//  Arguments:  [pwzInName] -- Name to map
//
//  Returns:    pointer into string passed in, or new memory.
//
//  History:    14-Sep-93   WadeR   Created
//
//  Notes:
//
//  BUGBUG:     The client should be fixed to NEVER pass in a bogus name,
//              so this should be able to map in place or return an error.
//
//----------------------------------------------------------------------------

static PWCHAR
MapNameDRN( PWCHAR pwzInName )
{
    if (*pwzInName == L'\\')
        return(pwzInName);

    if (wcsnicmp(pwzInName,
                 SecData.KdcRealm()->Buffer,
                 SecData.KdcRealm()->Length / sizeof(WCHAR) ) == 0 )
    {
        // Starts with this domain.
        return(pwzInName + SecData.KdcRealm()->Length / sizeof(WCHAR) );
    }
    ULONG cch = wcslen( awcDOMAIN ) - 1;    // - 1 because don't want the '\'
    if (wcsnicmp( pwzInName, awcDOMAIN, cch ) == 0)
    {
        // Starts with "domain:"
        return(pwzInName + cch);
    }

    KdcDebug(( DEB_WARN, "MapNameDRN(%ws): Don't understand (prepending '\\').\n",
                        pwzInName ));
    KdcDebug(( DEB_WARN, "MapNameDRN: Memory leak.\n" ));

    PWCHAR pwNew = new WCHAR [wcslen(pwzInName) + 2];
    pwNew[0] = '\\';
    pwNew[1] = '\0';
    wcscat( pwNew, pwzInName );

    return(pwNew);
}



//
// Private member functions.
//


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::ReleaseCacheEntry
//
//  Synopsis:   Removes a cache slot, releasing if needed.
//
//  Effects:    May call CLogonAccount::Release()
//
//  Arguments:  [i] -- Slot to release
//
//  Requires:   Caller must have write access to _Monitor
//
//  Returns:    void
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This moves the empty slot to the end.
//
//----------------------------------------------------------------------------

void
CPrincipalHandler::ReleaseCacheEntry( ULONG i )
{
    KdcDebug(( DEB_T_CACHE, "Releasing slot %d.\n", i ));

    if (_Cache[i].plga != NULL)
    {
        _Cache[i].plga->Release();
    }
    if (_Cache[i].pwzName)
    {
        delete _Cache[i].pwzName;
    }

    // Move the empty spot to the end of the array.

    _cCache--;
    Win4Assert( _cCache >= 0 );
    _Cache[i] = _Cache[_cCache];

    // Zero out the new empty spot
    _Cache[_cCache].plga = 0;
    _Cache[_cCache].pwzName = 0;

    PrintSizes();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::Discard
//
//  Synopsis:   Removes a cache entry, completing it's logon if needed.
//
//  Effects:    may call CLogonAccount::LogonComplete()
//
//  Arguments:  [i] -- Slot to discard
//
//  Requires:   Caller must have write access to _Monitor
//
//  Returns:    void
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CPrincipalHandler::Discard( int i )
{
    KdcDebug(( DEB_T_CACHE, "Discarding %ws from cache slot %d%s.\n",
                            _Cache[i].pwzName, i,
                            (_Cache[i].fCacheFlags & CACHE_DOING_LOGON)?
                                " (logon interupted)":
                                "" ));

    // If it's a logon, then mark it as failed.
    // ReleaseCacheEntry will remove the entry, and move the
    // empty spot to the end.

    if (_Cache[i].fCacheFlags & CACHE_DOING_LOGON)
    {
        _Cache[i].plga->LogonComplete( FALSE, (FILETIME*)&tsZero );    // failed logon, no lockout
        _Cache[i].plga->Save(NULL, FALSE);
    }
    ReleaseCacheEntry( i );

    PrintSizes();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GrowCache
//
//  Synopsis:   Grows the principal cache.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Requires:   Caller must have a write lock on the cache.
//
//  Returns:    HRESULT (S_OK or E_OUTOFMEMORY)
//
//  Signals:    none
//
//  Algorithm:  Adds GROW_SIZE bytes to the cache, rounded down to
//              sizeof(CacheElement).
//
//  History:    05-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GrowCache()
{
    SafeAssert( _cCacheMaxSize >= _cCache );

    ULONG cNewSize = (_cCacheMaxSize * sizeof( CacheEntry ) + CACHE_GROW)
                        / sizeof( CacheEntry );

    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GrowCache() %d -> %d\n",
                             _cCacheMaxSize, cNewSize ));

    PrintSizes();

    SafeAssert( cNewSize > _cCache );

    CacheEntry * pNew = new (NullOnFail) CacheEntry [cNewSize];
    if (pNew == NULL)
    {
        KdcDebug(( DEB_ERROR, "Out of memory.\n" ));
        return(E_OUTOFMEMORY);
    }
    RtlCopyMemory( (PBYTE) pNew, (PBYTE) _Cache, _cCache * sizeof( CacheEntry ) );
    delete _Cache;
    _Cache = pNew;
    _cCacheMaxSize = cNewSize;

    PrintSizes();
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::ShrinkCache
//
//  Synopsis:   Shrinks the principal cache, if needed.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Requires:   Caller must have a write lock on the cache.
//
//  Returns:    HRESULT (S_OK or E_OUTOFMEMORY)
//
//  Signals:    none
//
//  Algorithm:  If the cache is SHRINK_THRESHOLD bytes too large, resizes
//              it to be just SHRINK_SIZE bytes bigger than needed, rounded
//              down to sizeof(CacheElement).
//
//  History:    05-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::ShrinkCache()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::ShrinkCache(%d)\n", _cCacheMaxSize ));


    PrintSizes();
    SafeAssert( _cCacheMaxSize >= _cCache );

    if ( (_cCacheMaxSize - _cCache) >
                CACHE_SHRINK_THRESHOLD / sizeof( CacheEntry ) )
    {
        // Need to shrink the cache.
        ULONG cNewSize = (_cCache * sizeof( CacheEntry ) + CACHE_SHRINK)
                            / sizeof( CacheEntry );

        KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::ShrinkCache() %d -> %d\n",
                                 _cCacheMaxSize, cNewSize ));

        SafeAssert( cNewSize > _cCache );

        CacheEntry * pNew = new (NullOnFail) CacheEntry [cNewSize];
        if (pNew == NULL)
        {
            KdcDebug(( DEB_ERROR, "Out of memory.\n" ));
            return(E_OUTOFMEMORY);
        }
        RtlCopyMemory( (PBYTE) pNew, (PBYTE) _Cache, _cCache * sizeof( CacheEntry ) );
        delete _Cache;
        _Cache = pNew;
        _cCacheMaxSize = cNewSize;
    }

    PrintSizes();
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::PurgeSomething
//
//  Synopsis:   Makes at least one entry in the cache free.
//
//  Effects:    May release some cache entries, may grow the cache.
//
//  Arguments:  (none)
//
//  Requires:   _Monitor to be acquired for writing.
//
//  Algorithm:  Deletes the oldest cache element.
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This function guarentees that on return, there is at least
//              one empty cache entry for the caller to use.  To do this,
//              the caller must know that no other thread will think it can
//              use that slot.  Therefore the caller must have write access
//              to the cache.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::PurgeSomething()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::PurgeSomething()\n" ));

    PrintSizes();

    ULONG i;
    TimeStamp tsOldest = tsInfinity;
    ULONG iOldest = 0;

    //
    // First pass, only consider entries that are not part of
    // a logon in progress.
    //

    for (i=0; i<_cCache; i++)
    {
        if (!(_Cache[i].fCacheFlags &
                 (CACHE_DOING_LOGON | CACHE_STICKY)) &&
            (_Cache[i].cUseCount == 0) &&
            (_Cache[i].tsLastUsed < tsOldest))
        {
            iOldest = i;
            tsOldest = _Cache[i].tsLastUsed;
        }
    }

    if (tsOldest == tsInfinity)
    {
        //
        // Didn't find anything that could be removed.
        //

        return GrowCache();
    }

    //
    // We have found the one to boot out.
    //
    // Convert the lock to write before discarding it.  Since we like to leave
    // things the way we found them, convert it back when we're done.
    //

    Discard( iOldest );
    PrintSizes();
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetCacheEntry
//
//  Synopsis:   Finds something in the cache, adding it if needed and if
//              requested.
//
//  Effects:    May call GetLogonAccount to insert in the cache.
//              May remove something from the cache to make room.
//
//  Arguments:  [pwzName]     -- [in] name of principal
//              [piIndex]     -- [out] cache index
//              [fCacheFlags] -- [in] Flags to put in created cache entry
//              [fLoad]       -- [in] if true, load missing entry.
//
//  Signals:    nothing (unless GetLogonAccount throws something).
//
//  Requires:   Caller must have read access to _Monitor
//
//  Returns:    S_OK if in cache, else result of GetLogonAccount()
//              KDC_E_C_PRINCIPAL_UNKNOWN if it isn't in the cache and
//              fLoad == FALSE
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This code is not exception-safe.  If GetLogonAccount throws
//              an exception, it will leak resources.
//
// This routine returns an index into the cache.  This index must remain
// valid, so you can't allow anyone to change the cache while it's in use.
// Therefore the caller must hold a read lock on the cache, and release it
// once the caller is done with the index returned.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GetCacheEntry( PWCHAR pwzName,
                                  PULONG piIndex,
                                  ULONG  fCacheFlags,
                                  BOOL   fLoad )
{
    KdcDebug(( DEB_TRACE, "Looking for account %ws (DRN)\n", pwzName ));

    // Scan through the cache entries looking for this name.

    for (ULONG i=0; i<_cCache; i++ )
    {
        if (!wcsicmp(_Cache[i].pwzName, pwzName ))
        {
            //
            // We found the cache entry we are interested in.
            //

            *piIndex = i;

            //
            // Convert the monitor to write access, so we can modify
            // the last access time.
            //

            _Monitor.ReadToWrite();

            GetCurrentTimeStamp( &_Cache[i].tsLastUsed );

            // Return the monitor and leave.

            _Monitor.WriteToRead();
            return(S_OK);
        }
    }

    // Didn't find it in the cache.

    KdcDebug(( DEB_T_CACHE, "Didn't find %ws in the cache.\n", pwzName ));

    if (!fLoad)
    {
        return(KDC_E_C_PRINCIPAL_UNKNOWN);
    }

    //
    // Build the information that we are going to write to the
    // Cache now, before upgrading to a write lock on the monitor.
    // This way, we keep an exclusive lock for as little time as
    // possible.
    //

    //
    // Copy the name, so it stays valid regardless of what the caller
    // does with it.
    //

    PWCHAR pwzNameCopy = new (NullOnFail) WCHAR [wcslen( pwzName ) + 1];
    if (pwzNameCopy == 0)
    {
        return(E_OUTOFMEMORY);
    }
    wcscpy( pwzNameCopy, pwzName );

    CLogonAccount* plga;

    //
    // Get the account object
    //

    HRESULT hr = GetLogonAccount( pwzName,
                                  TRUE,     // Domain namespace
                                  &plga );
    if (FAILED(hr))
    {
        KdcDebug(( DEB_WARN, "Error finding principal '%ws' (0x%X)\n",
                    pwzName, hr ));
        delete pwzNameCopy;
        return(hr);
    }

    TimeStamp tsNow;
    GetCurrentTimeStamp( &tsNow );

    _Monitor.ReadToWrite();

    if (_cCache == _cCacheMaxSize)
    {
        // Cache is full, so must purge something.
        PurgeSomething();
    }

    //
    // The last entry is free now.
    //
    //
    //  BUGBUG:    PurgeSomething could run out of memory.
    //

    SafeAssert( _cCache < _cCacheMaxSize );

    //
    // Insert the data we constructed before.
    //

    _Cache[_cCache].pwzName = pwzNameCopy;
    _Cache[_cCache].plga = plga;
    _Cache[_cCache].tsLastUsed = tsNow;
    _Cache[_cCache].fCacheFlags = fCacheFlags;

    *piIndex = _cCache;
    _cCache++;

    _Monitor.WriteToRead();

    // Subtract 1 because we've already incremented the count (inside the
    // monitor).

    KdcDebug(( DEB_T_CACHE, "Added %ws in slot %d (flags:%x)\n",
                             _Cache[_cCache-1].pwzName, _cCache-1,
                             _Cache[_cCache-1].fCacheFlags ));

    PrintSizes();
    return(S_OK);
}



//
//
// Public methods
//
//



//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetTicketInfo
//
//  Synopsis:   Gets the ticket-granting info for a principal
//
//  Effects:    Cache lookup.
//
//  Arguments:  [pwzName] -- [in]  Name of principal
//              [pti]     -- [out] ticket info
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This routine is exception-safe.  If any of the routines it
//              calls (GetCacheEntry, CLogonAccount::GetTicketInfo) throw,
//              it will pass the exception up and not leak resources.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GetTicketInfo(  PWCHAR pwzName, TicketInfo* pti )
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GetTicketInfo(%ws)\n",
                                pwzName ));

    SafeAssert( _fInitialized );

    ULONG iIndex;
    PWCHAR pwzDRName = MapNameDRN( pwzName );

    CReadLock lock( _Monitor );

    RET_IF_ERROR( DEB_WARN, GetCacheEntry(pwzDRName, &iIndex, 0) );

    RET_IF_ERROR( DEB_TRACE, _Cache[iIndex].plga->GetTicketInfo(
                                        &(pti->gGuid),
                                        &(pti->kKey),
                                        &(pti->fTicketOpts) ));

    pti->fLogonSteps = _Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON;

    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetLogonInfo
//
//  Synopsis:   Gets the logon info (and ticket info) for a principal
//
//  Effects:    Cache lookup, increments the use count of returned principal
//
//  Arguments:  [pwzName] -- [in] name of principal
//              [pli]     -- [out] logon info
//              [pti]     -- [out] ticket info
//              [phHandle]-- [out] hint for Release, below.
//              [fLogon]  -- [in] true if it's a logon attempt
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This probes the memory returned from
//              CLogonAccount::GetLogonInfo().
//
// This routine will catch any exceptions thrown by it's callees, and return
// and error code without leaking resources.
//
// The caller MUST call ReleaseLogonInfo with the handle returned from this
// call when the logon info is no longer needed.  The cache will not delete
// the logon hours or the valid workstations until ReleaseLogonInfo is called.
//
//----------------------------------------------------------------------------

#define PROBE_R_DWORD( _x_ )      ((void) (*((volatile long *)(_x_))))
#define PROBE_R_CHAR( _x_ )      ((void) (*((volatile char *)(_x_))))

HRESULT
CPrincipalHandler::GetLogonInfo(PWCHAR pwzName,
                                LogonInfo * pli,
                                TicketInfo* pti,
                                PULONG phHandle,
                                BOOL fLogon )
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GetLogonInfo(%ws)\n",
                                pwzName ));
    SafeAssert( _fInitialized );
    HRESULT hr;
    TRY
    {
        CReadLock lock (_Monitor);

        RtlZeroMemory( pli, sizeof( LogonInfo ) );
        RtlZeroMemory( pti, sizeof( TicketInfo ) );

        PWCHAR pwzDRName = MapNameDRN( pwzName );
        ULONG iIndex;

        hr = GetCacheEntry( pwzDRName,
                            &iIndex,
                            fLogon? CACHE_DOING_LOGON : 0);
        if (FAILED(hr))
        {
            KdcDebug(( DEB_TRACE, "GetCacheEntry(%ws)==%x\n",
                                    pwzDRName, hr ));
            goto Error;
        }

        *phHandle = iIndex;

        hr = _Cache[iIndex].plga->GetTicketInfo( &(pti->gGuid),
                                                 &(pti->kKey),
                                                 &(pti->fTicketOpts) );
        if (FAILED(hr))
        {
            KdcDebug(( DEB_TRACE, "GetTicketInfo(%ws)==%x\n",
                                    pwzDRName, hr ));
            goto Error;
        }
        pti->fLogonSteps = _Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON;

        hr = _Cache[iIndex].plga->GetLogonInfo(  &(pli->pbValidLogonHours),
                                                 &(pli->prpwszValidWorkstations),
                                                 &(pli->fInteractive),
                                                 &(pli->fAttributes),
                                                 &(pli->ftAccountExpiry),
                                                 &(pli->ftPasswordChange),
                                                 &(pli->ftLockoutTime) );
        if (FAILED(hr))
        {
            KdcDebug(( DEB_TRACE, "GetLogonInfo(%ws)==%x\n",
                                    pwzDRName, hr ));
            goto Error;
        }

        //
        // Check that the pointers, etc, returned are valid.
        //
        if (pli->pbValidLogonHours)
        {
            PROBE_R_DWORD( pli->pbValidLogonHours );
            PROBE_R_DWORD( pli->pbValidLogonHours->pBlobData );
            PROBE_R_DWORD( pli->pbValidLogonHours->pBlobData +
                                        pli->pbValidLogonHours->cbSize );
#if DBG
            if (KDCInfoLevel & DEB_T_CACHE)
            {
                SECURITY_STRING ss;
                ss = FormatBytes(pli->pbValidLogonHours->pBlobData,
                                 (BYTE) pli->pbValidLogonHours->cbSize );
                KdcDebug(( DEB_T_CACHE, "Valid logon hours (%d): %wZ\n",
                                        pli->pbValidLogonHours->cbSize, &ss ));
                SRtlFreeString( &ss );
            }
#endif
        }

        if (pli->prpwszValidWorkstations)
        {
            PROBE_R_DWORD( pli->prpwszValidWorkstations );
            KdcDebug(( DEB_T_CACHE, "There are %d valid workstations\n",
                                    pli->prpwszValidWorkstations->cElems ));
            for (ULONG i=0; i<pli->prpwszValidWorkstations->cElems; i++ )
            {
                (void) wcslen( pli->prpwszValidWorkstations->pElems[i] );
                KdcDebug(( DEB_T_CACHE, "Valid workstation[%d] = %ws\n",
                        i, pli->prpwszValidWorkstations->pElems[i] ));
            }
        }

        //
        // Bump my read lock up to a write lock, then increment the count.
        // Note that the lock is released at the end of this scope
        // automatically.
        //

        _Monitor.ReadToWrite();
        _Cache[iIndex].cUseCount++;
        _Monitor.WriteToRead();

        hr = S_OK;
Error:
        // Fall out of the TRY/CATCH block.
        ;
    }
    CATCH( CException, e )
    {
        hr = e.GetErrorCode();
        KdcDebug(( DEB_ERROR, "Exception 0x%X getting and checking logon info for %ws\n",
                             hr, pwzName ));
    }
    END_CATCH
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseLogonInfo
//
//  Synopsis:   Allows the cache entry to be deleted.
//
//  Effects:    Decrements the use count
//
//  Arguments:  [pwzName] -- Name of principal
//              [iHandle] -- handle returned from GetLogonInfo
//
//  Returns:    void
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      iHandle is just a hint.  If it has been moved,
//              this will look through the cache for it.
//
//----------------------------------------------------------------------------

void
CPrincipalHandler::ReleaseLogonInfo( PWCHAR pwzName, ULONG iHandle )
{
    SafeAssert( _fInitialized );

    _Monitor.GetRead();

    if ( (iHandle >= _cCache) ||
          wcsicmp( _Cache[iHandle].pwzName, pwzName ) != 0)
    {
        //
        // The cache entry must have been moved.
        //
        // It still has to be in the cache, because it's tagged as in-use.
        // This will be fast, and it must succeed, because it won't have to
        // hit the disk.
        //
#if DBG
        HRESULT hr =
#else
        (void)
#endif
        GetCacheEntry( pwzName, &iHandle, 0, FALSE );   // No flags, don't load
#if DBG
        Win4Assert( SUCCEEDED( hr ) );
#endif
    }

    Win4Assert( _Cache[iHandle].cUseCount > 0 );


    _Monitor.ReadToWrite();
    _Cache[iHandle].cUseCount--;

    // If the CACHE_INVALID bit is set, and the CACHE_DOING_LOGON bit is NOT
    // set, and the use count is zero, then discard it.
    if (((_Cache[iHandle].fCacheFlags & (CACHE_INVALID | CACHE_DOING_LOGON))
            == CACHE_INVALID ) &&
        (_Cache[iHandle].cUseCount == 0) )
    {
        Discard( iHandle );
    }

    _Monitor.Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetPAC
//
//  Synopsis:   Gets the PAC for a principal.
//
//  Effects:    Allocates memory, creates a CPAC
//
//  Arguments:  [pwzName] -- [in] principal to get pac for
//              [ppPAC]   -- [out] pac
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//  BUGBUG:     Need to merge MikeSe's changes, comment better.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GetPAC( PWCHAR pwzName, CPAC ** ppPAC )
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GetPAC(%ws)\n",
                                pwzName ));
    SafeAssert( _fInitialized );
    PWCHAR pwzDRName = MapNameDRN( pwzName );
    SECID           gSID;
    KerbKey         kGarbage;
    ULONG           dwGarbage;
    ULONG           iIndex;

    CReadLock lock(_Monitor);

    RET_IF_ERROR( DEB_WARN, GetCacheEntry(pwzDRName, &iIndex, 0) );     // 0 -> no flags
    RET_IF_ERROR( DEB_WARN, _Cache[iIndex].plga->GetTicketInfo(
                                                    &gSID,
                                                    &kGarbage,
                                                    &dwGarbage ) );
    *ppPAC = new CPAC;
    (*ppPAC)->Init( _Cache[iIndex].plga->GetGroupInfo(),
                    gSID,
                    pwzName,
                    NULL );       // NT Sid.

#if DBG
    // Why would anyone want to get thier PAC if they aren't doing
    // a login?
    if ((_Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON) == 0)
    {
        KdcDebug(( DEB_WARN, "Strange, \"%ws\" fetching a PAC outside login.\n",
                             pwzName ));
    }
#endif
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::LogonComplete
//
//  Synopsis:   Calls LogonComplete on the CLogonAccount, saves it, releases it.
//
//  Effects:    releases memory.
//
//  Arguments:  [pwzName] -- [in] Name of principal who's finished logging on.
//              [fGood]   -- [in] True if it's a successful logon.
//              [ftLock]  -- [in] Account locked out until this time.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This catches any exceptions, and passes back error codes.
//              This should check the CACHE_INVALID bit and, if set, discard
//              the entry.  But, since this always discards the entry it can
//              safely ignore the bit.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::LogonComplete(   PWCHAR pwzName,
                                    BOOL fGood,
                                    FILETIME ftLock )
{
    SafeAssert( _fInitialized );
    HRESULT hr;
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::LogonComplete(%ws)\n",
                                pwzName ));
    TRY
    {
        ULONG iIndex;
        PWCHAR pwzDRName = MapNameDRN( pwzName );

        CReadLock lock(_Monitor);

        hr = GetCacheEntry(pwzDRName, &iIndex, 0);  // no special flags
        if (SUCCEEDED(hr))
        {
            _Monitor.ReadToWrite();

            if ((_Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON) == 0)
            {
                // Oops!  We aged this principal out of the cache already.
                // This means that the principal took so long to log on, we
                // decided that it was a failed logon attempt and we've
                // already marked it as such.  So we'll just ignore this call
                // to LogonComplete.

                KdcDebug(( DEB_ERROR, "Someone called LogonComplete when "
                                      "they weren't logging on!\n" ));
            }
            else
            {
                _Cache[iIndex].plga->LogonComplete( fGood, &ftLock );
                _Cache[iIndex].plga->Save(NULL, FALSE);
            }
            ReleaseCacheEntry( iIndex );
            hr = ShrinkCache();
        }
        else
        {
            KdcDebug(( DEB_WARN, "GetCacheEntry(%ws) failed 0x%x.\n",
                                  pwzDRName, hr ));
        }
    }
    CATCH( CException, e )
    {
        hr = e.GetErrorCode();
        KdcDebug(( DEB_ERROR, "Exception 0x%X in LogonComplete( %ws )\n",
                             hr, pwzName ));
    }
    END_CATCH
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::ClearCache
//
//  Synopsis:   Removes one or more cache entries
//
//  Effects:    May call LogonComplete on some entries.
//
//  Arguments:  [pwzName] -- Name of principal.  If null, clears everything.
//              [fForce]  -- If true, remove everything, even pending logons.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    05-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::ClearCache(PWCHAR pwzName, BOOL fForce)
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::ClearCache(%ws)\n", pwzName ));

    SafeAssert( _fInitialized );

    // Flag to indicate the principal should be reloaded, because it was
    // in the middle of a logon.
    BOOL fReload = FALSE;

    if (pwzName)
    {
        ULONG iIndex;

        // Get a read lock so we can call GetCacheEntry
        _Monitor.GetRead();

        // Get the cache entry, but don't load it if it isn't there.
        if (GetCacheEntry(pwzName, &iIndex, 0, FALSE) == S_OK)
        {
            // It was found in the cache.
            // We are going to change it, either to mark it as invalid or to
            // delete it, so upgrade our lock.
            _Monitor.ReadToWrite();

            // If fForce is true, or the cache entry is in use, we can discard
            // it.  If it's in use, and fForce isn't set, simply mark it as
            // invalid.
            if (fForce || (_Cache[iIndex].cUseCount == 0 ))
            {
                if (_Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON)
                {
                    // This principal was in the process of logging on, so
                    // reload the account (so LogonComplete can succeed),
                    // unless fForce is true (because we don't want it to
                    // reappear).
                    fReload = !fForce;
                }
                ReleaseCacheEntry( iIndex );
            }
            else
            {
                _Cache[iIndex].fCacheFlags |= CACHE_INVALID;
            }

            //
            // If we flushed an account that was in the process of logging on,
            // we should re-load it.
            //
            if (fReload)
            {
                ULONG iFoo;
                _Monitor.WriteToRead();
                (void) GetCacheEntry( pwzName, &iFoo, CACHE_DOING_LOGON );
            }
        }
        _Monitor.Release();
    }
    else
    {
        // Some of the cache entries will be in the middle of a logon.  We
        // must save the names away, so they can be re-loaded later.
        //
        // Since the cache is fixed size, we know the maximim number of names.
        PWCHAR *    apwzNames = new PWCHAR [_cCacheMaxSize];
        ULONG       cNamesUsed = 0;

        // Going to delete everything, so get the lock once up front.

        _Monitor.GetWrite();

        //
        // This loop is a little strange in that both ends move.  The
        // Discard() method will move the empty slot to the end of the cache,
        // and decrement _cCache.  Since it moves a new cache entry to the
        // vacated spot, we don't want to increment the index if we discard
        // something.
        //
        // On the other hand, if we don't discard the entry, we must increment
        // the index to look at the next entry.
        //
        // Every iteration of the loop gets one step closer to finishing,
        // either by raising the index or lowering the max.

        ULONG iIndex = 0;
        while (iIndex < _cCache)
        {
            if (fForce || (_Cache[iIndex].cUseCount == 0 ))
            {
                if (!fForce && _Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON)
                {
                    apwzNames[cNamesUsed++] = _Cache[iIndex].pwzName;
                    _Cache[iIndex].pwzName = 0;     // so it isn't deleted by Discard.
                }
                // This will decrement _cCache
                ReleaseCacheEntry( iIndex );
            }
            else
            {
                _Cache[iIndex].fCacheFlags |= CACHE_INVALID;
                iIndex++;
            }
        }

        //
        // Finished clearing the cache, so re-load the principals that were in
        // the middle of a logon.
        //

        _Monitor.WriteToRead();
        for (iIndex=0; iIndex < cNamesUsed; iIndex++)
        {
            ULONG iFoo;
            (void) GetCacheEntry( apwzNames[iIndex], &iFoo, CACHE_DOING_LOGON);
            delete apwzNames[iIndex];
        }
        delete apwzNames;
        _Monitor.Release();
    }


    if ( !((pwzName == NULL) && fForce) )
    {
        //
        // If we are forcing everything out of the cache, we shouldn't be
        // loading new stuff again.  Otherwise we can count on these being
        // useful.
        //
        // Load the frequently used accounts.
        //
        //

        ULONG iFoo;
        _Monitor.GetRead();
        RET_IF_ERROR( DEB_ERROR, GetCacheEntry( pwcKdcPrincipal, &iFoo, CACHE_STICKY ));
        RET_IF_ERROR( DEB_ERROR, GetCacheEntry( pwcPSPrincipal, &iFoo, CACHE_STICKY ));
        _Monitor.Release();

        //
        // Load the ticket info for the KDC and PS
        //

        TicketInfo tiKDC;
        TicketInfo tiPS;

        RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcKdcPrincipal, &tiKDC ) );
        RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcPSPrincipal, &tiPS ) );

        _Monitor.GetWrite();
        _tiKdc = tiKDC;
        _tiPS = tiPS;
        _Monitor.Release();
    }

    _Monitor.GetWrite();
    HRESULT hr = ShrinkCache();
    _Monitor.Release();
#if DBG
    if (FAILED(hr))
    {
        KdcDebug(( DEB_ERROR, "ShrinkCache() == 0x%x\n", hr ));
    }
#endif
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::AgeCache
//
//  Synopsis:   Removes old entries from the cache.
//
//  Effects:    May release lots of cache slots.
//
//  Arguments:  (none)
//
//  Returns:    S_OK
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::AgeCache()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::AgeCache()\n" ));
    SafeAssert( _fInitialized );

    ULONG i;
    int cRemoved = 0;
    TimeStamp tsCutoff;

    GetCurrentTimeStamp( &tsCutoff );
    tsCutoff = tsCutoff - _tsMaxAge;

    CWriteLock lock( _Monitor );

    for (i=0; i<_cCache; i++)
    {
        if (!(_Cache[i].fCacheFlags & CACHE_STICKY) &&
            (_Cache[i].cUseCount == 0) &&
            (_Cache[i].tsLastUsed < tsCutoff))
        {
            Discard(i);
            cRemoved++;
        }
    }

    HRESULT hr = ShrinkCache();

    KdcDebug(( DEB_T_CACHE, "AgeCache() removed %d\n", cRemoved ));

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::Init
//
//  Synopsis:   Initializes the principal handler
//
//  Effects:    Calls CoInitialize, loads PS and KDC info.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//  BUGBUG:     If this fails, it could leak resources.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::Init()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::Init()\n" ));

    if (_fInitialized)
    {
        Win4Assert( !"CPrincipalHandler::Init() called twice!" );
        return(E_UNEXPECTED);
    }
    RET_IF_ERROR(DEB_ERROR, _sci.Init() );

    _tsMaxAge = tsZero;
    AddSecondsToTimeStamp( &_tsMaxAge, 60 * 60 );       // BUGBUG: magic numbers.

    //
    // Initialize the cache
    //
    _cCache = 0;
    _cCacheMaxSize = CACHE_INITIALSIZE / sizeof( CacheEntry );
    _Cache = new (NullOnFail) CacheEntry [ _cCacheMaxSize ];
    if (_Cache == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    _fInitialized = TRUE;

    // This will load the KDC and PS info.
    RET_IF_ERROR( DEB_ERROR, ClearCache() );

    //
    // Load the ticket info for the KDC and PS
    //

    TicketInfo tiKDC;
    TicketInfo tiPS;

    RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcKdcPrincipal, &tiKDC ) );
    RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcPSPrincipal, &tiPS ) );

    _Monitor.GetWrite();
    _tiKdc = tiKDC;
    _tiPS = tiPS;
    _Monitor.Release();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\klin\klin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsid.c
//
//--------------------------------------------------------------------------

#pragma hdrstop

				   

#include <stdlib.h>
#include <stdio.h>				   
#include <fileno.h>



struct namepair {
    int key;
    char * name;
};

struct namepair dirtbl [] = {
    {DIRNO_CLIENT2, "client2"},
	{DIRNO_COMMON2, "common2"},
    {DIRNO_KERNEL, "kernel"},
    {DIRNO_RTL, "rtl"},
    {DIRNO_SERVER, "server"},
    {0,0}
};

// Please add constants to this table alphabetically by constant, or
// we'll never find the ones we've missed.

struct namepair filetbl [] = {
    {FILENO_BNDCACHE,"bndcache.cxx"},
    {FILENO_CREDAPI,"credapi.cxx"},
    {FILENO_CREDMGR,"credmgr.cxx"},
    {FILENO_CTXTAPI,"ctxtapi.cxx"},
    {FILENO_CTXTMGR,"ctxtmgr.cxx"},
    {FILENO_GSSUTIL,"gssutil.cxx"},
    {FILENO_KERBEROS,"kerberos.cxx"},
    {FILENO_KERBLIST,"kerblist.cxx"},
    {FILENO_KERBPASS,"kerbpass.cxx"},
    {FILENO_KERBTICK,"kerbtick.cxx"},
    {FILENO_KERBWOW,"kerbwow.cxx"},
    {FILENO_KRBEVENT,"krbevent.cxx"},
    {FILENO_KRBTOKEN,"krbtoken.cxx"},
    {FILENO_LOGONAPI,"logonapi.cxx"},
    {FILENO_MISCAPI,"miscapi.cxx"},
    {FILENO_MITUTIL,"mitutil.cxx"},
    {FILENO_PKAUTH,"pkauth.cxx"},
    {FILENO_PROXYAPI,"proxyapi.cxx"},
    {FILENO_RPCUTIL,"rpcutil.cxx"},
    {FILENO_SIDCACHE,"sidcache.cxx"},
    {FILENO_TIMESYNC,"timesync.cxx"},
    {FILENO_TKTCACHE,"tktcache.cxx"},
    {FILENO_TKTLOGON,"tktlogon.cxx"},
    {FILENO_USERAPI,"userapi.cxx"},
    {FILENO_USERLIST,"userlist.cxx"}, // client2
    {FILENO_S4U,"kerbs4u.cxx"}, // client2
    {FILENO_AUTHEN,"authen.cxx"},
    {FILENO_CRYPT,"crypt.c"},
    {FILENO_KEYGEN,"keygen.c"},
    {FILENO_KRB5,"krb5.c"},
    {FILENO_NAMES,"names.c"},
    {FILENO_PASSWD,"passwd.c"},
    {FILENO_RESTRICT,"restrict.c"},
    {FILENO_SOCKETS,"sockets.cxx"},
    {FILENO_TICKETS,"tickets.cxx"}, // Kernel
    {FILENO_CPGSSUTL,"cpgssutl.cxx"},
    {FILENO_CTXTMGR2,"ctxtmgr.cxx"},
    {FILENO_KERBLIST2,"kerblist.cxx"},
    {FILENO_KRNLAPI,"krnlapi.cxx"}, // RTL
    {FILENO_AUTHDATA,"authdata.cxx"}, 
    {FILENO_CRACKPAC,"crackpac.cxx"},
    {FILENO_CRED,"cred.cxx"},
    {FILENO_CREDLIST,"credlist.cxx"},
    {FILENO_CREDLOCK,"credlock.cxx"},
    {FILENO_DBUTIL,"dbutil.cxx"},
    {FILENO_DBOPEN,"dbopen.cxx"},
    {FILENO_DOMCACHE,"domcache.cxx"},
    {FILENO_FILTER,"filter.cxx"},
    {FILENO_MAPERR,"maperr.cxx"},
    {FILENO_MAPSECER,"mapsecer.cxx"},
    {FILENO_MISCID,"miscid.cxx"},
    {FILENO_PAC,"pac.cxx"},
    {FILENO_PAC2, "pac2.cxx"},
    {FILENO_PARMCHK, "parmchk.cxx"},
    {FILENO_REG, "reg.cxx"},
    {FILENO_SECSTR,"secstr.cxx"},
    {FILENO_SERVICES,"services.cxx"},
    {FILENO_STRING,"string.cxx"},
    {FILENO_TIMESERV,"timeserv.cxx"},
    {FILENO_TOKENUTL,"tokenutl.cxx"},
    {FILENO_TRNSPORT,"trnsport.cxx"}, // Server
    {FILENO_DEBUG,"debug.cxx"},
    {FILENO_DGUTIL,"dgutil.cxx"},
    {FILENO_EVENTS,"events.cxx"},
    {FILENO_GETAS,"getas.cxx"},
    {FILENO_GETTGS,"gettgs.cxx"},
    {FILENO_KDC,"kdc.cxx"},
    {FILENO_KDCTRACE,"kdctrace.cxx"},
    {FILENO_KPASSWD,"kpasswd.cxx"},
    {FILENO_NOTIFY2,"notify2.cxx"},
    {FILENO_SRVPAC,"srvpac.cxx"},
    {FILENO_PKSERV,"pkserv.cxx"},
    {FILENO_REFER,"refer.cxx"},
    {FILENO_RPCIF,"rpcif.cxx"},
    {FILENO_SECDATA,"secdata.cxx"},
    {FILENO_SOCKUTIL,"sockutil.cxx"},
    {FILENO_TKTUTIL,"tktutil.cxx"},
    {FILENO_TRANSIT,"transit.cxx"},
	{0, 0}
};




void __cdecl main(int argc, char ** argv)
{
    int line;
    int fileno;
    int dirno;
    int dirfile;
    int i;
    char * stopstring;
    char * dirname;
    char * filename;

    dirname = filename = "huh?";

    if (argc != 2) {
        printf("usage: %s id\n", argv[0]);
        exit(1);
    }

    dirfile = strtol(argv[1], &stopstring, 16);
    if (dirfile == 0) {
        printf("I can't make sense of %s\n", argv[1]);
        exit(1);
    }

    line = dirfile & 0x0000ffff;
    dirno = (dirfile & 0xff000000) >> 24;
    fileno = (dirfile & 0x00ff0000) >> 16;
    dirfile >>= 16;

    for (i=0; dirtbl[i].name; i++) {
        if (dirtbl[i].key == dirno << 8) {
            dirname = dirtbl[i].name;
            break;
        }
    }
    for (i=0; filetbl[i].name; i++) {
        if (filetbl[i].key == dirfile) {
            filename = filetbl[i].name;
            break;
        }
    }

    printf("dir %u, file %u (%s\\%s), line %u\n", dirno, fileno, dirname,
           filename, line);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\kernel\kerbktst.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#include <ntos.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_KERBEROS
#include <security.h>
#include <zwapi.h>

BOOLEAN QuietMode = FALSE;
ULONG DoTests = FALSE;


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    DbgPrint("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            DbgPrint("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            DbgPrint("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            DbgPrint("  %s\n", TextBuffer);
        }

    }

    DbgPrint("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    DbgPrint( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        DbgPrint( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        DbgPrint( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    ULONG NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    DbgPrint( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {

    case SEC_E_NO_SPM:
        DbgPrint( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        DbgPrint( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        DbgPrint( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        DbgPrint( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        DbgPrint( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        DbgPrint( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        DbgPrint( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        DbgPrint( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        DbgPrint( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        DbgPrint( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        DbgPrint( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        DbgPrint( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        DbgPrint( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        DbgPrint( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        DbgPrint( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        DbgPrint( " SEC_E_NOT_SUPPORTED" ); break;


    }

    DbgPrint( "\n" );
}

//+-------------------------------------------------------------------------
//
//  Function:   SecAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SspAlloc(ULONG Flags, ULONG cbMemory)
{
    NTSTATUS scRet;
    PVOID  Buffer = NULL;
    scRet = ZwAllocateVirtualMemory(
                NtCurrentProcess(),
                &Buffer,
                0L,
                &cbMemory,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(scRet))
    {
        return(NULL);
    }
    return(Buffer);
    UNREFERENCED_PARAMETER(Flags);
}



//+-------------------------------------------------------------------------
//
//  Function:   SecFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SspFree(PVOID pvMemory)
{
    ULONG Length = 0;

    (VOID) ZwFreeVirtualMemory(
                 NtCurrentProcess(),
                 &pvMemory,
                 &Length,
                 MEM_RELEASE
                 );
}




VOID
TestSspRoutine(
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ServerCredHandle;
    CredHandle ClientCredentialHandle;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    static int Calls;
    ULONG ClientFlags;
    ULONG ServerFlags;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR TargetName = NULL;
    UNICODE_STRING TargetString;
    UNICODE_STRING PackageName;


    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Names ContextNames;
    SecPkgContext_Lifespan ContextLifespan;
    PSecPkgCredentials_Names CredNames;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    UCHAR    bDataBuffer[20];
    UCHAR    bSigBuffer[100];

    //
    // Allow tests to be disabled
    //


    if (!DoTests)
    {
        return;
    }

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    DomainName = L"makalu";
    UserName = L"mikesw";


    PackageName.Buffer = (LPWSTR) SspAlloc(0,100);
    if (PackageName.Buffer == NULL)
    {
        return;
    }

    wcscpy(
        PackageName.Buffer,
        L"Kerberos"
        );
    RtlInitUnicodeString(
        &PackageName,
        PackageName.Buffer
        );
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    DbgPrint( "PackageCount: %ld\n", PackageCount );
    for (Index = 0; Index < PackageCount ; Index++ )
    {
        DbgPrint( "Package %d:\n",Index);
        DbgPrint( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
        DbgPrint( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
            PackageInfo[Index].fCapabilities,
            PackageInfo[Index].wVersion,
            PackageInfo[Index].wRPCID,
            PackageInfo[Index].cbMaxToken );


    }


#ifdef notdef
    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( &PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        DbgPrint( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        DbgPrint( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }

    FreeContextBuffer(PackageInfo);
#endif

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    &PackageName,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        DbgPrint( "ServerCredHandle: 0x%lx 0x%lx   ",
                ServerCredHandle.dwLower, ServerCredHandle.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Acquire a credential handle for the client side
    //



    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    &PackageName,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ClientCredentialHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        DbgPrint( "ClientCredentialHandle: 0x%lx 0x%lx   ",
                ClientCredentialHandle.dwLower, ClientCredentialHandle.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Query some cred attributes
    //

    CredNames = SspAlloc(0, sizeof(*CredNames));
    if (CredNames == NULL)
    {
        DbgPrint("Failed to allocate CredNames\n");
        return;
    }

    SecStatus = QueryCredentialsAttributes(
                    &ClientCredentialHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QueryCredentialsAttributes (Client) (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    DbgPrint("Client credential names: %ws\n",CredNames->sUserName);
    FreeContextBuffer(CredNames->sUserName);

    //
    // Do the same for the client
    //

    SecStatus = QueryCredentialsAttributes(
                    &ServerCredHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QueryCredentialsAttributes (Server) (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    DbgPrint("Server credential names: %ws\n",CredNames->sUserName);
    FreeContextBuffer(CredNames->sUserName);

    SspFree(CredNames);

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = SspAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        DbgPrint( "Allocate NegotiateMessage failed\n" );
        return;
    }

    ClientFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_MUTUAL_AUTH; //  | ISC_REQ_USE_DCE_STYLE  | ISC_REQ_DATAGRAM; // | ISC_REQ_DELEGATE;

    TargetName = (LPWSTR) SspAlloc(0,100);
    if (TargetName == NULL)
    {
        return;
    }

    wcscpy(
        TargetName,
        DomainName
        );
    wcscat(
        TargetName,
        L"\\"
        );
    wcscat(
        TargetName,
        UserName
        );

    RtlInitUnicodeString(
        &TargetString,
        TargetName
        );

    InitStatus = InitializeSecurityContext(
                    &ClientCredentialHandle,
                    NULL,               // No Client context yet
                    &TargetString,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            DbgPrint( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        DbgPrint( "\n\nNegotiate Message:\n" );

        DbgPrint( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

//        DumpBuffer(  NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }






    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = SspAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        DbgPrint( "Allocate ChallengeMessage failed\n");
        return;
    }
    ServerFlags = 0;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(AcceptStatus) ) {
            DbgPrint( "AcceptSecurityContext (Challenge): " );
            PrintStatus( AcceptStatus );
        }
        if ( !NT_SUCCESS(AcceptStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        DbgPrint( "\n\nChallenge Message:\n" );

        DbgPrint( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

//        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }




    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = SspAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            DbgPrint( "Allocate AuthenticateMessage failed: \n" );
            return;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        NULL,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            DbgPrint( "InitializeSecurityContext (Authenticate): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            DbgPrint( "\n\nAuthenticate Message:\n" );

            DbgPrint( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes );
            PrintTime( "Lifetime: ", Lifetime );

//            DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            0,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( SecStatus != STATUS_SUCCESS ) {
                DbgPrint( "AcceptSecurityContext (Challenge): " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {
                DbgPrint( "\n\nFinal Authentication:\n" );

                DbgPrint( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                        ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );
                DbgPrint(" \n" );
            }
        }

    }



    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_NAMES,
                    &ContextNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QueryContextAttributes (Server) (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    DbgPrint("Server Context names: %ws\n",ContextNames.sUserName);
    FreeContextBuffer(ContextNames.sUserName);


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

#ifdef notdef
    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );
    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    NtClose(Token);

#endif
#ifdef notdef
    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        DbgPrint("\n Signature: \n");
//        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        DbgPrint("\n Signature: \n");
//        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        DbgPrint( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
#endif

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &ServerCredHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &ClientCredentialHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if (PackageInfo != NULL)
    {
        FreeContextBuffer(PackageInfo);
    }

    if (PackageName.Buffer != NULL)
    {
        SspFree(PackageName.Buffer);
    }
    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) SspFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) SspFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) SspFree( AuthenticateBuffer.pvBuffer );
    }

    if (TargetName != NULL)
    {
        SspFree(TargetName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\kdcdiag\godmode.cxx ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}



BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
//  RevertToSelf() must be called to restore original token  
//
//
DWORD
RunAsLocalSystem()
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbrgPIDs / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed! ", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
                hPToken,
                DACL_SECURITY_INFORMATION,
                pSD
                )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

    if (!ImpersonateLoggedOnUser(hDupToken))  {              
        dwErr = GetLastError();
        TERRORVAL(L"ImpersonateLoggedOnUser failed!", dwErr);
        goto ret;
    }   

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}



                    


//
//  LogoffAndRevert()
//
//  This function simply RevertsToSelf(), and then closes the logon token
//
//  Params:
//
//  hToken      -   Logon token from LogonUserW
//
//  Returns:
//  
//  dwErr from last failure, S_OK otherwise.
//
DWORD
LogoffAndRevert(HANDLE                  hToken,
                PSECURITY_DESCRIPTOR    pSD)
{
    
    HANDLE  hThread = INVALID_HANDLE_VALUE;
    DWORD   dwErr = 0;

    //
    //  Verify impersonation, and revert
    //
    if (OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hThread
            )) {

        CloseHandle(hThread);
        RevertToSelf();
    }

    /*if (!SetKernelObjectSecurity(
        hToken,
        DACL_SECURITY_INFORMATION,
        pSD
        )) {
        dwErr = GetLastError();
        TCOMMENT(L"Security was not reset on kernel object!");
    }*/

    return dwErr;
}




 









extern "C"
int __cdecl wmain(int carg, WCHAR* rgwszarg[])
{

    LPWSTR          wszUPN = NULL;
    LPWSTR          wszOldPwd = NULL;
    LPWSTR          wszNewPwd = NULL;

    DATA_BLOB*      arData = NULL;
    DATA_BLOB*      arCipherData = NULL;

    INT             i = 1;
    DWORD           dwErr = S_OK;
    DWORD           dwCleanupErrors = S_OK;
    HANDLE          hToken = INVALID_HANDLE_VALUE;
    HANDLE          hLocalSystem = NULL;
    HANDLE          hProfile = INVALID_HANDLE_VALUE;
    BOOL            fTest = TRUE;

    PSECURITY_DESCRIPTOR    pSD = NULL;

    while (i < carg)  {

        if (!_wcsicmp(rgwszarg[i], L"-?")) {

            Usage();
            return 0;
        }

        if (!_wcsicmp(rgwszarg[i], L"-reset")) {

            ResetTestUser();
            return 0;

        }

        if (!_wcsicmp(rgwszarg[i], L"-create")) {

            CreateTestUser();
            return 0;

        }


        if (!_wcsicmp(rgwszarg[i], L"-user")) {

            if (carg < 4) {
                Usage();
            }

            fTest = TRUE;
        }

       
        i++;

    }

    //
    //  Allocate raw data storage, and fill values
    //
    arData = (DATA_BLOB*) MyAlloc(MAX_BLOBS * sizeof(DATA_BLOB));
    if (arData == NULL) {

        TERRORVAL(L"Alloc Failed!", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
 
    //
    //  Enable debug privilege
    //
    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (TCB) failed!");
        return E_FAIL;
    }


    //
    //  Run as local system
    //
    dwErr = GetLocalSystemToken(&hLocalSystem);
    if (NULL == hLocalSystem || dwErr != S_OK) {
        goto Ret;
    }

  
    dwErr = LogoffAndRevert(hToken, pSD);

    if (NULL != pSD) {
        MyFree(pSD);
        pSD = NULL;
    }
    
    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
        hToken = INVALID_HANDLE_VALUE;
    }


Ret:

    

    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }

    if (NULL != hLocalSystem) {
        RevertToSelf();
        CloseHandle(hLocalSystem);
    }

    if (arData != NULL)
        DataFree(arData, FALSE);

       return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\utest\trantest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transtest.cxx
//
//  Contents:   KDC transit field compression testing code
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------


#include <secpch2.hxx>
#pragma hdrstop

#include "transit.hxx"


void
AddRealm(   PSECURITY_STRING  pssTransit,
            PWCHAR            pwzPrinRealm,
            PWCHAR            pwzThisRealm,
            PWCHAR          pwzNewRealm )
{
    printf("Starting tr field:\t%wZ\nAuth. Realm:\t%ws\n"
           "ThisRealm:\t%ws\nNew Realm:\t%ws\n", pssTransit, pwzPrinRealm,
           pwzThisRealm, pwzNewRealm );

    //CTransitData    tdFoo;
    CNodeList       nlRealms;
    SECURITY_STRING ssTemp;

    //ExpandTransitedField( *pssTransit, pwzPrinRealm, pwzNewRealm, &tdFoo );
    //tdFoo.AddRealm( pwzNewRealm );
    //ssTemp = CompressTransitedField( tdFoo );

    ssTemp = AddToTransitedField( *pssTransit, pwzPrinRealm,
                                  pwzNewRealm, pwzThisRealm, &nlRealms );

    printf("New tr field: %wZ\n\n", &ssTemp );
    SRtlFreeString( pssTransit );
    *pssTransit = ssTemp;
}


int
TransitTest()
{
    printf("Testing transit field compression...\n");
    SECURITY_STRING ssTransit;
    PWCHAR pwAuth;
    PWCHAR pwNew;
    PWCHAR pwThis;

#if 0
    // test 1.
    // No links.

    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg\\sys\\cairo\\sphinx\\dev";
    pwNew  = L"org:\\wpg\\sys\\cairo\\sphinx";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys";
    pwThis = L"org:\\wpg";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg";
    pwThis = L"org:";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:";
    pwThis = L"org:\\fin";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin";
    pwThis = L"org:\\fin\\apps";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps";
    pwThis = L"org:\\fin\\apps\\word";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word";
    pwThis = L"org:\\fin\\apps\\word\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word\\dev";
    pwThis = L"org:\\fin\\apps\\word\\dev\\foo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    printf("Resut of going from 'org:\\wpg\\sys\\cairo\\sphinx\\dev'"
        " to 'org:\\fin\\apps\\word\\dev\\foo' is: '%wZ' (should be ',')\n\n\n",
            &ssTransit);
    SRtlFreeString( &ssTransit );
#endif

#if 1
    // test 2
    // Link between org:\wpg\sys and org:\fin
    //
    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg\\sys\\cairo\\sphinx\\dev";
    pwNew  = L"org:\\wpg\\sys\\cairo\\sphinx";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );


    pwNew  = L"org:\\wpg\\sys";
    pwThis = L"org:\\fin";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin";
    pwThis = L"org:\\fin\\apps";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps";
    pwThis = L"org:\\fin\\apps\\word";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word";
    pwThis = L"org:\\fin\\apps\\word\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word\\dev";
    pwThis = L"org:\\fin\\apps\\word\\dev\\foo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    printf("Resut of going from 'org:\\wpg\\sys\\cairo\\sphinx\\dev'"
           " to 'org:\\fin\\apps\\word\\dev\\foo' is: '%wZ'\n", &ssTransit );
    printf("Should be ',org:\\wpg\\sys,org:\\fin,'");
    SRtlFreeString( &ssTransit );
#endif

#if 1
    // test 2b -- reverse
    // Link between org:\fin and org:\fin\apps\word
    //
    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg\\sys\\cairo\\sphinx\\dev";
    pwNew  = L"org:\\wpg\\sys\\cairo\\sphinx";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys";
    pwThis = L"org:\\wpg";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg";
    pwThis = L"org:";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:";
    pwThis = L"org:\\fin";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );

    pwNew  = L"org:\\fin";
    pwThis = L"org:\\fin\\apps\\word";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word";
    pwThis = L"org:\\fin\\apps\\word\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word\\dev";
    pwThis = L"org:\\fin\\apps\\word\\dev\\foo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    printf("Resut of going from 'org:\\wpg\\sys\\cairo\\sphinx\\dev'"
        " to 'org:\\fin\\apps\\word\\dev\\foo' is: '%wZ' (should be ',')\n\n\n",
            &ssTransit);
    SRtlFreeString( &ssTransit );
#endif

#if 1
    // test 3.
    // Link outside the normal path.
    // org:\wpg -> org:\fin\apps -> org:\wpg\sys\cairo -> org:\wpg\sys\cairo\dev

    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg";
    pwNew  = L"org:\\fin\\apps";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );

    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys\\cairo\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );

    printf("Resut of traversing "
            "'org:\\wpg,org:\\fin\\apps,org:\\wpg\\sys\\cairo,org:\\wpg\\sys\\cairo\\dev'"
            "is: '%wZ'\n", &ssTransit);
    printf("Should be 'org:\\fin\\apps,org:wpg\\sys\\cairo,'" );
    SRtlFreeString( &ssTransit );
#endif

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\logon\sclogon.cxx ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
}
#include <wchar.h>
extern "C" {
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <negossp.h>
#include <wincrypt.h>
#include <cryptui.h>
}
#include <sclogon.h>



BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
#define MAX_RECURSION_DEPTH 1


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = (PBYTE) Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;


    }

    printf( "\n" );
}

VOID
TestGetKdcCert(
    IN LPWSTR ServiceName,
    IN LPWSTR ContainerName,
    IN LPWSTR CaLocation,
    IN LPWSTR CaName
    )
{
    PCCERT_CONTEXT CertContext = NULL;
    DWORD Status = 0;
    WCHAR UsageOid[100];
    WCHAR ComputerName[100];
    ULONG ComputerNameLength = 100;
    LPSTR UsageString;
    CERT_ENHKEY_USAGE KeyUsage;
    CRYPTUI_WIZ_CERT_REQUEST_INFO CertInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW PvkNew;

    RtlZeroMemory(
        &CertInfo,
        sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO)
        );

    RtlZeroMemory(
        &PvkNew,
        sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW)
        );

    GetComputerName(
        ComputerName,
        &ComputerNameLength
        );

    CertInfo.dwSize = sizeof(CertInfo);
    CertInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;
    CertInfo.pwszMachineName = ComputerName;            // local computer
    CertInfo.pwszAccountName = NULL;            // ServiceName;
    CertInfo.pAuthentication = NULL;            // MBZ
    CertInfo.pCertRequestString = NULL;         // ??
    CertInfo.pwszDesStore = ContainerName;
    CertInfo.dwCertOpenStoreFlag = CERT_SYSTEM_STORE_SERVICES;
    CertInfo.pRenewCertContext = NULL;          // we aren't renewing
    CertInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
                                                // generate new key
    CertInfo.pPvkNew = &PvkNew;
    PvkNew.dwSize = sizeof(PvkNew);
    PvkNew.pKeyProvInfo = NULL;                 // use default provider
    PvkNew.dwGenKeyFlags = 0; // CRYPT_MACHINE_KEYSET;                   // no flags
    CertInfo.pwszCALocation = CaLocation;           // ignore for no-ui enrollment
    CertInfo.pwszCAName = CaName;
    CertInfo.dwPostOption = 0; // CRYPTUI_WIZ_CERT_REQUEST_POST_ON_CSP;
    KeyUsage.cUsageIdentifier = 1;
    UsageString = szOID_PKIX_KP_SERVER_AUTH;
    KeyUsage.rgpszUsageIdentifier = &UsageString;
    CertInfo.pKeyUsage = &KeyUsage;

    CertInfo.pwszFriendlyName = NULL;           // friendly name is optional
    CertInfo.pwszDescription = NULL;            // description is optional

    //
    // Request a certificate
    //

    if (!CryptUIWizCertRequest(
            CRYPTUI_WIZ_NO_UI,
            NULL,                       // no window
            NULL,                       // no title
            &CertInfo,
            &CertContext,
            &Status
            ))
    {
        printf("CryptUIWizCertRequest failed: 0x%x\n",GetLastError());
        return;
    }
    //
    // Check the real status
    //

    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED)
    {
        printf("Cert request succeeded!\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR)
    {
        printf("Cert request failed: request error\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED)
    {
        printf("Cert request denied\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY)
    {
        printf("Cert request issued seperately\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION)
    {
        printf("Cert request under submission\n");
    }

    return;
}

VOID
TestScLogonRoutine(
    IN ULONG Count,
    IN LPSTR Pin
    )
{
    NTSTATUS Status;
    PKERB_SMART_CARD_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_SMART_CARD_LOGON);
    BOOLEAN WasEnabled;
    STRING PinString;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_SMART_CARD_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ScHandle = NULL;
    PBYTE ScLogonInfo = NULL;
    ULONG ScLogonInfoSize;
    ULONG WaitResult = 0;
    PCCERT_CONTEXT CertContext = NULL;

    printf("Waiting for smart card insertion\n");

    //
    // First register for insertion notification
    //

    Status = ScHelperInitialize();
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to initialize schelper: 0x%x\n",Status);
        return;
    }

    ScHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ScHandle == NULL)
    {
        printf("Failed to create event: %d\n",GetLastError());
        return;
    }

    Status = ScHelperWatchForSas(
                ScHandle,
                &ScLogonInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to watch for SAS: 0x%x\n",Status);
        return;
    }

    WaitResult = WaitForSingleObject(ScHandle,INFINITE);
    if (WaitResult != WAIT_OBJECT_0)
    {
        printf("Failed to wait for single object: %d\n",GetLastError());
        return;
    }

    //
    // We should now have logon info.
    //

    if (ScLogonInfo == NULL)
    {
        printf("Failed to get logon info!\n");
        return;
    }

    ScLogonInfoSize = ((struct LogonInfo *) ScLogonInfo)->dwLogonInfoLen;

    Status = ScHelperInitializeContext(
                ScLogonInfo,
                ScLogonInfoSize
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to initialize context: 0x%x\n",Status);
        return;
    }

    ScHelperRelease(ScLogonInfo);

    RtlInitString(
        &PinString,
        Pin
        );


    LogonInfoSize += (PinString.Length+1 ) * sizeof(WCHAR) + ScLogonInfoSize;

    LogonInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);

    LogonInfo->MessageType = KerbSmartCardLogon;


    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->Pin.Buffer = (LPWSTR) Where;
    LogonInfo->Pin.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Pin,
        &PinString,
        FALSE
        );
    Where += LogonInfo->Pin.Length + sizeof(WCHAR);

    LogonInfo->CspDataLength = ScLogonInfoSize;
    LogonInfo->CspData = Where;
    RtlCopyMemory(
        LogonInfo->CspData,
        ScLogonInfo,
        ScLogonInfoSize
        );
    Where += ScLogonInfoSize;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    for (Index = 0; Index < Count ; Index++ )
    {
        printf("Logging on with PIN  %s\n",Pin);

        Status = LsaLogonUser(
                    LogonHandle,
                    &Name,
                    Interactive,
                    PackageId,
                    LogonInfo,
                    LogonInfoSize,
                    NULL,           // no token groups
                    &SourceContext,
                    (PVOID *) &Profile,
                    &ProfileSize,
                    &LogonId,
                    &TokenHandle,
                    &Quotas,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("lsalogonuser failed: 0x%x\n",Status);
            return;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
            return;
        }

        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        printf("Username = %ws\n",UserNameString);
        RevertToSelf();
        NtClose(TokenHandle);

        if (Profile->Profile.MessageType = MsV1_0SmartCardProfile)
        {
            CertContext = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            Profile->CertificateData,
                            Profile->CertificateSize
                            );
            if (CertContext == NULL)
            {
                printf("Failed to create cert context: 0x%x\n",GetLastError());
            }
            else
            {
                printf("Built certificate context\n");
                CertFreeCertificateContext( CertContext );
                CertContext = NULL;
            }
        }
        else
        {
            printf("No certificate in profile\n");
        }

        

        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

    }

}


VOID
PrintKdcName(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Index;
    for (Index = 0; Index < Name->NameCount ; Index++ )
    {
        printf(" %wZ ",&Name->Names[Index]);
    }
    printf("\n");
}

VOID
TestCallPackageRoutine(
    IN LPWSTR Function
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    KERB_DEBUG_REQUEST DebugRequest;
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    ULONG Index;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    if (_wcsicmp(Function,L"bp") == 0)
    {
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_REQ_BREAKPOINT;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }

    }
    else if (_wcsicmp(Function,L"tickets")  == 0)
    {
        CacheRequest.MessageType = KerbQueryTicketCacheMessage;
        CacheRequest.LogonId.LowPart = 0;
        CacheRequest.LogonId.HighPart = 0;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    (PVOID *) &CacheResponse,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            printf("Cached Tickets:\n");
            for (Index = 0; Index < CacheResponse->CountOfTickets ; Index++ )
            {
                printf("\tServer: %wZ\n",&CacheResponse->Tickets[Index].ServerName);
                PrintTime("\t\tEnd Time: ",CacheResponse->Tickets[Index].EndTime);
                PrintTime("\t\tRenew Time: ",CacheResponse->Tickets[Index].RenewTime);

            }
        }


    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (CacheResponse != NULL)
    {
        LsaFreeReturnBuffer(CacheResponse);
    }
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations;
    LPSTR Pin;
    LPWSTR PackageFunction;
    ULONG ContextReq = 0;
    WCHAR ContainerName[100];
    WCHAR CaName[100];
    WCHAR CaLocation[100];
    WCHAR ServiceName[100];




    enum {
        NoAction,
#define LOGON_PARAM "/Logon"
#define LOGON_PARAM2 "/Logon:"
        TestLogon,
#define PACKAGE_PARAM "/callpackage:"
        TestPackage,
#define CERT_PARAM "/getcert"
        GetCert,
    } Action = NoAction;





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /ConfigureService
        //

        if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            Iterations = 1;
            if ( _strnicmp( argument, LOGON_PARAM2, sizeof(LOGON_PARAM2)-1 ) == 0 ) {
                sscanf(&argument[sizeof(LOGON_PARAM2)-1], "%d",&Iterations);
            }


            Action = TestLogon;

            if (argc < i + 1)
            {
                goto Usage;
            }
            Pin = argv[++i];
        } else if ( _strnicmp( argument, PACKAGE_PARAM, sizeof(PACKAGE_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(PACKAGE_PARAM)-1];
            PackageFunction = NetpAllocWStrFromStr( argument );

            Action = TestPackage;
        } else if ( _stricmp( argument, CERT_PARAM) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            if (argc < i + 4)
            {
                goto Usage;
            }

            mbstowcs(ServiceName,argv[++i],100);
            mbstowcs(ContainerName,argv[++i],100);
            mbstowcs(CaLocation,argv[++i],100);
            mbstowcs(CaName,argv[++i],100);

            Action = GetCert;
        } else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }


    }

    //
    // Perform the action requested
    //

    switch ( Action ) {

    case TestPackage:
        TestCallPackageRoutine(PackageFunction);
        break;

    case TestLogon :
        TestScLogonRoutine(
            Iterations,
            Pin
            );
        break;
    case GetCert:
        TestGetKdcCert(
            ServiceName,
            ContainerName,
            CaLocation,
            CaName
            );

    }
    return 0;
Usage:
    printf("%s /logon username password [domainname]\n",argv[0]);
    printf("%s /testssp [/package:pacakgename] [/target:targetname] [/user:username] [/serveruser:username]\n",
        argv[0]);
    printf("%s /getcert service-name container-name ca-location ca-name\n",
        argv[0]);
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\rpc\client\kerbcli.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   kerbcli.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "kerbtest.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -d delegation address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -a authn level\n");
    fprintf(stderr, " -s authn service\n");
    fprintf(stderr, " -r recursiion level\n");
    fprintf(stderr, " -x shutdown server\n");
    fprintf(stderr, " -# number of times to call\n");
    fprintf(stderr, " -t target principal\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "30760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszDelegationAddress = NULL;
    unsigned char * pszPrincipal = NULL;
    unsigned char PrincipalBuffer[100];
    ULONG PrincipalLength;
    ULONG AuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    ULONG AuthnService = RPC_C_AUTHN_DCE_PRIVATE;
    ULONG RecursionLevel = 0;
    ULONG LoopCount = 1;
    BOOLEAN ShutdownService = FALSE;
    ULONG i;
    handle_t BindingHandle = NULL;

    // allow the user to override settings with command line switches
    for (i = 1; i < (ULONG) argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'd':  // network address
                pszDelegationAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 't':
                pszPrincipal = argv[++i];
                break;
            case 'a':
                sscanf(argv[++i],"%d",&AuthnLevel);
                break;
            case 's':
                sscanf(argv[++i],"%d",&AuthnService);
                break;
            case 'r':
                sscanf(argv[++i],"%d",&RecursionLevel);
                break;
            case '#':
                sscanf(argv[++i],"%d",&LoopCount);
                break;
            case 'x':
                ShutdownService = TRUE;
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    //
    // If the principal is NULL, get it from the environment
    //

    if (pszPrincipal == NULL)
    {
        LPSTR pszUserRealm;
        LPSTR pszUserName;

        PrincipalBuffer[0] = '\0';

        pszUserRealm = getenv( "USERDOMAIN" );
        pszUserName  = getenv( "USERNAME" );
        if (pszUserRealm != NULL)
        {
            strcpy(PrincipalBuffer, pszUserRealm);
        }
        if ((pszUserRealm != NULL) &&
            (pszUserName != NULL))
        {
            strcat(PrincipalBuffer,"\\");
        }
        if (pszUserName != NULL)
        {
            strcat(PrincipalBuffer,pszUserName);
        }
        pszPrincipal = PrincipalBuffer;

    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(NULL,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned %d\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &BindingHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned %d\n", status);
        exit(2);
    }


    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned %d\n", status);
        exit(2);
    }

    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, pszPrincipal );
    status = RpcBindingSetAuthInfo(
                    BindingHandle,
                    pszPrincipal,
                    AuthnLevel,
                    AuthnService,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //


    RpcTryExcept {
        for (i = 0; i < LoopCount ; i++ )
        {

            status = RemoteCall(
                        BindingHandle,
                        0,                      // no options for now
                        pszDelegationAddress,
                        pszProtocolSequence,
                        pszEndpoint,
                        pszPrincipal,
                        pszNetworkAddress,
                        AuthnLevel,
                        AuthnService,
                        RecursionLevel
                        );
            if (status != 0)
            {
                printf("RemoteCall failed: 0x%x\n",status);
                break;
            }

        }

        if (ShutdownService)
        {
            Shutdown( BindingHandle );
        }
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        printf("Runtime library reported an exception %d\n",
               RpcExceptionCode());

    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the binding handle


    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\scbvt\log.h ===
//
//  log.h
//
//  Copyright (c) Microsoft Corp, 1997
//
//  This file contains the code necessary to log error messages to the event 
//  log of a remote machine (or a local machine, depending on the #defines
//  below).
//
//  Revision History:
//
//  LarryWin	Created		12/15/1997
//

// defines

// target machine
#define SZ_IPC_SHARE        L"\\\\larrywin2\\ipc$"
#define SZ_TARGETMACHINE    L"\\\\larrywin2"
#define SZ_TEST             L"SCLogon"

// event levels
#define PERF_ERROR			EVENTLOG_ERROR_TYPE
#define PERF_WARNING		EVENTLOG_WARNING_TYPE
#define PERF_INFORMATION	EVENTLOG_INFORMATION_TYPE

// function prototypes
void SetEventMachine(LPWSTR*);

void Event(DWORD, LPWSTR, DWORD);

BOOL OpenIPCConnection();

BOOL ErrorToEventLog(DWORD, LPWSTR, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\scbvt\sclogon.cxx ===
/*--

  Copyright (c) 1987-1998  Microsoft Corporation
  
    Module Name:
    
      sclogon.cxx
      
        Abstract:
        
          Test program for Smart Card Logon
          
            Author:
            
              28-Jun-1993 (cliffv)
              
                Environment:
                
                  User mode only.
                  Contains NT-specific code.
                  Requires ANSI C extensions: slash-slash comments, long external names.
                  
                    Revision History:
                    
                      29-Oct-1998 (larrywin)
                      
--*/


//
// Common include files.
//

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <stddef.h>		// 'offset' macro

#include <windows.h>
#include <winnls.h>
#include <iostream.h>
#include <winioctl.h>
#include <tchar.h>
#include <string.h>

}
#include <wchar.h>
#include <conio.h>
#include <ctype.h>

extern "C" {
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <negossp.h>
#include <wincrypt.h>
#include <cryptui.h>
}
#include <sclogon.h>
#include <winscard.h>
#include <log.h>

#define MAX_RECURSION_DEPTH 1
#define BUFFERSIZE 200

BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
LPWSTR g_wszReaderName = new wchar_t[BUFFERSIZE];
// file handle for output file
FILE            *outstream;

/*++

PrintMessage:

    Simple function to dump text to standard output.
	
    Arguments:

    lpszFormat - String to dump to standard output
	
--*/

void _cdecl 
PrintMessage(
    IN LPSTR lpszFormat, ...)
{
    //
    // Helper to do print traces...
    //

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    char szBuffer[512];
    ZeroMemory(szBuffer, sizeof(szBuffer));

    nBuf = _vstprintf(szBuffer, lpszFormat, args);

    _tprintf(szBuffer);
    fprintf(outstream, "%s", szBuffer);

    OutputDebugStringA(szBuffer);
    va_end(args);
}


/*++

  BuildLogonInfo:
  GetReaderName:
  GetCardName:
  GetContainerName:
  GetCSPName:
  
    : Intended for accessing the LogonInformation glob
    
      Author:
      
        Amanda Matlosz
        
          Note:
          
            Some of these are made available to outside callers; see sclogon.h
            
--*/
PBYTE
BuildSCLogonInfo(
                 LPCTSTR szCard,
                 LPCTSTR szReader,
                 LPCTSTR szContainer,
                 LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.
    
    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");
    
    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }
    
    //
    // Build the LogonInfo glob using strings (or empty strings)
    //
    
    DWORD cbLi = offsetof(LogonInfo, bBuffer)
        + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
        + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
        + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
        + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);
    
    if (NULL == pLI)
    {
        return NULL;
    }
    
    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;
    
    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);
    
    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);
    
    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);
    
    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);
    
    //    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}

LPTSTR ErrorString( IN DWORD dwError ) 
{
    DWORD dwLen = 0;
    LPTSTR szErrorString = NULL;

    dwLen = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        (DWORD)dwError,
        LANG_NEUTRAL,
        (LPTSTR)&szErrorString,
        0,
        NULL);

    return szErrorString;
}


HANDLE
FindAndOpenWinlogon(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    NTSTATUS Status ;
    UNICODE_STRING Winlogon ;
    HANDLE Process ;

    SystemInfo = (PSYSTEM_PROCESS_INFORMATION)LocalAlloc( LMEM_FIXED, sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024 );

    if ( !SystemInfo )
    {
        return NULL ;
    }

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                SystemInfo,
                sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
                NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    RtlInitUnicodeString( &Winlogon, L"winlogon.exe" );

    Walk = SystemInfo ;

    while ( RtlCompareUnicodeString( &Walk->ImageName, &Winlogon, TRUE ) != 0 )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        LocalFree( SystemInfo );
        return NULL ;
    }

    Process = OpenProcess( PROCESS_QUERY_INFORMATION,
                           FALSE,
                           HandleToUlong(Walk->UniqueProcessId) );

    LocalFree( SystemInfo );

    return Process ;


}

NTSTATUS
TestScLogonRoutine(
                   IN ULONG Count,
                   IN LPSTR Pin
                   )
{
    NTSTATUS Status;
    PKERB_SMART_CARD_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_SMART_CARD_LOGON);
    BOOLEAN WasEnabled;
    STRING PinString;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ScHandle = NULL;
    PBYTE ScLogonInfo = NULL;
    ULONG ScLogonInfoSize;
    ULONG WaitResult = 0;
    SCARDCONTEXT hContext = NULL;
    LONG lCallReturn = -1;
    LPTSTR szReaders = NULL;
    LPTSTR pchReader = NULL;
    LPTSTR mszCards = NULL;
    LPTSTR szLogonCard = NULL;
    LPTSTR szCSPName = NULL;
    BYTE bSLBAtr[] = {0x3b,0xe2,0x00,0x00,0x40,0x20,0x49,0x06};
    BYTE bGEMAtr[] = {0x3b,0x27,0x00,0x80,0x65,0xa2,0x00,0x01,0x01,0x37};
    DWORD dwReadersLen = SCARD_AUTOALLOCATE;
    DWORD dwCardsLen = SCARD_AUTOALLOCATE;
    DWORD dwCSPLen = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderStates[MAXIMUM_SMARTCARD_READERS]; // not necessarily max for pnp readers
    LONG nIndex;
    LONG nCnReaders;
    BOOL fFound = FALSE;
	SYSTEMTIME StartTime, DoneTime;
	SYSTEMTIME		stElapsed;
	FILETIME		ftStart, ftDone,
		*pftStart = &ftStart,
		*pftDone  = &ftDone;
	LARGE_INTEGER	liStart, liDone,
		*pliStart = &liStart,
		*pliDone  = &liDone;
	LARGE_INTEGER liAccumulatedTime, liSplitTime,
		*pliAccumulatedTime = &liAccumulatedTime,
		*pliSplitTime = &liSplitTime;
	FILETIME ftAccumulatedTime,
		*pftAccumulatedTime   = &ftAccumulatedTime;
	SYSTEMTIME stAccumulatedTime;
	LPWSTR buffer = new wchar_t[BUFFERSIZE];
	int j;
	memset(buffer, 0, BUFFERSIZE);
		
	liAccumulatedTime.QuadPart = 0;
    
    // get a ResMgr context
    lCallReturn = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hContext);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to initialize context: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // list all readers
    lCallReturn = SCardListReaders(hContext, SCARD_ALL_READERS, (LPTSTR)&szReaders, &dwReadersLen);
    if (SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to list readers on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else if ((0 == dwReadersLen)
        || (NULL == szReaders)
        || (0 == *szReaders))
    {
        lCallReturn = SCARD_E_UNKNOWN_READER;   // Or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
		swprintf(buffer, L"Failed to identify a reader on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // list cards
    lCallReturn = SCardListCards(hContext, NULL, NULL, 0, (LPTSTR)&mszCards, &dwCardsLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        printf("Failed to list cards in the system: 0x%x\n", lCallReturn);
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to identify a card on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // use the list of readers to build a readerstate array
    nIndex = 0;
    if (0 != wcslen(g_wszReaderName)) {
        // use the reader specified in the command line
        rgReaderStates[nIndex].szReader = (const unsigned short *)g_wszReaderName;
        rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
        nCnReaders = 1;
    } else {
        pchReader = szReaders;
        while (0 != *pchReader)
        {
            rgReaderStates[nIndex].szReader = pchReader;
            rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
            pchReader += lstrlen(pchReader)+1;
            nIndex++;
            if (MAXIMUM_SMARTCARD_READERS == nIndex)
                break;
        }
        nCnReaders = nIndex;
    }
    
    // find a reader with one of the listed cards, or the specified card, present
    lCallReturn = SCardLocateCards(hContext, mszCards, rgReaderStates, nCnReaders);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to locate a smart card for logon: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // find the reader containing the requested card
    for (nIndex=0; nIndex<nCnReaders && FALSE == fFound; nIndex++) {
        if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_ATRMATCH) {
            // reader found
            fFound = TRUE;
            break;
        }
    }
    if (FALSE == fFound) {
        lCallReturn = SCARD_E_NO_SMARTCARD; // or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"No smart card in any reader: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else { // get the name of the card found
        dwCardsLen = SCARD_AUTOALLOCATE;
        lCallReturn = SCardListCards(hContext, rgReaderStates[nIndex].rgbAtr, NULL, 0, (LPTSTR)&szLogonCard, &dwCardsLen);
        if ( SCARD_S_SUCCESS != lCallReturn ) {
            if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
            if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
            if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
			swprintf(buffer, L"Failed to get name of card in reader: 0x%x\n", lCallReturn);
            PrintMessage("%S",buffer);
			memset(buffer, 0, sizeof(buffer));
            return (NTSTATUS)lCallReturn;
        }
    }
    
    // get the csp provider name for the card
    lCallReturn = SCardGetCardTypeProviderName(hContext, szLogonCard, SCARD_PROVIDER_CSP, (LPTSTR)&szCSPName, &dwCSPLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
        if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
        if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
		swprintf(buffer, L"Failed to locate smart card crypto service provider: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    ScLogonInfo = BuildSCLogonInfo(szLogonCard,
        rgReaderStates[nIndex].szReader,
        TEXT(""), // use default container
        szCSPName
        );
    
    //
    // We should now have logon info.
    //
    if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
    if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
    if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
    if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
    
    j =  swprintf(buffer, L"Reader : %s\n", GetReaderName(ScLogonInfo));
    j += swprintf(buffer + j, L"Card   : %s\n", GetCardName(ScLogonInfo));
    j += swprintf(buffer + j, L"CSP    : %s\n", GetCSPName(ScLogonInfo));
    PrintMessage("%S",buffer);
	memset(buffer, 0, sizeof(buffer));

	// perform sclogon
    if (ScLogonInfo == NULL)
    {
        swprintf(buffer, L"Failed to get logon info!\n");
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS) -1;
    }
    
    ScLogonInfoSize = ((struct LogonInfo *) ScLogonInfo)->dwLogonInfoLen;
    
    Status = ScHelperInitializeContext(
        ScLogonInfo,
        ScLogonInfoSize
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to initialize helper context: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    ScHelperRelease(ScLogonInfo);
    
    RtlInitString(
        &PinString,
        Pin
        );
    
    
    LogonInfoSize += (PinString.Length+1 ) * sizeof(WCHAR) + ScLogonInfoSize;
    
    LogonInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    
    LogonInfo->MessageType = KerbSmartCardLogon;
    
    
    Where = (PUCHAR) (LogonInfo + 1);
    
    LogonInfo->Pin.Buffer = (LPWSTR) Where;
    LogonInfo->Pin.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Pin,
        &PinString,
        FALSE
        );
    Where += LogonInfo->Pin.Length + sizeof(WCHAR);
    
    LogonInfo->CspDataLength = ScLogonInfoSize;
    LogonInfo->CspData = Where;
    RtlCopyMemory(
        LogonInfo->CspData,
        ScLogonInfo,
        ScLogonInfoSize
        );
    Where += ScLogonInfoSize;
    
    //
    // Turn on the TCB privilege
    //
    
    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to adjust privilege: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }

    RtlInitString(
        &Name,
        "SmartCardLogon"
        );
    Status = LsaRegisterLogonProcess(
        &Name,
        &LogonHandle,
        &Dummy
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to register as a logon process: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    strncpy(
        SourceContext.SourceName,
        "SmartCardLogon        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );
    
    
    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
        LogonHandle,
        &Name,
        &PackageId
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to lookup package %Z: 0x%x\n",&Name, Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    //
    // Now call LsaLogonUser
    //
    
    RtlInitString(
        &Name,
        "SmartCardLogon"
        );

    for (Index = 1; Index <= Count ; Index++ )
    {
        swprintf(buffer, L"\nLogon %.6d\n", Index);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

		// get start time
		GetSystemTime(&StartTime);
        
        Status = LsaLogonUser(
            LogonHandle,
            &Name,
            Interactive,
            PackageId,
            LogonInfo,
            LogonInfoSize,
            NULL,           // no token groups
            &SourceContext,
            (PVOID *) &Profile,
            &ProfileSize,
            &LogonId,
            &TokenHandle,
            &Quotas,
            &SubStatus
            );

		// get done time
		GetSystemTime(&DoneTime);

		// convert systemtime to filetime
		SystemTimeToFileTime(&StartTime, &ftStart);
		SystemTimeToFileTime(&DoneTime, &ftDone);
		
		// copy filetime to large int
		CopyMemory(pliStart, pftStart, 8);
		CopyMemory(pliDone, pftDone, 8);
		
		// diff the large ints and accumulate result
		liDone.QuadPart = liDone.QuadPart - liStart.QuadPart;
		liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart + liDone.QuadPart;
		
		// copy result back to filetime
		CopyMemory(pftDone, pliDone, 8);
		
		// convert result back to systemtime
		FileTimeToSystemTime( (CONST FILETIME *)&ftDone, &stElapsed);
		
		// output the result
		swprintf(buffer, L"RunTime:  %2.2ldm:%2.2lds:%3.3ldms\n",
			stElapsed.wMinute,
			stElapsed.wSecond,
			stElapsed.wMilliseconds);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

        if (!NT_SUCCESS(Status))
        {
            j = swprintf(buffer, L"lsalogonuser failed: 0x%x\n",Status);
            LPTSTR szErrorMessage = ErrorString((DWORD)Status);
            if (NULL == szErrorMessage) {
                j += swprintf(buffer + j, L"   ErrorMessage: error message not found, check ntstatus.h\n");
            } else {
                j += swprintf(buffer + j, L"   ErrorMessage: %S\n", szErrorMessage);
            }
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            return (NTSTATUS)Status;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            j = swprintf(buffer, L"LsalogonUser failed: substatus = 0x%x\n",SubStatus);
            LPTSTR szErrorMessage = ErrorString((DWORD)Status);
            if (NULL == szErrorMessage) {
                j += swprintf(buffer + j, L"   ErrorMessage: error message not found, check ntstatus.h\n");
            } else {
                j += swprintf(buffer + j, L"   ErrorMessage: %S", szErrorMessage);
            }
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            return (NTSTATUS)SubStatus;
        }
        
        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        j = swprintf(buffer, L"Result:   %S", ErrorString((DWORD)Status));
        j += swprintf(buffer, L"Username: %ws\n",UserNameString);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        RevertToSelf();
        NtClose(TokenHandle);
        
        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

		// report average every 10th logon
		if (0 == Index % 10) {
			liSplitTime.QuadPart = liAccumulatedTime.QuadPart / Index;
			CopyMemory(pftAccumulatedTime, pliSplitTime, 8);
			FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
			swprintf(buffer, L"\nAverage Time after %d Logons: %2.2ldm:%2.2lds:%3.3ldms\n",
				Index,
				stAccumulatedTime.wMinute,
				stAccumulatedTime.wSecond,
				stAccumulatedTime.wMilliseconds);
            PrintMessage("%S",buffer);
		}

        Sleep(2000); // let card stack unwind
    
    }

	// ouput average results
	if ( 1 != Count ) {
        liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart / Count;
        CopyMemory(pftAccumulatedTime, pliAccumulatedTime, 8);
        FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
        swprintf(buffer, L"\nAverage Logon Time: %2.2ldm:%2.2lds:%3.3ldms\n",
            stAccumulatedTime.wMinute,
            stAccumulatedTime.wSecond,
            stAccumulatedTime.wMilliseconds);
        PrintMessage("%S", buffer);
	}
    return (NTSTATUS)Status;
    
}


VOID
PrintKdcName(
             IN PKERB_INTERNAL_NAME Name
             )
{
    ULONG Index;
    for (Index = 0; Index < Name->NameCount ; Index++ )
    {
        printf(" %wZ ",&Name->Names[Index]);
    }
    printf("\n");
}

int __cdecl
main(
     IN int argc,
     IN char ** argv
     )
     /*++
     
       Routine Description:
       
         Drive the NtLmSsp service
         
           Arguments:
           
             argc - the number of command-line arguments.
             
               argv - an array of pointers to the arguments.
               
                 Return Value:
                 
                   Exit status
                   
                     --*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;
    LPSTR PinBuffer = new char [81];
    LPSTR szReaderBuffer = new char[BUFFERSIZE];
	LPSTR EventMachineBuffer = new char [81];
    LPWSTR wEventMachineBuffer = new wchar_t[81];
    LPWSTR PackageFunction;
    ULONG ContextReq = 0;
    WCHAR ContainerName[100];
    WCHAR CaName[100];
    WCHAR CaLocation[100];
    WCHAR ServiceName[100];
    NTSTATUS Status = -1;
    
    
    enum {
        NoAction,
#define LOGON_PARAM "/p"
            TestLogon,
#define ITERATION_PARAM "/i"
#define HELP_PARAM "/?"
//#define EVENT_PARAM "/s"
#define READER_PARAM "/r"
    } Action = NoAction;

    memset(g_wszReaderName, 0, BUFFERSIZE);
    memset(szReaderBuffer, 0, BUFFERSIZE);

    // open output file
    outstream = fopen( "scardbvt.out", "w" );
    
    //
    // Loop through the arguments handle each in turn
    //
    
    if ( 1 == argc ) {// silent mode
        Iterations = 1;
        Action = TestLogon;
        printf("Enter your pin number: ");
        int ch;
        int j = 0;

        ch = _getch();

        while (ch != 0x0d) {
            j += sprintf(PinBuffer + j,"%c", ch);
            printf("*");
            ch = _getch();
        }

        printf("\n");

    }
    
    for ( i=1; i<argc; i++ ) {
        
        argument = argv[i];
        
        //
        // Handle /ConfigureService
        //
        
        if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Iterations = 1;
            Action = TestLogon;
            
            if (argc <= i + 1) {
                goto Usage;
            }

            PinBuffer = argv[++i];

        } else if ( _strnicmp( argument, ITERATION_PARAM, sizeof(ITERATION_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
            
            Iterations = atoi(argv[++i]);

        } /*else if ( _strnicmp( argument, EVENT_PARAM, sizeof(EVENT_PARAM) - 1 ) == 0 ) {
			if (argc <= i + 1) {
                goto Usage;
            }
			// save name of machine to which events will be posted
            EventMachineBuffer = argv[++i];
			wsprintfW(wEventMachineBuffer, L"%S", EventMachineBuffer);
            SetEventMachine(&wEventMachineBuffer);
            //Event(PERF_INFORMATION, L"Trying to set machine name\n", 1);

		} */
        
          else if ( _strnicmp( argument, HELP_PARAM, sizeof(HELP_PARAM) - 1 ) == 0 ) {
            goto Usage;
		} else if ( _strnicmp( argument, READER_PARAM, sizeof(READER_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
			// get the name of a specified reader
            szReaderBuffer = argv[++i];
            wsprintfW(g_wszReaderName, L"%S", szReaderBuffer);
        } else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }
        
        
    }

    //
    // Perform the action requested
    //
    
    switch ( Action ) {
        
    case TestLogon :
        Status = TestScLogonRoutine(
            Iterations,
            PinBuffer
            );
        break;

    case NoAction :
        goto Usage;
        break;
        
    }
    return Status;
Usage:
    PrintMessage("%s - no parameters, manually enter pin\n", argv[0]);
    PrintMessage("   optional parameters (if any used, must have /p)\n");
    PrintMessage("   /p Pin\n");
    PrintMessage("   /i Iterations\n");
//    printf("   /s EventMachineName (post events to this machine)\n");
    PrintMessage("   /r %cReader Name X%c (registry device name in quotes)\n", '"', '"');
    return -1;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\rpc\server\kerbserv.c ===
/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "kerbtest.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -s authn service\n");
    exit(1);
}

HANDLE TerminateEvent;
ULONG AuthnService = RPC_C_AUTHN_GSS_KERBEROS;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszEndpoint         = "30760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    unsigned char * PrincipalName       = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 's':
                    sscanf(argv[++i],"%d",&AuthnService);
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    printf("Server using protseq %s endpoint %s\n",pszProtocolSequence, pszEndpoint );
    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   3, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(srv_kerbtest_ServerIfHandle, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerInqDefaultPrincName(
                AuthnService,
                &PrincipalName
                );
    if (status)
    {
        printf("RpcServerInqDefaultPrincName returned %d\n",status);
        exit(2);
    }
    status = RpcServerRegisterAuthInfo(
                PrincipalName,
                AuthnService,
                NULL,
                NULL
                );

    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API
MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API
MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

ULONG
RecurseRemoteCall(
    ULONG Options,
    LPSTR RemoteAddress,
    LPSTR RemoteProtocol,
    LPSTR RemoteEndpoint,
    LPSTR Principal,
    LPSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{

    unsigned char * pszStringBinding;
    RPC_STATUS status;
    handle_t BindingHandle;

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(NULL,
                                     RemoteProtocol,
                                     RemoteAddress,
                                     RemoteEndpoint,
                                     NULL,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned %d\n", status);
        return(status);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &BindingHandle);

    RpcStringFree(&pszStringBinding);

    if (status) {

        printf("RpcBindingFromStringBinding returned %d\n", status);
        return(status);
    }


    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, Principal );
    status = RpcBindingSetAuthInfo(
                    BindingHandle,
                    Principal,
                    AuthnLevel,
                    AuthnService,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        return( status );
    }


    //
    // Do the actual RPC calls to the server.
    //


    RpcTryExcept {
        status = RemoteCall(
                    BindingHandle,
                    Options,
                    Address,
                    RemoteProtocol,
                    RemoteEndpoint,
                    Principal,
                    RemoteAddress,
                    AuthnLevel,
                    AuthnService,
                    RecursionLevel
                    );
        if (status != 0)
        {
            printf("RemoteCall failed: 0x%x\n",status);
        }

    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        printf("Runtime library reported an exception %d\n",
               RpcExceptionCode());

    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the binding handle


    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }


}


ULONG
srv_RemoteCall(
    handle_t BindingHandle,
    ULONG Options,
    LPSTR RemoteAddress,
    LPSTR RemoteProtocol,
    LPSTR RemoteEndpoint,
    LPSTR Principal,
    LPSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{
    RPC_STATUS RpcStatus;
    CHAR ClientName[100];
    ULONG NameLen = sizeof(ClientName);

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
        goto Cleanup;
    }
    GetUserName(ClientName,&NameLen);
    printf("Recursion %d: Client called: name = %s\n",RecursionLevel, ClientName);

    if (RecursionLevel != 0)
    {
        RpcStatus = RecurseRemoteCall(
                        Options,
                        RemoteAddress,
                        RemoteProtocol,
                        RemoteEndpoint,
                        Principal,
                        Address,
                        AuthnLevel,
                        AuthnSvc,
                        RecursionLevel - 1
                        );
    }
    RpcRevertToSelf();


Cleanup:


    return(RpcStatus);
}

void
srv_Shutdown(
    handle_t BindingHandle
    )
{
    RPC_STATUS status;

    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\scbvt\log.cpp ===
//
//  log.cpp
//
//  Copyright (c) Microsoft Corp, 1997
//
//  This file contains the code necessary to log error messages to the event 
//  log of a remote machine (or a local machine, depending on the #defines
//  below).
//
//  Revision History:
//
//  Todds		11/13/97    Created
//  LarryWin	12/19/97	Modified to provide more error reporting
//

#include <windows.h>
#include <stdio.h>
#include <winnetwk.h>
#include "log.h"

#pragma warning( disable : 4244) // signed/unsigned mismatch

static BOOL g_IPCInit = FALSE;

// can be defined by calling program; if not defaults to #define in log.h
LPWSTR wszIPC_SHARE     = NULL;
LPWSTR wszTARGETMACHINE = NULL;

void SetEventMachine(LPWSTR* pSZ_IPC_SHARE)
{
    LPWSTR wszTemp = new wchar_t[80];

    wszIPC_SHARE = new wchar_t[100];
    wszTARGETMACHINE = new wchar_t[100];
    memset(wszTemp, 0, sizeof(wszTemp));
    memset(wszIPC_SHARE, 0, sizeof(wszIPC_SHARE));
    memset(wszTARGETMACHINE, 0, sizeof(wszTARGETMACHINE));

    wszIPC_SHARE     = *pSZ_IPC_SHARE;
    wcscpy(wszTARGETMACHINE, wszIPC_SHARE);
    
    wcscpy(wszTemp, L"\\\\");
    wcscat(wszTemp, wszTARGETMACHINE);

    wcscpy(wszTARGETMACHINE, wszTemp);
    wcscpy(wszIPC_SHARE, wszTemp);
    wcscat(wszIPC_SHARE, L"\\ipc$");

}

void Event(DWORD dwEventType,
		   LPWSTR wszErr,
		   DWORD dwErr)
{
	wprintf(L"%s", wszErr);

	if (!g_IPCInit)
		g_IPCInit = OpenIPCConnection();

    if (!g_IPCInit) return; // return if IPC connection not established

	ErrorToEventLog(
		    dwEventType,
			wszErr,
			dwErr
			);

}


//
//  OpenIPCConnection()
//
//  This function opens a \\larrywin1\ipc$ virtual connection to allow logging
//  to the event log of the remote machine.
//
//  Returns:
//  
//  True | False, depending on whether or not IPC connection established.
//
BOOL OpenIPCConnection()
{
	NETRESOURCE IPCConnection;
	DWORD	    dwRet;

    //
    // Set up Net Connection to \\todds7\ipc$
    //
    ZeroMemory(&IPCConnection, sizeof(NETRESOURCE));
    IPCConnection.dwType = RESOURCETYPE_ANY;
    IPCConnection.lpLocalName = NULL; // virtual connection
    if (wszIPC_SHARE != NULL) {
        IPCConnection.lpRemoteName = wszIPC_SHARE;
    } else {
        // get local machine name for share
        IPCConnection.lpRemoteName = SZ_IPC_SHARE;
    }
    IPCConnection.lpProvider = NULL; // use ntlm provider

	//
	//	Try 3 times to establish connection, otherwise  fail
    //
	for (DWORD dwTry = 0;((dwRet != NO_ERROR) && (dwTry < 3)) ; dwTry++)
	{
		dwRet = WNetAddConnection2(
					&IPCConnection,
					NULL,
					NULL,
					0
					);

    }

    if (dwRet != NO_ERROR)  {

        dwRet = GetLastError(); // For debugging
        return FALSE;
    }

    return TRUE;

}



BOOL ErrorToEventLog(DWORD dwEventType,
					 LPWSTR lpszMsg,
					 DWORD	dwErr)
{

	    WCHAR   szMsg[512];
        HANDLE  hEventSource;
        LPWSTR  lpszStrings[2];
        LPWSTR  lpszCRLF = L"\n";

        if (wszTARGETMACHINE != NULL) {
            hEventSource = RegisterEventSourceW(
                wszTARGETMACHINE, 
                SZ_TEST
                );
        } else {
            // get local machine name
            hEventSource = RegisterEventSourceW(
                SZ_TARGETMACHINE, 
                SZ_TEST
                );
        }

        if(hEventSource == NULL)
            return FALSE;

//        wsprintfW(szMsg, L"%s error: %lu", SZ_TEST, dwErr);        
        wsprintfW(szMsg, L": 0x%08x", dwErr);        
        lpszStrings[0] = lpszMsg;
        lpszStrings[1] = szMsg;

        ReportEventW(hEventSource,			// handle of event source
                     dwEventType,			// event type
                     0,			            // event category
                     dwErr,                 // event ID
                     NULL,					// current user's SID
                     2,						// strings in lpszStrings
                     0,						// no bytes of raw data
                     (LPCWSTR*)lpszStrings,	// array of error strings
                     NULL					// no raw data
                     );               

        (VOID) DeregisterEventSource(hEventSource);


        OutputDebugStringW(lpszMsg);
        OutputDebugStringW(szMsg);
        OutputDebugStringW(lpszCRLF);

		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\ssp\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

  
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE

#include "krbprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <wincrypt.h>
#include <kerbdefs.h>
#include <kerblist.h>
#include <negossp.h>
#include <kerbcli.h>
#include <lm.h>
#include <malloc.h>
#include <alloca.h>


BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DumpToken = FALSE;
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
ULONG MaxRecursionDepth = 1;

#define STRING_OR_NULL(_x_) (((_x_) != NULL) ? (_x_) : L"<null>")
#define STRING_OR_NULLA(_x_) (((_x_) != NULL) ? (_x_) : "<null>")

#define RTN_ERROR           13


char * ImpLevels[] = {"Anonymous", "Identification", "Impersonation", "Delegation"};
#define ImpLevel(x) ((x < (sizeof(ImpLevels) / sizeof(char *))) ? ImpLevels[x] : "Illegal!")

#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3




WCHAR *  GetPrivName(PLUID   pPriv)
{
    switch (pPriv->LowPart)
    {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        case SE_UNDOCK_PRIVILEGE:
            return(SE_UNDOCK_NAME);
        case SE_SYNC_AGENT_PRIVILEGE:
            return(SE_SYNC_AGENT_NAME);
        case SE_ENABLE_DELEGATION_PRIVILEGE:
            return(SE_ENABLE_DELEGATION_NAME);
        default:
            return(L"Unknown Privilege");
    }
}


void
DumpLuidAttr(PLUID_AND_ATTRIBUTES   pLA,
             int                    LAType)
{

    printf("0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    printf(" %-32ws", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {
        printf("  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {
            printf("Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {
            printf("Default ");
        }
    }

}



void
LocalDumpSid(PSID    pxSid)
{
    
    UNICODE_STRING  ucsSid;

    RtlConvertSidToUnicodeString(&ucsSid, pxSid, TRUE);
    printf("  %wZ", &ucsSid);
    RtlFreeUnicodeString(&ucsSid);
}




void
DumpSidAttr(PSID_AND_ATTRIBUTES pSA,
            int                 SAType)
{
    LocalDumpSid(pSA->Sid);

    if (SAType == SATYPE_GROUP)
    {
        printf("\tAttributes - ");
        if (pSA->Attributes & SE_GROUP_MANDATORY)
        {
            printf("Mandatory ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            printf("Default ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED)
        {
            printf("Enabled ");
        }
        if (pSA->Attributes & SE_GROUP_OWNER)
        {
            printf("Owner ");
        }
        if (pSA->Attributes & SE_GROUP_LOGON_ID)
        {
            printf("LogonId ");
        }
    }

}

void
PrintToken(HANDLE    hToken)
{
    PTOKEN_USER         pTUser;
    PTOKEN_GROUPS       pTGroups;
    PTOKEN_PRIVILEGES   pTPrivs;
    PTOKEN_PRIMARY_GROUP    pTPrimaryGroup;
    TOKEN_STATISTICS    TStats;
    ULONG               cbRetInfo;
    NTSTATUS            status;
    DWORD               i;
    DWORD               dwSessionId;

    pTUser = (PTOKEN_USER) alloca (256);
    pTGroups = (PTOKEN_GROUPS) alloca (4096);
    pTPrivs = (PTOKEN_PRIVILEGES) alloca (1024);
    pTPrimaryGroup  = (PTOKEN_PRIMARY_GROUP) alloca (128);

    if ( pTUser == NULL ||
         pTGroups == NULL ||
         pTPrivs == NULL ||
         pTPrimaryGroup == NULL ) {

        printf( "Failed to allocate memory\n" );
        return;
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenSessionId,
                                        &dwSessionId,
                                        sizeof(dwSessionId),
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        printf("Failed to query token:  %#x\n", status);
        return;
    }
    printf("TS Session ID: %x\n", dwSessionId);

    status = NtQueryInformationToken(   hToken,
                                        TokenUser,
                                        pTUser,
                                        256,
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        printf("Failed to query token:  %#x\n", status);
        return;
    }

    printf("User\n  ");
    DumpSidAttr(&pTUser->User, SATYPE_USER);

    printf("\nGroups");
    status = NtQueryInformationToken(   hToken,
                                        TokenGroups,
                                        pTGroups,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount ; i++ )
    {
        printf("\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP);
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenPrimaryGroup,
                                        pTPrimaryGroup,
                                        128,
                                        &cbRetInfo);

    printf("\nPrimary Group:\n  ");
    LocalDumpSid(pTPrimaryGroup->PrimaryGroup);

    printf("\nPrivs\n");
    status = NtQueryInformationToken(   hToken,
                                        TokenPrivileges,
                                        pTPrivs,
                                        1024,
                                        &cbRetInfo);
    if (!NT_SUCCESS(status))
    {
        printf("NtQueryInformationToken returned %#x\n", status);
        return;
    }
    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        printf("\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenStatistics,
                                        &TStats,
                                        sizeof(TStats),
                                        &cbRetInfo);

    printf("\n\nAuth ID  %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    printf("Impersonation Level:  %s\n", ImpLevel(TStats.ImpersonationLevel));
    printf("TokenType  %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
}    


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
    if (!NT_SUCCESS( Status )) {
        printf( "Can't convert time from GMT to Local time\n" );
        LocalTime = ConvertTime;
    }

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;


    }

    printf( "\n" );
}

HANDLE
FindAndOpenWinlogon(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    NTSTATUS Status ;
    UNICODE_STRING Winlogon ;
    HANDLE Process ;

    SystemInfo = LocalAlloc( LMEM_FIXED, sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024 );

    if ( !SystemInfo )
    {
        return NULL ;
    }

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                SystemInfo,
                sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
                NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    RtlInitUnicodeString( &Winlogon, L"winlogon.exe" );

    Walk = SystemInfo ;

    while ( RtlCompareUnicodeString( &Walk->ImageName, &Winlogon, TRUE ) != 0 )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        LocalFree( SystemInfo );
        return NULL ;
    }

    Process = OpenProcess( PROCESS_QUERY_INFORMATION,
                           FALSE,
                           HandleToUlong(Walk->UniqueProcessId) );

    LocalFree( SystemInfo );

    return Process ;


}

BOOLEAN
GetCredentialsHandle(
    OUT PCredHandle CredentialsHandle,
    IN LPWSTR PackageName,
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR Password,
    IN ULONG Flags
    )
{
    TimeStamp Lifetime;
    NTSTATUS SecStatus;
    SEC_WINNT_AUTH_IDENTITY_W Identity = {0};
    PSEC_WINNT_AUTH_IDENTITY_W AuthIdentity = NULL;

    if ((UserName != NULL) ||
        (DomainName != NULL) ||
        (Password != NULL))
    {
        Identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        if (UserName != NULL)
        {
            Identity.UserLength = (ULONG) wcslen(UserName);
            Identity.User = UserName;
        }
        if (DomainName != NULL)
        {
            Identity.DomainLength = (ULONG) wcslen(DomainName);
            Identity.Domain = DomainName;
        }
        if (Password != NULL)
        {
            Identity.PasswordLength = (ULONG) wcslen(Password);
            Identity.Password = Password;
        }
        AuthIdentity = &Identity;
    }

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    PackageName,
                    Flags,
                    NULL,
                    AuthIdentity,
                    NULL,
                    NULL,
                    CredentialsHandle,
                    &Lifetime );

    if (!NT_SUCCESS(SecStatus))
    {
        printf("Failed to acquire credentials: 0x%x\n",SecStatus);
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}
VOID
TestQuickISC(
    IN LPWSTR TargetNameU
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    TimeStamp Lifetime;
    TimeStamp CurrentTime;
    TimeStamp stLocal;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    static int Calls;
    ULONG ClientFlags;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBuffer ChallengeBuffer;
    SecBuffer AuthenticateBuffer;
    SecPkgCredentials_Names CredNames;
    LPWSTR PackageName = NEGOSSP_NAME_W;
    
    CredNames.sUserName = NULL;
    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");


    printf("Recursion depth = %d\n",RecursionDepth);
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (Index = 0; Index < PackageCount ; Index++ )
        {
            printf( "Package %d:\n",Index);
            printf( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[Index].fCapabilities,
                    PackageInfo[Index].wVersion,
                    PackageInfo[Index].wRPCID,
                    PackageInfo[Index].cbMaxToken );
        }

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    SecStatus = AcquireCredentialsHandle(
                        NULL,           // New principal
                        PackageName,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &CredentialHandle2,
                        &Lifetime );
    

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);
    }

    


    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY; // USE_DCE_STYLE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_SESSION_KEY; //  | ISC_REQ_DATAGRAM;
    
   InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetNameU,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }




    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    

}

VOID
TestSspRoutine(
    IN LPWSTR PackageName,
    IN LPWSTR UserNameU,
    IN LPWSTR DomainNameU,
    IN LPWSTR PasswordU,
    IN LPWSTR ServerUserNameU,
    IN LPWSTR ServerDomainNameU,
    IN LPWSTR ServerPasswordU,
    IN LPWSTR TargetNameU,
    IN LPWSTR PackageListU,
    IN ULONG ContextReq,
    IN ULONG CredFlags
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    TimeStamp CurrentTime;
    TimeStamp stLocal;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    static int Calls;
    ULONG ClientFlags;
    ULONG ServerFlags;
    BOOLEAN AcquiredServerCred = FALSE;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    WCHAR TargetName[100];
    PSEC_WINNT_AUTH_IDENTITY_EXW AuthIdentity = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W ServerAuthIdentity = NULL;
    PUCHAR Where;
    HANDLE TokenHandle = NULL;
    ULONG CredSize;
    SecBuffer MarshalledContext;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;


    PBYTE pbWholeBuffer;
    ULONG cbWholeBuffer;


    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Flags ContextFlags;
    SecPkgContext_Lifespan ContextLifespan;
    SecPkgContext_DceInfo ContextDceInfo;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;
    SecPkgContext_NativeNames NativeNames;
    SecPkgContext_NativeNamesA NativeNamesA;
    SecPkgCredentials_Names CredNames;
    SecPkgContext_PackageInfo ContextPackageInfo;
    SecPkgContext_KeyInfo KeyInfo = {0};

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[8];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];
    PBYTE pbSealBuffer;
    
    CHAR UserNameA[100];
    CHAR DomainNameA[100];
    CHAR PasswordA[100];


    if (PackageName == NULL)
    {
        PackageName = MICROSOFT_KERBEROS_NAME_W;
    }

    if (!DoAnsi)
    {
        if ((UserNameU != NULL) || (DomainNameU != NULL) || (PasswordU != NULL) || (PackageListU != NULL) || (CredFlags != 0))
        {
            CredSize = (((ULONG) ((UserNameU != NULL) ? wcslen(UserNameU) + 1 : 0) +
                        (ULONG) ((DomainNameU != NULL) ? wcslen(DomainNameU) + 1 : 0) +
                        (ULONG) ((PackageListU != NULL) ? wcslen(PackageListU) + 1 : 0) +
                        (ULONG) ((PasswordU != NULL) ? wcslen(PasswordU) + 1 : 0)) * sizeof(WCHAR)) +
                        (ULONG) sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
            AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW) LocalAlloc(LMEM_ZEROINIT,CredSize);
            if (NULL == AuthIdentity)
            {
                printf( "Failed : Allocation of AuthIdentity\n" );
                return;
            }
           
            AuthIdentity->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
            Where = (PUCHAR) (AuthIdentity + 1);

            if (UserNameU != NULL)
            {
                AuthIdentity->UserLength = (ULONG) wcslen(UserNameU);
                AuthIdentity->User = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    UserNameU
                    );
                Where += (wcslen(UserNameU) + 1) * sizeof(WCHAR);
            }

            if (DomainNameU != NULL)
            {
                AuthIdentity->DomainLength = (ULONG) wcslen(DomainNameU);
                AuthIdentity->Domain = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    DomainNameU
                    );
                Where += (wcslen(DomainNameU) + 1) * sizeof(WCHAR);
            }

            if (PasswordU != NULL)
            {
                AuthIdentity->PasswordLength = (ULONG) wcslen(PasswordU);
                AuthIdentity->Password = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    PasswordU
                    );
                Where += (wcslen(PasswordU) + 1) * sizeof(WCHAR);
            }
            AuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | CredFlags;
            if (PackageListU != NULL)
            {
                AuthIdentity->PackageListLength = (ULONG) wcslen(PackageListU);
                AuthIdentity->PackageList = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    PackageListU
                    );
                Where += (wcslen(PackageListU) + 1) * sizeof(WCHAR);
                AuthIdentity->Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
            }

        }
    }
    else
    {
        if ((UserNameU != NULL) || (DomainNameU != NULL) || (PasswordU != NULL) || (PackageListU != NULL))
        {
            PSEC_WINNT_AUTH_IDENTITY_A Identity;
            CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_A);
            Identity = (PSEC_WINNT_AUTH_IDENTITY_A) LocalAlloc(LMEM_ZEROINIT,CredSize);
            if (NULL == Identity)
            {
                printf( "Failed : Allocation of Identity\n" );
                return;
            }

            if (UserNameU != NULL)
            {
                Identity->UserLength = (ULONG) wcslen(UserNameU);
                Identity->User = (unsigned char *) UserNameA;
                wcstombs(UserNameA,UserNameU,100);
            }

            if (DomainNameU != NULL)
            {
                Identity->DomainLength = (ULONG) wcslen(DomainNameU);
                Identity->Domain = (unsigned char *) DomainNameA;
                wcstombs(DomainNameA,DomainNameU,100);
            }

            if (PasswordU != NULL)
            {
                Identity->PasswordLength = (ULONG) wcslen(PasswordU);
                Identity->Password = (unsigned char *) PasswordA;
                wcstombs(PasswordA,PasswordU,100);
            }
            Identity->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW) Identity;
        }
    }


    if ((ServerUserNameU != NULL) || (ServerDomainNameU != NULL) || (ServerPasswordU != NULL))
    {
        CredSize = ((ULONG) ((ServerUserNameU != NULL) ? wcslen(ServerUserNameU) + 1 : 0) +
                    (ULONG) ((ServerDomainNameU != NULL) ? wcslen(ServerDomainNameU) + 1 : 0) +
                    (ULONG) (((ServerPasswordU != NULL) ? wcslen(ServerPasswordU) + 1 : 0))) * sizeof(WCHAR) +
                    (ULONG) sizeof(SEC_WINNT_AUTH_IDENTITY);
        ServerAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) LocalAlloc(LMEM_ZEROINIT,CredSize);
        if (NULL == ServerAuthIdentity)
        {
            printf( "Failed : Allocation of ServerAuthIdentity\n" );
            return;
        }

        Where = (PUCHAR) (ServerAuthIdentity + 1);

        if (ServerUserNameU != NULL)
        {
            ServerAuthIdentity->UserLength = (ULONG) wcslen(ServerUserNameU);
            ServerAuthIdentity->User = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerUserNameU
                );
            Where += (wcslen(ServerUserNameU) + 1) * sizeof(WCHAR);
        }

        if (ServerDomainNameU != NULL)
        {
            ServerAuthIdentity->DomainLength = (ULONG) wcslen(ServerDomainNameU);
            ServerAuthIdentity->Domain = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerDomainNameU
                );
            Where += (wcslen(ServerDomainNameU) + 1) * sizeof(WCHAR);
        }

        if (ServerPasswordU != NULL)
        {
            ServerAuthIdentity->PasswordLength = (ULONG) wcslen(ServerPasswordU);
            ServerAuthIdentity->Password = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerPasswordU
                );
            Where += (wcslen(ServerPasswordU) + 1) * sizeof(WCHAR);
        }
        ServerAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | SEC_WINNT_AUTH_IDENTITY_MARSHALLED;

    }

    CredNames.sUserName = NULL;
    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;


    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");


    printf("Recursion depth = %d\n",RecursionDepth);
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (Index = 0; Index < PackageCount ; Index++ )
        {
            printf( "Package %d:\n",Index);
            printf( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[Index].fCapabilities,
                    PackageInfo[Index].wVersion,
                    PackageInfo[Index].wRPCID,
                    PackageInfo[Index].cbMaxToken );
        }

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //
    if (ServerCredHandle == NULL)
    {

        ServerCredHandle = &ServerCredHandleStorage;
        AcquiredServerCred = TRUE;

        SecStatus = AcquireCredentialsHandle(
                        NULL,
                        PackageName,
                        SECPKG_CRED_INBOUND,
                        NULL,
                        ServerAuthIdentity,
                        NULL,
                        NULL,
                        ServerCredHandle,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "AcquireCredentialsHandle failed: ");
            PrintStatus( SecStatus );
            return;
        }

        if ( !QuietMode ) {
            printf( "ServerCredHandle: 0x%lx 0x%lx   ",
                    ServerCredHandle->dwLower, ServerCredHandle->dwUpper );
            PrintTime( "Lifetime: ", Lifetime );
            GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
            FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
            PrintTime( "Current Time: ", stLocal);
        }

    }

    //
    // Acquire a credential handle for the client side
    //



    if (!DoAnsi)
    {
        SecStatus = AcquireCredentialsHandle(
                        NULL,           // New principal
                        PackageName,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        AuthIdentity,
                        NULL,
                        NULL,
                        &CredentialHandle2,
                        &Lifetime );
    }
    else
    {
        CHAR AnsiPackageName[100];
        wcstombs(AnsiPackageName, PackageName, 100);
        SecStatus = AcquireCredentialsHandleA(
                        NULL,           // New principal
                        AnsiPackageName,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        AuthIdentity,
                        NULL,
                        NULL,
                        &CredentialHandle2,
                        &Lifetime );

    }

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);
    }

    //
    // Query some cred attributes
    //

    SecStatus = QueryCredentialsAttributes(
                    &CredentialHandle2,
                    SECPKG_CRED_ATTR_NAMES,
                    &CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryCredentialsAttributes (Client) (names): " );
        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
    }
    else
    {
        printf("Client credential names: %ws\n",CredNames.sUserName);
        FreeContextBuffer(CredNames.sUserName);

    }

    //
    // Do the same for the client
    //

    SecStatus = QueryCredentialsAttributes(
                    ServerCredHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    &CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryCredentialsAttributes (Server) (names): " );
        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
    } else {
        printf("Server credential names: %ws\n",CredNames.sUserName);
        FreeContextBuffer(CredNames.sUserName);

    }


    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    if (ContextReq == 0)
    {
        ClientFlags = ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_CONFIDENTIALITY | ISC_REQ_REPLAY_DETECT | ISC_REQ_MUTUAL_AUTH ; //ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY; // USE_DCE_STYLE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_SESSION_KEY; //  | ISC_REQ_DATAGRAM;
    }
    else
    {
        ClientFlags = ContextReq;
    }

    Calls++;

    if (ARGUMENT_PRESENT(TargetNameU))
    {
        wcscpy(TargetName, TargetNameU);
    }
    else if (ARGUMENT_PRESENT(ServerUserNameU) && ARGUMENT_PRESENT(ServerDomainNameU))
    {
        wcscpy(
            TargetName,
            ServerDomainNameU
            );
        wcscat(
            TargetName,
            L"\\"
            );
        wcscat(
            TargetName,
            ServerUserNameU
            );
    }
    else
    {
        wcscpy(
            TargetName,
            DomainName
            );
        wcscat(
            TargetName,
            L"\\"
            );
        wcscat(
            TargetName,
            UserName
            );
    }

    InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetName,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);

        DumpBuffer(  NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }






    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(AcceptStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( AcceptStatus );
        }
        if ( !NT_SUCCESS(AcceptStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }


Redo:

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        if (AuthenticateBuffer.pvBuffer == NULL) {
            AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
            if ( AuthenticateBuffer.pvBuffer == NULL ) {
                printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
                return;
            }
        }

        InitStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        ClientFlags,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( InitStatus != STATUS_SUCCESS ) {
            printf( "InitializeSecurityContext (Authenticate): " );
            PrintStatus( InitStatus );
            if ( !NT_SUCCESS(InitStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            printf( "\n\nAuthenticate Message:\n" );

            printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes );
            PrintTime( "Lifetime: ", Lifetime );
            GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
            FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
            PrintTime( "Current Time: ", stLocal);

            DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
            ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;

            AcceptStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            &ChallengeDesc,
                            &ContextAttributes,
                            &Lifetime );

            if ( AcceptStatus != STATUS_SUCCESS ) {
                printf( "AcceptSecurityContext (Challenge): " );
                PrintStatus( AcceptStatus );
                if ( !NT_SUCCESS(AcceptStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {
                printf( "\n\nFinal Authentication:\n" );

                printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                        ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );
                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
                FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
                PrintTime( "Current Time: ", stLocal);
                printf(" \n" );
                DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
            }

            if (InitStatus != STATUS_SUCCESS)
            {
                goto Redo;
            }
        }

    }

#ifdef notdef
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
#endif





    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_FLAGS,
                    &ContextFlags );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (flags): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryFlags: 0x%x\n",
                    ContextFlags.Flags );
    }

    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_KEY_INFO,
                    &KeyInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (KeyInfo): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryKeyInfo:\n");

        printf("Signature algorithm = %ws\n",KeyInfo.sSignatureAlgorithmName);
        printf("Encrypt algorithm = %ws\n",KeyInfo.sEncryptAlgorithmName);
        printf("KeySize = %d\n",KeyInfo.KeySize);
        printf("Signature Algorithm = %d\n",KeyInfo.SignatureAlgorithm);
        printf("Encrypt Algorithm = %d\n",KeyInfo.EncryptAlgorithm);

        FreeContextBuffer(
            KeyInfo.sSignatureAlgorithmName
            );
        FreeContextBuffer(
            KeyInfo.sEncryptAlgorithmName
            );
    }



    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames for ServerContextHandle: %ws\n", ContextNames->sUserName );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes for client context (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames for ClientContextHandle: %ws\n", ContextNames->sUserName );
    }

    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_NATIVE_NAMES,
                    &NativeNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (Nativenames): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    if ( !QuietMode ) {
        printf( "QueryNativeNames for ServerContextHandle: %ws, %ws\n",
            STRING_OR_NULL(NativeNames.sClientName),
            STRING_OR_NULL(NativeNames.sServerName) );

    }
    if (NativeNames.sClientName != NULL)
    {
        FreeContextBuffer(NativeNames.sClientName);
    }
    if (NativeNames.sServerName != NULL)
    {
        FreeContextBuffer(NativeNames.sServerName);
    }
    if (!DoAnsi)
    {
        SecStatus = QueryContextAttributes(
                        &ClientContextHandle,
                        SECPKG_ATTR_NATIVE_NAMES,
                        &NativeNames );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "QueryContextAttributes (Nativenames): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            printf( "QueryNativeNames for ClientContextHandle: %ws, %ws\n",
                STRING_OR_NULL(NativeNames.sClientName),
                STRING_OR_NULL(NativeNames.sServerName) );

        }
    }
    else
    {
        SecStatus = QueryContextAttributesA(
                        &ClientContextHandle,
                        SECPKG_ATTR_NATIVE_NAMES,
                        &NativeNamesA );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "QueryContextAttributes (Nativenames): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        NativeNames = *(PSecPkgContext_NativeNames) &NativeNamesA;

        if ( !QuietMode ) {
            printf( "QueryNativeNames for ClientContextHandle: %s, %s\n",
                STRING_OR_NULLA(NativeNamesA.sClientName),
                STRING_OR_NULLA(NativeNamesA.sServerName) );
        }


    }

    if (NativeNames.sClientName != NULL)
    {
        FreeContextBuffer(NativeNames.sClientName);
    }
    if (NativeNames.sServerName != NULL)
    {
        FreeContextBuffer(NativeNames.sServerName);
    }


    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_DCE_INFO,
                    &ContextDceInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryDceInfo: %ws\n", ContextDceInfo.pPac );
    }


    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        PrintTime("   Start:", ContextLifespan.tsStart );
        PrintTime("  Expiry:", ContextLifespan.tsExpiry );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);
    }

    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_PACKAGE_INFO,
                    &ContextPackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (PackageInfo): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "PackageInfo: %ws %ws %d\n",
                    ContextPackageInfo.PackageInfo->Name,
                    ContextPackageInfo.PackageInfo->Comment,
                    ContextPackageInfo.PackageInfo->wRPCID
                    );
    }
    FreeContextBuffer(ContextPackageInfo.PackageInfo);

    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Get the UserName
    //

    {
        PUNICODE_STRING UserNameLsa;
        PUNICODE_STRING DomainNameLsa;
        NTSTATUS Status;

        Status = LsaGetUserName( &UserNameLsa, &DomainNameLsa );
        if (NT_SUCCESS(Status))
        {
            printf("Lsa username = %wZ\\%wZ\n",DomainNameLsa, UserNameLsa );
            LsaFreeMemory(
                UserNameLsa->Buffer);
            LsaFreeMemory(UserNameLsa);
            LsaFreeMemory(DomainNameLsa->Buffer);
            LsaFreeMemory(DomainNameLsa);
        }
        else
        {
            printf("Failed LsaGetUserName: 0x%x\n",Status);
        }
    }


    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {

            if ( DumpToken )
            {
                PrintToken( TokenHandle ); 
            }

            (VOID) NtClose( TokenHandle );
        }

    }

    //
    // If delegation is enabled and we are below our recursion depth, try
    // this again.
    //
    if ((ClientFlags & ISC_REQ_DELEGATE) && (++RecursionDepth < MaxRecursionDepth))
    {
        TestSspRoutine(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, ClientFlags, CredFlags);
    }

    //
    // RevertToSelf (ServerSide)
    //

//    SecStatus = RevertSecurityContext( &ServerContextHandle );
//
//    if ( SecStatus != STATUS_SUCCESS ) {
//        printf( "RevertSecurityContext: " );
//        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
//    }


#ifdef notdef
    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityContextToken: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if (!ImpersonateLoggedOnUser(Token))
    {
        printf("Impersonate logged on user failed: %d\n",GetLastError());
        return;
    }
    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        WCHAR UserName[100];
        ULONG NameLength = 100;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
        if (!GetUserName(UserName, &NameLength))
        {
            printf("Failed to get username: %d\n",GetLastError());
            return;
        }
        else
        {
            printf("Username = %ws\n",UserName);
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

//    if (!RevertToSelf())
//    {
//        printf( "RevertToSelf failed: %d\n ",GetLastError() );
//        return;
//    }
    CloseHandle(Token);
#endif

    //
    // Sign a message
    //

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = ContextSizes.cbMaxSignature;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Encrypt a message
    //

    SigBuffers[0].pvBuffer = bSigBuffer;
    SigBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
    SigBuffers[0].BufferType = SECBUFFER_TOKEN;

    pbSealBuffer = (PBYTE) LocalAlloc(0, 60);
    memset(
        pbSealBuffer,
        0xeb,
        60
        );

    SigBuffers[1].cbBuffer = 60;
    SigBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;
    SigBuffers[1].pvBuffer = pbSealBuffer;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    

    printf("\n Pre-Encrypt Blob: \n");
    DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    SecStatus = EncryptMessage(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EncryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    if ( !QuietMode ) {

        printf("\n Encrypt Blob: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[0].pvBuffer,SigBuffers[0].cbBuffer); 
    }
                                                                   
    //
    // Decrypt the message
    //
    //pbSealBuffer[11] = 0xcc;

    for (Index = 1; Index < 4 ; Index++ )
    {
        SigBuffers[Index].cbBuffer = 20;
        SigBuffers[Index].pvBuffer = pbSealBuffer + (Index - 1) * 20;
        SigBuffers[Index].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;
        printf("\n %x: \n", Index);
        DumpBuffer(SigBuffers[Index].pvBuffer,SigBuffers[Index].cbBuffer);
        
    }

    


    SignMessage.cBuffers = 4;
    SecStatus = DecryptMessage(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DecryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Now try the opposite.
    //

    //
    // Encrypt a message
    //

    #define tstsize 133
    
    SigBuffers[0].pvBuffer = bSigBuffer;
    SigBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
    SigBuffers[0].BufferType = SECBUFFER_TOKEN;

    pbSealBuffer = (PBYTE) LocalAlloc(0, tstsize);
    memset(
        pbSealBuffer,
        0xeb,
        tstsize
        );

    SigBuffers[1].cbBuffer = tstsize;
    SigBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;
    SigBuffers[1].pvBuffer = pbSealBuffer;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = EncryptMessage(
                        &ServerContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EncryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Encrypt Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Decrypt the message
    //

    for (Index = 1; Index < 7 ; Index++ )
    {
        SigBuffers[Index].cbBuffer = 20;
        SigBuffers[Index].pvBuffer = pbSealBuffer + (Index - 1) * 20;
        SigBuffers[Index].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;
    }


    //pbSealBuffer[99] = 0xec;


        SigBuffers[7].cbBuffer = 13;
        SigBuffers[7].pvBuffer = pbSealBuffer + 120;
        SigBuffers[7].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;


    SignMessage.cBuffers = 8;
    SecStatus = DecryptMessage(
                        &ClientContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DecryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



#define BIG_BUFFER_SIZE 144770


    SigBuffers[0].pvBuffer = bSigBuffer;
    SigBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
    SigBuffers[0].BufferType = SECBUFFER_TOKEN;

    pbSealBuffer = (PBYTE) LocalAlloc(0, BIG_BUFFER_SIZE);
    memset(
        pbSealBuffer,
        0xeb,
        BIG_BUFFER_SIZE
        );

    SigBuffers[1].cbBuffer = BIG_BUFFER_SIZE;
    SigBuffers[1].BufferType = SECBUFFER_DATA;
    SigBuffers[1].pvBuffer = pbSealBuffer;

    SigBuffers[2].cbBuffer = ContextSizes.cbBlockSize;
    SigBuffers[2].BufferType = SECBUFFER_PADDING;
    SigBuffers[2].pvBuffer = LocalAlloc(LMEM_ZEROINIT, ContextSizes.cbBlockSize);

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 3;
    SignMessage.ulVersion = 0;

    SecStatus = EncryptMessage(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "Big EncryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Decrypt the message
    //

    cbWholeBuffer = SigBuffers[0].cbBuffer +
                    SigBuffers[1].cbBuffer +
                    SigBuffers[2].cbBuffer;

    pbWholeBuffer = (PBYTE) LocalAlloc(LMEM_ZEROINIT, cbWholeBuffer);
    RtlCopyMemory(
        pbWholeBuffer,
        SigBuffers[0].pvBuffer,
        SigBuffers[0].cbBuffer
        );
    RtlCopyMemory(
        pbWholeBuffer + SigBuffers[0].cbBuffer,
        SigBuffers[1].pvBuffer,
        SigBuffers[1].cbBuffer
        );
    RtlCopyMemory(
        pbWholeBuffer + SigBuffers[0].cbBuffer + SigBuffers[1].cbBuffer,
        SigBuffers[2].pvBuffer,
        SigBuffers[2].cbBuffer
        );


    SigBuffers[0].pvBuffer = pbWholeBuffer;
    SigBuffers[0].cbBuffer = cbWholeBuffer;
    SigBuffers[0].BufferType = SECBUFFER_STREAM;


    SigBuffers[1].cbBuffer = 0;
    SigBuffers[1].BufferType = SECBUFFER_DATA;
    SigBuffers[1].pvBuffer = NULL;
    SignMessage.cBuffers = 2;
    SignMessage.pBuffers = SigBuffers;

    SecStatus = DecryptMessage(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "set Big DecryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = ContextSizes.cbMaxSignature;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN ;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA ;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    printf("BAD SIGNATURE TEST\n");
    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Export & Import contexts
    //

    for (Index = 0; Index < 3 ; Index++ )
    {
        SecStatus = ExportSecurityContext(
                        &ClientContextHandle,
                        SECPKG_CONTEXT_EXPORT_DELETE_OLD,
                        &MarshalledContext,
                        &TokenHandle
                        );
        if (!NT_SUCCESS(SecStatus))
        {
            printf("Failed to export context: ");
            PrintStatus(SecStatus);
        }
        else
        {
            SecStatus = ImportSecurityContext(
                            PackageName,
                            &MarshalledContext,
                            TokenHandle,
                            &ClientContextHandle
                            );
            if (!NT_SUCCESS(SecStatus))
            {
                printf("Failed to import context: ");
                PrintStatus(SecStatus);
                return;
            }

            //
            // Sign a message again, using the imported context
            //

            SigBuffers[1].pvBuffer = bSigBuffer;
            SigBuffers[1].cbBuffer = ContextSizes.cbMaxSignature;
            SigBuffers[1].BufferType = SECBUFFER_TOKEN;

            SigBuffers[0].pvBuffer = bDataBuffer;
            SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
            SigBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY_WITH_CHECKSUM;;
            memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

            SignMessage.pBuffers = SigBuffers;
            SignMessage.cBuffers = 2;
            SignMessage.ulVersion = 0;

            SecStatus = MakeSignature(
                                &ClientContextHandle,
                                0,
                                &SignMessage,
                                0 );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "MakeSignature: " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {

                printf("\n Signature: \n");
                DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

            }


            //
            // Verify the signature
            //

            SecStatus = VerifySignature(
                                &ServerContextHandle,
                                &SignMessage,
                                0,
                                0 );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "VerifySignature: " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }



        }
    }


    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext( ClientContext %x : %x ) failed: ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext( ServerContext %x : %x ) failed: ",
                    ServerContextHandle.dwLower, ServerContextHandle.dwUpper );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    if (AcquiredServerCred)
    {
        SecStatus = FreeCredentialsHandle( ServerCredHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "FreeCredentialsHandle failed: " );
            PrintStatus( SecStatus );
            return;
        }
        ServerCredHandle = NULL;

    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    /*if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    } */

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}

VOID
TestLogonRoutine(
    IN ULONG Count,
    IN BOOLEAN Relogon,
    IN SECURITY_LOGON_TYPE LogonType,
    IN LPSTR PackageName,
    IN LPSTR UserName,
    IN LPSTR DomainName,
    IN LPSTR Password
    )
{
    NTSTATUS Status;
    PKERB_INTERACTIVE_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_INTERACTIVE_LOGON);
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ThreadTokenHandle = NULL;
    LARGE_INTEGER StartTime, EndTime;

    printf("Logging On %s\\%s %s\n",DomainName, UserName, Password);
    if (Relogon)
    {
        LogonInfoSize = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
    }
    LogonInfoSize += (ULONG) (strlen(UserName) + ((DomainName == NULL) ?
                                  0 :
                                  strlen(DomainName)) + strlen(Password) + 3 ) * sizeof(WCHAR);

    LogonInfo = (PKERB_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    if (NULL == LogonInfo)
    {
        printf("Failed to allocate LogonInfo\n");
        return;
    }

    LogonInfo->MessageType = KerbInteractiveLogon;

    RtlInitString(
        &Name,
        UserName
        );

    if (Relogon)
    {
        Where = ((PUCHAR) LogonInfo) + sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
    }
    else
    {
        Where = (PUCHAR) (LogonInfo + 1);
    }

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->UserName,
        &Name,
        FALSE
        );
    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        DomainName
        );

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where;
    LogonInfo->LogonDomainName.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->LogonDomainName,
        &Name,
        FALSE
        );
    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        Password
        );

    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Password,
        &Name,
        FALSE
        );
    Where += LogonInfo->Password.Length + sizeof(WCHAR);

    LogonInfo->MessageType = KerbInteractiveLogon;

    if (Relogon)
    {
        HANDLE ProcessToken = NULL;
        TOKEN_STATISTICS Stats;
        ULONG StatsSize = sizeof(TOKEN_STATISTICS);

        if (OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &ProcessToken))
        {
            if (GetTokenInformation(
                    ProcessToken,
                    TokenStatistics,
                    &Stats,
                    StatsSize,
                    &StatsSize
                    ))
            {
                PKERB_INTERACTIVE_UNLOCK_LOGON UnlockLogonInfo = (PKERB_INTERACTIVE_UNLOCK_LOGON) LogonInfo;

                UnlockLogonInfo->LogonId = Stats.AuthenticationId;
                LogonInfo->MessageType = KerbWorkstationUnlockLogon;
            }
            else
            {
                printf("Failed to get token info: %d\n",GetLastError());
            }
        }
        else
        {
            printf("Failed to open process token info: %d\n",GetLastError());
        }
    }
    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, (BOOLEAN) OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&ThreadTokenHandle) , &WasEnabled);
    if (ThreadTokenHandle != NULL)
    {
        CloseHandle(ThreadTokenHandle);
        ThreadTokenHandle = NULL;
    }
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        PackageName
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    for (Index = 0; Index < Count ; Index++ )
    {
        NtQuerySystemTime(&StartTime);
        Status = LsaLogonUser(
                    LogonHandle,
                    &Name,
                    LogonType,
                    PackageId,
                    LogonInfo,
                    LogonInfoSize,
                    NULL,           // no token groups
                    &SourceContext,
                    (PVOID *) &Profile,
                    &ProfileSize,
                    &LogonId,
                    &TokenHandle,
                    &Quotas,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("lsalogonuser failed: 0x%x\n",Status);
            return;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
            return;
        }

        NtQuerySystemTime(&EndTime);
        printf("logon took %d ms\t\t",(EndTime.QuadPart-StartTime.QuadPart) / 10000);
        PrintTime("", EndTime);
        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        printf("Username = %ws\n",UserNameString);
        RevertToSelf();
        NtClose(TokenHandle);

        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

    }

}


BOOL
LaunchCommandWindowAsUser(HANDLE hToken)
{

    HANDLE  hFullToken = NULL;
    BOOL    fRet = FALSE;
    DWORD   dwErr = 0;
    WCHAR   lpApp[MAX_PATH];

    STARTUPINFOW            startupinfo;
    PROCESS_INFORMATION     processinfo;


    if (!DuplicateTokenEx(
            hToken,
            TOKEN_ALL_ACCESS,
            NULL,
            SecurityImpersonation,
            TokenPrimary,
            &hFullToken
            ))  {

        dwErr = GetLastError();
        printf("DuplicateTokenEx failed! - %x\n", dwErr);
        return FALSE;
    }


    //
    //  At this point, we need to setup the LPSTARTUPINFO for the
    //  CreateProcessAsUser() call.
    //
    ZeroMemory(&startupinfo, sizeof(STARTUPINFOW));
    startupinfo.cb = sizeof(STARTUPINFOW);

    startupinfo.lpDesktop = L"winsta0\\default";
    startupinfo.lpTitle = L"Impersonated Client Security Context";

    GetSystemDirectoryW(lpApp, MAX_PATH);

    wcscat(lpApp, L"\\cmd.exe");//potential for buffer overflow, but not likely


    if (!CreateProcessAsUserW(
                hFullToken,
                lpApp,
                NULL,
                NULL,
                NULL,
                FALSE,
                CREATE_NEW_CONSOLE,
                NULL,
                NULL,
                &startupinfo,
                &processinfo
                ))  {

        printf("CreateProcessAsUserW failed! - %x\n", GetLastError());
        return FALSE;
    }

     return fRet;
}



VOID
TestS4ULogonRoutine(
    IN LPSTR UserName,
    IN LPSTR DomainName
    )
{
    NTSTATUS Status;
    PKERB_S4U_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_S4U_LOGON);
    BOOLEAN WasEnabled, Trusted = TRUE;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;

    //printf("S4U LogOn %s\\%s\n",((DomainName == NULL)? "<NULL>" : DomainName), UserName);
    LogonInfoSize += (ULONG) ((strlen(UserName)+1) * sizeof(WCHAR));
    LogonInfoSize += (ULONG) ((DomainName == NULL) ? 0 : ((strlen(DomainName) +1) * sizeof(WCHAR)));
    
    LogonInfo = (PKERB_S4U_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    if (NULL == LogonInfo)
    {
        return;
    }


    LogonInfo->MessageType = KerbS4ULogon;

    RtlInitString(
        &Name,
        UserName
        );

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->ClientUpn.Buffer = (LPWSTR) Where;
    LogonInfo->ClientUpn.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->ClientUpn,
        &Name,
        FALSE
        );
    Where += LogonInfo->ClientUpn.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        DomainName
        );

    LogonInfo->ClientRealm.Buffer = (LPWSTR) Where;
    LogonInfo->ClientRealm.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->ClientRealm,
        &Name,
        FALSE
        );
    Where += LogonInfo->ClientRealm.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        "SspTest"
        );

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }


    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    Status = LsaLogonUser(
                LogonHandle,
                &Name,
                Network,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &TokenHandle,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("lsalogonuser failed: 0x%x\n",Status);
        printf("          substatus: 0x%x\n",SubStatus);
        return;
    }
    

    //LaunchCommandWindowAsUser( TokenHandle );


    ImpersonateLoggedOnUser( TokenHandle );



    GetUserName(UserNameString,&NameLength);
    printf("Username = %ws\n",UserNameString);
    RevertToSelf();


    if ( DumpToken )
    {   
        PrintToken(TokenHandle);
    }

    NtClose(TokenHandle);






}


VOID
PrintKdcName(
    IN PKERB_EXTERNAL_NAME Name
    )
{
    ULONG Index;
    if (Name == NULL)
    {
        printf("(null)");
    }
    else
    {
        for (Index = 0; Index < Name->NameCount ; Index++ )
        {
            printf(" %wZ ",&Name->Names[Index]);
        }
    }
    printf("\n");
}


#ifdef notdef
//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKerbCredFromExternalTickets
//
//  Synopsis:   Builds a marshalled KERB_CRED structure
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  Ticket - The ticket of the session key to seal the
//                      encrypted portion
//              DelegationTicket - The ticket to marshall into the cred message
//              MarshalledKerbCred - Receives a marshalled KERB_CRED structure
//              KerbCredSizes - Receives size, in bytes, of marshalled
//                      KERB_CRED.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildKerbCredFromExternalTickets(
    IN PKERB_EXTERNAL_TICKET Ticket,
    IN PKERB_EXTERNAL_TICKET DelegationTicket,
    OUT PUCHAR * MarshalledKerbCred,
    OUT PULONG KerbCredSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_CRED KerbCred;
    KERB_CRED_INFO_LIST CredInfo;
    KERB_ENCRYPTED_CRED EncryptedCred;
    KERB_CRED_TICKET_LIST TicketList;
    ULONG EncryptionOverhead;
    ULONG BlockSize;
    PUCHAR MarshalledEncryptPart = NULL;
    ULONG MarshalledEncryptSize;
    ULONG ConvertedFlags;
    PKERB_TICKET DecodedTicket = NULL;


    //
    // Initialize the structures so they can be freed later.
    //

    *MarshalledKerbCred = NULL;
    *KerbCredSize = 0;

    RtlZeroMemory(
        &KerbCred,
        sizeof(KERB_CRED)
        );

    RtlZeroMemory(
        &EncryptedCred,
        sizeof(KERB_ENCRYPTED_CRED)
        );
    RtlZeroMemory(
        &CredInfo,
        sizeof(KERB_CRED_INFO_LIST)
        );
    RtlZeroMemory(
        &TicketList,
        sizeof(KERB_CRED_TICKET_LIST)
        );

    KerbCred.version = KERBEROS_VERSION;
    KerbCred.message_type = KRB_CRED;


    //
    // Decode the ticket so we can put it in the structure (to re-encode it)
    //

    KerbErr = KerbUnpackData(
                DelegationTicket->EncodedTicket,
                DelegationTicket->EncodedTicketSize,
                KERB_TICKET_PDU,
                (PVOID *) &DecodedTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack encoded ticket: 0x%x\n",KerbErr);
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // First stick the ticket into the ticket list.
    //


    TicketList.next= NULL;
    TicketList.value = *DecodedTicket;
    KerbCred.tickets = &TicketList;

    //
    // Now build the KERB_CRED_INFO for this ticket
    //

    CredInfo.value.key = * (PKERB_ENCRYPTION_KEY) &DelegationTicket->SessionKey;
    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.endtime,
        NULL,
        &DelegationTicket->EndTime
        );
    CredInfo.value.bit_mask |= endtime_present;
    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.KERB_CRED_INFO_renew_until,
        NULL,
        &DelegationTicket->RenewUntil
        );
    CredInfo.value.bit_mask |= KERB_CRED_INFO_renew_until_present;
    ConvertedFlags = KerbConvertUlongToFlagUlong(DelegationTicket->TicketFlags);
    CredInfo.value.flags.value = (PUCHAR) &ConvertedFlags;
    CredInfo.value.flags.length = 8 * sizeof(ULONG);
    CredInfo.value.bit_mask |= flags_present;

    //
    // The following fields are marked as optional but treated
    // as mandatory by the MIT implementation of Kerberos.
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.sender_name,
                (PKERB_INTERNAL_NAME) DelegationTicket->ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= sender_name_present;

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.principal_name,
                (PKERB_INTERNAL_NAME) DelegationTicket->ServiceName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= principal_name_present;

    //
    // NOTE: we are assuming that because we are sending a TGT the
    // client realm is the same as the serve realm. If we ever
    // send non-tgt or cross-realm tgt, this needs to be fixed.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &CredInfo.value.principal_realm,
                &DelegationTicket->DomainName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    //
    // The realms are the same, so don't allocate both
    //

    CredInfo.value.sender_realm = CredInfo.value.principal_realm;
    CredInfo.value.bit_mask |= principal_realm_present | sender_realm_present;

    EncryptedCred.ticket_info = &CredInfo;


    //
    // Now encrypted the encrypted cred into the cred
    //

    if (!KERB_SUCCESS(KerbPackEncryptedCred(
            &EncryptedCred,
            &MarshalledEncryptSize,
            &MarshalledEncryptPart
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If we are doing DES encryption, then we are talking with an non-NT
    // server. Hence, don't encrypt the kerb-cred.
    //

    if ((Ticket->SessionKey.KeyType == KERB_ETYPE_DES_CBC_CRC) ||
        (Ticket->SessionKey.KeyType == KERB_ETYPE_DES_CBC_MD5))
    {
        KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
        KerbCred.encrypted_part.cipher_text.value = MarshalledEncryptPart;
        KerbCred.encrypted_part.encryption_type = 0;
        MarshalledEncryptPart = NULL;

    }
    else
    {
        //
        // Now get the encryption overhead
        //

        KerbErr = KerbAllocateEncryptionBufferWrapper(
                    Ticket->SessionKey.KeyType,
                    MarshalledEncryptSize,
                    &KerbCred.encrypted_part.cipher_text.length,
                    &KerbCred.encrypted_part.cipher_text.value
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }



        //
        // Encrypt the data.
        //

        KerbErr = KerbEncryptDataEx(
                    &KerbCred.encrypted_part,
                    MarshalledEncryptSize,
                    MarshalledEncryptPart,
                    Ticket->SessionKey.KeyType,
                    KERB_CRED_SALT,
                    (PKERB_ENCRYPTION_KEY) &Ticket->SessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Now we have to marshall the whole KERB_CRED
    //

    if (!KERB_SUCCESS(KerbPackKerbCred(
            &KerbCred,
            KerbCredSize,
            MarshalledKerbCred
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:

    if (DecodedTicket != NULL)
    {
        KerbFreeData(
            KERB_TICKET_PDU,
            DecodedTicket
            );
    }
    KerbFreePrincipalName(&CredInfo.value.sender_name);

    KerbFreePrincipalName(&CredInfo.value.principal_name);

    KerbFreeRealm(&CredInfo.value.principal_realm);

    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }
    if (KerbCred.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(KerbCred.encrypted_part.cipher_text.value);
    }
    return(Status);
}

#endif

VOID
TestCallPackageRoutine(
    IN LPWSTR Function
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    KERB_DEBUG_REQUEST DebugRequest;
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    PKERB_EXTERNAL_TICKET CacheEntry = NULL;
    ULONG Index;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    if (_wcsicmp(Function,L"bp") == 0)
    {
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_REQ_BREAKPOINT;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }

    }
    else if (_wcsicmp(Function,L"tickets")  == 0)
    {
        CacheRequest.MessageType = KerbQueryTicketCacheMessage;
        CacheRequest.LogonId.LowPart = 0;
        CacheRequest.LogonId.HighPart = 0;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    (PVOID *) &CacheResponse,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            printf("Cached Tickets:\n");
            for (Index = 0; Index < CacheResponse->CountOfTickets ; Index++ )
            {
                printf("\tServer: %wZ@%wZ\n",
                    &CacheResponse->Tickets[Index].ServerName,
                    &CacheResponse->Tickets[Index].RealmName);
                PrintTime("\t\tStart Time: ",CacheResponse->Tickets[Index].StartTime);
                PrintTime("\t\tEnd Time: ",CacheResponse->Tickets[Index].EndTime);
                PrintTime("\t\tRenew Time: ",CacheResponse->Tickets[Index].RenewTime);
                printf("\t\tEncryptionType: %d\n",CacheResponse->Tickets[Index].EncryptionType);
                printf("\t\tTicketFlags: 0x%x\n",CacheResponse->Tickets[Index].TicketFlags);

            }
        }


    }
    else if (_wcsicmp(Function,L"tgt") == 0)
    {
        CacheRequest.MessageType = KerbRetrieveTicketMessage;
        CacheRequest.LogonId.LowPart = 0;
        CacheRequest.LogonId.HighPart = 0;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    (PVOID *) &CacheEntry,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("query tgt failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            printf("Cached TGT:\n");
            printf("ServiceName: "); PrintKdcName(CacheEntry->ServiceName);
            printf("TargetName: "); PrintKdcName(CacheEntry->TargetName);
            printf("DomainName: %wZ\n",&CacheEntry->DomainName);
            printf("TargetDomainName: %wZ\n",&CacheEntry->TargetDomainName);
            printf("ClientName: "); PrintKdcName(CacheEntry->ClientName);
            printf("TicketFlags: 0x%x\n",CacheEntry->TicketFlags);
            PrintTime("StartTime: ",CacheEntry->StartTime);
            PrintTime("StartTime: ",CacheEntry->StartTime);
            PrintTime("EndTime: ",CacheEntry->EndTime);
            PrintTime("RenewUntil: ",CacheEntry->RenewUntil);
            PrintTime("TimeSkew: ",CacheEntry->TimeSkew);
            LsaFreeReturnBuffer(CacheEntry);
        }

    }
    else if (_wcsicmp(Function,L"stats")  == 0)
    {
        PKERB_DEBUG_REPLY DbgReply;
        PKERB_DEBUG_STATS DbgStats;
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_REQ_STATISTICS;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("stats failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            DbgReply = (PKERB_DEBUG_REPLY) Response;
            if (DbgReply->MessageType != KerbDebugRequestMessage)
            {
                printf("Wrong return message type: %d\n",DbgReply->MessageType);
                return;
            }
            DbgStats = (PKERB_DEBUG_STATS) DbgReply->Data;
            printf("Cache hits = %d\n",DbgStats->CacheHits);
            printf("Cache Misses = %d\n",DbgStats->CacheMisses);
            printf("Skewed Requets = %d\n",DbgStats->SkewedRequests);
            printf("Success Requets = %d\n",DbgStats->SuccessRequests);
            PrintTime("Last Sync = ",DbgStats->LastSync);
        }
        LsaFreeReturnBuffer(Response);
    }
    else if (_wcsicmp(Function,L"token") == 0)
    {
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_CREATE_TOKEN;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }

    }
    else if (_wcsnicmp(Function,L"purge:", wcslen(L"purge:")) == 0)
    {
        PKERB_PURGE_TKT_CACHE_REQUEST CacheRequest = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"purge:")
            );




        CacheRequest = (PKERB_PURGE_TKT_CACHE_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_PURGE_TKT_CACHE_REQUEST));

        CacheRequest->MessageType = KerbPurgeTicketCacheMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        for (Index = 0; Index < Target.Length / sizeof(WCHAR);  Index++ )
        {
            if (Target.Buffer[Index] == L'@')
            {
                CacheRequest->ServerName.Buffer = Target.Buffer;
                CacheRequest->ServerName.Length = 2*Index;
                CacheRequest->ServerName.MaximumLength = CacheRequest->ServerName.Length;
                CacheRequest->RealmName.Buffer = Target.Buffer+Index+1;
                CacheRequest->RealmName.Length = Target.Length - 2*(Index+1);
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                break;
            }
            else if (Target.Buffer[Index] == L'\\')
            {
                CacheRequest->RealmName.Buffer = Target.Buffer;
                CacheRequest->RealmName.Length = 2*Index;
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                CacheRequest->ServerName.Buffer = Target.Buffer+Index+1;
                CacheRequest->ServerName.Length = Target.Length - 2*(Index+1);
                CacheRequest->ServerName.MaximumLength = CacheRequest->ServerName.Length;
                break;
            }
        }

        printf("Deleting tickets: %wZ\\%wZ\n",
            &CacheRequest->RealmName, &CacheRequest->ServerName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_PURGE_TKT_CACHE_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }


    }
    else if (_wcsnicmp(Function,L"purgeex:", wcslen(L"purgeex:")) == 0)
    {
        PKERB_PURGE_TKT_CACHE_EX_REQUEST CacheRequest = NULL;
        
        CacheRequest = (PKERB_PURGE_TKT_CACHE_EX_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, sizeof(KERB_PURGE_TKT_CACHE_EX_REQUEST));

        CacheRequest->MessageType = KerbPurgeTicketCacheExMessage;
        CacheRequest->Flags = KERB_PURGE_ALL_TICKETS;

        printf("Deleting all tickets\n" );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    sizeof(KERB_PURGE_TKT_CACHE_EX_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }


    }
    else if (_wcsnicmp(Function,L"retrieve:", wcslen(L"retrieve:")) == 0)
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"retrieve:")
            );




        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            printf("Cached Ticket:\n");
            printf("ServiceName: "); PrintKdcName(CacheResponse->Ticket.ServiceName);
            printf("TargetName: "); PrintKdcName(CacheResponse->Ticket.TargetName);
            printf("DomainName: %wZ\n",&CacheResponse->Ticket.DomainName);
            printf("ClientDomain: %wZ\n", &CacheResponse->Ticket.AltTargetDomainName); 
            printf("TargetDomainName: %wZ\n",&CacheResponse->Ticket.TargetDomainName);
            printf("ClientName: "); PrintKdcName(CacheResponse->Ticket.ClientName);
            printf("TicketFlags: 0x%x\n",CacheResponse->Ticket.TicketFlags);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("EndTime: ",CacheResponse->Ticket.EndTime);
            PrintTime("RenewUntil: ",CacheResponse->Ticket.RenewUntil);
            PrintTime("TimeSkew: ",CacheResponse->Ticket.TimeSkew);
            LsaFreeReturnBuffer(CacheResponse);

        }


    }
    else if (_wcsnicmp(Function,L"decode:", wcslen(L"decode:")) == 0)
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"decode:")
            );




        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            PKERB_DECRYPT_REQUEST DecryptRequest = NULL;
            PKERB_DECRYPT_RESPONSE DecryptResponse = NULL;
            ULONG DecryptRequestSize = 0;
            ULONG DecryptResponseSize = 0;
            PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
            PKERB_TICKET DecodedTicket = NULL;
            KERBERR KerbErr;

            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            KerbErr = KerbUnpackData(
                        CacheResponse->Ticket.EncodedTicket,
                        CacheResponse->Ticket.EncodedTicketSize,
                        KERB_TICKET_PDU,
                        (PVOID *) &DecodedTicket
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to decode ticket: 0x%x\n",KerbErr);
                return;
            }


            //
            // Now try to decrypt the ticket with our default key
            //

            DecryptRequestSize = sizeof(KERB_DECRYPT_REQUEST) +
                                    DecodedTicket->encrypted_part.cipher_text.length;
            DecryptRequest = (PKERB_DECRYPT_REQUEST) LocalAlloc(LMEM_ZEROINIT, DecryptRequestSize);

            DecryptRequest->MessageType = KerbDecryptDataMessage;
            DecryptRequest->Flags = KERB_DECRYPT_FLAG_DEFAULT_KEY;
            DecryptRequest->InitialVectorSize = 0;
            DecryptRequest->InitialVector = NULL;
            DecryptRequest->KeyUsage = KERB_TICKET_SALT;
            DecryptRequest->CryptoType = DecodedTicket->encrypted_part.encryption_type;
            DecryptRequest->EncryptedDataSize = DecodedTicket->encrypted_part.cipher_text.length;
            DecryptRequest->EncryptedData = (PUCHAR) (DecryptRequest + 1);
            RtlCopyMemory(
                DecryptRequest->EncryptedData,
                DecodedTicket->encrypted_part.cipher_text.value,
                DecryptRequest->EncryptedDataSize
                );


            Status = LsaCallAuthenticationPackage(
                        LogonHandle,
                        PackageId,
                        DecryptRequest,
                        DecryptRequestSize,
                        (PVOID *) &DecryptResponse,
                        &DecryptResponseSize,
                        &SubStatus
                        );
            if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
            {
                printf("Failed to decrypt message: 0x%x or 0x%x\n",Status,SubStatus);
                return;
            }

            //
            // Now decode the encrypted ticket
            //

            KerbErr = KerbUnpackData(
                            DecryptResponse->DecryptedData,
                            DecryptResponseSize,
                            KERB_ENCRYPTED_TICKET_PDU,
                            (PVOID *) &EncryptedTicket
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to unpack encrypted ticket: 0x%x\n",KerbErr);
                return;
            }

            //
            // Now print some fields
            //

            printf("Enc.Ticket client_realm = %s\n",EncryptedTicket->client_realm);
            printf("Enc.Ticket. client_name = %s\n",EncryptedTicket->client_name.name_string->value);

            LsaFreeReturnBuffer(DecryptResponse);


            LsaFreeReturnBuffer(CacheResponse);

        }


    }
    else if (_wcsnicmp(Function,L"decrypt:", wcslen(L"decrypt:")) == 0)
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        UNICODE_STRING Password = {0};
        UNICODE_STRING EmptyString = {0};
        KERB_ENCRYPTION_KEY Key = {0};
        USHORT Index;
        KERBERR KerbErr;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"decrypt:")
            );

        for (Index = 0; Index < Target2.Length / sizeof(WCHAR) ; Index ++ )
        {
            if (Target2.Buffer[Index] == L':')
            {
                Password = Target2;
                Password.Length = Index*2;
                Target2.Buffer = Target2.Buffer+Index+1;
                Target2.Length -= (Index+1)*2;
            }
        }


        printf("Decrypting with key %wZ\n",&Password);


        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            PKERB_DECRYPT_REQUEST DecryptRequest = NULL;
            PKERB_DECRYPT_RESPONSE DecryptResponse = NULL;
            ULONG DecryptRequestSize = 0;
            ULONG DecryptResponseSize = 0;
            PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
            PKERB_TICKET DecodedTicket = NULL;

            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            KerbErr = KerbUnpackData(
                        CacheResponse->Ticket.EncodedTicket,
                        CacheResponse->Ticket.EncodedTicketSize,
                        KERB_TICKET_PDU,
                        (PVOID *) &DecodedTicket
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to decode ticket: 0x%x\n",KerbErr);
                return;
            }

            KerbErr = KerbHashPasswordEx(
                        &Password,
                        &EmptyString,
                        DecodedTicket->encrypted_part.encryption_type,
                        &Key
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to hash key %wZ with type %d\n",
                    &Password,
                    DecodedTicket->encrypted_part.encryption_type
                    );
                return;
            }


            //
            // Now try to decrypt the ticket with our default key
            //

            DecryptRequestSize = sizeof(KERB_DECRYPT_REQUEST) +
                                    DecodedTicket->encrypted_part.cipher_text.length +
                                    Key.keyvalue.length;
            DecryptRequest = (PKERB_DECRYPT_REQUEST) LocalAlloc(LMEM_ZEROINIT, DecryptRequestSize);

            DecryptRequest->MessageType = KerbDecryptDataMessage;
            DecryptRequest->Flags = 0;
            DecryptRequest->InitialVectorSize = 0;
            DecryptRequest->InitialVector = NULL;
            DecryptRequest->KeyUsage = KERB_TICKET_SALT;
            DecryptRequest->CryptoType = DecodedTicket->encrypted_part.encryption_type;
            DecryptRequest->EncryptedDataSize = DecodedTicket->encrypted_part.cipher_text.length;
            DecryptRequest->EncryptedData = (PUCHAR) (DecryptRequest + 1);
            RtlCopyMemory(
                DecryptRequest->EncryptedData,
                DecodedTicket->encrypted_part.cipher_text.value,
                DecryptRequest->EncryptedDataSize
                );
            DecryptRequest->Key.KeyType = Key.keytype;
            DecryptRequest->Key.Length = Key.keyvalue.length;
            DecryptRequest->Key.Value = DecryptRequest->EncryptedData + DecryptRequest->EncryptedDataSize;
            RtlCopyMemory(
                DecryptRequest->Key.Value,
                Key.keyvalue.value,
                Key.keyvalue.length
                );


            Status = LsaCallAuthenticationPackage(
                        LogonHandle,
                        PackageId,
                        DecryptRequest,
                        DecryptRequestSize,
                        (PVOID *) &DecryptResponse,
                        &DecryptResponseSize,
                        &SubStatus
                        );
            if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
            {
                printf("Failed to decrypt message: 0x%x or 0x%x\n",Status,SubStatus);
                return;
            }

            //
            // Now decode the encrypted ticket
            //

            KerbErr = KerbUnpackData(
                            DecryptResponse->DecryptedData,
                            DecryptResponseSize,
                            KERB_ENCRYPTED_TICKET_PDU,
                            (PVOID *) &EncryptedTicket
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to unpack encrypted ticket: 0x%x\n",KerbErr);
                return;
            }

            //
            // Now print some fields
            //

            printf("Enc.Ticket client_realm = %s\n",EncryptedTicket->client_realm);
            printf("Enc.Ticket. client_name = %s\n",EncryptedTicket->client_name.name_string->value);

            LsaFreeReturnBuffer(DecryptResponse);


            LsaFreeReturnBuffer(CacheResponse);

        }


    }
    else if (_wcsnicmp(Function,L"binding:", wcslen(L"binding:")) == 0)
    {
        PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST CacheRequest = NULL;
        UNICODE_STRING Server = {0};
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"binding:")
            );




        CacheRequest = (PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_ADD_BINDING_CACHE_ENTRY_REQUEST));

        CacheRequest->MessageType = KerbAddBindingCacheEntryMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        Server = Target;
        for (Index = 0; Index < Target.Length / sizeof(WCHAR);  Index++ )
        {
            if (Target.Buffer[Index] == L'@')
            {
                CacheRequest->KdcAddress.Buffer = Target.Buffer;
                CacheRequest->KdcAddress.Length = 2*Index;
                CacheRequest->KdcAddress.MaximumLength = CacheRequest->KdcAddress.Length;
                CacheRequest->RealmName.Buffer = Target.Buffer+Index+1;
                CacheRequest->RealmName.Length = Target.Length - 2*(Index+1);
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                break;
            }
            else if (Target.Buffer[Index] == L'\\')
            {
                CacheRequest->RealmName.Buffer = Target.Buffer;
                CacheRequest->RealmName.Length = 2*Index;
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                CacheRequest->KdcAddress.Buffer = Target.Buffer+Index+1;
                CacheRequest->KdcAddress.Length = Target.Length - 2*(Index+1);
                CacheRequest->KdcAddress.MaximumLength = CacheRequest->KdcAddress.Length;
                break;
            }
        }

        CacheRequest->AddressType = 0;
        printf("Updating binding cache: realm %wZ,kdc %wZ\n",
            &CacheRequest->RealmName, &CacheRequest->KdcAddress );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_ADD_BINDING_CACHE_ENTRY_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }


    }
    else if (_wcsnicmp(Function,L"purgesc:", wcslen(L"purgesc:")) == 0)
    {
        PKERB_REFRESH_SCCRED_REQUEST PurgeRequest = NULL;
        ULONG RequestSize = sizeof(KERB_REFRESH_SCCRED_REQUEST);
        UNICODE_STRING CredBlob = {0};


        RtlInitUnicodeString(
            &CredBlob,
            Function+wcslen(L"purgesc:")
            );                                

        RequestSize += CredBlob.MaximumLength;
            
        PurgeRequest = (PKERB_REFRESH_SCCRED_REQUEST) LocalAlloc(LMEM_ZEROINIT, RequestSize);    
        PurgeRequest->MessageType = KerbRefreshSmartcardCredentialsMessage;                           
        PurgeRequest->Flags = KERB_REFRESH_SCCRED_GETTGT;
        PurgeRequest->LogonId.LowPart = 0;
        PurgeRequest->LogonId.HighPart = 0;

        PurgeRequest->CredentialBlob.Buffer = (LPWSTR) ( PurgeRequest + 1 );
        PurgeRequest->CredentialBlob.Length = CredBlob.Length;
        PurgeRequest->CredentialBlob.MaximumLength = CredBlob.MaximumLength;

        RtlCopyMemory(
             PurgeRequest->CredentialBlob.Buffer,
             CredBlob.Buffer,
             CredBlob.MaximumLength 
             );
      
        printf("Purging SC creds\n");
    
        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    PurgeRequest,
                    RequestSize,
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }                      
    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (CacheResponse != NULL)
    {
        LsaFreeReturnBuffer(CacheResponse);
    }
}

VOID
TestGetTicketRoutine(
    IN LPWSTR TargetName,
    IN LPWSTR OPTIONAL UserName,
    IN LPWSTR OPTIONAL DomainName,
    IN LPWSTR OPTIONAL Password,
    IN ULONG Flags
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;
    CredHandle Credentials = {0};
    BOOLEAN UseCreds = FALSE;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }


    //
    // Get a cred handle if we need one
    //

    if ((UserName != NULL) ||
        (DomainName != NULL) ||
        (Password != NULL))
    {
        if (!GetCredentialsHandle(
                &Credentials,
                MICROSOFT_KERBEROS_NAME_W,
                UserName,
                DomainName,
                Password,
                SECPKG_CRED_OUTBOUND
                ))
        {
            printf("Failed to get creds\n");
            return;
        }
        UseCreds = TRUE;
    }
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};

        RtlInitUnicodeString(
            &Target2,
            TargetName
            );




        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;
        CacheRequest->CacheOptions = Flags;
        if (UseCreds)
        {
            CacheRequest->CacheOptions |= KERB_RETRIEVE_TICKET_USE_CREDHANDLE;
            CacheRequest->CredentialsHandle = Credentials;
        }

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            printf("Cached Ticket:\n");
            printf("ServiceName: "); PrintKdcName(CacheResponse->Ticket.ServiceName);
            printf("TargetName: "); PrintKdcName(CacheResponse->Ticket.TargetName);
            printf("DomainName: %wZ\n",&CacheResponse->Ticket.DomainName);
            printf("TargetDomainName: %wZ\n",&CacheResponse->Ticket.TargetDomainName);
            printf("ClientDomainName: %wZ\n", &CacheResponse->Ticket.AltTargetDomainName);
            printf("ClientName: "); PrintKdcName(CacheResponse->Ticket.ClientName);
            printf("TicketFlags: 0x%x\n",CacheResponse->Ticket.TicketFlags);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("EndTime: ",CacheResponse->Ticket.EndTime);
            PrintTime("RenewUntil: ",CacheResponse->Ticket.RenewUntil);
            PrintTime("TimeSkew: ",CacheResponse->Ticket.TimeSkew);
            LsaFreeReturnBuffer(CacheResponse);

        }

    }
    if (UseCreds)
    {
        FreeCredentialsHandle(&Credentials);
    }
}

#include <ntmsv1_0.h>
VOID
TestChangeCachedPassword(
    IN LPWSTR AccountName,
    IN LPWSTR DomainName,
    IN LPWSTR NewPassword
    )
{
    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    HANDLE LogonHandle = NULL;
    ULONG Dummy;
    ULONG RequestSize = 0;
    ULONG PackageId = 0;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus = STATUS_SUCCESS, Status = STATUS_SUCCESS;
    BOOLEAN Trusted = TRUE;
    BOOLEAN WasEnabled;
    PBYTE Where;
    STRING Name;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }




    RtlInitString(
        &Name,
        MSV1_0_PACKAGE_NAME
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }


    RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                ((ULONG) wcslen(AccountName) +
                 (ULONG) wcslen(DomainName) +
                 (ULONG) (wcslen(NewPassword) + 3) * sizeof(WCHAR));

    Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT,RequestSize);

    Where = (PBYTE) (Request + 1);
    Request->MessageType = MsV1_0ChangeCachedPassword;
    wcscpy(
        (LPWSTR) Where,
        DomainName
        );
    RtlInitUnicodeString(
        &Request->DomainName,
        (LPWSTR) Where
        );
    Where += Request->DomainName.MaximumLength;

    wcscpy(
        (LPWSTR) Where,
        AccountName
        );
    RtlInitUnicodeString(
        &Request->AccountName,
        (LPWSTR) Where
        );
    Where += Request->AccountName.MaximumLength;

    wcscpy(
        (LPWSTR) Where,
        NewPassword
        );
    RtlInitUnicodeString(
        &Request->NewPassword,
        (LPWSTR) Where
        );
    Where += Request->NewPassword.MaximumLength;

    //
    // Make the call
    //

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                Request,
                RequestSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );

    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("changepass failed: 0x%x, 0x%x\n",Status, SubStatus);
    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }
}

VOID
TestChangePasswordRoutine(
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    )
{
#if 1

    NTSTATUS Status;

    Status = KerbChangePasswordUser(
                DomainName,
                UserName,
                OldPassword,
                NewPassword
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to change password: 0x%x\n",Status);
    }
    else
    {
        printf("Change password succeeded\n");
    }
#else
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    printf("Changing password for %wZ@%wZ from %wZ to %wZ\n",
        &ChangeRequest->AccountName,
        &ChangeRequest->DomainName,
        &ChangeRequest->OldPassword,
        &ChangeRequest->NewPassword
        );
    ChangeRequest->Impersonating = TRUE;

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
    }


    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }
#endif
}

VOID
TestSetPasswordRoutine(
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR NewPassword
    )
{
#if 1

    NTSTATUS Status;

    Status = KerbSetPasswordUser(
                DomainName,
                UserName,
                NewPassword,
                NULL
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set password: 0x%x\n",Status);
    }
    else
    {
        printf("Set password succeeded\n");
    }
#else

    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;
    PKERB_SETPASSWORD_REQUEST SetRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_SETPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    NewPass.Length ;
    SetRequest = (PKERB_SETPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    SetRequest->MessageType = KerbSetPasswordMessage;

    SetRequest->AccountName = User;
    SetRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_SETPASSWORD_REQUEST) + (PBYTE) SetRequest,4);

    RtlCopyMemory(
        SetRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    SetRequest->DomainName = Domain;
    SetRequest->DomainName.Buffer = SetRequest->AccountName.Buffer + SetRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );


    SetRequest->Password = NewPass;
    SetRequest->Password.Buffer = SetRequest->DomainName.Buffer + SetRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->Password.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    printf("Setting password for %wZ@%wZ to %wZ\n",
        &SetRequest->AccountName,
        &SetRequest->DomainName,
        &SetRequest->Password
        );

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                SetRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
    }


    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }
#endif
}

/*
#define KERB_REQUEST_ADD_CREDENTIAL     1
#define KERB_REQUEST_REPLACE_CREDENTIAL 2
#define KERB_REQUEST_REMOVE_CREDENTIAL  4
*/

#define KERB_TEST_REGISTER  0x10
/*
VOID
TestRegisterMultiCred(
        LPWSTR MachineName,
        LPWSTR Domain,
        LPWSTR Password,
        ULONG Flags
        )
{


    SERVER_TRANSPORT_INFO_2   sti2 = {0};

    CHAR                      netBiosName[ NETBIOS_NAME_LEN ];
    OEM_STRING                netBiosNameString;
    UNICODE_STRING            unicodeName;
    NET_API_STATUS            status;
    NTSTATUS                  ntStatus;

       
    LPSERVER_TRANSPORT_INFO_0 pBuf = NULL;
    LPSERVER_TRANSPORT_INFO_0 pTmpBuf;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD dwResumeHandle = 0;
    DWORD i = 0;
    DWORD dwTotalCount = 0;

    PKERB_ADD_CREDENTIALS_REQUEST AddCredRequest = NULL;
    ULONG Buffsize =  sizeof(KERB_ADD_CREDENTIALS_REQUEST);
    UNICODE_STRING Target2 = {0};


    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus = STATUS_SUCCESS, Status = STATUS_SUCCESS;
    BOOLEAN Trusted = TRUE;
    BOOLEAN WasEnabled;
    HANDLE LogonHandle = NULL;
    ULONG Dummy;
    ULONG PackageId;
    STRING Name;
    PBYTE Where;






    if ((Flags & KERB_TEST_REGISTER) != 0)
    {
        printf("Adding Netbios transport\n");

        RtlInitUnicodeString( &unicodeName, MachineName );
    
        netBiosNameString.Buffer = (PCHAR)netBiosName;
        netBiosNameString.MaximumLength = sizeof( netBiosName );
        
        ntStatus = RtlUpcaseUnicodeStringToOemString(
                       &netBiosNameString,
                       &unicodeName,
                       FALSE
                       );
        
        if (ntStatus != STATUS_SUCCESS) {
            printf("String conversion failed - %x\n", ntStatus);
            return;
        }      
        
    
        //
        // Enum, and change, existing transports.
        //
        do
        {
    
            status = NetServerTransportEnum(NULL,
                                             0,
                                             (LPBYTE *) &pBuf,
                                             MAX_PREFERRED_LENGTH,
                                             &dwEntriesRead,
                                             &dwTotalEntries,
                                             &dwResumeHandle);
            //
            // If the call succeeds,
            //
            if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
            {
                if ((pTmpBuf = pBuf) != NULL)
                 {
                    //
                    // Loop through the entries;
                    //  process access errors.
                    //
                    for (i = 0; i < dwEntriesRead; i++)
                    {  
                        sti2.svti2_transportaddress = (LPBYTE) netBiosName;
                        sti2.svti2_transportaddresslength = strlen(netBiosName);
                        sti2.svti2_transportname = pTmpBuf->svti0_transportname;
                        
                        status = NetServerTransportAddEx( NULL, 2, (LPBYTE)&sti2 );
    
                        if (status)
                        {
                            printf("NetServerTransportAddEx failed - %x\n", status);
                        } 
                       
                        //
                       // Print the transport protocol name. 
                       //
                       wprintf(L"\tTransport: %s\n", pTmpBuf->svti0_transportname);
        
                       pTmpBuf++;
                       dwTotalCount++;
                    }
                 }
              }
              //
              // Otherwise, indicate a system error.
              //
              else
                 printf("A system error has occurred: %d\n", status);
        
              //
              // Free the allocated buffer.
              //
              if (pBuf != NULL)
              {
                 NetApiBufferFree(pBuf);
                 pBuf = NULL;
              }
                     
        }
        while (status == ERROR_MORE_DATA); // end do

  
    }


    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    Buffsize += (sizeof(WCHAR) * ( wcslen(MachineName) + wcslen(Domain) + wcslen(Password) + 3));
    AddCredRequest = (PKERB_ADD_CREDENTIALS_REQUEST) LocalAlloc(LMEM_ZEROINIT,Buffsize); 

    if (NULL == AddCredRequest)
    {
        return;
    }    

    AddCredRequest->MessageType = KerbAddExtraCredentialsMessage;

    RtlInitUnicodeString(
        &Target2,
        MachineName
        );


    AddCredRequest->UserName.Buffer = (LPWSTR) (AddCredRequest + 1);
    AddCredRequest->UserName.Length = Target2.Length;
    AddCredRequest->UserName.MaximumLength = Target2.MaximumLength;

    RtlCopyMemory(
        AddCredRequest->UserName.Buffer,
        Target2.Buffer,
        Target2.MaximumLength
        );

    RtlInitUnicodeString(
        &Target2,
        Domain
        );


    
    Where = ((PBYTE) AddCredRequest->UserName.Buffer) + AddCredRequest->UserName.MaximumLength;

    AddCredRequest->DomainName.Buffer = (LPWSTR) Where;
    AddCredRequest->DomainName.Length = Target2.Length;
    AddCredRequest->DomainName.MaximumLength = Target2.MaximumLength;
    
    RtlCopyMemory(
        AddCredRequest->DomainName.Buffer,
        Target2.Buffer,
        Target2.MaximumLength
        );


    RtlInitUnicodeString(
        &Target2,
        Password
        );                                            

    Where += AddCredRequest->DomainName.MaximumLength;

    AddCredRequest->Password.Buffer = (LPWSTR) Where;
    AddCredRequest->Password.Length = Target2.Length;
    AddCredRequest->Password.MaximumLength = Target2.MaximumLength;
    
    RtlCopyMemory(
        AddCredRequest->Password.Buffer,
        Target2.Buffer,
        Target2.MaximumLength
        );

    AddCredRequest->Flags = Flags;
    
    printf("Updating second creds: u %wZ, d %wZ, p %wZ\n",
           &AddCredRequest->UserName, &AddCredRequest->DomainName, &AddCredRequest->Password );

    Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    AddCredRequest,
                    Buffsize,
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
    }


    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    return;

}   */
                                                               
PVOID
KdcAllocate(SIZE_T size)
{
    return LocalAlloc( 0, size );
}

VOID
KdcFree(PVOID buff)
{
    LocalFree( buff );
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;
    LPSTR UserName = NULL,DomainName = NULL,Password = NULL, Package = MICROSOFT_KERBEROS_NAME_A;
    LPWSTR DomainNameW = NULL;
    LPWSTR UserNameW = NULL;
    LPWSTR PasswordW = NULL;
    LPWSTR OldPasswordW = NULL;
    LPWSTR ServerDomainName = NULL;
    LPWSTR ServerUserName = NULL;
    LPWSTR ServerPassword = NULL;
    LPWSTR TargetName = NULL;
    LPWSTR PackageName = NULL;
    LPWSTR PackageFunction = NULL;
    LPWSTR PackageList = NULL;
    ULONG ContextReq = 0;
    ULONG CredFlags = 0;
    BOOLEAN Relogon = FALSE;
    SECURITY_LOGON_TYPE LogonType = Interactive;

    enum {
        NoAction,
#define USER_PARAM "/user:"
#define DOMAIN_PARAM "/domain:"
#define PASSWORD_PARAM "/password:"
#define CHANGE_PASSWORD_PARAM "/changepass:"
        ChangePassword,
#define SET_PASSWORD_PARAM "/setpass"
        SetPassword,
#define CHANGE_CACHED_PASSWORD_PARAM "/cache"
        ChangeCachedPassword,
#define SERVER_USER_PARAM "/serveruser:"
#define SERVER_DOMAIN_PARAM "/serverdomain:"
#define SERVER_PASSWORD_PARAM "/serverpassword:"
#define TARGET_PARAM "/target:"
#define PACKAGENAME_PARAM "/package:"
#define PACKAGELIST_PARAM "/packagelist:"
#define ANSI_PARAM "/ansi"
#define FLAG_PARAM "/flags:"
#define RECURSE_PARAM "/recurse:"
#define SYSTEM_PARAM "/system"
#define TESTSSP_PARAM "/TestSsp"
        TestSsp,
#define LOGON_PARAM2 "/Logon:"
#define LOGON_PARAM "/Logon"
        TestLogon,
#define PACKAGE_PARAM "/callpackage:"
#define PACKAGE_PARAM2 "/cp:"
        TestPackage,
#define BATCH_PARAM "/batch"
#define RELOGON_PARAM "/relogon"
#define NOPAC_PARAM "/nopac"
#define GETTICKET_PARAM "/ticket:"
        TestGetTicket,
#define TIME_PARAM "/time:"
#define S4ULOGON_PARAM "/S4U:"
        TestS4ULogon,
#define ISC_PARAM "/ISC:"
        QuickISCTest, 
#define DUMPTOKEN_PARAM "/DUMPTOKEN:"
#define CONVERT_PARAM "/CONVERT:"
        Convert           
    } Action = NoAction;

    SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT, SAFEALLOCA_USE_DEFAULT, KdcAllocate, KdcFree);

    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /ConfigureService
        //
        if ( _stricmp( argument, ANSI_PARAM ) == 0 ) {
            DoAnsi = TRUE;
        } else if ( _stricmp( argument, TESTSSP_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;
            Iterations = 1;

        } else if ( _strnicmp( argument,
                              USER_PARAM,
                              sizeof(USER_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(USER_PARAM)-1];
            UserNameW = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              DOMAIN_PARAM,
                              sizeof(DOMAIN_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(DOMAIN_PARAM)-1];
            DomainNameW = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              PASSWORD_PARAM,
                              sizeof(PASSWORD_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(PASSWORD_PARAM)-1];
            PasswordW = NetpAllocWStrFromStr( argument );


        } else if ( _strnicmp( argument,
                              SERVER_USER_PARAM,
                              sizeof(SERVER_USER_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(SERVER_USER_PARAM)-1];
            ServerUserName = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              SERVER_DOMAIN_PARAM,
                              sizeof(SERVER_DOMAIN_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(SERVER_DOMAIN_PARAM)-1];
            ServerDomainName = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              SERVER_PASSWORD_PARAM,
                              sizeof(SERVER_PASSWORD_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(SERVER_PASSWORD_PARAM)-1];
            ServerPassword = NetpAllocWStrFromStr( argument );


        } else if ( _strnicmp( argument,
                              TARGET_PARAM,
                              sizeof(TARGET_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(TARGET_PARAM)-1];
            TargetName = NetpAllocWStrFromStr( argument );


        } else if ( _strnicmp( argument,
                              PACKAGENAME_PARAM,
                              sizeof(PACKAGENAME_PARAM)-1 ) == 0 ){

            Package = &argument[sizeof(PACKAGENAME_PARAM)-1];
            PackageName = NetpAllocWStrFromStr( Package );


        } else if (_strnicmp(argument,
                            TIME_PARAM,
                            sizeof(TIME_PARAM)-1 ) == 0 ){
            char *end;
            LARGE_INTEGER ConvertTime;
            LONGLONG Time;


            ConvertTime.LowPart = strtoul( &argument[sizeof(TIME_PARAM)-1], &end, 16 );
            i++;
            argument = argv[i];

            ConvertTime.HighPart = strtoul( argument, &end, 16 );

            Time = ConvertTime.QuadPart / 10000000;
            if (Time < 60)
            {
                printf("time : %d seconds\n", (LONG) Time);
            }
            else
            {
                Time = Time / 60;
                if (Time < 60)
                {
                    printf("time : %d minutes\n", (LONG) Time);
                }
                else
                {
                    Time = Time / 60;
                    if (Time < 24)
                    {
                        printf("time: %d hours\n", (LONG) Time);
                    }
                    else
                    {
                        Time = Time / 24;
                        printf("time: %d days\n",(LONG) Time);
                    }
                }
            }

        } else if ( _strnicmp( argument,
                              FLAG_PARAM,
                              sizeof(FLAG_PARAM)-1 ) == 0 ){

            sscanf(&argument[sizeof(FLAG_PARAM)-1], "%x",&ContextReq);

        } else if ( _strnicmp( argument,
                              RECURSE_PARAM,
                              sizeof(RECURSE_PARAM)-1 ) == 0 ){

            sscanf(&argument[sizeof(RECURSE_PARAM)-1], "%d",&MaxRecursionDepth);

        } else if ( _strnicmp( argument,
                              PACKAGELIST_PARAM,
                              sizeof(PACKAGELIST_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(PACKAGELIST_PARAM)-1];
            PackageList = NetpAllocWStrFromStr( argument );


        } else if (_strnicmp( argument,
                              BATCH_PARAM,
                              sizeof(BATCH_PARAM) - 1) == 0) {
            LogonType = Batch;
        } else if (_strnicmp( argument,
                              DUMPTOKEN_PARAM,
                              sizeof(DUMPTOKEN_PARAM) - 1) == 0) {
            DumpToken = TRUE;

        } else if (_strnicmp( argument,
                              RELOGON_PARAM,
                              sizeof(RELOGON_PARAM) - 1) == 0) {
            Relogon = TRUE;
        } else if (_strnicmp( argument,
                              NOPAC_PARAM,
                              sizeof(NOPAC_PARAM) - 1) == 0) {
            CredFlags |= SEC_WINNT_AUTH_IDENTITY_ONLY;
        } else if (_strnicmp( argument,
                              SYSTEM_PARAM,
                              sizeof(SYSTEM_PARAM) - 1) == 0) {
            HANDLE hWinlogon = NULL;
            HANDLE SystemToken = NULL;
            hWinlogon = FindAndOpenWinlogon();

            if ( OpenProcessToken(
                        hWinlogon,
                        WRITE_DAC,
                        &SystemToken ) )
            {
                SECURITY_DESCRIPTOR EmptyDacl;
                RtlZeroMemory(
                    &EmptyDacl,
                    sizeof(SECURITY_DESCRIPTOR)
                    );
                InitializeSecurityDescriptor(
                    &EmptyDacl,
                    SECURITY_DESCRIPTOR_REVISION
                    );
                SetSecurityDescriptorDacl(
                    &EmptyDacl,
                    FALSE,
                    NULL,
                    FALSE
                    );
                if (!SetKernelObjectSecurity(
                        SystemToken,
                        DACL_SECURITY_INFORMATION,
                        &EmptyDacl))
                {
                    printf("Failed to set token dacl: %d\n",GetLastError());
                    return(0);
                }
                CloseHandle(SystemToken);
            }
            if ( OpenProcessToken(
                        hWinlogon,
                        TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                        &SystemToken ) )
            {
                ImpersonateLoggedOnUser(SystemToken);
                CloseHandle(SystemToken);
            }
            else
            {
                printf("Failed to get system token: %d\n",GetLastError());
                return(0);
            }
            CloseHandle(hWinlogon);

        } else if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLogon;
            Iterations = 1;
            if ( _strnicmp( argument, LOGON_PARAM2, sizeof(LOGON_PARAM2)-1 ) == 0 ) {
                sscanf(&argument[sizeof(LOGON_PARAM2)-1], "%x",&Iterations);

            }

            if (argc < i + 2)
            {
                goto Usage;
            }

            UserName = argv[++i];
            Password = argv[++i];
            if (i < argc)
            {
                DomainName = argv[++i];
            }
            else
            {
                DomainName = NULL;
            }
        } else if (( _strnicmp( argument, PACKAGE_PARAM, sizeof(PACKAGE_PARAM) - 1 ) == 0 ) ||
                   ( _strnicmp( argument, PACKAGE_PARAM2, sizeof(PACKAGE_PARAM2) - 1 ) == 0 )) {
          
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(PACKAGE_PARAM)-1];
            PackageFunction = NetpAllocWStrFromStr( argument );

            Action = TestPackage;
        } else if ( _strnicmp( argument, GETTICKET_PARAM, sizeof(GETTICKET_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(GETTICKET_PARAM)-1];
            PackageFunction = NetpAllocWStrFromStr( argument );

            Action = TestGetTicket;
        } else if ( _strnicmp( argument, CHANGE_PASSWORD_PARAM, sizeof(CHANGE_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(CHANGE_PASSWORD_PARAM)-1];
            OldPasswordW = NetpAllocWStrFromStr( argument );

            Action = ChangePassword;
        } else if ( _strnicmp( argument, SET_PASSWORD_PARAM, sizeof(SET_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            Action = SetPassword;
        } else if ( _strnicmp( argument, CHANGE_CACHED_PASSWORD_PARAM, sizeof(CHANGE_CACHED_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            Action = ChangeCachedPassword;
        } else if (_stricmp( argument, S4ULOGON_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }


            Action = TestS4ULogon;
            Iterations = 1;
            UserName = argv[++i];

            if (i < argc)
                {
                DomainName = argv[++i];
            }
            else
                {
                DomainName = NULL;
            }
        } else if (_strnicmp( argument, ISC_PARAM,sizeof(ISC_PARAM)-1 ) == 0 )
        {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = QuickISCTest; 

            argument = &argument[sizeof(ISC_PARAM)-1];
            TargetName = NetpAllocWStrFromStr( argument );
            

        } 
        else if (_strnicmp( argument, CONVERT_PARAM,sizeof(CONVERT_PARAM)-1 ) == 0 )
        {
            if ( Action != NoAction ) {
                goto Usage;
            }
    
            sscanf(&argument[sizeof(FLAG_PARAM)-1], "%x",&ContextReq);
            printf("%x", ContextReq);
            Action = Convert; 



        } 
        else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }


    }

    //
    // Perform the action requested
    //

    switch ( Action ) {
    
    case TestSsp:
        for ( j=0; j<Iterations ; j++ ) {
            TestSspRoutine(
                PackageName,
                UserNameW,
                DomainNameW,
                PasswordW,
                ServerUserName,
                ServerDomainName,
                ServerPassword,
                TargetName,
                PackageList,
                ContextReq,
                CredFlags
                );
        }
        break;
    case TestPackage:
        TestCallPackageRoutine(PackageFunction);
        break;

    case TestLogon :
        TestLogonRoutine(
            Iterations,
            Relogon,
            LogonType,
            Package,
            UserName,
            DomainName,
            Password
            );
        break;

    case TestS4ULogon :
        TestS4ULogonRoutine(
            UserName,
            DomainName
            );
        break;

    case ChangePassword :
        TestChangePasswordRoutine(
            UserNameW,
            DomainNameW,
            OldPasswordW,
            PasswordW
            );
        break;

    case ChangeCachedPassword :
        TestChangeCachedPassword(
            UserNameW,
            DomainNameW,
            PasswordW
            );
        break;

    case SetPassword :
        TestSetPasswordRoutine(
            UserNameW,
            DomainNameW,
            PasswordW
            );
        break;
    case TestGetTicket :
        TestGetTicketRoutine(
            PackageFunction,
            UserNameW,
            DomainNameW,
            PasswordW,
            ContextReq
            );
        break;

    case QuickISCTest:
        TestQuickISC(
            TargetName
            );
        break;
    case Convert:
        printf("%x", (ContextReq >> 26));


    }
    return 0;
Usage:
    printf("%s /logon username password [domainname]\n",argv[0]);
    printf("%s /testssp [/package:pacakgename] [/target:targetname]\n", argv[0]); 
    printf("\t[/user:username]  [/domain:user domain] [/password: client password]\n", argv[0]);
    printf("\t[/serveruser:username] [/serverdomain:server domain] \n");
    printf("\t[/serverpassword:server password] [/dumptoken] [/system]\n");
    printf("%s /s4u: clientname [domain] [/dumptoken] [/system]\n", argv[0]);
    printf("%s /callpackage:[purge:SPN | retrieve:SPN | binding:dc@domain] \n", argv[0]);
    printf("\t[/system]\n");
    printf("%s /ticket:SPN\n", argv[0]);

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\utest\scperfrm\scperf.cpp ===
/*--

  Copyright (c) 1987-1998  Microsoft Corporation
  
    Module Name:
    
      sclogon.cxx
      
        Abstract:
        
          Test program for Smart Card Logon
          
            Author:
            
              28-Jun-1993 (cliffv)
              
                Environment:
                
                  User mode only.
                  Contains NT-specific code.
                  Requires ANSI C extensions: slash-slash comments, long external names.
                  
                    Revision History:
                    
                      29-Oct-1998 (larrywin)
                      
--*/


//
// Common include files.
//

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <stddef.h>		// 'offset' macro

#include <windows.h>
#include <winnls.h>
#include <iostream.h>
#include <winioctl.h>
#include <tchar.h>
#include <string.h>

}
#include <wchar.h>
#include <conio.h>
#include <ctype.h>

extern "C" {
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <negossp.h>
#include <wincrypt.h>
#include <cryptui.h>
}
#include <sclogon.h>
#include <winscard.h>
//#include <log.h>

#define MAX_RECURSION_DEPTH 1
#define BUFFERSIZE 200

BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
LPWSTR g_wszReaderName = new wchar_t[BUFFERSIZE];
// file handle for output file
//FILE            *outstream;

/*++

PrintMessage:

    Simple function to dump text to standard output.
	
    Arguments:

    lpszFormat - String to dump to standard output
	
--*/

void _cdecl 
PrintMessage(
    IN LPSTR lpszFormat, ...)
{
    //
    // Helper to do print traces...
    //

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    char szBuffer[512];
    ZeroMemory(szBuffer, sizeof(szBuffer));

    nBuf = _vstprintf(szBuffer, lpszFormat, args);

    _tprintf(szBuffer);
//    fprintf(outstream, "%s", szBuffer);

//    OutputDebugStringA(szBuffer);
    va_end(args);
}


/*++

  BuildLogonInfo:
  GetReaderName:
  GetCardName:
  GetContainerName:
  GetCSPName:
  
    : Intended for accessing the LogonInformation glob
    
      Author:
      
        Amanda Matlosz
        
          Note:
          
            Some of these are made available to outside callers; see sclogon.h
            
--*/
PBYTE
BuildSCLogonInfo(
                 LPCTSTR szCard,
                 LPCTSTR szReader,
                 LPCTSTR szContainer,
                 LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.
    
    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");
    
    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }
    
    //
    // Build the LogonInfo glob using strings (or empty strings)
    //
    
    DWORD cbLi = offsetof(LogonInfo, bBuffer)
        + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
        + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
        + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
        + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);
    
    if (NULL == pLI)
    {
        return NULL;
    }
    
    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;
    
    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);
    
    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);
    
    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);
    
    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);
    
    //    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}

LPTSTR ErrorString( IN DWORD dwError ) 
{
    DWORD dwLen = 0;
    LPTSTR szErrorString = NULL;

    dwLen = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        (DWORD)dwError,
        LANG_NEUTRAL,
        (LPTSTR)&szErrorString,
        0,
        NULL);

    return szErrorString;
}


HANDLE
FindAndOpenWinlogon(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    NTSTATUS Status ;
    UNICODE_STRING Winlogon ;
    HANDLE Process ;

    SystemInfo = (PSYSTEM_PROCESS_INFORMATION)LocalAlloc( LMEM_FIXED, sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024 );

    if ( !SystemInfo )
    {
        return NULL ;
    }

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                SystemInfo,
                sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
                NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    RtlInitUnicodeString( &Winlogon, L"winlogon.exe" );

    Walk = SystemInfo ;

    while ( RtlCompareUnicodeString( &Walk->ImageName, &Winlogon, TRUE ) != 0 )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        LocalFree( SystemInfo );
        return NULL ;
    }

    Process = OpenProcess( PROCESS_QUERY_INFORMATION,
                           FALSE,
                           HandleToUlong(Walk->UniqueProcessId) );

    LocalFree( SystemInfo );

    return Process ;


}

NTSTATUS
TestScLogonRoutine(
                   IN ULONG Count,
                   IN LPSTR Pin
                   )
{
    NTSTATUS Status;
    PKERB_SMART_CARD_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_SMART_CARD_LOGON);
    BOOLEAN WasEnabled;
    STRING PinString;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ScHandle = NULL;
    PBYTE ScLogonInfo = NULL;
    ULONG ScLogonInfoSize;
    ULONG WaitResult = 0;
    SCARDCONTEXT hContext = NULL;
    LONG lCallReturn = -1;
    LPTSTR szReaders = NULL;
    LPTSTR pchReader = NULL;
    LPTSTR mszCards = NULL;
    LPTSTR szLogonCard = NULL;
    LPTSTR szCSPName = NULL;
    BYTE bSLBAtr[] = {0x3b,0xe2,0x00,0x00,0x40,0x20,0x49,0x06};
    BYTE bGEMAtr[] = {0x3b,0x27,0x00,0x80,0x65,0xa2,0x00,0x01,0x01,0x37};
    DWORD dwReadersLen = SCARD_AUTOALLOCATE;
    DWORD dwCardsLen = SCARD_AUTOALLOCATE;
    DWORD dwCSPLen = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderStates[MAXIMUM_SMARTCARD_READERS]; // not necessarily max for pnp readers
    LONG nIndex;
    LONG nCnReaders;
    BOOL fFound = FALSE;
	SYSTEMTIME StartTime, DoneTime;
	SYSTEMTIME		stElapsed;
	FILETIME		ftStart, ftDone,
		*pftStart = &ftStart,
		*pftDone  = &ftDone;
	LARGE_INTEGER	liStart, liDone,
		*pliStart = &liStart,
		*pliDone  = &liDone;
	LARGE_INTEGER liAccumulatedTime, liSplitTime,
		*pliAccumulatedTime = &liAccumulatedTime,
		*pliSplitTime = &liSplitTime;
	FILETIME ftAccumulatedTime,
		*pftAccumulatedTime   = &ftAccumulatedTime;
	SYSTEMTIME stAccumulatedTime;
	LPWSTR buffer = new wchar_t[BUFFERSIZE];
	int j;
	memset(buffer, 0, BUFFERSIZE);
		
	liAccumulatedTime.QuadPart = 0;
    
    // get a ResMgr context
    lCallReturn = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hContext);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to initialize context: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // list all readers
    lCallReturn = SCardListReaders(hContext, SCARD_ALL_READERS, (LPTSTR)&szReaders, &dwReadersLen);
    if (SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to list readers on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else if ((0 == dwReadersLen)
        || (NULL == szReaders)
        || (0 == *szReaders))
    {
        lCallReturn = SCARD_E_UNKNOWN_READER;   // Or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
		swprintf(buffer, L"Failed to identify a reader on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // list cards
    lCallReturn = SCardListCards(hContext, NULL, NULL, 0, (LPTSTR)&mszCards, &dwCardsLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        printf("Failed to list cards in the system: 0x%x\n", lCallReturn);
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to identify a card on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // use the list of readers to build a readerstate array
    nIndex = 0;
    if (0 != wcslen(g_wszReaderName)) {
        // use the reader specified in the command line
        rgReaderStates[nIndex].szReader = (const unsigned short *)g_wszReaderName;
        rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
        nCnReaders = 1;
    } else {
        pchReader = szReaders;
        while (0 != *pchReader)
        {
            rgReaderStates[nIndex].szReader = pchReader;
            rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
            pchReader += lstrlen(pchReader)+1;
            nIndex++;
            if (MAXIMUM_SMARTCARD_READERS == nIndex)
                break;
        }
        nCnReaders = nIndex;
    }
    
    // find a reader with one of the listed cards, or the specified card, present
    lCallReturn = SCardLocateCards(hContext, mszCards, rgReaderStates, nCnReaders);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to locate a smart card for logon: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // find the reader containing the requested card
    for (nIndex=0; nIndex<nCnReaders && FALSE == fFound; nIndex++) {
        if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_ATRMATCH) {
            // reader found
            fFound = TRUE;
            break;
        }
    }
    if (FALSE == fFound) {
        lCallReturn = SCARD_E_NO_SMARTCARD; // or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"No smart card in any reader: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else { // get the name of the card found
        dwCardsLen = SCARD_AUTOALLOCATE;
        lCallReturn = SCardListCards(hContext, rgReaderStates[nIndex].rgbAtr, NULL, 0, (LPTSTR)&szLogonCard, &dwCardsLen);
        if ( SCARD_S_SUCCESS != lCallReturn ) {
            if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
            if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
            if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
			swprintf(buffer, L"Failed to get name of card in reader: 0x%x\n", lCallReturn);
            PrintMessage("%S",buffer);
			memset(buffer, 0, sizeof(buffer));
            return (NTSTATUS)lCallReturn;
        }
    }
    
    // get the csp provider name for the card
    lCallReturn = SCardGetCardTypeProviderName(hContext, szLogonCard, SCARD_PROVIDER_CSP, (LPTSTR)&szCSPName, &dwCSPLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
        if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
        if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
		swprintf(buffer, L"Failed to locate smart card crypto service provider: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    ScLogonInfo = BuildSCLogonInfo(szLogonCard,
        rgReaderStates[nIndex].szReader,
        TEXT(""), // use default container
        szCSPName
        );
    
    //
    // We should now have logon info.
    //
    if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
    if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
    if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
    if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
    
//    j =  swprintf(buffer, L"Reader : %s\n", GetReaderName(ScLogonInfo));
//    j += swprintf(buffer + j, L"Card   : %s\n", GetCardName(ScLogonInfo));
//    j += swprintf(buffer + j, L"CSP    : %s\n", GetCSPName(ScLogonInfo));
//    PrintMessage("%S",buffer);
//	memset(buffer, 0, sizeof(buffer));

	// perform sclogon
    if (ScLogonInfo == NULL)
    {
        swprintf(buffer, L"Failed to get logon info!\n");
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS) -1;
    }
    
    ScLogonInfoSize = ((struct LogonInfo *) ScLogonInfo)->dwLogonInfoLen;
    
    Status = ScHelperInitializeContext(
        ScLogonInfo,
        ScLogonInfoSize
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to initialize helper context: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    ScHelperRelease(ScLogonInfo);
    
    RtlInitString(
        &PinString,
        Pin
        );
    
    
    LogonInfoSize += (PinString.Length+1 ) * sizeof(WCHAR) + ScLogonInfoSize;
    
    LogonInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    
    LogonInfo->MessageType = KerbSmartCardLogon;
    
    
    Where = (PUCHAR) (LogonInfo + 1);
    
    LogonInfo->Pin.Buffer = (LPWSTR) Where;
    LogonInfo->Pin.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Pin,
        &PinString,
        FALSE
        );
    Where += LogonInfo->Pin.Length + sizeof(WCHAR);
    
    LogonInfo->CspDataLength = ScLogonInfoSize;
    LogonInfo->CspData = Where;
    RtlCopyMemory(
        LogonInfo->CspData,
        ScLogonInfo,
        ScLogonInfoSize
        );
    Where += ScLogonInfoSize;
    
    //
    // Turn on the TCB privilege
    //
    
    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to adjust privilege: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }

    RtlInitString(
        &Name,
        "SmartCardLogon"
        );
    Status = LsaRegisterLogonProcess(
        &Name,
        &LogonHandle,
        &Dummy
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to register as a logon process: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    strncpy(
        SourceContext.SourceName,
        "SmartCardLogon        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );
    
    
    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
        LogonHandle,
        &Name,
        &PackageId
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to lookup package %Z: 0x%x\n",&Name, Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    //
    // Now call LsaLogonUser
    //
    
    RtlInitString(
        &Name,
        "SmartCardLogon"
        );

    for (Index = 1; Index <= Count ; Index++ )
    {
        swprintf(buffer, L" %.6d : ", Index);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

		// get start time
		GetSystemTime(&StartTime);
        
        Status = LsaLogonUser(
            LogonHandle,
            &Name,
            Interactive,
            PackageId,
            LogonInfo,
            LogonInfoSize,
            NULL,           // no token groups
            &SourceContext,
            (PVOID *) &Profile,
            &ProfileSize,
            &LogonId,
            &TokenHandle,
            &Quotas,
            &SubStatus
            );

		// get done time
		GetSystemTime(&DoneTime);

		// convert systemtime to filetime
		SystemTimeToFileTime(&StartTime, &ftStart);
		SystemTimeToFileTime(&DoneTime, &ftDone);
		
		// copy filetime to large int
		CopyMemory(pliStart, pftStart, 8);
		CopyMemory(pliDone, pftDone, 8);
		
		// diff the large ints and accumulate result
		liDone.QuadPart = liDone.QuadPart - liStart.QuadPart;
		liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart + liDone.QuadPart;
		
		// copy result back to filetime
		CopyMemory(pftDone, pliDone, 8);
		
		// convert result back to systemtime
		FileTimeToSystemTime( (CONST FILETIME *)&ftDone, &stElapsed);
		
		// output the result
		swprintf(buffer, L" %2.2ld m %2.2ld s %3.3ld ms ",
			stElapsed.wMinute,
			stElapsed.wSecond,
			stElapsed.wMilliseconds);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

        if (!NT_SUCCESS(Status))
        {
            j = swprintf(buffer, L" : lsalogonuser failed 0x%x\n",Status);
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            goto fail;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            j = swprintf(buffer, L" : lsalogonUser failed substatus = 0x%x\n",SubStatus);
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            goto fail;
        }
        
        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        j = swprintf(buffer, L": %ws logon success\n",UserNameString);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        RevertToSelf();
        NtClose(TokenHandle);
        
        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

fail :
        // report average every 10th logon
		if (0 == Index % 10) {
			liSplitTime.QuadPart = liAccumulatedTime.QuadPart / Index;
			CopyMemory(pftAccumulatedTime, pliSplitTime, 8);
			FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
			swprintf(buffer, L"Average Time after %d Logons: %2.2ldm:%2.2lds:%3.3ldms\n",
				Index,
				stAccumulatedTime.wMinute,
				stAccumulatedTime.wSecond,
				stAccumulatedTime.wMilliseconds);
            PrintMessage("%S",buffer);
		}

        Sleep(2000); // let card stack unwind
    
    }

	// ouput average results
	if ( 1 != Count ) {
        liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart / Count;
        CopyMemory(pftAccumulatedTime, pliAccumulatedTime, 8);
        FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
        swprintf(buffer, L"\nAverage Logon Time: %2.2ldm:%2.2lds:%3.3ldms\n",
            stAccumulatedTime.wMinute,
            stAccumulatedTime.wSecond,
            stAccumulatedTime.wMilliseconds);
        PrintMessage("%S", buffer);
	}
    return (NTSTATUS)Status;
    
}


VOID
PrintKdcName(
             IN PKERB_INTERNAL_NAME Name
             )
{
    ULONG Index;
    for (Index = 0; Index < Name->NameCount ; Index++ )
    {
        printf(" %wZ ",&Name->Names[Index]);
    }
    printf("\n");
}

int __cdecl
main(
     IN int argc,
     IN char ** argv
     )
     /*++
     
       Routine Description:
       
         Drive the NtLmSsp service
         
           Arguments:
           
             argc - the number of command-line arguments.
             
               argv - an array of pointers to the arguments.
               
                 Return Value:
                 
                   Exit status
                   
                     --*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;
    LPSTR PinBuffer = new char [81];
    LPSTR szReaderBuffer = new char[BUFFERSIZE];
	LPSTR EventMachineBuffer = new char [81];
    LPWSTR wEventMachineBuffer = new wchar_t[81];
    LPWSTR PackageFunction;
    ULONG ContextReq = 0;
    WCHAR ContainerName[100];
    WCHAR CaName[100];
    WCHAR CaLocation[100];
    WCHAR ServiceName[100];
    NTSTATUS Status = -1;
    
    
    enum {
        NoAction,
#define LOGON_PARAM "/p"
            TestLogon,
#define ITERATION_PARAM "/i"
#define HELP_PARAM "/?"
//#define EVENT_PARAM "/s"
#define READER_PARAM "/r"
    } Action = NoAction;

    memset(g_wszReaderName, 0, BUFFERSIZE);
    memset(szReaderBuffer, 0, BUFFERSIZE);

    // open output file
//    outstream = fopen( "scperf.out", "w" );
    
    //
    // Loop through the arguments handle each in turn
    //
    
    if ( 1 == argc ) {// silent mode
        Iterations = 1;
        Action = TestLogon;
        printf("Enter your pin number: ");
        int ch;
        int j = 0;

        ch = _getch();

        while (ch != 0x0d) {
            j += sprintf(PinBuffer + j,"%c", ch);
            printf("*");
            ch = _getch();
        }

        printf("\n");

    }
    
    for ( i=1; i<argc; i++ ) {
        
        argument = argv[i];
        
        //
        // Handle /ConfigureService
        //
        
        if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Iterations = 1;
            Action = TestLogon;
            
            if (argc <= i + 1) {
                goto Usage;
            }

            PinBuffer = argv[++i];

        } else if ( _strnicmp( argument, ITERATION_PARAM, sizeof(ITERATION_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
            
            Iterations = atoi(argv[++i]);

        } /*else if ( _strnicmp( argument, EVENT_PARAM, sizeof(EVENT_PARAM) - 1 ) == 0 ) {
			if (argc <= i + 1) {
                goto Usage;
            }
			// save name of machine to which events will be posted
            EventMachineBuffer = argv[++i];
			wsprintfW(wEventMachineBuffer, L"%S", EventMachineBuffer);
            SetEventMachine(&wEventMachineBuffer);
            //Event(PERF_INFORMATION, L"Trying to set machine name\n", 1);

		} */
        
          else if ( _strnicmp( argument, HELP_PARAM, sizeof(HELP_PARAM) - 1 ) == 0 ) {
            goto Usage;
		} else if ( _strnicmp( argument, READER_PARAM, sizeof(READER_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
			// get the name of a specified reader
            szReaderBuffer = argv[++i];
            wsprintfW(g_wszReaderName, L"%S", szReaderBuffer);
        } else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }
        
        
    }

    //
    // Perform the action requested
    //
    
    switch ( Action ) {
        
    case TestLogon :
        Status = TestScLogonRoutine(
            Iterations,
            PinBuffer
            );
        break;

    case NoAction :
        goto Usage;
        break;
        
    }
    return Status;
Usage:
    PrintMessage("%s - no parameters, manually enter pin\n", argv[0]);
    PrintMessage("   optional parameters (if any used, must have /p)\n");
    PrintMessage("   /p Pin\n");
    PrintMessage("   /i Iterations\n");
//    printf("   /s EventMachineName (post events to this machine)\n");
    PrintMessage("   /r %cReader Name X%c (registry device name in quotes)\n", '"', '"');
    return -1;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created
    25-Jul-96       ChandanS    Copied from net\svcdlls\ntlmssp\client\crc32.c
    27-Jan-07       MikeSw      Incorporated x86 ASM code for performance

--*/

#include "crc32.h"

#ifdef KMODE_NTLM
#ifdef ALLOC_PRAGMA
#pragma alloc_text("PAGEMSG", Crc32)
#endif  // ALLOC_PRAGMA
#endif  // KMODE

//
// This code comes from Dr. Dobbs Journal, May 1992
//


unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


void
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc)
{
  unsigned char * pbBuffer;

#ifdef _X86_
_asm
{
  mov     ecx, DWORD PTR cbBuffer
  shr     ecx, 2
  mov     eax, ecx
  dec     ecx
  mov     esi, DWORD PTR pvBuffer

  mov     edx, DWORD PTR dwCrc
  test    eax, eax
  je      SHORT $LABEL2
  inc     ecx
$LABEL1:
  mov     ebx, DWORD PTR [esi]
  add     esi, 4

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
;  shr     ebx, 8  -- Not needed on last byte
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  dec     ecx
  jne     SHORT $LABEL1
$LABEL2:
  mov     DWORD PTR dwCrc, edx
  mov     DWORD PTR pbBuffer, esi
}

    cbBuffer &= 0x3;
#else // _X86_
    pbBuffer = (unsigned char *) pvBuffer;
#endif
    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    *pNewCrc = dwCrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\context.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    context.cxx

Abstract:

    API and support routines for handling security contexts.

Author:

    Cliff Van Dyke (CliffV) 13-Jul-1993

Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\context.c

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR, etc

#include <lm.h>
#include <dsgetdc.h>



SECURITY_STATUS
SspContextReferenceContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext,
    OUT PSSP_CONTEXT *ContextResult
    )

/*++

Routine Description:

    This routine checks to see if the Context is for the specified
    Client Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    ContextHandle - Points to the ContextHandle of the Context
        to be referenced.

    RemoveContext - This boolean value indicates whether the caller
        wants the Context to be removed from the list
        of Contexts.  TRUE indicates the Context is to be removed.
        FALSE indicates the Context is not to be removed.

    ContextResult set to result context handle if successful.


Return Value:

    SEC_E_OK returns a pointer to the referenced Context.

    SEC_E_INVALID_HANDLE - invalid handle supplied
    SEC_E_CONTEXT_EXPIRED - handle was valid, but expired

--*/

{
    PSSP_CONTEXT Context;

    SspPrint(( SSP_API_MORE, "Entering SspContextReferenceContext\n" ));

    *ContextResult = NULL;

#if DBG


    //
    // check for leaky client applications.
    //

    SECPKG_CALL_INFO CallInfo;

    if( LsaFunctions->GetCallInfo(&CallInfo) )
    {
        if ((CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0)
        {
            SspPrint(( SSP_LEAK_TRACK, "SspContextReferenceContext: pid: 0x%lx handle: %p refcount: %lu\n",
                    CallInfo.ProcessId, ContextHandle, CallInfo.CallCount));
        }
    }

#endif



    Context = (PSSP_CONTEXT)ContextHandle;

    __try {

        if ( (Context->ContextTag != SSP_CONTEXT_TAG_ACTIVE)
            || (MSV1_0_USER_SESSION_KEY_LENGTH != RtlCompareMemory(Context->ContextMagicNumber, NtlmGlobalMagicNumber, MSV1_0_USER_SESSION_KEY_LENGTH)) )
        {
            SspPrint(( SSP_CRITICAL, "Tried to reference unknown Context %p\n",
                   Context ));
            return SEC_E_INVALID_HANDLE;
        }

#if 0
        ASSERT( (KernelCaller == Context->KernelClient) );
#endif

        if (!RemoveContext)
        {
            if (SspTimeHasElapsed(Context->TickStart, Context->Interval))
            {
                if ((Context->State != AuthenticatedState) &&
                    (Context->State != AuthenticateSentState) &&
                    (Context->State != PassedToServiceState))
                {

                    SspPrint(( SSP_CRITICAL, "Context %p has timed out.\n",
                                ContextHandle ));

                    return SEC_E_CONTEXT_EXPIRED;
                }
            }

            InterlockedIncrement( (PLONG)&Context->References );
        }
        else
        {
            Context->ContextTag = SSP_CONTEXT_TAG_DELETE;

            RtlZeroMemory(Context->ContextMagicNumber, MSV1_0_USER_SESSION_KEY_LENGTH);

            SspPrint(( SSP_API_MORE, "Delinked Context %p\n", Context ));
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SspPrint(( SSP_CRITICAL, "Tried to reference invalid Context %p\n",
                       Context ));
        return SEC_E_INVALID_HANDLE;
    }

    *ContextResult = Context;
    return SEC_E_OK;
}

VOID
SspContextDereferenceContext(
    PSSP_CONTEXT Context
    )

/*++

Routine Description:

    This routine decrements the specified Context's reference count.
    If the reference count drops to zero, then the Context is deleted

Arguments:

    Context - Points to the Context to be dereferenced.


Return Value:

    None.

--*/

{

    LONG References;

    SspPrint(( SSP_API_MORE, "Entering SspContextDereferenceContext\n" ));

    //
    // Decrement the reference count
    //

    References = InterlockedDecrement( (PLONG)&Context->References );
    ASSERT( References >= 0 );


    //
    // If the count dropped to zero, then run-down the Context
    //

    if (References != 0)
    {
        return;
    }

    SspPrint(( SSP_API_MORE, "Deleting Context 0x%lx\n",
               Context ));

    Context->ContextTag = SSP_CONTEXT_TAG_DELETE;
    RtlZeroMemory(Context->ContextMagicNumber, MSV1_0_USER_SESSION_KEY_LENGTH);

    if ( Context->Password.Buffer != NULL ) {
        // note: Password.Length may contain run-encoding hint, so size may be illegal.
        ZeroMemory( Context->Password.Buffer, Context->Password.MaximumLength );
        (VOID) NtLmFree( Context->Password.Buffer );
    }
    if ( Context->DomainName.Buffer != NULL ) {
        (VOID) NtLmFree( Context->DomainName.Buffer );
    }
    if ( Context->UserName.Buffer != NULL ) {
        (VOID) NtLmFree( Context->UserName.Buffer );
    }
    if( Context->TargetInfo != NULL )
    {
        //
        // CredUnmarshallTargetInfo uses LocalAlloc()
        //

        LocalFree( Context->TargetInfo );
    }

    if ( Context->TokenHandle != NULL ) {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose( Context->TokenHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );
    }

    if( Context->pbMarshalledTargetInfo )
    {
        LocalFree( Context->pbMarshalledTargetInfo );
    }

    if (Context->Credential != NULL) {
        SspCredentialDereferenceCredential( Context->Credential );
    }

    ZeroMemory( Context, sizeof(SSP_CONTEXT) );
    (VOID) NtLmFree( Context );


    return;

}

PSSP_CONTEXT
SspContextAllocateContext(
    VOID
    )

/*++

Routine Description:

    This routine allocates the security context block, initializes it and
    links it onto the specified credential.

Arguments: None

Return Value:

    NULL -- Not enough memory to allocate context.

    otherwise -- pointer to allocated and referenced context.

--*/

{

    SspPrint(( SSP_API_MORE, "Entering SspContextAllocateContext\n" ));
    PSSP_CONTEXT Context;
    SECPKG_CALL_INFO CallInfo;


    //
    // Allocate a Context block and initialize it.
    //

    Context = (PSSP_CONTEXT)NtLmAllocate(sizeof(SSP_CONTEXT) );

    if ( Context == NULL ) {
        SspPrint(( SSP_CRITICAL, "SspContextAllocateContext: Error allocating Context.\n" ));
        return NULL;
    }

    ZeroMemory( Context, sizeof(SSP_CONTEXT) );



    if( LsaFunctions->GetCallInfo(&CallInfo) ) {
        Context->ClientProcessID = CallInfo.ProcessId;
        Context->KernelClient = ((CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE) != 0);
    }

    //
    // The reference count is set to 2.  1 to indicate it is on the
    // valid Context list, and one for the our own reference.
    //

    Context->References = 2;
    Context->State = IdleState;

    //
    // Timeout this context.
    //
    Context->TickStart = GetTickCount();

    (VOID) NtQuerySystemTime( &Context->StartTime );
    Context->Interval = NTLMSSP_MAX_LIFETIME;

    //
    // Add it to the list of valid Context handles.
    //

    Context->ContextTag = SSP_CONTEXT_TAG_ACTIVE;

    RtlCopyMemory(
        Context->ContextMagicNumber,
        NtlmGlobalMagicNumber,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    SspPrint(( SSP_API_MORE, "Added Context 0x%lx\n", Context ));

    SspPrint(( SSP_API_MORE, "Leaving SspContextAllocateContext\n" ));

    return Context;
}


NTSTATUS
SspContextGetMessage(
    IN PVOID InputMessage,
    IN ULONG InputMessageSize,
    IN NTLM_MESSAGE_TYPE ExpectedMessageType,
    OUT PVOID* OutputMessage
    )

/*++

Routine Description:

    This routine copies the InputMessage into the local address space.
    This routine then validates the message header.

Arguments:

    InputMessage - Address of the message in the client process.

    InputMessageSize - Size of the message (in bytes).

    ExpectedMessageType - The type of message the should be in the message
        header.

    OutputMessage - Returns a pointer to an allocated buffer that contains
        the message.  The buffer should be freed using NtLmFree.


Return Value:

    STATUS_SUCCESS - Call completed successfully

    SEC_E_INVALID_TOKEN -- Message improperly formatted
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory to allocate message

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    PNEGOTIATE_MESSAGE TypicalMessage = NULL;

    //
    // Allocate a local buffer for the message.
    //

    ASSERT( NTLMSP_MAX_TOKEN_SIZE >= NTLMSSP_MAX_MESSAGE_SIZE );
    if ( InputMessageSize > NTLMSSP_MAX_MESSAGE_SIZE ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint(( SSP_CRITICAL, "SspContextGetMessage, invalid input message size.\n" ));
        goto Cleanup;
    }

    TypicalMessage = (PNEGOTIATE_MESSAGE)NtLmAllocate(InputMessageSize );

    if ( TypicalMessage == NULL ) {
        Status = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL, "SspContextGetMessage: Error allocating TypicalMessage.\n" ));
        goto Cleanup;
    }

    //
    // Copy the message into the buffer
    //

    RtlCopyMemory( TypicalMessage,
                   InputMessage,
                   InputMessageSize );

    //
    // Validate the message header.
    //

    if ( strncmp( (const char *)TypicalMessage->Signature,
                  NTLMSSP_SIGNATURE,
                  sizeof(NTLMSSP_SIGNATURE)) != 0 ||
         TypicalMessage->MessageType != ExpectedMessageType ) {

        (VOID) NtLmFree( TypicalMessage );
        TypicalMessage = NULL;
        Status = SEC_E_INVALID_TOKEN;
        SspPrint(( SSP_CRITICAL, "SspContextGetMessage, Bogus Message.\n" ));
        goto Cleanup;

    }

Cleanup:

    *OutputMessage = TypicalMessage;

    return Status;

}

VOID
SspContextCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING32 OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString into the MessageBuffer at Where.
    It then updates OutString to be a descriptor for the copied string.  The
    descriptor 'address' is an offset from the MessageBuffer.

    Where is updated to point to the next available space in the MessageBuffer.

    The caller is responsible for any alignment requirements and for ensuring
    there is room in the buffer for the string.

Arguments:

    MessageBuffer - Specifies the base address of the buffer being copied into.

    OutString - Returns a descriptor for the copied string.  The descriptor
        is relative to the begining of the buffer.

    InString - Specifies the string to copy.

    Where - On input, points to where the string is to be copied.
        On output, points to the first byte after the string.

Return Value:

    None.

--*/

{
    //
    // Copy the data to the Buffer.
    //

    if ( InString->Buffer != NULL ) {
        RtlCopyMemory( *Where, InString->Buffer, InString->Length );
    }

    //
    // Build a descriptor to the newly copied data.
    //

    OutString->Length = OutString->MaximumLength = InString->Length;
    OutString->Buffer = (ULONG)(*Where - ((PCHAR)MessageBuffer));


    //
    // Update Where to point past the copied data.
    //

    *Where += InString->Length;

}

VOID
SspContextCopyStringAbsolute(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString into the MessageBuffer at Where.
    It then updates OutString to be a descriptor for the copied string.

    Where is updated to point to the next available space in the MessageBuffer.

    The caller is responsible for any alignment requirements and for ensuring
    there is room in the buffer for the string.

Arguments:

    MessageBuffer - Specifies the base address of the buffer being copied into.

    OutString - Returns a descriptor for the copied string.  The descriptor
        is relative to the begining of the buffer.

    InString - Specifies the string to copy.

    Where - On input, points to where the string is to be copied.
        On output, points to the first byte after the string.

Return Value:

    None.

--*/

{
    //
    // Copy the data to the Buffer.
    //

    if ( InString->Buffer != NULL ) {
        RtlCopyMemory( *Where, InString->Buffer, InString->Length );
    }

    //
    // Build a descriptor to the newly copied data.
    //

    OutString->Length = OutString->MaximumLength = InString->Length;
    OutString->Buffer = *Where;

    //
    // Update Where to point past the copied data.
    //

    *Where += InString->Length;

}

BOOLEAN
SspConvertRelativeToAbsolute (
    IN PVOID MessageBase,
    IN ULONG MessageSize,
    IN PSTRING32 StringToRelocate,
    IN PSTRING OutputString,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString
    )

/*++

Routine Description:

    Convert a Relative string desriptor to be absolute.
    Perform all boudary condition testing.

Arguments:

    MessageBase - a pointer to the base of the buffer that the string
        is relative to.  The MaximumLength field of the descriptor is
        forced to be the same as the Length field.

    MessageSize - Size of the message buffer (in bytes).

    StringToRelocate - A pointer to the string descriptor to make absolute.

    AlignToWchar - If TRUE the passed in StringToRelocate must describe
        a buffer that is WCHAR aligned.  If not, an error is returned.

    AllowNullString - If TRUE, the passed in StringToRelocate may be
        a zero length string.

Return Value:

    TRUE - The string descriptor is valid and was properly relocated.

--*/

{
    ULONG_PTR Offset;

    //
    // If the buffer is allowed to be null,
    //  check that special case.
    //

    if ( AllowNullString ) {
        if ( StringToRelocate->Length == 0 ) {
            OutputString->MaximumLength = OutputString->Length = StringToRelocate->Length;
            OutputString->Buffer = NULL;
            return TRUE;
        }
    }

    //
    // Ensure the string in entirely within the message.
    //

    Offset = (ULONG_PTR) StringToRelocate->Buffer;

    if ( Offset >= MessageSize ||
         Offset + StringToRelocate->Length > MessageSize ) {
        return FALSE;
    }

    //
    // Ensure the buffer is properly aligned.
    //

    if ( AlignToWchar ) {
        if ( !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ||
             !COUNT_IS_ALIGNED( StringToRelocate->Length, ALIGN_WCHAR) ) {
            return FALSE;
        }
    }

    //
    // Finally make the pointer absolute.
    //

    OutputString->Buffer = (((PCHAR)MessageBase) + Offset);
    OutputString->MaximumLength = OutputString->Length = StringToRelocate->Length ;

    return TRUE;

}


TimeStamp
SspContextGetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN BOOLEAN GetExpirationTime
    )
/*++

Routine Description:

    Get the Start time or Expiration time for the specified context.

Arguments:

    Context - Pointer to the context to query

    GetExpirationTime - If TRUE return the expiration time.
        Otherwise, return the start time for the context.

Return Value:

    Returns the requested time as a local time.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TimeStamp LocalTimeStamp;

    //
    // Get the requested time in NT system time format.
    //

    SystemTime = Context->StartTime;

    if ( GetExpirationTime ) {
        LARGE_INTEGER Interval;

        //
        // If the time is infinite, return that
        //

        if ( Context->Interval == INFINITE ) {
            return NtLmGlobalForever;
        }

        //
        // Compute the ending time in NT System Time.
        //

        Interval.QuadPart = Int32x32To64( (LONG) Context->Interval, 10000 );
        SystemTime.QuadPart = Interval.QuadPart + SystemTime.QuadPart;
    }

    //
    // Convert the time to local time
    //

    Status = RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );

    if ( !NT_SUCCESS(Status) ) {
        return NtLmGlobalForever;
    }

    LocalTimeStamp.HighPart = LocalTime.HighPart;
    LocalTimeStamp.LowPart = LocalTime.LowPart;

    return LocalTimeStamp;

}

VOID
SspContextSetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN LARGE_INTEGER ExpirationTime
    )
/*++

Routine Description:

    Set the Expiration time for the specified context.

Arguments:

    Context - Pointer to the context to change

    ExpirationTime - Expiration time to set

Return Value:

    NONE.

--*/

{

    LARGE_INTEGER BaseGetTickMagicDivisor = { 0xe219652c, 0xd1b71758 };
    CCHAR BaseGetTickMagicShiftCount = 13;

    LARGE_INTEGER TimeRemaining;
    LARGE_INTEGER MillisecondsRemaining;

    //
    // If the expiration time is infinite,
    //  so is the interval
    //

    if ( ExpirationTime.HighPart == 0x7FFFFFFF &&
         ExpirationTime.LowPart == 0xFFFFFFFF ) {
        Context->Interval = INFINITE;

    //
    // Handle non-infinite expiration times
    //

    } else {

        //
        // Compute the time remaining before the expiration time
        //

        TimeRemaining.QuadPart = ExpirationTime.QuadPart -
                                 Context->StartTime.QuadPart;

        //
        // If the time has already expired,
        //  indicate so.
        //

        if ( TimeRemaining.QuadPart < 0 ) {

            Context->Interval = 0;

        //
        // If the time hasn't expired, compute the number of milliseconds
        //  remaining.
        //

        } else {

            MillisecondsRemaining = RtlExtendedMagicDivide(
                                        TimeRemaining,
                                        BaseGetTickMagicDivisor,
                                        BaseGetTickMagicShiftCount );

            if ( MillisecondsRemaining.HighPart == 0 &&
                 MillisecondsRemaining.LowPart < 0x7fffffff ) {

                Context->Interval = MillisecondsRemaining.LowPart;

            } else {

                Context->Interval = INFINITE;
            }
        }

    }

}


NTSTATUS
SsprDeleteSecurityContext (
    IN OUT ULONG_PTR ContextHandle
    )

/*++

Routine Description:

    Deletes the local data structures associated with the specified
    security context and generates a token which is passed to a remote peer
    so it too can remove the corresponding security context.

    This API terminates a context on the local machine, and optionally
    provides a token to be sent to the other machine.  The OutputToken
    generated by this call is to be sent to the remote peer (initiator or
    acceptor).  If the context was created with the I _REQ_ALLOCATE_MEMORY
    flag, then the package will allocate a buffer for the output token.
    Otherwise, it is the responsibility of the caller.

Arguments:

    ContextHandle - Handle to the context to delete

Return Value:

    STATUS_SUCCESS - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;

    //
    // Initialization
    //

    SspPrint(( SSP_API_MORE, "SspDeleteSecurityContext Entered\n" ));

    //
    // Find the currently existing context (and delink it).
    //

    Status = SspContextReferenceContext( ContextHandle, TRUE, &Context );

    if ( NT_SUCCESS(Status) )
    {
        SspContextDereferenceContext( Context );
    }

    SspPrint(( SSP_API_MORE, "SspDeleteSecurityContext returns 0x%lx\n", Status));
    return Status;
}

NTSTATUS
SspContextInitialize(
    VOID
    )

/*++

Routine Description:

    This function initializes this module.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/

{

    return STATUS_SUCCESS;

}


VOID
SspContextTerminate(
    VOID
    )

/*++

Routine Description:

    This function cleans up any dangling Contexts.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/
{
    //
    // don't forcibly try to delete contexts during shutdown, as, the
    // state of the machine is in flux during shutdown.
    //

    return;
}

BOOL
SsprCheckMinimumSecurity(
    IN ULONG NegotiateFlags,
    IN ULONG MinimumSecurityFlags
    )
/*++
Routine Description:

    Check that minimum security requirements have been met.

Arguments:

    NegotiateFlags: requested security features
    MinimumSecurityFlags: minimum required features

Return Value:
    TRUE    if minimum requirements met
    FALSE   otherwise

Notes:
    The MinimumSecurityFlags can contain features that only apply if
    a key is needed when doing signing or sealing. These have to be removed
    if SIGN or SEAL is not in the NegotiateFlags.

--*/
{
    ULONG EffFlags;     // flags in effect

    EffFlags = MinimumSecurityFlags;


    if( (NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) == 0 )
        EffFlags &= ~(NTLMSSP_NEGOTIATE_SIGN);


    if( (NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) == 0 )
        EffFlags &= ~(NTLMSSP_NEGOTIATE_SEAL);


    //
    // if SIGN or SEAL is not negotiated, then remove all key related
    //  requirements, since they're not relevant when a key isn't needed
    //

    if ((NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL)) == 0)
    {
        EffFlags &= ~(
                NTLMSSP_NEGOTIATE_128 |
                NTLMSSP_NEGOTIATE_56 |
                NTLMSSP_NEGOTIATE_KEY_EXCH
                );
    } else if ((NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) == 0) {

        //
        // If SIGN is negotiated, but SEAL isn't, then remove flags
        //  that aren't relevant to encryption
        //

        EffFlags &= ~( NTLMSSP_NEGOTIATE_KEY_EXCH );
    }

    //
    // FYI: flags that can be usefully spec'd even without SIGN or SEAL:
    //      NTLM2 -- forces stronger authentication
    //  All other flags should never be set.... and are nuked in initcomn
    //

    return ((NegotiateFlags & EffFlags) == EffFlags);
}


SECURITY_STATUS
SsprMakeSessionKey(
    IN  PSSP_CONTEXT Context,
    IN  PSTRING LmChallengeResponse,
    IN  UCHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH], // from the DC or GetChalResp
    IN  UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH],     // from the DC of GetChalResp
    IN  PSTRING DatagramSessionKey
    )

/*++
// SsprMakeSessionKey
//  on entry:
//      if KEY_EXCH has been negotiated, then
//          either Context->SessionKey has a random number to be encrypted
//          to be sent to the server, or it has the encrypted session key
//          received from the client
//          if client, DatagramSessionKey must point to STRING set up to hold 16 byte key,
//              but with 0 length.
//      else Context->SessionKey and DatagramSessionKey are irrelevant on entry
//  on exit:
//      Context->SessionKey has the session key to be used for the rest of the session
//      if (DatagramSessionKey != NULL) then if KEY_EXCH then it has the encrypted session key
//      to send to the server, else it is zero length
//
--*/

{
    NTSTATUS Status;
    UCHAR LocalSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    // if we don't need to make any keys, just return
// RDR/SRV expect session key but don't ask for it! work-around this...
//    if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN| NTLMSSP_NEGOTIATE_SEAL)) == 0)
//        return(SEC_E_OK);

    if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN| NTLMSSP_NEGOTIATE_SEAL)) == 0)
    {

        RtlCopyMemory(
            Context->SessionKey,
            NtUserSessionKey,
            sizeof(LocalSessionKey)
            );

        return SEC_E_OK;
    }

    if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
        //
        // when using NTLM2, LSA gets passed flags that cause
        //  it to make good session keys -- nothing for us to do
        //

        RtlCopyMemory(
            LocalSessionKey,
            NtUserSessionKey,
            sizeof(LocalSessionKey)
            );
    }
    else if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY )
    {
        LM_OWF_PASSWORD LmKey;
        LM_RESPONSE LmResponseKey;

        BYTE TemporaryResponse[ LM_RESPONSE_LENGTH ];

        RtlZeroMemory(
            LocalSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        if (LmChallengeResponse->Length > LM_RESPONSE_LENGTH)
            return(SEC_E_UNSUPPORTED_FUNCTION);

        ZeroMemory( TemporaryResponse, sizeof(TemporaryResponse) );
        CopyMemory( TemporaryResponse, LmChallengeResponse->Buffer, LmChallengeResponse->Length );

        //
        // The LM session key is made by taking the LM sesion key
        // given to us by the LSA, extending it to LM_OWF_LENGTH
        // with our salt, and then producing a new challenge-response
        // with it and the original challenge response.  The key is
        // made from the first 8 bytes of the key.
        //

        RtlCopyMemory(  &LmKey,
                        LanmanSessionKey,
                        MSV1_0_LANMAN_SESSION_KEY_LENGTH );

        memset( (PUCHAR)(&LmKey) + MSV1_0_LANMAN_SESSION_KEY_LENGTH,
                NTLMSSP_KEY_SALT,
                LM_OWF_PASSWORD_LENGTH - MSV1_0_LANMAN_SESSION_KEY_LENGTH );

        Status = RtlCalculateLmResponse(
                    (PLM_CHALLENGE) TemporaryResponse,
                    &LmKey,
                    &LmResponseKey
                    );

        ZeroMemory( TemporaryResponse, sizeof(TemporaryResponse) );
        if (!NT_SUCCESS(Status))
            return(SspNtStatusToSecStatus(Status, SEC_E_NO_CREDENTIALS));

        RtlCopyMemory(
            LocalSessionKey,
            &LmResponseKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );
    } else {

        RtlCopyMemory(
            LocalSessionKey,
            NtUserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );
    }


    //
    // If we aren't doing key exchange, store the session key in the
    // context.  Otherwise encrypt the session key to send to the
    // server.
    //

    if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) {

        struct RC4_KEYSTRUCT Rc4Key;

        //
        // make a key schedule from the temp key to form key exchange key
        //

        rc4_key(
            &Rc4Key,
            MSV1_0_USER_SESSION_KEY_LENGTH,
            LocalSessionKey
            );

        if (DatagramSessionKey == NULL)
        {
            //
            // decrypt what's in Context->SessionKey, leave it there
            //

            rc4(
                &Rc4Key,
                MSV1_0_USER_SESSION_KEY_LENGTH,
                Context->SessionKey
                );
        } else {

            //
            // set the proper length so client will send something (length was 0)
            //

            DatagramSessionKey->Length =
                DatagramSessionKey->MaximumLength =
                    MSV1_0_USER_SESSION_KEY_LENGTH;

            //
            // copy randomly generated key to buffer to send to server
            //

            RtlCopyMemory(
                DatagramSessionKey->Buffer,
                Context->SessionKey,
                MSV1_0_USER_SESSION_KEY_LENGTH
                );

            //
            // encrypt it with the key exchange key
            //

            rc4(
                &Rc4Key,
                MSV1_0_USER_SESSION_KEY_LENGTH,
                (unsigned char*)DatagramSessionKey->Buffer
                );
        }


    } else {

        //
        // just make the temp key into the real one
        //

        RtlCopyMemory(
            Context->SessionKey,
            LocalSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

    }

    /*
    //
    // These casts currently generate an alignment fault on 64-bit and AV on 32-bit.
    //

    SspPrint((SSP_SESSION_KEYS, "SsprMakeSessionKey NegotiateFlags %lx, session key %lx %lx %lx %lx\n",
            Context->NegotiateFlags,
            ((DWORD*)Context->SessionKey)[0],
            ((DWORD*)Context->SessionKey)[1],
            ((DWORD*)Context->SessionKey)[2],
            ((DWORD*)Context->SessionKey)[3]
            ));

    SspPrint((SSP_SESSION_KEYS, "SsprMakeSessionKey LmChallengeResponse %lx %lx %lx %lx %lx %lx\n",
            ((DWORD*)LmChallengeResponse->Buffer)[0],
            ((DWORD*)LmChallengeResponse->Buffer)[1],
            ((DWORD*)LmChallengeResponse->Buffer)[2],
            ((DWORD*)LmChallengeResponse->Buffer)[3],
            ((DWORD*)LmChallengeResponse->Buffer)[4],
            ((DWORD*)LmChallengeResponse->Buffer)[5]
            ));

    if (DatagramSessionKey && DatagramSessionKey->Length >= MSV1_0_USER_SESSION_KEY_LENGTH) 
    {
        SspPrint((SSP_SESSION_KEYS, "SsprMakeSessionKey datagram session key %lx %lx %lx %lx\n",
                ((DWORD*)DatagramSessionKey->Buffer)[0],
                ((DWORD*)DatagramSessionKey->Buffer)[1],
                ((DWORD*)DatagramSessionKey->Buffer)[2],
                ((DWORD*)DatagramSessionKey->Buffer)[3]
                ));

    }
    */

    return(SEC_E_OK);
}

NTSTATUS
SsprQueryTreeName(
    OUT PUNICODE_STRING TreeName
    )
{

    PDS_DOMAIN_TRUSTSW Trusts = NULL;
    ULONG TrustCount ;
    ULONG Index;
    LPWSTR DnsTreeName = NULL;

    DWORD NetStatus;

    ZeroMemory( TreeName, sizeof(*TreeName) );

    NetStatus = DsEnumerateDomainTrustsW(
                    NULL,
                    DS_DOMAIN_PRIMARY | DS_DOMAIN_IN_FOREST,
                    &Trusts,
                    &TrustCount
                    );

    if( NetStatus != NO_ERROR )
    {
        // TODO: Talk to CliffV about failure causes.
        // in any event, the failure is not catastrophic.
        //

        return STATUS_SUCCESS;
    }

    for(Index = 0 ; Index < TrustCount; Index++)
    {
        ULONG Attempts; // bound the attempts in the event bogus data comes back.

        if( (Trusts[Index].Flags & DS_DOMAIN_PRIMARY) == 0)
        {
            continue;
        }

        for( Attempts = 0 ; Index < TrustCount; Attempts++ )
        {
            if( Attempts > TrustCount )
            {
                break;
            }

            if( (Trusts[Index].Flags & DS_DOMAIN_TREE_ROOT) == 0 )
            {
                Index = Trusts[Index].ParentIndex;
                continue;
            }

            DnsTreeName = Trusts[Index].DnsDomainName;
            break;
        }

        break;
    }

    if( DnsTreeName )
    {
        DWORD cchTreeName = lstrlenW( DnsTreeName );

        TreeName->Buffer = (PWSTR)NtLmAllocate( cchTreeName*sizeof(WCHAR) );
        if( TreeName->Buffer == NULL )
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        TreeName->Length = (USHORT)(cchTreeName*sizeof(WCHAR));
        TreeName->MaximumLength = TreeName->Length;

        RtlCopyMemory( TreeName->Buffer, DnsTreeName, TreeName->Length );
    }

    NetApiBufferFree( Trusts );

    return STATUS_SUCCESS;
}


NTSTATUS
SsprUpdateTargetInfo(
    VOID
    )
/*++

    Update the NtLmGlobalNtLm3TargetInfo buffer based on the current values
    of the various global variables.

    NOTE: the global lock must be held for exclusive access prior to making
    this call!

--*/
{
    PMSV1_0_AV_PAIR pAV;
    PUNICODE_STRING pDnsTargetName;
    PUNICODE_STRING pDnsComputerName;
    PUNICODE_STRING pDnsTreeName;
    ULONG cbAV;

    ULONG AvFlags = 0;

    if( NtLmGlobalNtLm3TargetInfo.Buffer != NULL )
    {
        NtLmFree(NtLmGlobalNtLm3TargetInfo.Buffer);
        NtLmGlobalNtLm3TargetInfo.Buffer = NULL;
        NtLmGlobalNtLm3TargetInfo.MaximumLength = NtLmGlobalNtLm3TargetInfo.Length = 0;
    }

    if( NtLmGlobalTargetFlags == NTLMSSP_TARGET_TYPE_DOMAIN ) {
        pDnsTargetName = &NtLmGlobalUnicodeDnsDomainNameString;
    } else {
        pDnsTargetName = &NtLmGlobalUnicodeDnsComputerNameString;
    }

    pDnsComputerName = &NtLmGlobalUnicodeDnsComputerNameString;

    pDnsTreeName = &NtLmGlobalUnicodeDnsTreeName;

    cbAV = NtLmGlobalUnicodeTargetName.Length +
           NtLmGlobalUnicodeComputerNameString.Length +
           pDnsComputerName->Length +
           pDnsTargetName->Length +
           pDnsTreeName->Length +
           sizeof( AvFlags ) +
           (sizeof( MSV1_0_AV_PAIR ) * 6) +
           sizeof( MSV1_0_AV_PAIR );

    NtLmGlobalNtLm3TargetInfo.Buffer = (PWSTR)NtLmAllocate( cbAV );

    if( NtLmGlobalNtLm3TargetInfo.Buffer == NULL )
    {
        SspPrint((SSP_CRITICAL, "SsprUpdateTargetInfo, Error from NtLmAllocate\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory( NtLmGlobalNtLm3TargetInfo.Buffer, cbAV );

    pAV = MsvpAvlInit( NtLmGlobalNtLm3TargetInfo.Buffer );
    MsvpAvlAdd( pAV, MsvAvNbDomainName, &NtLmGlobalUnicodeTargetName, cbAV );
    MsvpAvlAdd( pAV, MsvAvNbComputerName, &NtLmGlobalUnicodeComputerNameString, cbAV );

    if( pDnsTargetName->Length != 0 && pDnsTargetName->Buffer != NULL )
    {
        MsvpAvlAdd( pAV, MsvAvDnsDomainName, pDnsTargetName, cbAV );
    }

    if( pDnsComputerName->Length != 0 && pDnsComputerName->Buffer != NULL )
    {
        MsvpAvlAdd( pAV, MsvAvDnsComputerName, pDnsComputerName, cbAV );
    }

    if( pDnsTreeName->Length != 0 && pDnsTreeName->Buffer != NULL )
    {
        MsvpAvlAdd( pAV, MsvAvDnsTreeName, pDnsTreeName, cbAV );
    }

    //
    // add in AvFlags into TargetInfo, if applicable.
    //

    if( NtLmGlobalForceGuest )
    {
        AvFlags |= MSV1_0_AV_FLAG_FORCE_GUEST;
    }

    if( AvFlags )
    {
        UNICODE_STRING AvString;

        AvString.Buffer = (PWSTR)&AvFlags;
        AvString.Length = sizeof( AvFlags );
        AvString.MaximumLength = AvString.Length;

        MsvpAvlAdd( pAV, MsvAvFlags, &AvString, cbAV );
    }


    NtLmGlobalNtLm3TargetInfo.Length = (USHORT)MsvpAvlLen( pAV, cbAV );
    NtLmGlobalNtLm3TargetInfo.MaximumLength = NtLmGlobalNtLm3TargetInfo.Length;


    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtapi.cxx
//
// Contents:    Context APIs for the NtLm security package
//              Main entry points into this dll:
//                SpDeleteContext
//                SpInitLsaModeContext
//                SpApplyControlToken
//                SpAcceptLsaModeContext
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\ctxtapi.cxx
//              JClark   28-Jun-2000   Added WMI Trace Logging Support
//
//------------------------------------------------------------------------
#define NTLM_CTXTAPI
#include <global.h>
#include "Trace.h"



//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteContext
//
//  Synopsis:   Deletes an NtLm context
//
//  Effects:
//
//  Arguments:  ContextHandle - The context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_HANDLE
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteContext(
    IN ULONG_PTR ContextHandle
    )
/*++

Routine Description:

    Deletes the local data structures associated with the specified
    security context.

    This API terminates a context on the local machine.

Arguments:

    ContextHandle - Handle to the context to delete


Return Value:

    STATUS_SUCCESS - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG_PTR TempContextHandle = ContextHandle;
    SspPrint((SSP_API, "Entering SpDeleteContext for 0x%x\n", ContextHandle));

    Status = SsprDeleteSecurityContext(
                    TempContextHandle );

    SspPrint((SSP_API, "Leaving SpDeleteContext for 0x%x\n", ContextHandle));
    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitLsaModeContext
//
//  Synopsis:   NtLm implementation of InitializeSecurityContext
//              while in Lsa mode. If we return TRUE in *MappedContext,
//              secur32 will call SpInitUserModeContext with
//              the returned context handle and ContextData
//              as input. Fill in whatever info needed for
//              the user mode apis
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: This function can be called in various ways:
//         1. Generic users of ntlm make the first call to
//            InitializeSecurityContext and we return a NEGOTIATE_MESSAGE
//         2. The rdr makes the first call to InitializeSecurityContext
//            with no contextHandle but info is passed in through a
//            CHALLENGE_MESSAGE (& possibly an NTLM_CHALLENGE_MESSAGE),
//            we return an AUTHENTICATE_MESSAGE and an
//            NTLM_INITIALIZE_RESPONSE
//         3. Generic users of NTLM make the second call to
//            InitializeSecurityContext, passing in a CHALLENGE_MESSAGE
//            and we return an AUTHENTICATE_MESSAGE
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitLsaModeContext(
    IN OPTIONAL ULONG_PTR CredentialHandle,
    IN OPTIONAL ULONG_PTR OldContextHandle,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputBuffers,
    OUT PULONG_PTR NewContextHandle,
    IN OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    SecBuffer TempTokens[4];
    PSecBuffer FirstInputToken;
    PSecBuffer SecondInputToken;
    PSecBuffer FirstOutputToken;
    PSecBuffer SecondOutputToken;

    ULONG_PTR OriginalContextHandle = NULL;
    ULONG_PTR TempContextHandle = NULL;
    ULONG NegotiateFlags = 0;
    UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    //Tracing State
    NTLM_TRACE_INFO TraceInfo = {0};
    UINT32          TraceHint = 0;


    SspPrint((SSP_API, "Entering SpInitLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));


    //Begin tracing an InitializeSecurityContext call for NTLM
    if (NtlmGlobalEventTraceFlag){           
        
        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmInitializeGuid, 
                         EVENT_TRACE_TYPE_START, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         2);                                            

        TraceHint = (OldContextHandle == 0)?
            TRACE_INIT_FIRST:
            TRACE_INIT_CHALLENGE;

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);
        
        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }



    RtlZeroMemory(
        TempTokens,
        sizeof(TempTokens)
        );

    FirstInputToken = &TempTokens[0];
    SecondInputToken = &TempTokens[1];
    FirstOutputToken = &TempTokens[2];
    SecondOutputToken = &TempTokens[3];


    *MappedContext = FALSE;

    ASSERT(ContextData);

    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;

    RtlZeroMemory(SessionKey,
                  MSV1_0_USER_SESSION_KEY_LENGTH);

    UNREFERENCED_PARAMETER( TargetDataRep );

    //
    // Extract tokens from the SecBuffers
    //

    if ( !SspGetTokenBuffer( InputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstInputToken,
                             TRUE
                             ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (FirstInputToken) returns %d\n", Status));
        goto Cleanup;
    }

    //
    //  If we are using supplied credentials, get the second SECBUFFER_TOKEN
    //

    if (ContextReqFlags & ISC_REQ_USE_SUPPLIED_CREDS)
    {
        if ( !SspGetTokenBuffer( InputBuffers,
                             1,   // get the second SECBUFFER_TOKEN
                             &SecondInputToken,
                             TRUE
                             ) ) {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (SecondInputToken) returns %d\n", Status));
            goto Cleanup;
        }
    }

    if ( !SspGetTokenBuffer( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstOutputToken,
                             FALSE
                             ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (FirstOutputToken) returns %d\n", Status));
        goto Cleanup;
    }

    if ( !SspGetTokenBuffer( OutputBuffers,
                             1,   // get the second SECBUFFER_TOKEN
                             &SecondOutputToken,
                             FALSE
                             ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (SecondOutputToken) returns %d\n", Status));
        goto Cleanup;
    }

    //
    // Save the old context handle, in case someone changes it
    //

    TempContextHandle = OldContextHandle;
    OriginalContextHandle = OldContextHandle;

    //
    // If no previous context was passed
    // and if no legitimate input token existed, this is the first call
    //

    if ((OriginalContextHandle == 0 ) &&
        (FirstInputToken->cbBuffer == 0))
    {

        if ( !ARGUMENT_PRESENT( CredentialHandle ) ) {
            Status = STATUS_INVALID_HANDLE;
            SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, No CredentialHandle\n"));
            goto Cleanup;
        }

        *NewContextHandle = 0;

        Status = SsprHandleFirstCall(
                        CredentialHandle,
                        NewContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        TargetName,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime,
                        SessionKey,
                        &NegotiateFlags );

        TempContextHandle = *NewContextHandle;
    //
    // If context was passed in, continue where we left off.
    // Or if the redir's passing in stuff in the InputBuffers,
    // skip the first call and get on with the second
    //

    } else {

        *NewContextHandle = OldContextHandle;

        Status = SsprHandleChallengeMessage(
                        CredentialHandle,
                        &TempContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        SecondInputToken->cbBuffer,
                        SecondInputToken->pvBuffer,
                        TargetName,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        &SecondOutputToken->cbBuffer,
                        &SecondOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime,
                        SessionKey,
                        &NegotiateFlags
                        );
    }

    //
    // If the original handle is zero, set it to be the TempContextHandle.
    // This is for the datagram case, where we map the context after the
    // first call to initialize.
    //

    if (OriginalContextHandle == 0) {

        OriginalContextHandle = TempContextHandle;
        *NewContextHandle = OriginalContextHandle;
    }
    //
    // Only map the context if this is the real authentication, not a re-auth
    // or if this was datagram.
    //

    if (((Status == SEC_I_CONTINUE_NEEDED) &&
         ((*ContextAttributes & ISC_RET_DATAGRAM) != 0)) ||
        ((Status == SEC_E_OK) &&
         ((*ContextAttributes & (SSP_RET_REAUTHENTICATION | ISC_RET_DATAGRAM)) == 0))) {

        NTSTATUS TempStatus;

        TempStatus = SspMapContext(
                        &OriginalContextHandle,
                        SessionKey,
                        NegotiateFlags,
                        NULL,               // no token handle for clients
                        NULL,               // no password expiry for clients
                        0,                  // no userflags
                        ContextData
                        );

        if (!NT_SUCCESS(TempStatus)) {
            Status = TempStatus;
            SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspMapContext returns %d\n", Status));
            goto Cleanup;
        }

        SspPrint((SSP_SESSION_KEYS, "Init sessionkey %lx %lx %lx %lx\n",
                ((DWORD*)SessionKey)[0],
                ((DWORD*)SessionKey)[1],
                ((DWORD*)SessionKey)[2],
                ((DWORD*)SessionKey)[3]
                ));


        //
        // Yes, do load msv1_0.dll in the client's process
        // and ContextData will contain info to be passed on
        // to the InitializeSecurityContext counterpart that
        // runs in the client's process

        *MappedContext = TRUE;
    }

    //
    // Make sure this bit isn't sent to the caller
    //

    *ContextAttributes &= ~SSP_RET_REAUTHENTICATION;


Cleanup:

    // Send the output stuff
    // pvBuffer is reassigned in case ISC-REQ_ALLOCATE_MEMORY has ben defined

//    if (OutputBuffers != NULL && OutputBuffers->cBuffers > 0 && OutputBuffers->pBuffers != NULL)
//    {
//        OutputBuffers->pBuffers->cbBuffer =  FirstOutputToken.cbBuffer;
//        OutputBuffers->pBuffers->pvBuffer =  FirstOutputToken.pvBuffer;
//    }

    SspPrint((SSP_API, "Leaving  SpInitLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));

    //
    // Convert and save, will be (perhaps traced then) returned
    //
    Status = (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

    //
    //Trace the end of this call
    //
    if (NtlmGlobalEventTraceFlag){

        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmInitializeGuid, 
                         EVENT_TRACE_TYPE_END, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         4);
                         
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_OUTCONTEXT,
                        NewContextHandle);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STATUS,
                        Status);
        
        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }
    
    return Status;
}



NTSTATUS NTAPI
SpApplyControlToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc ControlToken
    )
{
    SspPrint((SSP_API, "Entering SpApplyControlToken\n"));
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(ControlToken);
    SspPrint((SSP_API, "Leaving  SpApplyControlToken\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptLsaModeContext
//
//  Synopsis:   NtLm implementation of AcceptSecurityContext call.
//              This routine accepts an AP request message from a client
//              and verifies that it is a valid ticket. If mutual
//              authentication is desired an AP reply is generated to
//              send back to the client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------




NTSTATUS NTAPI
SpAcceptLsaModeContext(
    IN OPTIONAL ULONG_PTR CredentialHandle,
    IN OPTIONAL ULONG_PTR OldContextHandle,
    IN PSecBufferDesc InputBuffers,
    IN ULONG ContextReqFlags,
    IN ULONG TargetDataRep,
    OUT PULONG_PTR NewContextHandle,
    OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
/*++

Routine Description:

    Allows a remotely initiated security context between the application
    and a remote peer to be established.  To complete the establishment of
    context one or more reply tokens may be required from remote peer.

    This function is the server counterpart to the
    InitializeSecurityContext API.  The ContextAttributes is a bit mask
    representing various context level functions viz.  delegation, mutual
    authentication, confidentiality, replay detection and sequence
    detection.  This API is used by the server side.  When a request comes
    in, the server uses the ContextReqFlags parameter to specify what
    it requires of the session.  In this fashion, a server can specify that
    clients must be capable of using a confidential or integrity checked
    session, and fail clients that can't meet that demand.  Alternatively,
    a server can require nothing, and whatever the client can provide or
    requires is returned in the pfContextAttributes parameter.  For a
    package that supports 3 leg mutual authentication, the calling sequence
    would be: Client provides a token, server calls Accept the first time,
    generating a reply token.  The client uses this in a second call to
    InitializeSecurityContext, and generates a final token.  This token is
    then used in the final call to Accept to complete the session.  Another
    example would be the LAN Manager/NT authentication style.  The client
    connects to negotiate a protocol.  The server calls Accept to set up a
    context and generate a challenge to the client.  The client calls
    InitializeSecurityContext and creates a response.  The server then
    calls Accept the final time to allow the package to verify the response
    is appropriate for the challenge.

Arguments:

   CredentialHandle - Handle to the credentials to be used to
       create the context.

   OldContextHandle - Handle to the partially formed context, if this is
       a second call (see above) or NULL if this is the first call.

   InputToken - Pointer to the input token.  In the first call this
       token can either be NULL or may contain security package specific
       information. 

   ContextReqFlags - Requirements of the context, package specific.

      #define ASC_REQ_DELEGATE         0x00000001
      #define ASC_REQ_MUTUAL_AUTH      0x00000002
      #define ASC_REQ_REPLAY_DETECT    0x00000004
      #define ASC_REQ_SEQUENCE_DETECT  0x00000008
      #define ASC_REQ_CONFIDENTIALITY  0x00000010
      #define ASC_REQ_ALLOCATE_MEMORY 0x00000100
      #define ASC_REQ_USE_DCE_STYLE    0x00000200

   TargetDataRep - Long indicating the data representation (byte ordering, etc)
        on the target.  The constant SECURITY_NATIVE_DREP may be supplied
        by the transport indicating that the native format is in use.

   NewContextHandle - New context handle.  If this is a second call, this
       can be the same as OldContextHandle.

   OutputToken - Buffer to receive the output token.

   ContextAttributes -Attributes of the context established.

        #define ASC_RET_DELEGATE          0x00000001
        #define ASC_RET_MUTUAL_AUTH       0x00000002
        #define ASC_RET_REPLAY_DETECT     0x00000004
        #define ASC_RET_SEQUENCE_DETECT   0x00000008
        #define ASC_RET_CONFIDENTIALITY   0x00000010
        #define ASC_RET_ALLOCATED_BUFFERS 0x00000100
        #define ASC_RET_USED_DCE_STYLE    0x00000200

   ExpirationTime - Expiration time of the context.

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_LOGON_DENIED -- User is no allowed to logon to this server
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    SecBuffer TempTokens[3];
    PSecBuffer FirstInputToken;
    PSecBuffer SecondInputToken;
    PSecBuffer FirstOutputToken;

    ULONG NegotiateFlags = 0;
    UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    HANDLE TokenHandle = NULL;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    TimeStamp PasswordExpiry;
    ULONG UserFlags = 0;

    //Tracing State
    NTLM_TRACE_INFO TraceInfo = {0};
    UINT32          TraceHint = 0;
            
    SspPrint((SSP_API, "Entering SpAcceptLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));

    //Begin tracing an AcceptSecurityContext call for NTLM
    if (NtlmGlobalEventTraceFlag){
        
        
        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmAcceptGuid, 
                         EVENT_TRACE_TYPE_START, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         2);

        TraceHint = (OldContextHandle == 0)?
            TRACE_ACCEPT_NEGOTIATE:
            TRACE_ACCEPT_AUTHENTICATE;

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);
        
        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    FirstInputToken = &TempTokens[0];
    SecondInputToken = &TempTokens[1];
    FirstOutputToken = &TempTokens[2];

    RtlZeroMemory(
        TempTokens,
        sizeof(TempTokens)
        );

    RtlZeroMemory(
        SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    *MappedContext = FALSE;

    //
    // Validate the arguments
    //

    UNREFERENCED_PARAMETER( TargetDataRep );


    if ( !SspGetTokenBuffer( InputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstInputToken,
                             TRUE ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspGetTokenBuffer (FirstInputToken) returns %d\n", Status));
        goto Cleanup;
    }

    if ( !SspGetTokenBuffer( InputBuffers,
                             1,   // get the second SECBUFFER_TOKEN
                             &SecondInputToken,
                             TRUE ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspGetTokenBuffer (SecondInputToken) returns %d\n", Status));
        goto Cleanup;
    }

    if ( !SspGetTokenBuffer( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstOutputToken,
                             FALSE ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspGetTokenBuffer (FirstOutputToken) returns %d\n", Status));
        goto Cleanup;
    }

    //
    // If no previous context was passed in this is the first call.
    //

    if ( (OldContextHandle  == 0 ) &&
         (SecondInputToken->cbBuffer == 0)) {

        if ( !ARGUMENT_PRESENT( CredentialHandle ) ) {
            Status = SEC_E_INVALID_HANDLE;
            SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, No CredentialHandle\n"));
            goto Cleanup;
        }

        Status = SsprHandleNegotiateMessage(
                        CredentialHandle,
                        NewContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime );

    //
    // If context was passed in, continue where we left off.
    //

    } else {

        *NewContextHandle = OldContextHandle;

        Status = SsprHandleAuthenticateMessage(
                        CredentialHandle,
                        NewContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        SecondInputToken->cbBuffer,
                        SecondInputToken->pvBuffer,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime,
                        SessionKey,
                        &NegotiateFlags,
                        &TokenHandle,
                        &SubStatus,
                        &PasswordExpiry,
                        &UserFlags
                        );

        //
        // for errors such as PASSWORD_EXPIRED, return the SubStatus, which
        // is more descriptive than the generic error code.
        //

        if ( Status == STATUS_ACCOUNT_RESTRICTION ) {
            if (!NT_SUCCESS(Status)) {

                Status = SubStatus;
            } else {
                ASSERT(!"SubStatus should be a failure code");
            }
        }
    }

    if ((Status == SEC_E_OK) &&
        !(*ContextAttributes & SSP_RET_REAUTHENTICATION)) {
        Status = SspMapContext(
                        NewContextHandle,
                        SessionKey,
                        NegotiateFlags,
                        TokenHandle,
                        &PasswordExpiry,
                        UserFlags,
                        ContextData
                        );

        if (!NT_SUCCESS(Status)) {
            SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspMapContext returns %d\n", Status));
            goto Cleanup;
        }

        SspPrint((SSP_SESSION_KEYS, "Accept sessionkey %lx %lx %lx %lx\n",
                ((DWORD*)SessionKey)[0],
                ((DWORD*)SessionKey)[1],
                ((DWORD*)SessionKey)[2],
                ((DWORD*)SessionKey)[3]
                ));

        *MappedContext = TRUE;


    } else {

        //
        // Make sure this bit isn't sent to the caller
        //

        *ContextAttributes &= ~SSP_RET_REAUTHENTICATION;
    }

Cleanup:

    if (TokenHandle != NULL) {
        NtClose(TokenHandle);
    }

    // TODO: this really necessary since we're in LSA mode???
    SetLastError(RtlNtStatusToDosError(SubStatus));


    SspPrint((SSP_API, "Leaving SpAcceptLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));

    //Convert and save, will be (perhaps traced then) returned
    Status = (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

    //Trace the end of this call
    if (NtlmGlobalEventTraceFlag){
        
        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmAcceptGuid, 
                         EVENT_TRACE_TYPE_END, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         4);
                         
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_OUTCONTEXT,
                        NewContextHandle);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STATUS,
                        Status);
        
        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }

    // Converted to SecStatus before tracing
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ctxtcli.cxx ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    ctxtcli.cxx

Abstract:

    API and support routines for handling security contexts.

Author:

    Cliff Van Dyke (CliffV) 13-Jul-1993

Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\context.c

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR, etc
#include <credp.h>
#include <kerberos.h>

#include "msp.h"

#include "nlp.h"


NTSTATUS
SsprHandleFirstCall(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PLSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN PUNICODE_STRING TargetServerName OPTIONAL,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    )

/*++

Routine Description:

    Handle the First Call part of InitializeSecurityContext.

Arguments:

    All arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS -- All OK
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{

    SspPrint(( SSP_API_MORE, "Entering SsprHandleFirstCall\n" ));
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context      = NULL;
    PSSP_CREDENTIAL Credential = NULL;

    PNEGOTIATE_MESSAGE NegotiateMessage = NULL;
    ULONG NegotiateMessageSize = 0;
    PCHAR Where = NULL;

    ULONG NegotiateFlagsKeyStrength;

    STRING NtLmLocalOemComputerNameString;
    STRING NtLmLocalOemPrimaryDomainNameString;

    //
    // Initialization
    //

    *ContextAttributes = 0;
    *NegotiateFlags = 0;

    RtlInitString( &NtLmLocalOemComputerNameString, NULL );
    RtlInitString( &NtLmLocalOemPrimaryDomainNameString, NULL );

    //
    // Get a pointer to the credential
    //

    Status = SspCredentialReferenceCredential(
                CredentialHandle,
                FALSE,
                &Credential );

    if ( !NT_SUCCESS( Status ) )
    {
        SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: invalid credential handle.\n" ));
        goto Cleanup;
    }

    if ( (Credential->CredentialUseFlags & SECPKG_CRED_OUTBOUND) == 0 ) {
        Status = SEC_E_INVALID_CREDENTIAL_USE;
        SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: invalid credential use.\n" ));
        goto Cleanup;
    }

    //
    // Allocate a new context
    //

    Context = SspContextAllocateContext( );

    if ( Context == NULL) {
        Status = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: SspContextAllocateContext returned NULL\n"));
        goto Cleanup;
    }

    //
    // Build a handle to the newly created context.
    //

    *ContextHandle = (LSA_SEC_HANDLE) Context;

    //
    // We don't support any options.
    //
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & ISC_REQ_PROMPT_FOR_CREDS) != 0 ) {

        Status = SEC_E_INVALID_CONTEXT_REQ;
        SspPrint(( SSP_CRITICAL,
                   "SsprHandleFirstCall: invalid ContextReqFlags 0x%lx.\n",
                   ContextReqFlags ));
        goto Cleanup;
    }

    //
    // Capture the default credentials from the credential structure.
    //

    if ( Credential->DomainName.Buffer != NULL ) {
        Status = NtLmDuplicateUnicodeString(
                        &Context->DomainName,
                        &Credential->DomainName
                        );
        if (!NT_SUCCESS(Status)) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: NtLmDuplicateUnicodeString (DomainName) returned %d\n",Status));
            goto Cleanup;
        }
    }
    if ( Credential->UserName.Buffer != NULL ) {
        Status = NtLmDuplicateUnicodeString(
                        &Context->UserName,
                        &Credential->UserName
                        );
        if (!NT_SUCCESS(Status)) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: NtLmDuplicateUnicodeString (UserName) returned %d\n", Status ));
            goto Cleanup;
        }
    }

    Status = SspCredentialGetPassword(
                    Credential,
                    &Context->Password
                    );

    if (!NT_SUCCESS(Status)) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleFirstCall: SspCredentialGetPassword returned %d\n", Status ));
        goto Cleanup;
    }


    //
    // save away any marshalled credential info.
    //

    Status = CredpExtractMarshalledTargetInfo(
                TargetServerName,
                &Context->TargetInfo
                );

    if (!NT_SUCCESS(Status)) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleFirstCall: CredpExtractMarshalledTargetInfo returned %d\n", Status ));
        goto Cleanup;
    }

    //
    // Compute the negotiate flags
    //


    //
    // Supported key strength(s)
    //

    NegotiateFlagsKeyStrength = NTLMSSP_NEGOTIATE_56;
    NegotiateFlagsKeyStrength |= NTLMSSP_NEGOTIATE_128;

    Context->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                              NTLMSSP_NEGOTIATE_OEM |
                              NTLMSSP_NEGOTIATE_NTLM |
                              ((NtLmGlobalLmProtocolSupported != 0)
                               ? NTLMSSP_NEGOTIATE_NTLM2 : 0 ) |
                              NTLMSSP_REQUEST_TARGET |
                              NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                              NegotiateFlagsKeyStrength |
                              NTLMSSP_NEGOTIATE_VERSION;



    if ((ContextReqFlags & ISC_REQ_CONFIDENTIALITY) != 0) {
        if (NtLmGlobalEncryptionEnabled) {

            //
            // CONFIDENTIALITY implies INTEGRITY
            //

            ContextReqFlags |= ISC_REQ_INTEGRITY;

            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL |
                                       NTLMSSP_NEGOTIATE_LM_KEY |
                                       NTLMSSP_NEGOTIATE_KEY_EXCH ;

            *ContextAttributes |= ISC_RET_CONFIDENTIALITY;
            Context->ContextFlags |= ISC_RET_CONFIDENTIALITY;
        } else {
            Status = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: NtLmGlobalEncryptionEnabled is FALSE\n"));
            goto Cleanup;
        }
    }

    //
    // If the caller specified INTEGRITY, SEQUENCE_DETECT or REPLAY_DETECT,
    // that means they want to use the MakeSignature/VerifySignature
    // calls.  Add this to the negotiate.
    //

    if (ContextReqFlags &
        (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT))
    {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN |
                                   NTLMSSP_NEGOTIATE_KEY_EXCH |
                                   NTLMSSP_NEGOTIATE_LM_KEY;
    }

    if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) ||
        (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
        )
    {
        //
        // allows us to support gss-style seal/unseal for LDAP.
        //

        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM2;
    }

    if ((ContextReqFlags & ISC_REQ_INTEGRITY) != 0)
    {
        *ContextAttributes |= ISC_RET_INTEGRITY;
        Context->ContextFlags |= ISC_RET_INTEGRITY;
    }


    if ((ContextReqFlags & ISC_REQ_SEQUENCE_DETECT) != 0)
    {
        *ContextAttributes |= ISC_RET_SEQUENCE_DETECT;
        Context->ContextFlags |= ISC_RET_SEQUENCE_DETECT;
    }

    if ((ContextReqFlags & ISC_REQ_REPLAY_DETECT) != 0)
    {
        *ContextAttributes |= ISC_RET_REPLAY_DETECT;
        Context->ContextFlags |= ISC_RET_REPLAY_DETECT;
    }

    if ( (ContextReqFlags & ISC_REQ_NULL_SESSION ) != 0) {

        *ContextAttributes |= ISC_RET_NULL_SESSION;
        Context->ContextFlags |= ISC_RET_NULL_SESSION;
    }

    if ( (ContextReqFlags & ISC_REQ_CONNECTION ) != 0) {

        *ContextAttributes |= ISC_RET_CONNECTION;
        Context->ContextFlags |= ISC_RET_CONNECTION;
    }

    //
    // Check if the caller wants identify level
    //

    if ((ContextReqFlags & ISC_REQ_IDENTIFY)!= 0)  {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_IDENTIFY;
        *ContextAttributes |= ISC_RET_IDENTIFY;
        Context->ContextFlags |= ISC_RET_IDENTIFY;
    }

    IF_DEBUG( USE_OEM ) {
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_UNICODE;
    }

    if ( ((ContextReqFlags & ISC_REQ_MUTUAL_AUTH) != 0 ) &&
         (NtLmGlobalMutualAuthLevel < 2 ) ) {

        *ContextAttributes |= ISC_RET_MUTUAL_AUTH ;

        if ( NtLmGlobalMutualAuthLevel == 0 )
        {
            Context->ContextFlags |= ISC_RET_MUTUAL_AUTH ;
        }
    }

    //
    // For connection oriented security, we send a negotiate message to
    // the server.  For datagram, we get back the server's
    // capabilities in the challenge message.
    //

    if ((ContextReqFlags & ISC_REQ_DATAGRAM) == 0) {

        BOOLEAN CheckForLocal;

        if ( (Credential->DomainName.Buffer == NULL &&
              Credential->UserName.Buffer == NULL &&
              Credential->Password.Buffer == NULL )
             )
        {
            CheckForLocal = TRUE;
        } else {
            CheckForLocal = FALSE;
        }


        if ( CheckForLocal ) {

            //
            // snap up a copy of the globals so we can just take the critsect once.
            // the old way took the critsect twice, once to read sizes, second time
            // to grab buffers - bad news if the global got bigger in between.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if ( NtLmGlobalOemComputerNameString.Buffer == NULL ||
                NtLmGlobalOemPrimaryDomainNameString.Buffer == NULL ) {

                //
                // user has picked a computer name or domain name
                // that failed to convert to OEM.  disable the loopback
                // detection.
                // Sometime beyond Win2k, Negotiate package should have
                // a general, robust scheme for detecting loopback.
                //

                CheckForLocal = FALSE;

            } else {

                Status = NtLmDuplicateString(
                                        &NtLmLocalOemComputerNameString,
                                        &NtLmGlobalOemComputerNameString
                                        );

                if ( NT_SUCCESS(Status) ) {
                    Status = NtLmDuplicateString(
                                            &NtLmLocalOemPrimaryDomainNameString,
                                            &NtLmGlobalOemPrimaryDomainNameString
                                            );
                }

            }

            RtlReleaseResource(&NtLmGlobalCritSect);


            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleFirstCall: NtLmDuplicateUnicodeString (GlobalOemComputerName or GlobalOemPrimaryDomainName) returned %d\n", Status ));
                goto Cleanup;
            }
        }


        //
        // Allocate a Negotiate message
        //

        NegotiateMessageSize = sizeof(*NegotiateMessage) +
                               NtLmLocalOemComputerNameString.Length +
                               NtLmLocalOemPrimaryDomainNameString.Length;

        if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if ( NegotiateMessageSize > *OutputTokenSize ) {
                Status = SEC_E_BUFFER_TOO_SMALL;
                SspPrint(( SSP_CRITICAL,
                "SsprHandleFirstCall: OutputTokenSize is %d\n", *OutputTokenSize));
                goto Cleanup;
            }
        }

        NegotiateMessage = (PNEGOTIATE_MESSAGE)
                           NtLmAllocateLsaHeap( NegotiateMessageSize );

        if ( NegotiateMessage == NULL) {
            Status = STATUS_NO_MEMORY;
            SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: Error allocating NegotiateMessage.\n"));
            goto Cleanup;
        }

        //
        // If this is the first call,
        //  build a Negotiate message.
        //

        strcpy( (char *) NegotiateMessage->Signature, NTLMSSP_SIGNATURE );
        NegotiateMessage->MessageType = NtLmNegotiate;
        NegotiateMessage->NegotiateFlags = Context->NegotiateFlags;
        NegotiateMessage->Version = NTLMSSP_ENGINE_VERSION;

        IF_DEBUG( REQUEST_TARGET ) {
            NegotiateMessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;
        }

        //
        // Copy the DomainName and ComputerName into the negotiate message so
        // the other side can determine if this is a call from the local system.
        //
        // Pass the names in the OEM character set since the character set
        // hasn't been negotiated yet.
        //
        // Skip passing the workstation name if credentials were specified. This
        // ensures the other side doesn't fall into the case that this is the
        // local system.  We wan't to ensure the new credentials are
        // authenticated.
        //

        Where = (PCHAR)(NegotiateMessage+1);

        if ( CheckForLocal ) {

            SspContextCopyString( NegotiateMessage,
                                  &NegotiateMessage->OemWorkstationName,
                                  &NtLmLocalOemComputerNameString,
                                  &Where );

            NegotiateMessage->NegotiateFlags |=
                              NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED;


            //
            // OEM_DOMAIN_SUPPLIED used to always be supplied - but the
            // only case it is ever used is when NTLMSSP_NEGOTIATE_LOCAL_CALL
            // is set.
            //

            SspContextCopyString( NegotiateMessage,
                                  &NegotiateMessage->OemDomainName,
                                  &NtLmLocalOemPrimaryDomainNameString,
                                  &Where );

            NegotiateMessage->NegotiateFlags |=
                                  NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED;

        }

        if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            RtlCopyMemory( *OutputToken,
                       NegotiateMessage,
                       NegotiateMessageSize );

        }
        else
        {
            *OutputToken = NegotiateMessage;
            NegotiateMessage = NULL;
            *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
        }

        *OutputTokenSize = NegotiateMessageSize;

    }

    //
    // Save a reference to the credential in the context.
    //

    Context->Credential = Credential;
    Credential = NULL;

    //
    // Check for a caller requesting datagram security.
    //

    if ((ContextReqFlags & ISC_REQ_DATAGRAM) != 0) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_NT_ONLY;
        Context->ContextFlags |= ISC_RET_DATAGRAM;
        *ContextAttributes |= ISC_RET_DATAGRAM;

        // If datagram security is required, then we don't send back a token

        *OutputTokenSize = 0;



        //
        // Generate a session key for this context if sign or seal was
        // requested.
        //

        if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL)) != 0) {

            Status = SspGenerateRandomBits(
                        Context->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH
                        );

            if ( !NT_SUCCESS( Status ) ) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleFirstCall: SspGenerateRandomBits failed\n"));
                goto Cleanup;
            }
        }
        RtlCopyMemory(
            SessionKey,
            Context->SessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );


        //
        // Unless client wants to force its use,
        // Turn off strong crypt, because we can't negotiate it.
        //

        if (!NtLmGlobalDatagramUse128BitEncryption) {
            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_128;
        }

        //
        // likewise for 56bit.  note that package init handles turning
        // off 56bit if 128bit is configured for datagram.
        //

        if (!NtLmGlobalDatagramUse56BitEncryption) {
            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_56;
        }

        //
        //  Unless client wants to require NTLM2, can't use its
        //  message processing features because we start using
        //  MD5 sigs, full duplex mode, and datagram rekey before
        //  we know if the server supports NTLM2.
        //

        if (!NtLmGlobalRequireNtlm2) {
            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_NTLM2;
        }

        //
        // done fiddling with the negotiate flags, output them.
        //

        *NegotiateFlags = Context->NegotiateFlags;

        //
        // send back the negotiate flags to control signing and sealing
        //

        *NegotiateFlags |= NTLMSSP_APP_SEQ;

    }

    if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH )
    {
        Status = SspGenerateRandomBits(
                    Context->SessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH
                    );

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: SspGenerateRandomBits failed\n"));
            goto Cleanup;
        }

        RtlCopyMemory(
            SessionKey,
            Context->SessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );
    }

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    Status = SEC_I_CONTINUE_NEEDED;
    Context->State = NegotiateSentState;


    SspPrint(( SSP_NEGOTIATE_FLAGS,
        "SsprHandleFirstCall: NegotiateFlags = %lx\n", Context->NegotiateFlags));


    //
    // Check that caller asked for minimum security required.
    //

    if (!SsprCheckMinimumSecurity(
            Context->NegotiateFlags,
            NtLmGlobalMinimumClientSecurity)) {

        Status = SEC_E_UNSUPPORTED_FUNCTION;

        SspPrint(( SSP_CRITICAL,
                  "SsprHandleFirstCall: "
                  "Caller didn't request minimum security requirements (caller=0x%lx wanted=0x%lx).\n",
                    Context->NegotiateFlags, NtLmGlobalMinimumClientSecurity ));
        goto Cleanup;
    }


    //
    // Free and locally used resources.
    //
Cleanup:

    if ( Context != NULL ) {

        //
        // If we failed,
        //  deallocate the context we allocated above.
        //
        // Delinking is a side effect of referencing, so do that.
        //

        if ( !NT_SUCCESS(Status) ) {

            PSSP_CONTEXT LocalContext;
            SspContextReferenceContext( *ContextHandle, TRUE, &LocalContext );

            ASSERT( LocalContext != NULL );
            if ( LocalContext != NULL ) {
                SspContextDereferenceContext( LocalContext );
            }
        }

        // Always dereference it.

        SspContextDereferenceContext( Context );
    }

    if ( NegotiateMessage != NULL ) {
        (VOID) NtLmFreeLsaHeap( NegotiateMessage );
    }

    if ( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    if ( NtLmLocalOemComputerNameString.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalOemComputerNameString.Buffer );
    }

    if ( NtLmLocalOemPrimaryDomainNameString.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalOemPrimaryDomainNameString.Buffer );
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleFirstCall: 0x%lx\n", Status ));
    return Status;

    UNREFERENCED_PARAMETER( InputToken );
    UNREFERENCED_PARAMETER( InputTokenSize );

}

//+-------------------------------------------------------------------------
//
//  Function:   SppGenerateExplicitCredAudit
//
//  Synopsis:   Generates audit event when a logon is initiated by
//              explicitly supplying credentials.
//
//  Arguments:  pContext             -- pointer to SSP context
//              pChallengeMessage    -- pointer to challenge message. the target
//                                      information is extracted from this.
//              ChallengeMessageSize -- size of the above
//              DoUnicode            -- whether the target info is in
//                                      unicode or ascii format.
//
//  Returns:    NTSTATUS code
//
//--------------------------------------------------------------------------

NTSTATUS
NTAPI
SppGenerateExplicitCredAudit(
    IN PSSP_CONTEXT pContext,
    IN PCHALLENGE_MESSAGE pChallengeMessage,
    IN ULONG ChallengeMessageSize,
    IN BOOLEAN DoUnicode
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING  TargetName = { 0 };
    UNICODE_STRING  TargetInfo = { 0 };
    PUNICODE_STRING pTargetName = NULL;
    PUNICODE_STRING pTargetInfo = NULL;
    PWSTR pszTemp = NULL;
 
    ASSERT( DoUnicode && L"SppGenerateExplicitCredAudit: DoUnicode is FALSE" );

    //
    // we do not handle non-unicode for now.
    //

    if ( !pContext || !pContext->Credential || !DoUnicode)
    {
        goto Cleanup;
    }

    //
    // extract target info from ChallengeMessage
    //

    if ((pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO) &&
        (pChallengeMessage->TargetInfo.Length != 0) &&
        (pChallengeMessage->TargetInfo.Buffer != NULL))
    {
        //
        // target info is present. convert to absolute format now.
        //

        if (SspConvertRelativeToAbsolute (
                pChallengeMessage,
                ChallengeMessageSize,
                &pChallengeMessage->TargetInfo,
                (PSTRING)&TargetInfo,
                DoUnicode,
                TRUE    // NULL target info OK
                ))
        {
            //
            // get the DNS computer name
            //
            Status = MsvpAvlToString(
                         &TargetInfo,
                         MsvAvDnsComputerName,
                         &pszTemp
                         );

            if ( NT_SUCCESS(Status) && pszTemp )
            {
                //
                // initialize the target name/info to the same value
                //

                RtlInitUnicodeString( &TargetInfo, pszTemp );
                RtlInitUnicodeString( &TargetName, pszTemp );
            }
            else
            {
                //
                // DNS name not available, get the Netbios computer name
                //

                Status = MsvpAvlToString(
                             &TargetInfo,
                             MsvAvNbComputerName,
                             &pszTemp
                             );

                if ( NT_SUCCESS(Status) && pszTemp )
                {
                    //
                    // initialize the target name/info to the same value
                    //

                    RtlInitUnicodeString( &TargetInfo, pszTemp );
                    RtlInitUnicodeString( &TargetName, pszTemp );
                }
            }
        }
        else
        {
            SspPrint(( SSP_CRITICAL,
                       "SppGenerateExplicitCredAudit: "
                       "ChallengeMessage.TargetInfo size wrong %ld\n",
                       ChallengeMessageSize ));
        }
    }

    if ( TargetInfo.Length && TargetName.Length )
    {
        pTargetInfo = &TargetInfo;
        pTargetName = &TargetName;
    }
    //
    // target info not available or could not be extracted,
    // but we may have "domain name\0servername" (or "servername")
    // in TargetName instead, use that if available.
    //
    else if ((pChallengeMessage->TargetName.Length != 0) &&
             (pChallengeMessage->TargetName.Buffer != NULL))
    {
        if (SspConvertRelativeToAbsolute (
                pChallengeMessage,
                ChallengeMessageSize,
                &pChallengeMessage->TargetName,
                (PSTRING)&TargetName,
                DoUnicode,
                TRUE    // NULL target info OK
                ))
        {
            //
            // determine the TargetName format
            // "domain name\0servername" or "servername"
            //

            PWSTR psz = TargetName.Buffer;
            USHORT cb = 0;

            while ((cb < TargetName.Length) && *psz)
            {
                psz++;
                cb += sizeof(WCHAR);
            }

            if ( cb < TargetName.Length )
            {
                //
                // we have "domain name\0servername", skip the
                // domain name part.
                //

                psz++;
                TargetName.Buffer = psz;
                TargetName.Length = TargetName.Length - cb;
                TargetName.MaximumLength = TargetName.Length;
            }

            pTargetName = pTargetInfo = &TargetName;

        }
        else
        {
            SspPrint(( SSP_CRITICAL,
                       "SppGenerateExplicitCredAudit: "
                       "ChallengeMessage.TargetName size wrong %ld\n",
                       ChallengeMessageSize ));
        }
    }

    {
        SECPKG_CALL_INFO CallInfo;

        LsaFunctions->GetCallInfo(&CallInfo);


        Status = I_LsaIAuditLogonUsingExplicitCreds(
                     EVENTLOG_AUDIT_SUCCESS,
                     &pContext->Credential->LogonId, // user1 logon id
                     NULL,                  // user1 logon guid
                     (HANDLE) (ULONG_PTR) CallInfo.ProcessId,
                     &pContext->UserName,
                     &pContext->DomainName,
                     NULL,                  // user2 logon guid (NULL for ntlm)
                     pTargetName,
                     pTargetInfo
                     );
    }

 Cleanup:

    if ( pszTemp )
    {
        NtLmFree( pszTemp );
    }

    return Status;
}



NTSTATUS
SsprHandleChallengeMessage(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PLSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN PUNICODE_STRING TargetServerName,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    IN OUT PULONG SecondOutputTokenSize,
    OUT PVOID *SecondOutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    )

/*++

Routine Description:

    Handle the Challenge message part of InitializeSecurityContext.

Arguments:

    DomainName,UserName,Password - Passed in credentials to be used for this
        context.

    DomainNameSize,userNameSize,PasswordSize - length in characters of the
        credentials to be used for this context.

    SessionKey - Session key to use for this context

    NegotiateFlags - Flags negotiated for this context

    TargetServerName - Target server name, used by CredMgr to associates NT4 servers with domains

    All other arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_NO_CREDENTIALS -- There are no credentials for this client
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;
    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    PNTLM_CHALLENGE_MESSAGE NtLmChallengeMessage = NULL;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    PNTLM_INITIALIZE_RESPONSE NtLmInitializeResponse = NULL;
    PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponseMessage = NULL;
    STRING UserName = {0};
    STRING DomainName = {0};
    STRING Workstation = {0};
    STRING LmChallengeResponse = {0};
    STRING NtChallengeResponse = {0};
    STRING DatagramSessionKey = {0};
    BOOLEAN DoUnicode = TRUE;

    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS ProtocolStatus;
    NTSTATUS AuditStatus = STATUS_SUCCESS;

    MSV1_0_GETCHALLENRESP_REQUEST TempChallengeResponse;
    PMSV1_0_GETCHALLENRESP_REQUEST GetChallengeResponse;
    ULONG GetChallengeResponseSize;

    UNICODE_STRING RevealedPassword = {0};

    ULONG ChallengeResponseSize;
    ULONG AuthenticateMessageSize;
    PCHAR Where;
    UCHAR DatagramKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    PLUID ClientLogonId = NULL;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation;
    BOOLEAN UseSuppliedCreds = FALSE;
    PSSP_CREDENTIAL Credential = NULL;
    BOOLEAN fCallFromRedir = FALSE;
    BOOLEAN fShareLevel = FALSE;    // is target down-level share based security (no username) ?
    BOOLEAN fCredmanCredentials = FALSE;    // used credman creds?

    UNICODE_STRING TargetName = {0};
    UNICODE_STRING DefectiveTargetName = {0}; // for broken servers.
    LPWSTR szCredTargetDomain = NULL;
    LPWSTR szCredTargetServer = NULL;
    LPWSTR szCredTargetDnsDomain = NULL;
    LPWSTR szCredTargetDnsServer = NULL;
    LPWSTR szCredTargetDnsTree = NULL;
    LPWSTR szCredTargetPreDFSServer = NULL;
    LUID LogonIdNetworkService = NETWORKSERVICE_LUID;

    PSSP_CONTEXT ServerContext = NULL;  // server context referenced during loopback
    HANDLE ClientTokenHandle = NULL;    // access token associated with client
                                        // which called AcquireCredentialsHandle (OUTBOUND)

    SspPrint((SSP_API_MORE, "Entering SsprHandleChallengeMessage\n"));

    //
    // Initialization
    //

    *ContextAttributes = 0;
    *NegotiateFlags = 0;

    GetChallengeResponse = &TempChallengeResponse;

    if (*ContextHandle == NULL)
    {
        // This is possibly an old style redir call (for 4.0 and before)
        // so, alloc the context and replace the creds if new ones exists

        fCallFromRedir = TRUE;

        SspPrint((SSP_API_MORE, "SsprHandleChallengeMessage: *ContextHandle is NULL (old-style RDR)\n"));

        if ((ContextReqFlags & ISC_REQ_USE_SUPPLIED_CREDS) != 0)
        {
            UseSuppliedCreds = TRUE;
        }

        // This is a  superflous check since we alloc only if the caller
        // has asked us too. This is to make sure that the redir always asks us to alloc

        if (!(ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY))
        {
            SecStatus = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        SecStatus = SspCredentialReferenceCredential(
                        CredentialHandle,
                        FALSE,
                        &Credential );

        if ( !NT_SUCCESS( SecStatus ) )
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: SspCredentialReferenceCredential returns %x.\n", SecStatus ));
            goto Cleanup;
        }

        //
        // Allocate a new context
        //

        Context = SspContextAllocateContext();

        if (Context == NULL)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: SspContextAllocateContext returns NULL.\n" ));
            SecStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // We've just added a context, we don't nornally add and then
        // reference it.

        SspContextDereferenceContext( Context );

        *ContextHandle = (LSA_SEC_HANDLE) Context;

        //
        // Capture the default credentials from the credential structure.
        //

        if ( Credential->DomainName.Buffer != NULL ) {
            Status = NtLmDuplicateUnicodeString(
                        &Context->DomainName,
                        &Credential->DomainName
                        );
            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString (DomainName) returned %d\n",Status));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }
        }
        if ( Credential->UserName.Buffer != NULL ) {
            Status = NtLmDuplicateUnicodeString(
                        &Context->UserName,
                        &Credential->UserName
                        );
            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString (UserName) returned %d\n", Status ));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }
        }

        SecStatus = SspCredentialGetPassword(
                        Credential,
                        &Context->Password
                        );

        if (!NT_SUCCESS(SecStatus)) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleChallengeMessage: SspCredentialGetPassword returned %d\n", SecStatus ));
            goto Cleanup;
        }

        // Assign the Credential

        Context->Credential = Credential;
        Credential = NULL;

        //
        // fake it
        //

        Context->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                                  NTLMSSP_NEGOTIATE_OEM |
                                  NTLMSSP_REQUEST_TARGET |
                                  NTLMSSP_REQUEST_INIT_RESPONSE |
                                  ((NtLmGlobalLmProtocolSupported != 0)
                                  ? NTLMSSP_NEGOTIATE_NTLM2 : 0 ) |
                                  NTLMSSP_TARGET_TYPE_SERVER |
                                  NTLMSSP_NEGOTIATE_VERSION;


        *ExpirationTime = SspContextGetTimeStamp(Context, TRUE);

        Context->State = NegotiateSentState;

        // If creds are passed in by the RDR, then replace the ones in the context
        if (UseSuppliedCreds)
        {
            if (SecondInputTokenSize < sizeof(NTLM_CHALLENGE_MESSAGE))
            {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: Invalid SecondInputTokensize.\n" ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            NtLmChallengeMessage = (PNTLM_CHALLENGE_MESSAGE) NtLmAllocatePrivateHeap(SecondInputTokenSize);
            if (NtLmChallengeMessage == NULL)
            {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: Error while allocating NtLmChallengeMessage\n" ));
                SecStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(NtLmChallengeMessage,
                          SecondInputToken,
                          SecondInputTokenSize);

            //
            // NULL session is only true if user, domain, and password are all
            // empty strings in stead of NULLs
            //

            if (((NtLmChallengeMessage->Password.Length == 0) && (NtLmChallengeMessage->Password.Buffer != NULL)) &&
                ((NtLmChallengeMessage->UserName.Length == 0) && (NtLmChallengeMessage->UserName.Buffer != NULL)) &&
                ((NtLmChallengeMessage->DomainName.Length == 0) && (NtLmChallengeMessage->DomainName.Buffer != NULL)))
            {
                // This could only be a null session request

                SspPrint(( SSP_WARNING, "SsprHandleChallengeMessage: null session NtLmChallengeMessage\n" ));

                if (Context->Password.Buffer != NULL)
                {
                    // free it first
                    NtLmFreePrivateHeap (Context->Password.Buffer);
                }

                Context->Password.Buffer =  (LPWSTR) NtLmAllocatePrivateHeap(sizeof(WCHAR));
                if (Context->Password.Buffer == NULL)
                {
                    SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmAllocatePrivateHeap(Password) returns NULL.\n"));
                    SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
                Context->Password.Length = 0;
                Context->Password.MaximumLength = 0;
                *(Context->Password.Buffer) = L'\0';
                SspHidePassword(&Context->Password);

                if (Context->UserName.Buffer != NULL)
                {
                    // free it first
                    NtLmFreePrivateHeap (Context->UserName.Buffer);
                }

                Context->UserName.Buffer =  (LPWSTR) NtLmAllocatePrivateHeap(sizeof(WCHAR));
                if (Context->UserName.Buffer == NULL)
                {
                    SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmAllocatePrivateHeap(UserName) returns NULL.\n"));
                    SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
                Context->UserName.Length = 0;
                Context->UserName.MaximumLength = sizeof(WCHAR);
                *(Context->UserName.Buffer) = L'\0';

                if (Context->DomainName.Buffer != NULL)
                {
                    // free it first
                    NtLmFreePrivateHeap (Context->DomainName.Buffer);
                }

                Context->DomainName.Buffer =  (LPWSTR) NtLmAllocatePrivateHeap(sizeof(WCHAR));
                if (Context->DomainName.Buffer == NULL)
                {
                    SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmAllocatePrivateHeap(DomainName) returns NULL.\n"));
                    SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
                Context->DomainName.Length = 0;
                Context->DomainName.MaximumLength = sizeof(WCHAR);
                *(Context->DomainName.Buffer) = L'\0';
            }
            else
            {
                ULONG_PTR BufferTail = (ULONG_PTR)NtLmChallengeMessage + SecondInputTokenSize;
                UNICODE_STRING AbsoluteString;


                if (NtLmChallengeMessage->Password.Buffer != 0)
                {
                    AbsoluteString.Buffer = (LPWSTR)((PUCHAR)NtLmChallengeMessage + NtLmChallengeMessage->Password.Buffer);

                    //
                    // verify buffer not out of range.
                    //

                    if ( ( (ULONG_PTR)AbsoluteString.Buffer > BufferTail ) ||
                        ( (ULONG_PTR)((PUCHAR)AbsoluteString.Buffer + NtLmChallengeMessage->Password.Length) > BufferTail ) ||
                        ( (ULONG_PTR)AbsoluteString.Buffer < (ULONG_PTR)NtLmChallengeMessage )
                        )
                    {
                        SecStatus = SEC_E_NO_CREDENTIALS;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Buffer overflow (Password).\n" ));
                        goto Cleanup;

                    }

                    if (Context->Password.Buffer != NULL)
                    {
                        // free it first
                        NtLmFreePrivateHeap (Context->Password.Buffer);
                        Context->Password.Buffer = NULL;
                    }

                    AbsoluteString.Length = AbsoluteString.MaximumLength = NtLmChallengeMessage->Password.Length;

                    SecStatus = NtLmDuplicatePassword(
                                    &Context->Password,
                                    &AbsoluteString
                                    );

                    if (!NT_SUCCESS(SecStatus))
                    {
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmDuplicatePassword returns 0x%lx.\n",SecStatus ));
                        goto Cleanup;
                    }

                    SspHidePassword(&Context->Password);
                }

                if (NtLmChallengeMessage->UserName.Length != 0)
                {
                    AbsoluteString.Buffer = (LPWSTR)((PUCHAR)NtLmChallengeMessage + NtLmChallengeMessage->UserName.Buffer);

                    //
                    // verify buffer not out of range.
                    //

                    if ( ( (ULONG_PTR)AbsoluteString.Buffer > BufferTail ) ||
                        ( (ULONG_PTR)((PUCHAR)AbsoluteString.Buffer + NtLmChallengeMessage->UserName.Length) > BufferTail ) ||
                        ( (ULONG_PTR)AbsoluteString.Buffer < (ULONG_PTR)NtLmChallengeMessage )
                        )
                    {
                        SecStatus = SEC_E_NO_CREDENTIALS;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Buffer overflow (UserName).\n" ));
                        goto Cleanup;

                    }

                    if (Context->UserName.Buffer != NULL)
                    {
                        // free it first
                        NtLmFreePrivateHeap (Context->UserName.Buffer);
                    }

                    AbsoluteString.Length = AbsoluteString.MaximumLength = NtLmChallengeMessage->UserName.Length;
                    SecStatus = NtLmDuplicateUnicodeString(&Context->UserName,
                                                       &AbsoluteString);
                    if (!NT_SUCCESS(SecStatus))
                    {
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString(UserName) returns 0x%lx.\n",SecStatus ));
                        goto Cleanup;
                    }
                }

                if (NtLmChallengeMessage->DomainName.Length != 0)
                {
                    AbsoluteString.Buffer = (LPWSTR)((PUCHAR)NtLmChallengeMessage + NtLmChallengeMessage->DomainName.Buffer);

                    //
                    // verify buffer not out of range.
                    //

                    if ( ( (ULONG_PTR)AbsoluteString.Buffer > BufferTail ) ||
                        ( (ULONG_PTR)((PUCHAR)AbsoluteString.Buffer + NtLmChallengeMessage->DomainName.Length) > BufferTail ) ||
                        ( (ULONG_PTR)AbsoluteString.Buffer < (ULONG_PTR)NtLmChallengeMessage )
                        )
                    {
                        SecStatus = SEC_E_NO_CREDENTIALS;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Buffer overflow (DomainName).\n" ));
                        goto Cleanup;

                    }

                    if (Context->DomainName.Buffer != NULL)
                    {
                        // free it first
                        NtLmFreePrivateHeap (Context->DomainName.Buffer);
                    }

                    AbsoluteString.Length = AbsoluteString.MaximumLength = NtLmChallengeMessage->DomainName.Length;
                    SecStatus = NtLmDuplicateUnicodeString(&Context->DomainName,
                                                       &AbsoluteString);
                    if (!NT_SUCCESS(SecStatus))
                    {
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString(DomainName) returns 0x%lx.\n",SecStatus ));
                        goto Cleanup;
                    }
                }
            }

            if (NtLmChallengeMessage)
            {
                NtLmFreePrivateHeap (NtLmChallengeMessage);
                NtLmChallengeMessage = NULL;
            }

        } // end of special casing if credentials are supplied in the first init call

    } // end of special casing for the old style redir


    //
    // Find the currently existing context.
    //

    SecStatus = SspContextReferenceContext( *ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(SecStatus) )
    {
        SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: invalid context handle.\n" ));
        goto Cleanup;
    }


    //
    // passing Accept handle to Init can cause AV
    //

    if ( Context->Credential == NULL ) {
        SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: invalid context handle, missing credential.\n" ));

        SecStatus = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // If this is not reauthentication (or is datagram reauthentication)
    // pull the context out of the associated credential.
    //

    if ((Context->State != AuthenticateSentState) ||
       (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0)
    {
        ClientLogonId = &Context->Credential->LogonId;
        ImpersonationLevel = Context->Credential->ImpersonationLevel;
    }

    //
    // process the TargetServerName to see if marshalled target info was
    // passed in.  This can happen if the caller passes in marshalled target
    // info for each call to InitializeSecurityContext(), or, uses the downlevel
    // RDR path which happened previously in this routine.
    //

    Status = CredpExtractMarshalledTargetInfo(
                TargetServerName,
                &Context->TargetInfo
                );

    if (!NT_SUCCESS(Status)) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleChallengeMessage: CredpExtractMarshalledTargetInfo returned %d\n", Status ));
        goto Cleanup;
    }

    //
    // If we have already sent the authenticate message, then this must be
    // RPC calling Initialize a third time to re-authenticate a connection.
    // This happens when a new interface is called over an existing
    // connection.  What we do here is build a NULL authenticate message
    // that the server will recognize and also ignore.
    //

    //
    // That being said, if we are doing datagram style authentication then
    // the story is different.  The server may have dropped this security
    // context and then the client sent another packet over.  The server
    // will then be trying to restore the context, so we need to build
    // another authenticate message.
    //

    if ( Context->State == AuthenticateSentState ) {
        AUTHENTICATE_MESSAGE NullMessage;

        if (((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) ==
                NTLMSSP_NEGOTIATE_DATAGRAM) &&
            (InputTokenSize != 0) &&
            (InputToken != NULL) ) {

            //
            // we are doing a reauthentication for datagram, so let this
            // through.  We don't want the security.dll remapping this
            // context.
            //

            *ContextAttributes |= SSP_RET_REAUTHENTICATION;

        } else {

            //
            // To make sure this is the intended meaning of the call, check
            // that the input token is NULL.
            //

            if ( (InputTokenSize != 0) || (InputToken != NULL) ) {

                SecStatus = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: (re-auth) invalid InputTokenSize.\n" ));
                goto Cleanup;
            }

            if ( (*OutputTokenSize < sizeof(NullMessage))  &&
                 ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0))
            {
                SecStatus = SEC_E_BUFFER_TOO_SMALL;
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: invalid OutputTokenSize.\n" ));
            }
            else {
                RtlZeroMemory( &NullMessage, sizeof(NullMessage) );

                strcpy( (char *)NullMessage.Signature, NTLMSSP_SIGNATURE );
                NullMessage.MessageType = NtLmAuthenticate;
                if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
                {
                    RtlCopyMemory( *OutputToken,
                        &NullMessage,
                        sizeof(NullMessage));
                }
                else
                {
                    PAUTHENTICATE_MESSAGE NewNullMessage = (PAUTHENTICATE_MESSAGE)
                                            NtLmAllocateLsaHeap(sizeof(NullMessage));
                    if ( NewNullMessage == NULL)
                    {
                        SecStatus = STATUS_NO_MEMORY;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Error allocating NewNullMessage.\n" ));
                        goto Cleanup;
                    }

                    *OutputToken = NewNullMessage;
                    NewNullMessage = NULL;
                    *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
                }
                *OutputTokenSize = sizeof(NullMessage);
            }

            *ContextAttributes |= SSP_RET_REAUTHENTICATION;
            goto Cleanup;

        }

    } else if ( Context->State != NegotiateSentState ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "Context not in NegotiateSentState\n" ));
        SecStatus = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    //
    // We don't support any options.
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & ISC_REQ_PROMPT_FOR_CREDS) != 0 ){

        SspPrint(( SSP_CRITICAL,
                 "SsprHandleChallengeMessage: invalid ContextReqFlags 0x%lx.\n",
                 ContextReqFlags ));
        SecStatus = SEC_E_INVALID_CONTEXT_REQ;
        goto Cleanup;
    }

    //
    // Ignore the Credential Handle.
    //
    // Since this is the second call,
    // the credential is implied by the Context.
    // We could double check that the Credential Handle is either NULL or
    // correct.  However, our implementation doesn't maintain a close
    // association between the two (actually no association) so checking
    // would require a lot of overhead.
    //

    UNREFERENCED_PARAMETER( CredentialHandle );

    //
    // Get the ChallengeMessage.
    //

    if ( InputTokenSize < sizeof(OLD_CHALLENGE_MESSAGE) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage size wrong %ld\n",
                  InputTokenSize ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    SecStatus = SspContextGetMessage( InputToken,
                    InputTokenSize,
                    NtLmChallenge,
                    (PVOID *)&ChallengeMessage );

    if ( !NT_SUCCESS(SecStatus) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage GetMessage returns 0x%lx\n",
                  SecStatus ));
        goto Cleanup;
    }

    //
    // for down-level RDR, EXPORTED_CONTEXT is a hint that we are talking to
    // share level target.
    //

    if ( fCallFromRedir )
    {
        if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT )
        {
            ChallengeMessage->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT);
            fShareLevel = TRUE;

            SspPrint(( SSP_WARNING,
                      "SsprHandleChallengeMessage: "
                      "downlevel sharelevel security target\n"));
        }
    }

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM ) {

        //
        // take out any flags we didn't ask for -- self defense from bogus combinations
        //

        ChallengeMessage->NegotiateFlags &=
            ( Context->NegotiateFlags |
                NTLMSSP_NEGOTIATE_TARGET_INFO |
                NTLMSSP_TARGET_TYPE_SERVER |
                NTLMSSP_TARGET_TYPE_DOMAIN |
                NTLMSSP_NEGOTIATE_LOCAL_CALL);
    }


    //
    // Determine if the caller wants OEM or UNICODE
    //

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_OEM;
        DoUnicode = TRUE;
    } else if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM ){
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_UNICODE;
        DoUnicode = FALSE;
    } else {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Copy other interesting negotiate flags into the context
    //

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;
    } else {
        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_TARGET_INFO);
    }

    //
    // if got NTLM2, or if LM_KEY specifically forbidden don't use LM_KEY
    //

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)) {

        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server support NTLM2 caused LM_KEY to be disabled.\n" ));
        }

        ChallengeMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;
        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_LM_KEY);
    }

    //
    // if we did not get NTLM2 remove it from context negotiate flags
    //

    if (!(ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)) {
        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support NTLM2 and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_NTLM2);
    }

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) {
        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support NTLM and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_NTLM);
    }


    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) == 0) {
        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support KEY_EXCH and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_KEY_EXCH);
    }


    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY) == 0) {
        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support LM_KEY and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_LM_KEY);
    }


    //
    // make sure KEY_EXCH is always set if DATAGRAM negotiated and we need a key
    //  this is for local internal use; its now safe because we've got the bits
    //  to go on the wire copied...
    //

    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) &&
        (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL)))
    {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;
    }


    //
    // allow negotiate of certain options such as sign/seal when server
    // asked for it, but client didn't.
    //

#if 0
////
    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL ) {
        if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) == 0 ) {
            SspPrint(( SSP_SESSION_KEYS,
                  "SsprHandleChallengeMessage: client didn't request SEAL but server did, adding SEAL.\n"));
        }

        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
    }


    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN ) {
        if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) == 0 ) {
            SspPrint(( SSP_SESSION_KEYS,
                  "SsprHandleChallengeMessage: client didn't request SIGN but server did, adding SIGN.\n"));
        }

        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }
////
#endif

    //
    // if server didn't support certain crypto strengths, insure they
    // are disabled.
    //

    if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_56) == 0 ) {
        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_56 ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                  "SsprHandleChallengeMessage: Client supported 56, but server didn't.\n"));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_56);
    }


    if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_128) == 0 ) {

        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_128 ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                  "SsprHandleChallengeMessage: Client supported 128, but server didn't.\n"));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_128);
    }

    //
    // Check that server gave minimum security required.
    // not done for legacy down-level case, as, NegotiateFlags are
    // constructed from incomplete information.
    //

    if ( !fCallFromRedir )
    {
        if (!SsprCheckMinimumSecurity(
                    Context->NegotiateFlags,
                    NtLmGlobalMinimumClientSecurity)) {

            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "ChallengeMessage didn't support minimum security requirements.\n" ));
            goto Cleanup;
        }
    }

    if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
    } else {
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
    }

    //
    // Determine that the caller negotiated to NTLM or nothing, but not
    // NetWare.
    //

    if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE) &&
        ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) &&
        ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0)
        ) {
        SecStatus = STATUS_NOT_SUPPORTED;
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage asked for Netware only.\n" ));
        goto Cleanup;
    }

    if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION) {
        if (InputTokenSize >= RTL_SIZEOF_THROUGH_FIELD(CHALLENGE_MESSAGE, Version)) {

            C_ASSERT(sizeof(NTLM_VER_INFO) == sizeof(ULONG64));

            RtlCopyMemory(&Context->ServerVersion, &ChallengeMessage->Version, sizeof(ChallengeMessage->Version));

            SspPrint(( SSP_VERSION,
                "SsprHandleChallengeMessage: ServerVersion %#I64x, Major %I64d, Minor %I64d, Build %I64d, Revision %I64d\n",
                ChallengeMessage->Version,
                Context->ServerVersion.Major,
                Context->ServerVersion.Minor,
                Context->ServerVersion.Build,
                Context->ServerVersion.Revision ));

        } else {
            SecStatus = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: ChallengeMessage size too small with NTLMSSP_NEGOTIATE_VERSION\n" ));
            goto Cleanup;
        }
    }

    //
    // Check if we negotiated for identify level
    //

    if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {
        if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {

            Context->ContextFlags |= ISC_REQ_IDENTIFY;
            *ContextAttributes |= ISC_RET_IDENTIFY;
        } else {
            SecStatus = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
            goto Cleanup;
        }
    }

    //
    // If the server is running on this same machine,
    //  just duplicate our caller's token and use it.
    //

    while ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL )
    {
        ULONG_PTR ServerContextHandle;
        static const UCHAR FixedSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH] = {
                                'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                };


        SspPrint(( SSP_MISC,
                  "SsprHandleChallengeMessage: Local Call.\n"));

        //
        // Require the new challenge message if we are going to access the
        // server context handle
        //

        if ( InputTokenSize < sizeof(CHALLENGE_MESSAGE) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: invalid InputTokenSize.\n"));
            goto Cleanup;
        }

        //
        // Open the server's context here within this process.
        //

        ServerContextHandle = (ULONG_PTR)(ChallengeMessage->ServerContextHandle);

        SspContextReferenceContext(
            ServerContextHandle,
            FALSE,
            &ServerContext
            );
            
        if ( ServerContext == NULL )
        {
            //
            // This means the server has lied about this being a local call or
            //  the server process has exitted.
            // this can happen if the client and server have not had netbios
            // machine names set, so, allow this and continue processing
            // as if this were not loopback.
            //

            SspPrint(( SSP_WARNING,
                      "SsprHandleChallengeMessage: "
                      "ChallengeMessage bad ServerContextHandle 0x%p\n",
                      ChallengeMessage->ServerContextHandle));

            ChallengeMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LOCAL_CALL;
            break;
        }

        if (((ServerContext->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) == 0) ||
            (ServerContext->State != ChallengeSentState)
            )
        {
            SspPrint(( SSP_WARNING,
                      "SsprHandleChallengeMessage: "
                      "ChallengeMessage claimed ServerContextHandle in bad state 0x%p\n",
                      ChallengeMessage->ServerContextHandle));

            ChallengeMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LOCAL_CALL;
            break;
        }

        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_LOCAL_CALL;

        //
        // Local loopback for network servcice
        //

        if ( (Context->Credential->MutableCredFlags & SSP_CREDENTIAL_FLAG_WAS_NETWORK_SERVICE) )
        {
            SspPrint((SSP_WARNING, "SsprHandleChallengeMessage using networkservice in local loopback\n"));

            ClientLogonId = &LogonIdNetworkService;
        }

        //
        // open the token associated with the caller at the time of the
        // AcquireCredentialsHandle() call.
        //

        SecStatus = LsaFunctions->OpenTokenByLogonId(
                        ClientLogonId,
                        &ClientTokenHandle
                        );

        if (!NT_SUCCESS(SecStatus))
        {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "Could not open client token 0x%lx\n",
                      SecStatus ));
            goto Cleanup;
        }


        if ( ImpersonationLevel < SecurityImpersonation )
        {
            SspPrint(( SSP_WARNING, "Reducing impersonation level %lu to %lu\n",
                        SecurityImpersonation, ImpersonationLevel));
        }

        if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) != 0) {
            ImpersonationLevel = min(SecurityIdentification, ImpersonationLevel);
        }


        SecStatus = SspDuplicateToken(
                        ClientTokenHandle,
                        ImpersonationLevel,
                        &ServerContext->TokenHandle
                        );

        if (!NT_SUCCESS(SecStatus)) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "Could not duplicate client token 0x%lx\n",
                      SecStatus ));
            goto Cleanup;
        }

        //
        // enable all privileges in the duplicated token, to be consistent
        // with what a network logon normally looks like
        // (all privileges held are enabled by default).
        //

        if (!SspEnableAllPrivilegesToken(ServerContext->TokenHandle))
        {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "Could not enable all privileges for loopback.\n"));
        }

        //
        // give local call a hard-coded session key so calls into RDR
        // to fetch a session key succeed (eg: RtlGetUserSessionKeyClient)
        //

        RtlCopyMemory(Context->SessionKey, FixedSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);


        //
        // Don't pass any credentials in the authenticate message.
        //

        RtlInitString( &DomainName, NULL );
        RtlInitString( &UserName, NULL );
        RtlInitString( &Workstation, NULL );
        RtlInitString( &NtChallengeResponse, NULL );
        RtlInitString( &LmChallengeResponse, NULL );
        RtlInitString( &DatagramSessionKey, NULL );

        break;
    }

    //
    // If the server is running on a diffent machine,
    //  determine the caller's DomainName, UserName and ChallengeResponse
    //  to pass back in the AuthenicateMessage.
    //

    if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) == 0 )
    {
        //
        // Build the GetChallengeResponse message to pass to the LSA.
        //

        PCHAR MarshalPtr;     // marshalling pointer
        ULONG MarshalBytes;
        UNICODE_STRING TargetInfo;

        CREDENTIAL_TARGET_INFORMATIONW CredTargetInfo;

        //
        // insure all fields NULL.
        //

        ZeroMemory( &CredTargetInfo, sizeof(CredTargetInfo) );

        ZeroMemory( GetChallengeResponse, sizeof(*GetChallengeResponse) );
        GetChallengeResponseSize = sizeof(*GetChallengeResponse);
        GetChallengeResponse->MessageType = MsV1_0Lm20GetChallengeResponse;
        GetChallengeResponse->ParameterControl = 0;


        if ( Context->Credential )
        {
            PUNICODE_STRING TmpDomainName = &(Context->Credential->DomainName);
            PUNICODE_STRING TmpUserName = &(Context->Credential->UserName);
            PUNICODE_STRING TmpPassword = &(Context->Credential->Password);

            if ( (TmpDomainName->Buffer != NULL) ||
                (TmpUserName->Buffer != NULL) ||
                (TmpPassword->Buffer != NULL)
                )
            {
                UseSuppliedCreds = TRUE;
            }
        }

        //
        // if caller specifically asked for non nt session key, give it to them
        //

        if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_REQUEST_NON_NT_SESSION_KEY ) ||
             (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY))
        {
            GetChallengeResponse->ParameterControl |= RETURN_NON_NT_USER_SESSION_KEY;
        }

        GetChallengeResponse->ParameterControl |= GCR_NTLM3_PARMS;

        //
        // if TargetInfo present, use it, otherwise construct it from target name
        //

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)
        {
            if ( InputTokenSize < RTL_SIZEOF_THROUGH_FIELD(CHALLENGE_MESSAGE, TargetInfo) ) {
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage size wrong when target info flag on %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // validate and relocate the target info
            //

            if (!SspConvertRelativeToAbsolute (
                    ChallengeMessage,
                    InputTokenSize,
                    &ChallengeMessage->TargetInfo,
                    (PSTRING)&TargetInfo,
                    DoUnicode,
                    TRUE    // NULL target info OK
                    ))
            {
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage.TargetInfo size wrong %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Calculate mashal data size for the target info case
            //
            if ( UseSuppliedCreds )
            {
                MarshalBytes =
                    TargetInfo.Length +
                    Context->DomainName.Length +
                    Context->UserName.Length +
                    Context->Password.Length +
                    (4*sizeof(WCHAR));
            } else {
                MarshalBytes =
                    TargetInfo.Length +
                    (DNLEN * sizeof(WCHAR)) +
                    (UNLEN * sizeof(WCHAR)) +
                    (PWLEN * sizeof(WCHAR)) +
                    (4*sizeof(WCHAR));
            }

            //
            // Sets a "reasonable" upper limit on the token size
            // to avoid unbounded stack allocations.  The limit is
            // NTLMSSP_MAX_MESSAGE_SIZE*4 for historical reasons.
            //

            if ((NTLMSSP_MAX_MESSAGE_SIZE*4)<MarshalBytes){
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage.TargetInfo size wrong %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Allocate buffer for GetChallengeResponse + marshalled data
            //
            SafeAllocaAllocate(GetChallengeResponse, MarshalBytes +
                    sizeof(*GetChallengeResponse));

            if (!GetChallengeResponse){
                SecStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // Copy in the MSV1_0_GETCHALLENRESP_REQUEST structure so far
            //
            *GetChallengeResponse = TempChallengeResponse;

            MarshalPtr = (PCHAR)(GetChallengeResponse+1);


            // TargetInfo now contains the server's netbios domain name

            //
            // MSV needs the server name to be 'in' the passed in buffer.
            //

            SspContextCopyStringAbsolute(
                GetChallengeResponse,
                (PSTRING)&GetChallengeResponse->ServerName,
                (PSTRING)&TargetInfo,
                &MarshalPtr
                );

            GetChallengeResponseSize += GetChallengeResponse->ServerName.Length;

            //
            // tell GCR that its an AV list.
            //

            GetChallengeResponse->ParameterControl |= GCR_TARGET_INFO;

            // get various target names
            if ( !UseSuppliedCreds )
            {

                ULONG AvFlags = 0;

                //
                // Uplevel -- get the info from the comprehensive TARGET_INFO
                //
                //

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvNbDomainName,
                            &szCredTargetDomain
                            );
                if (!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvNbComputerName,
                            &szCredTargetServer
                            );
                if (!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvDnsDomainName,
                            &szCredTargetDnsDomain
                            );
                if (!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvDnsComputerName,
                            &szCredTargetDnsServer
                            );
                if (!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvDnsTreeName,
                            &szCredTargetDnsTree
                            );
                if (!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                if ( TargetServerName && TargetServerName->Length )
                {
                    //
                    // check TargetServerName against szTargetServer.  If they don't match, we have a DFS share.
                    // Add Pre-DFS ServerName
                    //


                    LPWSTR szTargetServerName = TargetServerName->Buffer;
                    DWORD cchTarget = TargetServerName->Length / sizeof(WCHAR);

                    DWORD IndexSlash;

                    for (IndexSlash = 0 ; IndexSlash < cchTarget; IndexSlash++)
                    {
                        if (TargetServerName->Buffer[IndexSlash] == L'/')
                        {
                            cchTarget -= IndexSlash;
                            szTargetServerName = &TargetServerName->Buffer[ IndexSlash+1 ];
                            break;
                        }
                    }

                    szCredTargetPreDFSServer = (LPWSTR)NtLmAllocatePrivateHeap( (cchTarget+1) * sizeof(WCHAR) );
                    if ( szCredTargetPreDFSServer == NULL )
                    {
                        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                        goto Cleanup;
                    }

                    CopyMemory( szCredTargetPreDFSServer, szTargetServerName, cchTarget*sizeof(WCHAR) );
                    szCredTargetPreDFSServer[ cchTarget ] = L'\0';

                    CredTargetInfo.TargetName = szCredTargetPreDFSServer;
                }


                //
                // see if server enabled the funky guest bit (tm)
                //

                Status = MsvpAvlToFlag(
                            &TargetInfo,
                            MsvAvFlags,
                            &AvFlags
                            );
                if ( Status == STATUS_SUCCESS )
                {
                    if ( AvFlags & MSV1_0_AV_FLAG_FORCE_GUEST )
                    {
                        CredTargetInfo.Flags |= CRED_TI_ONLY_PASSWORD_REQUIRED;
                    }
                }
            }

        } else {

            BOOLEAN DefectiveTarget = FALSE;

            // downlevel - first call may have been handled by redir


            //
            // validate and relocate the target name
            //

            if (!SspConvertRelativeToAbsolute (
                    ChallengeMessage,
                    InputTokenSize,
                    &ChallengeMessage->TargetName,
                    (PSTRING)&TargetName,
                    DoUnicode,
                    TRUE    // NULL targetname OK
                    ))
            {
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage.TargetName size wrong %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // certain flavors of Unix servers set UNICODE and OEM flags,
            // but supply an OEM buffer.  Try to resolve that here.
            //

            if ( (DoUnicode) &&
                 (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM)
                 )
            {
                if ( IsTextUnicode( TargetName.Buffer, TargetName.Length, NULL ) == 0 )
                {
                    DefectiveTarget = TRUE;
                }
            }

            //
            // convert TargetName to Unicode if needed
            //

            if ( !DoUnicode || DefectiveTarget )
            {
                UNICODE_STRING TempString;

                Status = RtlOemStringToUnicodeString(
                            &TempString,
                            (PSTRING)&TargetName,
                            TRUE);

                if ( !NT_SUCCESS(Status) ) {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                TargetName = TempString;

                if ( DefectiveTarget )
                {
                    //
                    // save it so we can free it later.
                    //

                    DefectiveTargetName = TargetName;
                }
            }


            if ( !UseSuppliedCreds )
            {

                // ChallengeMessage->TargetName will be the server's netbios domain name
                if ( TargetName.Buffer && TargetName.Length )
                {
                    LPWSTR szTmpTargetName;

                    szTmpTargetName = (PWSTR)NtLmAllocatePrivateHeap( TargetName.Length + sizeof(WCHAR) );
                    if ( szTmpTargetName == NULL )
                    {
                        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                        goto Cleanup;
                    }

                    RtlCopyMemory( szTmpTargetName, TargetName.Buffer, TargetName.Length );
                    szTmpTargetName[ TargetName.Length/sizeof(WCHAR) ] = L'\0';

                    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_TARGET_TYPE_SERVER )
                    {
                        szCredTargetServer = szTmpTargetName;
                    } else if ( ChallengeMessage->NegotiateFlags & NTLMSSP_TARGET_TYPE_DOMAIN )
                    {
                        szCredTargetDomain = szTmpTargetName;
                    }
                    // TODO: what if TARGET_TYPE not specified, or TARGET_TYPE_SHARE ?

                }

                if ( TargetServerName && TargetServerName->Length )
                {
                    //
                    // check TargetServerName against szTargetServer.  If they don't match, we have a DFS share.
                    // Add Pre-DFS ServerName
                    //


                    LPWSTR szTargetServerName = TargetServerName->Buffer;
                    DWORD cchTarget = TargetServerName->Length / sizeof(WCHAR);

                    DWORD IndexSlash;

                    for (IndexSlash = 0 ; IndexSlash < cchTarget; IndexSlash++)
                    {
                        if (TargetServerName->Buffer[IndexSlash] == L'/')
                        {
                            cchTarget -= IndexSlash;
                            szTargetServerName = &TargetServerName->Buffer[ IndexSlash+1 ];
                            break;
                        }
                    }

                    szCredTargetPreDFSServer = (LPWSTR)NtLmAllocatePrivateHeap( (cchTarget+1) * sizeof(WCHAR) );
                    if ( szCredTargetPreDFSServer == NULL )
                    {
                        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                        goto Cleanup;
                    }

                    CopyMemory( szCredTargetPreDFSServer, szTargetServerName, cchTarget*sizeof(WCHAR) );
                    szCredTargetPreDFSServer[ cchTarget ] = L'\0';

                    CredTargetInfo.TargetName = szCredTargetPreDFSServer;
                }

                if ( fShareLevel )
                {
                    CredTargetInfo.Flags |= CRED_TI_ONLY_PASSWORD_REQUIRED;
                }
            }

            //
            // Calculate mashal data size for the target name case
            //

            if ( UseSuppliedCreds )
            {
                MarshalBytes =
                    TargetName.Length +
                    Context->DomainName.Length +
                    Context->UserName.Length +
                    Context->Password.Length +
                    (4*sizeof(WCHAR));
            } else {
                MarshalBytes =
                    TargetName.Length +
                    (DNLEN * sizeof(WCHAR)) +
                    (UNLEN * sizeof(WCHAR)) +
                    (PWLEN * sizeof(WCHAR)) +
                    (4*sizeof(WCHAR));
            }

            //
            // Set a "reasonable" upper limit on the token size
            // to avoid unbounded stack allocations.  The limit is
            // NTLMSSP_MAX_MESSAGE_SIZE*4 for historical reasons.
            //

            if ((NTLMSSP_MAX_MESSAGE_SIZE*4)<MarshalBytes){
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage size wrong \n"));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Allocate buffer for GetChallengeResponse + marshalled data
            //
            SafeAllocaAllocate(GetChallengeResponse, MarshalBytes +
                    sizeof(*GetChallengeResponse));

            if (!GetChallengeResponse){
                SecStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // Copy in the MSV1_0_GETCHALLENRESP_REQUEST structure so far
            //
            *GetChallengeResponse = TempChallengeResponse;

            MarshalPtr = (PCHAR)(GetChallengeResponse+1);

            //
            // MSV needs the server name to be 'in' the passed in buffer.
            //

            SspContextCopyStringAbsolute(
                GetChallengeResponse,
                (PSTRING)&GetChallengeResponse->ServerName,
                (PSTRING)&TargetName,
                &MarshalPtr
                );

            GetChallengeResponseSize += GetChallengeResponse->ServerName.Length;

        }


        if ( !UseSuppliedCreds )
        {
            ULONG CredTypes[] = {CRED_TYPE_DOMAIN_PASSWORD};
            BOOLEAN bIsOwfPassword = FALSE;
            SECPKG_CALL_INFO CallInfo = {0};

            CredTargetInfo.NetbiosDomainName = szCredTargetDomain;
            CredTargetInfo.NetbiosServerName = szCredTargetServer;
            CredTargetInfo.DnsDomainName = szCredTargetDnsDomain;
            CredTargetInfo.DnsServerName = szCredTargetDnsServer;
            CredTargetInfo.DnsTreeName = szCredTargetDnsTree;
            CredTargetInfo.PackageName = NTLMSP_NAME;
            CredTargetInfo.CredTypeCount = COUNTOF(CredTypes);
            CredTargetInfo.CredTypes = CredTypes;


            //
            // if marshalled TargetInfo was supplied, we prefer those fields.
            //

            if ( Context->TargetInfo )
            {
                CredTargetInfo.TargetName = Context->TargetInfo->TargetName;
                CredTargetInfo.NetbiosServerName = Context->TargetInfo->NetbiosServerName;
                CredTargetInfo.DnsServerName = Context->TargetInfo->DnsServerName;
                CredTargetInfo.NetbiosDomainName = Context->TargetInfo->NetbiosDomainName;
                CredTargetInfo.DnsDomainName = Context->TargetInfo->DnsDomainName;
                CredTargetInfo.DnsTreeName = Context->TargetInfo->DnsTreeName;

                CredTargetInfo.Flags |= Context->TargetInfo->Flags;
            }

            SecStatus = CopyCredManCredentials (
                            ClientLogonId,
                            &CredTargetInfo,
                            Context,
                            fShareLevel,
                            TRUE, // allow OWF passwords
                            &bIsOwfPassword
                            );

            if ( NT_SUCCESS(SecStatus) )
            {
                fCredmanCredentials = TRUE;
                if (bIsOwfPassword)
                {
                    GetChallengeResponse->ParameterControl |= GCR_USE_OWF_PASSWORD;
                }
            }

            if ( SecStatus == STATUS_NOT_FOUND )
            {
                SecStatus = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(SecStatus) )
            {
                goto Cleanup;
            }

            //
            // stow away a copy of the marshalled target info.
            //

            if (!LsaFunctions->GetCallInfo(&CallInfo))
            {
                SecStatus = STATUS_INTERNAL_ERROR;
                goto Cleanup;
            }

            if ( fCredmanCredentials || (CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE) )
            {
                CredMarshalTargetInfo(
                    &CredTargetInfo,
                    (PUSHORT*)&(Context->pbMarshalledTargetInfo),
                    &Context->cbMarshalledTargetInfo
                    );
            }
        } else {

            //
            // if an explicit cred was supplied, check if it was a marshalled
            // cred, and if so, reject smartcard attempts.
            //

            if ( Context->UserName.Length != 0 &&
                Context->DomainName.Length == 0
                // Password may or may not contain a PIN for cert case.
                )
            {
                UNICODE_STRING UnpickledUserName;
                UNICODE_STRING UnpickledDomainName;
                UNICODE_STRING UnpickledPassword;

                Status = CredpProcessUserNameCredential(
                            &Context->UserName,
                            &UnpickledUserName,
                            &UnpickledDomainName,
                            &UnpickledPassword
                            );

                if ( NT_SUCCESS(Status) )
                {
                    NtLmFreePrivateHeap( UnpickledUserName.Buffer );
                    NtLmFreePrivateHeap( UnpickledDomainName.Buffer );
                    NtLmFreePrivateHeap( UnpickledPassword.Buffer );

                } 
                else if ( Status == STATUS_NOT_SUPPORTED )
                {
                    goto Cleanup;
                }

                Status = STATUS_SUCCESS;
            }

        }


        SspContextCopyStringAbsolute(
            GetChallengeResponse,
            (PSTRING)&GetChallengeResponse->LogonDomainName,
            (PSTRING)&Context->DomainName,
            &MarshalPtr
            );

        GetChallengeResponseSize += GetChallengeResponse->LogonDomainName.Length;

        SspContextCopyStringAbsolute(
            GetChallengeResponse,
            (PSTRING)&GetChallengeResponse->UserName,
            (PSTRING)&Context->UserName,
            &MarshalPtr
            );

        GetChallengeResponseSize += GetChallengeResponse->UserName.Length;


        //
        // Check for null session. This is the case if the caller supplies
        // an empty username, domainname, and password.
        //

        //
        // duplicate the hidden password string, then reveal it into
        // new buffer.  This avoids thread race conditions during hide/reveal
        // and also allows us to avoid re-hiding the material.
        // TODO: add flag that indicates to LSA that provided password is encrypted.
        //

        SecStatus = NtLmDuplicatePassword( &RevealedPassword, &Context->Password );
        if (!NT_SUCCESS( SecStatus ) ) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: NtLmDuplicatePassword returned %d\n",Status));
            goto Cleanup;
        }

        SspRevealPassword(&RevealedPassword);

        if (((Context->ContextFlags & ISC_RET_NULL_SESSION) != 0) ||
            (((Context->DomainName.Length == 0) && (Context->DomainName.Buffer != NULL)) &&
            ((Context->UserName.Length == 0) && (Context->UserName.Buffer != NULL)) &&
            ((Context->Password.Length == 0) && (Context->Password.Buffer != NULL)))) {

            SspPrint(( SSP_WARNING, "SsprHandleChallengeMessage: null session context\n" ));

            GetChallengeResponse->ParameterControl |= NULL_SESSION_REQUESTED |
                                                    USE_PRIMARY_PASSWORD;

        } else {

            //
            // We aren't doing a null session intentionally. MSV may choose
            // to do a null session if we have no credentials available.
            //

            if ( Context->DomainName.Buffer == NULL )
            {
                BOOLEAN FoundAt = FALSE;

                //
                // if  it's a UPN, don't fill in the domain field.
                //

                if ( Context->UserName.Buffer != NULL )
                {
                    ULONG i;

                    for (i = 0 ; i < (Context->UserName.Length / sizeof(WCHAR)) ; i++)
                    {
                        if ( Context->UserName.Buffer[i] == '@' )
                        {
                            FoundAt = TRUE;
                            break;
                        }
                    }
                }

                if ( !FoundAt )
                {
                    GetChallengeResponse->ParameterControl |=
                                  RETURN_PRIMARY_LOGON_DOMAINNAME;
                }
            }

            if ( Context->UserName.Buffer == NULL )
            {
                GetChallengeResponse->ParameterControl |= RETURN_PRIMARY_USERNAME;
            }

            //
            // The password may be a zero length password
            //

            GetChallengeResponse->Password = RevealedPassword;
            if ( Context->Password.Buffer == NULL ) {

                GetChallengeResponse->ParameterControl |= USE_PRIMARY_PASSWORD;


            } else {
                //
                // MSV needs the password to be 'in' the passed in buffer.
                //

                RtlCopyMemory(MarshalPtr,
                    GetChallengeResponse->Password.Buffer,
                    GetChallengeResponse->Password.Length);

                GetChallengeResponse->Password.Buffer =
                                           (LPWSTR)(MarshalPtr);
                GetChallengeResponseSize += GetChallengeResponse->Password.Length +
                                            sizeof(WCHAR);

            }
        }

        //
        // scrub the cleartext password now to avoid pagefile exposure
        // during lengthy processing.
        //

        if ( RevealedPassword.Buffer != NULL ) {
            ZeroMemory( RevealedPassword.Buffer, RevealedPassword.Length );
            NtLmFreePrivateHeap( RevealedPassword.Buffer );
            RevealedPassword.Buffer = NULL;
        }


        GetChallengeResponse->LogonId = *ClientLogonId;

        RtlCopyMemory( &GetChallengeResponse->ChallengeToClient,
                       ChallengeMessage->Challenge,
                       MSV1_0_CHALLENGE_LENGTH );

        //
        // if NTLM2 negotiated, then ask MSV1_0 to mix my challenge with the server's...
        //

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
        {
            GetChallengeResponse->ParameterControl |= GENERATE_CLIENT_CHALLENGE;
        } else {

            //
            // if it's share level, and:
            // 1. User only supplied a password, or
            // 2. Credman returned the creds
            // allow downgrade to NTLMv1 from NTLMv2.
            //

            if ( fShareLevel )
            {
                if ( (GetChallengeResponse->UserName.Length == 0) &&
                    (GetChallengeResponse->LogonDomainName.Length == 0) &&
                    (GetChallengeResponse->Password.Buffer != NULL)
                    )
                {
                    GetChallengeResponse->ParameterControl |= GCR_ALLOW_NTLM;
                }

                if ( fCredmanCredentials )
                {
                    GetChallengeResponse->ParameterControl |= GCR_ALLOW_NTLM;
                }
            }
            
            //
            // DataGram can not negotiate if it is non NTLM2, allow to use LM key
            //

            if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) 
            {
                //
                // handle smart servers that know to use NtUserSessionKey
                //

                if (Context->ServerVersion.Revision >= NTLMSSP_REVISION_W2K3 && NtLmGlobalLmProtocolSupported >= NoLm) 
                {
                    SspPrint((SSP_WARNING, "SsprHandleChallengeMessage turning off LM keys\n"));

                    GetChallengeResponse->ParameterControl &= ~RETURN_NON_NT_USER_SESSION_KEY;
                    Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY; // tell the server we turn off LM key 
                }
                else // let it through, this might fail if NoLmHash is stored in SAM
                {
                    GetChallengeResponse->ParameterControl |= GCR_ALLOW_LM;
                }
            }
        }

        if (!DoUnicode) {
            GetChallengeResponse->ParameterControl |= GCR_USE_OEM_SET;
        }

        //
        // Get the DomainName, UserName, and ChallengeResponse from the MSV
        //

        Status = LsaApCallPackage(
                    (PLSA_CLIENT_REQUEST)(-1),
                    GetChallengeResponse,
                    GetChallengeResponse,
                    GetChallengeResponseSize,
                    (PVOID *)&ChallengeResponseMessage,
                    &ChallengeResponseSize,
                    &ProtocolStatus );

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleChallengeMessage: "
            "ChallengeMessage LsaCall to get ChallengeResponse returns 0x%lx\n",
              Status ));
            SecStatus = SspNtStatusToSecStatus( Status, SEC_E_NO_CREDENTIALS);
            goto Cleanup;
        }

        if ( !NT_SUCCESS(ProtocolStatus) ) {
            Status = ProtocolStatus;
            SspPrint(( SSP_CRITICAL,
              "SsprHandleChallengeMessage: ChallengeMessage LsaCall "
              "to get ChallengeResponse returns ProtocolStatus 0x%lx\n",
              Status ));
            SecStatus = SspNtStatusToSecStatus( Status, SEC_E_NO_CREDENTIALS);
            goto Cleanup;
        }

        //
        // Check to see if we are doing a null session
        //

        if ((ChallengeResponseMessage->CaseSensitiveChallengeResponse.Length == 0) &&
            (ChallengeResponseMessage->CaseInsensitiveChallengeResponse.Length == 1)) {

            SspPrint(( SSP_WARNING, "SsprHandleChallengeMessage: null session\n" ));

            *ContextAttributes |= ISC_RET_NULL_SESSION;
            Context->ContextFlags |= ISC_RET_NULL_SESSION;
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_NULL_SESSION;
        } else {

            //
            // Normalize things by copying the default domain name and user name
            // into the ChallengeResponseMessage structure.
            //

            if ( Context->DomainName.Buffer != NULL ) {
                ChallengeResponseMessage->LogonDomainName = Context->DomainName;
            }
            if ( Context->UserName.Buffer != NULL ) {
                ChallengeResponseMessage->UserName = Context->UserName;
            }
        }

        //
        // Convert the domainname/user name to the right character set.
        //

        if ( DoUnicode ) {
            DomainName = *(PSTRING)&ChallengeResponseMessage->LogonDomainName;
            UserName = *(PSTRING)&ChallengeResponseMessage->UserName;
            Workstation =  *(PSTRING)&NtLmGlobalUnicodeComputerNameString;
        } else {
            Status = RtlUpcaseUnicodeStringToOemString(
                        &DomainName,
                        &ChallengeResponseMessage->LogonDomainName,
                        TRUE);

            if ( !NT_SUCCESS(Status) ) {
                SspPrint(( SSP_CRITICAL,
                            "SsprHandleChallengeMessage: RtlUpcaseUnicodeToOemString (DomainName) returned 0x%lx.\n", Status));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }

            Status = RtlUpcaseUnicodeStringToOemString(
                        &UserName,
                        &ChallengeResponseMessage->UserName,
                        TRUE);

            if ( !NT_SUCCESS(Status) ) {
                SspPrint(( SSP_CRITICAL,
                            "SsprHandleChallengeMessage: RtlUpcaseUnicodeToOemString (UserName) returned 0x%lx.\n", Status));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }
            Workstation =  NtLmGlobalOemComputerNameString;

        }

        //
        // Save the ChallengeResponses
        //

        LmChallengeResponse =
            ChallengeResponseMessage->CaseInsensitiveChallengeResponse;
        NtChallengeResponse =
            ChallengeResponseMessage->CaseSensitiveChallengeResponse;


        //
        // prepare to send encrypted randomly generated session key
        //

        DatagramSessionKey.Buffer = (CHAR*)DatagramKey;
        DatagramSessionKey.Length =
          DatagramSessionKey.MaximumLength = 0;

        //
        // Generate the session key, or encrypt the previosly generated random one,
        // from various bits of info. Fill in session key if needed.
        //

        SecStatus = SsprMakeSessionKey(
                        Context,
                        &LmChallengeResponse,
                        ChallengeResponseMessage->UserSessionKey,
                        ChallengeResponseMessage->LanmanSessionKey,
                        &DatagramSessionKey
                        );

        if (SecStatus != SEC_E_OK)
        {
            SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: SsprMakeSessionKey\n"));
            goto Cleanup;
        }

    }

    //
    // If the caller specified SEQUENCE_DETECT or REPLAY_DETECT,
    // that means they want to use the MakeSignature/VerifySignature
    // calls.  Add this to the returned attributes and the context
    // negotiate flags.
    //

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SIGN) ||
        (ContextReqFlags & ISC_REQ_REPLAY_DETECT)) {

        Context->ContextFlags |= ISC_RET_REPLAY_DETECT;
        *ContextAttributes |= ISC_RET_REPLAY_DETECT;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SIGN) ||
        (ContextReqFlags & ISC_REQ_SEQUENCE_DETECT)) {

        Context->ContextFlags |= ISC_RET_SEQUENCE_DETECT;
        *ContextAttributes |= ISC_RET_SEQUENCE_DETECT;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SIGN) ||
        (ContextReqFlags & ISC_REQ_INTEGRITY)) {

        Context->ContextFlags |= ISC_RET_INTEGRITY;
        *ContextAttributes |= ISC_RET_INTEGRITY;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SEAL) ||
        (ContextReqFlags & ISC_REQ_CONFIDENTIALITY)) {
        if (NtLmGlobalEncryptionEnabled) {
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
            Context->ContextFlags |= ISC_REQ_CONFIDENTIALITY;
            *ContextAttributes |= ISC_REQ_CONFIDENTIALITY;
        } else {
            SecStatus = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmGlobalEncryption not enabled.\n"));
            goto Cleanup;
        }
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_DATAGRAM) ==
        NTLMSSP_NEGOTIATE_DATAGRAM ) {
        *ContextAttributes |= ISC_RET_DATAGRAM;
        Context->ContextFlags |= ISC_RET_DATAGRAM;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
    }

    //
    // Slip in the hacky mutual auth override here:
    //

    if ( ((ContextReqFlags & ISC_REQ_MUTUAL_AUTH) != 0 ) &&
         (NtLmGlobalMutualAuthLevel < 2 ) ) {

        *ContextAttributes |= ISC_RET_MUTUAL_AUTH ;

        if ( NtLmGlobalMutualAuthLevel == 0 )
        {
            Context->ContextFlags |= ISC_RET_MUTUAL_AUTH ;
        }

    }

    if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) &&
        (ContextReqFlags & ISC_REQ_DELEGATE)
        )
    {
        //
        // for loopback, we can indeed support another hop.
        //

        *ContextAttributes |= ISC_RET_DELEGATE;
        Context->ContextFlags |= ISC_RET_DELEGATE;
    }

    //
    // Allocate an authenticate message
    //

    AuthenticateMessageSize =
        sizeof(*AuthenticateMessage) +
        LmChallengeResponse.Length +
        NtChallengeResponse.Length +
        DomainName.Length +
        UserName.Length +
        Workstation.Length +
        DatagramSessionKey.Length;

    if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if ( AuthenticateMessageSize > *OutputTokenSize ) {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: OutputTokenSize is 0x%lx.\n", *OutputTokenSize));
            SecStatus = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
    }

    AuthenticateMessage = (PAUTHENTICATE_MESSAGE)
                          NtLmAllocateLsaHeap(AuthenticateMessageSize );

    if ( AuthenticateMessage == NULL ) {
        SecStatus = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL,
            "SsprHandleChallengeMessage: Error allocating AuthenticateMessage.\n" ));
        goto Cleanup;
    }

    //
    // Build the authenticate message
    //

    strcpy( (char *)AuthenticateMessage->Signature, NTLMSSP_SIGNATURE );
    AuthenticateMessage->MessageType = NtLmAuthenticate;
    AuthenticateMessage->Version = NTLMSSP_ENGINE_VERSION;

    Where = (PCHAR)(AuthenticateMessage+1);

    //
    // Copy the strings needing 2 byte alignment.
    //

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->DomainName,
                          &DomainName,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->UserName,
                          &UserName,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->Workstation,
                          &Workstation,
                          &Where );

    //
    // Copy the strings not needing special alignment.
    //
    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->LmChallengeResponse,
                          &LmChallengeResponse,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->NtChallengeResponse,
                          &NtChallengeResponse,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->SessionKey,
                          &DatagramSessionKey,
                          &Where );

    AuthenticateMessage->NegotiateFlags = Context->NegotiateFlags;

    ASSERT((AuthenticateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION) && L"NTLMSSP_NEGOTIATE_VERSION should be set");

    SspPrint(( SSP_NEGOTIATE_FLAGS,
          "SsprHandleChallengeMessage: ChallengeFlags: %lx AuthenticateFlags: %lx\n",
            ChallengeMessage->NegotiateFlags, AuthenticateMessage->NegotiateFlags ));


    //
    // Copy the AuthenticateMessage to the caller's address space.
    //

    if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
    {
        RtlCopyMemory( *OutputToken,
            AuthenticateMessage,
            AuthenticateMessageSize );
    }
    else
    {
        *OutputToken = AuthenticateMessage;
        AuthenticateMessage = NULL;
        *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
    }

    *OutputTokenSize = AuthenticateMessageSize;

    // we need to send a second token back for the rdr
    if (fCallFromRedir)
    {
        NtLmInitializeResponse = (PNTLM_INITIALIZE_RESPONSE)
            NtLmAllocateLsaHeap(sizeof(NTLM_INITIALIZE_RESPONSE));

        if ( NtLmInitializeResponse == NULL ) {
            SecStatus = STATUS_NO_MEMORY;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: Error allocating NtLmInitializeResponse.\n" ));
            goto Cleanup;
        }
        RtlCopyMemory(
            NtLmInitializeResponse->UserSessionKey,
            ChallengeResponseMessage->UserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        RtlCopyMemory(
            NtLmInitializeResponse->LanmanSessionKey,
            ChallengeResponseMessage->LanmanSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );
        *SecondOutputToken = NtLmInitializeResponse;
        NtLmInitializeResponse = NULL;
        *SecondOutputTokenSize = sizeof(NTLM_INITIALIZE_RESPONSE);
    }

    // SspPrint((SSP_API_MORE, "Client session key = %p\n", Context->SessionKey));

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    SecStatus = STATUS_SUCCESS;

    //
    // Generate the explicit cred used audit for non null sessions
    //
    // LocalLoopBack uses implicit credentials only
    //

    if (NtChallengeResponse.Length) // both local loopback and null session have NtChallengeResponse zero length
    {
        AuditStatus = SppGenerateExplicitCredAudit( 
                        Context,
                        ChallengeMessage,
                        InputTokenSize,
                        DoUnicode 
                        );
    }

    //
    // Free and locally used resources.
    //
Cleanup:

    if ( RevealedPassword.Buffer != NULL ) {
        ZeroMemory( RevealedPassword.Buffer, RevealedPassword.Length );
        NtLmFreePrivateHeap( RevealedPassword.Buffer );
    }

    if ( ServerContext != NULL )
    {
        SspContextDereferenceContext( ServerContext );
    }

    if ( Context != NULL ) {

        Context->LastStatus = SecStatus;
        Context->DownLevel = fCallFromRedir;

        //
        // Don't allow this context to be used again.
        //

        if ( NT_SUCCESS(SecStatus) ) {
            Context->State = AuthenticateSentState;
        } else if ( SecStatus == SEC_I_CALL_NTLMSSP_SERVICE ) {
            Context->State = PassedToServiceState;
        } else {
            Context->State = IdleState;
        }

        RtlCopyMemory(
            SessionKey,
            Context->SessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH );

        *NegotiateFlags = Context->NegotiateFlags;

        // If we just created the context (because rdr may be talking to
        // a pre NT 5.0 server,, we need to dereference it again.

        if (fCallFromRedir && !NT_SUCCESS(SecStatus))
        {
            PSSP_CONTEXT LocalContext;
            SspContextReferenceContext( *ContextHandle, TRUE, &LocalContext );
            ASSERT(LocalContext != NULL);
            if (LocalContext != NULL)
            {
                SspContextDereferenceContext( LocalContext );
            }
        }

        SspContextDereferenceContext( Context );

    }

    if (szCredTargetPreDFSServer != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetPreDFSServer );
    }

    if (szCredTargetDomain != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDomain );
    }

    if (szCredTargetServer != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetServer );
    }

    if (szCredTargetDnsDomain != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDnsDomain );
    }

    if (szCredTargetDnsServer != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDnsServer );
    }

    if (szCredTargetDnsTree != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDnsTree );
    }

    if ( ChallengeMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( ChallengeMessage );
    }

    if ( AuthenticateMessage != NULL ) {
        (VOID) NtLmFreeLsaHeap( AuthenticateMessage );
    }

    if ( ChallengeResponseMessage != NULL ) {
        (VOID) LsaFunctions->FreeLsaHeap( ChallengeResponseMessage );
    }

    if ( !DoUnicode ) {
        RtlFreeUnicodeString( &TargetName );

        if ( DomainName.Buffer != NULL) {
            RtlFreeOemString( &DomainName );
        }
        if ( UserName.Buffer != NULL) {
            RtlFreeOemString( &UserName );
        }
    }

    RtlFreeUnicodeString( &DefectiveTargetName );

    if ( ClientTokenHandle )
    {
        CloseHandle( ClientTokenHandle );
    }

    if (GetChallengeResponse && (GetChallengeResponse!=&TempChallengeResponse)){
        SafeAllocaFree(GetChallengeResponse);
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleChallengeMessage: 0x%lx\n", SecStatus ));
    return SecStatus;

}

NTSTATUS
CredpParseUserName(
    IN OUT LPWSTR ParseName,
    OUT LPWSTR* pUserName,
    OUT LPWSTR* pDomainName
    )

/*++

Routine Description:

    This routine separates a passed in user name into domain and username.  A user name must have one
    of the following two syntaxes:

        <DomainName>\<UserName>
        <UserName>@<DnsDomainName>

    The name is considered to have the first syntax if the string contains an \.
    A string containing a @ is ambiguous since <UserName> may contain an @.

    For the second syntax, the last @ in the string is used since <UserName> may
    contain an @ but <DnsDomainName> cannot.

Arguments:

    ParseName - Name of user to validate - will be modified

    pUserName - Returned pointing to canonical name inside of ParseName

    pDomainName - Returned pointing to domain name inside of ParseName


Return Values:

    The following status codes may be returned:

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{

    LPWSTR SlashPointer;

    *pUserName = NULL;
    *pDomainName = NULL;

    //
    // NULL is invalid
    //

    if ( ParseName == NULL ) {
        return STATUS_INVALID_ACCOUNT_NAME;
    }

    //
    // Classify the input account name.
    //
    // The name is considered to be <DomainName>\<UserName> if the string
    // contains an \.
    //

    SlashPointer = wcsrchr( ParseName, L'\\' );

    if ( SlashPointer != NULL ) {

        //
        // point the output strings
        //

        *pDomainName = ParseName;

        //
        // Skip the backslash
        //

        *SlashPointer = L'\0';
        SlashPointer ++;

        *pUserName = SlashPointer;

    } else {

        //
        // it's a UPN.
        // leave it intact in the UserName field.
        // set the DomainName to empty string, so the rest of the logon code
        // avoids filling in the default.
        //

        *pUserName = ParseName;
        *pDomainName = L"";
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CopyCredManCredentials(
    IN PLUID LogonId,
    IN CREDENTIAL_TARGET_INFORMATIONW* pTargetInfo,
    IN OUT PSSP_CONTEXT Context,
    IN BOOLEAN fShareLevel,
    IN BOOLEAN bAllowOwfPassword,
    OUT BOOLEAN* pbIsOwfPassword
    )

/*++

Routine Description:

    Look for a keyring credential entry for the specified domain, and copy to Context handle if found

Arguments:

    LogonId -- LogonId of the calling process.

    pTargetInfo -- Information on target to search for creds.

    Context - Points to the ContextHandle of the Context
        to be referenced.

   fShareLevel - whether it is for sharelevel

   bAllowOwfPassword - whether to look for OWF password, this prevents
        username/domainname in Context from being trashed

   pbIsOwfPassword - whether the cred found consists of OWFs

Return Value:

    STATUS_SUCCESS -- All OK

    STATUS_NOT_FOUND - Credential couldn't be found.

    All others are real failures and should be returned to the caller.
--*/

{
    NTSTATUS Status;
    PENCRYPTED_CREDENTIALW *EncryptedCredentials = NULL;
    PCREDENTIALW *Credentials = NULL;
    PCREDENTIALW pPasswordForCertCred = NULL;
    ULONG CredentialCount;
    WCHAR* UserName = NULL;
    WCHAR* DomainName = NULL;
    UNICODE_STRING TempString = {0};
    WCHAR szTempBuffer[UNLEN + UNLEN + 4]; // to hold domain\username or username@dnsdomainname
    ENCRYPTED_CREDENTIALW* pCertCred = NULL;
    KERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE* pQuerySuppCredResp = NULL;

    if (!Context) // validate context only after call to Lookup
    {
        return STATUS_NOT_FOUND;
    }

    Status = LsaFunctions->CrediReadDomainCredentials(
                                LogonId,
                                CREDP_FLAGS_IN_PROCESS, // Allow password to be returned
                                pTargetInfo,
                                0,  // no flags
                                &CredentialCount,
                                &EncryptedCredentials
                                );

    Credentials = (PCREDENTIALW *)EncryptedCredentials;

    if (!NT_SUCCESS(Status))
    {
        //
        // Ideally, only STATUS_NO_SUCH_LOGON_SESSION should be converted to
        // STATUS_NOT_FOUND.  However, swallowing all failures and asserting
        // these specific two works around a bug in CrediReadDomainCredentials
        // which returns invalid parameter if the target is a user account name.
        // Eventually, CrediReadDomainCredentials should return a more
        // appropriate error in this case.
        //

        SspPrint((SSP_WARNING, "CopyCredManCredentials: CrediReadDomainCredentials returned %x, LogonId %#x:%#x\n",
                  Status, LogonId->HighPart, LogonId->LowPart));

        ASSERT(
            (Status == STATUS_NO_SUCH_LOGON_SESSION)||
            (Status == STATUS_INVALID_PARAMETER)||
            (Status == STATUS_NOT_FOUND)
            );
        return STATUS_NOT_FOUND;
    }

    //
    // NULL terminate scatch buffer
    //

    szTempBuffer[COUNTOF(szTempBuffer) - 1] = L'\0';

    //
    // Loop through the list of credentials
    //

    for ( ULONG CredIndex = 0; CredIndex < CredentialCount; CredIndex++ )
    {
        //
        // NTLM only supports password credentials
        // skip OWF passwords if not allowed
        //

        if ( (Credentials[CredIndex]->Type != CRED_TYPE_DOMAIN_PASSWORD)
             || (!bAllowOwfPassword && (Credentials[CredIndex]->Flags & CRED_FLAGS_OWF_CRED_BLOB)) )
        {
            continue;
        }

        //
        // For Share level connects, don't allow matching against * creds.
        //
        // CRED_FLAGS_PASSWORD_FOR_CERT cred is *Session cred
        //

        if ( fShareLevel )
        {
            if ( (Credentials[CredIndex]->TargetName) &&
                (wcschr( Credentials[CredIndex]->TargetName, L'*' ) != NULL) )
            {
                continue;
            }
        }

        if ((Credentials[CredIndex]->Flags & CRED_FLAGS_PASSWORD_FOR_CERT))
        {
            pPasswordForCertCred = Credentials[CredIndex];
            continue;
        }

        if ( Credentials[CredIndex]->Flags & CRED_FLAGS_PROMPT_NOW )
        {
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        //
        // Sanity check the credential
        //

        if ( Credentials[CredIndex]->UserName == NULL )
        {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Convert the UserName to domain name and user name
        //

        RtlCopyMemory(
            szTempBuffer,
            Credentials[CredIndex]->UserName,
            sizeof(WCHAR) * min(wcslen(Credentials[CredIndex]->UserName) + 1, COUNTOF(szTempBuffer) - 1)
            );
        Status = CredpParseUserName( szTempBuffer, &UserName, &DomainName );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Free the existing domain name and add the new one
        //

        if (Context->DomainName.Buffer)
        {
            NtLmFreePrivateHeap (Context->DomainName.Buffer);
            Context->DomainName.Buffer = NULL;
            Context->DomainName.Length = 0;
        }

        if ( DomainName )
        {
            RtlInitUnicodeString( &TempString, DomainName );

            Status = NtLmDuplicateUnicodeString(&Context->DomainName, &TempString);
            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup;
            }
        }

        //
        // Free the existing user name and add the new one
        //

        RtlInitUnicodeString( &TempString, UserName );

        if (Context->UserName.Buffer)
        {
            NtLmFreePrivateHeap (Context->UserName.Buffer);
            Context->UserName.Buffer = NULL;
        }

        Status = NtLmDuplicateUnicodeString(&Context->UserName, &TempString);
        if ( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }

        SspPrint((SSP_CRED, "CopyCredManCredentials copying credmain passwords\n"));

        TempString.Buffer = (PWSTR) Credentials[CredIndex]->CredentialBlob;
        TempString.MaximumLength = (USHORT) Credentials[CredIndex]->CredentialBlobSize;
        TempString.Length = (USHORT) EncryptedCredentials[CredIndex]->ClearCredentialBlobSize;


        //
        // zero length password must be treated as blank or NTLM will assume it
        // should use the password of the currently logged in user.
        //

        if ( TempString.Length == 0 )
        {
            TempString.Buffer = L"";
        }

        //
        // Free the existing password and add the new one
        //

        if (Context->Password.Buffer)
        {
            NtLmFreePrivateHeap (Context->Password.Buffer);
            Context->Password.Buffer = NULL;
        }

        Status = NtLmDuplicatePassword(&Context->Password, &TempString);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        *pbIsOwfPassword = (BOOLEAN) (Credentials[CredIndex]->Flags & CRED_FLAGS_OWF_CRED_BLOB);

        goto Cleanup;
    }

    //
    // now call kerberos to get password for cert cred
    //

    if (pPasswordForCertCred)
    {
        KERB_QUERY_SUPPLEMENTAL_CREDS_REQUEST QuerySuppCred;
        UNICODE_STRING KerberosPackageName = CONSTANT_UNICODE_STRING((MICROSOFT_KERBEROS_NAME_W));
        UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING((NTLMSP_NAME));
        ULONG cbResponse = 0;
        NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;
        ENCRYPTED_CREDENTIALW* pPasswordCred = NULL;

        SspPrint((SSP_CRED, "CopyCredManCredentials querying passwords for cert %ws\n", pPasswordForCertCred->TargetName));

        Status = LsaFunctions->CrediRead(
                    LogonId,
                    CREDP_FLAGS_IN_PROCESS, // CredFlags
                    pPasswordForCertCred->TargetName,
                    CRED_TYPE_DOMAIN_CERTIFICATE, // CredType
                    0, // no Flags
                    &pCertCred
                    );

        if (!NT_SUCCESS(Status))
        {
             goto Cleanup;
        }

        RtlZeroMemory(&QuerySuppCred, sizeof(QuerySuppCred));

        QuerySuppCred.MessageType = KerbQuerySupplementalCredentialsMessage;
        QuerySuppCred.PackageName = MsvPackageName;
        QuerySuppCred.MarshalledCreds = (CREDENTIALW *) pCertCred;
        QuerySuppCred.LogonId = *LogonId;

        Status = LsaFunctions->CallPackage(
                    &KerberosPackageName,
                    &QuerySuppCred,
                    sizeof(QuerySuppCred),
                    reinterpret_cast<VOID**>(&pQuerySuppCredResp),
                    &cbResponse,
                    &SubStatus
                    );

        if (!NT_SUCCESS(Status))
        {
            SspPrint((SSP_WARNING, "CopyCredManCredentials CallPackage failed with Status %#x\n", Status));
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        if (!NT_SUCCESS(SubStatus))
        {
            SspPrint((SSP_WARNING, "CopyCredManCredentials CallPackage failed with SubStatus %#x\n", SubStatus));
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        ASSERT( pQuerySuppCredResp );

        pPasswordCred = &pQuerySuppCredResp->ReturnedCreds;

        //
        // NTLM only supports password credentials and Sanity check the
        // credential
        //

        if ( (pPasswordCred->Cred.Type != CRED_TYPE_DOMAIN_PASSWORD) ||
             (pPasswordCred->Cred.Flags & CRED_FLAGS_PASSWORD_FOR_CERT) ||
             (!bAllowOwfPassword && (pPasswordCred->Cred.Flags & CRED_FLAGS_OWF_CRED_BLOB)) )
        {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        if (pPasswordCred->Cred.Flags & CRED_FLAGS_PROMPT_NOW)
        {
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        if (pPasswordCred->Cred.UserName == NULL)
        {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        SspPrint((SSP_CRED, "CopyCredManCredentials using domain\\user %ws\n", pPasswordCred->Cred.UserName));

        //
        // Convert the UserName to domain name and user name
        //

        RtlCopyMemory(
            szTempBuffer,
            pPasswordCred->Cred.UserName,
            sizeof(WCHAR) * min(wcslen(pPasswordCred->Cred.UserName) + 1, COUNTOF(szTempBuffer) - 1)
            );
        Status = CredpParseUserName( szTempBuffer, &UserName, &DomainName );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Free the existing domain name and add the new one
        //

        if (Context->DomainName.Buffer)
        {
            NtLmFreePrivateHeap(Context->DomainName.Buffer);
            Context->DomainName.Buffer = NULL;
            Context->DomainName.Length = 0;
        }

        if ( DomainName )
        {
            RtlInitUnicodeString( &TempString, DomainName );
        }

        Status = NtLmDuplicateUnicodeString(&Context->DomainName, &TempString);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Free the existing user name and add the new one
        //

        RtlInitUnicodeString( &TempString, UserName );

        if (Context->UserName.Buffer)
        {
            NtLmFreePrivateHeap(Context->UserName.Buffer);
            Context->UserName.Buffer = NULL;
        }

        Status = NtLmDuplicateUnicodeString(&Context->UserName, &TempString);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        TempString.Buffer = (PWSTR) pPasswordCred->Cred.CredentialBlob;
        TempString.MaximumLength = (USHORT) pPasswordCred->Cred.CredentialBlobSize;
        TempString.Length = (USHORT) pPasswordCred->ClearCredentialBlobSize;

        //
        // Free the existing password and add the new one
        //

        if (Context->Password.Buffer)
        {
            NtLmFreePrivateHeap(Context->Password.Buffer);
            Context->Password.Buffer = NULL;
        }

        Status = NtLmDuplicatePassword(&Context->Password, &TempString);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        *pbIsOwfPassword = (BOOLEAN) (pPasswordCred->Cred.Flags & CRED_FLAGS_OWF_CRED_BLOB);

        //
        // now this cred is good to go, write it into credman before we return
        //

        //
        // we consider failures of CrediWrite non-fatal, ignore the return code
        //

        (VOID) LsaFunctions->CrediWrite(
                    LogonId,
                    CREDP_FLAGS_IN_PROCESS, // CredFlags
                    pPasswordCred,
                    0 // no Flags
                    );

        goto Cleanup;
    }

    SspPrint((SSP_CRED, "CopyCredManCredentials no credman credential found\n"));

    Status = STATUS_NOT_FOUND;

Cleanup:

    //
    // Free the returned credentials
    //

    if (pCertCred)
    {
        LsaFunctions->FreeLsaHeap(pCertCred);
    }

    if (EncryptedCredentials)
    {
        LsaFunctions->CrediFreeCredentials(
            CredentialCount,
            EncryptedCredentials
            );
    }

    if (pQuerySuppCredResp)
    {
        LsaFunctions->FreeLsaHeap(pQuerySuppCredResp);
    }

#if DBG
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_WARNING, "CopyCredManCredentials failed to get credman password Status %#x\n", Status));
    }
#endif // DBG

    return Status;
}

NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    )
{
    CREDENTIAL_TARGET_INFORMATIONW *NewTargetInfo;
    NTSTATUS Status;

    //
    // LSA will set Length to include only the non-marshalled portion,
    // with MaximumLength trailing data to include marshalled portion.
    //

    if ( (TargetServerName == NULL) ||
        (TargetServerName->Buffer == NULL) ||
        (TargetServerName->Length >= TargetServerName->MaximumLength) ||
        ((TargetServerName->MaximumLength - TargetServerName->Length) < CRED_MARSHALED_TI_SIZE_SIZE )
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // Unmarshal the target info
    //

    Status = CredUnmarshalTargetInfo (
                TargetServerName->Buffer,
                TargetServerName->MaximumLength,
                &NewTargetInfo,
                NULL );

    if ( !NT_SUCCESS(Status) )
    {
        if ( Status == STATUS_INVALID_PARAMETER )
        {
            Status = STATUS_SUCCESS;
        }
    }
    else
    {

        if ( *pTargetInfo != NULL )
        {
            LocalFree( *pTargetInfo );
        }
        *pTargetInfo = NewTargetInfo;
    }


    return Status ;
}

NTSTATUS
CredpProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    )
{
    WCHAR FastUserName[ UNLEN+1 ];
    LPWSTR SlowUserName = NULL;
    LPWSTR TempUserName;
    CRED_MARSHAL_TYPE CredMarshalType;
    PUSERNAME_TARGET_CREDENTIAL_INFO pCredentialUserName = NULL;

    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;
    BOOLEAN bIsOwfPassword = FALSE;
    ULONG CredTypes;

    SECPKG_CLIENT_INFO ClientInfo;
    SSP_CONTEXT SspContext;
    NTSTATUS Status = STATUS_NOT_FOUND;

    ZeroMemory( &SspContext, sizeof(SspContext) );

    if ( (MarshalledUserName->Length+sizeof(WCHAR)) <= sizeof(FastUserName) )
    {
        TempUserName = FastUserName;
    } else {

        SlowUserName = (LPWSTR)NtLmAllocatePrivateHeap( MarshalledUserName->Length + sizeof(WCHAR) );
        if ( SlowUserName == NULL )
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        TempUserName = SlowUserName;
    }


    //
    // copy the input to a NULL terminated string, then attempt to unmarshal it.
    //

    RtlCopyMemory(  TempUserName,
        MarshalledUserName->Buffer,
        MarshalledUserName->Length
        );

    TempUserName[ MarshalledUserName->Length / sizeof(WCHAR) ] = L'\0';

    if (!CredUnmarshalCredentialW(
            TempUserName,
            &CredMarshalType,
            (VOID**)&pCredentialUserName
            ))
    {
        goto Cleanup;
    }

    if ( (CredMarshalType != UsernameTargetCredential) )
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }


    //
    // now query credential manager for a match.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ZeroMemory( &TargetInfo, sizeof(TargetInfo) );

    CredTypes = CRED_TYPE_DOMAIN_PASSWORD;

    TargetInfo.Flags = CRED_TI_USERNAME_TARGET;
    TargetInfo.TargetName = pCredentialUserName->UserName;
    TargetInfo.PackageName = NTLMSP_NAME;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;

    Status = CopyCredManCredentials(
                &ClientInfo.LogonId,
                &TargetInfo,
                &SspContext,
                FALSE,
                FALSE,   // do not allow OWF passwords
                &bIsOwfPassword
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // do not support OWF password via UserNameCredentials
    //

    ASSERT(!bIsOwfPassword);

    *UserName = SspContext.UserName;
    *DomainName = SspContext.DomainName;
    *Password = SspContext.Password;
    SspRevealPassword( Password );

    Status = STATUS_SUCCESS;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        NtLmFreePrivateHeap( SspContext.UserName.Buffer );
        NtLmFreePrivateHeap( SspContext.DomainName.Buffer );
        NtLmFreePrivateHeap( SspContext.Password.Buffer );
    }

    if ( SlowUserName )
    {
        NtLmFreePrivateHeap( SlowUserName );
    }

    if ( pCredentialUserName != NULL )
    {
        CredFree( pCredentialUserName );
    }

    return Status;
}

#if 0

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLsaModeContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG SavedUseValidated = 0xFF;
WCHAR SavedCredentialName[1024] = L"SaveMe";
ULONG SavedCredentialType = 0x22;


ULONG SavedCredTypes = CRED_TYPE_DOMAIN_PASSWORD;
CREDENTIAL_TARGET_INFORMATIONW SavedTargetInfo = {
    L"ntdsdc9",
    L"NTDSDC9",
    L"NTDSDC9.ntdev.microsoft.com",
    L"NTDEV",
    L"ntdev.microsoft.com",
    L"ntdev.microsoft.com",
    L"NTLM",
    0,
    1,
    &SavedCredTypes
};

NTSTATUS NTAPI
SpQueryLsaModeContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD WinStatus;
    PSSP_CONTEXT Context = NULL;
    SecPkgContext_CredentialNameW CredentialNameInfo;
    ULONG CredentialNameSize;
    LPWSTR UserCredentialName;

    PCREDENTIAL_TARGET_INFORMATIONW TempTargetInfo = NULL;
    ULONG TempTargetInfoSize;
    PCREDENTIAL_TARGET_INFORMATIONW UserTargetInfo;
    SecPkgContext_TargetInformationW TargetInfo;


    SspPrint((SSP_API, "Entering SpQueryLsaModeContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    //
    // Find the currently existing context.
    //

    Status = SspContextReferenceContext( ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(Status) )
    {
        SspPrint(( SSP_CRITICAL,
                "SpQueryLsaModeContextAttributes: invalid context handle.\n" ));
        goto Cleanup;
    }

    //
    // Return the appropriate information
    //

    switch(ContextAttribute) {
    case SECPKG_ATTR_CREDENTIAL_NAME:

        CredentialNameSize = (wcslen(SavedCredentialName) + 1) * sizeof(WCHAR);

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    CredentialNameSize,
                    (PVOID *) &UserCredentialName );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        // Copy the name to the user's address space
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    CredentialNameSize,
                    UserCredentialName,
                    SavedCredentialName );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        // Copy the struct itself to the user's address space
        CredentialNameInfo.CredentialType = SavedCredentialType;
        CredentialNameInfo.sCredentialName = UserCredentialName;

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(CredentialNameInfo),
                    Buffer,
                    &CredentialNameInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        break;

    case SECPKG_ATTR_TARGET_INFORMATION:

        //
        // Marshall the target info into a single buffer.
        //


        WinStatus = CredpConvertTargetInfo ( DoWtoW,
                        &SavedTargetInfo,
                        &TempTargetInfo,
                        &TempTargetInfoSize );

        if ( WinStatus != NO_ERROR ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Allocate a buffer the same size in the client's address space.
        //
        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    TempTargetInfoSize,
                    (PVOID *) &UserTargetInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Relocate all pointers to be user-buffer-specific
        //  YUCK!!
        //

        TempTargetInfo->TargetName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->TargetName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->NetbiosServerName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->NetbiosServerName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->DnsServerName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->DnsServerName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );

        TempTargetInfo->NetbiosDomainName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->NetbiosDomainName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->DnsDomainName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->DnsDomainName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->DnsTreeName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->DnsTreeName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->PackageName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->PackageName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->CredTypes = (LPDWORD)( ((LPBYTE)(TempTargetInfo->CredTypes)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );

        //
        // Copy the target info to the user's address space
        //
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    TempTargetInfoSize,
                    UserTargetInfo,
                    TempTargetInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy the struct itself to the user's address space
        //
        TargetInfo.TargetInformation = UserTargetInfo;

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(TargetInfo),
                    Buffer,
                    &TargetInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }


        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (Context != NULL) {
        SspContextDereferenceContext( Context );
    }
    if ( TempTargetInfo != NULL ) {
        CredFree( TempTargetInfo );
    }

    SspPrint((SSP_API, "Leaving SpQueryLsaModeContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpSetContextAttributes
//
//  Synopsis:   Set attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpSetContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;
    PSecPkgContext_CredentialNameW CredentialNameInfo;
    ULONG CredentialNameSize;
    LPBYTE LocalBuffer = NULL;


    SspPrint((SSP_API, "Entering SpSetContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    //
    // Find the currently existing context.
    //

    Status = SspContextReferenceContext( ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(Status) )
    {
        SspPrint(( SSP_CRITICAL,
                "SpSetContextAttributes: invalid context handle.\n" ));
        goto Cleanup;
    }


    //
    // Grab a local copy of the data
    //
    // Sanity check this size before allocating
    LocalBuffer = (LPBYTE) NtLmAllocatePrivateHeap( BufferSize );

    if ( LocalBuffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = LsaFunctions->CopyFromClientBuffer(
                NULL,
                BufferSize,
                LocalBuffer,
                Buffer );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Return the appropriate information
    //

    switch(ContextAttribute) {
    case SECPKG_ATTR_USE_VALIDATED:

        if ( BufferSize != sizeof(SavedUseValidated) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        SavedUseValidated = *(LPDWORD)LocalBuffer;
        break;

    case SECPKG_ATTR_CREDENTIAL_NAME:

        if ( BufferSize <= sizeof(SecPkgContext_CredentialNameW) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        // Sanity check the pointer and the contained string.
        CredentialNameInfo = (PSecPkgContext_CredentialNameW) LocalBuffer;
        SavedCredentialType = CredentialNameInfo->CredentialType;

        // I'm guessing at the offset of the string.
        wcscpy( SavedCredentialName, (LPWSTR)(CredentialNameInfo+1) );

        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (Context != NULL) {
        SspContextDereferenceContext( Context );
    }
    if ( LocalBuffer != NULL ) {
        NtLmFreePrivateHeap( LocalBuffer );
    }

    SspPrint((SSP_API, "Leaving SpSetContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credapi.cxx
//
// Contents:    Code for credentials APIs for the NtLm package
//              Main entry points into this dll:
//                SpAcceptCredentials
//                SpAcquireCredentialsHandle
//                SpFreeCredentialsHandle
//                SpQueryCredentialsAttributes
//                SpSaveCredentials
//                SpGetCredentials
//                SpDeleteCredentials
//
//              Helper functions:
//                CopyClientString
//
// History:     ChandanS   26-Jul-1996   Stolen from kerberos\client2\credapi.cxx
//
//------------------------------------------------------------------------
#define NTLM_CREDAPI
#include <global.h>

extern "C"
{
#include <nlp.h>
}



//+-------------------------------------------------------------------------
//
//  Function:   CopyClientString
//
//  Synopsis:   copies a client string to local memory, including
//              allocating space for it locally.
//
//  Arguments:
//              SourceString  - Could be Oem or Wchar in client process
//              SourceLength  - bytes
//              DoUnicode     - whether the string is Wchar
//
//  Returns:
//              DestinationString - Unicode String in Lsa Process
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT
CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString
    )
{
    SspPrint((SSP_API_MORE,"Entering CopyClientString\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    STRING TemporaryString;
    ULONG SourceSize = 0;
    ULONG CharacterSize = sizeof(CHAR);

    //
    // First initialize the string to zero, in case the source is a null
    // string
    //

    DestinationString->Length = DestinationString->MaximumLength = 0;
    DestinationString->Buffer = NULL;
    TemporaryString.Buffer = NULL;


    if (SourceString != NULL)
    {

        //
        // If the length is zero, allocate one byte for a "\0" terminator
        //

        if (SourceLength == 0)
        {
            DestinationString->Buffer = (LPWSTR) NtLmAllocate(sizeof(WCHAR));
            if (DestinationString->Buffer == NULL)
            {
                SspPrint((SSP_CRITICAL,"CopyClientString, Error from NtLmAllocate is 0x%lx\n", Status));
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            DestinationString->MaximumLength = sizeof(WCHAR);
            *DestinationString->Buffer = L'\0';

        }
        else
        {
            //
            // Allocate a temporary buffer to hold the client string. We may
            // then create a buffer for the unicode version. The length
            // is the length in characters, so  possible expand to hold unicode
            // characters and a null terminator.
            //

            if (DoUnicode)
            {
                CharacterSize = sizeof(WCHAR);
            }

            SourceSize = (SourceLength + 1) * CharacterSize;

            //
            // insure no overflow aggainst UNICODE_STRING
            //

            if ( (SourceSize > 0xFFFF) ||
                 ((SourceSize - CharacterSize) > 0xFFFF)
                 )
            {
                Status = STATUS_INVALID_PARAMETER;
                SspPrint((SSP_CRITICAL,"CopyClientString, SourceSize is too large\n"));
                goto Cleanup;
            }


            TemporaryString.Buffer = (LPSTR) NtLmAllocate(SourceSize);
            if (TemporaryString.Buffer == NULL)
            {
                Status = STATUS_NO_MEMORY;
                SspPrint((SSP_CRITICAL,"CopyClientString, Error from NtLmAllocate is 0x%lx\n", Status));
                goto Cleanup;
            }
            TemporaryString.Length = (USHORT) (SourceSize - CharacterSize);
            TemporaryString.MaximumLength = (USHORT) SourceSize;


            //
            // Finally copy the string from the client
            //

            Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            SourceSize - CharacterSize,
                            TemporaryString.Buffer,
                            SourceString
                            );

            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"CopyClientString, Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }

            //
            // If we are doing unicode, finish up now
            //
            if (DoUnicode)
            {
                DestinationString->Buffer = (LPWSTR) TemporaryString.Buffer;
                DestinationString->Length = (USHORT) (SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT) SourceSize;

                TemporaryString.Buffer = NULL;
            }
            else
            {
                //
                // allocate enough space based on the size of the original Unicode input.
                // required so that we can use our own allocation scheme.
                //

                DestinationString->Buffer = (LPWSTR)NtLmAllocate( SourceSize*sizeof(WCHAR) );
                if( DestinationString->Buffer == NULL )
                {
                    Status = STATUS_NO_MEMORY;
                    SspPrint((SSP_CRITICAL,"Error from NtLmAllocate\n"));
                    goto Cleanup;
                }

                DestinationString->Length = (USHORT)(SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT)SourceSize * sizeof(WCHAR);

                Status = RtlOemStringToUnicodeString(
                            DestinationString,
                            &TemporaryString,
                            FALSE
                            );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL,"CopyClientString, Error from RtlOemStringToUnicodeString is 0x%lx\n", Status));
                    // set to STATUS_NO_MEMORY, as it's unlikely that locale error code would be useful.
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if (TemporaryString.Buffer != NULL)
    {
        NtLmFree(TemporaryString.Buffer);
    }

    SspPrint((SSP_API_MORE,"Leaving CopyClientString\n"));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the NtLm package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              Accountname - Name of the account that logged on
//              PrimaryCredentials - Primary credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - NtLm -Specific blob of
//                  supplemental credentials.
//
//  Returns:    None
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    NTSTATUS Status = S_OK;
    SspPrint((SSP_API,"Entering SpAcceptCredentials\n"));

    Status = SspAcceptCredentials(
                LogonType,
                PrimaryCredentials,
                SupplementalCredentials
                );

    SspPrint((SSP_API,"Leaving SpAcceptCredentials\n"));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
    UNREFERENCED_PARAMETER( AccountName );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcquireCredentialsHandle
//
//  Synopsis:   Contains NtLm Code for AcquireCredentialsHandle which
//              creates a Credential associated with a logon session.
//
//  Effects:    Creates a SSP_CREDENTIAL
//
//  Arguments:  PrincipalName - Name of logon session for which to create credential
//              CredentialUseFlags - Flags indicating whether the credentials
//                  is for inbound or outbound use.
//              LogonId - The logon ID of logon session for which to create
//                  a credential.
//              AuthorizationData - Unused blob of NtLm-specific data
//              GetKeyFunction - Unused function to retrieve a session key
//              GetKeyArgument - Argument for GetKeyFunction
//              CredentialHandle - Receives handle to new credential
//              ExpirationTime - Receives expiration time for credential
//
//  Returns:
//    STATUS_SUCCESS -- Call completed successfully
//    SEC_E_NO_SPM -- Security Support Provider is not running
//    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
//    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
//    SEC_E_NOT_OWNER -- caller does not own the specified credentials
//    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpAcquireCredentialsHandle(
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID LogonId,
    IN PVOID AuthorizationData,
    IN PVOID GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PULONG_PTR CredentialHandle,
    OUT PTimeStamp ExpirationTime
    )
{
    SspPrint((SSP_API,"Entering SpAcquireCredentialsHandle\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    UNICODE_STRING Password;
    ULONG NewCredentialUseFlags = CredentialUseFlags;
    PSEC_WINNT_AUTH_IDENTITY pAuthIdentity = NULL;
    BOOLEAN DoUnicode = TRUE;
    PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentityEx = NULL;

    PSEC_WINNT_AUTH_IDENTITY_W TmpCredentials = NULL;
    ULONG CredSize = 0;
    ULONG Offset = 0;

    //
    // Initialization
    //

    RtlInitUnicodeString(
        &UserName,
        NULL);

    RtlInitUnicodeString(
        &DomainName,
        NULL);

    RtlInitUnicodeString(
        &Password,
        NULL);

    //
    // Validate the arguments
    //

    if ( (CredentialUseFlags & (SECPKG_CRED_OUTBOUND |SECPKG_CRED_INBOUND)) == 0)
    {
        Status = SEC_E_INVALID_CREDENTIAL_USE;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        SspPrint((SSP_CRITICAL,"Error from SpAquireCredentialsHandle is 0x%lx\n", Status));
        goto Cleanup;
    }

    // RDR2 passes in a 1 while talking to down level clients

    if ( ARGUMENT_PRESENT(GetKeyArgument) && (GetKeyArgument != (PVOID) 1)) {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        SspPrint((SSP_CRITICAL,"Error from SpAquireCredentialsHandle is 0x%lx\n", Status));
        goto Cleanup;
    }

    //
    // First get information about the caller.
    //

    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonIdToUse;

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->GetClientInfo is 0x%lx\n", Status));
        goto Cleanup;
    }

    //
    // If the caller supplied a logon ID, and it doesn't match the caller,
    // they must have the TCB privilege
    //


    if (ARGUMENT_PRESENT(LogonId) &&
        ((LogonId->LowPart != 0) || (LogonId->HighPart != 0)) &&
        !RtlEqualLuid( LogonId, &ClientInfo.LogonId)
        )
    {
        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from ClientInfo.HasTcbPrivilege is 0x%lx\n", Status));
            goto Cleanup;
        }

        LogonIdToUse = LogonId;

        // note: there is a special case where the LogonIdToUse specifies
        // the SYSTEM token, and there may not be a credential (and access token)
        // for that Luid yet.  This special case is handled in SsprAcquireCredentialsHandle()

    }
    else
    {
        //
        // Use the callers logon id.
        //

        LogonIdToUse = &ClientInfo.LogonId;
    } 

    //
    // Got to have an impersonation level token in order to call ACH.
    // This check used to be in lsa, but moved here to enable
    // some S4Uproxy scenarios to work w/o tcb.
    //
    if (ClientInfo.ImpersonationLevel <= SecurityIdentification)
    {
        SspPrint((SSP_CRITICAL, "Trying to acquire credentials with an token no better than SecurityIdentification\n"));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Copy over the authorization data into out address
    // space and make a local copy of the strings.
    //


    if (AuthorizationData != NULL)
    {
        SECPKG_CALL_INFO CallInfo ;
        SEC_WINNT_AUTH_IDENTITY32 Cred32 = {0};
        SEC_WINNT_AUTH_IDENTITY_EX32 CredEx32 ;

        if(!LsaFunctions->GetCallInfo( &CallInfo ))
        {
            Status = STATUS_INTERNAL_ERROR;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->GetCallInfo is 0x%lx\n", Status));
            goto Cleanup;
        }

        pAuthIdentityEx = (PSEC_WINNT_AUTH_IDENTITY_EXW) NtLmAllocate(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));

        if (pAuthIdentityEx != NULL)
        {
            if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
            {

                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( Cred32 ),
                            pAuthIdentityEx,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    RtlCopyMemory( &Cred32, pAuthIdentityEx, sizeof( Cred32 ) );
                }

            }
            else
            {
                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY),
                            pAuthIdentityEx,
                            AuthorizationData);
            }


            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from NtLmAllocate is 0x%lx\n", Status));
            goto Cleanup;
        }

        //
        // Check for the ex version
        //

        if (pAuthIdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
        {
            //
            // It's an EX structure.
            //

            if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
            {
                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( CredEx32 ),
                            &CredEx32,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    pAuthIdentityEx->Version = CredEx32.Version ;
                    pAuthIdentityEx->Length = (CredEx32.Length < sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) ?
                                               (ULONG) sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) : CredEx32.Length );

                    pAuthIdentityEx->User = (PWSTR) UlongToPtr( CredEx32.User );
                    pAuthIdentityEx->UserLength = CredEx32.UserLength ;
                    pAuthIdentityEx->Domain = (PWSTR) UlongToPtr( CredEx32.Domain );
                    pAuthIdentityEx->DomainLength = CredEx32.DomainLength ;
                    pAuthIdentityEx->Password = (PWSTR) UlongToPtr( CredEx32.Password );
                    pAuthIdentityEx->PasswordLength = CredEx32.PasswordLength ;
                    pAuthIdentityEx->Flags = CredEx32.Flags ;
                    pAuthIdentityEx->PackageList = (PWSTR) UlongToPtr( CredEx32.PackageList );
                    pAuthIdentityEx->PackageListLength = CredEx32.PackageListLength ;

                }

            }
            else
            {
                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                            pAuthIdentityEx,
                            AuthorizationData);

            }


            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &pAuthIdentityEx->User;
            CredSize = pAuthIdentityEx->Length;
            Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
        }
        else
        {
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentityEx;

            if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
            {
                pAuthIdentity->User = (PWSTR) UlongToPtr( Cred32.User );
                pAuthIdentity->UserLength = Cred32.UserLength ;
                pAuthIdentity->Domain = (PWSTR) UlongToPtr( Cred32.Domain );
                pAuthIdentity->DomainLength = Cred32.DomainLength ;
                pAuthIdentity->Password = (PWSTR) UlongToPtr( Cred32.Password );
                pAuthIdentity->PasswordLength = Cred32.PasswordLength ;
                pAuthIdentity->Flags = Cred32.Flags ;
            }
            CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
        }

        if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
        {
            DoUnicode = FALSE;
            //
            // Turn off the marshalled flag because we don't support marshalling
            // with ansi.
            //

            pAuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
        }
        else if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from pAuthIdentity->Flags is 0x%lx\n", pAuthIdentity->Flags));
            goto Cleanup;
        }


        // This is the only place where we can figure out whether null
        // session was requested

        if ((pAuthIdentity->UserLength == 0) &&
            (pAuthIdentity->DomainLength == 0) &&
            (pAuthIdentity->PasswordLength == 0) &&
            (pAuthIdentity->User != NULL) &&
            (pAuthIdentity->Domain != NULL) &&
            (pAuthIdentity->Password != NULL))
        {
            NewCredentialUseFlags |= NTLM_CRED_NULLSESSION;
        }

        if(
            // UserName may include a marshalled credential > UNLEN
            pAuthIdentity->UserLength > 0xFFFC ||   // MAX_USHORT - NULL
            pAuthIdentity->PasswordLength > PWLEN ||
            pAuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH ) {

            SspPrint((SSP_CRITICAL,"Supplied credentials illegal length.\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }


        //
        // Copy over the strings
        //
        if( (pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0 ) {
            ULONG TmpCredentialSize;
            ULONG_PTR EndOfCreds;
            ULONG_PTR TmpUser;
            ULONG_PTR TmpDomain;
            ULONG_PTR TmpPassword;


            //
            // The callers can set the length of field to n chars, but they
            // will really occupy n+1 chars (null-terminator).
            //

            TmpCredentialSize = CredSize +
                             (  pAuthIdentity->UserLength +
                                pAuthIdentity->DomainLength +
                                pAuthIdentity->PasswordLength +
                             (((pAuthIdentity->User != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Domain != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Password != NULL) ? 1 : 0)) ) * (ULONG) sizeof(WCHAR);

            EndOfCreds = (ULONG_PTR) AuthorizationData + TmpCredentialSize;

            //
            // Verify that all the offsets are valid and no overflow will happen
            //

            TmpUser = (ULONG_PTR) pAuthIdentity->User;

            if ((TmpUser != NULL) &&
                ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
                  (TmpUser > EndOfCreds) ||
                  ((TmpUser + (pAuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpUser + (pAuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
            {
                SspPrint((SSP_CRITICAL,"Username in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            TmpDomain = (ULONG_PTR) pAuthIdentity->Domain;

            if ((TmpDomain != NULL) &&
                ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
                  (TmpDomain > EndOfCreds) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
            {
                SspPrint((SSP_CRITICAL,"Domainname in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            TmpPassword = (ULONG_PTR) pAuthIdentity->Password;

            if ((TmpPassword != NULL) &&
                ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
                  (TmpPassword > EndOfCreds) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
            {
                SspPrint((SSP_CRITICAL,"Password in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // Allocate a chunk of memory for the credentials
            //

            TmpCredentials = (PSEC_WINNT_AUTH_IDENTITY_W) NtLmAllocate(TmpCredentialSize - Offset);
            if (TmpCredentials == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Copy the credentials from the client
            //

            Status = LsaFunctions->CopyFromClientBuffer(
                        NULL,
                        TmpCredentialSize - Offset,
                        TmpCredentials,
                        (PUCHAR) AuthorizationData + Offset
                        );
            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"Failed to copy whole auth identity\n"));
                goto Cleanup;
            }

            //
            // Now convert all the offsets to pointers.
            //

            if (TmpCredentials->User != NULL)
            {
                USHORT cbUser;

                TmpCredentials->User = (LPWSTR) RtlOffsetToPointer(
                                                TmpCredentials->User,
                                                (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                );

                ASSERT( (TmpCredentials->UserLength*sizeof(WCHAR)) <= 0xFFFF );

                cbUser = (USHORT)(TmpCredentials->UserLength * sizeof(WCHAR));
                UserName.Buffer = (PWSTR)NtLmAllocate( cbUser );

                if (UserName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                CopyMemory( UserName.Buffer, TmpCredentials->User, cbUser );
                UserName.Length = cbUser;
                UserName.MaximumLength = cbUser;
            }

            if (TmpCredentials->Domain != NULL)
            {
                USHORT cbDomain;

                TmpCredentials->Domain = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Domain,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );

                ASSERT( (TmpCredentials->DomainLength*sizeof(WCHAR)) <= 0xFFFF );
                cbDomain = (USHORT)(TmpCredentials->DomainLength * sizeof(WCHAR));
                DomainName.Buffer = (PWSTR)NtLmAllocate( cbDomain );

                if (DomainName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                CopyMemory( DomainName.Buffer, TmpCredentials->Domain, cbDomain );
                DomainName.Length = cbDomain;
                DomainName.MaximumLength = cbDomain;
            }

            if (TmpCredentials->Password != NULL)
            {
                USHORT cbPassword;

                TmpCredentials->Password = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Password,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );


                ASSERT( (TmpCredentials->PasswordLength*sizeof(WCHAR)) <= 0xFFFF );
                cbPassword = (USHORT)(TmpCredentials->PasswordLength * sizeof(WCHAR));
                Password.Buffer = (PWSTR)NtLmAllocate( cbPassword );

                if (Password.Buffer == NULL ) {
                    ZeroMemory( TmpCredentials->Password, cbPassword );
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                CopyMemory( Password.Buffer, TmpCredentials->Password, cbPassword );
                Password.Length = cbPassword;
                Password.MaximumLength = cbPassword;

                ZeroMemory( TmpCredentials->Password, cbPassword );
            }

        } else {

            if (pAuthIdentity->Password != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Password,
                                pAuthIdentity->PasswordLength,
                                DoUnicode,
                                &Password
                                );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
                    goto Cleanup;
                }

            }

            if (pAuthIdentity->User != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->User,
                                pAuthIdentity->UserLength,
                                DoUnicode,
                                &UserName
                                );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
                    goto Cleanup;
                }

            }

            if (pAuthIdentity->Domain != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Domain,
                                pAuthIdentity->DomainLength,
                                DoUnicode,
                                &DomainName
                                );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
                    goto Cleanup;
                }

                //
                // Make sure that the domain name length is not greater
                // than the allowed dns domain name
                //

                if (DomainName.Length > DNS_MAX_NAME_LENGTH * sizeof(WCHAR))
                {
                    SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle: Invalid supplied domain name %wZ\n",
                        &DomainName ));
                    Status = SEC_E_UNKNOWN_CREDENTIALS;
                    goto Cleanup;
                }

            }
        }
    }   // AuthorizationData != NULL

#if 0
    //
    // Handle UPN and composite NETBIOS syntax
    //
    {
        UNICODE_STRING User = UserName;
        UNICODE_STRING Domain = DomainName;

        Status =
            NtLmParseName(
                &User,
                &Domain,
                TRUE); // If successful, this will allocate and free buffers
        if(NT_SUCCESS(Status)){

                UserName = User;
                DomainName = Domain;

        }
    }
#endif

    if( Password.Length != 0 )
    {
        UNICODE_STRING OldPassword = Password;

        Status = NtLmDuplicatePassword( &Password, &OldPassword );
        if(!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        ZeroMemory( OldPassword.Buffer, OldPassword.Length );
        NtLmFree( OldPassword.Buffer );
    }

    Status = SsprAcquireCredentialHandle(
                                LogonIdToUse,
                                &ClientInfo,
                                NewCredentialUseFlags,
                                CredentialHandle,
                                ExpirationTime,
                                &DomainName,
                                &UserName,
                                &Password );

    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle, Error from SsprAcquireCredentialsHandle is 0x%lx\n", Status));
        goto Cleanup;
    }

//  These will be kept in the Credential structure and freed
//  when the Credential structure is freed

    if (DomainName.Buffer != NULL)
    {
        DomainName.Buffer = NULL;
    }

    if (UserName.Buffer != NULL)
    {
        UserName.Buffer = NULL;
    }

    if (Password.Buffer != NULL)
    {
        Password.Buffer = NULL;
    }

Cleanup:

    if (TmpCredentials != NULL)
    {
        NtLmFree(TmpCredentials);
    }

    if (DomainName.Buffer != NULL)
    {
        NtLmFree(DomainName.Buffer);
    }

    if (UserName.Buffer != NULL)
    {
        NtLmFree(UserName.Buffer);
    }

    if (Password.Buffer != NULL)
    {
        ZeroMemory(Password.Buffer, Password.Length);
        NtLmFree(Password.Buffer);
    }

    if (pAuthIdentityEx != NULL)
    {
        NtLmFree(pAuthIdentityEx);
    }

    SspPrint((SSP_API, "Leaving SpAcquireCredentialsHandle, Status is %d\n", Status));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpFreeCredentialsHandle
//
//  Synopsis:   Frees a credential created by AcquireCredentialsHandle.
//
//  Effects:    Unlinks the credential from the global list and the list
//              for this client.
//
//  Arguments:  CredentialHandle - Handle to the credential to free
//              (acquired through AcquireCredentialsHandle)
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpFreeCredentialsHandle(
    IN ULONG_PTR CredentialHandle
    )
{
    SspPrint((SSP_API, "Entering SpFreeCredentialsHandle\n"));
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CREDENTIAL Credential;

    //
    // Find the referenced credential and delink it.
    //

    Status = SspCredentialReferenceCredential(
                            CredentialHandle,
                            TRUE,       // remove the instance of the credential
                            &Credential );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint((SSP_CRITICAL, "SpFreeCredentialsHandle, Error from SspCredentialReferenceCredential is 0x%lx\n", Status));
        goto Cleanup;
    }

    //
    // Dereferencing the Credential will remove the client's reference
    // to it, causing it to be rundown if nobody else is using it.
    //

    SspCredentialDereferenceCredential( Credential );

Cleanup:

    //
    // Catch spurious INVALID_HANDLE being returned to RPC.
    //

    ASSERT( NT_SUCCESS(Status) );

    SspPrint((SSP_API, "Leaving SpFreeCredentialsHandle\n"));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


NTSTATUS
NTAPI
SpQueryCredentialsAttributes(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    )
{
    PSSP_CREDENTIAL pCredential = NULL;
    SecPkgCredentials_NamesW Names;
    LUID LogonId;
    BOOLEAN bActiveLogonsAreLocked = FALSE;

    LPWSTR pszContextNames = NULL;
    LPWSTR pWhere;

    LPWSTR pszUserName = NULL;
    LPWSTR pszDomainName = NULL;
    DWORD cchUserName = 0;
    DWORD cchDomainName = 0;
    ULONG Length;

    BOOLEAN CalledLsaLookup = FALSE;
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomain = NULL;
    LSAPR_TRANSLATED_NAMES ReferencedUser;

#if _WIN64
    SECPKG_CALL_INFO CallInfo;
#endif

    NTSTATUS Status = STATUS_SUCCESS;

    SspPrint((SSP_API,"In SpQueryCredentialsAttributes\n"));


    Names.sUserName = NULL;

    if (CredentialAttribute != SECPKG_CRED_ATTR_NAMES)
    {
        SspPrint((SSP_MISC, "Asked for illegal info level in QueryCredAttr: %d\n",
                CredentialAttribute));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = SspCredentialReferenceCredential(
                            CredentialHandle,
                            FALSE,
                            &pCredential );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint((SSP_CRITICAL, "SpQueryCredentialsAttributes, Error from SspCredentialReferenceCredential is 0x%lx\n", Status));
        goto Cleanup;
    }

#if _WIN64
    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        SspPrint((SSP_CRITICAL, "SpQueryCredentialsAttributes, failed to get callinfo 0x%lx\n", Status));
        goto Cleanup;
    }
#endif



    //
    // The logon id of the credential is constant, so it is o.k.
    // to use it without locking the credential
    //

    LogonId = pCredential->LogonId;


    //
    // credentials were either specified when cred built, or, they were defaulted.
    //

    if ( pCredential->UserName.Buffer == NULL &&
        pCredential->DomainName.Buffer == NULL )
    {
        PACTIVE_LOGON pActiveLogon = NULL;

        //
        // defaulted creds: pickup info from active logon table.
        //

        NlpLockActiveLogonsRead();
        bActiveLogonsAreLocked = TRUE;

        pActiveLogon = NlpFindActiveLogon(&LogonId);

        if (pActiveLogon)
        {
            //
            // found an active logon entry.
            //

            pszUserName = pActiveLogon->UserName.Buffer;
            cchUserName = pActiveLogon->UserName.Length / sizeof(WCHAR);
            pszDomainName = pActiveLogon->LogonDomainName.Buffer;
            cchDomainName = pActiveLogon->LogonDomainName.Length / sizeof(WCHAR);
        }
        else
        {
            PTOKEN_USER pTokenInfo;
            BYTE FastBuffer[ 256 ];
            DWORD cbTokenInfo;
            HANDLE ClientTokenHandle;

            BOOL fSuccess = FALSE;

            NlpUnlockActiveLogons();
            bActiveLogonsAreLocked = FALSE;


            //
            // get a token associated with the logon session.
            //

            Status = LsaFunctions->OpenTokenByLogonId(
                                        &LogonId,
                                        &ClientTokenHandle
                                        );

            if (!NT_SUCCESS(Status))
            {
                SspPrint(( SSP_CRITICAL,
                          "SpQueryCredentialsAttributes: "
                          "Could not open client token 0x%lx\n",
                          Status ));
                goto Cleanup;
            }

            //
            // get Sid associated with credential.
            //

            cbTokenInfo = sizeof(FastBuffer);
            pTokenInfo = (PTOKEN_USER)FastBuffer;


            fSuccess = GetTokenInformation(
                            ClientTokenHandle,
                            TokenUser,
                            pTokenInfo,
                            cbTokenInfo,
                            &cbTokenInfo
                            );


            CloseHandle( ClientTokenHandle );

            if ( fSuccess )
            {
                LSAPR_SID_ENUM_BUFFER SidEnumBuffer;
                LSAPR_SID_INFORMATION SidInfo;
                ULONG MappedCount;

                SidEnumBuffer.Entries = 1;
                SidEnumBuffer.SidInfo = &SidInfo;

                SidInfo.Sid = (LSAPR_SID*)pTokenInfo->User.Sid;

                ZeroMemory( &ReferencedUser, sizeof(ReferencedUser) );
                CalledLsaLookup = TRUE;

                Status = LsarLookupSids(
                            NtLmGlobalPolicyHandle,
                            &SidEnumBuffer,
                            &ReferencedDomain,
                            &ReferencedUser,
                            LsapLookupWksta,
                            &MappedCount
                            );

                if ( !NT_SUCCESS( Status ) ||
                    (MappedCount == 0) ||
                    (ReferencedUser.Entries == 0) ||
                    (ReferencedDomain == NULL) ||
                    (ReferencedDomain->Entries == 0)
                    )
                {
                    fSuccess = FALSE;
                }
                else
                {
                    LONG Index = ReferencedUser.Names->DomainIndex;

                    pszUserName = ReferencedUser.Names->Name.Buffer;
                    cchUserName = ReferencedUser.Names->Name.Length / sizeof(WCHAR);

                    pszDomainName = ReferencedDomain->Domains[Index].Name.Buffer;
                    cchDomainName = ReferencedDomain->Domains[Index].Name.Length / sizeof(WCHAR);
                }
            }

            if ( !fSuccess )
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                SspPrint(( SSP_CRITICAL, "SpQueryCredentialsAtributes, NlpFindActiveLogon returns FALSE\n"));
                goto Cleanup;

            }
        }

    }
    else
    {

        //
        // specified creds.
        //

        pszUserName = pCredential->UserName.Buffer;
        cchUserName = pCredential->UserName.Length / sizeof(WCHAR);
        pszDomainName = pCredential->DomainName.Buffer;
        cchDomainName = pCredential->DomainName.Length / sizeof(WCHAR);
    }

    Length = (cchUserName + 1 + cchDomainName + 1) * sizeof(WCHAR);

    pszContextNames = (LPWSTR)NtLmAllocate( Length );
    if ( pszContextNames == NULL )
    {
        goto Cleanup;
    }

    pWhere = pszContextNames;

    if ( pszDomainName)
    {
        RtlCopyMemory( pszContextNames, pszDomainName, cchDomainName * sizeof(WCHAR) );
        pszContextNames[ cchDomainName ] = L'\\';
        pWhere += (cchDomainName+1);
    }


    if ( pszUserName )
    {
        RtlCopyMemory( pWhere, pszUserName, cchUserName * sizeof(WCHAR) );
    }

    pWhere[ cchUserName ] = L'\0';

    if (bActiveLogonsAreLocked)
    {
        NlpUnlockActiveLogons();
        bActiveLogonsAreLocked = FALSE;
    }


    //
    // Allocate memory in the client's address space
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                Length,
                (PVOID *) &Names.sUserName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy the string there
    //

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                Length,
                Names.sUserName,
                pszContextNames
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now copy the address of the string there
    //

#if _WIN64

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(ULONG),
                    Buffer,
                    &Names
                    );
    }
    else
    {
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Names),
                    Buffer,
                    &Names
                    );
    }

#else

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                sizeof(Names),
                Buffer,
                &Names
                );
#endif

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    if (bActiveLogonsAreLocked)
    {
        NlpUnlockActiveLogons();
    }

    if ( pCredential != NULL )
    {
        SspCredentialDereferenceCredential( pCredential );
    }

    if ( CalledLsaLookup )
    {
        if ( ReferencedDomain )
        {
            LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST( ReferencedDomain );
        }

        LsaIFree_LSAPR_TRANSLATED_NAMES( &ReferencedUser );
    }

    if (!NT_SUCCESS(Status))
    {
        if (Names.sUserName != NULL)
        {
            (VOID) LsaFunctions->FreeClientBuffer(
                        NULL,
                        Names.sUserName
                        );
        }
    }

    if ( pszContextNames )
    {
        NtLmFree( pszContextNames );
    }

    SspPrint((SSP_API, "Leaving SpQueryCredentialsAttributes\n"));

    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


NTSTATUS NTAPI
SpSaveCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    SspPrint((SSP_API,"In SpSaveCredentials\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpGetCredentials(
    IN ULONG_PTR CredentialHandle,
    IN OUT PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    SspPrint((SSP_API,"In SpGetCredentials\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpDeleteCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Key
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Key);
    SspPrint((SSP_API,"In SpDeleteCredentials\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\credderi.c ===
/*++

Copyright (c) 1987-1998  Microsoft Corporation

Module Name:

    credderi.c

Abstract:

    Interface to credential derivation facility.

Author:

    Scott Field (sfield)    14-Jan-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "msp.h"
#include "nlp.h"

#include <sha.h>

#define HMAC_K_PADSIZE      (64)


//
// Prototype for credential derivation routines.
//

VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    );



NTSTATUS
MspNtDeriveCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0DeriveCredential.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_DERIVECRED_REQUEST DeriveCredRequest;
    PMSV1_0_DERIVECRED_RESPONSE DeriveCredResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;

    PBYTE pbOwf;
    ULONG cbOwf;

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    *ProtocolStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_DERIVECRED_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DeriveCredRequest = (PMSV1_0_DERIVECRED_REQUEST) ProtocolSubmitBuffer;

    //
    // validate supported derive types.
    //


    if( DeriveCredRequest->DeriveCredType != MSV1_0_DERIVECRED_TYPE_SHA1 &&
        DeriveCredRequest->DeriveCredType != MSV1_0_DERIVECRED_TYPE_SHA1_V2 )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // caller must pass in mixing bits into submit buffer.
    //

    if( DeriveCredRequest->DeriveCredInfoLength == 0 ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Make sure the buffer fits in the supplied size
    //

    if ( (DeriveCredRequest->DeriveCredInfoLength + sizeof(MSV1_0_DERIVECRED_REQUEST))
            > SubmitBufferSize )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Get the OWF password for this session.
    //

    Status = NlpGetPrimaryCredential( &DeriveCredRequest->LogonId, &Credential, NULL );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_DERIVECRED_RESPONSE) +
                        A_SHA_DIGEST_LEN;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      *ReturnBufferSize,
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ZeroMemory( ClientBufferDesc.MsvBuffer, *ReturnBufferSize );
    DeriveCredResponse = (PMSV1_0_DERIVECRED_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    DeriveCredResponse->MessageType = MsV1_0DeriveCredential;
    DeriveCredResponse->DeriveCredInfoLength = A_SHA_DIGEST_LEN;

    pbOwf = NULL;
    cbOwf = 0;

    if( DeriveCredRequest->DeriveCredType == MSV1_0_DERIVECRED_TYPE_SHA1_V2 )
    {
        //
        // explicitly requested derivation based on ShaOwfPassword.
        //

        if( Credential->ShaPasswordPresent )
        {
            pbOwf = (PBYTE) &(Credential->ShaOwfPassword);  // key material is SHA OWF
            cbOwf = sizeof( SHA_OWF_PASSWORD );
        }
    }
    else if( DeriveCredRequest->DeriveCredType == MSV1_0_DERIVECRED_TYPE_SHA1 )
    {
        //
        // explicitly requested derivation based on NtOwfPassword.
        //

        if( Credential->NtPasswordPresent )
        {
            pbOwf = (PBYTE) &(Credential->NtOwfPassword);   // key material is NT OWF
            cbOwf = sizeof( NT_OWF_PASSWORD );
        }
    }

    if( pbOwf == NULL )
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // derive credential from HMAC_SHA1 crypto primitive
    // (the only supported crypto primitive at the moment)
    //

    DeriveWithHMAC_SHA1(
                pbOwf,
                cbOwf,
                DeriveCredRequest->DeriveCredSubmitBuffer,
                DeriveCredRequest->DeriveCredInfoLength,
                DeriveCredResponse->DeriveCredReturnBuffer
                );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if ( Credential != NULL ) {
        ZeroMemory( Credential, sizeof(*Credential) );
        (*Lsa.FreeLsaHeap)( Credential );
    }

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    return(Status);
}

VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,              // input key material
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,                     // input mixing data
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    )
{
    unsigned __int64 rgbKipad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    unsigned __int64 rgbKopad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    A_SHA_CTX sSHAHash;
    DWORD dwBlock;

    // truncate
    if( cbKeyMaterial > HMAC_K_PADSIZE )
    {
        cbKeyMaterial = HMAC_K_PADSIZE;
    }

    ZeroMemory(rgbKipad, sizeof(rgbKipad));
    ZeroMemory(rgbKopad, sizeof(rgbKopad));

    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for( dwBlock = 0; dwBlock < (HMAC_K_PADSIZE/sizeof(unsigned __int64)) ; dwBlock++ )
    {
        rgbKipad[dwBlock] ^= 0x3636363636363636;
        rgbKopad[dwBlock] ^= 0x5C5C5C5C5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKipad, sizeof(rgbKipad));
    A_SHAUpdate(&sSHAHash, pbData, cbData);


    // Finish off the hash
    A_SHAFinal(&sSHAHash, rgbHMAC);

    // prepend Kopad to H1, hash to get HMAC
    // note: done in place to avoid buffer copies

    // final hash: output value into passed-in buffer
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKopad, sizeof(rgbKopad));
    A_SHAUpdate(&sSHAHash, rgbHMAC, A_SHA_DIGEST_LEN);
    A_SHAFinal(&sSHAHash, rgbHMAC);

    RtlSecureZeroMemory( rgbKipad, sizeof(rgbKipad) );
    RtlSecureZeroMemory( rgbKopad, sizeof(rgbKopad) );
    RtlSecureZeroMemory( &sSHAHash, sizeof(sSHAHash) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ctxtsrv.cxx ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    ctxtsrv.cxx

Abstract:

    API and support routines for handling security contexts.

Author:

    Cliff Van Dyke (CliffV) 13-Jul-1993

Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\context.c
    JClark   28-Jun-2000  Added WMI Trace Logging Support

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR, etc
#include "Trace.h"


NTSTATUS
SsprHandleNegotiateMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    Handle the Negotiate message part of AcceptSecurityContext.

Arguments:

    All arguments same as for AcceptSecurityContext

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;
    PSSP_CREDENTIAL Credential = NULL;
    STRING TargetName;
    ULONG TargetFlags = 0;

    PNEGOTIATE_MESSAGE NegotiateMessage = NULL;

    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    ULONG ChallengeMessageSize = 0;
    PCHAR Where = NULL;

    ULONG NegotiateFlagsKeyStrength;

    UNICODE_STRING NtLmLocalUnicodeTargetName;
    UNICODE_STRING TargetInfo;
    STRING NtLmLocalOemTargetName;
    STRING OemWorkstationName;
    STRING OemDomainName;

    SspPrint(( SSP_API_MORE, "Entering SsprNegotiateMessage\n" ));
    //
    // Initialization
    //

    *ContextAttributes = 0;

    RtlInitString( &TargetName, NULL );

    RtlInitUnicodeString( &NtLmLocalUnicodeTargetName, NULL );
    RtlInitString( &NtLmLocalOemTargetName, NULL );

    RtlInitUnicodeString( &TargetInfo, NULL );

    //
    // Get a pointer to the credential
    //

    Status = SspCredentialReferenceCredential(
                CredentialHandle,
                FALSE,
                &Credential );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: invalid credential handle.\n" ));
        goto Cleanup;
    }

    if ( (Credential->CredentialUseFlags & SECPKG_CRED_INBOUND) == 0 ) {
        Status = SEC_E_INVALID_CREDENTIAL_USE;
        SspPrint(( SSP_CRITICAL,
            "SsprHandleNegotiateMessage: invalid credential use.\n" ));
        goto Cleanup;
    }

    //
    // Allocate a new context
    //

    Context = SspContextAllocateContext( );

    if ( Context == NULL ) {
        Status = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL,
            "SsprHandleNegotiateMessage: SspContextAllocateContext() returned NULL.\n" ));
        goto Cleanup;
    }

    //
    // Build a handle to the newly created context.
    //

    *ContextHandle = (ULONG_PTR) Context;


    if ( (ContextReqFlags & ASC_REQ_IDENTIFY) != 0 ) {

        *ContextAttributes |= ASC_RET_IDENTIFY;
        Context->ContextFlags |= ASC_RET_IDENTIFY;
    }

    if ( (ContextReqFlags & ASC_REQ_DATAGRAM) != 0 ) {

        *ContextAttributes |= ASC_RET_DATAGRAM;
        Context->ContextFlags |= ASC_RET_DATAGRAM;
    }

    if ( (ContextReqFlags & ASC_REQ_CONNECTION) != 0 ) {

        *ContextAttributes |= ASC_RET_CONNECTION;
        Context->ContextFlags |= ASC_RET_CONNECTION;
    }

    if ( (ContextReqFlags & ASC_REQ_INTEGRITY) != 0 ) {

        *ContextAttributes |= ASC_RET_INTEGRITY;
        Context->ContextFlags |= ASC_RET_INTEGRITY;
    }

    if ( (ContextReqFlags & ASC_REQ_REPLAY_DETECT) != 0){

        *ContextAttributes |= ASC_RET_REPLAY_DETECT;
        Context->ContextFlags |= ASC_RET_REPLAY_DETECT;
    }

    if ( (ContextReqFlags & ASC_REQ_SEQUENCE_DETECT ) != 0) {

        *ContextAttributes |= ASC_RET_SEQUENCE_DETECT;
        Context->ContextFlags |= ASC_RET_SEQUENCE_DETECT;
    }

    // Nothing to return, we might need this on the next server side call.
    if ( (ContextReqFlags & ASC_REQ_ALLOW_NULL_SESSION ) != 0) {

        Context->ContextFlags |= ASC_REQ_ALLOW_NULL_SESSION;
    }

    if ( (ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) != 0) {

        *ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
        Context->ContextFlags |= ASC_RET_ALLOW_NON_USER_LOGONS;
    }

    if ( ContextReqFlags & ASC_REQ_CONFIDENTIALITY ) {

        if (NtLmGlobalEncryptionEnabled) {
            *ContextAttributes |= ASC_RET_CONFIDENTIALITY;
            Context->ContextFlags |= ASC_RET_CONFIDENTIALITY;
        } else {
            Status = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: invalid ContextReqFlags 0x%lx\n", ContextReqFlags ));
            goto Cleanup;
        }
    }

    //
    // Supported key strength(s)
    //

    NegotiateFlagsKeyStrength = NTLMSSP_NEGOTIATE_56;
    NegotiateFlagsKeyStrength |= NTLMSSP_NEGOTIATE_128;

    //
    // Get the NegotiateMessage.  If we are re-establishing a datagram
    // context then there may not be one.
    //

    if ( InputTokenSize >= sizeof(OLD_NEGOTIATE_MESSAGE) ) {

        Status = SspContextGetMessage( InputToken,
            InputTokenSize,
            NtLmNegotiate,
            (PVOID *)&NegotiateMessage );

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage GetMessage returns 0x%lx\n",
                      Status ));
            goto Cleanup;
        }

        //
        // Compute the TargetName to return in the ChallengeMessage.
        //

        if ( NegotiateMessage->NegotiateFlags & NTLMSSP_REQUEST_TARGET ||
             NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
            if ( NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE) {
                Status = NtLmDuplicateUnicodeString( &NtLmLocalUnicodeTargetName, &NtLmGlobalUnicodeTargetName );
                TargetName = *((PSTRING)&NtLmLocalUnicodeTargetName);
            } else {
                Status = NtLmDuplicateString( &NtLmLocalOemTargetName, &NtLmGlobalOemTargetName );
                TargetName = NtLmLocalOemTargetName;
            }

            //
            // if client is NTLM2-aware, send it target info AV pairs
            //

            if (NT_SUCCESS(Status))
            {
                Status = NtLmDuplicateUnicodeString( &TargetInfo, &NtLmGlobalNtLm3TargetInfo );
            }

            TargetFlags = NtLmGlobalTargetFlags;
            RtlReleaseResource (&NtLmGlobalCritSect);

            TargetFlags |= NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO;

            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                          "SsprHandleNegotiateMessage: "
                          "failed to duplicate UnicodeTargetName or OemTargetName error 0x%lx\n",
                          Status ));

                goto Cleanup;
            }

        } else {
            TargetFlags = 0;
        }

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION) {
            if (InputTokenSize >= RTL_SIZEOF_THROUGH_FIELD(NEGOTIATE_MESSAGE, Version)) {
                C_ASSERT(sizeof(NTLM_VER_INFO) == sizeof(ULONG64));

                RtlCopyMemory(&Context->ClientVersion, &NegotiateMessage->Version, sizeof(NegotiateMessage->Version));

                SspPrint(( SSP_VERSION,
                    "SsprHandleNegotiateMessage: ClientVersion %#I64x, Major %I64d, Minor %I64d, Build %I64d, Revision %I64d\n",
                    NegotiateMessage->Version,
                    Context->ClientVersion.Major,
                    Context->ClientVersion.Minor,
                    Context->ClientVersion.Build,
                    Context->ClientVersion.Revision ));

            } else {
                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: NegotiateMessage size too small with NTLMSSP_NEGOTIATE_VERSION\n" ));
                goto Cleanup;
            }
        }

        //
        // Allocate a Challenge message
        //

        ChallengeMessageSize = sizeof(*ChallengeMessage) +
                                TargetName.Length +
                                TargetInfo.Length;

        if ((ContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if ( ChallengeMessageSize > *OutputTokenSize ) {
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: invalid ChallengeMessageSize\n"));
                Status = SEC_E_BUFFER_TOO_SMALL;
                goto Cleanup;
            }
        }

        ChallengeMessage = (PCHALLENGE_MESSAGE)
                           NtLmAllocateLsaHeap( ChallengeMessageSize );

        if ( ChallengeMessage == NULL ) {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: Error allocating ChallengeMessage.\n" ));
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        ChallengeMessage->NegotiateFlags = NTLMSSP_NEGOTIATE_VERSION;

        //
        // Check that both sides can use the same authentication model.  For
        // compatibility with beta 1 and 2 (builds 612 and 683), no requested
        // authentication type is assumed to be NTLM.  If NetWare is explicitly
        // asked for, it is assumed that NTLM would have been also, so if it
        // wasn't, return an error.
        //

        if ( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE) &&
             ((NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) &&
             ((NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0)
            ) {
            Status = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage asked for Netware only.\n" ));
            goto Cleanup;
        } else {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;
        }

        //
        // if client can do NTLM2, nuke LM_KEY
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) {
            NegotiateMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;

            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM2;
        } else if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;
        }

        //
        // If the client wants to always sign messages, so be it.
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
        }

        //
        // If the caller wants identify level, so be it.
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY ) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_IDENTIFY;

            *ContextAttributes |= ASC_RET_IDENTIFY;
            Context->ContextFlags |= ASC_RET_IDENTIFY;

        }

        //
        // Determine if the caller wants OEM or UNICODE
        //
        // Prefer UNICODE if caller allows both.
        //

        if ( NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;
        } else if ( NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM ){
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;
        } else {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage bad NegotiateFlags 0x%lx\n",
                      NegotiateMessage->NegotiateFlags ));
            goto Cleanup;
        }

        //
        // Client wants Sign capability, OK.
        //
        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;

            *ContextAttributes |= (ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT);
            Context->ContextFlags |= (ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT);

        }

        //
        // Client wants Seal, OK.
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;

            *ContextAttributes |= ASC_RET_CONFIDENTIALITY;
            Context->ContextFlags |= ASC_RET_CONFIDENTIALITY;
        }

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;

        }

        if ( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_56) &&
            (NegotiateFlagsKeyStrength & NTLMSSP_NEGOTIATE_56) )
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;
        }

        if ( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_128) &&
            (NegotiateFlagsKeyStrength & NTLMSSP_NEGOTIATE_128) )
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;
        }


        //
        // If the client supplied the Domain Name and User Name,
        //  and did not request datagram, see if the client is running
        //  on this local machine.
        //

        if ( ( (NegotiateMessage->NegotiateFlags &
                NTLMSSP_NEGOTIATE_DATAGRAM) == 0) &&
             ( (NegotiateMessage->NegotiateFlags &
               (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED|
                NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED)) ==
               (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED|
                NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) ) ) {

            //
            // The client must pass the new negotiate message if they pass
            // these flags
            //

            if (InputTokenSize < RTL_SIZEOF_THROUGH_FIELD(NEGOTIATE_MESSAGE, OemWorkstationName)) {
                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: invalid InputTokenSize.\n" ));
                goto Cleanup;
            }

            //
            // Convert the names to absolute references so we
            // can compare them
            //

            if ( !SspConvertRelativeToAbsolute(
                        NegotiateMessage,
                        InputTokenSize,
                        &NegotiateMessage->OemDomainName,
                        &OemDomainName,
                        FALSE,     // No special alignment
                        FALSE ) ) { // NULL not OK

                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: Error from SspConvertRelativeToAbsolute.\n" ));
                goto Cleanup;
            }

            if ( !SspConvertRelativeToAbsolute(
                        NegotiateMessage,
                        InputTokenSize,
                        &NegotiateMessage->OemWorkstationName,
                        &OemWorkstationName,
                        FALSE,     // No special alignment
                        FALSE ) ) { // NULL not OK

                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: Error from SspConvertRelativeToAbsolute.\n" ));
                goto Cleanup;
            }

            //
            // If both strings match,
            // this is a local call.
            // The strings have already been uppercased.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if ( RtlEqualString( &OemWorkstationName,
                                 &NtLmGlobalOemComputerNameString,
                                 FALSE ) &&
                RtlEqualString( &OemDomainName,
                                 &NtLmGlobalOemPrimaryDomainNameString,
                                 FALSE )
                                 )
            {
#if DBG
                IF_DEBUG( NO_LOCAL ) {
                    // nothing.
                } else {
#endif
                    ChallengeMessage->NegotiateFlags |=
                        NTLMSSP_NEGOTIATE_LOCAL_CALL;
                    SspPrint(( SSP_MISC,
                        "SsprHandleNegotiateMessage: Local Call.\n" ));

                    ChallengeMessage->ServerContextHandle = (ULONG64)*ContextHandle;
#if DBG
                }
#endif
            }
            RtlReleaseResource (&NtLmGlobalCritSect);
        }

        //
        // Check if datagram is being negotiated
        //

        if ( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) ==
                NTLMSSP_NEGOTIATE_DATAGRAM) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
        }

    } else {

        //
        // No negotiate message.  We need to check if the caller is asking
        // for datagram.
        //

        if ((ContextReqFlags & ASC_REQ_DATAGRAM) == 0 ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage size wrong %ld\n",
                      InputTokenSize ));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // always send target info -- new for NTLM3!
        //

        TargetFlags = NTLMSSP_NEGOTIATE_TARGET_INFO;

        RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
        
        Status = NtLmDuplicateUnicodeString( &TargetInfo, &NtLmGlobalNtLm3TargetInfo );
        
        RtlReleaseResource(&NtLmGlobalCritSect);

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage(datagram): Error duplicate TargetInfo %#x\n", Status ));
            goto Cleanup;
        }

        //
        // Allocate a Challenge message
        //

        ChallengeMessageSize = sizeof(*ChallengeMessage) + TargetInfo.Length;

        if ((ContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if ( ChallengeMessageSize > *OutputTokenSize ) {
                Status = SEC_E_BUFFER_TOO_SMALL;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: invalid ChallengeMessageSize.\n" ));
                goto Cleanup;
            }
        }

        ChallengeMessage = (PCHALLENGE_MESSAGE)
                           NtLmAllocateLsaHeap(ChallengeMessageSize );

        if ( ChallengeMessage == NULL ) {
            Status = STATUS_NO_MEMORY;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: Error allocating ChallengeMessage.\n" ));
            goto Cleanup;
        }

        //
        // Record in the context that we are doing datagram.  We will tell
        // the client everything we can negotiate and let it decide what
        // to negotiate.
        //

        ChallengeMessage->NegotiateFlags = NTLMSSP_NEGOTIATE_DATAGRAM |
                                            NTLMSSP_NEGOTIATE_UNICODE |
                                            NTLMSSP_NEGOTIATE_OEM |
                                            NTLMSSP_NEGOTIATE_SIGN |
                                            NTLMSSP_NEGOTIATE_LM_KEY |
                                            NTLMSSP_NEGOTIATE_NTLM |
                                            NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                            NTLMSSP_NEGOTIATE_IDENTIFY |
                                            NTLMSSP_NEGOTIATE_NTLM2 |
                                            NTLMSSP_NEGOTIATE_KEY_EXCH |
                                            NegotiateFlagsKeyStrength |
                                            NTLMSSP_NEGOTIATE_VERSION;

        if (NtLmGlobalEncryptionEnabled) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
        }
    }

    //
    // Build the Challenge Message
    //

    strcpy( (char *) ChallengeMessage->Signature, NTLMSSP_SIGNATURE );
    ChallengeMessage->MessageType = NtLmChallenge;
    ChallengeMessage->Version = NTLMSSP_ENGINE_VERSION;
    Status = SspGenerateRandomBits( (UCHAR*)ChallengeMessage->Challenge,
                                    MSV1_0_CHALLENGE_LENGTH );
    if ( !NT_SUCCESS( Status ) ) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleNegotiateMessage: SspGenerateRandomBits failed\n"));
        goto Cleanup;
    }

    Where = (PCHAR)(ChallengeMessage + 1);

    SspContextCopyString( ChallengeMessage,
                          &ChallengeMessage->TargetName,
                          &TargetName,
                          &Where );

    SspContextCopyString( ChallengeMessage,
                          &ChallengeMessage->TargetInfo,
                          (PSTRING)&TargetInfo,
                          &Where );

    ChallengeMessage->NegotiateFlags |= TargetFlags;

    //
    // Save the Challenge and Negotiate Flags in the Context so it
    // is available when the authenticate message comes in.
    //

    RtlCopyMemory( Context->Challenge,
                   ChallengeMessage->Challenge,
                   sizeof( Context->Challenge ) );

    Context->NegotiateFlags = ChallengeMessage->NegotiateFlags;

    if (!SsprCheckMinimumSecurity(
                    Context->NegotiateFlags,
                    NtLmGlobalMinimumServerSecurity)) {

        Status = SEC_E_UNSUPPORTED_FUNCTION;
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleNegotiateMessage: "
                  "NegotiateMessage didn't support minimum security requirements. (caller=0x%lx wanted=0x%lx\n",
                   Context->NegotiateFlags, NtLmGlobalMinimumServerSecurity ));
        goto Cleanup;
    }


    if ((ContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
    {
        RtlCopyMemory( *OutputToken,
            ChallengeMessage,
            ChallengeMessageSize );
    }
    else
    {
        *OutputToken = ChallengeMessage;
        ChallengeMessage = NULL;
        *ContextAttributes |= ASC_RET_ALLOCATED_MEMORY;
    }

    *OutputTokenSize = ChallengeMessageSize;

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );
    Context->State = ChallengeSentState;

    Status = SEC_I_CONTINUE_NEEDED;

    //
    // Free and locally used resources.
    //

Cleanup:

    if ( Context != NULL ) {

        //
        // If we failed, deallocate the context we allocated above.
        // Delinking is a side effect of referencing, so do that.
        //

        if ( !NT_SUCCESS(Status) ) {
            PSSP_CONTEXT LocalContext;

            SspContextReferenceContext( *ContextHandle,
                                        TRUE,
                                        &LocalContext
                                        );

            ASSERT( LocalContext != NULL );
            if ( LocalContext != NULL ) {
                SspContextDereferenceContext( LocalContext );
            }
        }

        // Always dereference it.

        SspContextDereferenceContext( Context );
    }

    if ( NegotiateMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( NegotiateMessage );
    }

    if ( ChallengeMessage != NULL ) {
        (VOID) NtLmFreeLsaHeap( ChallengeMessage );
    }

    if ( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    if ( NtLmLocalUnicodeTargetName.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalUnicodeTargetName.Buffer );
    }

    if ( NtLmLocalOemTargetName.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalOemTargetName.Buffer );
    }

    if (TargetInfo.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( TargetInfo.Buffer );
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleNegotiateMessage: 0x%lx\n", Status ));

    return Status;
}


NTSTATUS
SsprHandleAuthenticateMessage(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PLSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags,
    OUT PHANDLE TokenHandle,
    OUT PNTSTATUS ApiSubStatus,
    OUT PTimeStamp PasswordExpiry,
    OUT PULONG UserFlags
    )

/*++

Routine Description:

    Handle the authenticate message part of AcceptSecurityContext.

Arguments:

    SessionKey - The session key for the context, used for signing and sealing

    NegotiateFlags - The flags negotiated for the context, used for sign & seal

    ApiSubStatus - Returns the substatus for why the logon failed.

    PasswordExpiry - Contains the time that the authenticated user's password
        expires, or 0x7fffffff ffffffff for local callers.

    UserFlags - UserFlags returned in LogonProfile.

    All other arguments same as for AcceptSecurityContext


Return Value:

    STATUS_SUCCESS - Message handled

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_LOGON_DENIED -- User is no allowed to logon to this server
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;

    PNEGOTIATE_MESSAGE NegotiateMessage = NULL;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    PNTLM_AUTHENTICATE_MESSAGE NtLmAuthenticateMessage = NULL;
    PNTLM_ACCEPT_RESPONSE NtLmAcceptResponse = NULL;
    ULONG MsvLogonMessageSize = 0;
    PMSV1_0_LM20_LOGON MsvLogonMessage = NULL;
    ULONG MsvSubAuthLogonMessageSize = 0;
    PMSV1_0_SUBAUTH_LOGON MsvSubAuthLogonMessage = NULL;
    ULONG LogonProfileMessageSize;
    PMSV1_0_LM20_LOGON_PROFILE LogonProfileMessage = NULL;
    LSA_TOKEN_INFORMATION_TYPE TokenInformationType = LsaTokenInformationNull;

    BOOLEAN DoUnicode = FALSE;
    STRING DomainName2;
    STRING UserName2;
    STRING Workstation2;
    STRING SessionKeyString = {0, 0, NULL};
    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    LARGE_INTEGER KickOffTime;

    LUID LogonId = {0};
    HANDLE LocalTokenHandle = NULL;
    BOOLEAN LocalTokenHandleOpenned = FALSE;
    TOKEN_SOURCE SourceContext;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    STRING OriginName;
    PCHAR Where;
    PSSP_CREDENTIAL Credential = NULL;
    BOOLEAN fCallFromSrv = FALSE;
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING AuthenticatingAuthority = NULL;
    PUNICODE_STRING WorkstationName = NULL;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
    BOOL fSubAuth = FALSE;
    ULONG SubAuthPackageId = 0;
    PSID AllocatedAuditSid = NULL ;
    PSID AuditSid = NULL;
    BOOLEAN fAvoidGuestAudit = FALSE;
    SECPKG_PRIMARY_CRED PrimaryCredentials;
    BOOL IsDatagramLmKeyCorrectionOn = FALSE;

    //Tracing State
    NTLM_TRACE_INFO TraceInfo = {0};
    PLSA_SEC_HANDLE TraceOldContextHandle = ContextHandle;

    ASSERT(LM_RESPONSE_LENGTH >= MSV1_0_USER_SESSION_KEY_LENGTH);

    SspPrint(( SSP_API_MORE, "Entering SsprHandleAuthenticateMessage\n"));
    //
    // Initialization
    //

    *ContextAttributes = 0;
    RtlInitUnicodeString(
        &DomainName,
        NULL
        );
    RtlInitUnicodeString(
        &UserName,
        NULL
        );
    RtlInitUnicodeString(
        &Workstation,
        NULL
        );
    *ApiSubStatus = STATUS_SUCCESS;
    PasswordExpiry->LowPart = 0xffffffff;
    PasswordExpiry->HighPart = 0x7fffffff;
    *UserFlags = 0;


    RtlZeroMemory(&PrimaryCredentials, sizeof(SECPKG_PRIMARY_CRED));

    if (*ContextHandle == NULL)
    {
        // This is possibly an old style srv call (for 4.0 and before)
        // so, alloc the context and replace the creds if new ones exists

        fCallFromSrv = TRUE;

        SspPrint((SSP_API_MORE, "SsprHandleAuthenticateMessage: *ContextHandle is NULL (old style SRV)\n"));

        SECPKG_CALL_INFO CallInfo = {0};

        //
        // Client must have TCB, otherwise an un-trusted LSA-client could use a
        // stolen challenge/response pair to network logon any user
        //

        if ( !LsaFunctions->GetCallInfo( &CallInfo ) ||
            ((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0)
            )
        {
            SecStatus = STATUS_PRIVILEGE_NOT_HELD;
            SspPrint((SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: Client does not hold Tcb\n"));
            goto Cleanup;
        }

        SecStatus = SspCredentialReferenceCredential(
                        CredentialHandle,
                        FALSE,
                        &Credential );

        if ( !NT_SUCCESS( SecStatus ) )
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: SspCredentialReferenceCredential returns %x.\n", SecStatus ));
            goto Cleanup;
        }

        // check the validity of the NtlmAuthenticateMessage

        if (SecondInputTokenSize < sizeof(NTLM_AUTHENTICATE_MESSAGE))
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: NtlmAuthenticateMessage size if bogus.\n" ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;

        }

        // This is a  superflous check since we alloc only if the caller
        // has asked us too. This is to make sure that the srv always allocs

        if (ContextReqFlags  & ISC_REQ_ALLOCATE_MEMORY)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: ContextReqFlags has ISC_REQ_ALLOCATE_MEMORY.\n" ));
            SecStatus = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        if (*OutputTokenSize < sizeof(NTLM_ACCEPT_RESPONSE))
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: NtlmAcceptResponse size if bogus.\n" ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // Allocate a new context
        //

        Context = SspContextAllocateContext();

        if (Context == NULL)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: SspContextAllocateContext returns NULL.\n" ));
            SecStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // We've just added a context, we don't nornally add and then
        // reference it.

        SspContextDereferenceContext( Context );

        *ContextHandle = (LSA_SEC_HANDLE) Context;

        // Assign the Credential

        Context->Credential = Credential;
        Credential = NULL;

        NtLmAuthenticateMessage = (PNTLM_AUTHENTICATE_MESSAGE) SecondInputToken;
        if (NtLmAuthenticateMessage == NULL)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: Error while assigning NtLmAuthenticateMessage\n" ));
            SecStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // copy challenge from NTLM_AUTHENTICATE_MESSAGE
        RtlCopyMemory(Context->Challenge,
                      NtLmAuthenticateMessage->ChallengeToClient,
                      MSV1_0_CHALLENGE_LENGTH);

        if (NtLmAuthenticateMessage->ParameterControl & MSV1_0_SUBAUTHENTICATION_FLAGS)
        {
            fSubAuth = TRUE;
            SubAuthPackageId = (NtLmAuthenticateMessage->ParameterControl >>
                                MSV1_0_SUBAUTHENTICATION_DLL_SHIFT)
                                ;
        }
        Context->State = ChallengeSentState;
        Context->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE ;

        //
        // The server may request this option with a <= 4.0 client, in
        // which case HandleNegotiateMessage, which normally sets
        // this flag, won't have been called.
        //

        if ( (ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) != 0) {

            *ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
            Context->ContextFlags |= ASC_RET_ALLOW_NON_USER_LOGONS;
        }
    }

    //
    // Find the currently existing context.
    //

    SecStatus = SspContextReferenceContext( *ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(SecStatus) )
    {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: Error from SspContextReferenceContext.\n" ));

        goto Cleanup;
    }


    if ( ( Context->State != ChallengeSentState) &&
         ( Context->State != AuthenticatedState) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "Context not in ChallengeSentState\n" ));
        SecStatus = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    //
    // Ignore the Credential Handle.
    //
    // Since this is the second call,
    // the credential is implied by the Context.
    // We could double check that the Credential Handle is either NULL or
    // correct.  However, our implementation doesn't maintain a close
    // association between the two (actually no association) so checking
    // would require a lot of overhead.
    //

    UNREFERENCED_PARAMETER( CredentialHandle );

    //
    // Get the AuthenticateMessage.
    //

    if ( InputTokenSize < sizeof(OLD_AUTHENTICATE_MESSAGE) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "AuthenticateMessage size wrong %ld\n",
                  InputTokenSize ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    SecStatus = SspContextGetMessage( InputToken,
                                      InputTokenSize,
                                      NtLmAuthenticate,
                                      (PVOID *)&AuthenticateMessage );

    if ( !NT_SUCCESS(SecStatus) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "AuthenticateMessage GetMessage returns 0x%lx\n",
                  SecStatus ));
        goto Cleanup;
    }

    if (fCallFromSrv)
    {
        // Copy the Context Negotiate Flags from what's sent in
        Context->NegotiateFlags |= AuthenticateMessage->NegotiateFlags;
    }
    //
    // If the call comes and we have already authenticated, then it is
    // probably RPC trying to reauthenticate, which happens when someone
    // calls two interfaces on the same connection.  In this case we don't
    // have to do anything - we just return success and let them get on
    // with it.  We do want to check that the input token is all zeros,
    // though.
    //

    if ( Context->State == AuthenticatedState ) {
        AUTHENTICATE_MESSAGE NullMessage;

        *OutputTokenSize = 0;

        //
        // Check that all the fields are null.  There are 5 strings
        // in the Authenticate message that have to be set to zero.
        //

        RtlZeroMemory(&NullMessage.LmChallengeResponse, 5 * sizeof(STRING32));

        if (memcmp(&AuthenticateMessage->LmChallengeResponse,
                   &NullMessage.LmChallengeResponse,
                   sizeof(STRING32) * 5) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "AuthenticateMessage->LmChallengeResponse is not zeroed\n"));
        }
        else
        {
            *ContextAttributes = SSP_RET_REAUTHENTICATION;
            SecStatus = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // If we are re-establishing a datagram context, get the negotiate flags
    // out of this message.
    //

    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) {

        if ((InputTokenSize < RTL_SIZEOF_THROUGH_FIELD(AUTHENTICATE_MESSAGE, NegotiateFlags)) ||
            ((AuthenticateMessage->NegotiateFlags &
              NTLMSSP_NEGOTIATE_DATAGRAM) == 0) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        Context->NegotiateFlags = AuthenticateMessage->NegotiateFlags;

        //
        // always do key exchange with datagram if we need a key (for SIGN or SEAL)
        //

        if (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL))
        {
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;
        }

        //
        // if got NTLM2, don't use LM_KEY 
        //

        if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) != 0 )
        {
            if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
                SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleAuthenticateMessage: "
                      "AuthenticateMessage (datagram) NTLM2 caused LM_KEY to be disabled.\n" ));
            }

            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;
        }

        if (AuthenticateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
        {
            if (InputTokenSize >= RTL_SIZEOF_THROUGH_FIELD(AUTHENTICATE_MESSAGE, Version))
            {
                C_ASSERT(sizeof(NTLM_VER_INFO) == sizeof(ULONG64));

                RtlCopyMemory(&Context->ClientVersion, &AuthenticateMessage->Version, sizeof(AuthenticateMessage->Version));

                SspPrint(( SSP_VERSION,
                    "SsprHandleAuthenticateMessage: ClientVersion %#I64x, Major %I64d, Minor %I64d, Build %I64d, Revision %I64d\n",
                    AuthenticateMessage->Version,
                    Context->ClientVersion.Major,
                    Context->ClientVersion.Minor,
                    Context->ClientVersion.Build,
                    Context->ClientVersion.Revision ));

            }
            else
            {
                SecStatus = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleAuthenticateMessage: AuthenticateMessage size too small with NTLMSSP_NEGOTIATE_VERSION\n" ));
                goto Cleanup;
            }
        }

        if ( (Context->ClientVersion.Revision >= NTLMSSP_REVISION_W2K3) 
             && ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_LM_KEY | NTLMSSP_NEGOTIATE_NTLM2)) == 0) )
        {
            // smartclient knows to turn off LM KEY

            SspPrint(( SSP_WARNING, "SsprHandleAuthenticateMessage client turned off LM keys\n" ));
            IsDatagramLmKeyCorrectionOn = TRUE;
        }
    }

    //
    // Check that client asked for minimum security required.
    // not done for legacy down-level case, as, NegotiateFlags are
    // constructed from incomplete information.
    //

    if ( !fCallFromSrv )
    {
        if (!SsprCheckMinimumSecurity(
                    AuthenticateMessage->NegotiateFlags,
                    NtLmGlobalMinimumServerSecurity)) {

            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "client didn't support minimum security requirements.\n" ));
            goto Cleanup;
        }
    }

    //
    // Convert relative pointers to absolute.
    //

    DoUnicode = ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) != 0;

    if (!SspConvertRelativeToAbsolute(AuthenticateMessage,
                                      InputTokenSize,
                                      &AuthenticateMessage->LmChallengeResponse,
                                      (PSTRING) &LmChallengeResponse,
                                      FALSE,     // No special alignment
                                      TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (!SspConvertRelativeToAbsolute(AuthenticateMessage,
                                      InputTokenSize,
                                      &AuthenticateMessage->NtChallengeResponse,
                                      (PSTRING) &NtChallengeResponse,
                                      FALSE,     // No special alignment
                                      TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (!SspConvertRelativeToAbsolute(AuthenticateMessage,
                                      InputTokenSize,
                                      &AuthenticateMessage->DomainName,
                                      &DomainName2,
                                      DoUnicode, // Unicode alignment
                                      TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( !SspConvertRelativeToAbsolute( AuthenticateMessage,
                                        InputTokenSize,
                                        &AuthenticateMessage->UserName,
                                        &UserName2,
                                        DoUnicode, // Unicode alignment
#ifdef notdef

        //
        // Allow null sessions.  The server should guard against them if
        // it doesn't want them.
        //
                                        FALSE )) { // User name cannot be NULL

#endif // notdef
                                        TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( !SspConvertRelativeToAbsolute( AuthenticateMessage,
                                        InputTokenSize,
                                        &AuthenticateMessage->Workstation,
                                        &Workstation2,
                                        DoUnicode, // Unicode alignment
                                        TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // If this is datagram, get the session key
    //

///    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) {
    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) != 0) {

        if ( !SspConvertRelativeToAbsolute( AuthenticateMessage,
                                            InputTokenSize,
                                            &AuthenticateMessage->SessionKey,
                                            &SessionKeyString,
                                            FALSE, // No special alignment
                                            TRUE) ) { // NULL OK
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // It should be NULL if this is a local call
        //

        if (((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) == 0) &&
            (SessionKeyString.Buffer == NULL)) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL)
        {
            static const UCHAR FixedSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH] = {
                                        'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                        'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                        };

            RtlCopyMemory(Context->SessionKey, FixedSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        }

    }

    //
    // Convert the domainname/user name/workstation to the right character set.
    //

    if ( DoUnicode ) {

        DomainName = *((PUNICODE_STRING) &DomainName2);
        UserName = *((PUNICODE_STRING) &UserName2);
        Workstation = *((PUNICODE_STRING) &Workstation2);

    } else {

        SspPrint(( SSP_API_MORE, "SsprHandleAuthenticateMessage: Not doing Unicode\n"));
        Status = RtlOemStringToUnicodeString(
                    &DomainName,
                    &DomainName2,
                    TRUE);

        if ( !NT_SUCCESS(Status) ) {
            SecStatus = SspNtStatusToSecStatus( Status,
                                                SEC_E_INSUFFICIENT_MEMORY );
            goto Cleanup;
        }

        Status = RtlOemStringToUnicodeString(
                    &UserName,
                    &UserName2,
                    TRUE);

        if ( !NT_SUCCESS(Status) ) {
            SecStatus = SspNtStatusToSecStatus( Status,
                                                SEC_E_INSUFFICIENT_MEMORY );
            goto Cleanup;
        }

        Status = RtlOemStringToUnicodeString(
                    &Workstation,
                    &Workstation2,
                    TRUE);

        if ( !NT_SUCCESS(Status) ) {
            SecStatus = SspNtStatusToSecStatus( Status,
                                                SEC_E_INSUFFICIENT_MEMORY );
            goto Cleanup;
        }

    }

    //
    // Trace the username, domain name and workstation
    //
    if (NtlmGlobalEventTraceFlag){

        //Header goo
        SET_TRACE_HEADER(TraceInfo,
                         NtlmAcceptGuid,
                         EVENT_TRACE_TYPE_INFO,
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                         10);

        int TraceHint = TRACE_ACCEPT_INFO;
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        TraceOldContextHandle);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_OUTCONTEXT,
                        ContextHandle);

        // lets see the negotiate flags here
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STATUS,
                        Context->NegotiateFlags);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_INITACC_CLIENTNAME,
                          UserName);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_INITACC_CLIENTDOMAIN,
                          DomainName);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_INITACC_WORKSTATION,
                          Workstation);

        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }


    //
    // If the client is on the same machine as we are, just
    // use the token the client has already placed in our context structure,
    //

    if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL ) &&
         Context->TokenHandle != NULL &&
         DomainName.Length == 0 &&
         UserName.Length == 0 &&
         Workstation.Length == 0 &&
         AuthenticateMessage->NtChallengeResponse.Length == 0 &&
         AuthenticateMessage->LmChallengeResponse.Length == 0 )
    {


        static const UCHAR FixedSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH] = {
                                    'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                    'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                    };

        LocalTokenHandle = Context->TokenHandle;
        Context->TokenHandle = NULL;

        KickOffTime.HighPart = 0x7FFFFFFF;
        KickOffTime.LowPart = 0xFFFFFFFF;

        RtlCopyMemory(Context->SessionKey, FixedSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        SspPrint(( SSP_MISC, "SsprHandleAuthenticateMessage: Local Call\n"));

        if ( (ContextReqFlags & ASC_REQ_DELEGATE) )
        {
            //
            // can support another hop if loopback.
            //

            *ContextAttributes |= ASC_RET_DELEGATE;
            Context->ContextFlags |= ASC_RET_DELEGATE;
        }

    //
    // If the client is on a different machine than we are,
    //  use LsaLogonUser to create a token for the client.
    //

    } else {

        //
        //  Store user name and domain name
        //

        SecStatus = NtLmDuplicateUnicodeString(
                          &Context->UserName,
                          &UserName);
        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }

        SecStatus = NtLmDuplicateUnicodeString(
                          &Context->DomainName,
                          &DomainName);
        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }


        //
        // Allocate an MSV1_0 network logon message
        //

        if (!fSubAuth)
        {
            //
            // The string buffers may be used as structure pointers later on.
            // Align them to pointer boundaries to avoid alignment problems.
            //

            MsvLogonMessageSize =
                ROUND_UP_COUNT(sizeof(*MsvLogonMessage) +
                               DomainName.Length +
                               UserName.Length +
                               Workstation.Length, ALIGN_LPVOID) +
                ROUND_UP_COUNT(AuthenticateMessage->NtChallengeResponse.Length, ALIGN_LPVOID) +
                AuthenticateMessage->LmChallengeResponse.Length;

            MsvLogonMessage = (PMSV1_0_LM20_LOGON)
                          NtLmAllocatePrivateHeap(MsvLogonMessageSize );

            if ( MsvLogonMessage == NULL ) {
                SecStatus = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: Error allocating MsvLogonMessage"));
                goto Cleanup;
            }

            //
            // Build the MSV1_0 network logon message to pass to the LSA.
            //

            MsvLogonMessage->MessageType = MsV1_0NetworkLogon;

            Where = (PCHAR)(MsvLogonMessage+1);

            SspContextCopyStringAbsolute( MsvLogonMessage,
                              (PSTRING)&MsvLogonMessage->LogonDomainName,
                              (PSTRING)&DomainName,
                              &Where );

            SspContextCopyStringAbsolute( MsvLogonMessage,
                              (PSTRING)&MsvLogonMessage->UserName,
                              (PSTRING)&UserName,
                              &Where );

            SspContextCopyStringAbsolute( MsvLogonMessage,
                              (PSTRING)&MsvLogonMessage->Workstation,
                              (PSTRING)&Workstation,
                              &Where );

            RtlCopyMemory( MsvLogonMessage->ChallengeToClient,
                       Context->Challenge,
                       sizeof( MsvLogonMessage->ChallengeToClient ) );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute( MsvLogonMessage,
                              &MsvLogonMessage->CaseSensitiveChallengeResponse,
                              &NtChallengeResponse,
                              &Where );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute(MsvLogonMessage,
                             &MsvLogonMessage->CaseInsensitiveChallengeResponse,
                             &LmChallengeResponse,
                             &Where );

            MsvLogonMessage->ParameterControl = MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT;

            // This is required by the pre 4.0 server
            if (fCallFromSrv)
            {
                MsvLogonMessage->ParameterControl = MSV1_0_CLEARTEXT_PASSWORD_ALLOWED | NtLmAuthenticateMessage->ParameterControl;

                if ( (Context->ContextFlags & ASC_RET_ALLOW_NON_USER_LOGONS ) != 0)
                {
                    MsvLogonMessage->ParameterControl |= MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;
                }
            } else {
                MsvLogonMessage->ParameterControl |= MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;
            }

            //
            // Get the profile path for EFS
            //

            MsvLogonMessage->ParameterControl |= MSV1_0_RETURN_PROFILE_PATH;

            //
            // By passing in the RETURN_PASSWORD_EXPIRY flag, the password
            // expiration time is returned in the logoff time
            //

            MsvLogonMessage->ParameterControl |= MSV1_0_RETURN_PASSWORD_EXPIRY;

            //
            // for Personal easy file/print sharing, hint to LsaLogonUser
            // that Forced Guest may occur.
            //

            MsvLogonMessage->ParameterControl |= MSV1_0_ALLOW_FORCE_GUEST;
        }
        else
        {
            MsvSubAuthLogonMessageSize =
                ROUND_UP_COUNT(sizeof(*MsvSubAuthLogonMessage) +
                               DomainName.Length +
                               UserName.Length +
                               Workstation.Length, ALIGN_LPVOID) +
                ROUND_UP_COUNT(AuthenticateMessage->NtChallengeResponse.Length, ALIGN_LPVOID) +
                AuthenticateMessage->LmChallengeResponse.Length;

            MsvSubAuthLogonMessage = (PMSV1_0_SUBAUTH_LOGON)
                          NtLmAllocatePrivateHeap(MsvSubAuthLogonMessageSize );

            if ( MsvSubAuthLogonMessage == NULL ) {
                SecStatus = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: Error allocating MsvSubAuthLogonMessage"));
                goto Cleanup;
            }

            //
            // Build the MSV1_0 subauth logon message to pass to the LSA.
            //

            MsvSubAuthLogonMessage->MessageType = MsV1_0SubAuthLogon;

            Where = (PCHAR)(MsvSubAuthLogonMessage + 1);

            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              (PSTRING)&MsvSubAuthLogonMessage->LogonDomainName,
                              (PSTRING)&DomainName,
                              &Where );

            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              (PSTRING)&MsvSubAuthLogonMessage->UserName,
                              (PSTRING)&UserName,
                              &Where );

            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              (PSTRING)&MsvSubAuthLogonMessage->Workstation,
                              (PSTRING)&Workstation,
                              &Where );

            RtlCopyMemory( MsvSubAuthLogonMessage->ChallengeToClient,
                       Context->Challenge,
                       sizeof( MsvSubAuthLogonMessage->ChallengeToClient ) );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              &MsvSubAuthLogonMessage->AuthenticationInfo1,
                              &LmChallengeResponse,
                              &Where );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute(MsvSubAuthLogonMessage,
                             &MsvSubAuthLogonMessage->AuthenticationInfo2,
                             &NtChallengeResponse,
                             &Where );

            MsvSubAuthLogonMessage->ParameterControl = MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT;

            MsvSubAuthLogonMessage->SubAuthPackageId = SubAuthPackageId;

            // This is required by the pre 4.0 server
            if (fCallFromSrv)
            {
                MsvSubAuthLogonMessage->ParameterControl = MSV1_0_CLEARTEXT_PASSWORD_ALLOWED | NtLmAuthenticateMessage->ParameterControl;
            }

            if ( (Context->ContextFlags & ASC_RET_ALLOW_NON_USER_LOGONS ) != 0) {
                MsvSubAuthLogonMessage->ParameterControl |= MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;
            }

            //
            // By passing in the RETURN_PASSWORD_EXPIRY flag, the password
            // expiration time is returned in the logoff time
            //

            MsvSubAuthLogonMessage->ParameterControl |= MSV1_0_RETURN_PASSWORD_EXPIRY;

            //
            // for Personal easy file/print sharing, hint to LsaLogonUser
            // that Forced Guest may occur.
            //

            MsvSubAuthLogonMessage->ParameterControl |= MSV1_0_ALLOW_FORCE_GUEST;
        }

        //
        // if NTLM2 is negotiated, then mix my challenge with the client's...
        // But, special case for null sessions. since we already negotiated
        // NTLM2, but the LmChallengeResponse field is actually used
        // here. REVIEW -- maybe don't negotiate NTLM2 if NULL session
        //

        if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)  &&
           (AuthenticateMessage->LmChallengeResponse.Length >= MSV1_0_CHALLENGE_LENGTH))
        {
            MsvLogonMessage->ParameterControl |= MSV1_0_USE_CLIENT_CHALLENGE;
        }

        //
        // Log this user on.
        //

        // No origin (could use F(workstaion))

        RtlInitString( &OriginName, NULL );

        strncpy( SourceContext.SourceName,
                 "NtLmSsp ",
                 sizeof(SourceContext.SourceName) );

        RtlZeroMemory( &SourceContext.SourceIdentifier,
                       sizeof(SourceContext.SourceIdentifier) );

        {
            PVOID TokenInformation;
            PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials = NULL;

            if (!fSubAuth)
            {
                Status = LsaApLogonUserEx2(
                            (PLSA_CLIENT_REQUEST) (-1),
                            Network,
                            MsvLogonMessage,
                            MsvLogonMessage,
                            MsvLogonMessageSize,
                            (PVOID *) &LogonProfileMessage,
                            &LogonProfileMessageSize,
                            &LogonId,
                            &SubStatus,
                            &TokenInformationType,
                            &TokenInformation,
                            &AccountName,
                            &AuthenticatingAuthority,
                            &WorkstationName,
                            &PrimaryCredentials,
                            &Credentials
                            );
            }
            else
            {
                Status = LsaApLogonUserEx2(
                            (PLSA_CLIENT_REQUEST) (-1),
                            Network,
                            MsvSubAuthLogonMessage,
                            MsvSubAuthLogonMessage,
                            MsvSubAuthLogonMessageSize,
                            (PVOID *) &LogonProfileMessage,
                            &LogonProfileMessageSize,
                            &LogonId,
                            &SubStatus,
                            &TokenInformationType,
                            &TokenInformation,
                            &AccountName,
                            &AuthenticatingAuthority,
                            &WorkstationName,
                            &PrimaryCredentials,
                            &Credentials
                            );
            }

            if ( !NT_SUCCESS(Status) ) {
                SspPrint(( SSP_CRITICAL,
                          "SsprHandleAuthenticateMessage: "
                          "LsaApLogonUserEx2 returns 0x%lx for context 0x%x\n",
                          Status, Context ));
                SecStatus = SspNtStatusToSecStatus( Status, SEC_E_LOGON_DENIED );
                if (Status == STATUS_PASSWORD_MUST_CHANGE) {
                    *ApiSubStatus = Status;
                }
                else if (Status == STATUS_ACCOUNT_RESTRICTION) {
                    *ApiSubStatus = SubStatus;
                } else {
                    *ApiSubStatus = Status;
                }

                goto Cleanup;
            }

            if ( !NT_SUCCESS(SubStatus) ) {
                SspPrint(( SSP_CRITICAL,
                          "SsprHandleAuthenticateMessage: "
                          "LsaApLogonUserEx2 returns SubStatus of 0x%lx\n",
                          SubStatus ));
                SecStatus = SspNtStatusToSecStatus( SubStatus, SEC_E_LOGON_DENIED );
                goto Cleanup;
            }

            //
            // Set package-specific flags in the logon session
            //

            if (fCallFromSrv)
            {
                I_LsaISetPackageAttrInLogonSession(&LogonId, LOGONSES_FLAG_NTLM_DOWNLEVEL);
            }

            //
            // Check if this was a null session. The TokenInformationType will
            // be LsaTokenInformationNull if it is. If so, we may need to fail
            // the logon.
            //

            if (TokenInformationType == LsaTokenInformationNull)
            {

//
// RESTRICT_NULL_SESSIONS deemed too risky because legacy behavior of package
// allows null sessions from SYSTEM.
//

#ifdef RESTRICT_NULL_SESSIONS
                if ((Context->ContextFlags & ASC_REQ_ALLOW_NULL_SESSION) == 0) {
                    SspPrint(( SSP_CRITICAL,
                               "SsprHandleAuthenticateMessage: "
                               "Null session logon attempted but not allowed\n" ));
                    SecStatus = SEC_E_LOGON_DENIED;
                    goto Cleanup;
                }
#endif
                *ContextAttributes |= ASC_RET_NULL_SESSION;
                Context->ContextFlags |= ASC_RET_NULL_SESSION;
                Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_NULL_SESSION;

                AuditSid = NtLmGlobalAnonymousSid;
            }
            else
            {
                PLSA_TOKEN_INFORMATION_V2 TokenInfoV2 ;

                TokenInfoV2 = (PLSA_TOKEN_INFORMATION_V2) TokenInformation ;

                SafeAllocaAllocate( AllocatedAuditSid, RtlLengthSid( TokenInfoV2->User.User.Sid ) );

                if ( AllocatedAuditSid )
                {

                    RtlCopyMemory( AllocatedAuditSid,
                                   TokenInfoV2->User.User.Sid,
                                   RtlLengthSid( TokenInfoV2->User.User.Sid ) );

                }

                AuditSid = AllocatedAuditSid;
            }


            Status = LsaFunctions->CreateTokenEx(
                        &LogonId,
                        &SourceContext,
                        Network,
                        (((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) != 0) ?
                            SecurityIdentification : SecurityImpersonation),
                        TokenInformationType,
                        TokenInformation,
                        NULL,
                        WorkstationName,
                        ((LogonProfileMessage->UserFlags & LOGON_PROFILE_PATH_RETURNED) != 0) ? &LogonProfileMessage->UserParameters : NULL,
                        &PrimaryCredentials,
                        SecSessionPrimaryCred,
                        &LocalTokenHandle,
                        &SubStatus);

            if ( !NT_SUCCESS(Status) && (LocalTokenHandle == NULL) ) {
                LsaFunctions->DeleteLogonSession(&LogonId);
            }

            if (Status == STATUS_ACCOUNT_RESTRICTION) {
                *ApiSubStatus = SubStatus;
            } else {
                *ApiSubStatus = Status;
            }   
        }  // end of block for LsaLogonUser

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "CreateToken returns 0x%lx\n",
                      Status ));
            
            SecStatus = Status;
            goto Cleanup;
        }

        if ( !NT_SUCCESS(SubStatus) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "CreateToken returns SubStatus of 0x%lx\n",
                      SubStatus ));
            SecStatus = SubStatus;
            goto Cleanup;
        }

        LocalTokenHandleOpenned = TRUE;

        //
        // Don't allow cleartext password on the logon.
        // Except if called from Downlevel

        if (!fCallFromSrv)
        {
            if ( LogonProfileMessage->UserFlags & LOGON_NOENCRYPTION ) {
                SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "LsaLogonUser used cleartext password\n" ));
                SecStatus = SEC_E_LOGON_DENIED;
                goto Cleanup;

            }
        }

        //
        // If we did a guest logon, set the substatus to be STATUS_NO_SUCH_USER
        //

        if ( LogonProfileMessage->UserFlags & LOGON_GUEST ) {
            fAvoidGuestAudit = TRUE;
            *ApiSubStatus = STATUS_NO_SUCH_USER;

#if 0
            //
            // If caller required Sign/Seal, fail them here
            //
            if (
                (!NtLmGlobalForceGuest) &&
                (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
                )
            {
                SspPrint(( SSP_CRITICAL,
                     "SsprHandleAuthenticateMessage: "
                      "LsaLogonUser logged user as a guest but seal is requested\n" ));
                SecStatus = SEC_E_LOGON_DENIED;
                goto Cleanup;
            }
#endif


        }

        //
        // Save important information about the caller.
        //

        KickOffTime = LogonProfileMessage->KickOffTime;

        //
        // By passing in the RETURN_PASSWORD_EXPIRY flag, the password
        // expiration time is returned in the logoff time
        //

        *PasswordExpiry = LogonProfileMessage->LogoffTime;
        *UserFlags = LogonProfileMessage->UserFlags;

        //
        // set the session key to what the client sent us (if anything)
        //

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH &&
            AuthenticateMessage->SessionKey.Length == MSV1_0_USER_SESSION_KEY_LENGTH)
        {
            RtlCopyMemory(
                Context->SessionKey,
                SessionKeyString.Buffer,
                MSV1_0_USER_SESSION_KEY_LENGTH
                );
        }

        //
        // Generate the session key, or decrypt the generated random one sent to
        // us by the client, from various bits of info
        //

        SecStatus = SsprMakeSessionKey(
                        Context,
                        &LmChallengeResponse,
                        LogonProfileMessage->UserSessionKey,
                        LogonProfileMessage->LanmanSessionKey,
                        NULL
                        );

        if ( !NT_SUCCESS(SecStatus) ) {
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "SsprMakeSessionKey failed.\n" ));
            goto Cleanup;
        }

    }

    //
    // Copy the logon domain name returned by the LSA if it is different.
    // from the one the caller passed in. This may happen with temp duplicate
    // accounts and local account
    //

    if ((LogonProfileMessage != NULL) &&
        (LogonProfileMessage->LogonDomainName.Length != 0) &&
        !RtlEqualUnicodeString(
            &Context->DomainName,
            &LogonProfileMessage->LogonDomainName,
            TRUE               // case insensitive
            )) {
        //
        // erase the old domain name
        //

        if (Context->DomainName.Buffer != NULL) {
            NtLmFreePrivateHeap(Context->DomainName.Buffer);
            Context->DomainName.Buffer = NULL;
            Context->DomainName.Length = Context->DomainName.MaximumLength = 0;
        }

        SecStatus = NtLmDuplicateUnicodeString(
                        &Context->DomainName,
                        &LogonProfileMessage->LogonDomainName
                        );

        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }
    }

    //
    // use SAM account username in case of UPN logon
    //

    if ((TokenInformationType != LsaTokenInformationNull)
        && (0 != PrimaryCredentials.DownlevelName.Length) // older DCs do not send DownlevelName for network logon
        && !RtlEqualUnicodeString(
                &Context->UserName,
                &PrimaryCredentials.DownlevelName,
                TRUE  // case insensitive
                )) {
        //
        // erase the old user name
        //

        if (Context->UserName.Buffer != NULL) {
            NtLmFreePrivateHeap(Context->UserName.Buffer);
            Context->UserName.Buffer = NULL;
            Context->UserName.Length = Context->UserName.MaximumLength = 0;
        }

        SecStatus = NtLmDuplicateUnicodeString(
                        &Context->UserName,
                        &PrimaryCredentials.DownlevelName
                        );

        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }
    }

    //
    // Allow the context to live until kickoff time.
    //

    SspContextSetTimeStamp( Context, KickOffTime );

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    //
    // Return output token
    //

    if (fCallFromSrv)
    {
        NtLmAcceptResponse = (PNTLM_ACCEPT_RESPONSE) *OutputToken;
        if (NtLmAcceptResponse == NULL)
        {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }

        LUID UNALIGNED * TempLogonId = (LUID UNALIGNED *) &NtLmAcceptResponse->LogonId;
        *TempLogonId = LogonId;
        NtLmAcceptResponse->UserFlags = LogonProfileMessage->UserFlags;

        RtlCopyMemory(
            NtLmAcceptResponse->UserSessionKey,
            LogonProfileMessage->UserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        RtlCopyMemory(
            NtLmAcceptResponse->LanmanSessionKey,
            LogonProfileMessage->LanmanSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );

        LARGE_INTEGER UNALIGNED *TempKickoffTime = (LARGE_INTEGER UNALIGNED *) &NtLmAcceptResponse->KickoffTime;
        *TempKickoffTime = LogonProfileMessage->KickOffTime;

    }
    else
    {
        *OutputTokenSize = 0;
    }


    //
    // We don't support sign/seal options if fallback to Guest
    // this is because the client and server won't have a matched session-key
    // AND even if they did match (ie: blank password), the session-key
    // would likely be well-known.
    //


    SecStatus = STATUS_SUCCESS;

    //
    // Free and locally used resources.
    //

Cleanup:

    //
    // Audit this logon
    //

    if (NT_SUCCESS(SecStatus)) {

        //
        // If we don't have an account name, this was a local connection
        // and we didn't build a new token, so don't bother auditing.
        // also, don't bother auditing logons that fellback to guest.
        //

        if ( (AccountName != NULL) &&
             ((AccountName->Length != 0) || (*ContextAttributes & ASC_RET_NULL_SESSION)) &&
              !fAvoidGuestAudit ) {

            LsaFunctions->AuditLogon(
                STATUS_SUCCESS,
                STATUS_SUCCESS,
                AccountName,
                AuthenticatingAuthority,
                WorkstationName,
                AuditSid,
                Network,
                &SourceContext,
                &LogonId
                );
        }
    } else {
        LsaFunctions->AuditLogon(
            !NT_SUCCESS(Status) ? Status : SecStatus,
            SubStatus,
            &UserName,
            &DomainName,
            &Workstation,
            NULL,
            Network,
            &SourceContext,
            &LogonId
            );

    }

    if ( Context != NULL ) {

        //
        // client does not negotiate version, do not send the newer status code
        //

        if ( (STATUS_AUTHENTICATION_FIREWALL_FAILED == SecStatus)
             && (Context->ClientVersion.Revision < NTLMSSP_REVISION_W2K3_RC1) ) {

            SspPrint(( SSP_WARNING,
                  "SsprHandleAuthenticateMessage: remapping STATUS_AUTHENTICATION_FIREWALL_FAILED to STATUS_NO_SUCH_USER\n",
                  SubStatus ));

            SecStatus = STATUS_NO_SUCH_USER;
        }

        Context->Server = TRUE;
        Context->LastStatus = SecStatus;
        Context->DownLevel = fCallFromSrv;


        //
        // Don't allow this context to be used again.
        //

        if ( NT_SUCCESS(SecStatus) ) {

            Context->State = AuthenticatedState;

            if ( LocalTokenHandle ) {
                *TokenHandle = LocalTokenHandle;
            }

            LocalTokenHandle = NULL;

            RtlCopyMemory(
                SessionKey,
                Context->SessionKey,
                MSV1_0_USER_SESSION_KEY_LENGTH );

            *NegotiateFlags = Context->NegotiateFlags;

            //
            // tricky here:
            //
            // datagram client side context is mapped during the first call, so
            // remove LM key correction so that the mapped context on the 
            // server side would have matching flags
            //

            if (IsDatagramLmKeyCorrectionOn) {

                SspPrint(( SSP_WARNING, "SsprHandleAuthenticateMessage turning on LM keys\n" ));

                *NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;
            }

            if ( !fAvoidGuestAudit ) {

                if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL ) {
                    *ContextAttributes |= ASC_RET_CONFIDENTIALITY;
                }
            
                if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN ) {
                    *ContextAttributes |= ASC_RET_REPLAY_DETECT |
                                          ASC_RET_SEQUENCE_DETECT |
                                          ASC_RET_INTEGRITY;
                }
            
                if ( ContextReqFlags & ASC_REQ_REPLAY_DETECT ) {
                    *ContextAttributes |= ASC_RET_REPLAY_DETECT;
                }
            
                if ( ContextReqFlags & ASC_REQ_SEQUENCE_DETECT ) {
                    *ContextAttributes |= ASC_RET_SEQUENCE_DETECT;
                }
            }           
            
            if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY ) {
                *ContextAttributes |= ASC_RET_IDENTIFY;
            }
            
            if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM ) {
                *ContextAttributes |= ASC_RET_DATAGRAM;
            }
            
            if ( ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) {
                *ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
            }    

            //
            // if caller wants only INTEGRITY, then wants application
            // supplied sequence numbers...
            //

            if ((Context->ContextFlags &
                (ASC_REQ_INTEGRITY | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT)) ==
                ASC_REQ_INTEGRITY)
            {
                *NegotiateFlags |= NTLMSSP_APP_SEQ;
            }

        } else {
            Context->State = IdleState;
        }

        // If we just created this context, then we need to dereference it
        // once more with feeling

        if (fCallFromSrv && !NT_SUCCESS(SecStatus))
        {
            PSSP_CONTEXT LocalContext;
            SspContextReferenceContext (*ContextHandle, TRUE, &LocalContext);
            ASSERT (LocalContext != NULL);
            if (LocalContext != NULL)
            {
                SspContextDereferenceContext( LocalContext );
            }

        }
        SspContextDereferenceContext( Context );

    }

    if ( NegotiateMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( NegotiateMessage );
    }

    if ( AuthenticateMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( AuthenticateMessage );
    }

    if ( MsvLogonMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( MsvLogonMessage );
    }

    if ( MsvSubAuthLogonMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( MsvSubAuthLogonMessage );
    }


    if ( LogonProfileMessage != NULL ) {
        (VOID) LsaFunctions->FreeLsaHeap( LogonProfileMessage );
    }

    if ( LocalTokenHandle != NULL && LocalTokenHandleOpenned ) {
        (VOID) NtClose( LocalTokenHandle );
    }

    if ( !DoUnicode ) {
        if ( DomainName.Buffer != NULL) {
            RtlFreeUnicodeString( &DomainName );
        }
        if ( UserName.Buffer != NULL) {
            RtlFreeUnicodeString( &UserName );
        }
        if ( Workstation.Buffer != NULL) {
            RtlFreeUnicodeString( &Workstation );
        }
    }

    if (AccountName != NULL) {
        if (AccountName->Buffer != NULL) {
            LsaFunctions->FreeLsaHeap(AccountName->Buffer);
        }
        LsaFunctions->FreeLsaHeap(AccountName);
    }
    if (AuthenticatingAuthority != NULL) {
        if (AuthenticatingAuthority->Buffer != NULL) {
            LsaFunctions->FreeLsaHeap(AuthenticatingAuthority->Buffer);
        }
        LsaFunctions->FreeLsaHeap(AuthenticatingAuthority);
    }
    if (WorkstationName != NULL) {
        if (WorkstationName->Buffer != NULL) {
            LsaFunctions->FreeLsaHeap(WorkstationName->Buffer);
        }
        LsaFunctions->FreeLsaHeap(WorkstationName);
    }

    if ( AllocatedAuditSid )
    {
        SafeAllocaFree( AllocatedAuditSid );
    }

    //
    // need to free the PrimaryCredentials fields filled in by LsaApLogonUserEx2
    //

    if ( PrimaryCredentials.DownlevelName.Buffer )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DownlevelName.Buffer);
    }

    if ( PrimaryCredentials.DomainName.Buffer )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DomainName.Buffer);
    }

    if ( PrimaryCredentials.UserSid )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.UserSid);
    }

    if ( PrimaryCredentials.LogonServer.Buffer )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
    }

    //
    // Set a flag telling RPC not to destroy the connection yet
    //

    if (!NT_SUCCESS(SecStatus)) {
        *ContextAttributes |= ASC_RET_THIRD_LEG_FAILED;
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleAutheticateMessage: 0x%lx\n", SecStatus ));
    return SecStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\debug.cxx ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.cxx

Abstract:

    Support routines allowing the NtLmSsp DLL side use the common routines
    shared between the DLL and the SERVICE.

    These routines exist in the DLL side.  They are different implementations
    of the same routines that exist on the SERVICE side.  These implementations
    are significantly simpler because they run in the address space of the
    caller.

Author:

    Cliff Van Dyke (CliffV) 22-Sep-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\client\support.c

--*/

//
// Common include files.
//

#include <global.h>


#if DBG
#include <stdio.h>
#define MAX_PRINTF_LEN 1024        // Arbitrary.


VOID
SspPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    int cbUsed = 0;
    static BeginningOfLine = TRUE;
    static LineCount = 0;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (SspGlobalDbflag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &SspGlobalLogFileCritSect );
    length = 0;

    //
    // make sure it is null terminated
    //

    OutputBuffer[sizeof(OutputBuffer) - 1] = '\0';

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine )
    {
        //
        // If we're writing to the debug terminal,
        //  indicate this is an NtLmSsp message.
        //

        cbUsed = _snprintf(&OutputBuffer[length], sizeof(OutputBuffer) - 1 - length, "[MSV1_0.dll] ");

        if (cbUsed <= 0)
        {
            goto Done;
        }

        length += cbUsed;

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP )
        {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            cbUsed = _snprintf( &OutputBuffer[length], sizeof(OutputBuffer) - 1 - length,
                "%02u/%02u %02u:%02u:%02u ",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );
            if (cbUsed <= 0)
            {
                goto Done;
            }

            length += cbUsed;
        }

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag)
            {
            case SSP_INIT:
                Text = "INIT"; break;
            case SSP_MISC:
                Text = "MISC"; break;
            case SSP_LOGON_SESS:
                Text = "LOGON_SESS"; break;
            case SSP_CRITICAL:
                Text = "CRITICAL"; break;
            case SSP_LEAK_TRACK:
                Text = "LEAK_TRACK"; break;
            case SSP_WARNING:
                Text = "WARNING"; break;
            case SSP_LPC:
            case SSP_LPC_MORE:
                Text = "LPC"; break;
            case SSP_API:
                Text = "API"; break;
            case SSP_API_MORE:
                Text = "APIMORE"; break;
            case SSP_SESSION_KEYS:
                Text = "SESSION_KEYS"; break;
            case SSP_NEGOTIATE_FLAGS:
                Text = "NEGOTIATE_FLAGS"; break;
            case SSP_UPDATES:
                Text = "UPDATES"; break;
            case SSP_NTLM_V2:
                Text = "NTLM_V2"; break;
            case SSP_CRED:
                Text = "CRED"; break;
            case SSP_VERSION:
                Text = "VER"; break;
            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }

            if ( Text != NULL )
            {
                cbUsed = _snprintf( &OutputBuffer[length], sizeof(OutputBuffer) - 1 - length,
                                   "[%s] ", Text );
                if (cbUsed <= 0)
                {
                    goto Done;
                }

                length += cbUsed;
            }
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    cbUsed = _vsnprintf(&OutputBuffer[length], sizeof(OutputBuffer) - 1 - length,
                        Format, arglist);
    va_end(arglist);

    if (cbUsed <= 0)
    {
        goto Done;
    }

    length += cbUsed;

Done:

    BeginningOfLine = (length > 0 && OutputBuffer[length - 1] == '\n' );

    //
    //  just output to the debug terminal
    //

    (void) DbgPrint( (PCH) OutputBuffer);

    LeaveCriticalSection( &SspGlobalLogFileCritSect );

} // SspPrintRoutine

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\credhand.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    credhand.cxx

Abstract:

    API and support routines for handling credential handles.

Author:


    Cliff Van Dyke (CliffV) 26-Jun-1993
Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\credhand.c

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR

extern "C"
{

#include <nlp.h>

}

//
// Crit Sect to protect various globals in this module.
//

RTL_RESOURCE    SspCredentialCritSect;
LIST_ENTRY      SspCredentialList;

// This is the definition of a null session string.
// Change this if the definition changes

#define IsNullSessionString(x) (((x)->Length == 0) &&    \
                          ((x)->Buffer != NULL))


BOOLEAN
AlterRtlEqualUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )
/*++
    This is here to catch cases that RtlEqualUnicodeString does not.
    For e.g, if String1 is (NULL,0,0) and String2 is ("",0,2),
    RtlEqualUnicodeString returned TRUE but we really want it to return FALSE
--*/
{
    BOOL fRet = RtlEqualUnicodeString(String1, String2, CaseInSensitive);

    if (fRet && (IsNullSessionString(String1) != IsNullSessionString(String2)))
    {
        fRet = FALSE;
    }
    return (fRet != 0);
}



NTSTATUS
SspCredentialReferenceCredential(
    IN ULONG_PTR CredentialHandle,
    IN BOOLEAN DereferenceCredential,
    OUT PSSP_CREDENTIAL * UserCredential
    )

/*++

Routine Description:

    This routine checks to see if the Credential is from a currently
    active client, and references the Credential if it is valid.

    The caller may optionally request that the client's Credential be
    removed from the list of valid Credentials - preventing future
    requests from finding this Credential.

    For a client's Credential to be valid, the Credential value
    must be on our list of active Credentials.


Arguments:

    CredentialHandle - Points to the CredentialHandle of the Credential
        to be referenced.

    DereferenceCredential - This boolean value indicates that that a call
        a single instance of this credential handle should be freed. If there
        are multiple instances, they should still continue to work.


Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

{
    PSSP_CREDENTIAL Credential = NULL;
    SECPKG_CALL_INFO CallInfo;
    ULONG DereferenceCount;

    *UserCredential = NULL ;


    if (LsaFunctions->GetCallInfo(&CallInfo))
    {
        DereferenceCount = CallInfo.CallCount;
    } else {
        ASSERT( (STATUS_INTERNAL_ERROR == STATUS_SUCCESS) );
        return STATUS_INTERNAL_ERROR;
    }


    if( CallInfo.Attributes & SECPKG_CALL_CLEANUP )
    {
        CallInfo.Attributes |= SECPKG_CALL_IS_TCB;

        SspPrint(( SSP_LEAK_TRACK, "SspCredentialReferenceCredential: pid: 0x%lx handle: %p refcount: %lu\n",
                    CallInfo.ProcessId, CredentialHandle, DereferenceCount));
    }


    //
    // Acquire exclusive access to the Credential list
    //

    RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );


    __try {

        Credential = (PSSP_CREDENTIAL)CredentialHandle;

        while( Credential->CredentialTag == SSP_CREDENTIAL_TAG_ACTIVE )
        {

            // Make sure we have the privilege of accessing
            // this handle

            if (((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0) &&
                 (Credential->ClientProcessID != CallInfo.ProcessId)
               )
            {
                break;
            }

            if (!DereferenceCredential) {
                InterlockedIncrement( (PLONG)&Credential->References );
            } else {

                LONG References;

                //
                // Decremenent the credential references, indicating
                // that a call to free

                ASSERT((DereferenceCount > 0));

                //
                // NOTE: subtract one off the deref count,
                // avoids an extra interlocked operation, since DerefCred will
                // decrement and check for refcnt == 0.
                //

                DereferenceCount--;

                if( DereferenceCount == 1 )
                {
                    References = InterlockedDecrement( (PLONG)&Credential->References );

                    ASSERT( (References > 0) );
                } else if( DereferenceCount > 1 )
                {

                    //
                    // there is no equivalent to InterlockedSubtract.
                    // so, turn it into an Add with some signed magic.
                    //

                    LONG DecrementToIncrement = 0 - DereferenceCount;

                    References = InterlockedExchangeAdd( (PLONG)&Credential->References, DecrementToIncrement );

                    ASSERT( ((References+DecrementToIncrement) > 0) );
                }
            }

            *UserCredential = Credential ;

            RtlReleaseResource( &SspCredentialCritSect );

            return STATUS_SUCCESS ;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SspPrint(( SSP_CRITICAL, "Tried to reference invalid Credential %p\n",
                       Credential ));

    }


    RtlReleaseResource( &SspCredentialCritSect );

    //
    // No match found
    //
    SspPrint(( SSP_API_MORE, "Tried to reference unknown Credential %p\n",
               CredentialHandle ));


    return STATUS_INVALID_HANDLE ;
}



NTSTATUS
SspCredentialGetPassword(
    IN PSSP_CREDENTIAL Credential,
    OUT PUNICODE_STRING Password
    )
/*++

Routine Description:

    This routine copies the password out of credential.

    NOTE: Locking is no longer required, because the caller is expected
    to NtLmDuplicateUnicodeString() the cipher text Password prior to
    passing it to this routine.  This change allows the following advantages:

    1. Avoid taking Credential list lock.
    2. Avoid having to avoid having to Re-hide the password after reveal.
    3. Avoid having to take locks elsewhere associated with hiding/revealing.


Arguments:

    Credential - Credential record to retrieve the password from.

    Password - UNICODE_STRING to store the password in.


Return Value:

    STATUS_NO_MEMORY - there was not enough memory to copy
        the password.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( Credential->Password.Buffer != NULL ) {
        Status = NtLmDuplicatePassword(
                        Password,
                        &Credential->Password
                        );
    } else {
        RtlInitUnicodeString(
            Password,
            NULL
            );
    }

    return(Status);
}


PSSP_CREDENTIAL
SspCredentialLookupCredential(
    IN PLUID LogonId,
    IN ULONG CredentialUseFlags,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password
    )

/*++

Routine Description:

    This routine walks the list of credentials for this client looking
    for one that has the same supplemental credentials as those passed
    in.  If it is found, its reference count is increased and a pointer
    to it is returned.


Arguments:

    UserName - User name to match.

    DomainName - Domain name to match.

    Password - Password to match.


Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

{
    SspPrint((SSP_API_MORE, "Entering SspCredentialLookupCredential\n"));
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PSSP_CREDENTIAL Credential = NULL;
    PSSP_CREDENTIAL CredentialResult = NULL;
    PLIST_ENTRY ListHead;
    SECPKG_CALL_INFO CallInfo ;

    UNICODE_STRING EncryptedPassword;

    if ( !LsaFunctions->GetCallInfo( &CallInfo ) )
    {
        SspPrint(( SSP_CRITICAL, "SspCredentialLookupCredential: GetCallInfo returned FALSE\n" ));
        return NULL ;
    }

    ZeroMemory(&EncryptedPassword, sizeof(EncryptedPassword));

    Status = NtLmDuplicatePassword(&EncryptedPassword, Password);
    if(!NT_SUCCESS( Status ))
    {
        SspPrint(( SSP_CRITICAL, "SspCredentialLookupCredential: DuplicatePassword failed\n" ));
        return NULL;
    }

    SspHidePassword( &EncryptedPassword );

    //
    // Acquire exclusive access to the Credential list
    //

    RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );

    ListHead = &SspCredentialList;

    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = ListHead->Flink;
          ListEntry != ListHead;
          ListEntry = ListEntry->Flink )
    {

        Credential = CONTAINING_RECORD( ListEntry, SSP_CREDENTIAL, Next );

        //
        // we now allow matching and pooling of INBOUND creds, too.
        //


        //
        // We only want credentials from the same caller
        //
        if (Credential->ClientProcessID != CallInfo.ProcessId) {
            continue;
        }

        //
        // don't share creds across impersonation levels.
        //

        if (Credential->ImpersonationLevel != ImpersonationLevel)
        {
            continue;
        }

        //
        // if the caller is from kernel mode, only return creds
        // granted to kernel mode
        //

        if ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) != 0 )
        {
            if ( !Credential->KernelClient )
            {
                continue;
            }
        }

        //
        // Check for a match
        //

        // The credential use check was added because null session
        // credentials were being returned when default credentials
        // were being asked. This happened becuase RtlEqualUnicodeString
        // for NULL,0,0 and "",0,2 is TRUE

        if ( (CredentialUseFlags != Credential->CredentialUseFlags) )
        {
            continue;
        }

        if(!RtlEqualLuid(
                LogonId,
                &Credential->LogonId
                ))
        {
            continue;
        }

        if(!AlterRtlEqualUnicodeString(
                UserName,
                &Credential->UserName,
                FALSE
                ))
        {
            continue;
        }

        if(!AlterRtlEqualUnicodeString(
                DomainName,
                &Credential->DomainName,
                FALSE
                ))
        {
            continue;
        }

        //
        // password is stored encrypted in list -- we're comparing
        // a one-time encrypted version of candidate.  advantages:
        // 1. passwords not revealed in memory.
        // 2. only need encrypt candidate single time.
        //

        if(!AlterRtlEqualUnicodeString(
                &Credential->Password,
                &EncryptedPassword,
                FALSE
                ))
        {
            continue;
        }

        //
        // Found a match - reference the credential
        //


        //
        // Reference the credential and indicate that
        // it is in use as two different handles to the caller
        // (who may call FreeCredentialsHandle twice)
        //

        InterlockedIncrement( (PLONG)&Credential->References );

        CredentialResult = Credential;
        break;
    }


    RtlReleaseResource( &SspCredentialCritSect );

    if( EncryptedPassword.Buffer != NULL ) {
        ZeroMemory( EncryptedPassword.Buffer, EncryptedPassword.Length );
        NtLmFree( EncryptedPassword.Buffer );
    }


    if( CredentialResult == NULL )
    {
        SspPrint(( SSP_API_MORE, "Tried to reference unknown Credential\n" ));
    }

    SspPrint((SSP_API_MORE, "Leaving SspCredentialLookupCredential\n"));

    return CredentialResult;
}


VOID
SspCredentialDereferenceCredential(
    IN PSSP_CREDENTIAL Credential
    )

/*++

Routine Description:

    This routine decrements the specified Credential's reference count.
    If the reference count drops to zero, then the Credential is deleted

Arguments:

    Credential - Points to the Credential to be dereferenced.


Return Value:

    None.

--*/

{
    LONG References;

    //
    // Decrement the reference count
    //

    References = InterlockedDecrement( (PLONG)&Credential->References );

    ASSERT( References >= 0 );

    //
    // If the count dropped to zero, then run-down the Credential
    //

    if ( References == 0 )
    {

        if (!Credential->Unlinked) {

            RtlAcquireResourceExclusive(&SspCredentialCritSect, TRUE);

            if( Credential->References != 0 )
            {
                RtlReleaseResource( &SspCredentialCritSect );
                return;
            }

            RemoveEntryList( &Credential->Next );
            Credential->Unlinked = TRUE;
            Credential->CredentialTag = SSP_CREDENTIAL_TAG_DELETE;

            RtlReleaseResource( &SspCredentialCritSect );
        }

        SspPrint(( SSP_API_MORE, "Deleting Credential 0x%lx\n",
                   Credential ));

        if ( Credential->Password.Buffer ) {
            ZeroMemory( Credential->Password.Buffer, Credential->Password.MaximumLength );
            (VOID) NtLmFree( Credential->Password.Buffer );
        }

        if ( Credential->DomainName.Buffer ) {
            (VOID) NtLmFree( Credential->DomainName.Buffer );
        }

        if ( Credential->UserName.Buffer ) {
            (VOID) NtLmFree( Credential->UserName.Buffer );
        }


        ZeroMemory( Credential, sizeof(SSP_CREDENTIAL) );
        (VOID) NtLmFree( Credential );
    }

    return;
}

BOOLEAN
SsprCheckMachineLogon(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password,
    IN OUT PLUID pLogonId,
    IN OUT ULONG *pCredFlags
    )
/*++

Routine Description:

    This routine determines if the input credential matches a special
    machine account logon over-ride.

    This routine also checks if the caller is the NetworkService account,
    specifying default credentials, in a downlevel domain.  This will cause
    a credential over-ride to LocalSystem, for backwards compatibility.
    NT4 did not understand machine account authentication, so outbound authentication
    from networkservice as machine account cannot succeed -- downgrade to the old
    LocalSystem default.


Return Value:

    TRUE - the intput credential was the special machine account logon over-ride.
           the pLogonId is updated to utilize the machine credential.

--*/
{
    UNICODE_STRING MachineAccountName;
    static LUID LogonIdAnonymous = ANONYMOUS_LOGON_LUID;
    static LUID LogonIdSystem = SYSTEM_LUID;
    static LUID LogonIdNetworkService = NETWORKSERVICE_LUID;
    BOOLEAN fMachineLogon = FALSE;

    MachineAccountName.Buffer = NULL;

    //
    // if caller is NetworkService with default cred, for downlevel domains
    // use anonymous
    //

    if (RtlEqualLuid( pLogonId, &LogonIdNetworkService ))
    {
        if ( UserName->Buffer == NULL &&
            DomainName->Buffer == NULL &&
            Password->Buffer == NULL )
        {
            BOOL MixedMode = FALSE;
            NTSTATUS Status;

            if ( !NlpNetlogonInitialized )
            {
                Status = NlWaitForNetlogon( NETLOGON_STARTUP_TIME );

                if ( NT_SUCCESS(Status) )
                {
                    NlpNetlogonInitialized = TRUE;
                }
            }

            if (NlpNetlogonInitialized)
            {
                ASSERT(NlpNetLogonMixedDomain && L"NlpNetLogonMixedDomain must be non null");

                Status = (*NlpNetLogonMixedDomain)(&MixedMode);
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "SsprCheckMachineLogon call to I_NetLogonMixedDomain failed %#x\n", Status));
                    MixedMode = FALSE;
                }
            }

            if (MixedMode)
            {
                SspPrint((SSP_WARNING, "SsprCheckMachineLogon using anonymous connection for networkservices\n"));
                *pLogonId = LogonIdAnonymous; // use anonymous
                *pCredFlags |= SSP_CREDENTIAL_FLAG_WAS_NETWORK_SERVICE;

                // return FALSE;
            }
            else
            {
                return TRUE;
            }
        }

        return FALSE;
    }

    //
    // check if caller was system, and requested machine credential
    // eg: user=computername$, domain=NULL, password=NULL
    //

    if ( !RtlEqualLuid( pLogonId, &LogonIdSystem ) )
    {
        return FALSE;
    }

    if( UserName->Buffer == NULL )
    {
        return FALSE;
    }

    if( DomainName->Buffer != NULL )
    {
        return FALSE;
    }

    if( Password->Buffer != NULL )
    {
        return FALSE;
    }


    RtlAcquireResourceShared (&NtLmGlobalCritSect, TRUE);

    MachineAccountName.Length = NtLmGlobalUnicodeComputerNameString.Length + sizeof(WCHAR);

    if( MachineAccountName.Length == UserName->Length )
    {
        MachineAccountName.MaximumLength = MachineAccountName.Length;
        MachineAccountName.Buffer = (PWSTR)NtLmAllocate( MachineAccountName.Length );

        if( MachineAccountName.Buffer != NULL )
        {
            RtlCopyMemory(  MachineAccountName.Buffer,
                            NtLmGlobalUnicodeComputerNameString.Buffer,
                            NtLmGlobalUnicodeComputerNameString.Length
                            );

            MachineAccountName.Buffer[ (MachineAccountName.Length / sizeof(WCHAR)) - 1 ] = L'$';
        }
    }

    RtlReleaseResource (&NtLmGlobalCritSect);


    if( MachineAccountName.Buffer == NULL )
    {
        goto Cleanup;
    }

    if( RtlEqualUnicodeString( &MachineAccountName, UserName, TRUE ) )
    {
        //
        // yes, it's a machine account logon request, update the
        // requested LogonId to match our mapped logon session.
        //

        *pLogonId = NtLmGlobalLuidMachineLogon;
        fMachineLogon = TRUE;
    }

Cleanup:

    if( MachineAccountName.Buffer )
    {
        NtLmFree( MachineAccountName.Buffer );
    }

    return fMachineLogon;
}


NTSTATUS
SsprAcquireCredentialHandle(
    IN PLUID LogonId,
    IN PSECPKG_CLIENT_INFO ClientInfo,
    IN ULONG CredentialUseFlags,
    OUT PLSA_SEC_HANDLE CredentialHandle,
    OUT PTimeStamp Lifetime,
    IN OPTIONAL PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING UserName,
    IN OPTIONAL PUNICODE_STRING Password
    )

/*++

Routine Description:

    This API allows applications to acquire a handle to pre-existing
    credentials associated with the user on whose behalf the call is made
    i.e. under the identity this application is running.  These pre-existing
    credentials have been established through a system logon not described
    here.  Note that this is different from "login to the network" and does
    not imply gathering of credentials.


    This API returns a handle to the credentials of a principal (user, client)
    as used by a specific security package.  This handle can then be used
    in subsequent calls to the Context APIs.  This API will not let a
    process obtain a handle to credentials that are not related to the
    process; i.e. we won't allow a process to grab the credentials of
    another user logged into the same machine.  There is no way for us
    to determine if a process is a trojan horse or not, if it is executed
    by the user.

Arguments:

    CredentialUseFlags - Flags indicating the way with which these
        credentials will be used.

        #define     CRED_INBOUND        0x00000001
        #define     CRED_OUTBOUND       0x00000002
        #define     CRED_BOTH           0x00000003

        The credentials created with CRED_INBOUND option can only be used
        for (validating incoming calls and can not be used for making accesses.

    CredentialHandle - Returned credential handle.

    Lifetime - Time that these credentials expire. The value returned in
        this field depends on the security package.

    DomainName, DomainNameSize, UserName, UserNameSize, Password, PasswordSize -
        Optional credentials for this user.

Return Value:

    STATUS_SUCCESS -- Call completed successfully

    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
    SEC_E_NOT_OWNER -- caller does not own the specified credentials
    STATUS_NO_MEMORY -- Not enough memory

--*/

{
    SspPrint((SSP_API_MORE, "Entering SsprAcquireCredentialHandle\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CREDENTIAL Credential = NULL;
    ULONG CredFlags = 0; // ntlm specific cred use flags


    if ((CredentialUseFlags & SECPKG_CRED_OUTBOUND) != 0) {

        //
        // check if machine account logon over-ride.
        // this has the side-effect of updating LogonId if over-ride was
        // requsted.
        //

        SsprCheckMachineLogon(
            UserName,
            DomainName,
            Password,
            LogonId,
            &CredFlags
            );
    }

    //
    // Look to see if we have already created one with this set of credentials.
    // Note - this leaves the credential referenced, so if we fail further down
    // we need to dereference the credential.
    //

    Credential = SspCredentialLookupCredential(
        LogonId,
        CredentialUseFlags,
        ClientInfo->ImpersonationLevel,
        UserName,
        DomainName,
        Password
        );

    //
    // If we're using a common set of data, free the captured stuff
    //

    if ( Credential )
    {
        if ( (UserName) && (UserName->Buffer) )
        {
            NtLmFree( UserName->Buffer );
            UserName->Buffer = NULL ;
        }

        if ( ( DomainName ) && (DomainName->Buffer) )
        {
            NtLmFree( DomainName->Buffer );
            DomainName->Buffer = NULL ;
        }

        if ( ( Password ) && ( Password->Buffer ) )
        {
            ZeroMemory( Password->Buffer, Password->Length );
            NtLmFree( Password->Buffer );
            Password->Buffer = NULL ;
        }

        Credential->MutableCredFlags = CredFlags; // atomic
    }

    //
    // If we didn't just find a credential, create one now.
    //

    if (Credential == NULL) {

        SECPKG_CALL_INFO CallInfo ;

        if ( !LsaFunctions->GetCallInfo( &CallInfo ) )
        {
            SspPrint((SSP_CRITICAL, "SsprAcquireCredentialHandle failed to GetCallInfo\n"));
            Status = STATUS_UNSUCCESSFUL ;
            goto Cleanup;
        }

        //
        // Allocate a credential block and initialize it.
        //

        Credential = (PSSP_CREDENTIAL)NtLmAllocate(sizeof(SSP_CREDENTIAL) );

        if ( Credential == NULL ) {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "Error from NtLmAllocate 0x%lx\n", Status));
            goto Cleanup;
        }

        ZeroMemory( Credential, sizeof(*Credential) );

        Credential->References = 1;
        Credential->ClientProcessID = ClientInfo->ProcessID;
        Credential->CredentialUseFlags = CredentialUseFlags;
        Credential->MutableCredFlags = CredFlags;
        Credential->ImpersonationLevel = ClientInfo->ImpersonationLevel;
        Credential->Unlinked = TRUE;

        if ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) != 0 )
        {
            Credential->KernelClient = TRUE ;
        }
        else
        {
            Credential->KernelClient = FALSE ;
        }


        //
        // Stick the logon ID in the credential
        //

        Credential->LogonId = *LogonId;

        //
        // Stick the supplemental credentials into the credential.
        //

        if (ARGUMENT_PRESENT(DomainName))
        {
            Credential->DomainName = *DomainName;
        }

        if (ARGUMENT_PRESENT(UserName))
        {
            Credential->UserName = *UserName;
        }

        if (ARGUMENT_PRESENT(Password))
        {
            SspHidePassword(Password);
            Credential->Password = *Password;
        }

        //
        // Add it to the list of valid credential handles.
        //

        Credential->Unlinked = FALSE;
        Credential->CredentialTag = SSP_CREDENTIAL_TAG_ACTIVE;

        RtlAcquireResourceExclusive( &SspCredentialCritSect, TRUE );
        InsertHeadList( &SspCredentialList, &Credential->Next );
        RtlReleaseResource( &SspCredentialCritSect );

        SspPrint((SSP_API_MORE, "Added Credential 0x%lx\n", Credential ));

        //
        // Don't bother dereferencing because we already set the
        // reference count to 1.
        //
    }

    //
    // Return output parameters to the caller.
    //

    *CredentialHandle = (LSA_SEC_HANDLE) Credential;

    *Lifetime = NtLmGlobalForever;

Cleanup:

    if ( !NT_SUCCESS(Status) ) {

        if ( Credential != NULL ) {
            (VOID)NtLmFree( Credential );
        }

    }

    SspPrint((SSP_API_MORE, "Leaving SsprAcquireCredentialHandle\n"));

    return Status;
}


NTSTATUS
SsprFreeCredentialHandle(
    IN ULONG_PTR CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:


    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    STATUS_SUCCESS -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    STATUS_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CREDENTIAL Credential;

    SspPrint(( SSP_API_MORE, "SspFreeCredentialHandle Entered\n" ));

    //
    // Find the referenced credential and delink it.
    //

    Status = SspCredentialReferenceCredential(
                            CredentialHandle,
                            TRUE,       // remove the instance of the credential
                            &Credential );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    //
    // Dereferencing the Credential will remove the client's reference
    // to it, causing it to be rundown if nobody else is using it.
    //

    SspCredentialDereferenceCredential( Credential );

    //
    // Free and locally used resources.
    //
Cleanup:


    SspPrint(( SSP_API_MORE, "SspFreeCredentialHandle returns 0x%lx\n", Status ));
    return Status;
}


NTSTATUS
SspCredentialInitialize(
    VOID
    )

/*++

Routine Description:

    This function initializes this module.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Credential list to be empty.
    //

    __try
    {
        RtlInitializeResource(&SspCredentialCritSect);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    InitializeListHead( &SspCredentialList );

Cleanup:

    return Status;
}


VOID
SspCredentialTerminate(
    VOID
    )

/*++

Routine Description:

    This function cleans up any dangling credentials.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/

{
#if 0
    NTSTATUS Status ;

    //
    // Drop any lingering Credentials
    //

    RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );
    while ( !IsListEmpty( &SspCredentialList ) ) {
        ULONG_PTR CredentialHandle;
        PSSP_CREDENTIAL Credential;

        CredentialHandle =
            (LSA_SEC_HANDLE) CONTAINING_RECORD( SspCredentialList.Flink,
                                      SSP_CREDENTIAL,
                                      Next );


        RtlReleaseResource( &SspCredentialCritSect );

        Status = SspCredentialReferenceCredential(
                                CredentialHandle,
                                TRUE,
                                TRUE,
                                &Credential );            // Remove Credential

        if ( Credential != NULL ) {
            SspCredentialDereferenceCredential(Credential);
        }

        RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );
    }
    RtlReleaseResource( &SspCredentialCritSect );


    //
    // Delete the critical section
    //

    RtlDeleteResource(&SspCredentialCritSect);
#endif

    return;

}

BOOL
SspEnableAllPrivilegesToken(
    IN  HANDLE ClientTokenHandle
    )
{
    PTOKEN_PRIVILEGES pPrivileges;
    BYTE FastBuffer[ 512 ];
    PBYTE SlowBuffer = NULL;
    DWORD cbPrivileges;
    BOOL fSuccess;

    pPrivileges = (PTOKEN_PRIVILEGES)FastBuffer;
    cbPrivileges = sizeof( FastBuffer );

    fSuccess = GetTokenInformation(
                ClientTokenHandle,
                TokenPrivileges,
                pPrivileges,
                cbPrivileges,
                &cbPrivileges
                );

    if( !fSuccess ) {

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            return FALSE;

        SlowBuffer = (PBYTE)NtLmAllocate( cbPrivileges );
        if( SlowBuffer == NULL )
            return FALSE;

        pPrivileges = (PTOKEN_PRIVILEGES)SlowBuffer;

        fSuccess = GetTokenInformation(
                        ClientTokenHandle,
                        TokenPrivileges,
                        pPrivileges,
                        cbPrivileges,
                        &cbPrivileges
                        );
    }


    if( fSuccess && pPrivileges->PrivilegeCount != 0 ) {
        DWORD indexPrivilege;

        for( indexPrivilege = 0 ;
             indexPrivilege < pPrivileges->PrivilegeCount ;
             indexPrivilege ++ )
        {
            pPrivileges->Privileges[ indexPrivilege ].Attributes |=
                SE_PRIVILEGE_ENABLED;
        }

        fSuccess = AdjustTokenPrivileges(
                        ClientTokenHandle,
                        FALSE,
                        pPrivileges,
                        0,
                        NULL,
                        NULL
                        );

        if( fSuccess && GetLastError() != ERROR_SUCCESS )
            fSuccess = FALSE;
    }

    if( SlowBuffer )
        NtLmFree( SlowBuffer );

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\miscapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        miscapi.cxx
//
// Contents:    Code for miscellaneous lsa mode NtLm entrypoints
//              Main entry points in the dll:
//                SpGetUserInfo
//
//
// History:     ChandanS   26-Jul-1996   Stolen from kerberos\client2\miscapi.cxx
//
//------------------------------------------------------------------------
#include <global.h>

NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    SspPrint((SSP_API, "Entering SpGetUserInfo\n"));

    UNREFERENCED_PARAMETER(LogonId);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(UserData);

    SspPrint((SSP_API, "Leaving SpGetUserInfo\n"));
    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

    03-Aug-1996 ChandanS
        Stolen from net\svcdlls\ntlmssp\debug.h
--*/

//
// init.c will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef DEBUG_ALLOCATE
#undef EXTERN
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define SSP_INIT            0x00000001  // Initialization
#define SSP_MISC            0x00000002  // Misc debug
#define SSP_API             0x00000004  // API processing
#define SSP_LPC             0x00000008  // LPC
#define SSP_LOGON_SESS      0x00000010  // tracking logon sessions
#define SSP_CRITICAL        0x00000100  // Only real important errors
#define SSP_LEAK_TRACK      0x00000200  // calling PID etc
#define SSP_WARNING         0x00000400  // not fatal warnings of interest to developer
#define SSP_UPDATES         0x00000800  // updates to globals, passwords, etc.


#define SSP_SESSION_KEYS    0x00001000  // keying material
#define SSP_NEGOTIATE_FLAGS 0x00002000  // negotiate flags.
#define SSP_CRED            0x00004000  // tracking credentials
#define SSP_VERSION         0x00008000  // tracking versioning

//
// Very verbose bits
//

#define SSP_NTLM_V2         0x01000000  // verbose NTLMv2 info
#define SSP_API_MORE        0x04000000  // verbose API
#define SSP_LPC_MORE        0x08000000  // verbose LPC

//
// Control bits.
//

#define SSP_NO_LOCAL        0x10000000  // Force client to use OEM character set
#define SSP_TIMESTAMP       0x20000000  // TimeStamp each output line
#define SSP_REQUEST_TARGET  0x40000000  // Force client to ask for target name
#define SSP_USE_OEM         0x80000000  // Force client to use OEM character set


//
// Name and directory of log file
//

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\ntlmssp.log"
#define DEBUG_BAK_FILE      L"\\ntlmssp.bak"

#if DBG

EXTERN DWORD SspGlobalDbflag;

#define IF_DEBUG(Function) \
     if (SspGlobalDbflag & SSP_ ## Function)

#define SspPrint(_x_) SspPrintRoutine _x_

VOID
SspPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
SspDumpHexData(
    IN DWORD DebugFlag,
    IN LPDWORD Buffer,
    IN DWORD BufferSize
    );

VOID
SspDumpSid(
    IN DWORD DebugFlag,
    IN PSID Sid
    );

VOID
SspDumpBuffer(
    IN DWORD DebugFlag,
    IN PVOID Buffer,
    IN DWORD BufferSize
    );

VOID
SspOpenDebugFile(
    IN BOOL ReopenFlag
    );

//
// Debug log file
//

EXTERN HANDLE SspGlobalLogFile;
#define DEFAULT_MAXIMUM_LOGFILE_SIZE 20000000
EXTERN DWORD SspGlobalLogFileMaxSize;

//
// To serialize access to log file.
//

EXTERN CRITICAL_SECTION SspGlobalLogFileCritSect;
EXTERN LPWSTR SspGlobalDebugSharePath;

#else

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.
#define SspDumpHexData        /* no output; ignore arguments */
#define SspDumpBuffer
#define SspDumpSid
#define SspPrint(_x_)

#endif // DBG

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msp.h

Abstract:

    MSV1_0 authentication package private definitions.

Author:

    Jim Kelly 11-Apr-1991

Revision History:
    Scott Field (sfield)    05-Oct-98   Add NTLM3
    Scott Field (sfield)    15-Jan-98   Add MspNtDeriveCredential
    Chandana Surlu          21-Jul-96   Stolen from \\kernel\razzle3\src\security\msv1_0\msv1_0.c

--*/

#ifndef _MSP_
#define _MSP_

#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>
#include <ntmsv1_0.h>

#include <windows.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            SspPrint((SSP_CRITICAL, "Failed RELOCATE_ONE\n"));              \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                SspPrint((SSP_CRITICAL, "Failed NULL_RELOCATE_ONE\n"));     \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }


//
// RELOCATE_ONE_ENCODED - Relocate a unicode string pointer in a client
//   buffer.  The upper byte of the length field may be an encryption seed
//   and should not be used for error checking.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length & 0x00ff.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE_ENCODED( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + ((_q)->Length & 0x00ff) > SubmitBufferSize ||         \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            SspPrint((SSP_CRITICAL, "Failed RELOCATE_ONE_ENCODED\n"));      \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length & 0x00ff;                        \
    }

//
//  Following macro is used to initialize UNICODE strings
//
#ifndef CONSTANT_UNICODE_STRING
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#endif // CONSTANT_UNICODE_STRING

//
// General arrary count.
//

#ifndef COUNTOF
    #define COUNTOF(s) ( sizeof( (s) ) / sizeof( *(s) ) )
#endif // COUNTOF

#define NULL_SESSION_REQUESTED RETURN_RESERVED_PARAMETER 
#define PRIMARY_CREDENTIAL_NEEDED \
            (RETURN_PRIMARY_LOGON_DOMAINNAME | \
            RETURN_PRIMARY_USERNAME | \
            USE_PRIMARY_PASSWORD )
     
///////////////////////////////////////////////////////////////////////
//                                                                   //
// Authentication package dispatch routine definitions               //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    );

NTSTATUS
LsaApLogonUser(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority
    );

NTSTATUS
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

VOID
LsaApLogonTerminated(
    IN PLUID LogonId
    );


///////////////////////////////////////////////////////////////////////
//                                                                   //
// LsaApCallPackage function dispatch routines                       //
//                                                                   //
///////////////////////////////////////////////////////////////////////


NTSTATUS
MspLm20Challenge(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20GetChallengeResponse(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20EnumUsers(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20GetUserInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20ReLogonUsers(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20ChangePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20GenericPassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20CacheLogon(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20CacheLookup(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspNtSubAuth(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspNtDeriveCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspSetProcessOption(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );




///////////////////////////////////////////////////////////////////////
//                                                                   //
// NETLOGON routines visible to main msv1_0 code                     //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
NlInitialize(
    VOID
    );

NTSTATUS
MspLm20LogonUser (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation
    );

VOID
MsvLm20LogonTerminated (
    IN PLUID LogonId
    );




///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

//
// Variables defined in msvars.c
//

extern ULONG MspAuthenticationPackageId;
extern LSA_SECPKG_FUNCTION_TABLE Lsa;


//
// Change password log support routines
//


#ifndef DONT_LOG_PASSWORD_CHANGES

ULONG
MsvPaswdInitializeLog(
    VOID
    );

ULONG
MsvPaswdSetAndClearLog(
    VOID
    );

ULONG
MsvPaswdCloseLog(
    VOID
    );

VOID
MsvPaswdLogPrintRoutine(
    IN LPSTR Format,
    ...
    );

#define MsvPaswdLogPrint( x )  MsvPaswdLogPrintRoutine x


#else

#define MsvPaswdInitializeLog()
#define MsvPaswdCloseLog()
#define MsvPaswdLogPrint( x )
#define MsvPaswdSetAndClearLog()
#endif

#endif // _MSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\encrypt.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    encrypt.cxx

Abstract:

    Contains routine to check whether encryption is supported on this
    system or not.

Author:

    Mike Swift (MikeSw) 2-Aug-1994

Revision History:

    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\common\encrypt.c
--*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>

extern "C"
BOOLEAN
IsEncryptionPermitted(VOID)
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{

//
// sfield: permission to remove FRANCE check obtained 08-21-1999
//

#if 0
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfo(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }
    CountryValue = (ULONG) wcstol(CountryCode,NULL,10);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
#endif

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msvpaswd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msvpaswd.c

Abstract:

    This file contains the MSV1_0 Authentication Package password routines.

Author:

    Dave Hart    (davehart)   12-Mar-1992

Revision History:
    Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\msvpaswd.c

--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"

#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmremutl.h>
#include <lmwksta.h>

#include "msvwow.h"  // MsvConvertWOWChangePasswordBuffer()



NTSTATUS
MspDisableAdminsAlias (
    VOID
    )

/*++

Routine Description:

    Remove the current thread from the Administrators alias.  This
    is accomplished by impersonating our own thread, then removing
    the Administrators alias membership from the impersonation
    token.  Use MspStopImpersonating() to stop impersonating and
    thereby restore the thread to the Administrators alias.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    NTSTATUS                 Status;
    HANDLE                   TokenHandle = NULL;
    HANDLE                   FilteredToken = NULL;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    PSID                     AdminSid = NULL;
    SID                      LocalSystemSid = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID};
    BYTE                     GroupBuffer[sizeof(TOKEN_GROUPS) + sizeof(SID_AND_ATTRIBUTES)];
    PTOKEN_GROUPS            TokenGroups = (PTOKEN_GROUPS) GroupBuffer;

    //
    // Make sure we aren't impersonating anyone else
    // (that will prevent the RtlImpersonateSelf() call from succeeding).
    //

    RevertToSelf();

    //
    // Open our process token so we can filter it to disable the
    // Administrators and LocalSystem SIDs
    //

    Status = RtlImpersonateSelf(SecurityDelegation);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
                TRUE,           // open as self
                &TokenHandle
                );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Build the SID for the Administrators alias.  The Administrators
    // alias SID is well known, S-1-5-32-544.
    //

    Status = RtlAllocateAndInitializeSid(
        &IdentifierAuthority,         // SECURITY_NT_AUTHORITY (5)
        2,                            // SubAuthorityCount
        SECURITY_BUILTIN_DOMAIN_RID,  // 32
        DOMAIN_ALIAS_RID_ADMINS,      // 544
        0,0,0,0,0,0,
        &AdminSid
        );

    if ( !NT_SUCCESS(Status) ) {

        KdPrint(("MspDisableAdminsAlias: RtlAllocateAndInitializeSid returns %x\n",
                 Status));
        goto Cleanup;
    }

    //
    // Disable the Administrators and LocalSystem aliases.
    //

    TokenGroups->GroupCount = 2;
    TokenGroups->Groups[0].Sid = AdminSid;
    TokenGroups->Groups[0].Attributes = 0;   // SE_GROUP_ENABLED not on.
    TokenGroups->Groups[1].Sid = &LocalSystemSid;
    TokenGroups->Groups[1].Attributes = 0;   // SE_GROUP_ENABLED not on.

    Status = NtFilterToken(
                 TokenHandle,
                 0,                     // no flags
                 TokenGroups,
                 NULL,                  // no privileges
                 NULL,                  // no restricted sids
                 &FilteredToken
                 );

    if ( !NT_SUCCESS(Status) ) {

        KdPrint(("MspDisableAdminsAlias: NtFilter returns %x\n",
                 Status));
        goto Cleanup;
    }
    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                &FilteredToken,
                sizeof(HANDLE)
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

Cleanup:

    if (AdminSid) {
        RtlFreeSid(AdminSid);
    }

    if (TokenHandle) {
        NtClose(TokenHandle);
    }

    if (FilteredToken) {
        NtClose(FilteredToken);
    }

    return Status;
}


NTSTATUS
MspImpersonateAnonymous(
    VOID
    )

/*++

Routine Description:

    Remove the current thread from the Administrators alias.  This
    is accomplished by impersonating our own thread, then removing
    the Administrators alias membership from the impersonation
    token.  Use RevertToSelf() to stop impersonating and
    thereby restore the thread to the Administrators alias.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    RevertToSelf();

    if(!ImpersonateAnonymousToken( GetCurrentThread() ))
    {
        return STATUS_CANNOT_IMPERSONATE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MspAddBackslashesComputerName(
    IN PUNICODE_STRING ComputerName,
    OUT PUNICODE_STRING UncComputerName
    )

/*++

Routine Description:

    This function makes a copy of a Computer Name, prepending backslashes
    if they are not already present.

Arguments:

    ComputerName - Pointer to Computer Name without backslashes.

    UncComputerName - Pointer to Unicode String structure that will be
        initialized to reference the computerName with backslashes
        prepended if not already present.  The Unicode Buffer will be
        terminated with a Unicode NULL, so that it can be passed as
        a parameter to routines expecting a null terminated Wide String.
        When this string is finished with, the caller must free its
        memory via RtlFreeHeap.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN HasBackslashes = FALSE;
    BOOLEAN IsNullTerminated = FALSE;
    USHORT OutputNameLength;
    USHORT OutputNameMaximumLength;
    PWSTR StartBuffer = NULL;

    //
    // If the computername is NULL, a zero length string, or the name already begins with
    // backslashes and is wide char null terminated, just use it unmodified.
    //

    if( (!ARGUMENT_PRESENT(ComputerName)) || ComputerName->Length == 0 ) {
        UncComputerName->Buffer = NULL;
        UncComputerName->Length = 0;
        UncComputerName->MaximumLength = 0;
        goto AddBackslashesComputerNameFinish;
    }

    //
    // Name is not NULL or zero length.  Check if name already has
    // backslashes and a trailing Unicode Null
    //

    OutputNameLength = ComputerName->Length + (2 * sizeof(WCHAR));
    OutputNameMaximumLength = OutputNameLength + sizeof(WCHAR);

    if ((ComputerName && ComputerName->Length >= 2 * sizeof(WCHAR)) &&
        (ComputerName->Buffer[0] == L'\\') &&
        (ComputerName->Buffer[1] == L'\\')) {

        HasBackslashes = TRUE;
        OutputNameLength -= (2 * sizeof(WCHAR));
        OutputNameMaximumLength -= (2 * sizeof(WCHAR));
    }

    if ((ComputerName->Length + (USHORT) sizeof(WCHAR) <= ComputerName->MaximumLength) &&
        (ComputerName->Buffer[ComputerName->Length/sizeof(WCHAR)] == UNICODE_NULL)) {

        IsNullTerminated = TRUE;
    }

    if (HasBackslashes && IsNullTerminated) {

        *UncComputerName = *ComputerName;
        goto AddBackslashesComputerNameFinish;
    }

    //
    // Name either does not have backslashes or is not NULL terminated.
    // Make a copy with leading backslashes and a wide NULL terminator.
    //

    UncComputerName->Length = OutputNameLength;
    UncComputerName->MaximumLength = OutputNameMaximumLength;

    UncComputerName->Buffer = I_NtLmAllocate(
                                 OutputNameMaximumLength
                                 );

    if (UncComputerName->Buffer == NULL) {

        KdPrint(("MspAddBackslashes...: Out of memory copying ComputerName.\n"));
        Status = STATUS_NO_MEMORY;
        goto AddBackslashesComputerNameError;
    }

    StartBuffer = UncComputerName->Buffer;

    if (!HasBackslashes) {

        UncComputerName->Buffer[0] = UncComputerName->Buffer[1] = L'\\';
        StartBuffer +=2;
    }

    RtlCopyMemory(
        StartBuffer,
        ComputerName->Buffer,
        ComputerName->Length
        );

    UncComputerName->Buffer[UncComputerName->Length / sizeof(WCHAR)] = UNICODE_NULL;

AddBackslashesComputerNameFinish:

    return(Status);

AddBackslashesComputerNameError:

    goto AddBackslashesComputerNameFinish;
}

#ifndef DONT_LOG_PASSWORD_CHANGES
#include <stdio.h>
HANDLE MsvPaswdLogFile = NULL;
#define MSVPASWD_LOGNAME L"\\debug\\PASSWD.LOG"
#define MSVPASWD_BAKNAME L"\\debug\\PASSWD.BAK"

ULONG
MsvPaswdInitializeLog(
    VOID
    )
/*++

Routine Description:

    Initializes the debugging log file used by DCPROMO and the dssetup apis

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG dwErr = ERROR_SUCCESS;
    WCHAR LogFileName[ MAX_PATH + 1 ], BakFileName[ MAX_PATH + 1 ];


    if ( !GetWindowsDirectoryW( LogFileName,
                                sizeof( LogFileName )/sizeof( WCHAR ) ) ) {

        dwErr = GetLastError();
    } else {

        wcscpy( BakFileName, LogFileName );
        wcscat( LogFileName, MSVPASWD_LOGNAME );
        wcscat( BakFileName, MSVPASWD_BAKNAME );

        //
        // Copy the existing (maybe) log file to a backup
        //
    //if ( CopyFile( LogFileName, BakFileName, FALSE ) == FALSE ) {
    //
    // }


        MsvPaswdLogFile = CreateFileW( LogFileName,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,
                                      CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL );

        if ( MsvPaswdLogFile == INVALID_HANDLE_VALUE ) {

            dwErr = GetLastError();

            MsvPaswdLogFile = NULL;

        } else {

            if( SetFilePointer( MsvPaswdLogFile,
                                0, 0,
                                FILE_END ) == 0xFFFFFFFF ) {

                dwErr = GetLastError();

                CloseHandle( MsvPaswdLogFile );
                MsvPaswdLogFile = NULL;
            }
        }
    }

    return( dwErr );
}

ULONG
MsvPaswdCloseLog(
    VOID
    )
/*++

Routine Description:

    Closes the debugging log file used by DCPROMO and the dssetup apis

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG dwErr = ERROR_SUCCESS;

    if ( MsvPaswdLogFile != NULL ) {

        CloseHandle( MsvPaswdLogFile );
        MsvPaswdLogFile = NULL;
    }

    return( dwErr );
}

//
// Stolen and hacked up from netlogon code
//

VOID
MsvPaswdDebugDumpRoutine(
    IN LPSTR Format,
    va_list arglist
    )
{
    char OutputBuffer[2049];
    ULONG length;
    ULONG BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;
    int cbUsed = 0;

    //
    // If we don't have an open log file, just bail
    //
    if ( MsvPaswdLogFile == NULL ) {

        return;
    }

    length = 0;
    OutputBuffer[sizeof(OutputBuffer) - 1] = '\0';

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If we're writing to the debug terminal,
        //  indicate this is a Netlogon message.
        //

        //
        // Put the timestamp at the begining of the line.
        //

        GetLocalTime( &SystemTime );
        length += (ULONG) sprintf( &OutputBuffer[length],
                                   "%02u/%02u %02u:%02u:%02u ",
                                   SystemTime.wMonth,
                                   SystemTime.wDay,
                                   SystemTime.wHour,
                                   SystemTime.wMinute,
                                   SystemTime.wSecond );
    }

    //
    // Put a the information requested by the caller onto the line
    //
    // save two chars of spaces for the EOLs
    //
    cbUsed = (ULONG) _vsnprintf(&OutputBuffer[length], sizeof(OutputBuffer) - length - 1 - 2, Format, arglist);

    if (cbUsed >= 0)
    {
        length += cbUsed;
    }

    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {

        OutputBuffer[length-1] = '\r';
        OutputBuffer[length] = '\n';
        OutputBuffer[length+1] = '\0';
        length++;
    }

    ASSERT( length <= sizeof( OutputBuffer ) / sizeof( CHAR ) );


    //
    // Write the debug info to the log file.
    //
    if ( !WriteFile( MsvPaswdLogFile,
                     OutputBuffer,
                     length,
                     &BytesWritten,
                     NULL ) ) {
    }
}

VOID
MsvPaswdLogPrintRoutine(
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    va_start(arglist, Format);

    MsvPaswdDebugDumpRoutine( Format, arglist );

    va_end(arglist);
}

ULONG
MsvPaswdSetAndClearLog(
    VOID
    )
/*++

Routine Description:

    Flushes the log and seeks to the end of the file

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG dwErr = ERROR_SUCCESS;
    if ( MsvPaswdLogFile != NULL ) {

        if( FlushFileBuffers( MsvPaswdLogFile ) == FALSE ) {

            dwErr = GetLastError();
        }
    }

    return( dwErr );

}

#endif // DONT_LOG_PASSWORD_CHANGES


NTSTATUS
MspChangePasswordSam(
    IN PUNICODE_STRING UncComputerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN BOOLEAN Impersonating,
    OUT PDOMAIN_PASSWORD_INFORMATION *DomainPasswordInfo,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO *PrimaryDomainInfo OPTIONAL,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This routine is called by MspChangePassword to change the password
    on a Windows NT machine.

Arguments:

    UncComputerName - Name of the target machine.  This name must begin with
        two backslashes.

    UserName - Name of the user to change password for.

    OldPassword - Plaintext current password.

    NewPassword - Plaintext replacement password.

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    DomainPasswordInfo - Password restriction information (returned only if
        status is STATUS_PASSWORD_RESTRICTION).

    PrimaryDomainInfo - DomainNameInformation (returned only if status is
        STATUS_BACKUP_CONTROLLER).

    Authoritative - The failure was authoritative and no retries should be
        made.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    ...

--*/

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    LSA_HANDLE                  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES           LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    BOOLEAN                     ImpersonatingAnonymous = FALSE;
    BOOLEAN                     RetryAnonymous = FALSE;

    UNREFERENCED_PARAMETER(ClientRequest);

    //
    // Assume all failures are authoritative
    //

    *Authoritative = TRUE;

    //
    // If we're impersonating (ie, winlogon impersonated its caller before calling us),
    // impersonate again.  This allows us to get the name of the caller for auditing.
    //

    if ( Impersonating ) {

        Status = Lsa.ImpersonateClient();

    } else {
        UNICODE_STRING ComputerName;
        BOOLEAN AvoidAnonymous = FALSE;
        BOOLEAN LocalMachine = FALSE;

        //
        // Since the System context is a member of the Administrators alias,
        // when we connect with the local SAM we come in as an Administrator.
        // (When it's remote, we go over the null session and so have very
        // low access).  We don't want to be an Administrator because that
        // would allow the user to change the password on an account whose
        // ACL prohibits the user from changing the password.  So we'll
        // temporarily impersonate ourself and disable the Administrators
        // alias in the impersonation token.
        //


        //
        // find out if the referenced computer is the local machine.
        //

        ComputerName = *UncComputerName;

        if( ComputerName.Length > 4 &&
            ComputerName.Buffer[0] == L'\\' &&
            ComputerName.Buffer[1] == L'\\' )
        {
            ComputerName.Buffer += 2;
            ComputerName.Length -= 2 * sizeof(WCHAR);
        }

        if( NlpSamDomainName.Buffer )
        {
            LocalMachine = RtlEqualUnicodeString(
                                        &ComputerName,
                                        &NlpSamDomainName,
                                        TRUE
                                        );
        }

        if( !LocalMachine )
        {
            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            LocalMachine = RtlEqualUnicodeString(
                                        &ComputerName,
                                        &NtLmGlobalUnicodeComputerNameString,
                                        TRUE
                                        );

            RtlReleaseResource(&NtLmGlobalCritSect);
        }


        //
        // Don't impersonateAnonymous if BLANKPWD flag is set
        // AND the change is for the local machine.
        //

        if( (BOOLEAN) ((NtLmCheckProcessOption( MSV1_0_OPTION_ALLOW_BLANK_PASSWORD ) & MSV1_0_OPTION_ALLOW_BLANK_PASSWORD) != 0))
        {

            AvoidAnonymous = LocalMachine;
        }

        if( AvoidAnonymous )
        {
            Status = STATUS_SUCCESS;
            ImpersonatingAnonymous = FALSE;

            //
            // allow a retry as anonymous on failure.
            //

            RetryAnonymous = TRUE;

        } else {

            //
            // if the call is against the local machine, impersonate anonymous
            // otherwise, impersonate a crippled SYSTEM token, so the call
            // leaves the box as SYSTEM/machine creds.
            //


            if( !LocalMachine )
            {
                Status = MspDisableAdminsAlias ();
                RetryAnonymous = TRUE;
            } else {

                Status = MspImpersonateAnonymous();
            }

            ImpersonatingAnonymous = TRUE;
        }
    }

    if (!NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    try
    {
        Status = SamChangePasswordUser2(
                    UncComputerName,
                    UserName,
                    OldPassword,
                    NewPassword
                    );
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    MsvPaswdLogPrint(("SamChangePasswordUser2 on machine %wZ for user %wZ returned 0x%x\n",
        UncComputerName,
        UserName,
        Status
        ));

    if ( !NT_SUCCESS(Status) ) {

#ifdef COMPILED_BY_DEVELOPER
        KdPrint(("MspChangePasswordSam: SamChangePasswordUser2(%wZ) failed, status %x\n",
                 UncComputerName, Status));
#endif // COMPILED_BY_DEVELOPER

        //
        // If we failed to connect and we were impersonating a client
        // then we may want to try again using the NULL session.
        // Only try this if we found a server last try.  Otherwise,
        // we'll subject our user to another long timeout.
        //

        if (( Impersonating || RetryAnonymous ) &&
            ( Status != STATUS_WRONG_PASSWORD ) &&
            ( Status != STATUS_PASSWORD_RESTRICTION ) &&
            ( Status != STATUS_ACCOUNT_RESTRICTION ) &&
            ( Status != RPC_NT_SERVER_UNAVAILABLE) &&
            ( Status != STATUS_INVALID_DOMAIN_ROLE) ) {

            Status = MspImpersonateAnonymous();

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            ImpersonatingAnonymous = TRUE;

            Status = SamChangePasswordUser2(
                        UncComputerName,
                        UserName,
                        OldPassword,
                        NewPassword
                        );

            MsvPaswdLogPrint(("SamChangePasswordUser2 retry on machine %wZ for user %wZ returned 0x%x\n",
                UncComputerName,
                UserName,
                Status
                ));

#ifdef COMPILED_BY_DEVELOPER
            if ( !NT_SUCCESS(Status) ) {
                KdPrint(("MspChangePasswordSam: SamChangePasswordUser2(%wZ) (2nd attempt) failed, status %x\n",
                 UncComputerName, Status));
                }
#endif // COMPILED_BY_DEVELOPER
        }
    }

    //
    // if we are impersonating Anonymous, RevertToSelf, so the password policy
    // fetch attempt occurs using machine/system creds.
    //

    if( ImpersonatingAnonymous )
    {
        RevertToSelf();
    }

    if ( !NT_SUCCESS(Status) ) {

#ifdef COMPILED_BY_DEVELOPER
        KdPrint(("MspChangePasswordSam: Cannot change password for %wZ, status %x\n",
                 UserName, Status));
#endif // COMPILED_BY_DEVELOPER
        if (Status == RPC_NT_SERVER_UNAVAILABLE ||
            Status == RPC_S_SERVER_UNAVAILABLE ) {

            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        } else if (Status == STATUS_PASSWORD_RESTRICTION) {

            //
            // don't whack the original status code.
            //

            NTSTATUS TempStatus;

            //
            // Get the password restrictions for this domain and return them
            //

            //
            // Get the SID of the account domain from LSA
            //

            InitializeObjectAttributes( &LSAObjectAttributes,
                                          NULL,             // Name
                                          0,                // Attributes
                                          NULL,             // Root
                                          NULL );           // Security Descriptor

            TempStatus = LsaOpenPolicy( UncComputerName,
                                    &LSAObjectAttributes,
                                    POLICY_VIEW_LOCAL_INFORMATION,
                                    &LSAPolicyHandle );

            if( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: LsaOpenPolicy(%wZ) failed, status %x\n",
                         UncComputerName, TempStatus));
                LSAPolicyHandle = NULL;
                goto Cleanup;
            }

            TempStatus = LsaQueryInformationPolicy(
                            LSAPolicyHandle,
                            PolicyAccountDomainInformation,
                            (PVOID *) &AccountDomainInfo );

            if( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: LsaQueryInformationPolicy(%wZ) failed, status %x\n",
                         UncComputerName, TempStatus));
                AccountDomainInfo = NULL;
                goto Cleanup;
            }

            //
            // Setup ObjectAttributes for SamConnect call.
            //

            InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
            ObjectAttributes.SecurityQualityOfService = &SecurityQos;

            SecurityQos.Length = sizeof(SecurityQos);
            SecurityQos.ImpersonationLevel = SecurityIdentification;
            SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
            SecurityQos.EffectiveOnly = FALSE;

            TempStatus = SamConnect(
                         UncComputerName,
                         &SamHandle,
                         SAM_SERVER_LOOKUP_DOMAIN,
                         &ObjectAttributes
                         );

            if ( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: Cannot open sam on %wZ, status %x\n",
                         UncComputerName, TempStatus));
                DomainHandle = NULL;
                goto Cleanup;
            }

            //
            // Open the Account domain in SAM.
            //

            TempStatus = SamOpenDomain(
                         SamHandle,
                         DOMAIN_READ_PASSWORD_PARAMETERS,
                         AccountDomainInfo->DomainSid,
                         &DomainHandle
                         );

            if ( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: Cannot open domain on %wZ, status %x\n",
                         UncComputerName, TempStatus));
                DomainHandle = NULL;
                goto Cleanup;
            }

            TempStatus = SamQueryInformationDomain(
                            DomainHandle,
                            DomainPasswordInformation,
                            (PVOID *)DomainPasswordInfo );

            if (!NT_SUCCESS(TempStatus)) {
                KdPrint(("MspChangePasswordSam: Cannot queryinformationdomain on %wZ, status %x\n",
                         UncComputerName, TempStatus));
                *DomainPasswordInfo = NULL;
            } else {
                Status = STATUS_PASSWORD_RESTRICTION;
            }
        }

        goto Cleanup;
    }

Cleanup:

    //
    // If the only problem is that this is a BDC,
    //  Return the domain name back to the caller.
    //

    if ( (Status == STATUS_BACKUP_CONTROLLER ||
         Status == STATUS_INVALID_DOMAIN_ROLE) &&
         PrimaryDomainInfo != NULL ) {

        NTSTATUS TempStatus;

        //
        // Open the LSA if we haven't already.
        //

        if (LSAPolicyHandle == NULL) {

            InitializeObjectAttributes( &LSAObjectAttributes,
                                        NULL,             // Name
                                        0,                // Attributes
                                        NULL,             // Root
                                        NULL );           // Security Descriptor

            TempStatus = LsaOpenPolicy( UncComputerName,
                                        &LSAObjectAttributes,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &LSAPolicyHandle );

            if( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: LsaOpenPolicy(%wZ) failed, status %x\n",
                     UncComputerName, TempStatus));
                LSAPolicyHandle = NULL;
            }
        }

        if (LSAPolicyHandle != NULL) {
            TempStatus = LsaQueryInformationPolicy(
                            LSAPolicyHandle,
                            PolicyPrimaryDomainInformation,
                            (PVOID *) PrimaryDomainInfo );

            if( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: LsaQueryInformationPolicy(%wZ) failed, status %x\n",
                         UncComputerName, TempStatus));
                *PrimaryDomainInfo = NULL;
    #ifdef COMPILED_BY_DEVELOPER
            } else {
                KdPrint(("MspChangePasswordSam: %wZ is really a BDC in domain %wZ\n",
                         UncComputerName, &(*PrimaryDomainInfo)->Name));
    #endif // COMPILED_BY_DEVELOPER
            }
        }

        Status = STATUS_BACKUP_CONTROLLER;
    }

    //
    // Check for non-authoritative failures
    //

    if (( Status != STATUS_ACCESS_DENIED) &&
        ( Status != STATUS_WRONG_PASSWORD ) &&
        ( Status != STATUS_NO_SUCH_USER ) &&
        ( Status != STATUS_PASSWORD_RESTRICTION ) &&
        ( Status != STATUS_ACCOUNT_RESTRICTION ) &&
        ( Status != STATUS_INVALID_DOMAIN_ROLE ) &&
        ( Status != STATUS_ACCOUNT_LOCKED_OUT ) ) {
        *Authoritative = FALSE;
    }

    //
    // Stop impersonating.
    //

    RevertToSelf();

    //
    // Free Locally used resources
    //

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    if ( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    if ( AccountDomainInfo != NULL ) {
        (VOID) LsaFreeMemory( AccountDomainInfo );
    }

    return Status;
}


NTSTATUS
MspChangePasswordDownlevel(
    IN PUNICODE_STRING UncComputerName,
    IN PUNICODE_STRING UserNameU,
    IN PUNICODE_STRING OldPasswordU,
    IN PUNICODE_STRING NewPasswordU,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This routine is called by MspChangePassword to change the password
    on an OS/2 User-level server.  First we try sending an encrypted
    request to the server, failing that we fall back on plaintext.

Arguments:

    UncComputerName - Pointer to Unicode String containing the Name of the
        target machine.  This name must begin with two backslashes and
        must be null terminated.

    UserNameU    - Name of the user to change password for.

    OldPasswordU - Plaintext current password.

    NewPasswordU - Plaintext replacement password.

    Authoritative - If the attempt failed with an error that would
        otherwise cause the password attempt to fail, this flag, if false,
        indicates that the error was not authoritative and the attempt
        should proceed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    NTSTATUS         Status;
    NET_API_STATUS   NetStatus;
    DWORD            Length;
    LPWSTR           UserName = NULL;
    LPWSTR           OldPassword = NULL;
    LPWSTR           NewPassword = NULL;

    *Authoritative = TRUE;

    //
    // Convert UserName from UNICODE_STRING to null-terminated wide string
    // for use by RxNetUserPasswordSet.
    //

    Length = UserNameU->Length;

    UserName = I_NtLmAllocate(
                   Length + sizeof(TCHAR)
                   );

    if ( NULL == UserName ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( UserName, UserNameU->Buffer, Length );

    UserName[ Length / sizeof(TCHAR) ] = 0;

    //
    // Convert OldPassword from UNICODE_STRING to null-terminated wide string.
    //

    Length = OldPasswordU->Length;

    OldPassword = I_NtLmAllocate( Length + sizeof(TCHAR) );

    if ( NULL == OldPassword ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( OldPassword, OldPasswordU->Buffer, Length );

    OldPassword[ Length / sizeof(TCHAR) ] = 0;

    //
    // Convert NewPassword from UNICODE_STRING to null-terminated wide string.
    //

    Length = NewPasswordU->Length;

    NewPassword = I_NtLmAllocate( Length + sizeof(TCHAR) );

    if ( NULL == NewPassword ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( NewPassword, NewPasswordU->Buffer, Length );

    NewPassword[ Length / sizeof(TCHAR) ] = 0;

#ifdef COMPILED_BY_DEVELOPER

    KdPrint(("MSV1_0: Changing password on downlevel server:\n"
        "\tUncComputerName: %wZ\n"
        "\tUserName:     %ws\n"
        "\tOldPassword:  %ws\n"
        "\tNewPassword:  %ws\n",
        UncComputerName,
        UserName,
        OldPassword,
        NewPassword
        ));

#endif // COMPILED_BY_DEVELOPER

    //
    // Attempt to change password on downlevel server.
    //

    NetStatus = RxNetUserPasswordSet(
                    UncComputerName->Buffer,
                    UserName,
                    OldPassword,
                    NewPassword);

    MsvPaswdLogPrint(("RxNetUserPasswordSet on machine %ws for user %ws returned 0x%x\n",
        UncComputerName->Buffer,
        UserName,
        NetStatus
        ));

#ifdef COMPILED_BY_DEVELOPER
    KdPrint(("MSV1_0: RxNUserPasswordSet returns %d.\n", NetStatus));
#endif // COMPILED_BY_DEVELOPER

    // Since we overload the computername as the domain name,
    // map NERR_InvalidComputer to STATUS_NO_SUCH_DOMAIN, since
    // that will give the user a nice error message.
    //
    // ERROR_PATH_NOT_FOUND is returned on a standalone workstation that
    //  doesn't have the network installed.
    //

    if (NetStatus == NERR_InvalidComputer ||
        NetStatus == ERROR_PATH_NOT_FOUND) {

        Status = STATUS_NO_SUCH_DOMAIN;

    // ERROR_SEM_TIMEOUT can be returned when the computer name doesn't
    //  exist.
    //
    // ERROR_REM_NOT_LIST can also be returned when the computer name
    //  doesn't exist.
    //

    } else if ( NetStatus == ERROR_SEM_TIMEOUT ||
                NetStatus == ERROR_REM_NOT_LIST) {

        Status = STATUS_BAD_NETWORK_PATH;

    } else if ( (NetStatus == ERROR_INVALID_PARAMETER) &&
                ((wcslen(NewPassword) > LM20_PWLEN) ||
                 (wcslen(OldPassword) > LM20_PWLEN)) ) {

        //
        // The net api returns ERROR_INVALID_PARAMETER if the password
        // could not be converted to the LM OWF password.  Return
        // STATUS_PASSWORD_RESTRICTION for this.
        //

        Status = STATUS_PASSWORD_RESTRICTION;

        //
        // We never made it to the other machine, so we should continue
        // trying to change the password.
        //

        *Authoritative = FALSE;
    } else {
        Status = NetpApiStatusToNtStatus( NetStatus );
    }

Cleanup:

    //
    // Free UserName if used.
    //

    if (UserName) {

        I_NtLmFree(UserName);
    }

    //
    // Free OldPassword if used. (Don't let password make it to page file)
    //

    if (OldPassword) {
        RtlZeroMemory( OldPassword, wcslen(OldPassword) * sizeof(WCHAR) );
        I_NtLmFree(OldPassword);
    }

    //
    // Free NewPassword if used. (Don't let password make it to page file)
    //

    if (NewPassword) {
        RtlZeroMemory( NewPassword, wcslen(NewPassword) * sizeof(WCHAR) );
        I_NtLmFree(NewPassword);
    }

    return Status;
}

NTSTATUS
MspChangePassword(
    IN OUT PUNICODE_STRING ComputerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN BOOLEAN Impersonating,
    OUT PDOMAIN_PASSWORD_INFORMATION *DomainPasswordInfo,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO *PrimaryDomainInfo OPTIONAL,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This routine is called by MspLM20ChangePassword to change the password
    on the specified server.  The server may be either NT or Downlevel.

Arguments:

    ComputerName - Name of the target machine.  This name may or may not
        begin with two backslashes.

    UserName - Name of the user to change password for.

    OldPassword - Plaintext current password.

    NewPassword - Plaintext replacement password.

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    DomainPasswordInfo - Password restriction information (returned only if
        status is STATUS_PASSWORD_RESTRICTION).

    PrimaryDomainInfo - DomainNameInformation (returned only if status is
        STATUS_BACKUP_CONTROLLER).

    Authoritative - Indicates that the error code is authoritative
        and it indicates that password changing should stop. If false,
        password changing should continue.


Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_PASSWORD_RESTRICTION - Password changing is restricted.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UncComputerName;

    *Authoritative = TRUE;

    //
    // Ensure the server name is a UNC server name.
    //

    Status = MspAddBackslashesComputerName( ComputerName, &UncComputerName );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("MspChangePassword: MspAddBackslashes..(%wZ) failed, status %x\n",
                 ComputerName, Status));
        return(Status);
    }

    //
    // Assume the Server is an NT server and try to change the password.
    //

    Status = MspChangePasswordSam(
                 &UncComputerName,
                 UserName,
                 OldPassword,
                 NewPassword,
                 ClientRequest,
                 Impersonating,
                 DomainPasswordInfo,
                 PrimaryDomainInfo,
                 Authoritative );

    //
    // If MspChangePasswordSam returns anything other than
    // STATUS_CANT_ACCESS_DOMAIN_INFO, it was able to connect
    // to the remote computer so we won't try downlevel.
    //

    if (Status == STATUS_CANT_ACCESS_DOMAIN_INFO) {
        NET_API_STATUS NetStatus;
        DWORD OptionsSupported;

        //
        // only if target machine doesn't support SAM protocol do we attempt
        // downlevel.
        // MspAddBackslashesComputerName() NULL terminates the buffer.
        //

        NetStatus = NetRemoteComputerSupports(
                     (LPWSTR)UncComputerName.Buffer,
                     SUPPORTS_RPC | SUPPORTS_LOCAL | SUPPORTS_SAM_PROTOCOL,
                     &OptionsSupported
                     );

        if ( NetStatus == NERR_Success && !(OptionsSupported & SUPPORTS_SAM_PROTOCOL) ) {

            Status = MspChangePasswordDownlevel(
                        &UncComputerName,
                        UserName,
                        OldPassword,
                        NewPassword,
                        Authoritative );
        }
    }

    //
    // Free UncComputerName.Buffer if different from ComputerName.
    //

    if ( UncComputerName.Buffer != ComputerName->Buffer ) {
        I_NtLmFree(UncComputerName.Buffer);
    }

    return(Status);
}

//
// the following structures are used to map win32 errors to NTSTATUS
//

typedef LONG (WINAPI * I_RPCMAPWIN32STATUS)(
    IN ULONG Win32Status
    );

typedef struct _STATUS_MAPPING {
    DWORD Error;
    NTSTATUS NtStatus;
} STATUS_MAPPING;

NTSTATUS
MspMapNtdsApiError(
    IN DWORD DsStatus,
    IN NTSTATUS DefaultStatus
    )
/*++

Routine Description:

    This routine maps DS API error codes to appropriate NTSTATUS codes
    
Arguments:

    DsStatus - Status code from DS APIs
    
    DefaultStatus - Default status code if no other code is found
    
Return Value:

    NtStatus code
--*/
{
    NTSTATUS Status = DsStatus;

    I_RPCMAPWIN32STATUS pFuncI_RpcMapWin32Status = NULL;
    HMODULE hLib = NULL;

    static const STATUS_MAPPING StatusMap[] = {
        {ERROR_NO_SUCH_DOMAIN, STATUS_NO_SUCH_DOMAIN},
        {ERROR_INVALID_DOMAINNAME, STATUS_INVALID_PARAMETER},
        {DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING, STATUS_NO_SUCH_USER},
        {ERROR_BUFFER_OVERFLOW, STATUS_BUFFER_TOO_SMALL}
    };

    if (SUCCEEDED(Status)) 
    {
        int i;

        //
        // handle expected win32 errors
        //

        for (i = 0; i < RTL_NUMBER_OF(StatusMap); i++) 
        {
            if (StatusMap[i].Error == (DWORD) Status) 
            {
                return (StatusMap[i].NtStatus);
            }
        }

        //
        //  handle RPC status
        //

        hLib = LoadLibraryW(L"rpcrt4.dll");
                
        if (hLib) 
        {
            pFuncI_RpcMapWin32Status = (I_RPCMAPWIN32STATUS) GetProcAddress( hLib, "I_RpcMapWin32Status" );           
            if (pFuncI_RpcMapWin32Status) 
            {            
                Status = pFuncI_RpcMapWin32Status(Status); 
            }

            FreeLibrary(hLib);
        } 
    }

    //
    // not mapped? use default status
    //

    if (NT_SUCCESS(Status) || (Status == STATUS_UNSUCCESSFUL)) 
    {
        Status = DefaultStatus;
    }

    return Status;
}

NTSTATUS
MspImpersonateNetworkService(
    VOID
    )
/*++

Routine Description:

    This routine impersonates network servcie.
    
Arguments:

    None
        
Return Value:

    NtStatus code
--*/
{
    NTSTATUS Status;

    HANDLE TokenHandle = NULL;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

    Status = LsaFunctions->OpenTokenByLogonId(&NetworkServiceLuid, &TokenHandle);

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                &TokenHandle,
                sizeof(TokenHandle) 
                );

    if (!NT_SUCCESS( Status)) 
    {
        goto Cleanup;
    }

Cleanup:

    if (TokenHandle) 
    {
        NtClose(TokenHandle);
    }

    return Status;
}

BOOL
MspIsRpcServerUnavailableError(
    IN DWORD Error
    )
/*++

Routine Description:

    This routine determines if an error code means the server is not available.
    
Arguments:

    Error - An RPC status code or Win32 error code
        
Return Value:

    True if the error code means the server is not avaiable and false otherwise
--*/
{
    // This list of error codes blessed by MazharM on 4/20/99.

    switch ( Error )
    {
    case RPC_S_SERVER_UNAVAILABLE:      // can't get there from here
    case EPT_S_NOT_REGISTERED:          // demoted or in DS repair mode
    case RPC_S_UNKNOWN_IF:              // demoted or in DS repair mode
    case RPC_S_INTERFACE_NOT_FOUND:     // demoted or in DS repair mode
    case RPC_S_COMM_FAILURE:            // can't get there from here
        return (TRUE);
    }

    return (FALSE);
}

NTSTATUS 
MspConstructSPN( 
    IN PCWSTR DomainControllerName,
    IN PCWSTR DnsDomainName, 
    OUT PWSTR * Spn 
    )
/*++

Routine Description:

    This routine constructs a SPN with the "@domainName" suffix. The suffix 
    serves as a hint for kerberos.
    
Arguments:

    DomainControllerName - Name of the domain controller
    
    DnsDomainName - DNS domain name
    
    Spn - Receives SPN for the domain controller at DNS domain name
        
Return Value:

    NTSTATUS code 
--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    DWORD Error = ERROR_SUCCESS;
    DWORD CharCount = 0; 
    DWORD TotalCharCount = 0;
    PCWSTR ServiceName = NULL; 
    PCWSTR InstanceName = NULL;
    PCWSTR SvcClass = L"ldap";

    //
    // the following temporary structures need to be free'ed
    //

    PWSTR TmpSpn = NULL;
    PWSTR TmpService = NULL;
    PWSTR TmpInstance = NULL;

    if (!DomainControllerName) 
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    
    if ( DnsDomainName )
    {
        // Caller gave all components needed to construct full 3-part SPN.
        InstanceName = DomainControllerName;
        ServiceName = DnsDomainName;
    }
    else 
    {
        // Construct SPN of form: LDAP/ntdsdc4.ntdev.microsoft.com
        InstanceName = DomainControllerName;
        ServiceName = DomainControllerName;
    }

    //
    // Skip past leading "\\" if present.  This is not circumventing
    // a client who has passed NetBIOS names mistakenly but rather
    // helping the client which has passed args as returned by
    // DsGetDcName which prepends "\\" even when DS_RETURN_DNS_NAME
    // was requested.
    //

    if (0 == wcsncmp(InstanceName, L"\\\\", 2)) 
    {
        InstanceName += 2;
    }

    if (0 == wcsncmp(ServiceName, L"\\\\", 2)) 
    {        
        ServiceName += 2;
    }

    //
    // Strip trailing '.' if it exists.  We do this as we know the server side 
    // registers dot-less names only.  We can't whack in place as the input 
    // args are const.
    //

    CharCount = (ULONG) wcslen(InstanceName);
    if ( L'.' == InstanceName[CharCount - 1] )
    {
        TmpInstance = (WCHAR *) NtLmAllocatePrivateHeap(CharCount * sizeof(WCHAR));
        if (!TmpInstance) 
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlCopyMemory(TmpInstance, InstanceName, (CharCount - 1) * sizeof(WCHAR));
        TmpInstance[CharCount - 1] = L'\0';
        InstanceName = TmpInstance;
    }

    CharCount = (ULONG) wcslen(ServiceName);
    if ( L'.' == ServiceName[CharCount - 1] )
    {
        TmpService = (WCHAR *) NtLmAllocatePrivateHeap(CharCount * sizeof(WCHAR));
        if (!TmpService) 
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlCopyMemory(TmpService, ServiceName, (CharCount - 1) * sizeof(WCHAR));
        TmpService[CharCount - 1] = L'\0';
        ServiceName = TmpService;
    }

    CharCount = 0;

    Error = DsMakeSpnW(SvcClass, ServiceName, InstanceName, 0,
                       NULL, &CharCount, NULL);

    if ( Error != ERROR_SUCCESS && (ERROR_BUFFER_OVERFLOW != Error) )
    {
        Status = MspMapNtdsApiError(Error, STATUS_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (DnsDomainName) 
    {
        TotalCharCount = CharCount + 1 + (ULONG) wcslen(ServiceName); // 1 char for @ sign
    }
    else
    {
        TotalCharCount = CharCount; 
    }

    TmpSpn = (WCHAR *) NtLmAllocatePrivateHeap(sizeof(WCHAR) * TotalCharCount);
    if ( !TmpSpn )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Error = DsMakeSpnW(SvcClass, ServiceName, InstanceName, 0,
                       NULL, &CharCount, TmpSpn);

    if ( Error != ERROR_SUCCESS)
    {
        Status = MspMapNtdsApiError(Error, STATUS_INVALID_PARAMETER);
        goto Cleanup;
    }
          
    if (DnsDomainName && (CharCount < TotalCharCount))
    {
        wcsncat(TmpSpn, L"@", TotalCharCount - CharCount);
        wcsncat(TmpSpn, ServiceName, TotalCharCount - CharCount - 1); 
    }

    Status = STATUS_SUCCESS;
    *Spn = TmpSpn;
    TmpSpn = NULL; // do not free it

Cleanup:

    if (TmpInstance) 
    {
        NtLmFreePrivateHeap(TmpInstance);
    }

    if (TmpService) 
    {
        NtLmFreePrivateHeap(TmpService);
    }

    if (TmpSpn) {

        NtLmFreePrivateHeap(TmpSpn);
    }

    return Status;
}

//
// maximum number of DC force rediscovery retries for cracking UPNs in changepassword
//

#define MAX_DC_REDISCOVERY_RETRIES     2

//
// determine if it is an authentication error, here I leverage two CREDUI macros
//
// ISSUE: Is downgrade error fatal? (CREDUI_IS_AUTHENTICATION_ERROR includes
//        downgrade errors)
//

#define IS_BAD_CREDENTIALS_ERROR(x)   (CREDUI_NO_PROMPT_AUTHENTICATION_ERROR((x)) \
                                        || CREDUI_IS_AUTHENTICATION_ERROR((x)))

NTSTATUS
MspLm20ChangePassword (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0ChangePassword.  This routine changes an
    account's password by either calling SamXxxPassword (for NT domains) or
    RxNetUserPasswordSet (for downlevel domains and standalone servers).

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_PASSWORD_RESTRICTION - The password change failed because the
        - password doesn't meet one or more domain restrictions.  The
        - response buffer is allocated.  If the PasswordInfoValid flag is
        - set it contains valid information otherwise it contains no
        - information because this was a down-level change.

    STATUS_BACKUP_CONTROLLER - The named machine is a Backup Domain Controller.
        Changing password is only allowed on the Primary Domain Controller.

--*/

{
    PMSV1_0_CHANGEPASSWORD_REQUEST ChangePasswordRequest = NULL;
    PMSV1_0_CHANGEPASSWORD_RESPONSE ChangePasswordResponse;
    NTSTATUS        Status = STATUS_SUCCESS;
    NTSTATUS        SavedStatus = STATUS_SUCCESS;
    LPWSTR          DomainName = NULL;
    PDOMAIN_CONTROLLER_INFO DCInfo = NULL;
    UNICODE_STRING  DCNameString;
    UNICODE_STRING  ClientNetbiosDomain = {0};
    PUNICODE_STRING  ClientDsGetDcDomain;
    UNICODE_STRING  ClientDnsDomain = {0};
    UNICODE_STRING  ClientUpn = {0};
    UNICODE_STRING  ClientName = {0};
    UNICODE_STRING  ValidatedAccountName;
    UNICODE_STRING  ValidatedDomainName;
    LPWSTR          ValidatedOldPasswordBuffer;
    LPWSTR          ValidatedNewPasswordBuffer;
    NET_API_STATUS  NetStatus;
    PPOLICY_LSA_SERVER_ROLE_INFO PolicyLsaServerRoleInfo = NULL;
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;
    PWKSTA_INFO_100 WkstaInfo100 = NULL;
    BOOLEAN PasswordBufferValidated = FALSE;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    PDS_NAME_RESULTW NameResult = NULL;
    HANDLE DsHandle = NULL;
    PWSTR SpnForDC = NULL;
    UCHAR Seed;
    BOOLEAN Authoritative = TRUE;
    BOOLEAN AttemptRediscovery = FALSE;
    BOOLEAN Validated = TRUE;

#if _WIN64
    PVOID pTempSubmitBuffer = ProtocolSubmitBuffer;
    SECPKG_CALL_INFO  CallInfo;
    BOOL  fAllocatedSubmitBuffer = FALSE;
#endif

    RtlInitUnicodeString(
        &DCNameString,
        NULL
        );
    //
    // Sanity checks.
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

#if _WIN64

    //
    // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
    // call came from a WOW client.
    //

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = MsvConvertWOWChangePasswordBuffer(ProtocolSubmitBuffer,
                                                   ClientBufferBase,
                                                   &SubmitBufferSize,
                                                   &pTempSubmitBuffer);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        fAllocatedSubmitBuffer = TRUE;

        //
        // Some macros below expand out to use ProtocolSubmitBuffer directly.
        // We've secretly replaced their usual ProtocolSubmitBuffer with
        // pTempSubmitBuffer -- let's see if they can tell the difference.
        //

        ProtocolSubmitBuffer = pTempSubmitBuffer;
    }

#endif  // _WIN64

    if ( SubmitBufferSize < sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChangePasswordRequest = (PMSV1_0_CHANGEPASSWORD_REQUEST) ProtocolSubmitBuffer;

    ASSERT( ChangePasswordRequest->MessageType == MsV1_0ChangePassword ||
            ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword );

    RELOCATE_ONE( &ChangePasswordRequest->DomainName );

    RELOCATE_ONE( &ChangePasswordRequest->AccountName );

    if ( ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword ) {
        NULL_RELOCATE_ONE( &ChangePasswordRequest->OldPassword );
    } else {
        RELOCATE_ONE_ENCODED( &ChangePasswordRequest->OldPassword );
    }

    RELOCATE_ONE_ENCODED( &ChangePasswordRequest->NewPassword );

    //
    // save away copies of validated buffers to check later.
    //

    RtlCopyMemory( &ValidatedDomainName, &ChangePasswordRequest->DomainName, sizeof(ValidatedDomainName) );
    RtlCopyMemory( &ValidatedAccountName, &ChangePasswordRequest->AccountName, sizeof(ValidatedAccountName) );

    ValidatedOldPasswordBuffer = ChangePasswordRequest->OldPassword.Buffer;
    ValidatedNewPasswordBuffer = ChangePasswordRequest->NewPassword.Buffer;


    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->OldPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->OldPassword
                );

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->NewPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        if ( ChangePasswordRequest->NewPassword.Buffer !=
            ValidatedNewPasswordBuffer ) {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->NewPassword
                );

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    //
    // sanity check that we didn't whack over buffers.
    //

    if (!RtlCompareMemory(
                        &ValidatedDomainName,
                        &ChangePasswordRequest->DomainName,
                        sizeof(ValidatedDomainName)
                        )
                        ||
        !RtlCompareMemory(
                        &ValidatedAccountName,
                        &ChangePasswordRequest->AccountName,
                        sizeof(ValidatedAccountName)
                        )
                        ||
        (ValidatedOldPasswordBuffer != ChangePasswordRequest->OldPassword.Buffer)
                        ||
        (ValidatedNewPasswordBuffer != ChangePasswordRequest->NewPassword.Buffer)
                        ) {

            Status= STATUS_INVALID_PARAMETER;
            goto Cleanup;
    }

    //
    // validate domain name and account name. Account name allows UPN
    //

    if ( (ChangePasswordRequest->DomainName.Length / sizeof(WCHAR) > DNS_MAX_NAME_LENGTH)
        || (ChangePasswordRequest->AccountName.Length / sizeof(WCHAR) > (UNLEN + 1 + DNS_MAX_NAME_LENGTH)) )
    {
        SspPrint((SSP_CRITICAL, "MspLm20ChangePassword invalid parameter: DomainName.Length %#x, AccountName.Length %#x\n",
            ChangePasswordRequest->DomainName.Length, ChangePasswordRequest->AccountName.Length));
    
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *ReturnBufferSize = 0;
    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_PENDING;
    PasswordBufferValidated = TRUE;

    MsvPaswdLogPrint(("Attempting password change server/domain %wZ for user %wZ\n",
        &ChangePasswordRequest->DomainName,
        &ChangePasswordRequest->AccountName
        ));

#ifdef COMPILED_BY_DEVELOPER

    KdPrint(("MSV1_0:\n"
             "\tDomain:\t%wZ\n"
             "\tAccount:\t%wZ\n"
             "\tOldPassword(%d)\n"
             "\tNewPassword(%d)\n",
             &ChangePasswordRequest->DomainName,
             &ChangePasswordRequest->AccountName,
             (int) ChangePasswordRequest->OldPassword.Length,
             (int) ChangePasswordRequest->NewPassword.Length
             ));

#endif // COMPILED_BY_DEVELOPER

    SspPrint((SSP_UPDATES, "MspLm20ChangePassword %wZ\\%wZ, message type %#x%s, impersonating ? %s\n",
        &ChangePasswordRequest->DomainName,
        &ChangePasswordRequest->AccountName,
        ChangePasswordRequest->MessageType,
        (MsV1_0ChangeCachedPassword == ChangePasswordRequest->MessageType) ? " (cached)" : "",
        ChangePasswordRequest->Impersonating ? "true" : "false"));
    
    //
    // If the client supplied a non-nt4 name, go ahead and convert it here.
    //

    if (ChangePasswordRequest->DomainName.Length == 0) {

        DWORD DsStatus;

        HANDLE NullTokenHandle = NULL;
        
        WCHAR NameBuffer[UNLEN + 1];
        ULONG Index;  
        BOOLEAN useSimpleCrackName = FALSE;
        PWSTR DcName = NULL;
        PWSTR DomainName = NULL;
        DWORD DsGetDcNameFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME; 
        BOOLEAN StandaloneWorkstation = FALSE;

        DWORD DcRediscoveryRetries = 0;

        if (ChangePasswordRequest->AccountName.Length / sizeof(WCHAR) > UNLEN) {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        RtlCopyMemory(
            NameBuffer,
            ChangePasswordRequest->AccountName.Buffer,
            ChangePasswordRequest->AccountName.Length
            );
        NameBuffer[ChangePasswordRequest->AccountName.Length/sizeof(WCHAR)] = L'\0';
        RtlInitUnicodeString( &ClientUpn, NameBuffer );

        if ( NlpWorkstation ) {

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
            StandaloneWorkstation = (BOOLEAN) (NtLmGlobalTargetFlags == NTLMSSP_TARGET_TYPE_SERVER);
            RtlReleaseResource(&NtLmGlobalCritSect);
        }

        if (StandaloneWorkstation) {

            SspPrint(( SSP_WARNING, "MspLm20ChangePassword use simple crack for standalone machines\n" ));
            useSimpleCrackName = TRUE;
        }

        //
        // bind and crack names
        //
        // we allow the bind to fail on a member workstation, which allows 
        // us to attempt a 'manual' crack.
        //

        while (!useSimpleCrackName) {

            if (DcName == NULL) {
         
                if ( DCInfo != NULL ) {
                
                    NetApiBufferFree(DCInfo);
                    DCInfo = NULL;
                }

                SspPrint(( SSP_UPDATES, "MspLm20ChangePassword: DsGetDcNameW for %ws, DsGetDcNameFlags %#x\n", DomainName, DsGetDcNameFlags ));

                NetStatus = DsGetDcNameW(
                                NULL, // no computername
                                DomainName, 
                                NULL, // no domain guid
                                NULL, // no site name
                                DsGetDcNameFlags,                                 
                                &DCInfo 
                                );

                if (NetStatus == NERR_Success) {

                    DcName = DCInfo->DomainControllerName;
                } else {      
        
                    SspPrint(( SSP_WARNING, "MspLm20ChangePassword: did not find a DC for %ws, NetStatus %#x\n", DomainName, NetStatus ));

                    if (!DomainName && !NlpWorkstation) { // DC can not bind to local forest is fatal 

                        Status = NetpApiStatusToNtStatus(NetStatus); 

                        if ( Status == STATUS_INTERNAL_ERROR ) {

                            Status = STATUS_NO_SUCH_DOMAIN;
                        }
                        goto Cleanup;
                    }

                    useSimpleCrackName = TRUE;
                    
                    break;    
                } 
            }

            if (DsHandle) {
            
                DsUnBindW(
                  &DsHandle
                  );
                DsHandle = NULL;
            }

            if (SpnForDC) {

                NtLmFreePrivateHeap(SpnForDC);
                SpnForDC = NULL;
            }

            Status = MspConstructSPN(DcName, DomainName, &SpnForDC);

            if (!NT_SUCCESS(Status)) {
            
                goto Cleanup;
            }

            //
            // impersonate for DsBind:
            //
            //  1) use machine credentials first, this can fail for 
            //     workstations in resource domains with one way trust
            //  2) if machine credentials does not work, try to impersonate
            //     the client iff asked to do so
            // 
            // Notes:
            //
            // the client can have a wrong password that he/she is trying to 
            // change, this can happen when the workstation is unlocked with 
            // a new password and the unlock is validated by NTLM (which does 
            // not parse unlock logonId or update old logon session credentials 
            // at this point) or in most common cases, the password is either 
            // expired or must be changed at the next logon etc
            //

            Status = MspImpersonateNetworkService(); // note if we get here, the machine is always joined
    
            if (!NT_SUCCESS(Status)) {
    
                goto Cleanup;
            }

            SspPrint(( SSP_UPDATES, "MspLm20ChangePassword: binding to %ws with machine identity, spn %ws\n", DcName, SpnForDC ));

            DsStatus = DsBindWithSpnExW(
                           DcName, // DC name
                           DcName == NULL ?  DomainName : NULL,  // domain name
                           NULL, // no AuthIdentity
                           SpnForDC, // SPN
                           0,  // No delegation
                           &DsHandle 
                           );

            if ( IS_BAD_CREDENTIALS_ERROR(DsStatus) && ChangePasswordRequest->Impersonating ) {

                Status = LsaFunctions->ImpersonateClient(); 

                if (!NT_SUCCESS(Status)) {
                
                    NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &NullTokenHandle,
                        sizeof(NullTokenHandle) 
                        );

                    goto Cleanup;
                }

                SspPrint(( SSP_UPDATES, "MspLm20ChangePassword: dsbind failed with %#x, rebinding to %ws with client identity, spn %ws\n", DsStatus, DcName, SpnForDC ));

                DsStatus = DsBindWithSpnExW(
                               DcName, // DC name
                               DcName == NULL ?  DomainName : NULL,  // domain name
                               NULL, // no AuthIdentity
                               SpnForDC, // SPN
                               0,  // No delegation
                               &DsHandle 
                               );
            }

            //
            // always revert to self
            //

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &NullTokenHandle,
                        sizeof(NullTokenHandle) 
                        );

            if (!NT_SUCCESS(Status)) {
            
                goto Cleanup;
            }
        
            if (DsStatus != ERROR_SUCCESS) {
        
                SspPrint(( SSP_WARNING, "MspLm20ChangePassword: could not bind %#x\n", DsStatus ));

                if ( MspIsRpcServerUnavailableError(DsStatus) ) {
                
                    if ( DCInfo != NULL ) {

                        NetApiBufferFree(DCInfo);
                        DCInfo = NULL;
                    }

                    SspPrint(( SSP_UPDATES, "MspLm20ChangePassword: force re-dicover DCs for %ws, DsGetDcNameFlags %#x\n", DomainName, DsGetDcNameFlags | DS_FORCE_REDISCOVERY ));

                    NetStatus = DsGetDcNameW(
                                    NULL, // no computername
                                    DomainName, 
                                    NULL, // no domain guid
                                    NULL, // no site name
                                    DsGetDcNameFlags | DS_FORCE_REDISCOVERY, 
                                    &DCInfo 
                                    );

                    //
                    // try again if a different DC is found
                    //

                    if (NetStatus == NERR_Success ) {
                        
                        ASSERT(DcName != NULL);

                        if (_wcsicmp(DcName, DCInfo->DomainControllerName) != 0) {

                            if (++DcRediscoveryRetries <= MAX_DC_REDISCOVERY_RETRIES) {

                                DcName = DCInfo->DomainControllerName;
                                                         
                                continue; 
                            } else {

                                SspPrint(( SSP_WARNING, "MspLm20ChangePassword: exceeded retry limits %#x\n", DcRediscoveryRetries ));
                            }
                        }

                        //
                        // use simple crack if necessary
                        //
                    } else { // pick up the new error code if rediscovery fails, use simple crack if necessary

                        DsStatus = NetpApiStatusToNtStatus(NetStatus); 

                        if ( DsStatus == STATUS_INTERNAL_ERROR ) {

                            DsStatus = (DWORD) STATUS_NO_SUCH_DOMAIN;
                        }
                    }

                    SspPrint(( SSP_WARNING, "MspLm20ChangePassword: could not redicovery a DC %#x\n", NetStatus ));
                }
                
                if ( !DomainName && !NlpWorkstation ) { // DC can not bind to local forest is fatal 

                    SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsBindW returned 0x%lx.\n", DsStatus ));

                    Status = MspMapNtdsApiError( DsStatus, STATUS_NO_SUCH_DOMAIN );
   
                    goto Cleanup;
                }
        
                useSimpleCrackName = TRUE;

                break;       
            }

            if (NameResult) {

                DsFreeNameResult(NameResult);
                NameResult = NULL;
            }

            DsStatus = DsCrackNamesW(
                            DsHandle,
                            DomainName ? 0 : DS_NAME_FLAG_TRUST_REFERRAL, // do not follow referral in the remote forest 
                            DS_UNKNOWN_NAME,
                            DS_NT4_ACCOUNT_NAME,
                            1,
                            &ClientUpn.Buffer,
                            &NameResult
                            );
            if (DsStatus != ERROR_SUCCESS) {

                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsCrackNamesW returned 0x%lx.\n", DsStatus ));

                Status = MspMapNtdsApiError( DsStatus, STATUS_NO_SUCH_DOMAIN );

                goto Cleanup;
            }

            //
            // Look for the name in the result
            //

            if (NameResult->cItems != 1) {

                ASSERT(!"Not exactly one result returned, this can not happen");

                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsCrackNamesW returned not exactly 1 item\n" ));
                Status = STATUS_INTERNAL_ERROR;
                goto Cleanup;
            }

            //
            // if not cracked on DC, try GC if it is avaiable
            //

            if (NameResult->rItems[0].status == DS_NAME_ERROR_NOT_FOUND 
                || NameResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY) {

                if ( DCInfo != NULL ) {

                    if (DCInfo->Flags & DS_GC_FLAG) {

                        SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsCrackNamesW failed on GC %#x\n", NameResult->rItems[0].status ));

                        useSimpleCrackName = TRUE;  

                        break;
                    }

                    NetApiBufferFree(DCInfo);
                    DCInfo = NULL;
                }

                DsGetDcNameFlags |= DS_GC_SERVER_REQUIRED;
                NetStatus = DsGetDcNameW(
                                NULL, // no computername
                                DomainName, 
                                NULL, // no domain guid
                                NULL, // no site name
                                DsGetDcNameFlags,
                                &DCInfo 
                                );

                if (NetStatus == NERR_Success) {

                    DcName = DCInfo->DomainControllerName;

                    continue; // try to crack name again with GC
                } else {
        
                    SspPrint(( SSP_WARNING, "MspLm20ChangePassword: could not find GC %#x\n", NetStatus ));

                    useSimpleCrackName = TRUE;  // crack name fails, use manual crack
                    break;
                }        
            } else if (!DomainName && (NameResult->rItems[0].status == DS_NAME_ERROR_TRUST_REFERRAL)) { // follow referral only in the local forest
                        
                //
                // always try GC in the remote forest, this assumes there must 
                // be at lest one GC in a forest
                //

                DcName = NULL;
                DsGetDcNameFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_GC_SERVER_REQUIRED;
                DomainName = NameResult->rItems[0].pDomain;

                continue; // try again to follow the referral path

            } else if (NameResult->rItems[0].status != DS_NAME_NO_ERROR) {

                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsCrackNamesW failed %#x\n", NameResult->rItems[0].status ));

                useSimpleCrackName = TRUE;  // crack name fails, use manual crack
                break;
            }

            //
            // crack name succeeded, break out
            // 

            ASSERT(useSimpleCrackName == FALSE);

            break;
        }

        if (DsHandle != NULL) {
        
            DsUnBindW(
              &DsHandle
              );
            DsHandle = NULL;
        }
        
        if ( DCInfo != NULL ) {
        
            NetApiBufferFree(DCInfo);
            DCInfo = NULL;
        }

        if ( useSimpleCrackName ) { // crack name failed

            SspPrint(( SSP_WARNING, "MspLm20ChangePassword: using simple crack\n" ));

            //
            // The name wasn't mapped. Try converting it manually by
            // splitting it at the '@'
            //

            RtlInitUnicodeString(
                &ClientName,
                NameBuffer
                );

            // shortest possible is 3 Unicode chars (eg: a@a)
            if (ClientName.Length < (sizeof(WCHAR) * 3)) {

                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            for (Index = (ClientName.Length / sizeof(WCHAR)) - 1; Index != 0 ; Index-- ) {
                if (ClientName.Buffer[Index] == L'@') {

                    RtlInitUnicodeString(
                        &ClientDnsDomain,
                        &ClientName.Buffer[Index+1]
                        );

                    ClientName.Buffer[Index] = L'\0';
                    ClientName.Length = (USHORT) Index * sizeof(WCHAR);

                    break;
                }
            }

            //
            // If the name couldn't be parsed, give up and go home
            //

            if (ClientDnsDomain.Length == 0) {
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            //
            // This isn't really the Netbios Domain name, but it is the best we have.
            //

            ClientNetbiosDomain = ClientDnsDomain;

            for (Index = 0; Index < (ClientNetbiosDomain.Length / sizeof(WCHAR)) ; Index++ ) {

                //
                // truncate the netbios domain to the first DOT
                //

                if ( ClientNetbiosDomain.Buffer[Index] == L'.' ) {
                    ClientNetbiosDomain.Length = (USHORT)(Index * sizeof(WCHAR));
                    ClientNetbiosDomain.MaximumLength = ClientNetbiosDomain.Length;
                    break;
                }
            }
        }
        else // crack name succeeded, look for the cracked results
        {

            RtlInitUnicodeString(
                &ClientDnsDomain,
                NameResult->rItems[0].pDomain
                );
            RtlInitUnicodeString(
                &ClientName,
                NameResult->rItems[0].pName
                );
            RtlInitUnicodeString(
                &ClientNetbiosDomain,
                NameResult->rItems[0].pName
                );
            //
            // Move the pointer for the name up to the first "\" in the name
            //

            for (Index = 0; Index < ClientName.Length / sizeof(WCHAR) ; Index++ ) {
                if (ClientName.Buffer[Index] == L'\\') {
                    RtlInitUnicodeString(
                        &ClientName,
                        &ClientName.Buffer[Index+1]
                        );

                    // Set the Netbios Domain Name to the string to the left of the backslash
                    ClientNetbiosDomain.Length = (USHORT)(Index * sizeof(WCHAR));
                    break;
                }
            }
        }

        SspPrint(( SSP_UPDATES, "MspLm20ChangePassword: UPN cracked %wZ\\%wZ, %wZ\n", &ClientNetbiosDomain, &ClientName, &ClientDnsDomain ));

    } else {

        ClientName = ChangePasswordRequest->AccountName;
        ClientNetbiosDomain = ChangePasswordRequest->DomainName;
    }

    //
    // If we're just changing the cached password, skip changing the password 
    // on the domain.
    //

    if ( ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword ) {

        Status = STATUS_SUCCESS;
        Validated = FALSE;
        goto PasswordChangeSuccessfull;
    }

    // Make sure that NlpSamInitialized is TRUE. If we logon using
    // Kerberos, this may not be true.

    if ( !NlpSamInitialized)
    {
        Status = NlSamInitialize( SAM_STARTUP_TIME );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Check to see if the name provided is a domain name. If it has no
    // leading "\\" and does not match the name of the computer, it may be.
    //

    if ((( ClientNetbiosDomain.Length < 3 * sizeof(WCHAR)) ||
        ( ClientNetbiosDomain.Buffer[0] != L'\\' &&
          ClientNetbiosDomain.Buffer[1] != L'\\' ) ) &&
          !RtlEqualDomainName(
                   &NlpComputerName,
                   &ClientNetbiosDomain )) {

        //
        // Check if we are a DC in this domain.
        //  If so, use this DC.
        //

        if ( !NlpWorkstation &&
                   RtlEqualDomainName(
                       &NlpSamDomainName,
                       &ClientNetbiosDomain )) {

            DCNameString = NlpComputerName;
        }

        if (DCNameString.Buffer == NULL) {

            if ( ClientDnsDomain.Length != 0 ) {
                ClientDsGetDcDomain = &ClientDnsDomain;
            } else {
                ClientDsGetDcDomain = &ClientNetbiosDomain;
            }

            //
            // Build a zero terminated domain name.
            //

            DomainName = I_NtLmAllocate(
                            ClientDsGetDcDomain->Length + sizeof(WCHAR)
                            );

            if ( DomainName == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory( DomainName,
                           ClientDsGetDcDomain->Buffer,
                           ClientDsGetDcDomain->Length );
            DomainName[ClientDsGetDcDomain->Length / sizeof(WCHAR)] = 0;

            NetStatus = DsGetDcNameW(
                                NULL,
                                DomainName,
                                NULL, // no domain guid
                                NULL, // no site name
                                DS_WRITABLE_REQUIRED,
                                &DCInfo );

            if ( NetStatus != NERR_Success ) {

                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsGetDcNameW %ws returned %#x\n", DomainName, NetStatus ));

                Status = NetpApiStatusToNtStatus( NetStatus );
                if ( Status == STATUS_INTERNAL_ERROR )
                    Status = STATUS_NO_SUCH_DOMAIN;
            } else {
                RtlInitUnicodeString( &DCNameString, DCInfo->DomainControllerName );
            }

            //
            // ISSUE: attempting DC rediscovery when DsGetDcName failed or 
            // password change failed non authoritatively this seemed to be
            // wrong
            //

            AttemptRediscovery = TRUE;
        }

        if (NT_SUCCESS(Status)) {

            Status = MspChangePassword(
                         &DCNameString,
                         &ClientName,
                         &ChangePasswordRequest->OldPassword,
                         &ChangePasswordRequest->NewPassword,
                         ClientRequest,
                         ChangePasswordRequest->Impersonating,
                         &DomainPasswordInfo,
                         NULL,
                         &Authoritative );

            //
            // If we succeeded or got back an authoritative answer
            if ( NT_SUCCESS(Status) || Authoritative) {
                goto PasswordChangeSuccessfull;
            }
        }
    }

    //
    // Free the DC info so we can call DsGetDcName again.
    //

    if ( DCInfo != NULL ) {
        NetApiBufferFree(DCInfo);
        DCInfo = NULL;
    }

    //
    // attempt re-discovery.
    //

    if ( AttemptRediscovery ) {

        NetStatus = DsGetDcNameW(
                            NULL,
                            DomainName,
                            NULL,           // no domain guid
                            NULL,           // no site name
                            DS_FORCE_REDISCOVERY | DS_WRITABLE_REQUIRED,
                            &DCInfo );

        if ( NetStatus != NERR_Success ) {

            SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsGetDcNameW (re-discover) %ws returned %#x\n", DomainName, NetStatus ));

            DCInfo = NULL;
            Status = NetpApiStatusToNtStatus( NetStatus );
            if ( Status == STATUS_INTERNAL_ERROR )
                Status = STATUS_NO_SUCH_DOMAIN;
        } else {
            RtlInitUnicodeString( &DCNameString, DCInfo->DomainControllerName );

            Status = MspChangePassword(
                         &DCNameString,
                         &ClientName,
                         &ChangePasswordRequest->OldPassword,
                         &ChangePasswordRequest->NewPassword,
                         ClientRequest,
                         ChangePasswordRequest->Impersonating,
                         &DomainPasswordInfo,
                         NULL,
                         &Authoritative );

            //
            // If we succeeded or got back an authoritative answer
            if ( NT_SUCCESS(Status) || Authoritative) {
                goto PasswordChangeSuccessfull;
            }

            //
            // Free the DC info so we can call DsGetDcName again.
            //

            if ( DCInfo != NULL ) {
                NetApiBufferFree(DCInfo);
                DCInfo = NULL;
            }
        }
    }

    if (Status != STATUS_BACKUP_CONTROLLER) {
        //
        // Change the password assuming the DomainName is really a server name
        //
        // The domain name is overloaded to be either a domain name or a server
        // name.  The server name is useful when changing the password on a LM2.x
        // standalone server, which is a "member" of a domain but uses a private
        // account database.
        //

        Status = MspChangePassword(
                     &ClientNetbiosDomain,
                     &ClientName,
                     &ChangePasswordRequest->OldPassword,
                     &ChangePasswordRequest->NewPassword,
                     ClientRequest,
                     ChangePasswordRequest->Impersonating,
                     &DomainPasswordInfo,
                     &PrimaryDomainInfo,
                     &Authoritative );

        //
        // If DomainName is actually a server name,
        //  just return the status to the caller.
        //

        if ( Authoritative &&
             ( Status != STATUS_BAD_NETWORK_PATH ||
               ( ClientNetbiosDomain.Length >= 3 * sizeof(WCHAR) &&
                 ClientNetbiosDomain.Buffer[0] == L'\\' &&
                 ClientNetbiosDomain.Buffer[1] == L'\\' ) ) ) {

            //
            // If \\xxx was specified, but xxx doesn't exist,
            //  return the status code that the DomainName field is bad.
            //

            if ( Status == STATUS_BAD_NETWORK_PATH ) {
                Status = STATUS_NO_SUCH_DOMAIN;
            }
        }

        //
        // If we didn't get an error that this was a backup controller,
        // we are out of here.
        //

        if (Status != STATUS_BACKUP_CONTROLLER) {
            goto PasswordChangeSuccessfull;
        }
    }

    //
    // If the specified machine was a BDC in a domain,
    //    Pretend the caller passed us the domain name in the first place.
    //

    if ( Status == STATUS_BACKUP_CONTROLLER && PrimaryDomainInfo != NULL ) {

        ClientNetbiosDomain = PrimaryDomainInfo->Name;
        Status = STATUS_BAD_NETWORK_PATH;
    } else {
        goto PasswordChangeSuccessfull;
    }

    //
    // Build a zero terminated domain name.
    //

    // BUGBUG: Should really pass both names to internal version of DsGetDcName
    if ( ClientDnsDomain.Length != 0 ) {
        ClientDsGetDcDomain = &ClientDnsDomain;
    } else {
        ClientDsGetDcDomain = &ClientNetbiosDomain;
    }

    if ( DomainName )
    {
        I_NtLmFree( DomainName );
    }

    DomainName = I_NtLmAllocate(
                    ClientDsGetDcDomain->Length + sizeof(WCHAR)
                    );

    if ( DomainName == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory( DomainName,
                   ClientDsGetDcDomain->Buffer,
                   ClientDsGetDcDomain->Length );
    DomainName[ClientDsGetDcDomain->Length / sizeof(WCHAR)] = 0;

    AttemptRediscovery = FALSE;

retry:
    {
        DWORD dwGetDcFlags = 0;

        if ( AttemptRediscovery )
            dwGetDcFlags |= DS_FORCE_REDISCOVERY;

        //
        // Determine the PDC of the named domain so we can change the password there.
        //

        NetStatus = DsGetDcNameW(
                            NULL,
                            DomainName,
                            NULL,           // no domain guid
                            NULL,           // no site name
                            dwGetDcFlags | DS_WRITABLE_REQUIRED,
                            &DCInfo );

        if ( NetStatus != NERR_Success ) {

            SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsGetDcNameW (retry) %ws, dwGetDcFlags %#x returned %#x\n", DomainName, dwGetDcFlags, NetStatus));

            Status = NetpApiStatusToNtStatus( NetStatus );
            if ( Status == STATUS_INTERNAL_ERROR )
                Status = STATUS_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        RtlInitUnicodeString( &DCNameString, DCInfo->DomainControllerName );

        Status = MspChangePassword(
                     &DCNameString,
                     &ClientName,
                     &ChangePasswordRequest->OldPassword,
                     &ChangePasswordRequest->NewPassword,
                     ClientRequest,
                     ChangePasswordRequest->Impersonating,
                     &DomainPasswordInfo,
                     NULL,
                     &Authoritative );

        if ( !NT_SUCCESS(Status) && !Authoritative && !AttemptRediscovery ) {

            //
            // ISSUE: only do rediscovery if the DC is not available, seem to 
            // be over-reactive here
            //

            AttemptRediscovery = TRUE;
            goto retry;
        }
    }

PasswordChangeSuccessfull:

    //
    // Allocate and initialize the response buffer.
    //

    SavedStatus = Status;

    *ReturnBufferSize = sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE),
                                      *ReturnBufferSize );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrint(("MSV1_0: MspLm20ChangePassword: cannot alloc client buffer\n" ));
        *ReturnBufferSize = 0;
        goto Cleanup;
    }

    ChangePasswordResponse = (PMSV1_0_CHANGEPASSWORD_RESPONSE) ClientBufferDesc.MsvBuffer;

    ChangePasswordResponse->MessageType = MsV1_0ChangePassword;


    //
    // Copy the DomainPassword restrictions out to the caller depending on
    //  whether it was passed to us.
    //
    // Mark the buffer as valid or invalid to let the caller know.
    //
    // if STATUS_PASSWORD_RESTRICTION is returned.  This status can be
    // returned by either SAM or a down-level change.  Only SAM will return
    // valid data so we have a flag in the buffer that says whether the data
    // is valid or not.
    //

    if ( DomainPasswordInfo == NULL ) {
        ChangePasswordResponse->PasswordInfoValid = FALSE;
    } else {
        ChangePasswordResponse->DomainPasswordInfo = *DomainPasswordInfo;
        ChangePasswordResponse->PasswordInfoValid = TRUE;
    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

    //
    // Update cached credentials with the new password.
    //
    // This is done by calling NlpChangePassword,
    // which takes encrypted passwords, so encrypt 'em.
    //

    if ( NT_SUCCESS(SavedStatus) ) {
        BOOLEAN Impersonating;
        NTSTATUS TempStatus;

        //
        // Failure of NlpChangePassword is OK, that means that the
        // account we've been working with isn't the one we're
        // caching credentials for.
        //

        TempStatus = NlpChangePassword(
                        Validated,
                        &ClientNetbiosDomain,
                        &ClientName,
                        &ChangePasswordRequest->NewPassword
                        );

        //
        // for ChangeCachedPassword, set the ProtocolStatus if an error
        // occured updating.
        //

        if ( !NT_SUCCESS(TempStatus) &&
            (ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword)
            )
        {
            SavedStatus = TempStatus;

            //
            // STATUS_PRIVILEGE_NOT_HELD means the caller is not allowed to change
            // cached passwords, if so bail out now
            //

            if (STATUS_PRIVILEGE_NOT_HELD == SavedStatus)
            {
                Status = SavedStatus;
                goto Cleanup;
            }
        }

        //
        // Notify the LSA itself of the password change
        //

        Impersonating = FALSE;

        if ( ChangePasswordRequest->Impersonating ) {
            TempStatus = Lsa.ImpersonateClient();

            if ( NT_SUCCESS(TempStatus)) {
                Impersonating = TRUE;
            }
        }

        LsaINotifyPasswordChanged(
            &ClientNetbiosDomain,
            &ClientName,
            ClientDnsDomain.Length == 0 ? NULL : &ClientDnsDomain,
            ClientUpn.Length == 0 ? NULL : &ClientUpn,
            ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword ?
                NULL :
                &ChangePasswordRequest->OldPassword,
            &ChangePasswordRequest->NewPassword,
            Impersonating );

        if ( Impersonating ) {
            RevertToSelf();
        }
    }

    Status = SavedStatus;

Cleanup:


    //
    // Free Locally allocated resources
    //

    if (DomainName != NULL) {
        I_NtLmFree(DomainName);
    }

    if ( DCInfo != NULL ) {
        NetApiBufferFree(DCInfo);
    }

    if ( WkstaInfo100 != NULL ) {
        NetApiBufferFree(WkstaInfo100);
    }

    if ( DomainPasswordInfo != NULL ) {
        SamFreeMemory(DomainPasswordInfo);
    }

    if ( PrimaryDomainInfo != NULL ) {
        (VOID) LsaFreeMemory( PrimaryDomainInfo );
    }

    if (NameResult) {

        DsFreeNameResult(NameResult);   
    }

    if ( DsHandle ) {

        DsUnBindW(
            &DsHandle
            );
    }

    if (SpnForDC) {

        NtLmFreePrivateHeap(SpnForDC);
    }

    //
    // Free Policy Server Role Information if used.
    //

    if (PolicyLsaServerRoleInfo != NULL) {

        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyLsaServerRoleInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyLsaServerRoleInfo
            );
    }

    //
    // Free the return buffer.
    //

    NlpFreeClientBuffer( &ClientBufferDesc );

    //
    // Don't let the password stay in the page file.
    //

    if ( PasswordBufferValidated ) {
        RtlEraseUnicodeString( &ChangePasswordRequest->OldPassword );
        RtlEraseUnicodeString( &ChangePasswordRequest->NewPassword );
    }

    //
    // Flush the log to disk
    //

    MsvPaswdSetAndClearLog();

#if _WIN64

    //
    // Do this last since some of the cleanup code above may refer to addresses
    // inside the pTempSubmitBuffer/ProtocolSubmitBuffer (e.g., erasing the old
    // and new passwords, etc).
    //

    if (fAllocatedSubmitBuffer)
    {
        NtLmFreePrivateHeap( pTempSubmitBuffer );
    }

#endif  // _WIN64

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msvars.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msvars.c

Abstract:

   This module contains variables used within the msv1_0 authentication
   package.

Author:

    Jim Kelly (JimK) 11-Apr-1991

Environment:

    User mode - msv1_0 authentication package DLL

Revision History:
    Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\msvars.c

--*/

#include "msp.h"



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////



//
// msv1_0 private heap.
//

PVOID MspHeap;


//
// package ID assigned to msv1_0 by the LSA.
//

ULONG MspAuthenticationPackageId;


//
// dispatch table of (public) LSA service routines.
//

LSA_SECPKG_FUNCTION_TABLE Lsa;





////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\global.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NtLm security package
//
//
// History:     ChandanS  25-Jul-1996 Stolen from kerberos\client2\kerbp.h
//
//------------------------------------------------------------------------

#ifndef __GLOBAL_H__
#define __GLOBAL_H__


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include "msvprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#include <wincred.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
#include <dsysdbg.h>
#include <lsarpc.h>
#include <lsaitf.h>
#include <dns.h>
#include <dnsapi.h>
#include <alloca.h>

#include <rc4.h>
#include <des.h>
#include <md5.h>
#include <sha.h>
#include <hmac.h>

#include "ntlmfunc.h"
#include "ntlmutil.h"
#include "ntlmsspi.h"
#include "ntlmcomn.h"

//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTLM_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTLM_GLOBAL

typedef enum _NTLM_STATE {
    NtLmLsaMode = 1,
    NtLmUserMode
} NTLM_STATE, *PNTLM_STATE;

EXTERN NTLM_STATE NtLmState;

EXTERN ULONG_PTR NtLmPackageId;

EXTERN SECPKG_FUNCTION_TABLE NtLmFunctionTable;

// Helper routines for use by a Security package handed over by Lsa

EXTERN SECPKG_USER_FUNCTION_TABLE NtLmUserFunctionTable;
EXTERN PSECPKG_DLL_FUNCTIONS UserFunctions;
EXTERN PLSA_SECPKG_FUNCTION_TABLE LsaFunctions;

EXTERN LSA_SECPKG_FUNCTION_TABLE Lsa;

// This one guards all globals
EXTERN RTL_RESOURCE NtLmGlobalCritSect;

// Save the PSECPKG_PARAMETERS sent in by SpInitialize
EXTERN SECPKG_PARAMETERS NtLmSecPkg;

EXTERN BOOLEAN NtLmGlobalEncryptionEnabled;

EXTERN ULONG NtLmGlobalLmProtocolSupported;
EXTERN UNICODE_STRING NtLmGlobalNtLm3TargetInfo;
EXTERN BOOLEAN NtLmGlobalRequireNtlm2;
EXTERN BOOLEAN NtLmGlobalDatagramUse128BitEncryption;
EXTERN BOOLEAN NtLmGlobalDatagramUse56BitEncryption;


EXTERN ULONG NtLmGlobalMinimumClientSecurity;
EXTERN ULONG NtLmGlobalMinimumServerSecurity;

//
// Useful constants
//

EXTERN TimeStamp NtLmGlobalForever;

// Local system is NtProductWinNt or NtProductLanmanNt

EXTERN NT_PRODUCT_TYPE NtLmGlobalNtProductType;

//
// The computername of the local system.
//

EXTERN WCHAR NtLmGlobalUnicodeComputerName[CNLEN + 1];
EXTERN CHAR NtLmGlobalOemComputerName[CNLEN + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodeComputerNameString;
EXTERN STRING NtLmGlobalOemComputerNameString;

EXTERN WCHAR NtLmGlobalUnicodeDnsComputerName[DNS_MAX_NAME_LENGTH + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodeDnsComputerNameString;

//
// The domain name of the local system
//

EXTERN WCHAR NtLmGlobalUnicodePrimaryDomainName[DNS_MAX_NAME_LENGTH + 1];
EXTERN CHAR NtLmGlobalOemPrimaryDomainName[DNS_MAX_NAME_LENGTH + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodePrimaryDomainNameString;
EXTERN STRING NtLmGlobalOemPrimaryDomainNameString;

EXTERN WCHAR NtLmGlobalUnicodeDnsDomainName[DNS_MAX_NAME_LENGTH + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodeDnsDomainNameString;


//
// The TargetName of the local system
//

EXTERN UNICODE_STRING NtLmGlobalUnicodeTargetName;
EXTERN STRING NtLmGlobalOemTargetName;
EXTERN ULONG NtLmGlobalTargetFlags;
EXTERN PSID NtLmGlobalLocalSystemSid;
EXTERN PSID NtLmGlobalAliasAdminsSid;
EXTERN PSID NtLmGlobalProcessUserSid;
EXTERN PSID NtLmGlobalAnonymousSid;

EXTERN UNICODE_STRING NtLmGlobalUnicodeDnsTreeName;

//
// mapped and preferred domain names
// NOTE: these require a reboot to be re-read during package startup
// it is not necessary to hold the global lock as a side-effect of this
// requirement
//

EXTERN UNICODE_STRING NtLmLocklessGlobalMappedDomainString;
EXTERN UNICODE_STRING NtLmLocklessGlobalPreferredDomainString;


EXTERN HKEY NtLmGlobalLsaKey;
EXTERN HKEY NtLmGlobalLsaMsv1_0Key;

EXTERN HANDLE NtLmGlobalRegChangeNotifyEvent;
EXTERN HANDLE NtLmGlobalRegWaitObject;

//
// Access token associated with SYSTEM account.
//

EXTERN HANDLE NtLmGlobalAccessTokenSystem;

//
// System wide fudge for mutual auth in mixed environments
//

EXTERN ULONG NtLmGlobalMutualAuthLevel ;

//
// LogonID of machine credential.
//

EXTERN LUID NtLmGlobalLuidMachineLogon;

//
// LSA policy handle to local machine.
//

EXTERN LSA_HANDLE NtLmGlobalPolicyHandle;


//
// force guest account usage for all network logons?
//

EXTERN BOOLEAN NtLmGlobalForceGuest;

//
// indicates if we are running on the Personal product SKU
//

EXTERN BOOLEAN NtLmGlobalPersonalSKU;


EXTERN BOOLEAN NtLmGlobalSafeBoot;

//
// Allow blank password logons?
//

EXTERN BOOLEAN NtLmGlobalAllowBlankPassword;

//
// Joined to a domain?
//

EXTERN BOOLEAN NtLmGlobalDomainJoined;

//
// Joined to downlevel (pre-Win2k) domain?
//

EXTERN BOOLEAN NtLmGlobalDownlevelDomain;

//
// magic number
//

EXTERN CHAR NtlmGlobalMagicNumber[MSV1_0_USER_SESSION_KEY_LENGTH];

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __GLOBAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msv1_0.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msv1_0.c

Abstract:

    MSV1_0 authentication package.


    The name of this authentication package is:


Author:

    Jim Kelly 11-Apr-1991

Revision History:
    Scott Field (sfield)    15-Jan-98   Add MspNtDeriveCredential
    Chandana Surlu          21-Jul-96   Stolen from \\kernel\razzle3\src\security\msv1_0\msv1_0.c
--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"


//
// LsaApCallPackage() function dispatch table
//


PLSA_AP_CALL_PACKAGE
MspCallPackageDispatch[] = {
    MspLm20Challenge,
    MspLm20GetChallengeResponse,
    MspLm20EnumUsers,
    MspLm20GetUserInfo,
    MspLm20ReLogonUsers,
    MspLm20ChangePassword,
    MspLm20ChangePassword,
    MspLm20GenericPassthrough,
    MspLm20CacheLogon,
    MspNtSubAuth,
    MspNtDeriveCredential,
    MspLm20CacheLookup,
    MspSetProcessOption
};





///////////////////////////////////////////////////////////////////////
//                                                                   //
// Authentication package dispatch routines.                         //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
LsaApInitializePackage (
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    )

/*++

Routine Description:

    This service is called once by the LSA during system initialization to
    provide the DLL a chance to initialize itself.

Arguments:

    AuthenticationPackageId - The ID assigned to the authentication
        package.

    LsaDispatchTable - Provides the address of a table of LSA
        services available to authentication packages.  The services
        of this table are ordered according to the enumerated type
        LSA_DISPATCH_TABLE_API.

    Database - This parameter is not used by this authentication package.

    Confidentiality - This parameter is not used by this authentication
        package.

    AuthenticationPackageName - Recieves the name of the
        authentication package.  The authentication package is
        responsible for allocating the buffer that the string is in
        (using the AllocateLsaHeap() service) and returning its
        address here.  The buffer will be deallocated by LSA when it
        is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    PSTRING NameString;
    PCHAR NameBuffer;
    NTSTATUS Status;

    //
    // If we haven't already initialized the internals, do it now.
    //

    if (!NlpMsvInitialized) {


        //
        // Save our assigned authentication package ID.
        //

        MspAuthenticationPackageId = AuthenticationPackageId;


        //
        // Copy the LSA service dispatch table
        // the LsaDispatchTable is actually a LSA_SECPKG_FUNCTION_TABLE
        // in Win2k and beyond.
        //

        CopyMemory( &Lsa, LsaDispatchTable, sizeof( Lsa ) );

        //
        // Initialize the change password log.
        //

        MsvPaswdInitializeLog();

        //
        // Initialize netlogon
        //

        Status = NlInitialize();

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,"Error from NlInitialize = %d\n", Status));
            return Status;
        }
        NlpMsvInitialized = TRUE;
    }

    //
    // Allocate and return our package name
    //

    if (ARGUMENT_PRESENT(AuthenticationPackageName))
    {
        NameBuffer = (*(Lsa.AllocateLsaHeap))(sizeof(MSV1_0_PACKAGE_NAME));
        if (!NameBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint((SSP_CRITICAL, "Error from Lsa.AllocateLsaHeap\n"));
            return Status;

        }
        strcpy( NameBuffer, MSV1_0_PACKAGE_NAME);

        NameString = (*(Lsa.AllocateLsaHeap))( (ULONG)sizeof(STRING) );
        if (!NameString)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint((SSP_CRITICAL, "Error from Lsa.AllocateLsaHeap\n"));
            return Status;
        }

        RtlInitString( NameString, NameBuffer );
        (*AuthenticationPackageName) = NameString;
    }


    RtlInitUnicodeString(
        &NlpMsv1_0PackageName,
        TEXT(MSV1_0_PACKAGE_NAME)
        );

    return STATUS_SUCCESS;

    //
    // Appease the compiler gods by referencing all arguments
    //

    UNREFERENCED_PARAMETER(Confidentiality);
    UNREFERENCED_PARAMETER(Database);

}


NTSTATUS
LsaApCallPackage (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage().

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/

{
    ULONG MessageType;

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

#endif  // _WIN64

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(MSV1_0_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PMSV1_0_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(MspCallPackageDispatch)/sizeof(MspCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

#if _WIN64

    if( ClientRequest != (PLSA_CLIENT_REQUEST)(-1) )
    {
        //
        // Only supported CallPackage level for WOW64 callers is password change.
        //

        if (!LsaFunctions->GetCallInfo(&CallInfo))
        {
            return STATUS_INTERNAL_ERROR;
        }

        if ( (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) &&
            ((CallInfo.Attributes & SECPKG_CALL_IN_PROC) == 0))

        {
            switch (MessageType)
            {
                case MsV1_0ChangePassword:
                case MsV1_0GenericPassthrough:
                {
                    break;
                }

                default:
                {
                    return STATUS_NOT_SUPPORTED;
                }
            }
        }
    }

#endif  // _WIN64

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;



    //
    // Call the appropriate routine for this message.
    //

    return (*(MspCallPackageDispatch[MessageType]))(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus ) ;

}


NTSTATUS
LsaApCallPackageUntrusted (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for untrusted clients.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.

--*/

{
    ULONG MessageType;
    NTSTATUS Status;

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

#endif  // _WIN64

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(MSV1_0_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PMSV1_0_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(MspCallPackageDispatch)/sizeof(MspCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allow an service to call the DeriveCredential function if the
    // request specifies the same logon id as the service.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0DeriveCredential)
    {
        PMSV1_0_DERIVECRED_REQUEST DeriveCredRequest;
        SECPKG_CLIENT_INFO ClientInfo;
        LUID SystemId = SYSTEM_LUID;

        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if(!NT_SUCCESS(Status))
        {
            return Status;
        }

        if ( SubmitBufferLength < sizeof(MSV1_0_DERIVECRED_REQUEST) ) {
            return STATUS_INVALID_PARAMETER;
        }

        DeriveCredRequest = (PMSV1_0_DERIVECRED_REQUEST) ProtocolSubmitBuffer;

        if(!RtlEqualLuid(&ClientInfo.LogonId, &DeriveCredRequest->LogonId))
        {
            return STATUS_ACCESS_DENIED;
        }

        if(RtlEqualLuid(&ClientInfo.LogonId, &SystemId))
        {
            return STATUS_ACCESS_DENIED;
        }
    }


    //
    // Allow an untrusted client to call the SetProcessOption function if
    // the DISABLE_FORCE_GUEST or ALLOW_OLD_PASSWORD option is set.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0SetProcessOption)
    {
        PMSV1_0_SETPROCESSOPTION_REQUEST ProcessOptionRequest;
        ULONG ValidOptions;

        if ( SubmitBufferLength < sizeof(MSV1_0_SETPROCESSOPTION_REQUEST) ) {
            return STATUS_INVALID_PARAMETER;
        }

        ProcessOptionRequest = (PMSV1_0_SETPROCESSOPTION_REQUEST) ProtocolSubmitBuffer;

        ValidOptions =  MSV1_0_OPTION_DISABLE_FORCE_GUEST |
                        MSV1_0_OPTION_ALLOW_OLD_PASSWORD |
                        MSV1_0_OPTION_TRY_CACHE_FIRST ;

        if( ProcessOptionRequest->ProcessOptions & ~ValidOptions )
        {
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // let DeriveCredential and SetProcessOption requests through if the caller is a service.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0DeriveCredential ||
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0SetProcessOption ||
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0ChangeCachedPassword
        )
    {
        BOOL IsMember = FALSE;
        PSID pServiceSid = NULL;
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

        Status = LsaFunctions->ImpersonateClient();

        if (NT_SUCCESS(Status))
        {
            if (AllocateAndInitializeSid( &siaNtAuthority,
                                         1,
                                         SECURITY_SERVICE_RID,
                                         0, 0, 0, 0, 0, 0, 0,
                                         &pServiceSid ))
            {
                if (!CheckTokenMembership(NULL, pServiceSid, &IsMember))
                {
                    IsMember = FALSE;
                }

                FreeSid(pServiceSid);
            }

            RevertToSelf();
        }
        else
        {
            return Status;
        }

        if (!IsMember)
        {
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Untrusted clients are only allowed to call a few of the functions.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0ChangePassword &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0DeriveCredential &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0SetProcessOption &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0Lm20ChallengeRequest &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0ChangeCachedPassword
        ) {

        return STATUS_ACCESS_DENIED;
    }

#if _WIN64

    //
    // Only supported CallPackage level for WOW64 callers is password change.
    //

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        return STATUS_INTERNAL_ERROR;
    }

    if ((CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
          &&
        ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0ChangePassword))
    {
        return STATUS_NOT_SUPPORTED;
    }

#endif  // _WIN64

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return (*(MspCallPackageDispatch[MessageType]))(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus ) ;

}



NTSTATUS
LsaApCallPackagePassthrough (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for passthrough logon requests.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/

{
    ULONG MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(MSV1_0_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PMSV1_0_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(MspCallPackageDispatch)/sizeof(MspCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // clients are only allowed to call the SubAuthLogon function.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0SubAuth) {

        return STATUS_ACCESS_DENIED;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return (*(MspCallPackageDispatch[MessageType]))(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msvprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msvprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let NTLM compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msvsam.c ===
//depot/Lab03_N/DS/security/protocols/msv_sspi/msvsam.c#37 - edit change 16740 (text)
/*++

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    msvsam.c

Abstract:

    Sam account validation interface.

    These routines are shared by the MSV authentication package and
    the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 15-Jan-1992

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\msvsam.c
    JClark                 28-Jun-2000    Added WMI Trace Logging Support
                                          Fixed bug 73583 - Password Expiration and Subauth DLLs

--*/

#include <global.h>
#undef EXTERN

#include "msp.h"
#include "nlp.h"
#include <stddef.h>     // offsetof()
#include <msaudite.h>   // SE_AUDITID_xxx
#include "trace.h"        // WMI Tracing goo



///////////////////////////////////////////////////////////////////////
//                                                                   //
// SubAuth package zero helper routine                               //
//                                                                   //
///////////////////////////////////////////////////////////////////////


NTSTATUS
Msv1_0SubAuthenticationRoutineZero(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );


BOOLEAN
MsvpCheckPreviousPassword(
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN SAMPR_HANDLE DomainHandle,
    PUNICODE_STRING UserName
    );


BOOLEAN
MsvpLm3ValidateResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
{
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
    ULONG i;

    // compute the response again

    MsvpLm3Response (
                pNtOwfPassword,
                pUserName,
                pLogonDomainName,
                ChallengeToClient,
                pLm3Response,
                Response,
                UserSessionKey,
                LmSessionKey
                );

    // compare with what we were passed

    i = (ULONG) RtlCompareMemory(
                    pLm3Response->Response,
                    Response,
                    MSV1_0_NTLM3_RESPONSE_LENGTH
                    );

#if 0
    //
    // If the NTLMv2 client computes a challenge/response, based on a missing
    // supplied LogonDomainName, it will use NULL and effectively not mix in
    // the LogonDomainName in the hash computation. On the server side, when
    // netlogon calls, we get passed non-NULL, and of course that fails to
    // compute the same hash. One somewhat slimy, but interesting way to fix
    // this problem would be to retry the hash computation against a NULL
    // domain, as below.  This may be more attractive than changing netlogon,
    // and trivial to backport & test on Win2k SP3.
    //
    //                                    Scott Field (SField)  11-6-2001
    //

    if ( (MSV1_0_NTLM3_RESPONSE_LENGTH != i) && pLogonDomainName->Length ) {

        UNICODE_STRING EmptyString = {0};

        MsvpLm3Response (
            pNtOwfPassword,
            pUserName,
            &EmptyString,
            ChallengeToClient,
            pLm3Response,
            Response,
            UserSessionKey,
            LmSessionKey
            );

        // compare with what we were passed

        i = (ULONG) RtlCompareMemory(
                        pLm3Response->Response,
                        Response,
                        MSV1_0_NTLM3_RESPONSE_LENGTH
                        );
    }
#endif

    SspPrint((SSP_NTLM_V2, "MsvpLm3ValidateResponse returning %s\n", (i == MSV1_0_NTLM3_RESPONSE_LENGTH) ? "true" : "false"));

    return (BOOLEAN) (i == MSV1_0_NTLM3_RESPONSE_LENGTH);
}


BOOLEAN
MsvpNtlm3ValidateResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    IN ULONG Ntlm3ResponseLength,
    IN PMSV1_0_LM3_RESPONSE pLm3Response,
    IN ULONG Lm3ResponseLength,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
{
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
    ULONG i;
    LARGE_INTEGER Time;
    NTSTATUS Status;

#ifndef USE_CONSTANT_CHALLENGE

    const LONGLONG TicksPerSecond = 10*1000*1000;    // 100 ns ticks per second

#endif


    //
    // three success scenarios:
    // 1) NTResponse provided is NTLMv2 and validation against NTResponse succeeds -- compute
    //    separate User and Lm sessionkeys.
    // 2) NTResponse provided is NTLMv2 and validation against NTResponse fails, validation
    //    against LMResponse succeeds -- compute separate User and Lm sessionkeys in the same
    //    manner as #1 above.
    // 3) NTResponse is not provided, and validation against LMResponse succeeds -- compute
    //    session keys as such:  User session key is derived from LMResponse, and LM session key
    //    is a truncated form of User sessionkey.
    //


    //
    // check the NTChallengeResponse first, if appropriate...
    //

    while (Ntlm3ResponseLength >= MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH)
    {
        //
        // check version numbers
        //

        if (pNtlm3Response->RespType > 1 ||
            pNtlm3Response->HiRespType < 1)
        {
            break;
        }

        //
        // check that the timestamp isn't too old
        //

        Status = NtQuerySystemTime( &Time );
        ASSERT( NT_SUCCESS(Status) );

        SspPrint((SSP_NTLM_V2, "MsvpNtlm3ValidateResponse: local %#I64x, response %#I64x\n", Time, pNtlm3Response->TimeStamp));

#ifndef USE_CONSTANT_CHALLENGE
        //
        // make sure time hasn't expired
        // don't forget that client's clock could be behind ours
        //

        if (Time.QuadPart > (LONGLONG)pNtlm3Response->TimeStamp)
        {
            if (Time.QuadPart - (LONGLONG)pNtlm3Response->TimeStamp >
                (MSV1_0_MAX_NTLM3_LIFE*TicksPerSecond))
            {
                break;
            }
        } else if ((LONGLONG)pNtlm3Response->TimeStamp - Time.QuadPart >
            (MSV1_0_MAX_NTLM3_LIFE*TicksPerSecond)) {
            break;
        }
#endif

        // compute the response itself

        MsvpNtlm3Response(
            pNtOwfPassword,
            pUserName,
            pLogonDomainName,
            (Ntlm3ResponseLength-sizeof(MSV1_0_NTLM3_RESPONSE)),
            ChallengeToClient,
            pNtlm3Response,
            Response,
            UserSessionKey,
            LmSessionKey
            );

        // compare with what we were passed

        i = (ULONG) RtlCompareMemory(
                        pNtlm3Response->Response,
                        Response,
                        MSV1_0_NTLM3_RESPONSE_LENGTH
                        );

        //
        // If the NTLMv2 client computes a challenge/response, based on a missing
        // supplied LogonDomainName, it will use NULL and effectively not mix in
        // the LogonDomainName in the hash computation. On the server side, when
        // netlogon calls, we get passed non-NULL, and of course that fails to
        // compute the same hash. One somewhat slimy, but interesting way to fix
        // this problem would be to retry the hash computation against a NULL
        // domain, as below.  This may be more attractive than changing netlogon,
        // and trivial to backport & test on Win2k SP3.
        //
        //                                    Scott Field (SField)  11-6-2001
        //

        if ( (MSV1_0_NTLM3_RESPONSE_LENGTH != i) && pLogonDomainName->Length )
        {
            UNICODE_STRING EmptyString = {0};

            MsvpNtlm3Response(
                pNtOwfPassword,
                pUserName,
                &EmptyString,
                (Ntlm3ResponseLength-sizeof(MSV1_0_NTLM3_RESPONSE)),
                ChallengeToClient,
                pNtlm3Response,
                Response,
                UserSessionKey,
                LmSessionKey
                );

            // compare with what we were passed

            i = (ULONG) RtlCompareMemory(
                            pNtlm3Response->Response,
                            Response,
                            MSV1_0_NTLM3_RESPONSE_LENGTH
                            );
        }

        if( i == MSV1_0_NTLM3_RESPONSE_LENGTH )
        {
            return TRUE;
        }

        break;
    }


    //
    // if we got here, the NTLMv2 NTChallengeResponse failed or was missing.
    //

    if ( Lm3ResponseLength == LM_RESPONSE_LENGTH )
    {
        UNICODE_STRING EmptyString = {0};

        if (!MsvpLm3ValidateResponse(
                pNtOwfPassword,
                pUserName,
                pLogonDomainName,
                ChallengeToClient,
                pLm3Response,
                UserSessionKey,
                LmSessionKey
                ))
        {
            //
            // try with a NULL domain, per the above.  This will carry through
            // to the Ntlm3Response below.
            //

            if ( (pLogonDomainName->Length == 0) ||
               !MsvpLm3ValidateResponse(
                    pNtOwfPassword,
                    pUserName,
                    &EmptyString,
                    ChallengeToClient,
                    pLm3Response,
                    UserSessionKey,
                    LmSessionKey
                    ) )
            {
                return FALSE;
            }
        }


        if ( Ntlm3ResponseLength >= MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH )
        {
            //
            // if the NTChallengeResponse was provided, but failed,
            // compute session keys based the same way as a success case would have.
            // this is required as the client does not know that the LM field was used
            // to successfully authenticate.
            //

            MsvpNtlm3Response(
                pNtOwfPassword,
                pUserName,
                pLogonDomainName,
                (Ntlm3ResponseLength - sizeof(MSV1_0_NTLM3_RESPONSE)),
                ChallengeToClient,
                pNtlm3Response,
                Response,
                UserSessionKey,
                LmSessionKey
                );
        }

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
MsvpPasswordValidate (
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN PUSER_INTERNAL1_INFORMATION Passwords,
    OUT PULONG UserFlags,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
)
/*++

Routine Description:

    Process an interactive, network, or session logon.  It calls
    SamIUserValidation, validates the passed in credentials, updates the logon
    statistics and packages the result for return to the caller.

    This routine is called directly from the MSV Authentication package
    on any system where LanMan is not installed.  This routine is called
    from the Netlogon Service otherwise.

Arguments:

    UasCompatibilityRequired -- True, if UAS compatibility is required.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

    Passwords -- Specifies the passwords for the user account.

    UserFlags -- Returns flags identifying how the password was validated.
        Returns LOGON_NOENCRYPTION if the password wasn't encrypted
        Returns LOGON_USED_LM_PASSWORD if the LM password from SAM was used.

    UserSessionKey -- Returns the NT User session key for this network logon
        session.

    LmSessionKey -- Returns the LM compatible session key for this network
        logon session.

Return Value:

    TRUE -- Password validation is successful
    FALSE -- Password validation failed

--*/
{
    NTSTATUS Status;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PNETLOGON_INTERACTIVE_INFO LogonInteractiveInfo;
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    BOOLEAN AlreadyValidated = FALSE;
    BOOLEAN TryLmResponse = TRUE;
    UNICODE_STRING NullUnicodeString;

    ULONG NtLmProtocolSupported;

    //
    // Initialization.
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;
    *UserFlags = LOGON_NTLMV2_ENABLED;
    RtlZeroMemory( UserSessionKey, sizeof(*UserSessionKey) );
    RtlZeroMemory( LmSessionKey, sizeof(*LmSessionKey) );
    RtlInitUnicodeString( &NullUnicodeString, NULL );

    //
    // Ensure the OWF password is always defined
    //

    if ( !Passwords->NtPasswordPresent ){
        RtlCopyMemory( &Passwords->NtOwfPassword,
                       &NlpNullNtOwfPassword,
                       sizeof(Passwords->NtOwfPassword) );
    }

    if ( !Passwords->LmPasswordPresent ){
        RtlCopyMemory( &Passwords->LmOwfPassword,
                       &NlpNullLmOwfPassword,
                       sizeof(Passwords->LmOwfPassword) );
    }

    //
    // Handle interactive/service validation.
    //
    // Simply compare the OWF password passed in with the one from the
    // SAM database.
    //

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        ASSERT( offsetof( NETLOGON_INTERACTIVE_INFO, LmOwfPassword)
            ==  offsetof( NETLOGON_SERVICE_INFO, LmOwfPassword) );
        ASSERT( offsetof( NETLOGON_INTERACTIVE_INFO, NtOwfPassword)
            ==  offsetof( NETLOGON_SERVICE_INFO, NtOwfPassword) );

        LogonInteractiveInfo =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;

        //
        // If we're in UasCompatibilityMode,
        //  and we don't have the NT password in SAM (but do have LM password),
        //  validate against the LM version of the password.
        //

        if ( UasCompatibilityRequired &&
             !Passwords->NtPasswordPresent &&
             Passwords->LmPasswordPresent ) {

            if ( RtlCompareMemory( &Passwords->LmOwfPassword,
                                   &LogonInteractiveInfo->LmOwfPassword,
                                   LM_OWF_PASSWORD_LENGTH ) !=
                                   LM_OWF_PASSWORD_LENGTH ) {

                return FALSE;
            }
            *UserFlags |= LOGON_USED_LM_PASSWORD;

        //
        // In all other circumstances, use the NT version of the password.
        //  This enforces case sensitivity.
        //

        } else {

            if ( RtlCompareMemory( &Passwords->NtOwfPassword,
                                   &LogonInteractiveInfo->NtOwfPassword,
                                   NT_OWF_PASSWORD_LENGTH ) !=
                                   NT_OWF_PASSWORD_LENGTH ) {

                return FALSE;
            }
        }

        break;


    //
    // Handle network logon validation.
    //

    case NetlogonNetworkInformation:
    {
        BOOLEAN TriedNtLm2 = FALSE;

        //
        // First, assume the passed password information is a challenge
        // response.
        //

        LogonNetworkInfo =
            (PNETLOGON_NETWORK_INFO) LogonInformation;

        SspPrint((SSP_CRED, 
            "MsvpPasswordValidate NetworkLogon ParameterControl %#x, user \"%wZ\", domain \"%wZ\", NtRespLen %#x, LmRespLen %#x\n", 
            LogonNetworkInfo->Identity.ParameterControl,
            &LogonNetworkInfo->Identity.UserName, 
            &LogonNetworkInfo->Identity.LogonDomainName,
            LogonNetworkInfo->NtChallengeResponse.Length,
            LogonNetworkInfo->LmChallengeResponse.Length));

        // If the NT response is an NTLM3 response, do NTLM3 or NTLM3 with LM OWF
        // if the length is > NT_RESPONSE_LENGTH, then it's an NTLM3 response

        if (LogonNetworkInfo->NtChallengeResponse.Length > NT_RESPONSE_LENGTH)
        {
            //
            // this routine will try both NTChallengeResponse and LmChallengeResponse
            // validation if appropriate.
            //

            AlreadyValidated = MsvpNtlm3ValidateResponse(
                                    &Passwords->NtOwfPassword,
                                    &LogonNetworkInfo->Identity.UserName,
                                    &LogonNetworkInfo->Identity.LogonDomainName,
                                    (PUCHAR)&LogonNetworkInfo->LmChallenge,
                                    (PMSV1_0_NTLM3_RESPONSE) LogonNetworkInfo->NtChallengeResponse.Buffer,
                                    LogonNetworkInfo->NtChallengeResponse.Length,
                                    (PMSV1_0_LM3_RESPONSE) LogonNetworkInfo->LmChallengeResponse.Buffer,
                                    LogonNetworkInfo->LmChallengeResponse.Length,
                                    UserSessionKey,
                                    LmSessionKey
                                    );

            SspPrint((SSP_NTLM_V2, "MsvpPasswordValidate MsvpNtlm3ValidateResponse(NtResponse) returns %s\n", AlreadyValidated ? "true" : "false"));

            //
            // because a Subauth may have been used, we will only return failure
            // here if we know the request was NTLMv2.
            //

            if( AlreadyValidated ||
                (LogonNetworkInfo->Identity.ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) ) {
                return AlreadyValidated;
            }

            TriedNtLm2 = TRUE;
        }

        //
        // check the LM3 response based on NT OWF hash next
        //  this will be recieved from Win9x server with NTLMv2 client
        //

        if ((LogonNetworkInfo->NtChallengeResponse.Length != NT_RESPONSE_LENGTH) &&
            (LogonNetworkInfo->LmChallengeResponse.Length == NT_RESPONSE_LENGTH) &&
             (!TriedNtLm2) )
        {
            //
            // we only reach here if we haven't tried to satisfy the NTLMv2 response.
            // ie: the NTChallengeResponse is not populated with NTLMv2.
            //

            AlreadyValidated =  MsvpNtlm3ValidateResponse (
                                    &Passwords->NtOwfPassword,
                                    &LogonNetworkInfo->Identity.UserName,
                                    &LogonNetworkInfo->Identity.LogonDomainName,
                                    (PUCHAR)&LogonNetworkInfo->LmChallenge,
                                    (PMSV1_0_NTLM3_RESPONSE) LogonNetworkInfo->NtChallengeResponse.Buffer,
                                    LogonNetworkInfo->NtChallengeResponse.Length,
                                    (PMSV1_0_LM3_RESPONSE) LogonNetworkInfo->LmChallengeResponse.Buffer,
                                    LogonNetworkInfo->LmChallengeResponse.Length,
                                    UserSessionKey,
                                    LmSessionKey
                                    );

            SspPrint((SSP_NTLM_V2, "MsvpPasswordValidate MsvpNtlm3ValidateResponse(LmResponse) returns %s\n", AlreadyValidated ? "true" : "false"));

            if (AlreadyValidated)
                return TRUE;
        }

        NtLmProtocolSupported = NtLmGlobalLmProtocolSupported;

        // if we're requiring all clients (Win9x and NT) to have been upgraded, fail out now
        //if (NtLmProtocolSupported >= RefuseNtlm)
            //return FALSE;

        // if that fails, check the NTLM response if there is one of the
        //  appropriate size in either NT response or LM response
        if (!AlreadyValidated &&
            (NtLmProtocolSupported < RefuseNtlm) &&
            (Passwords->NtPasswordPresent || (!Passwords->NtPasswordPresent && !Passwords->LmPasswordPresent)) &&
            (LogonNetworkInfo->NtChallengeResponse.Length == NT_RESPONSE_LENGTH ||
            LogonNetworkInfo->LmChallengeResponse.Length == NT_RESPONSE_LENGTH)) {

            NT_RESPONSE NtResponse;

            //
            // NT response is present and hash exists, don't try the LM respnose.
            //

            if( LogonNetworkInfo->NtChallengeResponse.Length == NT_RESPONSE_LENGTH )
            {
                TryLmResponse = FALSE;
            }

            //
            // Compute what the response should be.
            //

            Status = RtlCalculateNtResponse(
                        &LogonNetworkInfo->LmChallenge,
                        &Passwords->NtOwfPassword,
                        &NtResponse );

            if ( NT_SUCCESS(Status) ) {

                //
                // If the responses match, the passwords are valid.
                //  Try the NT response first, then the LM response
                //

                if ( RtlCompareMemory(
                      LogonNetworkInfo->
                        NtChallengeResponse.Buffer,
                      &NtResponse,
                      LogonNetworkInfo->NtChallengeResponse.Length ) ==
                      NT_RESPONSE_LENGTH ) {

                    AlreadyValidated = TRUE;

                } else if ( RtlCompareMemory(
                      LogonNetworkInfo->
                        LmChallengeResponse.Buffer,
                      &NtResponse,
                      LogonNetworkInfo->LmChallengeResponse.Length ) ==
                      NT_RESPONSE_LENGTH ) {

                    AlreadyValidated = TRUE;
                }
            }
        }

        // if we're requiring all Win9x clients to have been upgraded, fail out now
        //if (!AlreadyValidated && NtLmProtocolSupported >= RefuseLm)
        //    return FALSE;

        //
        //  if the LM response is the right size
        //  validate against the LM version of the response
        //  this applies also when both NTOWF and LMOWF are not present in SAM.
        //

        if (!AlreadyValidated &&
            ( TryLmResponse ) &&
            ( NtLmProtocolSupported < RefuseLm ) &&
            ( LogonNetworkInfo->LmChallengeResponse.Length == LM_RESPONSE_LENGTH ) &&
            ( (Passwords->LmPasswordPresent) || (!Passwords->LmPasswordPresent && !Passwords->NtPasswordPresent) )
            ) {

            LM_RESPONSE LmResponse;

            //
            // Compute what the response should be.
            //

            Status = RtlCalculateLmResponse(
                        &LogonNetworkInfo->LmChallenge,
                        &Passwords->LmOwfPassword,
                        &LmResponse );

            if ( NT_SUCCESS(Status) ) {

                //
                // If the responses match, the passwords are valid.
                //

                if ( RtlCompareMemory(
                      LogonNetworkInfo->
                        LmChallengeResponse.Buffer,
                      &LmResponse,
                      LM_RESPONSE_LENGTH ) ==
                      LM_RESPONSE_LENGTH ) {

                    AlreadyValidated = TRUE;
                    *UserFlags |= LOGON_USED_LM_PASSWORD;
                }
            }
        }

        //
        // If we haven't already validated this user,
        //  Validate a Cleartext password on a Network logon request.
        //

        if ( !AlreadyValidated ) {

            // If Cleartext passwords are not allowed,
            //  indicate the password doesn't match.
            //

            if((LogonInfo->ParameterControl & CLEARTEXT_PASSWORD_ALLOWED) == 0){
                return FALSE;
            }


            //
            // Compute the OWF password for the specified Cleartext password and
            // compare that to the OWF password retrieved from SAM.
            //

            //
            // If we're in UasCompatibilityMode,
            //  and we don't have the NT password in SAM or
            //      we don't have the NT password supplied by the caller.
            //  validate against the LM version of the password.
            //
            // if neither password are present, we validate against
            // the empty computed LMOWF.
            //

            if ( UasCompatibilityRequired &&
                 (NtLmProtocolSupported < RefuseLm) &&
                 ((Passwords->LmPasswordPresent) || (!Passwords->LmPasswordPresent && !Passwords->NtPasswordPresent)) &&
                 (!Passwords->NtPasswordPresent ||
                 LogonNetworkInfo->NtChallengeResponse.Length == 0 ) ) {

                LM_OWF_PASSWORD LmOwfPassword;
                CHAR LmPassword[LM20_PWLEN+1];
                USHORT i;


                //
                // Compute the LmOwfPassword for the cleartext password passed in.
                //  (Enforce length restrictions on LanMan compatible passwords.)
                //

                if ( LogonNetworkInfo->LmChallengeResponse.Length >
                    sizeof(LmPassword) ) {
                    return FALSE;
                }

                RtlZeroMemory( &LmPassword, sizeof(LmPassword) );

                for (i = 0; i < LogonNetworkInfo->LmChallengeResponse.Length; i++) {
                    LmPassword[i] =
                      RtlUpperChar(LogonNetworkInfo->LmChallengeResponse.Buffer[i]);
                }

                (VOID) RtlCalculateLmOwfPassword( LmPassword, &LmOwfPassword );

                if ( RtlCompareMemory( &Passwords->LmOwfPassword,
                                       &LmOwfPassword,
                                       LM_OWF_PASSWORD_LENGTH ) !=
                                       LM_OWF_PASSWORD_LENGTH ) {

                    //
                    // Try the case preserved clear text password, too.
                    //  (I know of no client that does this,
                    //  but it is compatible with the LM 2.x server.)
                    //

                    RtlZeroMemory( &LmPassword, sizeof(LmPassword) );
                    RtlCopyMemory(
                        &LmPassword,
                        LogonNetworkInfo->LmChallengeResponse.Buffer,
                        LogonNetworkInfo->LmChallengeResponse.Length);

                    (VOID) RtlCalculateLmOwfPassword( LmPassword,
                                                      &LmOwfPassword );

                    if ( RtlCompareMemory( &Passwords->LmOwfPassword,
                                           &LmOwfPassword,
                                           LM_OWF_PASSWORD_LENGTH ) !=
                                           LM_OWF_PASSWORD_LENGTH ) {

                        RtlSecureZeroMemory(LmPassword, sizeof(LmPassword));
                        RtlSecureZeroMemory(&LmOwfPassword, sizeof(LmOwfPassword));

                        return FALSE;
                    }

                    RtlSecureZeroMemory(LmPassword, sizeof(LmPassword));
                    RtlSecureZeroMemory(&LmOwfPassword, sizeof(LmOwfPassword));

                }

                *UserFlags |= LOGON_USED_LM_PASSWORD;


            //
            // In all other circumstances, use the NT version of the password.
            //  This enforces case sensitivity.
            //

            } else {
                NT_OWF_PASSWORD NtOwfPassword;


                //
                // Compute the NtOwfPassword for the cleartext password passed in.
                //

                Status = RtlCalculateNtOwfPassword(
                             (PUNICODE_STRING)
                                &LogonNetworkInfo->NtChallengeResponse,
                             &NtOwfPassword );

                if ( RtlCompareMemory( &Passwords->NtOwfPassword,
                                       &NtOwfPassword,
                                       NT_OWF_PASSWORD_LENGTH ) !=
                                       NT_OWF_PASSWORD_LENGTH ) {

                    RtlSecureZeroMemory(&NtOwfPassword, sizeof(NtOwfPassword));

                    return FALSE;
                }

                RtlSecureZeroMemory(&NtOwfPassword, sizeof(NtOwfPassword));
            }

            *UserFlags |= LOGON_NOENCRYPTION;
        }

        //
        // ASSERT: the network logon has been authenticated
        //
        //  Compute the session keys.

        //
        // If the client negotiated a non-NT protocol,
        //  use the lanman session key as the UserSessionKey.
        //

        if ( LogonNetworkInfo->NtChallengeResponse.Length == 0 ) {

            ASSERT( sizeof(*UserSessionKey) >= sizeof(*LmSessionKey) );

            //
            // win9x depends on the last 8 bytes to be zero, zero it out now
            //

            RtlZeroMemory( UserSessionKey, sizeof(*UserSessionKey) );

            RtlCopyMemory( UserSessionKey,
                           &Passwords->LmOwfPassword,
                           sizeof(*LmSessionKey) );

        } else {

            //
            // Return the NT UserSessionKey unless this is an account
            //  that doesn't have the NT version of the password.
            //  (A null password counts as a password).
            //

            if ( Passwords->NtPasswordPresent || !Passwords->LmPasswordPresent){

                Status = RtlCalculateUserSessionKeyNt(
                            (PNT_RESPONSE) NULL,    // Argument not used
                            &Passwords->NtOwfPassword,
                            UserSessionKey );

                ASSERT( NT_SUCCESS(Status) );
            }
        }

        //
        // Return the LM SessionKey unless this is an account
        //  that doesn't have the LM version of the password.
        //  (A null password counts as a password).
        //

        if ( Passwords->LmPasswordPresent || !Passwords->NtPasswordPresent ) {
            RtlCopyMemory( LmSessionKey,
                           &Passwords->LmOwfPassword,
                           sizeof(*LmSessionKey) );
        }

        break;
    }

    //
    // Any other LogonLevel is an internal error.
    //
    default:
        return FALSE;

    }

    return TRUE;
}


BOOLEAN
MsvpEqualSidPrefix(
    IN PSID DomainSid,
    IN PSID GroupSid
    )
/*++

Routine Description:

    This routine checks to see if the specified group sid came from the
    specified domain by verifying that the domain portion of the group sid
    is equal to the domain sid.

Arguments:

    DomainSid - Sid of the domain for comparison.

    GroupSid - Sid of the group for comparison

Returns:

    TRUE - The group sid came from the specified domain.
    FALSE - The group sid did not come from the specified domain.

--*/
{
    PISID LocalGroupSid = (PISID) GroupSid;
    PISID LocalDomainSid = (PISID) DomainSid;
    if ((LocalGroupSid->SubAuthorityCount == LocalDomainSid->SubAuthorityCount + 1) &&
        RtlEqualMemory(
            RtlIdentifierAuthoritySid(LocalDomainSid),
            RtlIdentifierAuthoritySid(LocalGroupSid),
            RtlLengthRequiredSid(
                LocalDomainSid->SubAuthorityCount
                ) - FIELD_OFFSET(SID,IdentifierAuthority)
            )) {
        return(TRUE);
    }
    return(FALSE);
}

NTSTATUS
MsvpFilterGroupMembership(
    IN PSID_AND_ATTRIBUTES_LIST CompleteMembership,
    IN PSID LogonDomainId,
    OUT PSAMPR_GET_GROUPS_BUFFER LocalMembership,
    OUT PSID_AND_ATTRIBUTES_LIST GlobalMembership,
    OUT PULONG GlobalMembershipSize
    )
/*++

Routine Description:

    This routine separates the complete transitive group membership into
    portions from this domain and portions from others.

Arguments:

    CompleteMembership - The complete transitive membership.

    LogonDomainId - SID of the logon domain, used for compressing group
        membership.

    LocalMembership - Receives a list of rids corresponding to groups in this
        domain. The list should be freed with MIDL_user_free.

    GlobalMembership - Recevies a list of sids corresponding to groups in
        other domain. The list, but not the sids, should be free with
        MIDL_user_free.

    GlobalMembershipSize - Size, in bytes, of the sids in the global membership
        and the size of the SID_AND_ATTRIBUTES structures.

Returns:

    STATUS_SUCCESS on success
    STATUS_INSUFFICIENT_RESOURCES on for memory allocation failures.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LocalCount = 0;
    ULONG GlobalCount = 0;
    ULONG GlobalSize = 0;
    ULONG Index;

    LocalMembership->MembershipCount = 0;
    LocalMembership->Groups = NULL;
    GlobalMembership->Count = 0;
    GlobalMembership->SidAndAttributes = NULL;


    //
    // Define a flag so we don't have to do the comparison twice.
    //

#define MSVP_LOCAL_GROUP_ATTR 0x20000000

    for (Index = 0; Index < CompleteMembership->Count ; Index++ ) {
        ASSERT((CompleteMembership->SidAndAttributes[Index].Attributes & MSVP_LOCAL_GROUP_ATTR) == 0);

        if (MsvpEqualSidPrefix(
            LogonDomainId,
            CompleteMembership->SidAndAttributes[Index].Sid
            )) {

            CompleteMembership->SidAndAttributes[Index].Attributes |= MSVP_LOCAL_GROUP_ATTR;
            LocalCount++;
        } else {

            GlobalCount++;
            GlobalSize += sizeof(SID_AND_ATTRIBUTES) + RtlLengthSid(CompleteMembership->SidAndAttributes[Index].Sid);
        }
    }

    //
    // Allocate the arrays for the output
    //

    if (LocalCount != 0)
    {
        LocalMembership->Groups = (PGROUP_MEMBERSHIP) I_NtLmAllocate(LocalCount * sizeof(GROUP_MEMBERSHIP));
        if (LocalMembership->Groups == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        LocalMembership->MembershipCount = LocalCount;
    }
    if (GlobalCount != 0)
    {
        GlobalMembership->SidAndAttributes = (PSID_AND_ATTRIBUTES) I_NtLmAllocate(GlobalCount * sizeof(SID_AND_ATTRIBUTES));
        if (GlobalMembership->SidAndAttributes == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        GlobalMembership->Count = GlobalCount;
    }

    //
    // Loop through again copy the rid or sid into the respective array
    //

    LocalCount = 0;
    GlobalCount = 0;
    for (Index = 0; Index < CompleteMembership->Count ; Index++ ) {

        if ((CompleteMembership->SidAndAttributes[Index].Attributes & MSVP_LOCAL_GROUP_ATTR) != 0) {

            LocalMembership->Groups[LocalCount].Attributes = CompleteMembership->SidAndAttributes[Index].Attributes & ~MSVP_LOCAL_GROUP_ATTR;
            LocalMembership->Groups[LocalCount].RelativeId =
                        *RtlSubAuthoritySid(
                            CompleteMembership->SidAndAttributes[Index].Sid,
                            *RtlSubAuthorityCountSid(
                                CompleteMembership->SidAndAttributes[Index].Sid
                                ) - 1
                            );
            LocalCount++;
        } else {
            GlobalMembership->SidAndAttributes[GlobalCount] = CompleteMembership->SidAndAttributes[Index];
            GlobalCount++;
        }
    }
    *GlobalMembershipSize = GlobalSize;
Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (LocalMembership->Groups != NULL)
        {
            I_NtLmFree(LocalMembership->Groups);
            LocalMembership->Groups = NULL;
        }
        if (GlobalMembership->SidAndAttributes != NULL)
        {
            I_NtLmFree(GlobalMembership->SidAndAttributes);
            GlobalMembership->SidAndAttributes = NULL;
        }
    }
    return(Status);
}


NTSTATUS
MsvpSamValidate (
    IN SAMPR_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG GuestRelativeId,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed
)
/*++

Routine Description:

    Process an interactive, network, or session logon.  It calls
    SamIUserValidation, validates the passed in credentials, updates the logon
    statistics and packages the result for return to the caller.

    This routine is called by MsvSamValidate.

Arguments:

    DomainHandle -- Specifies a handle to the SamDomain to use to
        validate the request.

    UasCompatibilityRequired -- TRUE iff UasCompatibilityMode is on.

    SecureChannelType -- The secure channel type this request was made on.

        When netlogon on the BDC is called, the user is actually
        already authenticated (via PDC) through a prior "net use"
        from the win9x client.  Netlogon merely returns the validation
        info to the win9x caller.  To do that Netlogon calls
        MsvSamValidate passing NullSecureChannel as the 3rd parameter
        indicating to skip the password check.


    LogonServer -- Specifies the server name of the caller.

    LogonDomainName -- Specifies the domain of the caller.

    LogonDomainId  -- Specifies the DomainId of the domain of the caller.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

    GuestRelativeId - If non-zero, specifies the relative ID of the account
        to validate against.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4.

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed user MIDL_user_free.
        This information is only return on STATUS_SUCCESS.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    BadPasswordCountZeroed - Returns TRUE iff we zeroed the BadPasswordCount
        field of this user.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_INVALID_INFO_CLASS: LogonLevel or ValidationLevel are invalid.
    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    Other return codes from SamIUserValidation

--*/
{
    NTSTATUS Status;
    NTSTATUS SubAuthExStatus = STATUS_SUCCESS;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    SAMPR_HANDLE UserHandle = NULL;
    ULONG RelativeId = GuestRelativeId;
    ULONG SamFlags;
    PSID LocalSidUser = NULL;

    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL;
    SAMPR_GET_GROUPS_BUFFER GroupsBuffer;
    ULONG UserFlags = 0;
    USER_SESSION_KEY UserSessionKey = {0};
    LM_SESSION_KEY LmSessionKey = {0};
    ULONG WhichFields = 0;
    UNICODE_STRING LocalUserName;

    UNICODE_STRING LocalWorkstation;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime = {0};
    LARGE_INTEGER KickoffTime = {0};
    UNICODE_STRING Upn;

    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordMustChange;
    LARGE_INTEGER PasswordLastSet;


    PNETLOGON_VALIDATION_SAM_INFO4 ValidationSam = NULL;
    ULONG ValidationSamSize;
    PUCHAR Where;
    ULONG Index;

    SAMPR_RETURNED_USTRING_ARRAY NameArray;
    SAMPR_ULONG_ARRAY UseArray;
    SID_AND_ATTRIBUTES_LIST GroupMembership;
    SID_AND_ATTRIBUTES_LIST GlobalGroupMembership;
    ULONG GlobalMembershipSize = 0;

    MSV1_0_VALIDATION_INFO SubAuthValidationInformation;
    BOOLEAN fSubAuthEx = FALSE;

    BOOLEAN fMachineAccount;

    ULONG ActionsPerformed = 0;
    PSID UserSid = NULL;

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;



    //
    // check if caller requested that logon only target specified domain.
    //

    if( LogonInfo->ParameterControl & MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY &&
        LogonInfo->LogonDomainName.Length ) {

        //
        // common case is a match for LogonDomainName, so avoid taking locks
        // until mis-match occurs.
        //

        if(!RtlEqualDomainName( &LogonInfo->LogonDomainName, LogonDomainName )) {

            WCHAR LocalTarget[ DNS_MAX_NAME_LENGTH + 1 ];
            WCHAR SpecifiedTarget[ DNS_MAX_NAME_LENGTH + 1 ];
            ULONG cchLocalTarget = 0;
            ULONG cchSpecifiedTarget = 0;

            //
            // pickup the local target name, based on whether this computer is
            // a domain controller.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if( NlpWorkstation ) {

                if( (NtLmGlobalUnicodeDnsComputerNameString.Length + sizeof(WCHAR)) <=
                    sizeof( LocalTarget ) ) {

                    RtlCopyMemory(
                                LocalTarget,
                                NtLmGlobalUnicodeDnsComputerName,
                                NtLmGlobalUnicodeDnsComputerNameString.Length
                                );

                    cchLocalTarget = (NtLmGlobalUnicodeDnsComputerNameString.Length) /
                                    sizeof(WCHAR);
                }

            } else {
                if( (NtLmGlobalUnicodeDnsDomainNameString.Length + sizeof(WCHAR)) <=
                    sizeof( LocalTarget ) ) {

                    RtlCopyMemory(
                                LocalTarget,
                                NtLmGlobalUnicodeDnsDomainName,
                                NtLmGlobalUnicodeDnsDomainNameString.Length
                                );

                    cchLocalTarget = (NtLmGlobalUnicodeDnsDomainNameString.Length) /
                                    sizeof(WCHAR);
                }

            }

            RtlReleaseResource(&NtLmGlobalCritSect);

            //
            // pull out target name.
            //

            if( (LogonInfo->LogonDomainName.Length + sizeof(WCHAR)) <= sizeof( SpecifiedTarget ) ) {

                cchSpecifiedTarget = (LogonInfo->LogonDomainName.Length) / sizeof(WCHAR);

                RtlCopyMemory(
                                SpecifiedTarget,
                                LogonInfo->LogonDomainName.Buffer,
                                LogonInfo->LogonDomainName.Length
                                );
            }

            if ( cchLocalTarget && cchSpecifiedTarget ) {

                LocalTarget[ cchLocalTarget ] = L'\0';
                SpecifiedTarget[ cchSpecifiedTarget ] = L'\0';

                if(!DnsNameCompare_W( LocalTarget, SpecifiedTarget ) ) {
                    *Authoritative = FALSE;
                    return STATUS_NO_SUCH_USER;
                }
            }
        }
    }


    //
    // Initialization.
    //

    RtlZeroMemory(
        &SubAuthValidationInformation,
        sizeof(MSV1_0_VALIDATION_INFO));

    SubAuthValidationInformation.Authoritative = TRUE;
    SubAuthValidationInformation.WhichFields = 0;
    NameArray.Count = 0;
    NameArray.Element = NULL;
    UseArray.Count = 0;
    UseArray.Element = NULL;
    *BadPasswordCountZeroed = FALSE;
    GroupMembership.Count = 0;
    GroupMembership.SidAndAttributes = NULL;
    GlobalGroupMembership.Count = 0;
    GlobalGroupMembership.SidAndAttributes = NULL;
    GroupsBuffer.MembershipCount = 0;
    GroupsBuffer.Groups = NULL;

    RtlInitUnicodeString( &Upn, NULL );

    (VOID) NtQuerySystemTime( &LogonTime );


    //
    // Determine what account types are valid.
    //
    // Normal user accounts are always allowed.
    //

    UserAccountControl = USER_NORMAL_ACCOUNT;

    *Authoritative = TRUE;

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        break;

    case NetlogonNetworkInformation:
        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ( SecureChannelType == MsvApSecureChannel ) {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        //
        // Machine accounts can be accessed on network connections.
        //

        UserAccountControl |= USER_INTERDOMAIN_TRUST_ACCOUNT |
                              USER_WORKSTATION_TRUST_ACCOUNT |
                              USER_SERVER_TRUST_ACCOUNT;
        break;

    default:
        *Authoritative = TRUE;
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    // Check the ValidationLevel
    //

    switch (ValidationLevel) {
    case NetlogonValidationSamInfo:
    case NetlogonValidationSamInfo2:
    case NetlogonValidationSamInfo4:
        break;

    default:

        *Authoritative = TRUE;
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    // Convert the user name to a RelativeId.
    //

    if ( RelativeId != 0 ) {

        UCHAR cDomainSubAuthorities;
        UCHAR SubAuthIndex;
        ULONG cbLocalSidUser;
        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;

        //
        // build a Sid out of the DomainId and the supplied Rid.
        //

        cDomainSubAuthorities = *RtlSubAuthorityCountSid( LogonDomainId );
        pIdentifierAuthority = RtlIdentifierAuthoritySid( LogonDomainId );

        cbLocalSidUser = RtlLengthRequiredSid( (ULONG)(cDomainSubAuthorities + 1) );
        LocalSidUser = I_NtLmAllocate( cbLocalSidUser );
        if (LocalSidUser == NULL) {
            *Authoritative = FALSE;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = RtlInitializeSid(LocalSidUser, pIdentifierAuthority, (UCHAR)((DWORD)cDomainSubAuthorities+1));
        if(!NT_SUCCESS(Status)) {
            *Authoritative = FALSE;
            goto Cleanup;
        }

        //
        // loop copying subauthorities.
        //

        for( SubAuthIndex = 0 ; SubAuthIndex < cDomainSubAuthorities ; SubAuthIndex++ )
        {
            *RtlSubAuthoritySid( LocalSidUser, (ULONG)SubAuthIndex ) =
            *RtlSubAuthoritySid( LogonDomainId, (ULONG)SubAuthIndex );
        }

        //
        // append relative ID.
        //

        *RtlSubAuthoritySid(LocalSidUser, cDomainSubAuthorities) = RelativeId;

        LocalUserName.Buffer = LocalSidUser;
        LocalUserName.Length = (USHORT)cbLocalSidUser;
        LocalUserName.MaximumLength = (USHORT)cbLocalSidUser;

        SamFlags = SAM_OPEN_BY_SID;
    } else {
        LocalUserName = LogonInfo->UserName;
        SamFlags = 0;
    }

    //
    // if this is a domain controller, and, we get a logon request that
    // looks like a possible UPN, set the flag...
    //

    if( (SamFlags == 0) &&
        (LogonInfo->LogonDomainName.Buffer == NULL) &&
        !NlpWorkstation
        )
    {
        SamFlags |= SAM_OPEN_BY_UPN_OR_ACCOUNTNAME;
    }

    //
    // Open the user account.
    //

    if (( LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL ) ||
        ( LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL_EX ) ||
        NlpSubAuthZeroExists ) {

        //
        // Fetch all attributes in the presence of a subauthentication DLL
        //

        Status = I_SamIGetUserLogonInformation(
                    DomainHandle,
                    SamFlags,
                    &LocalUserName,
                    &UserAllInfo,
                    &GroupMembership,
                    &UserHandle
                    );

    } else {

        //
        // Performance optimization:
        // Fetch only select attributes in the absence of a subauthentication DLL
        //

        Status = I_SamIGetUserLogonInformationEx(
                    DomainHandle,
                    SamFlags,
                    &LocalUserName,
                    USER_ALL_ACCOUNTEXPIRES |
                    USER_ALL_BADPASSWORDCOUNT |
                    USER_ALL_FULLNAME |
                    USER_ALL_HOMEDIRECTORY |
                    USER_ALL_HOMEDIRECTORYDRIVE |
                    USER_ALL_LASTLOGON |
                    USER_ALL_LMPASSWORDPRESENT |
                    USER_ALL_LOGONCOUNT |
                    USER_ALL_LOGONHOURS |
                    USER_ALL_NTPASSWORDPRESENT |
                    USER_ALL_OWFPASSWORD |
                    USER_ALL_PARAMETERS |
                    USER_ALL_PASSWORDCANCHANGE |
                    USER_ALL_PASSWORDLASTSET |
                    USER_ALL_PASSWORDMUSTCHANGE |
                    USER_ALL_PRIMARYGROUPID |
                    USER_ALL_PROFILEPATH |
                    USER_ALL_SCRIPTPATH |
                    USER_ALL_USERACCOUNTCONTROL |
                    USER_ALL_USERID |
                    USER_ALL_USERNAME |
                    USER_ALL_WORKSTATIONS,
                    &UserAllInfo,
                    &GroupMembership,
                    &UserHandle
                    );
    }

    if ( !NT_SUCCESS(Status) ) {
        UserHandle = NULL;
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    if ( !NlpWorkstation )
    {
        BOOLEAN UpnDefaulted;

        //
        // get the UPN.  Ignore the failure, as, there is existing logic
        // for dealing with the lack of Upn.
        //

        I_SamIUPNFromUserHandle(
                UserHandle,
                &UpnDefaulted,
                &Upn
                );
    }

    UserAll = &UserAllInfo->All;

    if ( RelativeId != 0 )
    {
        //
        // reset LocalUserName to be an actual username rather than a Sid
        // for Guest logon.  This allows proper audit later on.
        //

        RtlCopyMemory( &LocalUserName, &UserAll->UserName, sizeof(LocalUserName) );
    }

    //
    // pickup RelativeId from looked up information.
    //

    RelativeId = UserAll->UserId;

    //
    // If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //
    // SubAuthentication packages can be more specific than this test but
    // they can't become less restrictive.
    //

    if ( (UserAccountControl & UserAll->UserAccountControl) == 0 ) {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // determine if machine account, if so, certain failures are treated
    // as Authoritative, to prevent fallback to guest and returning incorrect
    // error codes.
    //

    if ( (UserAll->UserAccountControl & USER_MACHINE_ACCOUNT_MASK) != 0 ) {
        fMachineAccount = TRUE;
    } else {
        fMachineAccount = FALSE;
    }

    OLD_TO_NEW_LARGE_INTEGER( UserAll->AccountExpires, AccountExpires );

    //
    // If there is a SubAuthentication DLL,
    //  call it to do all the authentication work.
    //

    if ( (LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL) &&
         (!(LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL_EX))) {

        ULONG LocalUserFlags = 0;
        ULONG Flags = 0;

        //
        // Ensure the account isn't locked out.
        //
        // admin (rid==500) is not locked out iff in either of the following cases:
        //  1) on console and interactive logon
        //  2) DOMAIN_LOCKOUT_ADMINS is not set
        //
        // We did this regardless before NT 5.0. Now, we do it when either
        // No SubAuth package is specified or
        // New SubAuth package asks us to do account lockout test
        // But, for those who call with old SubAuth packages, they will expect
        // us to do the dirty work.
        //

        if ( (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) &&
             (SecureChannelType != NullSecureChannel) )
        {
            BOOL LockOut = TRUE;

            if (RelativeId == DOMAIN_USER_RID_ADMIN) {

                //
                // if the process is configured to allow over-ride
                // (true if physical console logon), then don't enforce lockout.
                //

                if ((LogonLevel == NetlogonInteractiveInformation)
                    && ( NtLmCheckProcessOption( MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT ) & MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT )) {
                
                    LockOut = FALSE;                    

                } else {

                    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo = NULL;
                    Status = I_SamrQueryInformationDomain(
                                DomainHandle,
                                DomainPasswordInformation,
                                (PSAMPR_DOMAIN_INFO_BUFFER *)&DomainPasswordInfo );
                    if (!NT_SUCCESS(Status)) {
                        Status = STATUS_INTERNAL_ERROR;
                        *Authoritative = TRUE;
                        goto Cleanup;
                    }
                    if (0 == (DomainPasswordInfo->PasswordProperties & DOMAIN_LOCKOUT_ADMINS)) {
                                                
                        LockOut = FALSE;
                    }
                    SamFreeMemory(DomainPasswordInfo);
                }
            }
            if (LockOut) {

                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them.  Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //

                if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                    *Authoritative = fMachineAccount;
                } else {
                    *Authoritative = TRUE;
                }

                Status = STATUS_ACCOUNT_LOCKED_OUT;
                goto Cleanup;

            }
        }

        if ( SecureChannelType != MsvApSecureChannel ) {
            Flags |= MSV1_0_PASSTHRU;
        }
        if ( GuestRelativeId != 0 ) {
            Flags |= MSV1_0_GUEST_LOGON;
        }

        Status = Msv1_0SubAuthenticationRoutine(
                    LogonLevel,
                    LogonInformation,
                    Flags,
                    (PUSER_ALL_INFORMATION) UserAll,
                    &WhichFields,
                    &LocalUserFlags,
                    Authoritative,
                    &LogoffTime,
                    &KickoffTime );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Sanity check what the SubAuthentication package returned
        //
        if ( (WhichFields & ~USER_ALL_PARAMETERS) != 0 ) {
            Status = STATUS_INTERNAL_ERROR;
            *Authoritative = TRUE;
            goto Cleanup;
        }

        UserFlags |= LocalUserFlags;

    } else { // we may still have an NT 5.0 SubAuth dll

        //
        // If there is an NT 5.0 SubAuthentication DLL,
        // call it to do all the authentication work.
        //

        if ( (LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL_EX))
        {
            ULONG Flags = 0;

            if ( SecureChannelType != MsvApSecureChannel ) {
                Flags |= MSV1_0_PASSTHRU;
            }
            if ( GuestRelativeId != 0 ) {
                Flags |= MSV1_0_GUEST_LOGON;
            }

            Status = Msv1_0SubAuthenticationRoutineEx(
                        LogonLevel,
                        LogonInformation,
                        Flags,
                        (PUSER_ALL_INFORMATION) UserAll,
                        (SAM_HANDLE)UserHandle,
                        &SubAuthValidationInformation,
                        &ActionsPerformed );

            *Authoritative = SubAuthValidationInformation.Authoritative;

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            // We need to do this because even if any of the following checks
            // fail, ARAP stills wants the returned blobs from the subauth
            // package to be returned to the caller.

            fSubAuthEx = TRUE;
        }

        //
        // Ensure the account isn't locked out.
        //
        // admin (rid==500) is not locked out iff in either of the following cases:
        //  1) on console and interactive logon
        //  2) DOMAIN_LOCKOUT_ADMINS is not set
        // 

        if ((ActionsPerformed & MSV1_0_SUBAUTH_LOCKOUT) == 0)
        {
            if ( (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) &&
                 (SecureChannelType != NullSecureChannel) )
            {
                BOOL LockOut = TRUE;

                if (RelativeId == DOMAIN_USER_RID_ADMIN) {

                    //
                    // if the process is configured to allow over-ride
                    // (true if physical console logon), then don't enforce lockout.
                    //

                    if ((LogonLevel == NetlogonInteractiveInformation)
                        && ( NtLmCheckProcessOption( MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT ) & MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT )) {
                    
                        LockOut = FALSE;                    

                    } else {

                        PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo = NULL;
                        Status = I_SamrQueryInformationDomain(
                                    DomainHandle,
                                    DomainPasswordInformation,
                                    (PSAMPR_DOMAIN_INFO_BUFFER *)&DomainPasswordInfo );
                        if (!NT_SUCCESS(Status)) {
                            Status = STATUS_INTERNAL_ERROR;
                            *Authoritative = TRUE;
                            goto Cleanup;
                        }
                        if (0 == (DomainPasswordInfo->PasswordProperties & DOMAIN_LOCKOUT_ADMINS)) {
                                                    
                            LockOut = FALSE;
                        }
                        SamFreeMemory(DomainPasswordInfo);
                    }
                }

                if (LockOut) {

                     //
                     // Since the UI strongly encourages admins to disable user
                     // accounts rather than delete them.  Treat disabled acccount as
                     // non-authoritative allowing the search to continue for other
                     // accounts by the same name.
                     //

                     if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                         *Authoritative = fMachineAccount;
                     } else {
                         *Authoritative = TRUE;
                     }

                    Status = STATUS_ACCOUNT_LOCKED_OUT;
                    goto Cleanup;
                }
            }
        }

        //
        // Check the password if there's no subauth or if subauth did
        // not already check password.
        //

        if ((ActionsPerformed & MSV1_0_SUBAUTH_PASSWORD) == 0)
        {
            if ( SecureChannelType != NullSecureChannel ) {
                USER_INTERNAL1_INFORMATION Passwords;

                //
                // Copy the password info to the right structure.
                //

                Passwords.NtPasswordPresent = UserAll->NtPasswordPresent;
                if ( UserAll->NtPasswordPresent ) {
                    Passwords.NtOwfPassword =
                        *((PNT_OWF_PASSWORD)(UserAll->NtOwfPassword.Buffer));
                }

                Passwords.LmPasswordPresent = UserAll->LmPasswordPresent;
                if ( UserAll->LmPasswordPresent ) {
                    Passwords.LmOwfPassword =
                        *((PLM_OWF_PASSWORD)(UserAll->LmOwfPassword.Buffer));
                }


                //
                // If the password specified doesn't match the SAM password,
                //    then we've got a password mismatch.
                //

                if ( ! MsvpPasswordValidate (
                            UasCompatibilityRequired,
                            LogonLevel,
                            LogonInformation,
                            &Passwords,
                            &UserFlags,
                            &UserSessionKey,
                            &LmSessionKey ) ) {

                    //
                    // If this is a guest logon and the guest account has no password,
                    //  let the user log on.
                    //
                    // This special case check is after the MsvpPasswordValidate to
                    // give MsvpPasswordValidate every opportunity to compute the
                    // correct values for UserSessionKey and LmSessionKey.
                    //

                    if ( GuestRelativeId != 0 &&
                         !UserAll->NtPasswordPresent &&
                         !UserAll->LmPasswordPresent ) {

                        RtlZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
                        RtlZeroMemory( &LmSessionKey, sizeof(LmSessionKey) );


                    //
                    // The password mismatched.  We treat STATUS_WRONG_PASSWORD as
                    // an authoritative response.  Our caller may choose to do otherwise.
                    //

                    } else {

                        Status = STATUS_WRONG_PASSWORD;

                        //
                        // Since the UI strongly encourages admins to disable user
                        // accounts rather than delete them.  Treat disabled acccount as
                        // non-authoritative allowing the search to continue for other
                        // accounts by the same name.
                        //
                        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                            *Authoritative = fMachineAccount;
                        } else {
                            *Authoritative = TRUE;
                        }

                        goto Cleanup;
                    }
                }
            }

        //
        // If SubAuth DLL checked the password, then it implicitly
        // checked the password's expiration, and we don't have to.
        //
        } else { // end if((ActionsPerformed & MSV1_0_SUBAUTH_PASSWORD) == 0)
            ActionsPerformed |= MSV1_0_SUBAUTH_PASSWORD_EXPIRY;
        }

        //
        // Check if the account is disabled if there's no subauth or if
        // subauth has not already checked.
        //

        if ((ActionsPerformed & MSV1_0_SUBAUTH_ACCOUNT_DISABLED) == 0)
        {
            if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them.  Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //

                *Authoritative = fMachineAccount;
                Status = STATUS_ACCOUNT_DISABLED;
                goto Cleanup;
            }
        }

        //
        // Prevent some things from effecting the Administrator user
        //

        if (RelativeId != DOMAIN_USER_RID_ADMIN) {

            //
            // Check if the account has expired if there's no subauth or if
            // subauth has not already checked.
            //

            if ((ActionsPerformed & MSV1_0_SUBAUTH_ACCOUNT_EXPIRY) == 0)
            {
                OLD_TO_NEW_LARGE_INTEGER( UserAll->AccountExpires, AccountExpires );

                if ( AccountExpires.QuadPart != 0 &&
                    LogonTime.QuadPart >= AccountExpires.QuadPart ) {
                    *Authoritative = TRUE;
                    Status = STATUS_ACCOUNT_EXPIRED;
                    goto Cleanup;
                }
            }

            //
            // The password is valid, check to see if the password is expired.
            //  (SAM will have appropriately set PasswordMustChange to reflect
            //  USER_DONT_EXPIRE_PASSWORD)
            //
            // We only check password expiration if we also checked the password.
            //

            if ((ActionsPerformed & MSV1_0_SUBAUTH_PASSWORD_EXPIRY) == 0)
            {

              OLD_TO_NEW_LARGE_INTEGER( UserAll->PasswordMustChange, PasswordMustChange );
              OLD_TO_NEW_LARGE_INTEGER( UserAll->PasswordLastSet, PasswordLastSet );

              if ( SecureChannelType != NullSecureChannel ) {
                if ( LogonTime.QuadPart >= PasswordMustChange.QuadPart ) {

                    if ( PasswordLastSet.QuadPart == 0 ) {
                        Status = STATUS_PASSWORD_MUST_CHANGE;
                    } else {
                        Status = STATUS_PASSWORD_EXPIRED;
                    }
                    *Authoritative = TRUE;
                    goto Cleanup;
                }
              }
            }
        }

        //
        // Validate the workstation the user logged on from.
        //
        // Ditch leading \\ on workstation name before passing it to SAM.
        //

        LocalWorkstation = LogonInfo->Workstation;
        if ( LocalWorkstation.Length > 0 &&
             LocalWorkstation.Buffer[0] == L'\\' &&
             LocalWorkstation.Buffer[1] == L'\\' ) {
            LocalWorkstation.Buffer += 2;
            LocalWorkstation.Length -= 2*sizeof(WCHAR);
            LocalWorkstation.MaximumLength -= 2*sizeof(WCHAR);
        }

        //
        // Check if SAM found some more specific reason to not allow logon.
        //

        Status = I_SamIAccountRestrictions(
                    UserHandle,
                    &LocalWorkstation,
                    (PUNICODE_STRING) &UserAll->WorkStations,
                    (PLOGON_HOURS) &UserAll->LogonHours,
                    &LogoffTime,
                    &KickoffTime );

        if ( !NT_SUCCESS(Status) ) {
            *Authoritative = TRUE;
            goto Cleanup;
        }

        //
        // If there is a SubAuthentication package zero, call it
        //

        if (NlpSubAuthZeroExists) {
            ULONG LocalUserFlags = 0;
            ULONG Flags = 0;

            if ( SecureChannelType != MsvApSecureChannel ) {
                Flags |= MSV1_0_PASSTHRU;
            }
            if ( GuestRelativeId != 0 ) {
                Flags |= MSV1_0_GUEST_LOGON;
            }

            Status = Msv1_0SubAuthenticationRoutineZero(
                        LogonLevel,
                        LogonInformation,
                        Flags,
                        (PUSER_ALL_INFORMATION) UserAll,
                        &WhichFields,
                        &LocalUserFlags,
                        Authoritative,
                        &LogoffTime,
                        &KickoffTime );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            //
            // Sanity check what the SubAuthentication package returned
            //

            if ( (WhichFields & ~USER_ALL_PARAMETERS) != 0 ) {
                Status = STATUS_INTERNAL_ERROR;
                *Authoritative = TRUE;
                goto Cleanup;
            }

            UserFlags |= LocalUserFlags;
        }
    }

    if ( AccountExpires.QuadPart != 0
         && KickoffTime.QuadPart > AccountExpires.QuadPart )
    {
         KickoffTime = AccountExpires;
    }

    //
    // If the account is a machine account,
    //  let the caller know he got the password right.
    //  (But don't let him actually log on).
    //

    // But, for NT 5.0, we must allow accounts with account control
    // USER_WORKSTATION_TRUST_ACCOUNT for remote boot clients who
    // will logon with their machine accounts

    if ( (UserAll->UserAccountControl & USER_MACHINE_ACCOUNT_MASK) != 0 ) {
        if (UserAll->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) {
            Status = STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT;
        } else if (UserAll->UserAccountControl &
                   USER_WORKSTATION_TRUST_ACCOUNT) {
            if ( (LogonInfo->ParameterControl & MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT) == 0) {
                Status = STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT;
            } else {

                UNICODE_STRING MachineAccountName;
                NTSTATUS TempStatus;

                //
                // if the password was correct, and it happened to match
                // the machine name, dis-allow it regardless.
                //

                //
                // Compute the lower case user name.
                //

                TempStatus = RtlDowncaseUnicodeString( &MachineAccountName,
                                                   (PUNICODE_STRING)&UserAll->UserName,
                                                   TRUE );

                if( NT_SUCCESS( TempStatus ) )
                {
                    USHORT LastChar = MachineAccountName.Length / sizeof(WCHAR);

                    if( LastChar )
                    {
                        if( MachineAccountName.Buffer[LastChar-1] == L'$' )
                        {
                            MachineAccountName.Length -= sizeof(WCHAR);
                        }

                        if( LastChar > LM20_PWLEN )
                        {
                            MachineAccountName.Length = LM20_PWLEN * sizeof(WCHAR);
                        }
                    }

                    if ( UserAll->NtPasswordPresent ) {

                        NT_OWF_PASSWORD NtOwfMachineName;
                        NT_OWF_PASSWORD *pOwf;

                        pOwf = ((PNT_OWF_PASSWORD)(UserAll->NtOwfPassword.Buffer));

                        RtlCalculateNtOwfPassword(
                                     &MachineAccountName,
                                     &NtOwfMachineName );

                        if ( RtlCompareMemory( pOwf,
                                               &NtOwfMachineName,
                                               NT_OWF_PASSWORD_LENGTH ) ==
                                               NT_OWF_PASSWORD_LENGTH ) {

                            Status = STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT;
                        }
                    }


                    RtlFreeUnicodeString( &MachineAccountName );
                }
            }
        } else if (UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) {
            if ( (LogonInfo->ParameterControl & MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT) == 0) {
                Status = STATUS_NOLOGON_SERVER_TRUST_ACCOUNT;
            } else {

                //
                // it's a server trust account.
                // treat same way as workstation trust account.

                UNICODE_STRING MachineAccountName;
                NTSTATUS TempStatus;

                // NOTE: some code here is duplicated from above.
                // this will be merged when a new Rtl has been added for
                // computing initial machine password from machine acct name.
                //

                //
                // if the password was correct, and it happened to match
                // the machine name, dis-allow it regardless.
                //

                //
                // Compute the lower case user name.
                //

                TempStatus = RtlDowncaseUnicodeString( &MachineAccountName,
                                                   (PUNICODE_STRING)&UserAll->UserName,
                                                   TRUE );

                if( NT_SUCCESS( TempStatus ) )
                {
                    USHORT LastChar = MachineAccountName.Length / sizeof(WCHAR);

                    if( LastChar )
                    {
                        if( MachineAccountName.Buffer[LastChar-1] == L'$' )
                        {
                            MachineAccountName.Length -= sizeof(WCHAR);
                        }

                        if( LastChar > LM20_PWLEN )
                        {
                            MachineAccountName.Length = LM20_PWLEN * sizeof(WCHAR);
                        }
                    }

                    if ( UserAll->NtPasswordPresent ) {

                        NT_OWF_PASSWORD NtOwfMachineName;
                        NT_OWF_PASSWORD *pOwf;

                        pOwf = ((PNT_OWF_PASSWORD)(UserAll->NtOwfPassword.Buffer));

                        RtlCalculateNtOwfPassword(
                                     &MachineAccountName,
                                     &NtOwfMachineName );

                        if ( RtlCompareMemory( pOwf,
                                               &NtOwfMachineName,
                                               NT_OWF_PASSWORD_LENGTH ) ==
                                               NT_OWF_PASSWORD_LENGTH ) {

                            Status = STATUS_NOLOGON_SERVER_TRUST_ACCOUNT;
                        }
                    }

                    RtlFreeUnicodeString( &MachineAccountName );
                }

                //
                // Let the client know that this was
                // a server trust account
                //

                UserFlags |= LOGON_SERVER_TRUST_ACCOUNT;
            }

        } else {
            Status = STATUS_NO_SUCH_USER;
        }
        if (!NT_SUCCESS(Status)) {
            *Authoritative = TRUE;
            goto Cleanup;
        }
    }

    //
    // don't allow blank password logons.
    //

    if(
        (RelativeId != DOMAIN_USER_RID_GUEST)
            &&
        (!NtLmGlobalAllowBlankPassword)
            &&
        (!UserAll->NtPasswordPresent || (RtlCompareMemory(
                                            &NlpNullNtOwfPassword,
                                            UserAll->NtOwfPassword.Buffer,
                                            NT_OWF_PASSWORD_LENGTH
                                            ) == NT_OWF_PASSWORD_LENGTH))
            &&
        (!UserAll->LmPasswordPresent || (RtlCompareMemory(
                                            &NlpNullLmOwfPassword,
                                            UserAll->LmOwfPassword.Buffer,
                                            LM_OWF_PASSWORD_LENGTH
                                            ) == LM_OWF_PASSWORD_LENGTH))
            &&
        ( ((NtLmCheckProcessOption( MSV1_0_OPTION_ALLOW_BLANK_PASSWORD )) & MSV1_0_OPTION_ALLOW_BLANK_PASSWORD) == 0 )
        )
    {
        *Authoritative = FALSE;
        Status = STATUS_ACCOUNT_RESTRICTION;
        goto Cleanup;
    }

    //
    // Filter the groups into global groups (from other domains) and local
    // groups (from this domain).
    //

    Status = MsvpFilterGroupMembership(
                &GroupMembership,
                LogonDomainId,
                &GroupsBuffer,
                &GlobalGroupMembership,
                &GlobalMembershipSize
                );

    if ( !NT_SUCCESS(Status) ) {
        *Authoritative = FALSE;
        goto Cleanup;
    }

Cleanup:

    if (NT_SUCCESS(Status) || fSubAuthEx)
    {
        UNICODE_STRING ReturnDnsDomainName;
        BOOLEAN UseDefaultUpn = FALSE;

        //
        // Allocate a return buffer for validation information.
        //  (Return less information for a network logon)
        //  (Return UserParameters for a MNS logon)
        //

        ValidationSamSize = sizeof( NETLOGON_VALIDATION_SAM_INFO4 ) +
                GroupsBuffer.MembershipCount * sizeof(GROUP_MEMBERSHIP) +
                LogonDomainName->Length + sizeof(WCHAR) +
                LogonServer->Length + sizeof(WCHAR) +
                RtlLengthSid( LogonDomainId );

        //
        // all logon types get the username, as, this could be mapped
        // to guest account, for instance, and logon session needs correct
        // names.
        //

        ValidationSamSize +=
            UserAll->UserName.Length + sizeof(WCHAR) ;

        if ( LogonLevel != NetlogonNetworkInformation ) {
            ValidationSamSize +=
                UserAll->FullName.Length + sizeof(WCHAR) +
                UserAll->ScriptPath.Length + sizeof(WCHAR)+
                UserAll->ProfilePath.Length + sizeof(WCHAR) +
                UserAll->HomeDirectory.Length + sizeof(WCHAR) +
                UserAll->HomeDirectoryDrive.Length + sizeof(WCHAR);
        }

        if ( LogonInfo->ParameterControl & MSV1_0_RETURN_USER_PARAMETERS ) {
            ValidationSamSize +=
                UserAll->Parameters.Length + sizeof(WCHAR);
        } else if ( LogonInfo->ParameterControl & MSV1_0_RETURN_PROFILE_PATH ) {
            ValidationSamSize +=
                UserAll->ProfilePath.Length + sizeof(WCHAR);
        }

        //
        // If the caller can handle extra groups, let them have the groups from
        // other domains.
        //

        if ( ValidationLevel == NetlogonValidationSamInfo2 ||
             ValidationLevel == NetlogonValidationSamInfo4 ) {
            ValidationSamSize += GlobalMembershipSize;
        }

        //
        // If the caller wants the logon domain in DNS and UPN form,
        //  grab it.
        //

        if ( ValidationLevel == NetlogonValidationSamInfo4 ) {

            //
            // Grab the dns name of the account domain.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if( NlpWorkstation ) {
                //ReturnDnsDomainName = NtLmGlobalUnicodeDnsComputerNameString;
                //
                // for local accounts, DnsDomainName doesn't exist.
                //

                RtlInitUnicodeString( &ReturnDnsDomainName, L"" );
            } else {
                ReturnDnsDomainName = NtLmGlobalUnicodeDnsDomainNameString;
            }

            ValidationSamSize += ReturnDnsDomainName.Length + sizeof(WCHAR);

            //
            // If we couldn't get the UPN from SAM,
            //  build the default one.
            //

            if( Upn.Buffer != NULL )
            {
                UseDefaultUpn = FALSE;

                ValidationSamSize += (Upn.Length + sizeof(WCHAR));

            } else {
                UseDefaultUpn = TRUE;

                if ( !NlpWorkstation )
                {
                    ValidationSamSize +=
                        UserAll->UserName.Length +
                        sizeof(WCHAR) +
                        ReturnDnsDomainName.Length + sizeof(WCHAR);
                }
            }
        }

        ValidationSamSize = ROUND_UP_COUNT( ValidationSamSize, sizeof(WCHAR) );

        ValidationSam = MIDL_user_allocate( ValidationSamSize );

        if ( ValidationSam == NULL ) {
            *Authoritative = FALSE;
            fSubAuthEx = FALSE; // avoid nasty loop condition
            Status = STATUS_NO_MEMORY;
            RtlReleaseResource(&NtLmGlobalCritSect);
            goto Cleanup;
        }

        //
        // Default unused fields (and ExpansionRoom) to zero.
        //

        RtlZeroMemory( ValidationSam, ValidationSamSize );

        //
        // Copy the scalars to the validation buffer.
        //

        Where = (PUCHAR) (ValidationSam + 1);

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_LOGOFF_TIME) != 0) {
            NEW_TO_OLD_LARGE_INTEGER( SubAuthValidationInformation.LogoffTime, ValidationSam->LogoffTime );
        }
        else {
            NEW_TO_OLD_LARGE_INTEGER( LogoffTime, ValidationSam->LogoffTime );
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_KICKOFF_TIME) != 0) {
            NEW_TO_OLD_LARGE_INTEGER( SubAuthValidationInformation.KickoffTime, ValidationSam->KickOffTime );
        }
        else {
            NEW_TO_OLD_LARGE_INTEGER( KickoffTime, ValidationSam->KickOffTime );
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_SESSION_KEY) != 0) {
                ValidationSam->UserSessionKey = SubAuthValidationInformation.SessionKey;
        }
        else {
            ValidationSam->UserSessionKey = UserSessionKey;
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_USER_FLAGS) != 0) {
            ValidationSam->UserFlags = SubAuthValidationInformation.UserFlags;
        }
        else {
            ValidationSam->UserFlags = UserFlags;
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_USER_ID) != 0) {
            ValidationSam->UserId = SubAuthValidationInformation.UserId;
        }
        else {
            ValidationSam->UserId = UserAll->UserId;
        }
        ValidationSam->LogonTime = UserAll->LastLogon;
        ValidationSam->PasswordLastSet = UserAll->PasswordLastSet;
        ValidationSam->PasswordCanChange = UserAll->PasswordCanChange;
        ValidationSam->PasswordMustChange = UserAll->PasswordMustChange;

        ValidationSam->LogonCount = UserAll->LogonCount;
        ValidationSam->BadPasswordCount = UserAll->BadPasswordCount;
        ValidationSam->PrimaryGroupId = UserAll->PrimaryGroupId;
        ValidationSam->GroupCount = GroupsBuffer.MembershipCount;
        ASSERT( SAMINFO_LM_SESSION_KEY_SIZE == sizeof(LmSessionKey) );
        RtlCopyMemory( &ValidationSam->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
                   &LmSessionKey,
                   SAMINFO_LM_SESSION_KEY_SIZE );
        ValidationSam->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] = UserAll->UserAccountControl;

        // Save any status for subuath users not returned by the subauth package

        if (fSubAuthEx)
        {
            ValidationSam->ExpansionRoom[SAMINFO_SUBAUTH_STATUS] = Status;
        }

        //
        // Copy ULONG aligned data to the validation buffer.
        //

        RtlCopyMemory(
            Where,
            GroupsBuffer.Groups,
            GroupsBuffer.MembershipCount * sizeof(GROUP_MEMBERSHIP) );

        ValidationSam->GroupIds = (PGROUP_MEMBERSHIP) Where;
        Where += GroupsBuffer.MembershipCount * sizeof(GROUP_MEMBERSHIP);

        RtlCopyMemory(
            Where,
            LogonDomainId,
            RtlLengthSid( LogonDomainId ) );

        ValidationSam->LogonDomainId = (PSID) Where;
        Where += RtlLengthSid( LogonDomainId );

        //
        // If the client asked for extra information, return that
        // we support it
        //

        if ( ValidationLevel == NetlogonValidationSamInfo2 ||
             ValidationLevel == NetlogonValidationSamInfo4 ) {

            ValidationSam->UserFlags |= LOGON_EXTRA_SIDS;
            if (GlobalMembershipSize != 0) {
                ULONG SidLength;

                ValidationSam->SidCount = GlobalGroupMembership.Count;
                ValidationSam->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) Where;
                Where += ValidationSam->SidCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES);

                //
                // Copy all the extra sids into the buffer
                //

                for (Index = 0; Index < ValidationSam->SidCount ; Index++ ) {
                    ValidationSam->ExtraSids[Index].Attributes = GlobalGroupMembership.SidAndAttributes[Index].Attributes;
                    ValidationSam->ExtraSids[Index].Sid = Where;
                    SidLength = RtlLengthSid(GlobalGroupMembership.SidAndAttributes[Index].Sid);
                    RtlCopyMemory(
                        ValidationSam->ExtraSids[Index].Sid,
                        GlobalGroupMembership.SidAndAttributes[Index].Sid,
                        SidLength
                        );

                    Where += SidLength;
                }
            }
        }

        //
        // Copy WCHAR aligned data to the validation buffer.
        //  (Return less information for a network logon)
        //

        Where = ROUND_UP_POINTER( Where, sizeof(WCHAR) );

        NlpPutString( &ValidationSam->EffectiveName,
                      (PUNICODE_STRING)&UserAll->UserName,
                      &Where );

        if ( LogonLevel != NetlogonNetworkInformation ) {

            NlpPutString( &ValidationSam->FullName,
                          (PUNICODE_STRING)&UserAll->FullName,
                          &Where );

            NlpPutString( &ValidationSam->LogonScript,
                          (PUNICODE_STRING)&UserAll->ScriptPath,
                          &Where );

            NlpPutString( &ValidationSam->ProfilePath,
                          (PUNICODE_STRING)&UserAll->ProfilePath,
                          &Where );

            NlpPutString( &ValidationSam->HomeDirectory,
                          (PUNICODE_STRING)&UserAll->HomeDirectory,
                          &Where );

            NlpPutString( &ValidationSam->HomeDirectoryDrive,
                          (PUNICODE_STRING)&UserAll->HomeDirectoryDrive,
                          &Where );

        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_LOGON_SERVER) != 0) {
            NlpPutString( &ValidationSam->LogonServer,
                          &SubAuthValidationInformation.LogonServer,
                          &Where );
        }
        else {
            NlpPutString( &ValidationSam->LogonServer,
                          LogonServer,
                          &Where );

        }
        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_LOGON_DOMAIN) != 0) {
            NlpPutString( &ValidationSam->LogonDomainName,
                          &SubAuthValidationInformation.LogonDomainName,
                          &Where );
        }
        else {
            NlpPutString( &ValidationSam->LogonDomainName,
                          LogonDomainName,
                          &Where );
        }

        //
        // If the caller wants the logon domain in DNS and UPN form,
        //  return them.
        //

        if ( ValidationLevel == NetlogonValidationSamInfo4 ) {

            //
            // Copy the DNS domain name into the allocated buffer
            //

            NlpPutString( &ValidationSam->DnsLogonDomainName,
                          &ReturnDnsDomainName,
                          &Where );

            //
            // If we couldn't get the UPN from SAM,
            //  copy the default one into the buffer.
            //

            if ( !NlpWorkstation )
            {
                if( UseDefaultUpn )
                {
                    UNICODE_STRING TempString1;
                    UNICODE_STRING TempString2;
                    UNICODE_STRING TempString3;
                    UNICODE_STRING AtString;

                    NlpPutString( &TempString1,
                                  (PUNICODE_STRING)&UserAll->UserName,
                                  &Where );
                    Where -= sizeof(WCHAR);

                    RtlInitUnicodeString( &AtString, L"@" );
                    NlpPutString( &TempString2,
                                  &AtString,
                                  &Where );
                    Where -= sizeof(WCHAR);

                    NlpPutString( &TempString3,
                                  &ReturnDnsDomainName,
                                  &Where );

                    ValidationSam->Upn.Buffer = TempString1.Buffer;
                    ValidationSam->Upn.Length =
                        TempString1.Length +
                        TempString2.Length +
                        TempString3.Length;
                    ValidationSam->Upn.MaximumLength = ValidationSam->Upn.Length + sizeof(WCHAR);
                } else {
                    UNICODE_STRING TempString1;

                    NlpPutString( &TempString1,
                                  &Upn,
                                  &Where );
                    Where -= sizeof(WCHAR);

                    ValidationSam->Upn.Buffer = TempString1.Buffer;
                    ValidationSam->Upn.Length = TempString1.Length;
                    ValidationSam->Upn.MaximumLength = ValidationSam->Upn.Length;
                }
            }

            //
            // Drop the lock that we've held since we grabbed pointer to the globals
            //
            RtlReleaseResource(&NtLmGlobalCritSect);
        }

        //
        // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
        // can't change the NETLOGON_VALIDATION_SAM_INFO structure between
        // releases NT 3.1 and NT 3.5. HomeDirectoryDrive was NULL for release 3.1
        // so we'll use that field.
        //

        if ( LogonInfo->ParameterControl & MSV1_0_RETURN_USER_PARAMETERS ) {
            NlpPutString( &ValidationSam->HomeDirectoryDrive,
                          (PUNICODE_STRING)&UserAll->Parameters,
                          &Where );
        } else if ( LogonInfo->ParameterControl & MSV1_0_RETURN_PROFILE_PATH ) {
            NlpPutString( &ValidationSam->HomeDirectoryDrive,
                          (PUNICODE_STRING)&UserAll->ProfilePath,
                          &Where );
            ValidationSam->UserFlags |= LOGON_PROFILE_PATH_RETURNED;
        }

        *Authoritative = TRUE;

        //
        // For SubAuthEx, we save away the original Status to make decisions
        // later on about additional processing to perform.
        //

        if( fSubAuthEx ) {
            SubAuthExStatus = Status;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Cleanup up before returning.
    //

    //
    // If the User Parameters have been changed,
    //  write them back to SAM.
    //

    if ( NT_SUCCESS(Status) &&
        (WhichFields & USER_ALL_PARAMETERS) )
    {
        SAMPR_USER_INFO_BUFFER UserInfo;

        UserInfo.Parameters.Parameters = UserAll->Parameters;

        Status = I_SamrSetInformationUser(
                        UserHandle,
                        UserParametersInformation,
                        &UserInfo );
    }

    //
    // Update the logon statistics.
    //

    if ( NT_SUCCESS( SubAuthExStatus ) &&
        (  NT_SUCCESS(Status)
        || Status == STATUS_WRONG_PASSWORD
        || Status == STATUS_NO_LOGON_SERVERS ) ) {

        SAM_LOGON_STATISTICS LogonStats;

        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        if ( NT_SUCCESS( Status ) ) {
            if ( LogonLevel == NetlogonInteractiveInformation ) {
                LogonStats.StatisticsToApply =
                    USER_LOGON_INTER_SUCCESS_LOGON;
            } else {

                //
                // On network logons,
                //  only update the statistics on 'success' if explicitly asked,
                //  or the Bad Password count will be zeroed.
                //
                LogonStats.StatisticsToApply =
                    USER_LOGON_NET_SUCCESS_LOGON | USER_LOGON_NO_WRITE;

                if ( (LogonInfo->ParameterControl & MSV1_0_UPDATE_LOGON_STATISTICS) ||
                     UserAll->BadPasswordCount != 0 ) {

                    LogonStats.StatisticsToApply &= ~USER_LOGON_NO_WRITE;
                }
            }

            // Tell the caller we zeroed the bad password count
            if ( UserAll->BadPasswordCount != 0 ) {
                *BadPasswordCountZeroed = TRUE;
            }

        } else {

            if (Status == STATUS_WRONG_PASSWORD) {
                LogonStats.StatisticsToApply = USER_LOGON_BAD_PASSWORD_WKSTA;
                LogonStats.Workstation = LogonInfo->Workstation;

                //
                // if it didn't match one of the (two) previous, it was a bad password.
                //

                if(!MsvpCheckPreviousPassword(
                                UasCompatibilityRequired,
                                LogonLevel,
                                LogonInformation,
                                DomainHandle,
                                &LocalUserName
                                ))
                {
                    LogonStats.StatisticsToApply |= USER_LOGON_BAD_PASSWORD; 
                }


            } else {
                LogonStats.StatisticsToApply = USER_LOGON_NO_LOGON_SERVERS;
                if (LogonLevel == NetlogonInteractiveInformation) {
                    LogonStats.StatisticsToApply |= USER_LOGON_INTER_FAILURE;
                }
            }
        }

        if ( LogonStats.StatisticsToApply != 0 ) {
            NTSTATUS LogonStatus;

            LogonStats.StatisticsToApply |= USER_LOGON_TYPE_NTLM;

            LogonStatus = I_SamIUpdateLogonStatistics(
                                          UserHandle,
                                         &LogonStats );
        }
    }

    //
    // Audit this logon. We don't audit failures for the guest account because
    // they are so frequent.
    //

    if (GuestRelativeId == 0 || NT_SUCCESS(Status)) {
        NTSTATUS AuditStatus;

        AuditStatus = Status;

        //
        // if there was a possibly un-successful SubAuthEx status, use it
        //

        if( NT_SUCCESS( AuditStatus ) && fSubAuthEx ) {

            AuditStatus = SubAuthExStatus;
        }

        if ( ValidationSam ) {
            
            UserSid = NlpMakeDomainRelativeSid(
                          ValidationSam->LogonDomainId,
                          ValidationSam->UserId
                          );
        } else {

            UserSid = NULL;
        }
        
        I_LsaIAuditAccountLogonEx(
            SE_AUDITID_ACCOUNT_LOGON,
            (BOOLEAN) NT_SUCCESS(AuditStatus),
            &NlpMsv1_0PackageName,
            &LocalUserName,
            &LogonInfo->Workstation,
            AuditStatus,
            UserSid
            );

        if ( ValidationSam && UserSid ) {

            LsaFunctions->FreeLsaHeap( UserSid );
            UserSid = NULL;
        }

    }

    //
    // Return the validation buffer to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        if (ValidationSam != NULL) {
            MIDL_user_free( ValidationSam );
            ValidationSam = NULL;
        }
    }

    *ValidationInformation = ValidationSam;

    //
    // Free locally used resources.
    //

    I_SamIFree_SAMPR_RETURNED_USTRING_ARRAY( &NameArray );
    I_SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

    if ( UserAllInfo != NULL ) {
        I_SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if( Upn.Buffer != NULL )
    {
        I_SamIFreeVoid( Upn.Buffer );
    }

    if (GroupMembership.SidAndAttributes != NULL)
    {
        I_SamIFreeSidAndAttributesList(&GroupMembership);
    }

    if ( GroupsBuffer.Groups != NULL ) {
        I_NtLmFree(GroupsBuffer.Groups);
    }

    if ( GlobalGroupMembership.SidAndAttributes != NULL ) {
        I_NtLmFree(GlobalGroupMembership.SidAndAttributes);
    }

    if ( UserHandle != NULL ) {
        I_SamrCloseHandle( &UserHandle );
    }

    if (SubAuthValidationInformation.LogonDomainName.Buffer != NULL) {
        MIDL_user_free(SubAuthValidationInformation.LogonDomainName.Buffer);
    }
    if (SubAuthValidationInformation.LogonServer.Buffer != NULL) {
        MIDL_user_free(SubAuthValidationInformation.LogonServer.Buffer);
    }

    if (LocalSidUser != NULL) {
        I_NtLmFree(LocalSidUser);
    }

    return Status;
}

BOOLEAN
MsvpCheckPreviousPassword(
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN SAMPR_HANDLE DomainHandle,
    PUNICODE_STRING UserName
    )
{
    PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PrivateData;
    NTSTATUS Status;
    
    SAMPR_HANDLE UserHandle = NULL;

    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL;
    SID_AND_ATTRIBUTES_LIST GroupMembership;
     
    USER_INTERNAL1_INFORMATION Passwords;
    NT_OWF_PASSWORD OldPasswordData = {0};             // Previous password
    NT_OWF_PASSWORD OldPasswordDataSecond = {0};       // Previous previous password

    USER_SESSION_KEY UserSessionKey;
    LM_SESSION_KEY LmSessionKey;
    ULONG UserFlags;

    BOOLEAN TryPrevious = FALSE;
    BOOLEAN TryPreviousPrevious = FALSE;
    BOOLEAN fMatchesOld = FALSE;


    GroupMembership.SidAndAttributes = NULL;

    //
    // query the account, to get the PRIVATEDATA  ( password history ).
    //

    Status = I_SamIGetUserLogonInformationEx(
                DomainHandle,
                SAM_NO_MEMBERSHIPS,
                UserName,
                USER_ALL_USERID | USER_ALL_PRIVATEDATA | USER_ALL_OWFPASSWORD,
                &UserAllInfo,
                &GroupMembership,
                &UserHandle
                );

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    UserAll = &UserAllInfo->All;

    if (UserAll->PrivateData.Length >= sizeof(SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE))
    {
        PrivateData= (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE) UserAll->PrivateData.Buffer;
        
        if (PrivateData->DataType == SamPrivateDataPassword)
        {
            //
            // The old password is the 2nd entry
            //

            if (PrivateData->NtPasswordHistory.Length >= 2* sizeof(ENCRYPTED_NT_OWF_PASSWORD))
            {
                //
                // Decrypt the old password with the RID. The history starts
                // at the first byte after the structure.
                //

                Status = RtlDecryptNtOwfPwdWithIndex(
                            (PENCRYPTED_NT_OWF_PASSWORD) (PrivateData + 1) + 1,
                            (PLONG)&UserAll->UserId,
                            &OldPasswordData
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }
            
            
                TryPrevious = TRUE;
            }
        
            // Now check for the second previous password - this will be the third password in history
            if (PrivateData->NtPasswordHistory.Length >= 3 * sizeof(ENCRYPTED_NT_OWF_PASSWORD))
            {
                //
                // Decrypt the old password with the RID. The history starts
                // at the first byte after the structure.
                //

                Status = RtlDecryptNtOwfPwdWithIndex(
                            (PENCRYPTED_NT_OWF_PASSWORD) (PrivateData + 1) + 2,
                            (PLONG)&UserAll->UserId,
                            &OldPasswordDataSecond
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                TryPreviousPrevious = TRUE;
                
            }

        }
    }


    //
    // call password validate for each.
    //


    Passwords.NtPasswordPresent = TRUE;
    Passwords.LmPasswordPresent = FALSE;

    if( TryPrevious )
    {
        CopyMemory( &(Passwords.NtOwfPassword), &OldPasswordData, sizeof(OldPasswordData) );
        
        //
        // If the password specified doesn't match the SAM password,
        //    then we've got a password mismatch.
        //
    
        if ( MsvpPasswordValidate (
                    UasCompatibilityRequired,
                    LogonLevel,
                    LogonInformation,
                    &Passwords,
                    &UserFlags,
                    &UserSessionKey,
                    &LmSessionKey ) )
        {
        
            RtlSecureZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
            RtlSecureZeroMemory( &LmSessionKey, sizeof(LmSessionKey) );
    
            fMatchesOld = TRUE;
            goto Cleanup;
        }
    }


    if( TryPreviousPrevious )
    {

        CopyMemory( &(Passwords.NtOwfPassword), &OldPasswordDataSecond, sizeof(OldPasswordDataSecond) );
        
        //
        // If the password specified doesn't match the SAM password,
        //    then we've got a password mismatch.
        //
    
        if ( MsvpPasswordValidate (
                    UasCompatibilityRequired,
                    LogonLevel,
                    LogonInformation,
                    &Passwords,
                    &UserFlags,
                    &UserSessionKey,
                    &LmSessionKey ) )
        {
        
            RtlSecureZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
            RtlSecureZeroMemory( &LmSessionKey, sizeof(LmSessionKey) );
    
            fMatchesOld = TRUE;
            goto Cleanup;
        }

    }


Cleanup:


    RtlSecureZeroMemory( &OldPasswordData, sizeof(OldPasswordData) );
    RtlSecureZeroMemory( &OldPasswordDataSecond, sizeof(OldPasswordDataSecond) );
    RtlSecureZeroMemory( &(Passwords.NtOwfPassword), sizeof(Passwords.NtOwfPassword) );


    if (GroupMembership.SidAndAttributes != NULL)
    {
        I_SamIFreeSidAndAttributesList(&GroupMembership);
    }

    if ( UserAllInfo != NULL ) {
        I_SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if ( UserHandle != NULL ) {
        I_SamrCloseHandle( &UserHandle );
    }

    return fMatchesOld;
}



NTSTATUS
MsvSamValidate (
    IN SAM_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed,
    IN DWORD AccountsToTry
)
/*++

Routine Description:

    Process an interactive, network, or session logon.  It calls
    SamIUserValidation, validates the passed in credentials, updates the logon
    statistics and packages the result for return to the caller.

    This routine is called directly from the MSV Authentication package
    if the account is defined locally.  This routine is called
    from the Netlogon Service otherwise.

Arguments:

    DomainHandle -- Specifies a handle to the SamDomain to use to
        validate the request.

    UasCompatibilityRequired -- TRUE if UasCompatibilityRequired is on.

    SecureChannelType -- The secure channel type this request was made on.

    LogonServer -- Specifies the server name of the caller.

    LogonDomainName -- Specifies the domain of the caller.

    LogonDomainId  -- Specifies the DomainId of the domain of the caller.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed user MIDL_user_free.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    BadPasswordCountZeroed - Returns TRUE if we zeroed the BadPasswordCount
        field of this user.

    AccountsToTry -- Specifies whether the username specified in
        LogonInformation is to be used to logon, whether to guest account
        is to be used to logon, or both serially.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_INVALID_INFO_CLASS: LogonLevel or ValidationLevel are invalid.
    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    Other return codes from SamIUserValidation

--*/
{
    NTSTATUS Status;
    NTSTATUS GuestStatus;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    //
    // Tracing
    //
    NTLM_TRACE_INFO TraceInfo = {0};

    //
    // Begin tracing a sam validate call for NTLM
    //
    if (NtlmGlobalEventTraceFlag){


        //Header goo
        SET_TRACE_HEADER(TraceInfo,
                         NtlmValidateGuid,
                         EVENT_TRACE_TYPE_START,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    //
    // if simple file/print option is enabled (applies to SSPI callers),
    // check if ForceGuest should occur.
    //

    if( (LogonInfo->ParameterControl & MSV1_0_ALLOW_FORCE_GUEST) )
    {
        if( NtLmGlobalForceGuest )
        {
            if((LogonInfo->ParameterControl & MSV1_0_DISABLE_PERSONAL_FALLBACK)==0)
            {
                if( (LogonLevel == NetlogonNetworkInformation) &&
                    (((NtLmCheckProcessOption( MSV1_0_OPTION_DISABLE_FORCE_GUEST ) & MSV1_0_OPTION_DISABLE_FORCE_GUEST )) == 0)
                    )
                {
                    AccountsToTry &= ~(MSVSAM_SPECIFIED);
                    AccountsToTry |= MSVSAM_GUEST;
                }
            }
        }
    }

    //
    // Validate the specified user.
    //
    *BadPasswordCountZeroed = FALSE;

    if ( AccountsToTry & MSVSAM_SPECIFIED ) {

        //
        // Keep track of the total number of logons attempted.
        //

        I_SamIIncrementPerformanceCounter(
            MsvLogonCounter
            );
        InterlockedIncrement((LPLONG) &NlpLogonAttemptCount);

        Status = MsvpSamValidate( (SAMPR_HANDLE) DomainHandle,
                                  UasCompatibilityRequired,
                                  SecureChannelType,
                                  LogonServer,
                                  LogonDomainName,
                                  LogonDomainId,
                                  LogonLevel,
                                  LogonInformation,
                                  0,
                                  ValidationLevel,
                                  ValidationInformation,
                                  Authoritative,
                                  BadPasswordCountZeroed );


        //
        // If the SAM database authoritatively handled this logon attempt,
        //  just return.
        //

        if ( *Authoritative ) {
            goto Cleanup;
        }

    //
    // If the caller only wants to log on as guest,
    //  Pretend the first validation simply didn't find the user.
    //
    } else {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
    }

    //
    // If guest accounts are not allowed,
    //  return now.
    //

    if ( LogonLevel != NetlogonNetworkInformation ||
        SecureChannelType != MsvApSecureChannel ||
        ( LogonInfo->ParameterControl & MSV1_0_DONT_TRY_GUEST_ACCOUNT ) ||
        (AccountsToTry & MSVSAM_GUEST) == 0 ) {

        goto Cleanup;
        //return Status;
    }

    //
    // Try the Guest Account.
    //

    GuestStatus = MsvpSamValidate( (SAMPR_HANDLE) DomainHandle,
                                   UasCompatibilityRequired,
                                   SecureChannelType,
                                   LogonServer,
                                   LogonDomainName,
                                   LogonDomainId,
                                   LogonLevel,
                                   LogonInformation,
                                   DOMAIN_USER_RID_GUEST,
                                   ValidationLevel,
                                   ValidationInformation,
                                   Authoritative,
                                   BadPasswordCountZeroed );

    if ( NT_SUCCESS(GuestStatus) ) {
        PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo;

        ASSERT ((ValidationLevel == NetlogonValidationSamInfo) ||
                (ValidationLevel == NetlogonValidationSamInfo2) ||
                (ValidationLevel == NetlogonValidationSamInfo4) );
        ValidationInfo =
            (PNETLOGON_VALIDATION_SAM_INFO4) *ValidationInformation;
        ValidationInfo->UserFlags |= LOGON_GUEST;

        Status = GuestStatus;
        goto Cleanup;
        //return GuestStatus;
    }

    //
    // Failed Guest logon attempts are never authoritative and the status from
    // the original logon attempt is more significant than the Guest logon
    // status.
    //
    *Authoritative = FALSE;
Cleanup:

    //
    // Trace the end of this call
    //
    if (NtlmGlobalEventTraceFlag){
        UINT32 Success;
        PNETLOGON_LOGON_IDENTITY_INFO LogonInfo =
            (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

        SET_TRACE_HEADER(TraceInfo,
                         NtlmValidateGuid,
                         EVENT_TRACE_TYPE_END,
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                         9);
        //
        // Build the "success" trace state bit mask
        // 1bit - Success
        // 2bit - Authoritative
        //
        Success = (Status == STATUS_SUCCESS)?1:0;
        Success |= (*Authoritative)?2:0;

        SET_TRACE_DATA(TraceInfo,
                        TRACE_VALIDATE_SUCCESS,
                        Success);

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_SERVER,
                        (*LogonServer));

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_DOMAIN,
                        (*LogonDomainName));

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_USERNAME,
                        LogonInfo->UserName);

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_WORKSTATION,
                        LogonInfo->Workstation);

        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }

    return Status;
}


NTSTATUS
MsvSamLogoff (
    IN SAM_HANDLE DomainHandle,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation
)
/*++

Routine Description:

    Process an interactive, network, or session logoff.  It simply updates
    the logon statistics for the user account.

    This routine is called directly from the MSV Authentication package
    if the user was logged on not using the Netlogon service.  This routine
    is called from the Netlogon Service otherwise.

Arguments:

    DomainHandle -- Specifies a handle to the SamDomain containing
        the user to logoff.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_INVALID_INFO_CLASS: LogonLevel or ValidationLevel are invalid.
    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    Other return codes from SamIUserValidation

--*/
{
    return(STATUS_SUCCESS);
    UNREFERENCED_PARAMETER( DomainHandle );
    UNREFERENCED_PARAMETER( LogonLevel );
    UNREFERENCED_PARAMETER( LogonInformation );
}


ULONG
MsvGetLogonAttemptCount (
    VOID
)
/*++

Routine Description:

    Return the number of logon attempts since the last reboot.

Arguments:

    NONE

Return Value:

    Returns the number of logon attempts since the last reboot.

--*/
{

    //
    // Keep track of the total number of logons attempted.
    //

    return NlpLogonAttemptCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msvwow.cxx ===
#if _WIN64

#include <global.h>
#include "msp.h"
#include "nlp.h"

#include "msvwow.h"


#define RELOCATE_WOW_UNICODE_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPWSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);

#define RELOCATE_WOW_ANSI_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);


//+-------------------------------------------------------------------------
//
//  Function:   MsvPutWOWString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
MsvPutWOWString(
    IN PUNICODE_STRING        InputString,
    OUT PUNICODE_STRING_WOW64 OutputString,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = PtrToUlong (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   MsvPutWOWClientString
//
//  Synopsis:   Copies a string into a buffer that will be copied to the
//              32-bit client's address space
//
//  Effects:
//
//  Arguments:  Where - Location in local buffer to place string.
//              OutString - Receives 'put' string
//              InString - String to 'put'
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutClientString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------


VOID
MsvPutWOWClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING_WOW64 OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    ClientBufferDesc->StringOffset, and fixes the OutString string to point
    to that new copy.


Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    InString - A pointer to an NT string to be copied

    OutString - A pointer to a destination NT string.  This string structure
        is in the "Mirror" allocated buffer.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{

    //
    // Ensure our caller passed good data.
    //

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( COUNT_IS_ALIGNED( ClientBufferDesc->StringOffset, sizeof(WCHAR)) );
    ASSERT( (LPBYTE)OutString >= ClientBufferDesc->MsvBuffer );
    ASSERT( (LPBYTE)OutString <
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->TotalSize - sizeof(UNICODE_STRING) );

    ASSERT( ClientBufferDesc->StringOffset + InString->Length + sizeof(WCHAR) <=
            ClientBufferDesc->TotalSize );

#ifdef notdef
    KdPrint(("NlpPutClientString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  Orig: UserBuffer: %lx Offset: 0x%lx TotalSize: 0x%lx\n",
                ClientBufferDesc->UserBuffer,
                ClientBufferDesc->StringOffset,
                ClientBufferDesc->TotalSize ));
#endif

    //
    // Build a string structure and copy the text to the Mirror buffer.
    //

    if ( InString->Length > 0 ) {

        ULONG_PTR TmpPtr;

        //
        // Copy the string (Add a zero character)
        //

        RtlCopyMemory(
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset,
            InString->Buffer,
            InString->Length );

        // Do one byte at a time since some callers don't pass in an even
        // InString->Length
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length) = '\0';
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length+1) = '\0';

        //
        // Build the string structure to point to the data in the client's
        // address space.
        //

        TmpPtr = (ULONG_PTR)(ClientBufferDesc->UserBuffer +
                                    ClientBufferDesc->StringOffset);

        OutString->Buffer = (ULONG)TmpPtr;
        OutString->Length = InString->Length;
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);

        //
        // Adjust the offset to past the newly copied string.
        //

        ClientBufferDesc->StringOffset += OutString->MaximumLength;

    } else {
        ZeroMemory( OutString, sizeof(*OutString) );
    }


    return;

}


//+-------------------------------------------------------------------------
//
//  Function:   MsvConvertWOWInteractiveLogonBuffer
//
//  Synopsis:   Converts logon buffers passed in from WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit logon buffer
//              pSubmitBufferSize    -- size of the 32-bit logon buffer
//              MessageType          -- format of the logon buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it.
//
//
//--------------------------------------------------------------------------

NTSTATUS
MsvConvertWOWInteractiveLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    PMSV1_0_INTERACTIVE_LOGON       Logon;
    PMSV1_0_INTERACTIVE_LOGON_WOW64 LogonWOW;
    DWORD                           dwOffset;
    DWORD                           dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Scale up the size and add on 3 PVOIDs for the worst-case
    // scenario to align the three embedded UNICODE_STRINGs
    //

    dwBufferSize += sizeof(MSV1_0_INTERACTIVE_LOGON)
                        - sizeof(MSV1_0_INTERACTIVE_LOGON_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_INTERACTIVE_LOGON))
    {
#if 0
        DebugLog((DEB_ERROR,
                  "Submit buffer to logon too small: %d. %ws, line %d\n",
                  dwBufferSize,
                  THIS_FILE,
                  __LINE__));
#endif
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = NtLmAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Logon    = (PMSV1_0_INTERACTIVE_LOGON) pTempBuffer;
    LogonWOW = (PMSV1_0_INTERACTIVE_LOGON_WOW64) ProtocolSubmitBuffer;

    Logon->MessageType = LogonWOW->MessageType;

    dwOffset    = sizeof(MSV1_0_INTERACTIVE_LOGON);
    dwWOWOffset = sizeof(MSV1_0_INTERACTIVE_LOGON_WOW64);


    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) Logon + dwOffset,
                  (LPBYTE) LogonWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                Logon->LogonDomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                Logon->UserName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->Password,
                                Logon->Password,
                                dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        NtLmFreePrivateHeap(pTempBuffer);
    }

    return Status;
}

NTSTATUS
MsvConvertWOWNetworkLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    PMSV1_0_LM20_LOGON              Logon;
    PMSV1_0_LM20_LOGON_WOW64        LogonWOW;
    DWORD                           dwOffset;
    DWORD                           dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Scale up the size and add on 5 PVOIDs for the worst-case
    // scenario to align the three embedded UNICODE_STRINGs
    //

    dwBufferSize += sizeof(MSV1_0_LM20_LOGON)
                        - sizeof(MSV1_0_LM20_LOGON_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_LM20_LOGON))
    {
#if 0
        DebugLog((DEB_ERROR,
                  "Submit buffer to logon too small: %d. %ws, line %d\n",
                  dwBufferSize,
                  THIS_FILE,
                  __LINE__));
#endif
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = NtLmAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Logon    = (PMSV1_0_LM20_LOGON) pTempBuffer;
    LogonWOW = (PMSV1_0_LM20_LOGON_WOW64) ProtocolSubmitBuffer;

    //
    // copy fixed fields.
    //

    Logon->MessageType      = LogonWOW->MessageType;
    Logon->ParameterControl = LogonWOW->ParameterControl;

    RtlCopyMemory(Logon->ChallengeToClient, LogonWOW->ChallengeToClient, MSV1_0_CHALLENGE_LENGTH);

    dwOffset    = sizeof(MSV1_0_LM20_LOGON);
    dwWOWOffset = sizeof(MSV1_0_LM20_LOGON_WOW64);

    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) Logon + dwOffset,
                  (LPBYTE) LogonWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                Logon->LogonDomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                Logon->UserName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->Workstation,
                                Logon->Workstation,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_ANSI_STRING(LogonWOW->CaseSensitiveChallengeResponse,
                             Logon->CaseSensitiveChallengeResponse,
                             dwOffset - dwWOWOffset);

    RELOCATE_WOW_ANSI_STRING(LogonWOW->CaseInsensitiveChallengeResponse,
                             Logon->CaseInsensitiveChallengeResponse,
                             dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        NtLmFreePrivateHeap(pTempBuffer);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   MsvConvertWOWChangePasswordBuffer
//
//  Synopsis:   Converts change password buffers passed in from
//              WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit buffer
//              ClientBufferBase     -- base address
//              pSubmitBufferSize    -- size of the 32-bit buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it.
//
//
//--------------------------------------------------------------------------

NTSTATUS
MsvConvertWOWChangePasswordBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    PMSV1_0_CHANGEPASSWORD_REQUEST        PasswordRequest;
    PMSV1_0_CHANGEPASSWORD_REQUEST_WOW64  PasswordRequestWOW;
    DWORD                                 dwOffset;
    DWORD                                 dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Scale up the size
    //

    dwBufferSize += sizeof(MSV1_0_CHANGEPASSWORD_REQUEST)
                        - sizeof(MSV1_0_CHANGEPASSWORD_REQUEST_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_CHANGEPASSWORD_REQUEST))
    {
#if 0
        DebugLog((DEB_ERROR,
                  "Submit buffer to logon too small: %d. %ws, line %d\n",
                  dwBufferSize,
                  THIS_FILE,
                  __LINE__));
#endif
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = NtLmAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    PasswordRequest    = (PMSV1_0_CHANGEPASSWORD_REQUEST) pTempBuffer;
    PasswordRequestWOW = (PMSV1_0_CHANGEPASSWORD_REQUEST_WOW64) ProtocolSubmitBuffer;

    //
    // copy fixed fields.
    //

    PasswordRequest->MessageType   = PasswordRequestWOW->MessageType;
    PasswordRequest->Impersonating = PasswordRequestWOW->Impersonating;

    dwOffset    = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST);
    dwWOWOffset = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST_WOW64);

    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) PasswordRequest + dwOffset,
                  (LPBYTE) PasswordRequestWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->DomainName,
                                PasswordRequest->DomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->AccountName,
                                PasswordRequest->AccountName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->OldPassword,
                                PasswordRequest->OldPassword,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->NewPassword,
                                PasswordRequest->NewPassword,
                                dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        NtLmFreePrivateHeap(pTempBuffer);
    }

    return Status;
}


NTSTATUS
MsvAllocateInteractiveWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    )

/*++

Routine Description:

    This allocates and fills in the clients interactive profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_INTERACTIVE_PROFILE_WOW64 LocalProfileBuffer;


    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;

    *ProfileBufferSize = sizeof(MSV1_0_INTERACTIVE_PROFILE_WOW64) +
        NlpUser->LogonScript.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectory.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR) +
        NlpUser->FullName.Length + sizeof(WCHAR) +
        NlpUser->ProfilePath.Length + sizeof(WCHAR) +
        NlpUser->LogonServer.Length + sizeof(WCHAR);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_INTERACTIVE_PROFILE_WOW64),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    LocalProfileBuffer = (PMSV1_0_INTERACTIVE_PROFILE_WOW64) ClientBufferDesc.MsvBuffer;


    //
    // Copy the scalar fields into the profile buffer.
    //

    LocalProfileBuffer->MessageType = MsV1_0InteractiveProfile;
    LocalProfileBuffer->LogonCount = NlpUser->LogonCount;
    LocalProfileBuffer->BadPasswordCount= NlpUser->BadPasswordCount;
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogonTime,
                              LocalProfileBuffer->LogonTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                              LocalProfileBuffer->LogoffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                              LocalProfileBuffer->KickOffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordLastSet,
                              LocalProfileBuffer->PasswordLastSet );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordCanChange,
                              LocalProfileBuffer->PasswordCanChange );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                              LocalProfileBuffer->PasswordMustChange );
    LocalProfileBuffer->UserFlags = NlpUser->UserFlags;

    //
    // Copy the Unicode strings into the profile buffer.
    //

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonScript,
                        &NlpUser->LogonScript );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectory,
                        &NlpUser->HomeDirectory );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectoryDrive,
                        &NlpUser->HomeDirectoryDrive );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->FullName,
                        &NlpUser->FullName );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->ProfilePath,
                        &NlpUser->ProfilePath );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonServer,
                        &NlpUser->LogonServer );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   (PVOID *) ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    return Status;

}

NTSTATUS
MsvAllocateNetworkWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    )

/*++

Routine Description:

    This allocates and fills in the clients network profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.  Will be NULL to indicate a
        NULL session.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    NTSTATUS SubAuthStatus = STATUS_SUCCESS;

    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_LM20_LOGON_PROFILE_WOW64 LocalProfile;

    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;
    *ProfileBufferSize = sizeof(MSV1_0_LM20_LOGON_PROFILE_WOW64);

    if ( NlpUser != NULL ) {
        *ProfileBufferSize += NlpUser->LogonDomainName.Length + sizeof(WCHAR) +
                              NlpUser->LogonServer.Length + sizeof(WCHAR) +
                              NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR);
    }


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_LM20_LOGON_PROFILE_WOW64),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    LocalProfile = (PMSV1_0_LM20_LOGON_PROFILE_WOW64) ClientBufferDesc.MsvBuffer;
    LocalProfile->MessageType = MsV1_0Lm20LogonProfile;


    //
    // For a NULL session, return a constant profile buffer
    //

    if ( NlpUser == NULL ) {

        LocalProfile->KickOffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->KickOffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->LogoffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->LogoffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->UserFlags = 0;
        RtlZeroMemory( LocalProfile->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey));
        RtlZeroMemory( LocalProfile->LanmanSessionKey,
                       sizeof(LocalProfile->LanmanSessionKey));
        RtlZeroMemory( &LocalProfile->LogonDomainName, sizeof(LocalProfile->LogonDomainName) );
        RtlZeroMemory( &LocalProfile->LogonServer, sizeof(LocalProfile->LogonServer) );
        RtlZeroMemory( &LocalProfile->UserParameters, sizeof(LocalProfile->UserParameters) );


    //
    // For non-null sessions,
    //  fill in the profile buffer.
    //

    } else {

        //
        // Copy the individual scalar fields into the profile buffer.
        //

        if ((ParameterControl & MSV1_0_RETURN_PASSWORD_EXPIRY) != 0) {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                                      LocalProfile->LogoffTime);
        } else {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                                      LocalProfile->LogoffTime);
        }
        OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                                  LocalProfile->KickOffTime);
        LocalProfile->UserFlags = NlpUser->UserFlags;

        RtlCopyMemory( LocalProfile->UserSessionKey,
                       &NlpUser->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey) );

        ASSERT( SAMINFO_LM_SESSION_KEY_SIZE ==
                sizeof(LocalProfile->LanmanSessionKey) );
        RtlCopyMemory(
            LocalProfile->LanmanSessionKey,
            &NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
            SAMINFO_LM_SESSION_KEY_SIZE );


        // We need to extract the true status sent back for subauth users,
        // but not by a sub auth package

        SubAuthStatus = NlpUser->ExpansionRoom[SAMINFO_SUBAUTH_STATUS];

        //
        // Copy the Unicode strings into the profile buffer.
        //

        MsvPutWOWClientString(  &ClientBufferDesc,
                                &LocalProfile->LogonDomainName,
                                &NlpUser->LogonDomainName );

        MsvPutWOWClientString(  &ClientBufferDesc,
                                &LocalProfile->LogonServer,
                                &NlpUser->LogonServer );

        //
        // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
        // can't change the NETLOGON_VALIDATION_SAM_INFO structure between
        // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
        // so we'll use that field.
        //

        MsvPutWOWClientString(  &ClientBufferDesc,
                                &LocalProfile->UserParameters,
                                &NlpUser->HomeDirectoryDrive );

    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   (PVOID*)ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    // Save the status for subauth logons

    if (NT_SUCCESS(Status) && !NT_SUCCESS(SubAuthStatus))
    {
        Status = SubAuthStatus;
    }

    return Status;

}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\msvwow.h ===
/*++

    Copyright (c) Microsoft Corporation 2001

    File:        msvwow.h

    Contents:    prototypes for 32-64 bit interop for the MSV1_0 package

    History:     07-Jan-2001    SField

--*/

#ifndef __MSVWOW_H__
#define __MSVWOW_H__

#ifdef _WIN64

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// WOW versions of native structures
// MUST keep these in sync with ntmsv1_0.h
//

typedef UNICODE_STRING32     UNICODE_STRING_WOW64;
typedef UNICODE_STRING_WOW64 *PUNICODE_STRING_WOW64;

typedef STRING32     STRING_WOW64;
typedef STRING_WOW64 *PSTRING_WOW64;

typedef struct _MSV1_0_INTERACTIVE_LOGON_WOW64 {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Password;
} MSV1_0_INTERACTIVE_LOGON_WOW64, *PMSV1_0_INTERACTIVE_LOGON_WOW64;

typedef struct _MSV1_0_INTERACTIVE_PROFILE_WOW64 {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING_WOW64 LogonScript;
    UNICODE_STRING_WOW64 HomeDirectory;
    UNICODE_STRING_WOW64 FullName;
    UNICODE_STRING_WOW64 ProfilePath;
    UNICODE_STRING_WOW64 HomeDirectoryDrive;
    UNICODE_STRING_WOW64 LogonServer;
    ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE_WOW64, *PMSV1_0_INTERACTIVE_PROFILE_WOW64;

typedef struct _MSV1_0_LM20_LOGON_WOW64 {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING_WOW64 CaseSensitiveChallengeResponse;
    STRING_WOW64 CaseInsensitiveChallengeResponse;
    ULONG ParameterControl;
} MSV1_0_LM20_LOGON_WOW64, * PMSV1_0_LM20_LOGON_WOW64;

typedef struct _MSV1_0_LM20_LOGON_PROFILE_WOW64 {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UNICODE_STRING_WOW64 LogonDomainName;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    UNICODE_STRING_WOW64 LogonServer;
    UNICODE_STRING_WOW64 UserParameters;
} MSV1_0_LM20_LOGON_PROFILE_WOW64, * PMSV1_0_LM20_LOGON_PROFILE_WOW64;


typedef struct _MSV1_0_ENUMUSERS_RESPONSE_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG NumberOfLoggedOnUsers;
    PLUID LogonIds;
    PULONG EnumHandles;
} MSV1_0_ENUMUSERS_RESPONSE_WOW64, *PMSV1_0_ENUMUSERS_RESPONSE_WOW64;

typedef struct _MSV1_0_GETUSERINFO_RESPONSE_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PSID UserSid;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 LogonServer;
    SECURITY_LOGON_TYPE LogonType;
} MSV1_0_GETUSERINFO_RESPONSE_WOW64, *PMSV1_0_GETUSERINFO_RESPONSE_WOW64;

typedef struct _MSV1_0_CHANGEPASSWORD_REQUEST_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64 DomainName;
    UNICODE_STRING_WOW64 AccountName;
    UNICODE_STRING_WOW64 OldPassword;
    UNICODE_STRING_WOW64 NewPassword;
    BOOLEAN        Impersonating;
} MSV1_0_CHANGEPASSWORD_REQUEST_WOW64, *PMSV1_0_CHANGEPASSWORD_REQUEST_WOW64;

typedef struct _MSV1_0_CHANGEPASSWORD_RESPONSE_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    BOOLEAN PasswordInfoValid;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
} MSV1_0_CHANGEPASSWORD_RESPONSE_WOW64, *PMSV1_0_CHANGEPASSWORD_RESPONSE_WOW64;

//
// If this assertion fails, we're overrunning the client's OUT buffer on
// password change requests
//

C_ASSERT(sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE) == sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE_WOW64));

//
// routines for working on primary structures
//

NTSTATUS
MsvConvertWOWInteractiveLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
MsvConvertWOWNetworkLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
MsvConvertWOWChangePasswordBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
MsvAllocateInteractiveWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    );

NTSTATUS
MsvAllocateNetworkWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    );


//
// generic helper routines
//

VOID
MsvPutWOWClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING_WOW64 OutString,
    IN PUNICODE_STRING InString
    );



#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _WIN64
#endif  // __MSVWOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nlp.c

Abstract:

    This file is the contains private routines which support
    for the LAN Manager portions of the MSV1_0 authentication package.

Author:

    Cliff Van Dyke 29-Apr-1991

Revision History:
   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlp.c

--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"
#include "nlpcache.h"
#include <wincrypt.h>

#include "msvwow.h"

DWORD
NlpCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    );

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);
    ASSERT( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );
#ifdef notdef
    KdPrint(("NlpPutString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  InString: %lx %lx OutString: %lx Where: %lx\n", InString,
        InString->Buffer, OutString, *Where ));
#endif

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }
#ifdef notdef
    KdPrint(("  OutString: %ld %lx\n",  OutString->Length, OutString->Buffer));
#endif

    return;
}


VOID
NlpInitClientBuffer(
    OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PLSA_CLIENT_REQUEST ClientRequest
    )

/*++

Routine Description:

    This routine initializes a ClientBufferDescriptor to known values.
    This routine must be called before any of the other routines that use
    the ClientBufferDescriptor.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

Return Values:

    None.

--*/

{

    //
    // Fill in a pointer to the ClientRequest and zero the rest.
    //

    ClientBufferDesc->ClientRequest = ClientRequest;
    ClientBufferDesc->UserBuffer = NULL;
    ClientBufferDesc->MsvBuffer = NULL;
    ClientBufferDesc->StringOffset = 0;
    ClientBufferDesc->TotalSize = 0;

}


NTSTATUS
NlpAllocateClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN ULONG FixedSize,
    IN ULONG TotalSize
    )

/*++

Routine Description:

    This routine allocates a buffer in the clients address space.
    It also allocates a mirror buffer in MSV's address space.

    The data will be constructed in the MSV's address space then 'flushed'
    into the client's address space.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    FixedSize - The size in bytes of the fixed portion of the buffer.

    TotalSize - The size in bytes of the entire buffer.

Return Values:

    Status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Allocate the Mirror buffer.
    //

    ASSERT( ClientBufferDesc->MsvBuffer == NULL );
    ClientBufferDesc->MsvBuffer = I_NtLmAllocate( TotalSize );

    if ( ClientBufferDesc->MsvBuffer == NULL ) {
        return STATUS_NO_MEMORY;
    }


    //
    // Allocate the client's buffer
    //

    ASSERT( ClientBufferDesc->UserBuffer == NULL );
    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
         ClientBufferDesc->UserBuffer = (*(Lsa.AllocateLsaHeap))(TotalSize);
    }
    else
    {
        Status = (*Lsa.AllocateClientBuffer)(
                    ClientBufferDesc->ClientRequest,
                    TotalSize,
                    (PVOID *)&ClientBufferDesc->UserBuffer );
    }

    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
        if (ClientBufferDesc->UserBuffer == NULL)
        {
            NlpFreeClientBuffer( ClientBufferDesc );
            return STATUS_NO_MEMORY;
        }
    }
    else
    {
        if ( !NT_SUCCESS( Status ) ) {
            ClientBufferDesc->UserBuffer = NULL;
            NlpFreeClientBuffer( ClientBufferDesc );
            return Status;
        }
    }

    //
    // Return
    //

    ClientBufferDesc->StringOffset = FixedSize;
    ClientBufferDesc->TotalSize = TotalSize;

    return STATUS_SUCCESS;

}


NTSTATUS
NlpFlushClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    OUT PVOID* UserBuffer
    )

/*++

Routine Description:

    Copy the Mirror Buffer into the Client's address space.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    UserBuffer - If successful, returns a pointer to the user's buffer.
        (The caller is now resposible for deallocating the buffer.)

Return Values:

    Status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy the data to the client's address space.
    //

    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
        RtlCopyMemory(
                 ClientBufferDesc->UserBuffer,
                 ClientBufferDesc->MsvBuffer,
                 ClientBufferDesc->TotalSize);
    }
    else
    {
        Status = (*Lsa.CopyToClientBuffer)(
                ClientBufferDesc->ClientRequest,
                ClientBufferDesc->TotalSize,
                ClientBufferDesc->UserBuffer,
                ClientBufferDesc->MsvBuffer );
    }


    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Mark that we're no longer responsible for the client's buffer.
    //

    *UserBuffer = (PVOID) ClientBufferDesc->UserBuffer;
    ClientBufferDesc->UserBuffer = NULL;

    //
    // Free the mirror buffer
    //

    NlpFreeClientBuffer( ClientBufferDesc );


    return STATUS_SUCCESS;

}


VOID
NlpFreeClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc
    )

/*++

Routine Description:

    Free any Mirror Buffer or Client buffer.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

Return Values:

    None

--*/

{

    //
    // Free the mirror buffer.
    //

    if ( ClientBufferDesc->MsvBuffer != NULL ) {
        I_NtLmFree( ClientBufferDesc->MsvBuffer );
        ClientBufferDesc->MsvBuffer = NULL;
    }

    //
    // Free the Client's buffer
    //

    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
        if ( ClientBufferDesc->UserBuffer != NULL ) {
            (*Lsa.FreeLsaHeap)(ClientBufferDesc->UserBuffer);
            ClientBufferDesc->UserBuffer = NULL;
        }
    }
    else
    {
        if ( ClientBufferDesc->UserBuffer != NULL ) {
            (VOID) (*Lsa.FreeClientBuffer)( ClientBufferDesc->ClientRequest,
                                            ClientBufferDesc->UserBuffer );
            ClientBufferDesc->UserBuffer = NULL;
        }
    }

}


VOID
NlpPutClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    ClientBufferDesc->StringOffset, and fixes the OutString string to point
    to that new copy.


Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    InString - A pointer to an NT string to be copied

    OutString - A pointer to a destination NT string.  This string structure
        is in the "Mirror" allocated buffer.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{

    //
    // Ensure our caller passed good data.
    //

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( COUNT_IS_ALIGNED( ClientBufferDesc->StringOffset, sizeof(WCHAR)) );
    ASSERT( (LPBYTE)OutString >= ClientBufferDesc->MsvBuffer );
    ASSERT( (LPBYTE)OutString <
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->TotalSize - sizeof(UNICODE_STRING) );

    ASSERT( ClientBufferDesc->StringOffset + InString->Length + sizeof(WCHAR) <=
            ClientBufferDesc->TotalSize );

#ifdef notdef
    KdPrint(("NlpPutClientString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  Orig: UserBuffer: %lx Offset: 0x%lx TotalSize: 0x%lx\n",
                ClientBufferDesc->UserBuffer,
                ClientBufferDesc->StringOffset,
                ClientBufferDesc->TotalSize ));
#endif

    //
    // Build a string structure and copy the text to the Mirror buffer.
    //

    if ( InString->Length > 0 ) {

        //
        // Copy the string (Add a zero character)
        //

        RtlCopyMemory(
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset,
            InString->Buffer,
            InString->Length );

        // Do one byte at a time since some callers don't pass in an even
        // InString->Length
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length) = '\0';
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length+1) = '\0';

        //
        // Build the string structure to point to the data in the client's
        // address space.
        //

        OutString->Buffer = (PWSTR)(ClientBufferDesc->UserBuffer +
                            ClientBufferDesc->StringOffset);
        OutString->Length = InString->Length;
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);

        //
        // Adjust the offset to past the newly copied string.
        //

        ClientBufferDesc->StringOffset += OutString->MaximumLength;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }

#ifdef notdef
    KdPrint(("  New: Offset: 0x%lx StringStart: %lx\n",
                ClientBufferDesc->StringOffset,
                OutString->Buffer ));
#endif

    return;

}


VOID
NlpMakeRelativeString(
    IN PUCHAR BaseAddress,
    IN OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine converts the buffer address in the specified string to
    be a byte offset from BaseAddress.

Parameters:

    BaseAddress - A pointer to make the destination address relative to.

    String - A pointer to a NT string to make relative.

Return Values:

    None.

--*/

{
    ASSERT( BaseAddress != NULL );
    ASSERT( String != NULL );
    ASSERT( sizeof(ULONG_PTR) == sizeof(String->Buffer) );

    if ( String->Buffer != NULL ) {
        *((PULONG_PTR)(&String->Buffer)) =
            (ULONG_PTR)((PUCHAR)String->Buffer - (PUCHAR)BaseAddress);
    }

    return;
}


VOID
NlpRelativeToAbsolute(
    IN PVOID BaseAddress,
    IN OUT PULONG_PTR RelativeValue
    )

/*++

Routine Description:

    This routine converts the byte offset from BaseAddress to be an
    absolute address.

Parameters:

    BaseAddress - A pointer the destination address is relative to.

    RelativeValue - A pointer to a relative value to make absolute.

Return Values:

    None.

--*/

{
    ASSERT( BaseAddress != NULL );
    ASSERT( RelativeValue != NULL );

    if ( *((PUCHAR *)RelativeValue) != NULL ) {
        *RelativeValue = (ULONG_PTR)((PUCHAR)BaseAddress + (*RelativeValue));
    }

    return;
}

ACTIVE_LOGON*
NlpFindActiveLogon(
    IN LUID* pLogonId
    )

/*++

Routine Description:

    This routine finds the specified Logon Id in the ActiveLogon table.
    It returns a boolean indicating whether the Logon Id exists in the
    ActiveLogon Table.  If so, this routine also returns a pointer to a
    pointer to the appropriate entry in the table.  If not, this routine
    returns a pointer to where such an entry would be inserted in the table.

    This routine must be called with the NlpActiveLogonLock locked.

Parameters:

    pLogonId - The LogonId of the logon to find in the table.

Return Values:

    ACTIVE_LOGON, NULL if not found

--*/

{
    LIST_ENTRY* pScan = NULL;
    ACTIVE_LOGON* pActiveLogon = NULL;

    //
    // Loop through the table looking for this particular LogonId.
    //

    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);
        if ( RtlCompareMemory(&pActiveLogon->LogonId, pLogonId, sizeof(LUID)) == sizeof(LUID) )
        {
            return pActiveLogon;
        }
    }

    return NULL;
}

ULONG
NlpCountActiveLogon(
    IN PUNICODE_STRING pLogonDomainName,
    IN PUNICODE_STRING pUserName
    )

/*++

Routine Description:

    This routine counts the number of time a particular user is logged on
    in the Active Logon Table.

Parameters:

    pLogonDomainName - Domain in which this user account is defined.

    pUserName - The user name to count the active logons for.

Return Values:

    The count of active logons for the specified user.

--*/

{
    LIST_ENTRY* pScan = NULL;
    ACTIVE_LOGON* pActiveLogon = NULL;
    ULONG LogonCount = 0;

    //
    // Loop through the table looking for this particular LogonId.
    //

    NlpLockActiveLogonsRead();

    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);
        if (RtlEqualUnicodeString(pUserName, &pActiveLogon->UserName, (BOOLEAN) TRUE) &&
           RtlEqualDomainName(pLogonDomainName,&pActiveLogon->LogonDomainName))
        {
            LogonCount ++;
        }
    }

    NlpUnlockActiveLogons();

    return LogonCount;
}

NTSTATUS
NlpAllocateInteractiveProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    )

/*++

Routine Description:

    This allocates and fills in the clients interactive profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_INTERACTIVE_PROFILE LocalProfileBuffer;

#if _WIN64

    if( ClientRequest != (PLSA_CLIENT_REQUEST)( -1 ) )
    {
        SECPKG_CALL_INFO  CallInfo;

        //
        // if the call originated outproc, need to check if wow64.
        //

        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            return MsvAllocateInteractiveWOWProfile (
                                    ClientRequest,
                                    ProfileBuffer,
                                    ProfileBufferSize,
                                    NlpUser
                                    );
        }
    }
#endif  // _WIN64


    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;

    *ProfileBufferSize = sizeof(MSV1_0_INTERACTIVE_PROFILE) +
        NlpUser->LogonScript.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectory.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR) +
        NlpUser->FullName.Length + sizeof(WCHAR) +
        NlpUser->ProfilePath.Length + sizeof(WCHAR) +
        NlpUser->LogonServer.Length + sizeof(WCHAR);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_INTERACTIVE_PROFILE),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    LocalProfileBuffer = (PMSV1_0_INTERACTIVE_PROFILE) ClientBufferDesc.MsvBuffer;

    //
    // Copy the scalar fields into the profile buffer.
    //

    LocalProfileBuffer->MessageType = MsV1_0InteractiveProfile;
    LocalProfileBuffer->LogonCount = NlpUser->LogonCount;
    LocalProfileBuffer->BadPasswordCount= NlpUser->BadPasswordCount;
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogonTime,
                              LocalProfileBuffer->LogonTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                              LocalProfileBuffer->LogoffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                              LocalProfileBuffer->KickOffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordLastSet,
                              LocalProfileBuffer->PasswordLastSet );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordCanChange,
                              LocalProfileBuffer->PasswordCanChange );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                              LocalProfileBuffer->PasswordMustChange );
    LocalProfileBuffer->UserFlags = NlpUser->UserFlags;

    //
    // Copy the Unicode strings into the profile buffer.
    //


    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonScript,
                        &NlpUser->LogonScript );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectory,
                        &NlpUser->HomeDirectory );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectoryDrive,
                        &NlpUser->HomeDirectoryDrive );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->FullName,
                        &NlpUser->FullName );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->ProfilePath,
                        &NlpUser->ProfilePath );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonServer,
                        &NlpUser->LogonServer );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   (PVOID *) ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    return Status;

}




NTSTATUS
NlpAllocateNetworkProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    )

/*++

Routine Description:

    This allocates and fills in the clients network profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.  Will be NULL to indicate a
        NULL session.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    NTSTATUS SubAuthStatus = STATUS_SUCCESS;

    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_LM20_LOGON_PROFILE LocalProfile;

#if _WIN64

    if( ClientRequest != (PLSA_CLIENT_REQUEST)( -1 ) )
    {
        SECPKG_CALL_INFO  CallInfo;

        //
        // if the call originated outproc, need to check if wow64.
        //

        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            return MsvAllocateNetworkWOWProfile (
                                    ClientRequest,
                                    ProfileBuffer,
                                    ProfileBufferSize,
                                    NlpUser,
                                    ParameterControl
                                    );
        }
    }
#endif  // _WIN64


    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;
    *ProfileBufferSize = sizeof(MSV1_0_LM20_LOGON_PROFILE);

    if ( NlpUser != NULL ) {
        *ProfileBufferSize += NlpUser->LogonDomainName.Length + sizeof(WCHAR) +
                              NlpUser->LogonServer.Length + sizeof(WCHAR) +
                              NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR);
    }


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_LM20_LOGON_PROFILE),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    LocalProfile = (PMSV1_0_LM20_LOGON_PROFILE) ClientBufferDesc.MsvBuffer;
    LocalProfile->MessageType = MsV1_0Lm20LogonProfile;


    //
    // For a NULL session, return a constant profile buffer
    //

    if ( NlpUser == NULL ) {

        LocalProfile->KickOffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->KickOffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->LogoffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->LogoffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->UserFlags = 0;
        RtlZeroMemory( LocalProfile->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey));
        RtlZeroMemory( LocalProfile->LanmanSessionKey,
                       sizeof(LocalProfile->LanmanSessionKey));
        RtlInitUnicodeString( &LocalProfile->LogonDomainName, NULL );
        RtlInitUnicodeString( &LocalProfile->LogonServer, NULL );
        RtlInitUnicodeString( &LocalProfile->UserParameters, NULL );


    //
    // For non-null sessions,
    //  fill in the profile buffer.
    //

    } else {

        //
        // Copy the individual scalar fields into the profile buffer.
        //

        if ((ParameterControl & MSV1_0_RETURN_PASSWORD_EXPIRY) != 0) {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                                      LocalProfile->LogoffTime);
        } else {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                                      LocalProfile->LogoffTime);
        }
        OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                                  LocalProfile->KickOffTime);
        LocalProfile->UserFlags = NlpUser->UserFlags;

        RtlCopyMemory( LocalProfile->UserSessionKey,
                       &NlpUser->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey) );

        ASSERT( SAMINFO_LM_SESSION_KEY_SIZE ==
                sizeof(LocalProfile->LanmanSessionKey) );
        RtlCopyMemory(
            LocalProfile->LanmanSessionKey,
            &NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
            SAMINFO_LM_SESSION_KEY_SIZE );


        // We need to extract the true status sent back for subauth users,
        // but not by a sub auth package

        SubAuthStatus = NlpUser->ExpansionRoom[SAMINFO_SUBAUTH_STATUS];

        //
        // Copy the Unicode strings into the profile buffer.
        //

        NlpPutClientString( &ClientBufferDesc,
                            &LocalProfile->LogonDomainName,
                            &NlpUser->LogonDomainName );

        NlpPutClientString( &ClientBufferDesc,
                            &LocalProfile->LogonServer,
                            &NlpUser->LogonServer );

        //
        // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
        // can't change the NETLOGON_VALIDATION_SAM_INFO structure between
        // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
        // so we'll use that field.
        //

        NlpPutClientString( &ClientBufferDesc,
                            &LocalProfile->UserParameters,
                            &NlpUser->HomeDirectoryDrive );

    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    // Save the status for subauth logons

    if (NT_SUCCESS(Status) && !NT_SUCCESS(SubAuthStatus))
    {
        Status = SubAuthStatus;
    }

    return Status;

}


PSID
NlpMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

/*++

Routine Description:

    Given a domain Id and a relative ID create the corresponding SID allocated
    from the LSA heap.

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

Return Value:

    Sid - Returns a pointer to a buffer allocated from the LsaHeap
            containing the resultant Sid.

--*/
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = (*Lsa.AllocateLsaHeap)( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        (*Lsa.FreeLsaHeap)( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}



PSID
NlpCopySid(
    IN  PSID * Sid
    )

/*++

Routine Description:

    Given a SID allocatees space for a new SID from the LSA heap and copies
    the original SID.

Arguments:

    Sid - The original SID.

Return Value:

    Sid - Returns a pointer to a buffer allocated from the LsaHeap
            containing the resultant Sid.

--*/
{
    PSID NewSid;
    ULONG Size;

    Size = RtlLengthSid( Sid );



    if ((NewSid = (*Lsa.AllocateLsaHeap)( Size )) == NULL ) {
        return NULL;
    }


    if ( !NT_SUCCESS( RtlCopySid( Size, NewSid, Sid ) ) ) {
        (*Lsa.FreeLsaHeap)( NewSid );
        return NULL;
    }


    return NewSid;
}

//+-------------------------------------------------------------------------
//
//  Function:   NlpMakeTokenInformationV2
//
//  Synopsis:   This routine makes copies of all the pertinent
//              information from the UserInfo and generates a
//              LSA_TOKEN_INFORMATION_V2 data structure.
//
//  Effects:
//
//  Arguments:
//
//    UserInfo - Contains the validation information which is
//        to be copied into the TokenInformation.
//
//    TokenInformation - Returns a pointer to a properly Version 1 token
//        information structures.  The structure and individual fields are
//        allocated properly as described in ntlsa.h.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates the service completed successfully.
//
//              STATUS_INSUFFICIENT_RESOURCES -  This error indicates that
//                      the logon could not be completed because the client
//                      does not have sufficient quota to allocate the return
//                      buffer.
//
//  Notes:      stolen back from from kerberos\client2\krbtoken.cxx.c:KerbMakeTokenInformationV1
//
//
//--------------------------------------------------------------------------


NTSTATUS
NlpMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo,
    OUT PLSA_TOKEN_INFORMATION_V2 *TokenInformation
    )
{
    PNETLOGON_VALIDATION_SAM_INFO3 UserInfo = (PNETLOGON_VALIDATION_SAM_INFO3) ValidationInfo;
    NTSTATUS Status;
    PLSA_TOKEN_INFORMATION_V2 V2 = NULL;
    ULONG Size, i;
    DWORD NumGroups = 0;
    PBYTE CurrentSid = NULL;
    ULONG SidLength = 0;

    //
    // Allocate the structure itself
    //

    Size = (ULONG)sizeof(LSA_TOKEN_INFORMATION_V2);

    //
    // Allocate an array to hold the groups
    //

    Size += sizeof(TOKEN_GROUPS);


    // Add room for groups passed as RIDS
    NumGroups = UserInfo->GroupCount;
    if(UserInfo->GroupCount)
    {
        Size += UserInfo->GroupCount * (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        ULONG i = 0;
        NumGroups += UserInfo->SidCount;

        // Add room for the sid's themselves
        for(i=0; i < UserInfo->SidCount; i++)
        {
            Size += RtlLengthSid(UserInfo->ExtraSids[i].Sid);
        }
    }

    //
    // If there are resource groups, add space for them
    //
    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {

        NumGroups += UserInfo->ResourceGroupCount;

        if ((UserInfo->ResourceGroupCount != 0) &&
            ((UserInfo->ResourceGroupIds == NULL) ||
             (UserInfo->ResourceGroupDomainSid == NULL)))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        // Allocate space for the sids
        if(UserInfo->ResourceGroupCount)
        {
            Size += UserInfo->ResourceGroupCount * (RtlLengthSid(UserInfo->ResourceGroupDomainSid) + sizeof(ULONG));
        }

    }


    if( UserInfo->UserId )
    {
        // Size of the user sid and the primary group sid.
        Size += 2*(RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }
    else
    {
        if ( UserInfo->SidCount <= 0 ) {

            Status = STATUS_INSUFFICIENT_LOGON_INFO;
            goto Cleanup;
        }

        // Size of the primary group sid.
        Size += (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }


    Size += (NumGroups - ANYSIZE_ARRAY)*sizeof(SID_AND_ATTRIBUTES);


    V2 = (PLSA_TOKEN_INFORMATION_V2) (*Lsa.AllocateLsaHeap)( Size );
    if ( V2 == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        V2,
        Size
        );

    V2->Groups = (PTOKEN_GROUPS)(V2+1);
    V2->Groups->GroupCount = 0;
    CurrentSid = (PBYTE)&V2->Groups->Groups[NumGroups];

    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime, V2->ExpirationTime );



    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {
        V2->User.User.Sid = (PSID)CurrentSid;
        CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->UserId);
    }

    //
    // Make a copy of the primary group (a required field).
    //
    V2->PrimaryGroup.PrimaryGroup = (PSID)CurrentSid;
    CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->PrimaryGroupId );




    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->GroupIds[i].Attributes;

        V2->Groups->Groups[V2->Groups->GroupCount].Sid = (PSID)CurrentSid;
        CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->GroupIds[i].RelativeId);

        V2->Groups->GroupCount++;
    }


    //
    // Add in the extra SIDs
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        ULONG index = 0;
        //
        // If the user SID wasn't passed as a RID, it is the first
        // SID.
        //

        if ( !V2->User.User.Sid ) {
            V2->User.User.Sid = (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;
            index++;
        }

        //
        // Copy over all additional SIDs as groups.
        //

        for ( ; index < UserInfo->SidCount; index++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                UserInfo->ExtraSids[index].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;

            V2->Groups->GroupCount++;
        }
    }

    //
    // Check to see if any resouce groups exist
    //

    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {


        for ( i=0; i < UserInfo->ResourceGroupCount; i++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->ResourceGroupIds[i].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->ResourceGroupDomainSid, UserInfo->ResourceGroupIds[i].RelativeId);

            V2->Groups->GroupCount++;
        }
    }

    ASSERT( ((PBYTE)V2 + Size) == CurrentSid );


    if (!V2->User.User.Sid) {

        Status = STATUS_INSUFFICIENT_LOGON_INFO;
        goto Cleanup;
    }

    //
    // There are no default privileges supplied.
    // We don't have an explicit owner SID.
    // There is no default DACL.
    //

    V2->Privileges = NULL;
    V2->Owner.Owner = NULL;
    V2->DefaultDacl.DefaultDacl = NULL;

    //
    // Return the Validation Information to the caller.
    //

    *TokenInformation = V2;
    return STATUS_SUCCESS;

    //
    // Deallocate any memory we've allocated
    //

Cleanup:

    (*Lsa.FreeLsaHeap)( V2 );

    return Status;
}

VOID
NlpPutOwfsInPrimaryCredential(
    IN PUNICODE_STRING pPassword,
    IN BOOLEAN bIsOwfPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL pCredential
    )

/*++

Routine Description:

    This routine puts the OWFs for the specified clear password into
    the passed in Credential structure.

Arguments:

    pPassword - User's password.

    bIsOwfPassword - whether CleartextPassword is actually an OWF password

    pCredential - A pointer to the credential to update.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;

    //
    // Compute the Ansi version to the Cleartext password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

    pCredential->LmPasswordPresent = FALSE;
    pCredential->NtPasswordPresent = FALSE;
    pCredential->ShaPasswordPresent = FALSE;

    if (!bIsOwfPassword)
    {
        if ( pPassword->Length <= (LM20_PWLEN * sizeof(WCHAR)) )
        {
            CHAR LmPassword[LM20_PWLEN+1];
            STRING AnsiCleartextPassword;

            AnsiCleartextPassword.Buffer = LmPassword;
            AnsiCleartextPassword.Length = sizeof(LmPassword);
            AnsiCleartextPassword.MaximumLength = AnsiCleartextPassword.Length;

            Status = RtlUpcaseUnicodeStringToOemString(
                                          &AnsiCleartextPassword,
                                          pPassword,
                                          (BOOLEAN) FALSE );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // Save the OWF encrypted versions of the passwords.
                //

                Status = RtlCalculateLmOwfPassword( LmPassword,
                                                    &pCredential->LmOwfPassword );

                ASSERT( NT_SUCCESS(Status) );

                pCredential->LmPasswordPresent = TRUE;
            }

            //
            // Don't leave passwords around in the pagefile
            //

            RtlZeroMemory( LmPassword, sizeof(LmPassword) );
        }

        Status = RtlCalculateNtOwfPassword( pPassword,
                                            &pCredential->NtOwfPassword );

        ASSERT( NT_SUCCESS(Status) );

        pCredential->NtPasswordPresent = TRUE;


        Status = RtlCalculateShaOwfPassword( pPassword,
                                             &pCredential->ShaOwfPassword );

        ASSERT( NT_SUCCESS(Status) );

        pCredential->ShaPasswordPresent = TRUE;
    }
    else
    {
        SspPrint((SSP_CRED, "NlpPutOwfsInPrimaryCredential handling MSV1_0_SUPPLEMENTAL_CREDENTIAL\n"));

        if (pPassword->Length >= sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL))
        {
            MSV1_0_SUPPLEMENTAL_CREDENTIAL SupCred;

            RtlCopyMemory(&SupCred, pPassword->Buffer, sizeof(SupCred)); // make a local copy so that data is aligned properly

            if (SupCred.Version != MSV1_0_CRED_VERSION)
            {
                SspPrint((SSP_CRITICAL, "NlpPutOwfsInPrimaryCredential failed to accept MSV1_0_SUPPLEMENTAL_CREDENTIAL, version %#x\n", SupCred.Version));
                return;
            }

            if (SupCred.Flags & MSV1_0_CRED_NT_PRESENT)
            {
                pCredential->NtPasswordPresent = TRUE;
                RtlCopyMemory(
                    &pCredential->NtOwfPassword,
                    SupCred.NtPassword,
                    MSV1_0_OWF_PASSWORD_LENGTH
                    );
            }

            if (SupCred.Flags & MSV1_0_CRED_LM_PRESENT)
            {
                pCredential->LmPasswordPresent = TRUE;
                RtlCopyMemory(
                   &pCredential->LmOwfPassword,
                   SupCred.LmPassword,
                   MSV1_0_OWF_PASSWORD_LENGTH
                   );
            }
        }
        else
        {
            SspPrint((SSP_CRITICAL, "NlpPutOwfsInPrimaryCredential failed to accept MSV1_0_SUPPLEMENTAL_CREDENTIAL, length %#x\n", pPassword->Length));
        }
    }
}

NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    )

/*++

Routine Description:

    This routine makes a primary credential for the given user nam and
    password.

Arguments:

    LogonDomainName - Is a string representing the domain in which the user's
        account is defined.

    UserName - Is a string representing the user's account name.  The
        name may be up to 255 characters long.  The name is treated case
        insensitive.

    CleartextPassword - Is a string containing the user's cleartext password.
        The password may be up to 255 characters long and contain any
        UNICODE value.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - the size of the allocated credential buffer (in bytes).

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    PMSV1_0_PRIMARY_CREDENTIAL Credential;
    PUCHAR Where;
    ULONG PaddingLength;


    //
    // Build the credential
    //

    *CredentialSize = sizeof(MSV1_0_PRIMARY_CREDENTIAL) +
            LogonDomainName->Length + sizeof(WCHAR) +
            UserName->Length + sizeof(WCHAR);

    //
    // add padding for memory encryption interface.
    //

    PaddingLength = DESX_BLOCKLEN - (*CredentialSize % DESX_BLOCKLEN);
    if( PaddingLength == DESX_BLOCKLEN )
    {
        PaddingLength = 0;
    }

    *CredentialSize += PaddingLength;


    Credential = (*Lsa.AllocateLsaHeap)( *CredentialSize );

    if ( Credential == NULL ) {
        KdPrint(("MSV1_0: NlpMakePrimaryCredential: No memory %ld\n",
            *CredentialSize ));
        return STATUS_QUOTA_EXCEEDED;
    }


    //
    // Put the LogonDomainName into the Credential Buffer.
    //

    Where = (PUCHAR)(Credential + 1);

    NlpPutString( &Credential->LogonDomainName, LogonDomainName, &Where );


    //
    // Put the UserName into the Credential Buffer.
    //

    NlpPutString( &Credential->UserName, UserName, &Where );


    //
    // Put the OWF passwords into the newly allocated credential.
    //

    NlpPutOwfsInPrimaryCredential( CleartextPassword, FALSE, Credential );


    //
    // Return the credential to the caller.
    //
    *CredentialBuffer = Credential;
    return STATUS_SUCCESS;
}


NTSTATUS
NlpMakePrimaryCredentialFromMsvCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN  PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredential,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    )


/*++

Routine Description:

    This routine makes a primary credential for the given user nam and
    password.

Arguments:

    LogonDomainName - Is a string representing the domain in which the user's
        account is defined.

    UserName - Is a string representing the user's account name.  The
        name may be up to 255 characters long.  The name is treated case
        insensitive.

    SupplementalCred - The credentials retrieved from the user's account on
        the domain controller.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - the size of the allocated credential buffer (in bytes).

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    PMSV1_0_PRIMARY_CREDENTIAL Credential;
    PUCHAR Where;
    ULONG PaddingLength;


    //
    // Build the credential
    //

    *CredentialSize = sizeof(MSV1_0_PRIMARY_CREDENTIAL) +
            LogonDomainName->Length + sizeof(WCHAR) +
            UserName->Length + sizeof(WCHAR);

    //
    // add padding for memory encryption interface.
    //

    PaddingLength = DESX_BLOCKLEN - (*CredentialSize % DESX_BLOCKLEN);
    if( PaddingLength == DESX_BLOCKLEN )
    {
        PaddingLength = 0;
    }

    *CredentialSize += PaddingLength;


    Credential = (*Lsa.AllocateLsaHeap)( *CredentialSize );

    if ( Credential == NULL ) {
        KdPrint(("MSV1_0: NlpMakePrimaryCredential: No memory %ld\n",
            *CredentialSize ));
        return STATUS_QUOTA_EXCEEDED;
    }

    RtlZeroMemory(
        Credential,
        *CredentialSize
        );

    //
    // Put the LogonDomainName into the Credential Buffer.
    //

    Where = (PUCHAR)(Credential + 1);

    NlpPutString( &Credential->LogonDomainName, LogonDomainName, &Where );


    //
    // Put the UserName into the Credential Buffer.
    //

    NlpPutString( &Credential->UserName, UserName, &Where );



    //
    // Save the OWF encrypted versions of the passwords.
    //

    if (MsvCredential->Flags & MSV1_0_CRED_NT_PRESENT) {
        RtlCopyMemory(
            &Credential->NtOwfPassword,
            MsvCredential->NtPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->NtPasswordPresent = TRUE;
    } else {
#if 0
        RtlCopyMemory(
            &Credential->NtOwfPassword,
            &NlpNullNtOwfPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->NtPasswordPresent = TRUE;
#endif
        Credential->NtPasswordPresent = FALSE;
    }


    if (MsvCredential->Flags & MSV1_0_CRED_LM_PRESENT) {
        RtlCopyMemory(
            &Credential->LmOwfPassword,
            MsvCredential->LmPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->LmPasswordPresent = TRUE;
    } else {
#if 0
        RtlCopyMemory(
            &Credential->LmOwfPassword,
            &NlpNullLmOwfPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->LmPasswordPresent = TRUE;
#endif
        Credential->LmPasswordPresent = FALSE;

    }


    //
    // Return the credential to the caller.
    //
    *CredentialBuffer = Credential;
    return STATUS_SUCCESS;
}


NTSTATUS
NlpAddPrimaryCredential(
    IN PLUID LogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL Credential,
    IN ULONG CredentialSize
    )


/*++

Routine Description:

    This routine sets a primary credential for the given LogonId.

Arguments:

    LogonId - The LogonId of the LogonSession to set the Credentials
        for.

    Credential - Specifies a pointer to the credential.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;
    STRING CredentialString;
    STRING PrimaryKeyValue;

    //
    // Make all pointers in the credential relative.
    //

    NlpMakeRelativeString( (PUCHAR)Credential, &Credential->UserName );
    NlpMakeRelativeString( (PUCHAR)Credential, &Credential->LogonDomainName );

    //
    // Add the credential to the logon session.
    //

    RtlInitString( &PrimaryKeyValue, MSV1_0_PRIMARY_KEY );
    CredentialString.Buffer = (PCHAR) Credential;
    CredentialString.Length = (USHORT) CredentialSize;
    CredentialString.MaximumLength = CredentialString.Length;

    //
    // encrypt input credential.
    //

    (*Lsa.LsaProtectMemory)( CredentialString.Buffer, (ULONG)CredentialString.Length );

    Status = (*Lsa.AddCredential)(
                    LogonId,
                    MspAuthenticationPackageId,
                    &PrimaryKeyValue,
                    &CredentialString );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrint(( "NlpAddPrimaryCredential: error from AddCredential %lX\n",
                  Status));
    }

    return Status;
}

NTSTATUS
NlpGetPrimaryCredentialByUserSid(
    IN  PSID pUserSid,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize OPTIONAL
    )
{
    LUID LogonId;
    BOOLEAN Match = FALSE;
    LIST_ENTRY* pScan = NULL;
    ACTIVE_LOGON* pActiveLogon = NULL;

    if (!pUserSid)
    {
        return STATUS_INVALID_PARAMETER;
    }

    NlpLockActiveLogonsRead();

    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);
        if (RtlEqualSid(pUserSid, pActiveLogon->UserSid))
        {
            Match = TRUE;
            RtlCopyMemory(&LogonId, &pActiveLogon->LogonId, sizeof(LogonId));
            break;
        }
    }

    NlpUnlockActiveLogons();

    if (!Match)
    {
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    return NlpGetPrimaryCredential(&LogonId, CredentialBuffer, CredentialSize);
}


NTSTATUS
NlpGetPrimaryCredential(
    IN PLUID LogonId,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize OPTIONAL
    )


/*++

Routine Description:

    This routine gets a primary credential for the given LogonId.

Arguments:

    LogonId - The LogonId of the LogonSession to retrieve the Credentials
        for.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - Optionally returns the size of the credential buffer.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;
    ULONG QueryContext = 0;
    ULONG PrimaryKeyLength;
    STRING PrimaryKeyValue;
    STRING CredentialString;
    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;

    RtlInitString( &PrimaryKeyValue, MSV1_0_PRIMARY_KEY );

    Status = (*Lsa.GetCredentials)( LogonId,
                                    MspAuthenticationPackageId,
                                    &QueryContext,
                                    (BOOLEAN) FALSE,  // Just retrieve primary
                                    &PrimaryKeyValue,
                                    &PrimaryKeyLength,
                                    &CredentialString );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Make all pointers in the credential absolute.
    //

    Credential = (PMSV1_0_PRIMARY_CREDENTIAL) CredentialString.Buffer;

    //
    // decrypt credential.
    //

    (*Lsa.LsaUnprotectMemory)( CredentialString.Buffer, (ULONG)CredentialString.Length );


    NlpRelativeToAbsolute( Credential,
                   (PULONG_PTR)&Credential->UserName.Buffer );
    NlpRelativeToAbsolute( Credential,
                   (PULONG_PTR)&Credential->LogonDomainName.Buffer );


    *CredentialBuffer = Credential;
    if ( CredentialSize != NULL ) {
        *CredentialSize = CredentialString.Length;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
NlpDeletePrimaryCredential(
    IN PLUID LogonId
    )


/*++

Routine Description:

    This routine deletes the credential for the given LogonId.

Arguments:

    LogonId - The LogonId of the LogonSession to delete the Credentials for.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;
    STRING PrimaryKeyValue;

    RtlInitString( &PrimaryKeyValue, MSV1_0_PRIMARY_KEY );

    Status = (*Lsa.DeleteCredential)( LogonId,
                                    MspAuthenticationPackageId,
                                    &PrimaryKeyValue );

    return Status;

}


NTSTATUS
NlpChangePassword(
    IN BOOLEAN Validated,
    IN PUNICODE_STRING pDomainName,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pPassword
    )

/*++

Routine Description:

    Change the password for the specified user in all currently stored
    credentials.

Arguments:

    pDomainName - The Netbios name of the domain in which the account exists.

    pUserName - The name of the account whose password is to be changed.

    pPassword - The new password.

Return Value:

    STATUS_SUCCESS - If the operation was successful.

--*/
{
    NTSTATUS Status = STATUS_NOT_FOUND;

    MSV1_0_PRIMARY_CREDENTIAL TempCredential;

    LUID FastLogonIds[ 32 ];
    PLUID pSlowLogonIds = NULL;
    ULONG AllocatedLogonIds;

    PLUID LogonIds;
    ULONG cLogonIds;
    UNICODE_STRING NetBiosLogonDomainName = {0};
    UNICODE_STRING DnsDomainName = {0};
    UNICODE_STRING* pNetBiosLogonDomainName = NULL;
    ACTIVE_LOGON* pActiveLogon = NULL;
    LIST_ENTRY* pScan = NULL;

    cLogonIds = 0;
    LogonIds = FastLogonIds;
    AllocatedLogonIds = sizeof(FastLogonIds) / sizeof(LUID);

    //
    // we call NlpChangeCachePassword here to ensure that non-trusted service
    // callers do not change cached passwords that do not belong to themselves
    //
    // it is understood that NlpChangeCachePassword can be called again later
    // for the same request
    //

    //
    // Compute the OWFs of the password.
    //

    NlpPutOwfsInPrimaryCredential( pPassword, FALSE, &TempCredential );

    Status = NlpChangeCachePassword(
                Validated,
                pDomainName,
                pUserName,
                &TempCredential.LmOwfPassword,
                &TempCredential.NtOwfPassword
                );

    RtlSecureZeroMemory( &TempCredential, sizeof(TempCredential) );

    //
    // STATUS_PRIVILEGE_NOT_HELD means the caller is not allowed to change
    // cached passwords, if so bail out now
    //

    if (STATUS_PRIVILEGE_NOT_HELD == Status)
    {
        goto Cleanup;
    }

    Status = LsaIGetNbAndDnsDomainNames( pDomainName, &DnsDomainName, &NetBiosLogonDomainName );

    if (NT_SUCCESS(Status) && NetBiosLogonDomainName.Length != 0)
    {
        pNetBiosLogonDomainName = &NetBiosLogonDomainName;
    }
    else
    {
        pNetBiosLogonDomainName = pDomainName;
    }

    //
    // Loop through the table looking for this particular UserName/DomainName.
    //

    NlpLockActiveLogonsRead();

    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);
        if (!RtlEqualUnicodeString( pUserName, &pActiveLogon->UserName, (BOOLEAN) TRUE ))
        {
            continue;
        }

        if (!RtlEqualDomainName( pNetBiosLogonDomainName, &pActiveLogon->LogonDomainName ))
        {
            continue;
        }

        SspPrint((SSP_UPDATES, "NlpChangePassword matched LogonId=%lx.%lx\n",
            pActiveLogon->LogonId.LowPart, pActiveLogon->LogonId.HighPart));

        //
        // if we don't have space to store the new entry, allocate a new
        // buffer, copy the existing buffer, and keep going.
        //

        if (AllocatedLogonIds < (cLogonIds + 1))
        {
            PLUID OldLogonIds = pSlowLogonIds;

            AllocatedLogonIds *= 2;

            pSlowLogonIds = I_NtLmAllocate( AllocatedLogonIds * sizeof(LUID) );
            if ( pSlowLogonIds == NULL )
            {
                break;
            }

            CopyMemory( pSlowLogonIds, LogonIds, cLogonIds * sizeof(LUID) );

            LogonIds = pSlowLogonIds;

            if ( OldLogonIds != NULL )
            {
                I_NtLmFree( OldLogonIds );
            }
        }

        LogonIds[ cLogonIds ] = pActiveLogon->LogonId;

        cLogonIds++;
    }

    NlpUnlockActiveLogons();

    //
    // Pass the change back to the LSA. Note - this only changes it for the
    // last element in the list.
    //

    if (cLogonIds != 0)
    {
        SECPKG_PRIMARY_CRED PrimaryCredentials;
        ULONG Index;

        RtlZeroMemory(
            &PrimaryCredentials,
            sizeof(SECPKG_PRIMARY_CRED)
            );

        PrimaryCredentials.Password = *pPassword;
        PrimaryCredentials.Flags = PRIMARY_CRED_UPDATE | PRIMARY_CRED_CLEAR_PASSWORD;

        //
        // update each instance of the credential that matches.
        // Multiple logon session can legally reference the same creds,
        // eg: Terminal Services, RunAs, etc.
        //

        for ( Index = 0 ; Index < cLogonIds ; Index++ )
        {
            PrimaryCredentials.LogonId = LogonIds[ Index ];

            (VOID) LsaFunctions->UpdateCredentials(
                                    &PrimaryCredentials,
                                    NULL            // no supplemental credentials
                                    );
        }

        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NOT_FOUND;
    }

Cleanup:

    if (pSlowLogonIds)
    {
        I_NtLmFree(pSlowLogonIds);
    }

    if (NetBiosLogonDomainName.Buffer)
    {
        LsaIFreeHeap(NetBiosLogonDomainName.Buffer);
    }

    if (DnsDomainName.Buffer)
    {
        LsaIFreeHeap(DnsDomainName.Buffer);
    }

    return Status;
}


NTSTATUS
NlpChangePwdCredByLogonId(
    IN PLUID pLogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL pNewCredential,
    IN BOOL bNotify
    )

/*++

Routine Description:

    Change the password for the specified user in all currently stored
    credentials.

Arguments:

    pLogonId - Logon ID of user whose password changed.

    pNewCredential - New credential.
    
    bNotify - Whether to notify password changes

Return Value:

    STATUS_SUCCESS - If the operation was successful.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMSV1_0_PRIMARY_CREDENTIAL pCredential = NULL;
    ULONG CredentialSize;
    LIST_ENTRY* pScan = NULL;
    ACTIVE_LOGON* pActiveLogon = NULL;

    //
    // Loop through the table looking for this particular UserName/DomainName.
    //

    // conservative: take the full write lock up front.
    NlpLockActiveLogonsWrite();

    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);

        if (!RtlEqualLuid( pLogonId, &pActiveLogon->LogonId))
        {
            continue;
        }

        SspPrint((SSP_UPDATES, "NlpChangePwdCredByLogonId LogonId %#x:%#x for %wZ\\%wZ\n",
            pLogonId->HighPart, pLogonId->LowPart, &pNewCredential->LogonDomainName, &pNewCredential->UserName));


        //
        // Get the current credential for this logonid.
        //

        Status = NlpGetPrimaryCredential( &pActiveLogon->LogonId,
                                          &pCredential,
                                          &CredentialSize );

        if ( !NT_SUCCESS(Status) )
        {
            break;
        }

        //
        // check if this upate is fake
        //

        if (RtlEqualMemory(
                &pCredential->NtOwfPassword, 
                &pNewCredential->NtOwfPassword, 
                sizeof(NT_OWF_PASSWORD)
                )) 
        {
            SspPrint((SSP_UPDATES, "NlpChangePwdCredByLogonId skip fake update for %#x:%#x\n",
               pLogonId->HighPart, pLogonId->LowPart));

            break;
        }

        //
        // Notify DPAPI that the user password has been changed. DPAPI will take
        // this opportunity to re-synchronize its master keys if necessary.
        //
        
        if (bNotify) 
        {
            #if 0

            BYTE BufferIn[8] = {0};
            DATA_BLOB DataIn = {0};
            DATA_BLOB DataOut = {0};
     
            DataIn.pbData = BufferIn;
            DataIn.cbData = sizeof(BufferIn);
     
            SspPrint((SSP_UPDATES, "NlpChangePwdCredByLogonId %#x:%#x for %wZ\\%wZ notifying DPAPI\n",
                pLogonId->HighPart, pLogonId->LowPart, &pNewCredential->LogonDomainName, &pNewCredential->UserName));
            
            CryptProtectData(
                &DataIn,
                NULL,
                NULL,
                NULL,
                NULL,
                CRYPTPROTECT_CRED_SYNC,
                &DataOut
                );

            #endif
        }

        //
        // Delete it from the LSA
        //

        Status = NlpDeletePrimaryCredential( &pActiveLogon->LogonId );

        if ( !NT_SUCCESS(Status) )
        {
            LsaFunctions->FreeLsaHeap( pCredential );
            break;
        }

        //
        // Change the passwords in it
        //

        pCredential->LmOwfPassword = pNewCredential->LmOwfPassword;
        pCredential->NtOwfPassword = pNewCredential->NtOwfPassword;
        pCredential->ShaOwfPassword = pNewCredential->ShaOwfPassword;
        pCredential->LmPasswordPresent = pNewCredential->LmPasswordPresent;
        pCredential->NtPasswordPresent = pNewCredential->NtPasswordPresent;
        pCredential->ShaPasswordPresent = pNewCredential->ShaPasswordPresent;

        //
        // Add it back to the LSA.
        //

        Status = NlpAddPrimaryCredential(
                    &pActiveLogon->LogonId,
                    pCredential,
                    CredentialSize
                    );

        LsaFunctions->FreeLsaHeap( pCredential );

        if ( !NT_SUCCESS(Status) )
        {
            break;
        }

        //
        // Pass the new password on to the logon cache
        //

        (VOID) NlpChangeCachePassword(
                    TRUE, // called only by SpAcceptCredentials, where the password is validated
                    &pActiveLogon->LogonDomainName,
                    &pActiveLogon->UserName,
                    &pNewCredential->LmOwfPassword,
                    &pNewCredential->NtOwfPassword
                    );

        break;
    }

    NlpUnlockActiveLogons();

    return Status;
}


VOID
NlpGetAccountNames(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    OUT PUNICODE_STRING SamAccountName,
    OUT PUNICODE_STRING NetbiosDomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING Upn
    )

/*++

Routine Description:

    Get the sundry account names from the LogonInfo and NlpUser

Arguments:

    LogonInfo - pointer to NETLOGON_INTERACTIVE_INFO structure which contains
                  the domain name, user name and password for this user. These
                  are what the user typed to WinLogon

    NlpUser - pointer to NETLOGON_VALIDATION_SAM_INFO4 structure which
                  contains this user's specific interactive logon information

    SamAccountName - Returns the SamAccountName of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.

    NetbiosDomainName - Returns the NetbiosDomainName of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.

    DnsDomainName - Returns the DnsDomainName of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.
        The returned length will be zero if DnsDomainName is not known.

    UPN - Returns the UPN of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.
        The returned length will be zero if UPN is not known.

Return Value:

    None.

--*/
{

    //
    // Return the SamAccountName and Netbios Domain Name
    //
    *SamAccountName = NlpUser->EffectiveName;
    *NetbiosDomainName = NlpUser->LogonDomainName;

    //
    // Return the DNS domain name.
    //

    *DnsDomainName = NlpUser->DnsLogonDomainName;

    //
    // Determine the UPN of the account
    //
    // If the caller passed in a UPN
    //   use it.
    // else
    //   use the UPN returned from the DC
    //
    // The caller passed in a UPN if all of the following are true:
    //  There is no domain name.
    //  The passed in user name isn't the one returned from the DC.
    //  The passed in user name has an @ in it.
    //
    //

    RtlZeroMemory(Upn, sizeof(*Upn));

    if ( LogonInfo->LogonDomainName.Length == 0 &&
         !RtlEqualUnicodeString( &LogonInfo->UserName, &NlpUser->EffectiveName, (BOOLEAN) TRUE ) ) {
    
         ULONG i;
    
         for ( i=0; i<LogonInfo->UserName.Length/sizeof(WCHAR); i++) {
    
             if ( LogonInfo->UserName.Buffer[i] == L'@') {
                 *Upn = LogonInfo->UserName;
                 break;
             }
         }
    
    }

    if ( Upn->Length == 0 ) {

        *Upn = NlpUser->Upn;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   NlpCopyDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID at the location indicated by TargetSid
//
//  Effects:
//
//  Arguments:  TargetSid - target memory location
//              DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Size - Size of the sid copied
//
//  Notes:
//
//
//--------------------------------------------------------------------------

DWORD
NlpCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, TargetSid, DomainId ) ) ) {
        return 0;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( TargetSid ))) ++;
    *RtlSubAuthoritySid( TargetSid, DomainIdSubAuthorityCount ) = RelativeId;

    return Size;
}


//
// temporary home for this function.
//


NTSTATUS
RtlCalculateShaOwfPassword(
    IN PSHA_PASSWORD ShaPassword,
    OUT PSHA_OWF_PASSWORD ShaOwfPassword
    )

/*++

Routine Description:

    Takes the passed ShaPassword and performs a one-way-function on it.
    Uses the FIPS approved SHA-1 function

Arguments:

    ShaPassword - The password to perform the one-way-function on.

    ShaOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in ShaOwfPassword.
--*/

{
    A_SHA_CTX   SHA_Context;

    A_SHAInit(&SHA_Context);
    A_SHAUpdate(&SHA_Context, (PUCHAR) ShaPassword->Buffer, ShaPassword->Length);
    A_SHAFinal(&SHA_Context, (PUCHAR) ShaOwfPassword);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nlp.h

Abstract:

    NETLOGON private definitions.

Author:

    Jim Kelly 11-Apr-1991

Revision History:
   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlp.h

--*/

#ifndef _NLP_
#define _NLP_

#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <logonmsv.h>
#include <samrpc.h>
#include <align.h>
#include <dsgetdc.h>
#include <ntdsapi.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// nlmain.c will #include this file with NLP_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NLP_ALLOCATE
#define EXTERN
#define INIT(_X) = _X
#else
#define EXTERN extern
#define INIT(_X)
#endif

//
// Amount of time to wait for netlogon to start.
//  Do this AFTER waiting for SAM to start.
//  Since Netlogon depends on SAM, don't timeout too soon.
#define NETLOGON_STARTUP_TIME   45          // 45 seconds

//
// Amount of time to wait for SAM to start.
//  DS recovery can take a very long time.
#define SAM_STARTUP_TIME        (20*60)     // 20 minutes

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private data structures                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Magic values to protect ourselves from mean spirited packages "NTLM"
//

#define NTLM_ACTIVE_LOGON_MAGIC_SIGNATURE    0x4D4C544E

//
// Structure used to keep track of all private information related to a
//  particular LogonId.
//

typedef struct _ACTIVE_LOGON {
    LIST_ENTRY ListEntry;
    ULONG Signature;
    LUID LogonId;               // The logon Id of this logon session

    ULONG EnumHandle;           // The enumeration handle of this logon session

    SECURITY_LOGON_TYPE LogonType;  // Type of logon (interactive or service)

    PSID UserSid;               // Sid of the logged on user

    UNICODE_STRING UserName;    // SAM Account name of the logged on user (Required)

    UNICODE_STRING LogonDomainName; // Netbios name of the domain logged onto (Required)

    UNICODE_STRING LogonServer; // Name of the server which logged this user on

    ULONG Flags;                    // Attributes of this entry.

#define LOGON_BY_NETLOGON   0x01    // Entry was validated by NETLOGON service
#define LOGON_BY_CACHE      0x02    // Entry was validated by local cache
#define LOGON_BY_OTHER_PACKAGE 0x04 // Entry was validated by another authentication package
#define LOGON_BY_LOCAL 0x08         // Entry was validated by local sam
#define LOGON_BY_NTLM3_DC   0x10    // Entry was validated by DC that understands NTLM3

} ACTIVE_LOGON, *PACTIVE_LOGON;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CREDENTIAL Related Data Structures                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//   Following is a description of the content and format of each type
//   of credential maintained by the MsV1_0 authentication package.
//
//   The MsV1_0 authentication package defines the following credential
//   primary key string values:
//
//       "Primary" - Is used to hold the primary credentials provided at
//           initial logon time.  This includes the username and both
//           case-sensitive and case-insensitive forms of the user's
//           password.
//
//   NOTE: All poitners stored in credentials must be
//   changed to be an offset to the body rather than a pointer.  This is
//   because credential fields are copied by the LSA and so the pointer
//   would become invalid.
//


//
// MsV1_0 Primary Credentials
//
//
//        The PrimaryKeyValue string of this type of credential contains the
//        following string:
//
//                  "Primary"
//
//        The Credential string of a Primary credential contains the following
//        values:
//
//             o  The user's username
//
//             o  A one-way function of the user's password as typed.
//
//             o  A one-way function of the user's password upper-cased.
//
//        These values are structured as follows:
//

#define MSV1_0_PRIMARY_KEY "Primary"

//
// move the SHA stuff to crypt.h when possible.
//

typedef UNICODE_STRING              SHA_PASSWORD;
typedef SHA_PASSWORD *              PSHA_PASSWORD;

#define SHA_OWF_PASSWORD_LENGTH     (20)

typedef struct {
    CHAR Data[ SHA_OWF_PASSWORD_LENGTH ];
} SHA_OWF_PASSWORD, *PSHA_OWF_PASSWORD;

NTSTATUS
RtlCalculateShaOwfPassword(
    IN PSHA_PASSWORD ShaPassword,
    OUT PSHA_OWF_PASSWORD ShaOwfPassword
    );


typedef struct _MSV1_0_PRIMARY_CREDENTIAL {
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    NT_OWF_PASSWORD NtOwfPassword;
    LM_OWF_PASSWORD LmOwfPassword;
    SHA_OWF_PASSWORD ShaOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
    BOOLEAN ShaPasswordPresent;
} MSV1_0_PRIMARY_CREDENTIAL, *PMSV1_0_PRIMARY_CREDENTIAL;

//
// Structure describing a buffer in the clients address space.
//

typedef struct _CLIENT_BUFFER_DESC {
    PLSA_CLIENT_REQUEST ClientRequest;
    LPBYTE UserBuffer;      // Address of buffer in client's address space
    LPBYTE MsvBuffer;       // Address of mirror buffer in MSV's address space
    ULONG StringOffset;     // Current offset to variable length data
    ULONG TotalSize;        // Size (in bytes) of buffer
} CLIENT_BUFFER_DESC, *PCLIENT_BUFFER_DESC;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal routine definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// From nlmain.c.
//

NTSTATUS
NlSamInitialize(
    ULONG Timeout
    );

//
// From nlp.c.
//

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    );

VOID
NlpInitClientBuffer(
    OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PLSA_CLIENT_REQUEST ClientRequest
    );

NTSTATUS
NlpAllocateClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN ULONG FixedSize,
    IN ULONG TotalSize
    );

NTSTATUS
NlpFlushClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    OUT PVOID* UserBuffer
    );

VOID
NlpFreeClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc
    );

VOID
NlpPutClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

VOID
NlpMakeRelativeString(
    IN PUCHAR BaseAddress,
    IN OUT PUNICODE_STRING String
    );

VOID
NlpRelativeToAbsolute(
    IN PVOID BaseAddress,
    IN OUT PULONG_PTR RelativeValue
    );

ACTIVE_LOGON*
NlpFindActiveLogon(
    IN LUID* pLogonId
    );

ULONG
NlpCountActiveLogon(
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING UserName
    );

NTSTATUS
NlpAllocateInteractiveProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    );

NTSTATUS
NlpAllocateNetworkProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    );

PSID
NlpMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

NTSTATUS
NlpMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    OUT PLSA_TOKEN_INFORMATION_V1 *TokenInformation
    );

VOID
NlpPutOwfsInPrimaryCredential(
    IN PUNICODE_STRING CleartextPassword,
    IN BOOLEAN bIsOwfPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL Credential
    );

NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpMakePrimaryCredentialFromMsvCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN  PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredential,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpAddPrimaryCredential(
    IN PLUID LogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL Credential,
    IN ULONG CredentialSize
    );

NTSTATUS
NlpGetPrimaryCredential(
    IN PLUID LogonId,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpGetPrimaryCredentialByUserSid(
    IN  PSID pSid,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize OPTIONAL
    );

NTSTATUS
NlpDeletePrimaryCredential(
    IN PLUID LogonId
    );

NTSTATUS
NlpChangePassword(
    IN BOOLEAN Validated,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    );

NTSTATUS
NlpChangePwdCredByLogonId(
    IN PLUID pLogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL pNewCredential,
    IN BOOL bNotify
    );

VOID
NlpGetAccountNames(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    OUT PUNICODE_STRING SamAccountName,
    OUT PUNICODE_STRING NetbiosDomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING Upn
    );

//
// msvsam.c
//

BOOLEAN
MsvpPasswordValidate (
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN PUSER_INTERNAL1_INFORMATION Passwords,
    OUT PULONG UserFlags,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
);

//
// nlnetapi.c
//

VOID
NlpLoadNetapiDll (
    VOID
    );

VOID
NlpLoadNetlogonDll (
    VOID
    );

//
// subauth.c
//

VOID
Msv1_0SubAuthenticationInitialization(
    VOID
    );

///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Null copies of Lanman and NT OWF password.
//
//

EXTERN LM_OWF_PASSWORD NlpNullLmOwfPassword;
EXTERN NT_OWF_PASSWORD NlpNullNtOwfPassword;

//
// Flag indicating our support for the LM challenge response protocol.
// If the flag is set to NoLm, MSV1_0 will not ever compute a LM
// challenge response. If it is set to AllowLm, MSV1_0 will not return
// it unless requested. Otherwise it will do the normal behaviour of
// returning both NT and LM challenge responses
//

typedef enum _LM_PROTOCOL_SUPPORT {
    UseLm,              // send LM response, NTLM response
    AllowLm,            // same as UseLm; for b/w compat w/lsa2-fix
    NoLm, //UseNtlm,            // Send NTLM response only; for b/w compat w/lsa2-fix
    UseNtlm3,           // Send NTLM3 response even if no target domain\server specified
    RefuseLm,           // Refuse LM responses (no Win9x clients) -- unsupported, reserved
    RefuseNtlm,         // Refuse LM and NTLM responses (require all clients are upgraded)
    RefuseNtlm3NoTarget // Refuse NTLM3 response witout domain and server info
} LM_PROTOCOL_SUPPORT, *PLM_PROTOCOL_SUPPORT;

#if 0

//
// This macro determines whether or not to return an LM challenge response.
// If NlpProtocolSupport == UseLm, we always return it. If it is
// AllowLm, only return it if the RETURN_LM_RESPONSE flag is set. Otherwise
// don't return it ever.
//

#define NlpReturnLmResponse(_Flags_) \
    ((NlpLmProtocolSupport == UseLm) || \
     ((NlpLmProtocolSupport == AllowLm) && \
      (((_Flags_) & RETURN_NON_NT_USER_SESSION_KEY) != 0)))

#define NlpChallengeResponseRequestSupported( _Flags_ ) \
 ((((_Flags_) & RETURN_NON_NT_USER_SESSION_KEY) == 0) || (NlpLmProtocolSupport != NoLm))

#endif


NET_API_STATUS NET_API_FUNCTION RxNetUserPasswordSet(LPWSTR, LPWSTR, LPWSTR, LPWSTR);
NTSTATUS NetpApiStatusToNtStatus( NET_API_STATUS );

//
// Routines in netlogon.dll
//

EXTERN HANDLE NlpNetlogonDllHandle;
EXTERN PNETLOGON_SAM_LOGON_PROCEDURE NlpNetLogonSamLogon;

typedef NTSTATUS
(*PNETLOGON_MIXED_DOMAIN_PROCEDURE)(
    OUT PBOOL MixedMode
    );

EXTERN PNETLOGON_MIXED_DOMAIN_PROCEDURE NlpNetLogonMixedDomain;

//
// TRUE if package is initialized
//

EXTERN BOOLEAN NlpMsvInitialized INIT(FALSE);

//
// TRUE if this is a workstation.
//

EXTERN BOOLEAN NlpWorkstation INIT(TRUE);

//
// TRUE once the MSV AP has initialized its connection to SAM.
//

EXTERN BOOLEAN NlpSamInitialized INIT(FALSE);

//
// TRUE if the MSV AP has initialized its connection to the NETLOGON service
//

EXTERN BOOLEAN NlpNetlogonInitialized INIT(FALSE);

//
// TRUE if LanMan is installed.
//

EXTERN BOOLEAN NlpLanmanInstalled INIT(FALSE);

//
// Computername of this computer.
//

EXTERN UNICODE_STRING NlpComputerName;

//
// Domain of which I am a member.
//

EXTERN UNICODE_STRING NlpPrimaryDomainName;

//
// Name of the MSV1_0 package
//

EXTERN UNICODE_STRING NlpMsv1_0PackageName;


//
// Name and domain id of the SAM account database.
//

EXTERN UNICODE_STRING NlpSamDomainName;
EXTERN PSID NlpSamDomainId;
EXTERN SAMPR_HANDLE NlpSamDomainHandle;
EXTERN BOOLEAN NlpUasCompatibilityRequired INIT(TRUE);

//
// TRUE if there is a subauthentication package zero
//

EXTERN BOOLEAN NlpSubAuthZeroExists INIT(TRUE);


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Define the list of active interactive logons.
//
// The NlpActiveLogonLock must be locked while referencing the list or
// any of its elements.
//

#define NlpLockActiveLogonsRead()           RtlAcquireResourceShared(&NlpActiveLogonLock,TRUE)
#define NlpLockActiveLogonsWrite()          RtlAcquireResourceExclusive(&NlpActiveLogonLock,TRUE)
#define NlpLockActiveLogonsReadToWrite()    RtlConvertSharedToExclusive(&NlpActiveLogonLock)
#define NlpUnlockActiveLogons()             RtlReleaseResource(&NlpActiveLogonLock)

EXTERN RTL_RESOURCE NlpActiveLogonLock;
EXTERN LIST_ENTRY NlpActiveLogonListAnchor;

//
// Define the running enumeration handle.
//
// This variable defines the enumeration handle to assign to a logon
//  session.  It will be incremented prior to assigning it value to
//  the next created logon session.  Access is serialize using
//  the interlocked primitives.

EXTERN ULONG NlpEnumerationHandle;

EXTERN ULONG NlpLogonAttemptCount;

NTSTATUS
NlWaitForNetlogon(
    IN ULONG Timeout
    );

#undef EXTERN
#undef INIT

#ifdef __cplusplus
}
#endif // __cplusplus

#endif _NLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlnetapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nlnetapi.c

Abstract:

   This module loads Netapi.dll at runtime and sets up pointers to
   the APIs called by Msv1_0.

Author:

    Dave Hart (DaveHart) 25-Mar-1992

Environment:

    User mode Win32 - msv1_0 authentication package DLL

Revision History:
    Dave Hart (DaveHart) 26-Mar-1992
        Added RxNetUserPasswordSet.

    Dave Hart (DaveHart) 30-May-1992
        Removed NetRemoteComputerSupports, added NetApiBufferAllocate.

    Chandana Surlu       21-Jul-1996
        Stolen from \\kernel\razzle3\src\security\msv1_0\nlnetapi.c

    Scott Field (sfield) 19-May-1999
        Use DELAYLOAD against ntdsapi.dll and netapi32.dll

--*/

#include "msp.h"
#include "nlp.h"

typedef NTSTATUS
            (*PI_NetNotifyNetlogonDllHandle) (
                IN PHANDLE Role
            );

VOID
NlpLoadNetlogonDll (
    VOID
    )

/*++

Routine Description:

    Uses Win32 LoadLibrary and GetProcAddress to get pointers to functions
    in Netlogon.dll that are called by Msv1_0.

Arguments:

    None.

Return Value:

    None.  If successful, NlpNetlogonDllHandle is set to non-null and function
    pointers are setup.


--*/

{
    HANDLE hModule = NULL;
    PI_NetNotifyNetlogonDllHandle pI_NetNotifyNetlogonDllHandle = NULL;

    //
    // Load netlogon.dll also.
    //

    hModule = LoadLibraryA("netlogon");

    if (NULL == hModule) {
#if DBG
        DbgPrint("Msv1_0: Unable to load netlogon.dll, Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }

    NlpNetLogonSamLogon = (PNETLOGON_SAM_LOGON_PROCEDURE)
        GetProcAddress(hModule, "NetILogonSamLogon");

    if (NlpNetLogonSamLogon == NULL) {
#if DBG
        DbgPrint(
            "Msv1_0: Can't find entrypoint NetILogonSamLogon in netlogon.dll.\n"
            "        Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }

    NlpNetLogonMixedDomain = (PNETLOGON_MIXED_DOMAIN_PROCEDURE)
        GetProcAddress(hModule, "I_NetLogonMixedDomain");

    if (NlpNetLogonMixedDomain == NULL) {
#if DBG
        DbgPrint(
            "Msv1_0: Can't find entrypoint I_NetLogonMixedDomain in netlogon.dll.\n"
            "        Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }

    //
    // Find the address of the I_NetNotifyNetlogonDllHandle procedure.
    //  This is an optional procedure so don't complain if it isn't there.
    //

    pI_NetNotifyNetlogonDllHandle = (PI_NetNotifyNetlogonDllHandle)
        GetProcAddress( hModule, "I_NetNotifyNetlogonDllHandle" );

    //
    // Found all the functions needed, so indicate success.
    //

    NlpNetlogonDllHandle = hModule;
    hModule = NULL;

    //
    // Notify Netlogon that we've loaded it.
    //

    if ( pI_NetNotifyNetlogonDllHandle != NULL ) {
        (VOID) (*pI_NetNotifyNetlogonDllHandle)( &NlpNetlogonDllHandle );
    }

Cleanup:
    if ( hModule != NULL ) {
        FreeLibrary( hModule );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlpcache.c ===
/*++

Copyright (c) 1991 - 1999  Microsoft Corporation

Module Name:

    nlpcache.c

Abstract:

    This module contains routines which implement user account caching:

        NlpCacheInitialize
        NlpCacheTerminate
        NlpAddCacheEntry
        NlpGetCacheEntry
        NlpDeleteCacheEntry
        NlpChangeCachePassword


    The cache contains the most recent validated logon information. There is
    only 1 (that's right - one) cache slot. This will probably change though

Author:

    Richard L Firth (rfirth) 17-Dec-1991

Revision History:

   Scott Field (sfield)   04-Jun-99
        Add supplemental cache data.
        Store all cache related data in single location.
        Encrypt interesting elements of cache entry using per-entry key mixed with per-machine key.
        MAC interesting cache elements for integrity check.
        Drastically reduce lock contention.
        Avoid NtFlushKey() for single location cache elements.
        Avoid persisting a new cache entry that matches an existing one.
        Attempt reg query with stack based buffer first.

   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlpcache.c

--*/

#include <global.h>
#undef EXTERN

#include "msp.h"
#include "nlp.h"
#include "nlpcache.h"

//
// manifests
//

#if DBG
#include <stdio.h>
#endif

//
// Revision numbers
//
//      NT 3.0 didn't explicitly store a revision number.
//          However, we are designating that release to be revision 0x00010000 (1.0).
//      NT 3.5 prior to build 622 is revision 0x00010001 (1.1).
//      NT 3.5 is revision 0x00010002 (1.2).
//      NT 4.0 SP 4 is revision 0x00010003 (1.3)
//      NT 5.0 build 2054+ is revision 0x00010004 (1.4)
//

#define NLP_CACHE_REVISION_NT_1_0         (0x00010000)  // NT 3.0
#define NLP_CACHE_REVISION_NT_1_0B        (0x00010002)  // NT 3.5
#define NLP_CACHE_REVISION_NT_4_SP4       (0x00010003)  // NT 4.0 SP 4 to save passwords as salted.
#define NLP_CACHE_REVISION_NT_5_0         (0x00010004)  // NT 5.0 to support opaque cache data and single location data storage.
#define NLP_CACHE_REVISION                (NLP_CACHE_REVISION_NT_5_0)

//
// The logon cache may be controlled via a value in the registry.
// If the registry key does not exist, then this default constant defines
// how many logon cache entries will be active.  The max constant
// places an upper limit on how many cache entries we will support.
// If the user specifies more than the max value, we will use the
// max value instead.
//

#define NLP_DEFAULT_LOGON_CACHE_COUNT           (10)
#define NLP_MAX_LOGON_CACHE_COUNT               (50)

//
// length of per-machine cache encryption key.
//

#define NLP_CACHE_ENCRYPTION_KEY_LEN            (64)

//
// name of LSA secret containing cache encryption key.
//

#define NLP_CACHE_ENCRYPTION_KEY_NAME           L"NL$KM"

//
// macros
//

#define AllocateCacheEntry(n)   (PLOGON_CACHE_ENTRY)I_NtLmAllocate(n)
#define FreeCacheEntry(p)       I_NtLmFree((PVOID)p)
#define AllocateFromHeap(n)     I_NtLmAllocate(n)
#define FreeToHeap(p)           I_NtLmFree((PVOID)p)

//
// guard against simultaneous access
//

#define READ_CACHE()            RtlAcquireResourceShared(&NlpLogonCacheCritSec, TRUE)
#define WRITE_CACHE()           RtlAcquireResourceExclusive(&NlpLogonCacheCritSec, TRUE)
#define READ_TO_WRITE_CACHE()   RtlConvertSharedToExclusive(&NlpLogonCacheCritSec)
#define LEAVE_CACHE()           RtlReleaseResource(&NlpLogonCacheCritSec)

#define INVALIDATE_HANDLE(handle) (*((PHANDLE)(&handle)) = INVALID_HANDLE_VALUE)
#define IS_VALID_HANDLE(handle)   (handle != INVALID_HANDLE_VALUE)


////////////////////////////////////////////////////////////////////////
//                                                                    //
// datatypes                                                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef enum _NLP_SET_TIME_HINT {
    NLP_SMALL_TIME,
    NLP_BIG_TIME,
    NLP_NOW_TIME
} NLP_SET_TIME_HINT, *PNLP_SET_TIME_HINT;

#define BIG_PART_1      0x7fffffff  // largest positive large int is 63 bits on
#define BIG_PART_2      0xffffffff
#define SMALL_PART_1    0x0         // smallest positive large int is 64 bits off
#define SMALL_PART_2    0x0

//
// This structure is saved on disk and provides information
// about the rest of the cache.  This structure is in a value
// named "NL$Control" under the cache registry key.
//

typedef struct _NLP_CACHE_CONTROL {

    //
    // Revision of the cache on-disk structure
    //

    ULONG       Revision;

    //
    // The current on-disk size of the cache (number of entries)
    //

    ULONG       Entries;

} NLP_CACHE_CONTROL, *PNLP_CACHE_CONTROL;


//
// This data structure is a single cache table entry (CTE)
// Each entry in the cache has a corresponding CTE.
//

typedef struct _NLP_CTE {

        //
        // CTEs are linked on either an invalid list (in any order)
        // or on a valid list (in ascending order of time).
        // This makes it easy to figure out which entry is to be
        // flushed when adding to the cache.
        //

        LIST_ENTRY Link;

        //
        // Time the cache entry was established.
        // This is used to determine which cache
        // entry is the oldest, and therefore will
        // be flushed from the cache first to make
        // room for new entries.
        //

        LARGE_INTEGER       Time;

        //
        // This field contains the index of the CTE within the
        // CTE table.  This index is used to generate the names
        // of the entrie's secret key and cache key in the registry.
        // This field is valid even if the entry is marked Inactive.
        //

        ULONG               Index;

        //
        // Normally, we walk the active and inactive lists
        // to find entries.  When growing or shrinking the
        // cache, however, it is nice to be able to walk the
        // table using indexes.  In this case, it is nice to
        // have a local way of determining whether an entry
        // is on the active or inactive list.  This field
        // provides that capability.
        //
        //      TRUE  ==> on active list
        //      FALSE ==> not on active list
        //

        BOOLEAN             Active;


} NLP_CTE, *PNLP_CTE;

//
// This structure is used for keeping track of all information that
// is stored on backing store.
//

typedef struct _NLP_CACHE_AND_SECRETS {
    PLOGON_CACHE_ENTRY          CacheEntry;
    ULONG                       EntrySize;
    PLSAPR_CR_CIPHER_VALUE      NewSecret;
    PLSAPR_CR_CIPHER_VALUE      OldSecret;
    BOOLEAN                     Active;
} NLP_CACHE_AND_SECRETS,  *PNLP_CACHE_AND_SECRETS;


////////////////////////////////////////////////////////////////////////
//                                                                    //
// Local Prototypes                                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
NlpInternalCacheInitialize(
    VOID
    );

NTSTATUS
NlpOpenCache( VOID );

VOID
NlpCloseCache( VOID );


NTSTATUS
NlpGetCacheControlInfo( VOID );

NTSTATUS
NlpCacheKeyInitialize(
    VOID
    );

NTSTATUS
NlpBuildCteTable( VOID );

NTSTATUS
NlpChangeCacheSizeIfNecessary( VOID );

NTSTATUS
NlpWriteCacheControl( VOID );

VOID
NlpMakeCacheEntryName(
    IN  ULONG               EntryIndex,
    OUT PUNICODE_STRING     Name
    );

NTSTATUS
NlpMakeNewCacheEntry(
    ULONG           Index
    );

NTSTATUS
NlpEliminateCacheEntry(
    IN  ULONG               Index
    );

NTSTATUS
NlpReadCacheEntryByIndex(
    IN  ULONG               Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG EntrySize
    );

VOID
NlpAddEntryToActiveList(
    IN  ULONG   Index
    );

VOID
NlpAddEntryToInactiveList(
    IN  ULONG   Index
    );

VOID
NlpGetFreeEntryIndex(
    OUT PULONG  Index
    );


NTSTATUS
NlpBuildCacheEntry(
    IN PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN ULONG CacheFlags,
    IN ULONG SupplementalCacheDataLength,
    IN PBYTE SupplementalCacheData,
    OUT PLOGON_CACHE_ENTRY* ppCacheEntry,
    OUT PULONG pEntryLength
    );

BOOLEAN
NlpCompareCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry1,
    IN  ULONG EntrySize1,
    IN  PLOGON_CACHE_ENTRY CacheEntry2,
    IN  ULONG EntrySize2
    );

NTSTATUS
NlpEncryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    );

NTSTATUS
NlpDecryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    );

NTSTATUS
NlpAddSupplementalCacheData(
    IN      PVOID SupplementalCacheData,
    IN      ULONG SupplementalCacheDataLength,
    IN OUT  PLOGON_CACHE_ENTRY *ppCacheEntry,
    IN OUT  PULONG pEntryLength
    );

NTSTATUS
NlpOpenCache( VOID );

VOID
NlpCloseCache( VOID );

NTSTATUS
NlpOpenSecret(
    IN  ULONG   Index
    );

VOID
NlpCloseSecret( VOID );

NTSTATUS
NlpWriteSecret(
    IN  PLSAPR_CR_CIPHER_VALUE NewSecret,
    IN  PLSAPR_CR_CIPHER_VALUE OldSecret
    );

NTSTATUS
NlpReadSecret(
    OUT PLSAPR_CR_CIPHER_VALUE * NewSecret,
    OUT PLSAPR_CR_CIPHER_VALUE * OldSecret
    );

NTSTATUS
NlpMakeSecretPassword(
    OUT PLSAPR_CR_CIPHER_VALUE Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    );

NTSTATUS
NlpMakeSecretPasswordNT5(
    IN OUT PCACHE_PASSWORDS Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    );

NTSTATUS
NlpGetCredentialNamesFromMitCacheEntry(
    IN PLOGON_CACHE_ENTRY CacheEntry,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING UserName
    );

NTSTATUS
NlpGetCredentialNamesFromCacheEntry(
    IN PLOGON_CACHE_ENTRY CacheEntry,
    IN PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING UserName
    );

NTSTATUS
NlpGetCredentialNamesFromMitCacheSupplementalCacheData(
    IN ULONG SupplementalCacheDataLength,
    IN PBYTE SupplementalCacheData,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING UserName
    );

NTSTATUS
NlpReadCacheEntry(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    OUT PULONG              Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG              EntrySize
    );

NTSTATUS
NlpWriteCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY Entry,
    IN  ULONG              EntrySize
    );

VOID
NlpCopyAndUpdateAccountInfo(
    IN  USHORT Length,
    IN  PUNICODE_STRING pUnicodeString,
    IN OUT PUCHAR* pSource,
    IN OUT PUCHAR* pDest
    );

VOID
NlpSetTimeField(
    OUT POLD_LARGE_INTEGER pTimeField,
    IN  NLP_SET_TIME_HINT Hint
    );

NTSTATUS
NlpBuildAccountInfo(
    IN  PLOGON_CACHE_ENTRY pCacheEntry,
    IN  ULONG EntryLength,
    OUT PNETLOGON_VALIDATION_SAM_INFO4* AccountInfo
    );



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//          Diagnostic support services prototypes                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#if DBG
PCHAR
DumpOwfPasswordToString(
    OUT PCHAR Buffer,
    IN  PLM_OWF_PASSWORD Password
    );

VOID
DumpLogonInfo(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo
    );

char*
MapWeekday(
    IN  CSHORT  Weekday
    );

VOID
DumpTime(
    IN  LPSTR   String,
    IN  POLD_LARGE_INTEGER OldTime
    );

VOID
DumpGroupIds(
    IN  LPSTR   String,
    IN  ULONG   Count,
    IN  PGROUP_MEMBERSHIP GroupIds
    );

VOID
DumpSessKey(
    IN  LPSTR   String,
    IN  PUSER_SESSION_KEY Key
    );

VOID
DumpSid(
    LPSTR   String,
    PISID   Sid
    );

VOID
DumpAccountInfo(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo
    );

VOID
DumpCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY pEntry
    );

#endif //DBG


////////////////////////////////////////////////////////////////////////
//                                                                    //
// global data                                                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// This boolean indicates whether or not we have been able to
// initialize caching yet.  It turn out that during authentication
// package load time, we can't do everything we would like to (like
// call LSA RPC routines).  So, we delay initializing until we can
// call LSA.  All publicly exposed interfaces must check this value
// before assuming work can be done.
//

BOOLEAN         NlpInitializationNotYetPerformed = TRUE;

RTL_RESOURCE    NlpLogonCacheCritSec;

HANDLE          NlpCacheHandle  = (HANDLE) INVALID_HANDLE_VALUE;
LSAPR_HANDLE    NlpSecretHandle = (LSAPR_HANDLE) INVALID_HANDLE_VALUE;

//
// control information about the cache (number of entries, etc).
//

NLP_CACHE_CONTROL   NlpCacheControl;

//
// This structure is generated and maintained only in memory.
// It indicates which cache entries are valid and which aren't.
// It also indicates what time each entry was established so we
// know which order to discard them in.
//
//  This field is a pointer to an array of CTEs.  The number of CTEs
//  in the array is in NlpCacheControl.Entries.  This structure is
//  allocated at initialization time.
//

PNLP_CTE            NlpCteTable;


//
// The Cache Table Entries in NlpCteTable are linked on either an
// active or inactive list.  The entries on the active list are in
// ascending time order - so the last one on the list is the first
// one to be discarded when a flush is needed to add a new entry.
//

LIST_ENTRY          NlpActiveCtes;
LIST_ENTRY          NlpInactiveCtes;

//
// global, per-machine key used for encrypting NT_5_0 version cache
// entries.
//

CHAR                NlpCacheEncryptionKey[ NLP_CACHE_ENCRYPTION_KEY_LEN ];

#if DBG
#ifdef DUMP_CACHE_INFO
ULONG   DumpCacheInfo = 1;
#else
ULONG   DumpCacheInfo = 0;
#endif
#endif


////////////////////////////////////////////////////////////////////////
//                                                                    //
// Services Exported by this module                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
NlpCacheInitialize(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize cached logon processing.

    Unfortunately, there isn't much we can do when we are called.
    (we can't open LSA, for example).  So, defer initialization
    until later.


Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    RtlInitializeResource(&NlpLogonCacheCritSec);
    return STATUS_SUCCESS;
}


NTSTATUS
NlpCacheTerminate(
    VOID
    )

/*++

Routine Description:

    Called when process detaches

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpCacheTerminate\n");
    }
#endif

    if (!NlpInitializationNotYetPerformed) {
        NlpCloseCache();
        NlpCloseSecret();

        if (IS_VALID_HANDLE(NlpCacheHandle)) {
            NtClose( NlpCacheHandle );
        }

        FreeToHeap( NlpCteTable );
    }

    RtlDeleteResource(&NlpLogonCacheCritSec);
    return STATUS_SUCCESS;
}


NTSTATUS
NlpGetCacheEntry(
    IN PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    IN ULONG CacheLookupFlags,
    OUT OPTIONAL PUNICODE_STRING CredentialDomainName, // domain/realm name
    OUT OPTIONAL PUNICODE_STRING CredentialUserName,
    OUT PNETLOGON_VALIDATION_SAM_INFO4* AccountInfo,
    OUT PCACHE_PASSWORDS Passwords,
    OUT OPTIONAL PVOID *ppSupplementalCacheData,
    OUT OPTIONAL PULONG pSupplementalCacheDataLength
    )

/*++

Routine Description:

    If the user logging on has information stored in the cache,
    then it is retrieved. Also returns the cached password from
    'secret' storage

Arguments:

    LogonInfo   - pointer to NETLOGON_IDENTITY_INFO structure which contains
                  the domain name, user name for this user
                  
    CacheLookupFlags - flags used to lookup                  
    
    CredentialDomainName - domain name in primary credentials
    
    CredentialUserName  - user name in primary credentials

    AccountInfo - pointer to NETLOGON_VALIDATION_SAM_INFO4 structure to
                  receive this user's specific interactive logon information

    Passwords   - pointer to CACHE_PASSWORDS structure to receive passwords
                  returned from secret storage
    
    ppSupplementalCacheData - supplemental cache data
    
    pSupplementalCacheDataLength - lenght of supplemental cache data

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *AccountInfo points to a NETLOGON_VALIDATION_SAM_INFO4
                    structure. This must be freed by caller

                    *Passwords contain USER_INTERNAL1_INFORMATION structure
                    which contains NT OWF password and LM OWF password. These
                    must be used to validate the logon

        Failure = STATUS_LOGON_FAILURE
                    The user logging on isn't in the cache.

--*/

{
    NTSTATUS
        NtStatus;

    PNETLOGON_VALIDATION_SAM_INFO4
        SamInfo = NULL;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    ULONG
        EntrySize,
        Index;

    PLSAPR_CR_CIPHER_VALUE
        CurrentSecret = NULL,
        OldSecret = NULL;

    BOOLEAN fCacheLocked = FALSE;

    *AccountInfo = NULL;

    if ( ppSupplementalCacheData )
        *ppSupplementalCacheData = NULL;

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpGetCacheEntry\n");
        DumpLogonInfo(LogonInfo);
    }
#endif

    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    if (NlpCacheControl.Entries == 0) {
        return(STATUS_LOGON_FAILURE);
    }

    //
    // TODO: consider comparing LogonDomainName to NlpSamDomainName
    // and failing cached logon attempts at local machine.
    //

    READ_CACHE();
    fCacheLocked = TRUE;

    //
    // Find the cache entry and open its secret (if found)
    //

    NtStatus = NlpReadCacheEntry(
                    &LogonInfo->LogonDomainName,
                    &LogonInfo->UserName,
                    &Index,
                    &CacheEntry,
                    &EntrySize
                    );

    if (!NT_SUCCESS(NtStatus)) {
        LEAVE_CACHE();
        return (NtStatus);
    }

    //
    // exclude smartcard only cache entries for NTLM.
    // check for earlier versions prior to nt_5_0 where SC is not 
    // supported and CacheFlags is not part of the cache entry
    //

    if ( (CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0)
         && ((CacheLookupFlags & MSV1_0_CACHE_LOGON_REQUEST_SMARTCARD_ONLY) == 0)
         && ((CacheEntry->CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_SMARTCARD_ONLY)
             || ((0 == (CacheEntry->CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON))
                  && CacheEntry->SupplementalCacheDataLength)) ) 
    {
        LEAVE_CACHE();
        
        SspPrint((SSP_CRITICAL, "NlpGetCacheEntry can not use smartcard only cacne entry: CacheFlags %#x, LookupFlags %#x\n", CacheEntry->CacheFlags, CacheLookupFlags));

        return STATUS_LOGON_FAILURE;
    }

    if ( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {

        //
        // for NT5, we can release the cache lock now, since all data
        // stored in one place.
        //

        LEAVE_CACHE();
        fCacheLocked = FALSE;

        //
        // if caller wanted supplemental data, give it to them.
        //

        if ( ppSupplementalCacheData && pSupplementalCacheDataLength )
        {
            LPBYTE Source;

            *pSupplementalCacheDataLength = CacheEntry->SupplementalCacheDataLength;

            *ppSupplementalCacheData = MIDL_user_allocate( *pSupplementalCacheDataLength );

            if ( *ppSupplementalCacheData == NULL ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // note: the decrypt operation that occurred during the
            // ReadCacheEntry validates any data and pointers through
            // integrity checking via HMAC.  Having said that, we can be
            // lazy and not do boundry checking.
            //

            Source = ((LPBYTE)CacheEntry + CacheEntry->SupplementalCacheDataOffset);

            CopyMemory( *ppSupplementalCacheData,
                        Source,
                        *pSupplementalCacheDataLength
                        );
        }
    }

    NtStatus = NlpBuildAccountInfo(CacheEntry, EntrySize, &SamInfo);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    if (CredentialDomainName && CredentialUserName) 
    {
        NtStatus = NlpGetCredentialNamesFromCacheEntry(
                        CacheEntry, 
                        SamInfo, 
                        CredentialDomainName, 
                        CredentialUserName
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
        
        SspPrint((SSP_CRED, "NlpGetCacheEntry getting cred %wZ\\%wZ, account %wZ\\%wZ, logon %wZ\\%wZ\n", 
            CredentialDomainName, CredentialUserName, 
            &SamInfo->LogonDomainName, &SamInfo->EffectiveName, 
            &LogonInfo->LogonDomainName, &LogonInfo->UserName));
    }
    
    if ( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {

        //
        // for NT5, the Passwords are stored in the CacheEntry.
        // note: passwords are assumed to be salted.
        //

        RtlCopyMemory( Passwords, &(CacheEntry->CachePasswords), sizeof(*Passwords) );


    } else {

        //
        // prior to NT5, the Passwords are stored separately in their
        // own LSA secret.
        //

        NtStatus = NlpReadSecret(&CurrentSecret, &OldSecret);

        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }

        if ( CurrentSecret == NULL )
        {
            NtStatus = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        //
        // can release the cache lock now, since second data item fetched.
        //

        LEAVE_CACHE();
        fCacheLocked = FALSE;

        //
        // Check to see which version of the passwords are stored
        // here - the normal or the salted.
        //

        RtlCopyMemory((PVOID)Passwords,
            (PVOID)CurrentSecret->Buffer,
            (ULONG)CurrentSecret->Length
            );

        if ( CacheEntry->Revision < NLP_CACHE_REVISION_NT_4_SP4 )
        {
            if (Passwords->SecretPasswords.NtPasswordPresent)
            {
                NtStatus = NlpComputeSaltedHashedPassword(
                                &Passwords->SecretPasswords.NtOwfPassword,
                                &Passwords->SecretPasswords.NtOwfPassword,
                                &SamInfo->EffectiveName
                                );
                if (!NT_SUCCESS(NtStatus))
                {
                    goto Cleanup;
                }
            }

            if (Passwords->SecretPasswords.LmPasswordPresent)
            {
                NtStatus = NlpComputeSaltedHashedPassword(
                                &Passwords->SecretPasswords.LmOwfPassword,
                                &Passwords->SecretPasswords.LmOwfPassword,
                                &SamInfo->EffectiveName
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if ( fCacheLocked ) {
        LEAVE_CACHE();
    }

    //
    // free structure allocated by NlpReadCacheEntry
    //

    if ( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeToHeap(CacheEntry);
    }

    //
    // free structures allocated by NlpReadSecret
    //

    if (CurrentSecret) {
        MIDL_user_free(CurrentSecret);
    }
    if (OldSecret) {
        MIDL_user_free(OldSecret);
    }

    if ( NT_SUCCESS( NtStatus ) ) {
        *AccountInfo = SamInfo;
    } else {

        if ( SamInfo != NULL ) {
            MIDL_user_free( SamInfo );
        }

        if( ppSupplementalCacheData && *ppSupplementalCacheData ) {
            if (pSupplementalCacheDataLength)
            {
                RtlZeroMemory(*ppSupplementalCacheData, *pSupplementalCacheDataLength);
            }
            MIDL_user_free( *ppSupplementalCacheData );
            *ppSupplementalCacheData = NULL;
        }
    }

    return(NtStatus);
}


NTSTATUS
NlpAddCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN  PVOID SupplementalCacheData,
    IN  ULONG SupplementalCacheDataLength,
    IN  ULONG CacheFlags
    )

/*++

Routine Description:

    Adds this domain:user interactive logon information to the cache.

Arguments:

    LogonInfo   - pointer to NETLOGON_INTERACTIVE_INFO structure which contains
                  the domain name, user name and password for this user. These
                  are what the user typed to WinLogon

    AccountInfo - pointer to NETLOGON_VALIDATION_SAM_INFO4 structure which
                  contains this user's specific interactive logon information

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    AccountInfo successfully added to cache

        Failure = STATUS_NO_MEMORY

--*/

{
    NTSTATUS
        NtStatus;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    PLOGON_CACHE_ENTRY
        CacheEntryExisting = NULL;

    ULONG
        EntrySize = 0,
        EntrySizeExisting = 0,
        Index;

    BOOLEAN fCacheLocked = FALSE;

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpAddCacheEntry\n");
        DumpLogonInfo(&LogonInfo->Identity);
        DumpAccountInfo(AccountInfo);
    }
#endif

    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    if (NlpCacheControl.Entries == 0) {
        return(STATUS_SUCCESS);
    }

    //
    // LogonUser() allows for a NULL domain name to be supplied, which
    // causes netlogon search logic to kick in.  this can result to logon
    // packages requesting to cache local account information.
    // In this case, use the LogonDomainName that SAM provides to make
    // a decision about whether to allow caching.  In the same scenario,
    // if we decide caching is allowed, the cache entry target domain
    // is also set based on what SAM returned.
    //

    if ( (CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON) == 0 )
    {
        //
        // If Sam is not yet initialized,
        //  do it now.
        //

        if ( !NlpSamInitialized ) {
            NtStatus = NlSamInitialize( SAM_STARTUP_TIME );

            if ( !NT_SUCCESS(NtStatus) ) {
                goto Cleanup;
            }
        }

        ASSERT( NlpSamDomainId != NULL );
        ASSERT( AccountInfo->LogonDomainId != NULL );

        if( RtlEqualSid( NlpSamDomainId, AccountInfo->LogonDomainId ) )
        {

#if DBG
            if (DumpCacheInfo) {
                DbgPrint("NlpAddCacheEntry: attempt to cache against local account skipped.\n");
            }
#endif
            return STATUS_SUCCESS;
        }
    }

    //
    // build base cache entry.
    //

    NtStatus = NlpBuildCacheEntry(
                    LogonInfo,
                    AccountInfo,
                    CacheFlags,
                    SupplementalCacheDataLength,
                    SupplementalCacheData,
                    &CacheEntry,
                    &EntrySize
                    );

    if(!NT_SUCCESS(NtStatus) )
    {
        return (NtStatus);
    }
      
    //
    // add in salted OWFs.
    //

    NtStatus = NlpMakeSecretPasswordNT5(
                    &CacheEntry->CachePasswords,
                    &AccountInfo->EffectiveName,
                    &LogonInfo->NtOwfPassword,
                    &LogonInfo->LmOwfPassword
                    );

    if(!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    READ_CACHE();
    fCacheLocked = TRUE;

    //
    // See if this entry already exists in the cache.
    // If so, use the same index.
    //

    NtStatus = NlpReadCacheEntry( &LogonInfo->Identity.LogonDomainName,
                                  &LogonInfo->Identity.UserName,
                                  &Index,
                                  &CacheEntryExisting,
                                  &EntrySizeExisting
                                  );

    //
    // If we didn't find an entry, then we need to allocate an
    // entry.
    //

    if (!NT_SUCCESS(NtStatus)) {

        NlpGetFreeEntryIndex( &Index );

        CacheEntryExisting = NULL;

    } else {

        //
        // We already have an entry for this user.
        // Discard the structure we got back but
        // use the same index.
        //

        // TODO: check if existing entry matches new built entry.
        // if so, avoid write.

        BOOLEAN fMatchesExisting;

        fMatchesExisting = NlpCompareCacheEntry(
                                    CacheEntry,
                                    EntrySize,
                                    CacheEntryExisting,
                                    EntrySizeExisting
                                    );

        if ( fMatchesExisting )
        {
            SspPrint((SSP_CRED, "NlpAddCacheEntry avoid matching entry for logon %wZ\\%wZ\n", 
                &LogonInfo->Identity.LogonDomainName,
                &LogonInfo->Identity.UserName));
            goto Cleanup;
        }
    }

    //
    // encrypt sensitive portions of the cache entry.
    // note: this was done prior to locking the cache, but, in the interest
    // of allowing for cache compare above, the encryption is deferred until
    // now.
    //

    NtStatus = NlpEncryptCacheEntry(CacheEntry, EntrySize);

    if(!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // we already have the read lock, convert it to write-lock.
    //

    READ_TO_WRITE_CACHE();

    //
    // now, write the entry out...
    //

    NtStatus = NlpWriteCacheEntry(Index, CacheEntry, EntrySize);


    if (NT_SUCCESS(NtStatus)) {

        SspPrint((SSP_CRED, "NlpAddCacheEntry entry %d written: %wZ\\%wZ (update? %s)\n", 
            Index, &LogonInfo->Identity.LogonDomainName, &LogonInfo->Identity.UserName, 
            CacheEntryExisting ? "true" : "false"));

        NlpCteTable[Index].Time = CacheEntry->Time;
        NlpAddEntryToActiveList( Index );
    }

Cleanup:

    if ( fCacheLocked )
    {
        LEAVE_CACHE();
    }


    if ( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeCacheEntry( CacheEntry );
    }

    if( CacheEntryExisting ) {
        ZeroMemory( CacheEntryExisting, EntrySizeExisting );
        FreeCacheEntry( CacheEntryExisting );
    }

    return(NtStatus);
}


NTSTATUS
NlpAddSupplementalCacheData(
    IN PVOID SupplementalCacheData,
    IN ULONG SupplementalCacheDataLength,
    IN OUT PLOGON_CACHE_ENTRY *ppCacheEntry,
    IN OUT PULONG pEntryLength
    )

/*++

Routine Description:

    Extends the supplied LOGON_CACHE_ENTRY with opaque authentication package
    SupplementalCacheData (eg: smart-card logon cache info).

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS

        Failure =

--*/

{
    PLOGON_CACHE_ENTRY NewCacheEntry = NULL;

    if( (*ppCacheEntry)->Revision < NLP_CACHE_REVISION_NT_5_0 ) {
        return STATUS_SUCCESS;
    }

    (*ppCacheEntry)->SupplementalCacheDataLength = SupplementalCacheDataLength;
    (*ppCacheEntry)->SupplementalCacheDataOffset = *pEntryLength;


    if ( SupplementalCacheData == NULL || SupplementalCacheDataLength == 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // allocate new entry, and copy existing entry + supplemental data to end.
    //

    NewCacheEntry = AllocateCacheEntry( *pEntryLength + SupplementalCacheDataLength );

    if( NewCacheEntry == NULL ) {
        return STATUS_NO_MEMORY;
    }

    CopyMemory( NewCacheEntry, *ppCacheEntry, *pEntryLength );
    CopyMemory( ((PBYTE)(NewCacheEntry) + *pEntryLength),
                SupplementalCacheData,
                SupplementalCacheDataLength
                );

    ZeroMemory( *ppCacheEntry, *pEntryLength );
    FreeCacheEntry( *ppCacheEntry );

    *ppCacheEntry = NewCacheEntry;
    *pEntryLength += SupplementalCacheDataLength;

    return STATUS_SUCCESS;
}


NTSTATUS
NlpDeleteCacheEntry(
    IN NTSTATUS FailedStatus,
    IN USHORT Authoritative,
    IN USHORT LogonType,
    IN BOOLEAN InvalidatedByNtlm,
    IN PNETLOGON_INTERACTIVE_INFO LogonInfo
    )

/*++

Routine Description:

    Deletes a user account from the local user account cache, if the corresponding
    entry can be found. We actually just null out the current contents instead of
    destroying the storage - this should save us some time when we next come to
    add an entry to the cache

Arguments:

    FailedStatus      - Status that caused the logon cache entry to be deleted
    
    Authoritative     - Was the error code authorative?
    
    LogonType         - LogonType that caused the logon cache entry to be deleted
                                                              
    InvalidatedByNtlm - whether entry is validated by NTLM
    
    LogonInfo         - pointer to NETLOGON_INTERACTIVE_INFO structure which contains
       the domain name, user name and password for this user

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS

        Failure =

--*/

{
    NTSTATUS
        NtStatus;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    ULONG
        EntrySize,
        Index;


    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    if (NlpCacheControl.Entries == 0) {
        return(STATUS_SUCCESS);
    }

    WRITE_CACHE();

    //
    // See if this entry exists in the cache.
    //

    NtStatus = NlpReadCacheEntry( &LogonInfo->Identity.LogonDomainName,
                                  &LogonInfo->Identity.UserName,
                                  &Index,
                                  &CacheEntry,
                                  &EntrySize
                                  );

    //
    // If we didn't find an entry, then there is nothing to do.
    //

    if (!NT_SUCCESS(NtStatus)) {
        LEAVE_CACHE();
        return(STATUS_SUCCESS);
    }

    //
    // ealier revisons of cache entries do not have the CacheFlags field
    //

    if (InvalidatedByNtlm && (CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0) && (CacheEntry->CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON)) {

       SspPrint((SSP_WARNING, 
           "NlpDeleteCacheEntry can not invalidate MIT cache entry %wZ\\%wZ\n", 
           &LogonInfo->Identity.LogonDomainName,
           &LogonInfo->Identity.UserName
           ));
       LEAVE_CACHE();
       return STATUS_NO_LOGON_SERVERS; // MIT kdc is not available     
   }

    //
    // Mark it as invalid.
    //

    CacheEntry->Valid = FALSE;

    ASSERT(sizeof(FailedStatus) == 4 && sizeof(Authoritative) == 2 && sizeof(LogonType) == 2 && sizeof(CacheEntry->RandomKey) == 16);

    RtlCopyMemory(CacheEntry->RandomKey, &FailedStatus, 4);
    RtlCopyMemory(CacheEntry->RandomKey + 4, &Authoritative, 2);
    RtlCopyMemory(CacheEntry->RandomKey + 6, &LogonType, 2);
    NtQuerySystemTime((PLARGE_INTEGER) (CacheEntry->RandomKey + 8)), // 8 bytes

    NtStatus = NlpWriteCacheEntry( Index, CacheEntry, EntrySize );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Put the CTE entry on the inactive list.
        //

        NlpAddEntryToInactiveList( Index );
    }

    LEAVE_CACHE();

    //
    // Free the structure returned from NlpReadCacheEntry()
    //

    if ( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeToHeap( CacheEntry );
    }

    return(NtStatus);
}

NTSTATUS
NlpChangeCachePassword(
    IN BOOLEAN Validated,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Update a cached password to the specified value, if we have
    the specified account cached.

Arguments:


    DomainName - The name of the domain in which the account exists.

    UserName - The name of the account whose password is to be changed.

    LmOwfPassword - The new LM compatible password.

    NtOwfPassword - The new NT compatible password.

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    ULONG
        EntrySize,
        Index;

    PLSAPR_CR_CIPHER_VALUE
        CurrentSecret = NULL,
        OldSecret = NULL;

    LSAPR_CR_CIPHER_VALUE
        Passwords;

    PNETLOGON_VALIDATION_SAM_INFO4 NlpUser = NULL;

    SECPKG_CALL_INFO CallInfo = {0};
    PSID CacheEntryUserSid = NULL;

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpChangeCachePassword\n");
    }
#endif

    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    }

    if (NlpCacheControl.Entries == 0) {
        return STATUS_NOT_FOUND;
    }

    WRITE_CACHE();

    NtStatus = NlpReadCacheEntry( DomainName,
                                  UserName,
                                  &Index,
                                  &CacheEntry,
                                  &EntrySize );

    if (!NT_SUCCESS( NtStatus) )
    {
        SspPrint((SSP_WARNING, "NlpChangeCachePassword no cache entry found %#x\n", NtStatus));

        //
        // NlpReadCacheEntry returns STATUS_LOGON_FAILURE if no cache entry is
        // found, remap the error code
        //

        if (STATUS_LOGON_FAILURE == NtStatus)
        {
            NtStatus = STATUS_NOT_FOUND;
        }
        goto Cleanup;
    }

    if (!Validated)
    {
        if (!LsaFunctions->GetCallInfo(&CallInfo))
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        //
        // disallow un-trusted callers to change cached passwords other than
        // their own cache entries
        //

        if (0 == (CallInfo.Attributes & SECPKG_CALL_IS_TCB))
        {
            BOOL IsMember = FALSE;

            NtStatus = NlpBuildAccountInfo(
                            CacheEntry,
                            EntrySize,
                            &NlpUser
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Cleanup;
            }

            CacheEntryUserSid = NlpMakeDomainRelativeSid(
                                    NlpUser->LogonDomainId,
                                    NlpUser->UserId
                                    );

            if (!CacheEntryUserSid)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // now impersonating, need to revert to self later
            //

            NtStatus = LsaFunctions->ImpersonateClient();
            if (!NT_SUCCESS(NtStatus))
            {
                goto Cleanup;
            }

            if (!CheckTokenMembership(NULL, CacheEntryUserSid, &IsMember))
            {
                SspPrint((SSP_CRITICAL, "NlpChangeCachePassword failed to check token membership, last error %#x\n", GetLastError()));
                IsMember = FALSE;
            }

            RevertToSelf();

            if (!IsMember)
            {
                NtStatus = STATUS_PRIVILEGE_NOT_HELD;
                SspPrint((SSP_CRITICAL, "NlpChangeCachePassword user sids do not mismatched\n"));
                goto Cleanup;
            }
        }
    }

    if ( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {
        UNICODE_STRING CachedUser;

        CachedUser.Length =
            CachedUser.MaximumLength = CacheEntry->UserNameLength;
        CachedUser.Buffer = (PWSTR) ((PBYTE) CacheEntry + sizeof(LOGON_CACHE_ENTRY));

        //
        // update timestamp in cache entry
        //

        NtQuerySystemTime(&CacheEntry->Time);

        NtStatus = NlpMakeSecretPasswordNT5( &CacheEntry->CachePasswords,
                                          &CachedUser,
                                          NtOwfPassword,
                                          LmOwfPassword );


        if (NT_SUCCESS(NtStatus)) {

            //
            // encrypt the entry...
            //

            NtStatus = NlpEncryptCacheEntry( CacheEntry, EntrySize );
        }

        if (NT_SUCCESS( NtStatus )) {

            //
            // now, write the entry out...
            //

            NtStatus = NlpWriteCacheEntry(Index, CacheEntry, EntrySize);

#ifdef DBG
            if(DumpCacheInfo) {
                if( NT_SUCCESS( NtStatus ) ) {
                    DbgPrint("NlpChangeCachePassword: SUCCEED write NT5 version cache entry.\n");
                } else {
                    DbgPrint("NlpChangeCachePassword: FAIL write NT5 version cache entry.\n");
                }
            }
#endif
        }

    } else {

        NtStatus = NlpOpenSecret( Index );
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = NlpReadSecret(&CurrentSecret, &OldSecret);
            if (NT_SUCCESS(NtStatus)) {
                UNICODE_STRING CachedUser;

                //
                // Grab the various strings from the cache entry.
                //
                ASSERT( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B );

                CachedUser.Length =
                    CachedUser.MaximumLength = CacheEntry->UserNameLength;
                CachedUser.Buffer = (PWSTR) ((PBYTE) CacheEntry + sizeof(LOGON_CACHE_ENTRY_NT_4_SP4));

                NtStatus = NlpMakeSecretPassword( &Passwords,
                                                  &CachedUser,
                                                  NtOwfPassword,
                                                  LmOwfPassword );

                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = NlpWriteSecret(&Passwords, CurrentSecret);

                    //
                    // free the buffer allocated to store the passwords
                    //

                    RtlZeroMemory(Passwords.Buffer, Passwords.Length);
                    FreeToHeap(Passwords.Buffer);
                }

                //
                // free strings returned by NlpReadSecret
                //

                if (CurrentSecret) {
                    RtlZeroMemory(CurrentSecret->Buffer, CurrentSecret->Length);
                    MIDL_user_free(CurrentSecret);
                }
                if (OldSecret) {
                    RtlZeroMemory(OldSecret->Buffer, OldSecret->Length);
                    MIDL_user_free(OldSecret);
                }
            }
        }
    }

Cleanup:

    LEAVE_CACHE();

    //
    // free structure allocated by NlpReadCacheEntry
    //

    if ( CacheEntry )
    {
        ZeroMemory( CacheEntry, EntrySize );
        FreeToHeap(CacheEntry);
    }

    if (CacheEntryUserSid)
    {
        LsaFunctions->FreeLsaHeap(CacheEntryUserSid);
    }

    if (NlpUser)
    {
        MIDL_user_free(NlpUser);
    }

    return NtStatus;
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
// Services Internal to this module                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
NlpInternalCacheInitialize(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize cached logon processing.

    This routine will automatically adjust the size of the logon
    cache if necessary to accomodate a new user-specified length
    (specified in the Winlogon part of the registry).

    NOTE: If called too early, this routine won't be able to call
          LSA's RPC routines.  In this case, initialization is
          defered until later.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{

    NTSTATUS
        NtStatus;

// DbgPrint("\n\n\n     REMEMBER TO TAKE THIS BREAKPOINT OUT BEFORE CHECKIN.\n\n\n");
// DumpCacheInfo = 1;   // Remember to take this out too !!!!!!
// DbgBreakPoint();     // Remember to take this out before checking

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpCacheInitialize\n");
    }
#endif


    //
    // Upon return from this routine, if logon caching is enabled,
    // the following will be true:
    //
    //      A handle to the registry key in which all cache entries
    //      are held will be open (NlpCacheHandle).
    //
    //      A global structure defining how many cache entries there are
    //      will be initialized (NlpCacheControl).
    //
    //      The Cache Table Entry table (CTE table) will be initialized
    //      (NlpCteTable).
    //
    //      The active and inactive CTE lists will be built
    //      (NlpActiveCtes and NlpInactiveCtes).
    //
    //      A global cache encryption key will be initialized.
    //

    WRITE_CACHE();

    //
    // Check again if the cache is initialized now that the crit sect is locked.
    //

    if (NlpInitializationNotYetPerformed) {

        //
        // Open the local system's policy object
        //

        //
        // Successfully, or unsucessfully,
        // The definition of "initialized" is we could call LSA's RPC
        // routines.
        //

        NlpInitializationNotYetPerformed = FALSE;

        //
        // Open the registry key containing cache entries.
        // This will remain open.
        //

        NtStatus = NlpOpenCache();

        if (NT_SUCCESS(NtStatus)) {

            //
            // Get information on the current cache structure
            // (number of entries, et cetera).  This information is
            // placed in a global variable for use throughout this
            // module.
            //

            NtStatus = NlpGetCacheControlInfo();

            //
            // Initialize the per-machine cache encryption key.
            //

            if(NT_SUCCESS( NtStatus) ) {
                NtStatus = NlpCacheKeyInitialize();
            }

            //
            // Now build the CTE table
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = NlpBuildCteTable();
            }

            //
            // If we were successful, then see if we need to change
            // the cache due to new user-specified cache size.
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = NlpChangeCacheSizeIfNecessary();
            }

            if (!NT_SUCCESS(NtStatus)) {
                NlpCloseCache();
            }
        }

        //
        // If we had an error, then set our entry count to zero
        // to prevent using any cache information.
        //

        if (!NT_SUCCESS(NtStatus)) {
            NlpCacheControl.Entries = 0;
        }
    } else {
        NtStatus = STATUS_SUCCESS;
    }

    LEAVE_CACHE();

    return(NtStatus);
}


NTSTATUS
NlpCacheKeyInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the Global variable NlpCacheEncryptionKey with a per-machine
    cache encryption key.  If the per-machine key does not exist as an LSA
    secret, it is created.

--*/
{
    LSAPR_HANDLE SecretHandle;
    UNICODE_STRING ValueName;
    BOOLEAN SecretCreationNeeded = FALSE;
    NTSTATUS NtStatus;

    RtlInitUnicodeString( &ValueName, NLP_CACHE_ENCRYPTION_KEY_NAME );

    NtStatus = I_LsarOpenSecret(NtLmGlobalPolicyHandle,
                              (PLSAPR_UNICODE_STRING) &ValueName,
                              SECRET_QUERY_VALUE | SECRET_SET_VALUE,
                              &SecretHandle
                              );

    if (!NT_SUCCESS(NtStatus)) {

        //
        // create new key, if not present.
        //

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
            return (NtStatus);
        }

        NtStatus = I_LsarCreateSecret(NtLmGlobalPolicyHandle,
                                    (PLSAPR_UNICODE_STRING) &ValueName,
                                    SECRET_SET_VALUE,
                                    &SecretHandle
                                    );

        if (!NT_SUCCESS(NtStatus)) {
            return (NtStatus);
        }

        SecretCreationNeeded = TRUE;

    } else {

        //
        // query current value...
        //

        LARGE_INTEGER
            CurrentTime;

        PLSAPR_CR_CIPHER_VALUE CurrentSecret = NULL;

        NtStatus = I_LsarQuerySecret(SecretHandle,
                                   &CurrentSecret,
                                   &CurrentTime,
                                   NULL,
                                   NULL
                                   );

        if (NT_SUCCESS( NtStatus ) ) {
            if( CurrentSecret == NULL ) {

                //
                // non existing data, create it.
                //

                SecretCreationNeeded = TRUE;
            } else {

                //
                // size of data is wrong, bail now and leave things as-is.
                //

                if( CurrentSecret->Length != sizeof( NlpCacheEncryptionKey ) ) {
                    NtStatus = STATUS_SECRET_TOO_LONG;
                } else {

                    //
                    // capture existing data into global.
                    //

                    CopyMemory( NlpCacheEncryptionKey, CurrentSecret->Buffer, CurrentSecret->Length );
                }

                RtlSecureZeroMemory(CurrentSecret->Buffer, CurrentSecret->Length);
                MIDL_user_free(CurrentSecret);
            }
        }
    }


    if ( SecretCreationNeeded ) {
        LSAPR_CR_CIPHER_VALUE SecretValue;

        NtStatus = SspGenerateRandomBits( NlpCacheEncryptionKey, sizeof(NlpCacheEncryptionKey) );

        if (NT_SUCCESS(NtStatus)) {

            //
            // write out secret...
            //

            SecretValue.Length = sizeof(NlpCacheEncryptionKey);
            SecretValue.MaximumLength = SecretValue.Length;
            SecretValue.Buffer = (PBYTE)NlpCacheEncryptionKey;

            NtStatus = I_LsarSetSecret(SecretHandle,
                                     &SecretValue,
                                     NULL
                                     );
        }
    }

    I_LsarClose( &SecretHandle );

    return (NtStatus);
}

BOOLEAN
NlpCompareCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry1,
    IN  ULONG EntrySize1,
    IN  PLOGON_CACHE_ENTRY CacheEntry2,
    IN  ULONG EntrySize2
    )
/*++

Routine Description:

    Compare two in-memory cache entries, for the purpose of avoiding
    un-necessary cache updates.

    Certain fields are not taken into account during the compare,
    ie: the Random encryption key.

--*/
{
    LARGE_INTEGER Time1;
    LARGE_INTEGER Time2;
    CHAR RandomKey1[16];
    CHAR RandomKey2[16];
    CHAR MAC1[16];
    CHAR MAC2[16];

    BOOLEAN fEqual = FALSE;

    if ( EntrySize1 != EntrySize2 )
    {
        return FALSE;
    }

    if ( CacheEntry1->Revision != CacheEntry2->Revision )
    {
        return FALSE;
    }

    //
    // scoop up the current values of the 'volatile' fields,
    // whack them to zero,
    // do the memory compare,
    // put the saved values back.
    //

    ASSERT(( sizeof(RandomKey1) == sizeof(CacheEntry1->RandomKey) ));
    ASSERT(( sizeof(MAC1) == sizeof(CacheEntry1->MAC) ));
    ASSERT(( sizeof(Time1) == sizeof(CacheEntry1->Time) ));

    Time1 = CacheEntry1->Time;
    Time2 = CacheEntry2->Time;
    RtlZeroMemory(&CacheEntry1->Time, sizeof(CacheEntry1->Time));
    RtlZeroMemory(&CacheEntry2->Time, sizeof(CacheEntry2->Time));

    RtlCopyMemory(RandomKey1, CacheEntry1->RandomKey, sizeof(RandomKey1));
    RtlCopyMemory(RandomKey2, CacheEntry2->RandomKey, sizeof(RandomKey2));
    ZeroMemory(CacheEntry1->RandomKey, sizeof(CacheEntry1->RandomKey));
    ZeroMemory(CacheEntry2->RandomKey, sizeof(CacheEntry2->RandomKey));

    RtlCopyMemory(MAC1, CacheEntry1->MAC, sizeof(MAC1));
    RtlCopyMemory(MAC2, CacheEntry2->MAC, sizeof(MAC2));
    ZeroMemory(CacheEntry1->MAC, sizeof(CacheEntry1->MAC));
    ZeroMemory(CacheEntry2->MAC, sizeof(CacheEntry2->MAC));

    if ( memcmp(CacheEntry1, CacheEntry2, EntrySize1) == 0 )
    {
        fEqual = TRUE;
    }

    CacheEntry1->Time = Time1;
    CacheEntry2->Time = Time2;

    RtlCopyMemory(CacheEntry1->RandomKey, RandomKey1, sizeof(RandomKey1));
    RtlCopyMemory(CacheEntry2->RandomKey, RandomKey2, sizeof(RandomKey2));

    RtlCopyMemory(CacheEntry1->MAC, MAC1, sizeof(MAC1));
    RtlCopyMemory(CacheEntry2->MAC, MAC2, sizeof(MAC2));

    return fEqual;
}


NTSTATUS
NlpEncryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    )
/*++

Routine Description:

    Encrypts the sensitive portions of the input CacheEntry.

--*/
{
    HMACMD5_CTX hmacCtx;
    RC4_KEYSTRUCT rc4key;
    CHAR DerivedKey[ MD5DIGESTLEN ];

    PBYTE pbData;
    ULONG cbData;

    if( CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {
        return STATUS_SUCCESS;
    }


    //
    // derive encryption key from global machine LSA secret, and random
    // cache entry key.
    //

    HMACMD5Init(&hmacCtx, (PUCHAR) NlpCacheEncryptionKey, sizeof(NlpCacheEncryptionKey));
    HMACMD5Update(&hmacCtx, (PUCHAR) CacheEntry->RandomKey, sizeof(CacheEntry->RandomKey));
    HMACMD5Final(&hmacCtx, (PUCHAR) DerivedKey);


    //
    // begin encrypting at the cachepasswords field.
    //

    pbData = (PBYTE) &(CacheEntry->CachePasswords);

    //
    // data length is EntrySize - header up to CachePasswords.
    //

    cbData = EntrySize - (ULONG)( pbData - (PBYTE)CacheEntry );


    //
    // MAC the data for integrity checking.
    //

    HMACMD5Init(&hmacCtx, (PUCHAR) DerivedKey, sizeof(DerivedKey));
    HMACMD5Update(&hmacCtx, pbData, cbData);
    HMACMD5Final(&hmacCtx, (PUCHAR) CacheEntry->MAC);

    //
    // now encrypt it...
    //

    rc4_key( &rc4key, sizeof(DerivedKey), (PUCHAR) DerivedKey );
    rc4( &rc4key, cbData, pbData );

    RtlSecureZeroMemory( DerivedKey, sizeof(DerivedKey) );

    return STATUS_SUCCESS;
}


NTSTATUS
NlpDecryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    )
/*++

Routine Description:

    Decrypts the sensitive portions of the input CacheEntry, and verified
    integrity of decrypted data.

--*/
{
    HMACMD5_CTX hmacCtx;
    RC4_KEYSTRUCT rc4key;
    CHAR DerivedKey[ MD5DIGESTLEN ];

    CHAR MAC[ MD5DIGESTLEN ];

    PBYTE pbData;
    ULONG cbData;

    if( CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {
        return STATUS_SUCCESS;
    }


    //
    // derive encryption key from global machine LSA secret, and random
    // cache entry key.
    //

    HMACMD5Init(&hmacCtx, (PUCHAR) NlpCacheEncryptionKey, sizeof(NlpCacheEncryptionKey));
    HMACMD5Update(&hmacCtx, (PUCHAR) CacheEntry->RandomKey, sizeof(CacheEntry->RandomKey));
    HMACMD5Final(&hmacCtx, (PUCHAR) DerivedKey);


    //
    // begin decrypting at the cachepasswords field.
    //

    pbData = (PBYTE)&(CacheEntry->CachePasswords);

    //
    // data length is EntrySize - header up to CachePasswords.
    //

    cbData = EntrySize - (ULONG)( pbData - (PBYTE)CacheEntry );

    //
    // now decrypt it...
    //

    rc4_key( &rc4key, sizeof(DerivedKey), (PUCHAR) DerivedKey );
    rc4( &rc4key, cbData, pbData );


    //
    // compute MAC on decrypted data for integrity checking.
    //

    HMACMD5Init(&hmacCtx, (PUCHAR) DerivedKey, sizeof(DerivedKey));
    HMACMD5Update(&hmacCtx, pbData, cbData);
    HMACMD5Final(&hmacCtx, (PUCHAR) MAC);

    RtlSecureZeroMemory( DerivedKey, sizeof(DerivedKey) );

    //
    // verify MAC.
    //

    if ( memcmp( MAC, CacheEntry->MAC, sizeof(MAC) ) != 0 ) {
        return STATUS_LOGON_FAILURE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NlpBuildCacheEntry(
    IN PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN ULONG CacheFlags,
    IN ULONG SupplementalCacheDataLength,
    IN PBYTE SupplementalCacheData,
    OUT PLOGON_CACHE_ENTRY* ppCacheEntry,
    OUT PULONG pEntryLength
    )

/*++

Routine Description:

    Builds a LOGON_CACHE_ENTRY from a NETLOGON_VALIDATION_SAM_INFO4 structure.
    We only cache those fields that we cannot easily re-invent

Arguments:

    LogonInfo       - pointer to NETLOGON_INTERACTIVE_INFO structure containing
                      user's name and logon domain name
                                                         
    AccountInfo     - pointer to NETLOGON_VALIDATION_SAM_INFO4 from successful
                      logon
                      
    CacheFlags      - cache flags
    
    SupplementalCacheDataLength - supplemental cache data length
    
    SupplementalCacheData - supplemental cache data

    ppCacheEntry    - pointer to place to return pointer to allocated
                      LOGON_CACHE_ENTRY

    pEntryLength    - size of the buffer returned in *ppCacheEntry

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *ppCacheEntry contains pointer to allocated LOGON_CACHE_ENTRY
                    structure

        Failure = STATUS_NO_MEMORY
                    *ppCacheEntry undefined

--*/

{
    PLOGON_CACHE_ENTRY pEntry = NULL;
    ULONG EntryLength = 0;
    ULONG length;
    PCHAR dataptr;

    UNICODE_STRING SamAccountName;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;
    UNICODE_STRING Upn;

    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING UserNameToUse = {0};
    UNICODE_STRING DomainNameToUse = {0};
    UNICODE_STRING UpnForMitUser = {0};

    *ppCacheEntry = NULL;
    *pEntryLength = 0;

    //
    // Grab the various forms of the account name
    //

    NlpGetAccountNames( &LogonInfo->Identity,
        AccountInfo,
        &SamAccountName,
        &NetbiosDomainName,
        &DnsDomainName, 
        &Upn );

    // 
    // two kinds of cached logonon: 1) UPN logon looked up by UPNs, 2) non UPN 
    // logon looked up by LogonInfo UserName and NetbiosDomainName or DNS doman
    // name. 
    //
    // Cache entries created by kerberos for MIT princ cached logon should 
    // have DnsDomainName populated as MIT realm name (FQDN) from kerberos
    // primary credential. In the authorization data LogonDomainName refers 
    // to MS domain where the PAC is created while DnsLogonDomainName refers 
    // to the MIT realm
    //

    if (CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON) {

        Status = NlpGetCredentialNamesFromMitCacheSupplementalCacheData(
                    SupplementalCacheDataLength,
                    SupplementalCacheData,
                    &DomainNameToUse,
                    &UserNameToUse
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        if (!RtlEqualUnicodeString(
                &DomainNameToUse, 
                &DnsDomainName, 
                FALSE // case sensitive
                )) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (Upn.Length == 0) { // construct an UPN
            UpnForMitUser.Length =  UserNameToUse.Length + sizeof(WCHAR) + DomainNameToUse.Length;
            UpnForMitUser.MaximumLength = UpnForMitUser.Length + sizeof(WCHAR);

            UpnForMitUser.Buffer = NtLmAllocatePrivateHeap(UpnForMitUser.MaximumLength);

            if (UpnForMitUser.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(
                UpnForMitUser.Buffer, 
                UserNameToUse.Buffer, 
                UserNameToUse.Length
                );

            RtlCopyMemory(
                ((PBYTE) UpnForMitUser.Buffer) + UserNameToUse.Length,
                L"@",
                sizeof(WCHAR)
                );

            RtlCopyMemory(
                ((PBYTE) UpnForMitUser.Buffer) + UserNameToUse.Length + sizeof(WCHAR),
                DomainNameToUse.Buffer,
                DomainNameToUse.Length
                );
            Upn = UpnForMitUser;
        }

        RtlZeroMemory(&DomainNameToUse, sizeof(DomainNameToUse)); // no need to store dumplicate domain names

    } else {

        UserNameToUse = SamAccountName;
        DomainNameToUse = NetbiosDomainName;
    }

    SspPrint((SSP_CRED, 
        "NlpBuildCacheEntry domain (%wZ), dnsDomain (%wZ), upn (%wZ), user (%wZ), flags %#x\n",
        &DomainNameToUse,
        &DnsDomainName,
        &Upn, 
        &UserNameToUse, 
        CacheFlags));

    //
    // assumes GROUP_MEMBERSHIP is integral multiple of DWORDs
    //

    length = ROUND_UP_COUNT(sizeof(LOGON_CACHE_ENTRY), sizeof(ULONG))
                + ROUND_UP_COUNT(DomainNameToUse.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(UserNameToUse.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(DnsDomainName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(Upn.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->EffectiveName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->FullName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->LogonScript.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->ProfilePath.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->HomeDirectory.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->HomeDirectoryDrive.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->LogonDomainName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->GroupCount * sizeof(GROUP_MEMBERSHIP), sizeof(ULONG))
                + ROUND_UP_COUNT(RtlLengthSid(AccountInfo->LogonDomainId), sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->LogonServer.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(SupplementalCacheDataLength, sizeof(ULONG));

    if (AccountInfo->UserFlags & LOGON_EXTRA_SIDS) {
        if (AccountInfo->SidCount) {
            ULONG i;
            length += ROUND_UP_COUNT(AccountInfo->SidCount * sizeof(ULONG), sizeof(ULONG));
            for (i = 0; i < AccountInfo->SidCount; i++) {
                length += ROUND_UP_COUNT(RtlLengthSid(AccountInfo->ExtraSids[i].Sid), sizeof(ULONG));
            }
        }
    }

    pEntry = AllocateCacheEntry(length);
    if (pEntry == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( pEntry, length );
    pEntry->Revision = NLP_CACHE_REVISION;
    NtQuerySystemTime( &pEntry->Time );
    pEntry->Valid    = TRUE;
    pEntry->LogonPackage = LogonInfo->Identity.ParameterControl;


    dataptr = (PCHAR)(pEntry + 1);
    EntryLength = length;

    ASSERT(!((ULONG_PTR)dataptr & (sizeof(ULONG) - 1)));

    //
    // each of these (unicode) strings and other structures are copied to the
    // end of the fixed LOGON_CACHE_ENTRY structure, each aligned on DWORD
    // boundaries
    //

    length = pEntry->UserNameLength = UserNameToUse.Length;
    RtlCopyMemory(dataptr, UserNameToUse.Buffer, length);
    dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));

    length = pEntry->DomainNameLength = DomainNameToUse.Length;
    if (length) {
        RtlCopyMemory(dataptr, DomainNameToUse.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->DnsDomainNameLength = DnsDomainName.Length;
    if (length) {
        RtlCopyMemory(dataptr, DnsDomainName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->UpnLength = Upn.Length;
    if (length) {
        RtlCopyMemory(dataptr, Upn.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->EffectiveNameLength = AccountInfo->EffectiveName.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->EffectiveName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->FullNameLength = AccountInfo->FullName.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->FullName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->LogonScriptLength = AccountInfo->LogonScript.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->LogonScript.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->ProfilePathLength = AccountInfo->ProfilePath.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->ProfilePath.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->HomeDirectoryLength = AccountInfo->HomeDirectory.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->HomeDirectory.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->HomeDirectoryDriveLength = AccountInfo->HomeDirectoryDrive.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->HomeDirectoryDrive.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    pEntry->UserId = AccountInfo->UserId;
    pEntry->PrimaryGroupId = AccountInfo->PrimaryGroupId;

    length = pEntry->GroupCount = AccountInfo->GroupCount;
    length *= sizeof(GROUP_MEMBERSHIP);
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->GroupIds, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->LogonDomainNameLength = AccountInfo->LogonDomainName.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->LogonDomainName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    if (AccountInfo->UserFlags & LOGON_EXTRA_SIDS) {
        length = pEntry->SidCount = AccountInfo->SidCount;
        length *= sizeof(ULONG);
        if (length) {
            ULONG i, sidLength;
            PULONG sidAttributes = (PULONG) dataptr;

            dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));

            //
            // Now copy over all the SIDs
            //

            for (i = 0; i < AccountInfo->SidCount ; i++ ) {
                sidAttributes[i] = AccountInfo->ExtraSids[i].Attributes;
                sidLength = RtlLengthSid(AccountInfo->ExtraSids[i].Sid);
                RtlCopySid(sidLength,(PSID) dataptr, AccountInfo->ExtraSids[i].Sid);
                dataptr = ROUND_UP_POINTER(dataptr + sidLength, sizeof(ULONG));
            }
            pEntry->SidLength = (ULONG) (dataptr - (PCHAR) sidAttributes);
        } else {
            pEntry->SidLength = 0;
        }
    } else {
        pEntry->SidCount = 0;
        pEntry->SidLength = 0;
    }

    length = pEntry->LogonDomainIdLength = (USHORT) RtlLengthSid(AccountInfo->LogonDomainId);

    Status = RtlCopySid(pEntry->LogonDomainIdLength,
                (PSID)dataptr,
                AccountInfo->LogonDomainId
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));

    //
    // copy in the LogonServer
    //

    length = pEntry->LogonServerLength = AccountInfo->LogonServer.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->LogonServer.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    length = pEntry->SupplementalCacheDataLength = SupplementalCacheDataLength;
    pEntry->SupplementalCacheDataOffset = RtlPointerToOffset(pEntry, dataptr);

    if (length) {
        RtlCopyMemory(dataptr, SupplementalCacheData, length);
        dataptr = ROUND_UP_POINTER(dataptr + length, sizeof(ULONG));
    }

    //
    // fill in randomkey for this cache entry.
    //

    SspGenerateRandomBits( pEntry->RandomKey, sizeof(pEntry->RandomKey) );

    pEntry->CacheFlags = CacheFlags;

    #if DBG
    if (DumpCacheInfo) {
        DbgPrint("BuildCacheEntry:\n");
        DumpCacheEntry(999, pEntry);
    }
    #endif

    *ppCacheEntry = pEntry;
    *pEntryLength = EntryLength;
    
    pEntry = NULL;

Cleanup:

    if (pEntry) {
        FreeCacheEntry(pEntry);
    }

    if (UpnForMitUser.Buffer) {
        NtLmFreePrivateHeap(UpnForMitUser.Buffer);
    }

    return Status;
}


NTSTATUS
NlpOpenCache( VOID )

/*++

Routine Description:

    Opens the registry node for read or write (depending on Switch) and opens
    the secret storage in the same mode.  If successful, the NlpCacheHandle
    is valid.

Arguments:

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    NlpCacheHandle contains handle to use for reading/writing
                    registry

        Failure =

--*/

{
    NTSTATUS NtStatus;
    ULONG Disposition;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ObjectName;

    ObjectName.Length = ObjectName.MaximumLength = CACHE_NAME_SIZE;
    ObjectName.Buffer = CACHE_NAME;

    InitializeObjectAttributes(&ObjectAttributes,
                                &ObjectName,
                                OBJ_CASE_INSENSITIVE,
                                0,      // RootDirectory
                                NULL    // default is reasonable from SYSTEM context
                                );
    NtStatus = NtCreateKey(&NlpCacheHandle,
                           (KEY_WRITE | KEY_READ),
                           &ObjectAttributes,
                           CACHE_TITLE_INDEX,
                           NULL,   // class name
                           0,      // create options
                           &Disposition
                           );

    return NtStatus;
}


VOID
NlpCloseCache( VOID )

/*++

Routine Description:

    Closes handles opened by NlpOpenCache

Arguments:

    None.

Return Value:

    None.

--*/

{
#if DBG
    NTSTATUS NtStatus;

    if (DumpCacheInfo) {
        DbgPrint("CloseCache: Closing NlpCacheHandle (%#08x)\n", NlpCacheHandle);
    }

    if (IS_VALID_HANDLE(NlpCacheHandle)) {
        NtStatus = NtClose(NlpCacheHandle);
        if (DumpCacheInfo) {
            DbgPrint("CloseCache: NtClose returns %#08x\n", NtStatus);
        }
        ASSERT(NT_SUCCESS(NtStatus));
        INVALIDATE_HANDLE(NlpCacheHandle);
    }
#else
    if (IS_VALID_HANDLE(NlpCacheHandle)) {
        NtClose(NlpCacheHandle);
        INVALIDATE_HANDLE(NlpCacheHandle);
    }
#endif
}


NTSTATUS
NlpOpenSecret(
    IN  ULONG   Index
    )

/*++

Routine Description:

    Opens a cache entry's secret storage object for read (in order to LsaQuerySecret) and
    write (in order to LsaSetSecret).  If successful, the handle value
    is placed in the global variable NlpSecretHandle.

    If the secret does not exist, it will be created.


Arguments:

    Index - The index of the entry being opened.  This is used to build
        a name of the object.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    NlpSecretHandle can be used to read/write secret storage

        Failure =

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];


    //
    // Close previous handle if necessary
    //

    if (IS_VALID_HANDLE(NlpSecretHandle)) {
        I_LsarClose( &NlpSecretHandle );
    }

    ValueName.Buffer = &NameBuffer[0];
    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    NlpMakeCacheEntryName( Index, &ValueName );

    NtStatus = I_LsarOpenSecret(NtLmGlobalPolicyHandle,
                              (PLSAPR_UNICODE_STRING) &ValueName,
                              SECRET_QUERY_VALUE | SECRET_SET_VALUE,
                              &NlpSecretHandle
                              );

    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
            NtStatus = I_LsarCreateSecret(NtLmGlobalPolicyHandle,
                                        (PLSAPR_UNICODE_STRING) &ValueName,
                                        SECRET_SET_VALUE | SECRET_QUERY_VALUE,
                                        &NlpSecretHandle
                                        );
            if (!NT_SUCCESS(NtStatus)) {
                INVALIDATE_HANDLE(NlpSecretHandle);
            }
        } else {
            INVALIDATE_HANDLE(NlpSecretHandle);
        }
    }
    return(NtStatus);
}


VOID
NlpCloseSecret( VOID )

/*++

Routine Description:

    Closes the handles opened via NlpOpenSecret

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS
        NtStatus;

    if (IS_VALID_HANDLE(NlpSecretHandle)) {
        NtStatus = I_LsarClose(&NlpSecretHandle);
#if DBG
        if (DumpCacheInfo) {
            DbgPrint("CloseSecret: LsaClose returns %#08x\n", NtStatus);
        }
#endif
        ASSERT(NT_SUCCESS(NtStatus));
        INVALIDATE_HANDLE(NlpSecretHandle);
    }
}


NTSTATUS
NlpWriteSecret(
    IN  PLSAPR_CR_CIPHER_VALUE NewSecret,
    IN  PLSAPR_CR_CIPHER_VALUE OldSecret
    )

/*++

Routine Description:

    Writes the password (and optionally the previous password) to the LSA
    secret storage

Arguments:

    NewSecret   - pointer to UNICODE_STRING containing current password
    OldSecret   - pointer to UNICODE_STRING containing previous password

Return Value:

    NTSTATUS
        Success =
        Failure =

--*/

{
    return I_LsarSetSecret(NlpSecretHandle, NewSecret, OldSecret);
}


NTSTATUS
NlpReadSecret(
    OUT PLSAPR_CR_CIPHER_VALUE * NewSecret,
    OUT PLSAPR_CR_CIPHER_VALUE * OldSecret
    )

/*++

Routine Description:

    Reads the new and old secrets (UNICODE_STRINGs) for the
    currently open LSA secret

    The Lsa routine returns us pointers to UNICODE strings

Arguments:

    NewSecret   - pointer to returned pointer to UNICODE_STRING containing
                  most recent password (if any)

    OldSecret   - pointer to returned pointer to UNICODE_STRING containing
                  previous password (if any)

Return Value:

    NTSTATUS
        Success
        Failure

--*/

{
    NTSTATUS
        NtStatus;

    LARGE_INTEGER
        NewTime,
        OldTime;

    NtStatus = I_LsarQuerySecret(NlpSecretHandle,
                              NewSecret,
                              &NewTime,
                              OldSecret,
                              &OldTime
                              );



#if DBG
    {
        char newNt[80];
        char newLm[80];
        char oldNt[80];
        char oldLm[80];

        if (DumpCacheInfo) {
            DbgPrint("NlpReadSecret: NewSecret.Nt = \"%s\"\n"
                     "            NewSecret.Lm = \"%s\"\n"
                     "            OldSecret.Nt = \"%s\"\n"
                     "            OldSecret.Lm = \"%s\"\n",
                     *NewSecret
                        ? DumpOwfPasswordToString(newNt, (PLM_OWF_PASSWORD)((*NewSecret)->Buffer))
                        : "",
                     *NewSecret
                        ? DumpOwfPasswordToString(newLm, (PLM_OWF_PASSWORD)((*NewSecret)->Buffer)+1)
                        : "",
                     *OldSecret
                        ? DumpOwfPasswordToString(oldNt, (PLM_OWF_PASSWORD)((*OldSecret)->Buffer))
                        : "",
                     *OldSecret
                        ? DumpOwfPasswordToString(oldLm, (PLM_OWF_PASSWORD)((*OldSecret)->Buffer)+1)
                        : ""
                     );
        }
    }
#endif

    return NtStatus;
}


NTSTATUS
NlpComputeSaltedHashedPassword(
    OUT PNT_OWF_PASSWORD SaltedOwfPassword,
    IN PNT_OWF_PASSWORD OwfPassword,
    IN PUNICODE_STRING UserName
    )

/*++

Routine Description:

    Computes the salted hash of a password by concatenating the user name
    with the OWF and computing the OWF of the combination.

Arguments:

    SaltedOwfPassword - receives the LM or NT salted password/
    OwfPassword - Contains the NT or LM owf password.
    UserName - Contains the name of the user, used for salt.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    Passwords created OK

        Failure = STATUS_NO_MEMORY
                    Not enough storage to create Passwords

--*/
{
    NTSTATUS Status;
    UNICODE_STRING TempString;
    UNICODE_STRING LowerUserName;

    //
    // Compute the lower case user name.
    //

    Status = RtlDowncaseUnicodeString( &LowerUserName,
                                       UserName,
                                       TRUE );

    if ( !NT_SUCCESS(Status)) {
        return Status;
    }


    //
    // Build a string that is a concatenation of the OWF and LowerCase username.
    //

    TempString.Length = TempString.MaximumLength = LowerUserName.Length + sizeof(NT_OWF_PASSWORD);
    TempString.Buffer = AllocateFromHeap( TempString.Length );
    if (TempString.Buffer == NULL) {
        RtlFreeUnicodeString( &LowerUserName );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        TempString.Buffer,
        OwfPassword,
        sizeof(NT_OWF_PASSWORD) );

    RtlCopyMemory(
        (PUCHAR) TempString.Buffer + sizeof(NT_OWF_PASSWORD),
        LowerUserName.Buffer,
        LowerUserName.Length );


    //
    // The Salted hash is the OWF of that.
    //
    Status = RtlCalculateNtOwfPassword(
                &TempString,
                SaltedOwfPassword
                );

    FreeToHeap(TempString.Buffer);
    RtlFreeUnicodeString( &LowerUserName );

    return(Status);

}


NTSTATUS
NlpMakeSecretPassword(
    OUT PLSAPR_CR_CIPHER_VALUE Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    )

/*++

Routine Description:

    Converts a (fixed length structure) NT_OWF_PASSWORD and a LM_OWF_PASSWORD
    to a UNICODE_STRING. Allocates memory for the unicode string in this function

    The calling function must free up the string buffer allocated in this routine.
    The caller uses FreeToHeap (RtlFreeHeap)

Arguments:

    Passwords       - returned UNICODE_STRING which actually contains a
                        CACHE_PASSWORDS structure
    NtOwfPassword   - pointer to encrypted, fixed-length NT password
    LmOwfPassword   - pointer to encrypted, fixed-length LM password

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    Passwords created OK

        Failure = STATUS_NO_MEMORY
                    Not enough storage to create Passwords

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACHE_PASSWORDS pwd;

    Passwords->Buffer = NULL;

    pwd = (PCACHE_PASSWORDS)AllocateFromHeap(sizeof(*pwd));
    if (pwd == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // concatenate the fixed length NT_OWF_PASSWORD and LM_OWF_PASSWORD structures
    // into a buffer which we then use as a UNICODE_STRING
    //

    if (ARGUMENT_PRESENT(NtOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.NtOwfPassword,
                    NtOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.NtPasswordPresent = TRUE;
    } else {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.NtOwfPassword,
                        sizeof(pwd->SecretPasswords.NtOwfPassword)
                        );
        pwd->SecretPasswords.NtPasswordPresent = FALSE;
    }

    if (ARGUMENT_PRESENT(LmOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.LmOwfPassword,
                    LmOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.LmPasswordPresent = TRUE;
    } else {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.LmOwfPassword,
                        sizeof(pwd->SecretPasswords.LmOwfPassword)
                        );
        pwd->SecretPasswords.LmPasswordPresent = FALSE;
    }

    Passwords->Length = Passwords->MaximumLength = sizeof(*pwd);
    Passwords->Buffer = (PUCHAR)pwd;

Cleanup:

    if( !NT_SUCCESS( Status ) ) {
        if( pwd != NULL )
            FreeToHeap( pwd );
    }

    return Status;
}


NTSTATUS
NlpMakeSecretPasswordNT5(
    IN OUT PCACHE_PASSWORDS Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    )

/*++

Routine Description:

    Populates CACHE_PASSWORDS structure with salted forms of NtOwfPassword
    and LmOwfPassword.

Arguments:

    Passwords       - populated CACHE_PASSWORDS structure.
    NtOwfPassword   - pointer to encrypted, fixed-length NT password
    LmOwfPassword   - pointer to encrypted, fixed-length LM password

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    Passwords created OK

        Failure = STATUS_NO_MEMORY
                    Not enough storage to create Passwords

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACHE_PASSWORDS pwd;


    pwd = Passwords;

    //
    // concatenate the fixed length NT_OWF_PASSWORD and LM_OWF_PASSWORD structures
    // into a buffer which we then use as a UNICODE_STRING
    //

    if (ARGUMENT_PRESENT(NtOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.NtOwfPassword,
                    NtOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.NtPasswordPresent = TRUE;
    } else {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.NtOwfPassword,
                        sizeof(pwd->SecretPasswords.NtOwfPassword)
                        );
        pwd->SecretPasswords.NtPasswordPresent = FALSE;
    }

    //
    // Windows2000:
    // never store LMOWF -- since we never need it, and, this would
    // be the first thing attacked once a cache entry is unwrapped.
    //

#if 0

    if (ARGUMENT_PRESENT(LmOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.LmOwfPassword,
                    LmOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.LmPasswordPresent = TRUE;
    } else
#else
    UNREFERENCED_PARAMETER( LmOwfPassword );
#endif
    {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.LmOwfPassword,
                        sizeof(pwd->SecretPasswords.LmOwfPassword)
                        );
        pwd->SecretPasswords.LmPasswordPresent = FALSE;
    }


Cleanup:


    return Status;
}

NTSTATUS
NlpGetCredentialNamesFromCacheEntry(
    IN PLOGON_CACHE_ENTRY CacheEntry,
    IN PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING UserName
    )

/*++

Routine Description:

    Uses the supplemental data found in a cached MIT logon to
    to get the MIT princ names

Arguments:

    CacheEntry - Cache entry
    DomainName - Realm name
    UserName - Princ name

Return Value:

    NTSATUS
    
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING User = {0};
    UNICODE_STRING Domain = {0};

    //
    // ealier revisons of cache entries do not have the CacheFlags field
    //

    if ((CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0) && (CacheEntry->CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON)) 
    {
        Status = NlpGetCredentialNamesFromMitCacheEntry(CacheEntry, &Domain, &User);

        if (!NT_SUCCESS(Status)) 
        {
            goto Cleanup;
        }
    }
    else
    {
        User = AccountInfo->EffectiveName;
        Domain = AccountInfo->LogonDomainName;
    }

    Status = NtLmDuplicateUnicodeString(DomainName, &Domain);

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    Status = NtLmDuplicateUnicodeString(UserName, &User);

Cleanup:

    return Status;
}

NTSTATUS
NlpGetCredentialNamesFromMitCacheEntry(
    IN PLOGON_CACHE_ENTRY CacheEntry,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING UserName
    )

/*++

Routine Description:

    Uses the supplemental data found in a cached MIT logon to
    to get the MIT princ names

Arguments:

    CacheEntry - Cache entry
    DomainName - Realm name
    UserName - Princ name

Return Value:

    NTSATUS
    
--*/

{
    if ( (CacheEntry->SupplementalCacheDataOffset < sizeof(LOGON_CACHE_ENTRY)) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    return NlpGetCredentialNamesFromMitCacheSupplementalCacheData(
                CacheEntry->SupplementalCacheDataLength,
                (PBYTE) RtlOffsetToPointer(
                            CacheEntry, 
                            CacheEntry->SupplementalCacheDataOffset
                            ),
                DomainName,
                UserName
                );
}

NTSTATUS
NlpGetCredentialNamesFromMitCacheSupplementalCacheData(
    IN ULONG SupplementalCacheDataLength,
    IN PBYTE SupplementalCacheData,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING UserName
    )

/*++

Routine Description:

    Uses the supplemental data found in a cached MIT logon to
    to get the MIT princ names

Arguments:

    SupplementalCacheDataLength - SupplementalCacheDataLength
    SupplementalCacheData - SupplementalCacheData   
    DomainName - Realm name
    UserName - Princ name

Return Value:

    NTSATUS
    
--*/

{
    PBYTE Tmp = SupplementalCacheData;

    if ( SupplementalCacheDataLength < (2 * sizeof(UNICODE_STRING)) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Supplemental data will contain 2 UNICODE_STRINGs & buffers, in format
    // MIT User <buffer> MIT Realm <buffer>.  All buffers are offset from
    // beginning of supplemental data.
    //

    RtlCopyMemory(
        UserName,
        Tmp,
        sizeof(UNICODE_STRING)
        );

    Tmp += sizeof(UNICODE_STRING);
    UserName->Buffer = (PWSTR) RtlOffsetToPointer(SupplementalCacheData, UserName->Buffer);
    
    Tmp += ROUND_UP_COUNT(UserName->Length, ALIGN_LONG);

    RtlCopyMemory(
        DomainName,
        Tmp,
        sizeof(UNICODE_STRING)
        );

    DomainName->Buffer = (PWSTR) RtlOffsetToPointer(SupplementalCacheData, DomainName->Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
NlpReadCacheEntry(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    OUT PULONG              Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG              EntrySize
    )

/*++

Routine Description:

    Searches the active entry list for a domain\username
    match in the cache.  If a match is found, then it
    is returned.

Arguments:

    DomainName   - The name of the domain in which the account exists.
        This can be the Netbios or Dns Domain Name.

    UserName     - The name of the account whose password is to be changed.
        This can be the Sam Account Name.
        If DomainName is empty, this is the UPN of the account

    Index        - receives the index of the entry retrieved.

    CacheEntry   - pointer to place to return pointer to LOGON_CACHE_ENTRY

    EntrySize    - size of returned LOGON_CACHE_ENTRY


Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *ppEntry points to allocated LOGON_CACHE_ENTRY
                    *EntrySize is size of returned data

        Failure = STATUS_NO_MEMORY
                    Couldn't allocate buffer for LOGON_CACHE_ENTRY

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    UNICODE_STRING CachedUser;
    UNICODE_STRING CachedDomain;
    UNICODE_STRING CachedDnsDomain;
    UNICODE_STRING CachedUpn;
    BOOLEAN CaseInSensitive = TRUE;

    PNLP_CTE Next;

    SspPrint((SSP_CRED, "NlpReadCacheEntry looking for: %wZ\\%wZ\n", DomainName, UserName));

    //
    // Walk the active list looking for a domain/name match
    //

    Next = (PNLP_CTE)NlpActiveCtes.Flink;

    while (Next != (PNLP_CTE)&NlpActiveCtes) {

        ASSERT(CacheEntry && (!*CacheEntry) && L"*CacheEntry must be null");

        NtStatus = NlpReadCacheEntryByIndex(
                        Next->Index,
                        CacheEntry,
                        EntrySize
                        );

        if (!NT_SUCCESS(NtStatus)) {
            break;  // out of while-loop
        }

        //
        // Grab the various strings from the cache entry.
        //
        ASSERT((*CacheEntry)->Revision >= NLP_CACHE_REVISION_NT_1_0B );

        //
        // decrypt the cache entry...
        //

        NtStatus = NlpDecryptCacheEntry( *CacheEntry, *EntrySize );

        if (!NT_SUCCESS(NtStatus)) {

            //
            // for failed decrypt, continue the search.
            // the reason for this is because the decrypt does an integrity
            // check.  We don't want one corrupt cache entry to cause (possibly)
            // the whole cache to be invalidated.
            //

            FreeToHeap( (*CacheEntry) );
            *CacheEntry = NULL;

            Next = (PNLP_CTE)(Next->Link.Flink);

            continue;
        }

        CachedUser.Length =
            CachedUser.MaximumLength = (*CacheEntry)->UserNameLength;
        if ( (*CacheEntry)->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {
            CachedUser.Buffer = (PWSTR) ((PBYTE) *CacheEntry + sizeof(LOGON_CACHE_ENTRY));
        } else {
            CachedUser.Buffer = (PWSTR) ((PBYTE) *CacheEntry + sizeof(LOGON_CACHE_ENTRY_NT_4_SP4));
        }

        CachedDomain.Length =
            CachedDomain.MaximumLength = (*CacheEntry)->DomainNameLength;
        CachedDomain.Buffer = (PWSTR)((LPBYTE)CachedUser.Buffer +
            ROUND_UP_COUNT((*CacheEntry)->UserNameLength, sizeof(ULONG)));

        CachedDnsDomain.Length =
            CachedDnsDomain.MaximumLength = (*CacheEntry)->DnsDomainNameLength;
        CachedDnsDomain.Buffer = (PWSTR)((LPBYTE)CachedDomain.Buffer +
            ROUND_UP_COUNT((*CacheEntry)->DomainNameLength, sizeof(ULONG)));

        CachedUpn.Length =
            CachedUpn.MaximumLength = (*CacheEntry)->UpnLength;
        CachedUpn.Buffer = (PWSTR)((LPBYTE)CachedDnsDomain.Buffer +
            ROUND_UP_COUNT((*CacheEntry)->DnsDomainNameLength, sizeof(ULONG)));

        //
        // ealier revisons of cache entries do not have the CacheFlags field
        //

        if (((*CacheEntry)->Revision >= NLP_CACHE_REVISION_NT_5_0)) {

            //
            // MIT user name and realm name are case sensitive
            //
            
            CaseInSensitive = (BOOLEAN) (0 == ((*CacheEntry)->CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON));
            
            SspPrint((SSP_CRED, 
                "NlpReadCacheEntry checking entry %d: domain (%wZ), dnsDomain (%wZ), upn (%wZ), user (%wZ), flags %#x\n",
                 Next->Index, 
                 &CachedDomain, 
                 &CachedDnsDomain,
                 &CachedUpn, 
                 &CachedUser, 
                 (*CacheEntry)->CacheFlags));
        }

        if (DomainName->Length != 0) {

            //
            // smartcard only cache entries use UPN only, skip it. 
            // check for earlier versions prior to nt_5_0 where SC is not 
            // supported and CacheFlags is not part of the cache entry
            //

            if (((*CacheEntry)->Revision < NLP_CACHE_REVISION_NT_5_0) || (0 == ((*CacheEntry)->CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_SMARTCARD_ONLY)))
            {
                if (RtlEqualUnicodeString(UserName, &CachedUser, CaseInSensitive)) {
    
                    if ( RtlEqualDomainName(DomainName, &CachedDomain) ||
                         RtlEqualUnicodeString(DomainName, &CachedDnsDomain, CaseInSensitive) ) {
    
                        //
                        // found it !
                        //
    
                        SspPrint((SSP_CRED, "NlpReadCacheEntry domain and user names matched\n"));
    
                        break; // out of while-loop
                    }
                }
            }

        //
        // If no domain name was passed in,
        //  the user name is the UPN.
        //

        } else {

            if ( RtlEqualUnicodeString(UserName, &CachedUpn, CaseInSensitive) ) {

                //
                // found it !
                //

                SspPrint((SSP_CRED, "NlpReadCacheEntry UPNs matched\n"));

                break; // out of while-loop
            }
        }

        //
        // Not the right entry, free the registry structure
        // and go on to the next one.
        //

        FreeToHeap( (*CacheEntry) );
        *CacheEntry = NULL;

        Next = (PNLP_CTE)(Next->Link.Flink);
    }

    if (Next != (PNLP_CTE)&NlpActiveCtes && NT_SUCCESS(NtStatus)) {

        //
        // We found a match - Open the corresponding secret
        //

        (*Index) = Next->Index;

        if( (*CacheEntry)->Revision < NLP_CACHE_REVISION_NT_5_0 ) {

            //
            // versions prior to NT5 require us open the corresponding LSA secret.
            //

            NtStatus = NlpOpenSecret(Next->Index);

            if (!NT_SUCCESS(NtStatus)) {
                FreeToHeap( (*CacheEntry) );
                *CacheEntry = NULL;
                return(NtStatus);
            }
        }

    } else {
        NtStatus = STATUS_LOGON_FAILURE;
    }

    return(NtStatus);
}


NTSTATUS
NlpWriteCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY Entry,
    IN  ULONG              EntrySize
    )

/*++

Routine Description:

    Writes a LOGON_CACHE_ENTRY to the registry cache.

    It is the caller's responsibility to place the corresponding
    CTE table entry in the correct active/inactive list.

Arguments:
    Index      - Index of entry to write out.

    Entry      - pointer to LOGON_CACHE_ENTRY to write to cache

    EntrySize   - size of this entry (in bytes (must be multiple of 4 thoough))


Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    The LOGON_CACHE_ENTRY is now in the registry (hopefully
                    on disk)

        Failure =

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    ValueName.Buffer = &NameBuffer[0];
    NlpMakeCacheEntryName( Index, &ValueName );

    SspPrint((SSP_CRED, "NlpWriteCacheEntry cache entry index: %d, value name: %wZ, valid %s\n", 
        Index, &ValueName, Entry->Valid ? "true" : "false"));

    NtStatus = NtSetValueKey(NlpCacheHandle,
                             &ValueName,
                             0,             // TitleIndex
                             REG_BINARY,    // Type
                             (PVOID)Entry,
                             EntrySize
                             );
    return(NtStatus);
}


VOID
NlpCopyAndUpdateAccountInfo(
    IN  USHORT Length,
    IN  PUNICODE_STRING pUnicodeString,
    IN OUT PUCHAR* pSource,
    IN OUT PUCHAR* pDest
    )

/*++

Routine Description:

    Updates a UNICODE_STRING structure and copies the associated buffer to
    *pDest, if Length is non-zero

Arguments:

    Length          - length of UNICODE_STRING.Buffer to copy
    pUnicodeString  - pointer to UNICODE_STRING structure to update
    pSource         - pointer to pointer to source WCHAR string
    pDest           - pointer to pointer to place to copy WCHAR string

Return Value:

    None.
    if string was copied, *Source and *Dest are updated to point to the next
    naturally aligned (DWORD) positions in the input and output buffers resp.

--*/

{
    PUCHAR  source = *pSource;
    PUCHAR  dest = *pDest;

    pUnicodeString->Length = Length;
    pUnicodeString->MaximumLength = Length;
    pUnicodeString->Buffer = (PWSTR)dest;
    if (Length) {
        RtlCopyMemory(dest, source, Length);
        *pSource = ROUND_UP_POINTER(source + Length, sizeof(ULONG));
        *pDest = ROUND_UP_POINTER(dest + Length, sizeof(ULONG));
    }
}


VOID
NlpSetTimeField(
    OUT POLD_LARGE_INTEGER pTimeField,
    IN  NLP_SET_TIME_HINT Hint
    )

/*++

Routine Description:

    Sets a LARGE_INTEGER time field to one of 3 values:
        NLP_BIG_TIME     = maximum positive large integer (0x7fffffffffffffff)
        NLP_SMALL_TIME   = smallest positive large integer (0)
        NLP_NOW_TIME     = current system time

Arguments:

    pTimeField  - pointer to LARGE_INTEGER structure to update
    Hint        - NLP_BIG_TIME, NLP_SMALL_TIME or NLP_NOW_TIME

Return Value:

    None.

--*/

{
    LARGE_INTEGER Time;

    switch (Hint) {
    case NLP_SMALL_TIME:
        pTimeField->HighPart = SMALL_PART_1;
        pTimeField->LowPart = SMALL_PART_2;
        break;

    case NLP_BIG_TIME:
        pTimeField->HighPart = BIG_PART_1;
        pTimeField->LowPart = BIG_PART_2;
        break;

    case NLP_NOW_TIME:
        NtQuerySystemTime(&Time);
        NEW_TO_OLD_LARGE_INTEGER( Time, (*pTimeField) );
        break;
    }
}


NTSTATUS
NlpBuildAccountInfo(
    IN  PLOGON_CACHE_ENTRY pCacheEntry,
    IN  ULONG EntryLength,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 *AccountInfo
    )

/*++

Routine Description:

    Performs the reverse of NlpBuildCacheEntry - creates a NETLOGON_VALIDATION_SAM_INFO4
    structure from a cache entry

Arguments:

    pCacheEntry - pointer to LOGON_CACHE_ENTRY

    EntryLength - inclusive size of *pCacheEntry, including variable data

    AccountInfo - pointer to place to create NETLOGON_VALIDATION_SAM_INFO4

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS

        Failure = STATUS_NO_MEMORY

--*/

{
    PNETLOGON_VALIDATION_SAM_INFO4 pSamInfo;
    PUCHAR source;
    PUCHAR dest;
    ULONG length;
    ULONG sidLength;
    ULONG commonBits;
    LPWSTR computerName = NULL;
    ULONG computerNameLength = 0;

    //
    // commonBits is the size of the variable data area common to both the
    // LOGON_CACHE_ENTRY and NETLOGON_VALIDATION_SAM_INFO4 structures
    //

    commonBits  = ROUND_UP_COUNT(pCacheEntry->EffectiveNameLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->FullNameLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->LogonScriptLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->ProfilePathLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->HomeDirectoryLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->HomeDirectoryDriveLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->GroupCount * sizeof(GROUP_MEMBERSHIP), sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->LogonDomainNameLength, sizeof(ULONG));

    if ( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 )
    {
        commonBits  += ROUND_UP_COUNT(pCacheEntry->DnsDomainNameLength, sizeof(ULONG))
                    + ROUND_UP_COUNT(pCacheEntry->UpnLength, sizeof(ULONG));

        if( pCacheEntry->LogonServerLength != 0 )
        {
            computerNameLength = pCacheEntry->LogonServerLength;
            computerName = NULL;
        }
    }

    if ( computerNameLength == 0 )
    {
        //
        // will GetComputerName ever fail??? Its only used to fake the logon
        // server name when we logon using the cached information, so its
        // probably ok to use a NULL string if GetComputerName phones in sick
        //

        computerName = NlpComputerName.Buffer;
        computerNameLength = NlpComputerName.Length / sizeof(WCHAR);

        ASSERT( computerName );
        ASSERT( computerNameLength );

#if DBG
        if (DumpCacheInfo) {
            DbgPrint("ComputerName = %ws, length = %d\n", computerName, computerNameLength);
        }
#endif
    }

    ASSERT(pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B);

    //
    // Account for possible roundup for NETLOGON_SID_AND_ATTRIBUTES structure
    //
    commonBits += sizeof(PVOID);

    commonBits += ROUND_UP_COUNT(sizeof(NETLOGON_SID_AND_ATTRIBUTES) * pCacheEntry->SidCount, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->SidLength, sizeof(ULONG));

    sidLength = pCacheEntry->LogonDomainIdLength;



    //
    // length is the required amount of buffer in which to build a working
    // NETLOGON_VALIDATION_SAM_INFO4 structure
    //

    length = ROUND_UP_COUNT(sizeof(NETLOGON_VALIDATION_SAM_INFO4), sizeof(ULONG))
                + commonBits
                + sidLength
                + computerNameLength * sizeof(WCHAR);

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpBuildAccountInfo: %d bytes required\n", length);
    }
#endif

    // MIDL_user_allocate zeros the buffer.  This routine depends on that.
    pSamInfo = (PNETLOGON_VALIDATION_SAM_INFO4)MIDL_user_allocate(length);
    if (pSamInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // point dest at the first (aligned) byte at the start of the variable data
    // area at the end of the sam info structure
    //

    dest = (PUCHAR)(pSamInfo + 1);

    //
    // point source at the first string to be copied out of the variable length
    // data area at the end of the cache entry
    //

    ASSERT(pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B );

    if ( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {
        source = (PUCHAR)(pCacheEntry + 1);
    } else {
        source = (PUCHAR)( (PLOGON_CACHE_ENTRY_NT_4_SP4)pCacheEntry + 1 );
    }

    source += ROUND_UP_COUNT(pCacheEntry->UserNameLength, sizeof(ULONG))
              + ROUND_UP_COUNT(pCacheEntry->DomainNameLength, sizeof(ULONG));


    if ( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 )
    {

        NlpCopyAndUpdateAccountInfo(pCacheEntry->DnsDomainNameLength,
                                    &pSamInfo->DnsLogonDomainName,
                                    &source,
                                    &dest
                                    );

        NlpCopyAndUpdateAccountInfo(pCacheEntry->UpnLength,
                                    &pSamInfo->Upn,
                                    &source,
                                    &dest
                                    );

    } else {
        //
        // Fill in the new field for the PNETLOGON_VALIDATION_SAM_INFO4 structure
        //

        RtlInitUnicodeString( &pSamInfo->DnsLogonDomainName, NULL );
        RtlInitUnicodeString( &pSamInfo->Upn, NULL );

        source += ROUND_UP_COUNT(pCacheEntry->DnsDomainNameLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->UpnLength, sizeof(ULONG));

    }

    //
    // pull out the variable length data from the end of the LOGON_CACHE_ENTRY
    // and stick them at the end of the NETLOGON_VALIDATION_SAM_INFO4 structure.
    // These must be copied out IN THE SAME ORDER as NlpBuildCacheEntry put them
    // in. If we want to change the order of things in the buffer, the order
    // must be changed in both routines (this & NlpBuildCacheEntry)
    //

    //
    // create the UNICODE_STRING structures in the NETLOGON_VALIDATION_SAM_INFO4
    // structure and copy the strings to the end of the buffer. 0 length strings
    // will get a pointer which should be ignored
    //

    NlpCopyAndUpdateAccountInfo(pCacheEntry->EffectiveNameLength,
                                &pSamInfo->EffectiveName,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->FullNameLength,
                                &pSamInfo->FullName,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->LogonScriptLength,
                                &pSamInfo->LogonScript,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->ProfilePathLength,
                                &pSamInfo->ProfilePath,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->HomeDirectoryLength,
                                &pSamInfo->HomeDirectory,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->HomeDirectoryDriveLength,
                                &pSamInfo->HomeDirectoryDrive,
                                &source,
                                &dest
                                );

    //
    // copy the group membership array
    //

    pSamInfo->GroupIds = (PGROUP_MEMBERSHIP)dest;
    length = pCacheEntry->GroupCount * sizeof(GROUP_MEMBERSHIP);
    RtlCopyMemory(dest, source, length);
    dest = ROUND_UP_POINTER(dest + length, sizeof(ULONG));
    source = ROUND_UP_POINTER(source + length, sizeof(ULONG));

    //
    // final UNICODE_STRING from LOGON_CACHE_ENTRY. Reorganize this to:
    // strings, groups, SID?
    //

    NlpCopyAndUpdateAccountInfo(pCacheEntry->LogonDomainNameLength,
                                &pSamInfo->LogonDomainName,
                                &source,
                                &dest
                                );


    //
    // Copy all the SIDs
    //

    if (pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B ) {
        pSamInfo->SidCount = pCacheEntry->SidCount;

        if (pCacheEntry->SidCount) {
            ULONG i, sidLength;
            PULONG SidAttributes = (PULONG) source;
            source = ROUND_UP_POINTER(source + pCacheEntry->SidCount * sizeof(ULONG), sizeof(ULONG));

            //
            // Structures containing pointers must start on 8-byte boundries
            //
            dest = ROUND_UP_POINTER(dest, sizeof(PVOID));

            pSamInfo->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) dest;
            dest = ROUND_UP_POINTER(dest + pCacheEntry->SidCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES), sizeof(ULONG));

            for (i = 0; i < pCacheEntry->SidCount ; i++ ) {
                pSamInfo->ExtraSids[i].Attributes = SidAttributes[i];
                sidLength = RtlLengthSid((PSID) source);
                RtlCopySid(sidLength, (PSID) dest, (PSID) source);
                pSamInfo->ExtraSids[i].Sid = (PSID) dest;
                dest = ROUND_UP_POINTER(dest + sidLength, sizeof(ULONG));
                source = ROUND_UP_POINTER(source + sidLength, sizeof(ULONG));
            }

            ASSERT((ULONG) (source - (PUCHAR) SidAttributes) == pCacheEntry->SidLength);

        } else {
            pSamInfo->ExtraSids = NULL;
        }
    } else {
        pSamInfo->ExtraSids = NULL;
        pSamInfo->SidCount = 0;
    }


    //
    // copy the LogonDomainId SID
    //

    RtlCopySid(sidLength, (PSID)dest, (PSID)source);
    pSamInfo->LogonDomainId = (PSID)dest;
    dest = ROUND_UP_POINTER(dest + sidLength, sizeof(ULONG));
    source = ROUND_UP_POINTER(source + sidLength, sizeof(ULONG));

    if ( computerName != NULL )
    {
        //
        // final UNICODE_STRING. This one from stack. Note that we have finished
        // with source
        //

        source = (PUCHAR)computerName;
        NlpCopyAndUpdateAccountInfo((USHORT)(computerNameLength * sizeof(WCHAR)),
                                    &pSamInfo->LogonServer,
                                    &source,
                                    &dest
                                    );
    } else {

        //
        // Sanity check that we have a proper cache revision.
        //

        if ( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 )
        {
            //
            // final UNICODE_STRING from LOGON_CACHE_ENTRY.
            //

            NlpCopyAndUpdateAccountInfo((USHORT)pCacheEntry->LogonServerLength,
                                        &pSamInfo->LogonServer,
                                        &source,
                                        &dest
                                        );
        }
    }

    //
    // copy the non-variable fields
    //

    pSamInfo->UserId = pCacheEntry->UserId;
    pSamInfo->PrimaryGroupId = pCacheEntry->PrimaryGroupId;
    pSamInfo->GroupCount = pCacheEntry->GroupCount;

    //
    // finally, invent some fields
    //

    NlpSetTimeField(&pSamInfo->LogonTime, NLP_NOW_TIME);
    NlpSetTimeField(&pSamInfo->LogoffTime, NLP_BIG_TIME);
    NlpSetTimeField(&pSamInfo->KickOffTime, NLP_BIG_TIME);
    NlpSetTimeField(&pSamInfo->PasswordLastSet, NLP_SMALL_TIME);
    NlpSetTimeField(&pSamInfo->PasswordCanChange, NLP_BIG_TIME);
    NlpSetTimeField(&pSamInfo->PasswordMustChange, NLP_BIG_TIME);

    pSamInfo->LogonCount = 0;
    pSamInfo->BadPasswordCount = 0;
    pSamInfo->UserFlags = LOGON_EXTRA_SIDS;
    if (pCacheEntry->LogonPackage != 0) {
        pSamInfo->UserFlags |= pCacheEntry->LogonPackage << PRIMARY_CRED_LOGON_PACKAGE_SHIFT;
    }

    // RtlZeroMemory(&pSamInfo->UserSessionKey, sizeof(pSamInfo->UserSessionKey));

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpBuildAccountInfo:\n");
        DumpAccountInfo(pSamInfo);
    }
#endif

    *AccountInfo = pSamInfo;
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER( EntryLength );
}


NTSTATUS
NlpGetCacheControlInfo( VOID )

/*++

Routine Description:

    This function retrieves the cache control information from the
    registry.  This information is placed in global data for use
    throughout this module.  The Cache Table Entry table will also
    be initialized.

    If this routine returns success, then it may be assumed that
    everything completed successfully.

Arguments:

    None.

Return Value:



--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        CacheControlValueName;

    ULONG
        RequiredSize;

    PKEY_VALUE_PARTIAL_INFORMATION
        RegInfo = NULL;


    //
    // read the current control info, if it is there.
    // If it is not there, then we may be dealing with a down-level
    // system and might have a single cache entry in the registry.
    //

    RtlInitUnicodeString( &CacheControlValueName, L"NL$Control" );
    NtStatus = NtQueryValueKey(NlpCacheHandle,
                               &CacheControlValueName,
                               KeyValuePartialInformation,
                               NULL,
                               0,
                               &RequiredSize
                               );

    if (NT_SUCCESS(NtStatus) || NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        NTSTATUS TempStatus;

        //
        // Hmmm - no entry, that means we are dealing with a
        //        first release system here (that didn't have
        //        this value).
        //


        //
        // Set up for 1 cache entry.
        // create the secret and cache key entry
        //

        TempStatus = NlpMakeNewCacheEntry( 0 );

        if ( NT_SUCCESS(TempStatus) ) {
            //
            // Now flush out the control information
            //


            NlpCacheControl.Revision = NLP_CACHE_REVISION;
            NlpCacheControl.Entries  = 1;
            TempStatus = NlpWriteCacheControl();

            if ( NT_SUCCESS(TempStatus) ) {

                //
                // If a version 1.0 entry exists,
                //  copy the old form of cache entry to the new structure.
                //

//                if (NT_SUCCESS(NtStatus)) {
//                    TempStatus = NlpConvert1_0To1_0B();
//                }
            }
        }

        NtStatus = TempStatus;

    } else if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) {

        //
        // allocate buffer then do query again, this time receiving data
        //

        RegInfo = (PKEY_VALUE_PARTIAL_INFORMATION)AllocateFromHeap(RequiredSize);
        if (RegInfo == NULL) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        NtStatus = NtQueryValueKey(NlpCacheHandle,
                                   &CacheControlValueName,
                                   KeyValuePartialInformation,
                                   (PVOID)RegInfo,
                                   RequiredSize,
                                   &RequiredSize
                                   );

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // check the revision - we can't deal with up-level revisions.
        //

        if (RegInfo->DataLength < sizeof(NLP_CACHE_CONTROL)) {
            NtStatus = STATUS_UNKNOWN_REVISION;
            goto Cleanup;
        }

        RtlCopyMemory( &NlpCacheControl, &(RegInfo->Data[0]), sizeof(NLP_CACHE_CONTROL) );
        if (NlpCacheControl.Revision > NLP_CACHE_REVISION) {
            NtStatus = STATUS_UNKNOWN_REVISION;
            goto Cleanup;
        }


        //
        // If this is an older cache, update it with the latest revision
        //

        if (NlpCacheControl.Revision != NLP_CACHE_REVISION) {

            // There is no conversion. All the version of cache control have
            //  been the same.
            NlpCacheControl.Revision = NLP_CACHE_REVISION;
            NtStatus = NlpWriteCacheControl();

            if (!NT_SUCCESS(NtStatus)) {
                goto Cleanup;
            }
        }

        NtStatus = STATUS_SUCCESS;
    }

Cleanup:

    if (!NT_SUCCESS(NtStatus)) {
        NlpCacheControl.Entries = 0;    // Disable logon cache
    }

    if( RegInfo ) {
        FreeToHeap( RegInfo );
    }

    return(NtStatus);
}


NTSTATUS
NlpBuildCteTable( VOID )

/*++

Routine Description:

    This function initializes the CTE table from the contents of
    the cache in the registry.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS - the cache is initialized.

    Other - The cache has been disabled.

--*/

{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    PLOGON_CACHE_ENTRY
        CacheEntry;

    ULONG
        EntrySize,
        i;


    //
    // Initialize the active and inactive CTE lists
    //

    InitializeListHead( &NlpActiveCtes );
    InitializeListHead( &NlpInactiveCtes );


    //
    // Allocate a CTE table
    //

    NlpCteTable = AllocateFromHeap( sizeof( NLP_CTE ) *
                                    NlpCacheControl.Entries );
    if (NlpCteTable == NULL) {

        //
        // Can't allocate table, disable caching
        //

        NlpCacheControl.Entries = 0;    // Disable cache
        return(STATUS_NO_MEMORY);
    }

    for (i = 0; i < NlpCacheControl.Entries; i++) {

        NtStatus = NlpReadCacheEntryByIndex( i,
                                             &CacheEntry,
                                             &EntrySize);
        if (!NT_SUCCESS(NtStatus) ) {
            NlpCacheControl.Entries = 0;    // Disable cache
            return(NtStatus);
        }

        //
        //
        if (EntrySize < sizeof(LOGON_CACHE_ENTRY_NT_4_SP4)) {

            //
            // Hmmm, something is bad.
            // disable caching and return an error
            //

            NlpCacheControl.Entries = 0;    // Disable cache
            FreeToHeap( CacheEntry );
            return( STATUS_INTERNAL_DB_CORRUPTION );
        }

        if (CacheEntry->Revision > NLP_CACHE_REVISION) {
            NlpCacheControl.Entries = 0;  // Disable cache
            FreeToHeap( CacheEntry );
            return(STATUS_UNKNOWN_REVISION);
        }

        NlpCteTable[i].Index  = i;
        NlpCteTable[i].Active = CacheEntry->Valid;
        NlpCteTable[i].Time   = CacheEntry->Time;

        InsertTailList( &NlpInactiveCtes, &NlpCteTable[i].Link );

        if (NlpCteTable[i].Active) {
            NlpAddEntryToActiveList( i );
        }

        FreeToHeap( CacheEntry );

    }
    return(NtStatus);
}


NTSTATUS
NlpChangeCacheSizeIfNecessary( VOID )

/*++

Routine Description:

    This function checks to see if the user has requested a
    different cache size than what we currently have.

    If so, then we try to grow or shrink our cache appropriately.
    If this succeeds, then the global cache control information is
    updated appropriately.  If it fails then one of two things will
    happen:

        1) If the user was trying to shrink the cache, then it will
           be disabled (entries set to zero).

        2) If the user was trying to grow the cache, then we will leave
           it as it is.

    In either of these two failure conditions, an error is returned.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{

    NTSTATUS
        NtStatus;

    UINT
        CachedLogonsCount;

    PNLP_CTE
        NewCteTable,
        Next;

    LIST_ENTRY
        NewActive,
        NewInactive;

    PNLP_CACHE_AND_SECRETS
        CacheAndSecrets;


    ULONG
        ErrorCacheSize,
        i,
        j;


    // Find out how many logons to cache.
    // This is a user setable value and it may be different than
    // the last time we booted.
    //

    CachedLogonsCount = GetProfileInt(
                               TEXT("Winlogon"),
                               TEXT("CachedLogonsCount"),
                               NLP_DEFAULT_LOGON_CACHE_COUNT      // Default value
                               );

    //
    // Minimize the user-supplied value with the maximum allowable
    // value.
    //

    if (CachedLogonsCount > NLP_MAX_LOGON_CACHE_COUNT) {
        CachedLogonsCount = NLP_MAX_LOGON_CACHE_COUNT;
    }


    //
    // Compare it to what we already have and see if we need
    // to change the size of the cache
    //

    if (CachedLogonsCount == NlpCacheControl.Entries) {

        //
        // No change
        //

        return(STATUS_SUCCESS);
    }

    //
    // Set the size of the cache to be used in case of error
    // changing the size.  If we are trying to grow the cache,
    // then use the existing cache on error.  If we are trying
    // to shrink the cache, then disable caching on error.
    //

    if (CachedLogonsCount > NlpCacheControl.Entries) {
        ErrorCacheSize = NlpCacheControl.Entries;
    } else {
        ErrorCacheSize = 0;
    }

    //
    // Allocate a CTE table the size of the new table
    //

    NewCteTable = AllocateFromHeap( sizeof( NLP_CTE ) *
                                    CachedLogonsCount );
    if (NewCteTable == NULL) {

        //
        // Can't shrink table, disable caching
        //

        NlpCacheControl.Entries = ErrorCacheSize;
        return(STATUS_NO_MEMORY);
    }



    //
    // Now the tricky parts ...
    //

    if (CachedLogonsCount > NlpCacheControl.Entries) {


        //
        // Try to grow the cache -
        // Create additional secrets and cache entries.
        //
        // Copy time fields and set index
        //

        for (i=0;   i < NlpCacheControl.Entries;   i++) {
            NewCteTable[i].Index = i;
            NewCteTable[i].Time  = NlpCteTable[i].Time;
        }

        //
        // Place existing entries on either the active or inactive list
        //

        InitializeListHead( &NewActive );
        for (Next  = (PNLP_CTE)NlpActiveCtes.Flink;
             Next != (PNLP_CTE)(&NlpActiveCtes);
             Next  = (PNLP_CTE)Next->Link.Flink
             ) {

            InsertTailList( &NewActive, &NewCteTable[Next->Index].Link );
            NewCteTable[Next->Index].Active = TRUE;
        }


        InitializeListHead( &NewInactive );
        for (Next  = (PNLP_CTE)NlpInactiveCtes.Flink;
             Next != (PNLP_CTE)(&NlpInactiveCtes);
             Next  = (PNLP_CTE)Next->Link.Flink
             ) {

            InsertTailList( &NewInactive, &NewCteTable[Next->Index].Link );
            NewCteTable[Next->Index].Active = FALSE;
        }


        //
        // Make all the new table entries.
        // Mark them as invalid.
        //

        for (i=NlpCacheControl.Entries; i<CachedLogonsCount; i++) {

            //
            // Add the CTE entry to the inactive list
            //

            InsertTailList( &NewInactive, &NewCteTable[i].Link );
            NewCteTable[i].Active = FALSE;
            NewCteTable[i].Index  = i;

            NtStatus = NlpMakeNewCacheEntry( i );

            if (!NT_SUCCESS(NtStatus)) {
                FreeToHeap( NewCteTable );
                return(NtStatus);
            }
        }
    } else {


        //
        // Try to shrink the cache.
        //

        if (CachedLogonsCount != 0) {

            //
            // 0 size implies disabling the cache.
            // That is a degenerate case of shrinking that
            // requires only the last few steps of shrinking.
            //


            //
            // Allocate an array of pointers for reading registry and secret
            // info into.  Clear it to assist in cleanup.
            //

            CacheAndSecrets = (PNLP_CACHE_AND_SECRETS)
                              AllocateFromHeap( sizeof( NLP_CACHE_AND_SECRETS ) *
                                                CachedLogonsCount );

            if (CacheAndSecrets == NULL) {
                FreeToHeap( NlpCteTable );
                NlpCacheControl.Entries = ErrorCacheSize;
                return(STATUS_NO_MEMORY);
            }
            RtlZeroMemory( CacheAndSecrets,
                           (sizeof( NLP_CACHE_AND_SECRETS ) * CachedLogonsCount) );


            //
            // Set up the new CTE table to be inactive
            //

            InitializeListHead( &NewActive );
            InitializeListHead( &NewInactive );
            for (i=0; i<CachedLogonsCount; i++) {
                InsertTailList( &NewInactive, &NewCteTable[i].Link );
                NewCteTable[i].Index  = i;
                NewCteTable[i].Active = FALSE;
            }


            //
            // Walk the current active list, reading
            // entries and copying information into the new CTE table.
            //

            i = 0;
            Next = (PNLP_CTE)NlpActiveCtes.Flink;
            while (Next != (PNLP_CTE)&NlpActiveCtes && i<CachedLogonsCount) {

                NtStatus = NlpReadCacheEntryByIndex( Next->Index,
                                                     &CacheAndSecrets[i].CacheEntry,
                                                     &CacheAndSecrets[i].EntrySize
                                                     // &EntrySize
                                                     );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // for pre-Win2000 cache entries, read the associated secret.
                    //

                    if( CacheAndSecrets[i].CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {

                        NtStatus = NlpOpenSecret( Next->Index );
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus = NlpReadSecret( &CacheAndSecrets[i].NewSecret,
                                                      &CacheAndSecrets[i].OldSecret);

                            NlpCloseSecret();
                        }
                    }

                    if (NT_SUCCESS(NtStatus)) {
                        //
                        // Only make this entry active if everything was
                        // successfully read in.
                        //

                        CacheAndSecrets[i].Active = TRUE;
                        i++;    // advance our new CTE table index

                    }
                }

                Next = (PNLP_CTE)(Next->Link.Flink);

            } // end-while

            //
            // At this point "i" indicates how many CacheAndSecrets entries
            // are active.  Furthermore, the entries were assembled
            // in the CacheAndSecrets array in ascending time order, which
            // is the order they need to be placed in the new CTE table.
            //

            for ( j=0; j<i; j++) {

                Next = &NewCteTable[j];

                //
                // The Time field in the original cache entry is not aligned
                // properly, so copy each field individually.
                //

                Next->Time.LowPart = CacheAndSecrets[j].CacheEntry->Time.LowPart;
                Next->Time.HighPart = CacheAndSecrets[j].CacheEntry->Time.HighPart;

                //
                // Try writing out the new entry's information
                //

                NtStatus = NlpWriteCacheEntry( j,
                                               CacheAndSecrets[j].CacheEntry,
                                               CacheAndSecrets[j].EntrySize
                                               );
                if (NT_SUCCESS(NtStatus)) {

                    if ( CacheAndSecrets[j].CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {

                        //
                        // for pre-Win2000 cache entries, write the secret back out.
                        // note: we don't bother to try to migrate pre-win2000 -> Win2000
                        // here, because this will happen later, as a side-effect
                        // of updating cache entry during successful DC validated logon.
                        //

                        NtStatus = NlpOpenSecret( j );

                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus = NlpWriteSecret(CacheAndSecrets[j].NewSecret,
                                                      CacheAndSecrets[j].OldSecret);
                        }
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // move the corresponding entry into the new CTEs
                        // active list.
                        //

                        Next->Active = TRUE;
                        RemoveEntryList( &Next->Link );
                        InsertTailList( &NewActive, &Next->Link );
                    }
                }

                //
                // Free the CacheEntry and secret information
                //

                if (CacheAndSecrets[j].CacheEntry != NULL) {
                    FreeToHeap( CacheAndSecrets[j].CacheEntry );
                }
                if (CacheAndSecrets[j].NewSecret != NULL) {
                    RtlZeroMemory(CacheAndSecrets[j].NewSecret->Buffer, CacheAndSecrets[j].NewSecret->Length);
                    MIDL_user_free( CacheAndSecrets[j].NewSecret );
                }
                if (CacheAndSecrets[j].OldSecret != NULL) {
                    RtlZeroMemory(CacheAndSecrets[j].OldSecret->Buffer, CacheAndSecrets[j].OldSecret->Length);
                    MIDL_user_free( CacheAndSecrets[j].OldSecret );
                }
            }

            //
            // Free the CacheAndSecrets array
            // (everything in it has already been freed)
            //

            if (CacheAndSecrets != NULL) {
                FreeToHeap( CacheAndSecrets );
            }

            //
            // Change remaining entries to invalid (on disk)
            //

            for (j=i; j<CachedLogonsCount; j++) {
                NlpMakeNewCacheEntry( j );
            }

        } // end-if (CachedLogonsCount != 0)


        //
        // Now get rid of extra (no longer needed) entries
        //

        for (j=CachedLogonsCount; j<NlpCacheControl.Entries; j++) {
            NlpEliminateCacheEntry( j );
        }


    }

    //
    // We have successfully:
    //
    //      Allocated the new CTE table.
    //
    //      Filled the CTE table with copies of the currently
    //      active CTEs (including putting each CTE on an active
    //      or inactive list).
    //
    //      Established new CTE entries, including the corresponding
    //      secrets and cache keys in the registry, for the
    //      new CTEs.
    //
    //
    // All we have left to do is:
    //
    //
    //      Update the cache control structure in the registry
    //      to indicate we have a new length
    //
    //      move the new CTE over to the real Active and Inactive
    //      list heads (rather than the local ones we've used so far)
    //
    //      deallocate the old CTE table.
    //
    //      Re-set the entries count in the in-memory
    //      cache-control structure NlpCacheControl.
    //

    NlpCacheControl.Entries = CachedLogonsCount;
    NtStatus = NlpWriteCacheControl();

    if (CachedLogonsCount > 0) {  // Only necessary if there is a new CTE table
        if (!NT_SUCCESS(NtStatus)) {
            FreeToHeap( NewCteTable );
            NlpCacheControl.Entries = ErrorCacheSize;
            return(NtStatus);
        }

        InsertHeadList( &NewActive, &NlpActiveCtes );
        RemoveEntryList( &NewActive );
        InsertHeadList( &NewInactive, &NlpInactiveCtes );
        RemoveEntryList( &NewInactive );

        FreeToHeap( NlpCteTable );
        NlpCteTable = NewCteTable;
    }

    return(NtStatus);
}


NTSTATUS
NlpWriteCacheControl( VOID )

/*++

Routine Description:

    This function writes a new cache length out to the
    cache control structure stored in the registry.

    Note:
        When lengthening the cache, call this routine after the cache
        entries and corresponding secrets have been established for
        the new length.

        When shortening the cache, call this routine before the cache
        entries and corresponding secrets being discarded have actually
        been discarded.

        This ensures that if the system crashes during the resizing
        operation, it will be in a valid state when the system comes
        back up.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{

    NTSTATUS
        NtStatus;

    UNICODE_STRING
        CacheControlValueName;


    RtlInitUnicodeString( &CacheControlValueName, L"NL$Control" );
    NtStatus = NtSetValueKey( NlpCacheHandle,
                              &CacheControlValueName,       // Name
                              0,                            // TitleIndex
                              REG_BINARY,                   // Type
                              &NlpCacheControl,             // Data
                              sizeof(NLP_CACHE_CONTROL)    // DataLength
                              );
    return(NtStatus);
}


VOID
NlpMakeCacheEntryName(
    IN  ULONG               EntryIndex,
    OUT PUNICODE_STRING     Name
    )

/*++

Routine Description:

    This function builds a name of a cache entry value or secret name
    for a cached entry.  The name is based upon the index of the cache
    entry.

    Names are of the form:

            "NLP1" through "NLPnnn"

    where "nnn" is the largest allowable entry count (see
    NLP_MAX_LOGON_CACHE_COUNT).

    The output UNICODE_STRING buffer is expected to be large enough
    to accept this string with a null termination on it.


Arguments:

    EntryIndex - The index of the cache entry whose name is desired.

    Name - A unicode string large enough to accept the name.


Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        TmpString;

    WCHAR
        TmpStringBuffer[17];

    ASSERT(Name->MaximumLength >= 7*sizeof(WCHAR) );
    ASSERT( EntryIndex <= NLP_MAX_LOGON_CACHE_COUNT );

    Name->Length = 0;
    RtlAppendUnicodeToString( Name, L"NL$" );

    TmpString.MaximumLength = 16;
    TmpString.Length = 0;
    TmpString.Buffer = TmpStringBuffer;
    NtStatus = RtlIntegerToUnicodeString ( (EntryIndex+1),      // make 1 based index
                                           10,           // Base 10
                                           &TmpString
                                           );
    ASSERT(NT_SUCCESS(NtStatus));

    RtlAppendUnicodeStringToString( Name, &TmpString );

    return;
}


NTSTATUS
NlpMakeNewCacheEntry(
    ULONG           Index
    )

/*++

Routine Description:

    This routine creates a secret and a cache entry value for a
    new cache entry with the specified index.

    The secret handle is NOT left open.


Arguments:

    Index - The index of the cache entry whose name is desired.

    Name - A unicode string large enough to accept the name.


Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS
        NtStatus;

    LOGON_CACHE_ENTRY
        Entry;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    LSAPR_HANDLE
        SecretHandle;

    ValueName.Length = 0;
    ValueName.MaximumLength = 32;
    ValueName.Buffer = &NameBuffer[0];

    NlpMakeCacheEntryName( Index, &ValueName );

    NtStatus = I_LsarOpenSecret( NtLmGlobalPolicyHandle,
                                    (PLSAPR_UNICODE_STRING) &ValueName,
                                    DELETE,
                                    &SecretHandle
                                    );

    if( NT_SUCCESS( NtStatus ) ) {

        //
        // for Windows2000, we remove old style cache entry related
        // LSA secrets.
        //


        //
        // Deleting and object causes its handle to be closed
        //

        I_LsarDelete( SecretHandle );

//      I_LsarClose( &SecretHandle );
    }


    //
    // Create the cache entry marked as invalid
    //

    RtlZeroMemory( &Entry, sizeof(Entry) );
    Entry.Revision = NLP_CACHE_REVISION;
    Entry.Valid = FALSE;

    NtStatus = NtSetValueKey( NlpCacheHandle,
                              &ValueName,                   // Name
                              0,                            // TitleIndex
                              REG_BINARY,                   // Type
                              &Entry,                       // Data
                              sizeof(LOGON_CACHE_ENTRY)     // DataLength
                              );

    return(NtStatus);
}


NTSTATUS
NlpEliminateCacheEntry(
    IN  ULONG               Index
    )

/*++

Routine Description:

    Delete the registry value and secret object related to a
    CTE entry.

Arguments:

    Index - The index of the entry whose value and secret are to
        be deleted.  This value is used only to build a name with
        (not to reference the CTE table).


Return Value:


--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    LSAPR_HANDLE
        SecretHandle;


    ValueName.Buffer = &NameBuffer[0];
    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    NlpMakeCacheEntryName( Index, &ValueName );

    NtStatus = I_LsarOpenSecret(NtLmGlobalPolicyHandle,
                             (PLSAPR_UNICODE_STRING) &ValueName,
                             DELETE,
                             &SecretHandle
                             );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Deleting and object causes its handle to be closed
        //

        NtStatus = I_LsarDelete( SecretHandle );
    }

    //
    // Now delete the registry value
    //

    NtStatus = NtDeleteValueKey( NlpCacheHandle, &ValueName );

    return(NtStatus);
}



NTSTATUS
NlpReadCacheEntryByIndex(
    IN  ULONG               Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG EntrySize
    )

/*++

Routine Description:

    Reads a cache entry from registry

Arguments:

    Index - CTE table index of the entry to open.
            This is used to build the entry's value and secret names.

    CacheEntry          - pointer to place to return pointer to LOGON_CACHE_ENTRY

    EntrySize           - size of returned LOGON_CACHE_ENTRY


Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *ppEntry points to allocated LOGON_CACHE_ENTRY
                    *EntrySize is size of returned data

        Failure = STATUS_NO_MEMORY
                    Couldn't allocate buffer for LOGON_CACHE_ENTRY

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    ULONG
        RequiredSize;

    PKEY_VALUE_FULL_INFORMATION
        RegInfo;

    PLOGON_CACHE_ENTRY
        RCacheEntry;   // CacheEntry in registry buffer

    BYTE FastBuffer[ 512 ];
    PBYTE SlowBuffer = NULL;

    ValueName.Buffer = &NameBuffer[0];
    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    NlpMakeCacheEntryName( Index, &ValueName );


    RegInfo = (PKEY_VALUE_FULL_INFORMATION)FastBuffer;
    RequiredSize = sizeof(FastBuffer);

    //
    // perform first query to find out how much buffer to allocate
    //

    NtStatus = NtQueryValueKey(NlpCacheHandle,
                               &ValueName,
                               KeyValueFullInformation,
                               (PVOID)RegInfo,
                               RequiredSize,
                               &RequiredSize
                               );

    if( (NtStatus == STATUS_BUFFER_TOO_SMALL) ||
        (NtStatus == STATUS_BUFFER_OVERFLOW) ) {

        //
        // allocate buffer then do query again, this time receiving data
        //

        SlowBuffer = (PBYTE)AllocateFromHeap(RequiredSize);
        if (SlowBuffer == NULL) {
            return(STATUS_NO_MEMORY);
        }

        RegInfo = (PKEY_VALUE_FULL_INFORMATION)SlowBuffer;

        NtStatus = NtQueryValueKey(NlpCacheHandle,
                                   &ValueName,
                                   KeyValueFullInformation,
                                   (PVOID)RegInfo,
                                   RequiredSize,
                                   &RequiredSize
                                   );
    }


    if (NT_SUCCESS(NtStatus)) {

#if DBG
        if (DumpCacheInfo) {
            DbgPrint("NlpReadCacheEntryByIndex: Index                  : %d\n"
                     "                          NtQueryValueKey returns: %d bytes\n"
                     "                                                      DataOffset=%d\n"
                     "                                                      DataLength=%d\n",
                    Index, RequiredSize, RegInfo->DataOffset, RegInfo->DataLength);
        }
#endif

        if( RegInfo->DataLength == 0 ) {
            NtStatus = STATUS_INTERNAL_DB_CORRUPTION;
            *CacheEntry = NULL;
            *EntrySize = 0;
        } else {

            RCacheEntry = (PLOGON_CACHE_ENTRY)((PCHAR)RegInfo + RegInfo->DataOffset);
            *EntrySize = RegInfo->DataLength;

            (*CacheEntry) = (PLOGON_CACHE_ENTRY)AllocateFromHeap( (*EntrySize) );
            if ((*CacheEntry) == NULL) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                RtlCopyMemory( (*CacheEntry),
                                RCacheEntry,
                                (*EntrySize) );

            }

        }
    }

    if ( SlowBuffer )
        FreeToHeap( SlowBuffer );

    return(NtStatus);
}


VOID
NlpAddEntryToActiveList(
    IN  ULONG   Index
    )

/*++

Routine Description:

    Place a CTE entry in the active CTE list.
    This requires placing the entry in the right location in
    the list chronologically.  The beginning of the list is
    the most recently updated (or referenced) cache entry.
    The end of the list is the oldest active cache entry.


    Note - The entry may be already in the active list (but
           in the wrong place), or may be on the inactive list.
           It will be removed from whichever list it is on.

Arguments:

    Index - CTE table index of the entry to make active..

Return Value:

    None.

--*/

{
    PNLP_CTE
        Next;

    //
    // Remove the entry from its current list, and then place it
    // in the active list.
    //

    RemoveEntryList( &NlpCteTable[Index].Link );

    //
    // Now walk the active list until we find a place to insert
    // the entry.  It must follow all entries with more recent
    // time stamps.
    //

    Next = (PNLP_CTE)NlpActiveCtes.Flink;

    while (Next != (PNLP_CTE)&NlpActiveCtes) {

        if ( NlpCteTable[Index].Time.QuadPart > Next->Time.QuadPart ) {

            //
            // More recent than this entry - add it here
            //

            break; // out of while-loop

        }

        Next = (PNLP_CTE)(Next->Link.Flink);  // Advance to next entry
    }


    //
    // Use the preceding entry as the list head.
    //

    InsertHeadList( Next->Link.Blink, &NlpCteTable[Index].Link );

    //
    // Mark the entry as valid
    //

    NlpCteTable[Index].Active = TRUE;

    return;
}


VOID
NlpAddEntryToInactiveList(
    IN  ULONG   Index
    )

/*++

Routine Description:

    Move the CTE entry to the inactive list.

    It doesn't matter if the entry is already inactive.

Arguments:

    Index - CTE table index of the entry to make inactive.

Return Value:

    None.

--*/

{
    //
    // Remove the entry from its current list, and then place it
    // in the inactive list.
    //

    RemoveEntryList( &NlpCteTable[Index].Link );
    InsertTailList( &NlpInactiveCtes, &NlpCteTable[Index].Link );


    //
    // Mark the entry as invalid
    //

    NlpCteTable[Index].Active = FALSE;

    return;
}


VOID
NlpGetFreeEntryIndex(
    OUT PULONG  Index
    )

/*++

Routine Description:

    This routine returns the index of either a free entry,
    or, lacking any free entries, the oldest active entry.

    The entry is left on the list it is already on.  If it
    is used by the caller, then the caller must ensure it is
    re-assigned to the active list (using NlpAddEntryToActiveList()).

    This routine is only callable if the cache is enabled (that is,
    NlpCacheControl.Entries != 0).

Arguments:

    Index - Receives the index of the next available entry.

Return Value:

    None.

--*/

{
    //
    // See if the Inactive list is empty.
    //

    if (NlpInactiveCtes.Flink != &NlpInactiveCtes) {
        (*Index) = ((PNLP_CTE)(NlpInactiveCtes.Flink))->Index;
    } else {

        //
        // Have to return the oldest active entry.
        //

        (*Index) = ((PNLP_CTE)(NlpActiveCtes.Blink))->Index;
    }

    return;
}

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//          Diagnostic support services                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// diagnostic dump routines
//

#if DBG

PCHAR
DumpOwfPasswordToString(
    OUT PCHAR Buffer,
    IN  PLM_OWF_PASSWORD Password
    )
{
    int i;
    PCHAR bufptr;

    for (i = 0, bufptr = Buffer; i < sizeof(*Password); ++i) {
        sprintf(bufptr, "%02.2x ", ((PCHAR)Password)[i] & 0xff);
        bufptr += 3;
    }
    return Buffer;
}


VOID
DumpLogonInfo(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo
    )
{

    DbgPrint(   "\n"
                "NETLOGON_INTERACTIVE_INFO:\n"
                "DomainName  : \"%*.*ws\"\n"
                "UserName    : \"%*.*ws\"\n"
                "Parm Ctrl   : %u (%x)\n"
                "LogonId     : %u.%u (%x.%x)\n"
                "Workstation : \"%*.*ws\"\n",
                LogonInfo->LogonDomainName.Length/sizeof(WCHAR),
                LogonInfo->LogonDomainName.Length/sizeof(WCHAR),
                LogonInfo->LogonDomainName.Buffer,
                LogonInfo->UserName.Length/sizeof(WCHAR),
                LogonInfo->UserName.Length/sizeof(WCHAR),
                LogonInfo->UserName.Buffer,
                LogonInfo->ParameterControl,
                LogonInfo->ParameterControl,
                LogonInfo->LogonId.HighPart,
                LogonInfo->LogonId.LowPart,
                LogonInfo->LogonId.HighPart,
                LogonInfo->LogonId.LowPart,
                LogonInfo->Workstation.Length/sizeof(WCHAR),
                LogonInfo->Workstation.Length/sizeof(WCHAR),
                LogonInfo->Workstation.Buffer
                );
}


char*
MapWeekday(
    IN  CSHORT  Weekday
    )
{
    switch (Weekday) {
    case 0: return "Sunday";
    case 1: return "Monday";
    case 2: return "Tuesday";
    case 3: return "Wednesday";
    case 4: return "Thursday";
    case 5: return "Friday";
    case 6: return "Saturday";
    }
    return "???";
}


VOID
DumpTime(
    IN  LPSTR   String,
    IN  POLD_LARGE_INTEGER OldTime
    )
{
    TIME_FIELDS tf;
    LARGE_INTEGER Time;

    OLD_TO_NEW_LARGE_INTEGER( (*OldTime), Time );

    RtlTimeToTimeFields(&Time, &tf);
    DbgPrint("%s%02d:%02d:%02d.%03d %02d/%02d/%d (%s [%d])\n",
            String,
            tf.Hour,
            tf.Minute,
            tf.Second,
            tf.Milliseconds,
            tf.Month,
            tf.Day,
            tf.Year,
            MapWeekday(tf.Weekday),
            tf.Weekday
            );
}


VOID
DumpGroupIds(
    IN  LPSTR   String,
    IN  ULONG   Count,
    IN  PGROUP_MEMBERSHIP GroupIds
    )
{
    DbgPrint(String);
    if (!Count) {
        DbgPrint("No group IDs!\n");
    } else {
        char tab[80];

        memset(tab, ' ', strlen(String));
//        tab[strcspn(String, "%")] = 0;
        tab[strlen(String)] = 0;
        while (Count--) {
            DbgPrint("%d, %d\n", GroupIds->RelativeId, GroupIds->Attributes);
            if (Count) {
                DbgPrint(tab);
            }
            ++GroupIds;
        }
    }
}


VOID
DumpSessKey(
    IN  LPSTR   String,
    IN  PUSER_SESSION_KEY Key
    )
{
    int     len;
    DbgPrint(String);
    DbgPrint("%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x\n",
            ((PUCHAR)&Key->data[0])[0],
            ((PUCHAR)&Key->data[0])[1],
            ((PUCHAR)&Key->data[0])[2],
            ((PUCHAR)&Key->data[0])[3],
            ((PUCHAR)&Key->data[0])[4],
            ((PUCHAR)&Key->data[0])[5],
            ((PUCHAR)&Key->data[0])[6],
            ((PUCHAR)&Key->data[0])[7]
            );
    len = (int) strlen(String);
    DbgPrint("%-*.*s", len, len, "");
    DbgPrint("%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x\n",
            ((PUCHAR)&Key->data[1])[0],
            ((PUCHAR)&Key->data[1])[1],
            ((PUCHAR)&Key->data[1])[2],
            ((PUCHAR)&Key->data[1])[3],
            ((PUCHAR)&Key->data[1])[4],
            ((PUCHAR)&Key->data[1])[5],
            ((PUCHAR)&Key->data[1])[6],
            ((PUCHAR)&Key->data[1])[7]
            );
}


VOID
DumpSid(
    LPSTR   String,
    PISID   Sid
    )
{
    DbgPrint(String);

    if ( Sid == NULL ) {
        DbgPrint(0, "(null)\n");
    } else {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("Invalid 0x%lX\n", Status );
        } else {
            DbgPrint( "%wZ\n", &SidString );
            RtlFreeUnicodeString( &SidString );
        }
    }
}


VOID
DumpAccountInfo(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo
    )
{
    DbgPrint(   "\n"
                "NETLOGON_VALIDATION_SAM_INFO:\n");

    DumpTime(   "LogonTime          : ", &AccountInfo->LogonTime);

    DumpTime(   "LogoffTime         : ", &AccountInfo->LogoffTime);

    DumpTime(   "KickOffTime        : ", &AccountInfo->KickOffTime);

    DumpTime(   "PasswordLastSet    : ", &AccountInfo->PasswordLastSet);

    DumpTime(   "PasswordCanChange  : ", &AccountInfo->PasswordCanChange);

    DumpTime(   "PasswordMustChange : ", &AccountInfo->PasswordMustChange);

    DbgPrint(   "EffectiveName      : \"%*.*ws\"\n"
                "Upn                : \"%*.*ws\"\n"
                "FullName           : \"%*.*ws\"\n"
                "LogonScript        : \"%*.*ws\"\n"
                "ProfilePath        : \"%*.*ws\"\n"
                "HomeDirectory      : \"%*.*ws\"\n"
                "HomeDirectoryDrive : \"%*.*ws\"\n"
                "LogonCount         : %d\n"
                "BadPasswordCount   : %d\n"
                "UserId             : %d\n"
                "PrimaryGroupId     : %d\n"
                "GroupCount         : %d\n",
                AccountInfo->EffectiveName.Length/sizeof(WCHAR),
                AccountInfo->EffectiveName.Length/sizeof(WCHAR),
                AccountInfo->EffectiveName.Buffer,
                AccountInfo->Upn.Length/sizeof(WCHAR),
                AccountInfo->Upn.Length/sizeof(WCHAR),
                AccountInfo->Upn.Buffer,
                AccountInfo->FullName.Length/sizeof(WCHAR),
                AccountInfo->FullName.Length/sizeof(WCHAR),
                AccountInfo->FullName.Buffer,
                AccountInfo->LogonScript.Length/sizeof(WCHAR),
                AccountInfo->LogonScript.Length/sizeof(WCHAR),
                AccountInfo->LogonScript.Buffer,
                AccountInfo->ProfilePath.Length/sizeof(WCHAR),
                AccountInfo->ProfilePath.Length/sizeof(WCHAR),
                AccountInfo->ProfilePath.Buffer,
                AccountInfo->HomeDirectory.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectory.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectory.Buffer,
                AccountInfo->HomeDirectoryDrive.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectoryDrive.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectoryDrive.Buffer,
                AccountInfo->LogonCount,
                AccountInfo->BadPasswordCount,
                AccountInfo->UserId,
                AccountInfo->PrimaryGroupId,
                AccountInfo->GroupCount
                );

    DumpGroupIds("GroupIds           : ",
                AccountInfo->GroupCount,
                AccountInfo->GroupIds
                );

    DbgPrint(   "UserFlags          : 0x%08x\n",
                AccountInfo->UserFlags
                );

    DumpSessKey("UserSessionKey     : ", &AccountInfo->UserSessionKey);

    DbgPrint(   "LogonServer        : \"%*.*ws\"\n"
                "LogonDomainName    : \"%*.*ws\"\n"
                "DnsLogonDomainName : \"%*.*ws\"\n",
                AccountInfo->LogonServer.Length/sizeof(WCHAR),
                AccountInfo->LogonServer.Length/sizeof(WCHAR),
                AccountInfo->LogonServer.Buffer,
                AccountInfo->LogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->LogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->LogonDomainName.Buffer,
                AccountInfo->DnsLogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->DnsLogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->DnsLogonDomainName.Buffer
                );

    DumpSid(    "LogonDomainId      : ", (PISID)AccountInfo->LogonDomainId);
}


VOID
DumpCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY pEntry
    )
{
    PUCHAR dataptr;
    ULONG length;

    DbgPrint(   "\n"
                "LOGON_CACHE_ENTRY:\n"
                "CTE Index          : %d\n", Index);

    if (pEntry->Valid != TRUE) {
        DbgPrint(   "State              : INVALID\n");
        return;
    }

    dataptr = (PUCHAR)(pEntry+1);

    length = pEntry->UserNameLength;

    DbgPrint(   "State              : VALID\n");
    DbgPrint(   "UserName           : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->DomainNameLength;
    DbgPrint(   "DomainName         : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->DnsDomainNameLength;
    DbgPrint(   "DnsDomainname      : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->UpnLength;
    DbgPrint(   "Upn                : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->EffectiveNameLength;
    DbgPrint(   "EffectiveName      : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->FullNameLength;
    DbgPrint(   "FullName           : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->LogonScriptLength;
    DbgPrint(   "LogonScript        : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->ProfilePathLength;
    DbgPrint(   "ProfilePath        : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->HomeDirectoryLength;
    DbgPrint(   "HomeDirectory      : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->HomeDirectoryDriveLength;
    DbgPrint(   "HomeDirectoryDrive : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    DbgPrint(   "UserId             : %d\n"
                "PrimaryGroupId     : %d\n"
                "GroupCount         : %d\n",
                pEntry->UserId,
                pEntry->PrimaryGroupId,
                pEntry->GroupCount
                );

    DumpGroupIds(
                "GroupIds           : ",
                pEntry->GroupCount,
                (PGROUP_MEMBERSHIP)dataptr
                );

    dataptr = ROUND_UP_POINTER((dataptr+pEntry->GroupCount * sizeof(GROUP_MEMBERSHIP)), sizeof(ULONG));

    length = pEntry->LogonDomainNameLength;
    DbgPrint(   "LogonDomainName    : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));


    if (pEntry->SidCount) {
        ULONG i, sidLength;
        PULONG SidAttributes = (PULONG) dataptr;

        dataptr = ROUND_UP_POINTER(dataptr + pEntry->SidCount * sizeof(ULONG), sizeof(ULONG));
        for (i = 0; i < pEntry->SidCount ; i++ ) {
            sidLength = RtlLengthSid ((PSID) dataptr);
            DumpSid("Sid    : ",(PISID) dataptr);
            DbgPrint("\tAttributes = 0x%x\n",SidAttributes[i]);
            dataptr = ROUND_UP_POINTER(dataptr + sidLength, sizeof(ULONG));
        }
    }

    DumpSid(    "LogonDomainId      : ", (PISID)dataptr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlvars.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nlvars.c

Abstract:

   This module contains variables used within the msv1_0 authentication
   package.

Author:

    Cliff Van Dyke (CliffV) 29-Apr-1991

Environment:

    User mode - msv1_0 authentication package DLL

Revision History:
  Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlvars.c

--*/

#include "msp.h"
#include "nlp.h"



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Null copies of Lanman and NT OWF password.
//

LM_OWF_PASSWORD NlpNullLmOwfPassword;
NT_OWF_PASSWORD NlpNullNtOwfPassword;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Define the list of active interactive logons.
//
// The NlpActiveLogonLock must be locked while referencing the list or
// any of its elements.
//

RTL_CRITICAL_SECTION NlpActiveLogonLock;
LIST_ENTRY NlpActiveLogonListAnchor;

//
// Define the running enumeration handle.
//
// This variable defines the enumeration handle to assign to a logon
//  session.  It will be incremented prior to assigning it value to
//  the next created logon session.  Access is serialize using
//  NlpActiveLogonLocks.

ULONG NlpEnumerationHandle;


//
// Define the number of successful/unsuccessful logons attempts.
//

ULONG NlpLogonAttemptCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlmain.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    nlmain.c

Abstract:

    This file contains the initialization and dispatch routines
    for the LAN Manager portions of the MSV1_0 authentication package.

Author:

    Jim Kelly 11-Apr-1991

Revision History:
    25-Apr-1991 (cliffv)
        Added interactive logon support for PDK.

    Chandana Surlu   21-Jul-1996
        Stolen from \\kernel\razzle3\src\security\msv1_0\nlmain.c

    JClark    28-Jun-2000
        Added WMI Trace Logging Support

--*/

#include <global.h>

#include "msp.h"
#undef EXTERN
#define NLP_ALLOCATE
#include "nlp.h"
#undef NLP_ALLOCATE

#include <lmsname.h>    // Service Names

#include <safeboot.h>

#include <confname.h>   // NETSETUPP_NETLOGON_JD_STOPPED

#include "nlpcache.h"   // logon cache prototypes

#include "trace.h" // wmi tracing goo

#include "msvwow.h"

NTSTATUS
NlpMapLogonDomain(
    OUT PUNICODE_STRING MappedDomain,
    IN PUNICODE_STRING LogonDomain
    );


NTSTATUS
NlInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize NETLOGON portion of msv1_0 authentication package.

Arguments:

    None.

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR ComputerName;
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    NT_PRODUCT_TYPE NtProductType;
    UNICODE_STRING TempUnicodeString;
    HKEY Key;
    int err;
    ULONG Size;
    ULONG Type;
    ULONG Value;

    //
    // Initialize global data
    //

    NlpEnumerationHandle = 0;
    NlpLogonAttemptCount = 0;


    NlpComputerName.Buffer = NULL;
    RtlInitUnicodeString( &NlpPrimaryDomainName, NULL );
    NlpSamDomainName.Buffer = NULL;
    NlpSamDomainId = NULL;
    NlpSamDomainHandle = NULL;

    //
    // Get the name of this machine.
    //

    ComputerName = I_NtLmAllocate(
                        ComputerNameLength * sizeof(WCHAR) );

    if (ComputerName == NULL ||
        !GetComputerNameW( ComputerName, &ComputerNameLength )) {

        SspPrint((SSP_MISC, "Cannot get computername %lX\n", GetLastError() ));

        NlpLanmanInstalled = FALSE;
        I_NtLmFree( ComputerName );
        ComputerName = NULL;
    } else {

        NlpLanmanInstalled = TRUE;
    }

    //
    // For Safe mode boot (minimal, no networking)
    // turn off the lanmaninstalled flag, since no network components will
    // be started.
    //

    err = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",
                0,
                KEY_READ,
                &Key );

    if ( err == ERROR_SUCCESS )
    {
        Value = 0 ;
        Size = sizeof( ULONG );

        err = RegQueryValueExW(
                    Key,
                    L"OptionValue",
                    0,
                    &Type,
                    (PUCHAR) &Value,
                    &Size );

        RegCloseKey( Key );

        if ( err == ERROR_SUCCESS )
        {
            NtLmGlobalSafeBoot = TRUE;

            if ( Value == SAFEBOOT_MINIMAL )
            {
                NlpLanmanInstalled = FALSE ;
            }
        }
    }

    RtlInitUnicodeString( &NlpComputerName, ComputerName );

    //
    // Determine if this machine is running Windows NT or Lanman NT.
    //  LanMan NT runs on a domain controller.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        SspPrint((SSP_MISC, "Nt Product Type undefined (WinNt assumed)\n" ));
        NtProductType = NtProductWinNt;
    }

    NlpWorkstation = (BOOLEAN)(NtProductType != NtProductLanManNt);

    InitializeListHead(&NlpActiveLogonListAnchor);

    //
    // Initialize any locks.
    //

    __try
    {
        RtlInitializeResource(&NlpActiveLogonLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( NT_SUCCESS(Status) );

    //
    // initialize the cache - creates a critical section is all
    //

    NlpCacheInitialize();


    //
    // Attempt to load Netlogon.dll
    //

    NlpLoadNetlogonDll();

#ifdef COMPILED_BY_DEVELOPER
    SspPrint((SSP_CRITICAL, "COMPILED_BY_DEVELOPER breakpoint.\n"));
    DbgBreakPoint();
#endif // COMPILED_BY_DEVELOPER

    //
    // Initialize useful encryption constants
    //

    Status = RtlCalculateLmOwfPassword( "", &NlpNullLmOwfPassword );
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(&TempUnicodeString, NULL);
    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                       &NlpNullNtOwfPassword);
    ASSERT( NT_SUCCESS(Status) );

    //
    // Initialize the SubAuthentication Dlls
    //

    Msv1_0SubAuthenticationInitialization();


#ifdef notdef
    //
    // If we weren't successful,
    //  Clean up global resources we intended to initialize.
    //

    if ( !NT_SUCCESS(Status) ) {
        if ( NlpComputerName.Buffer != NULL ) {
            MIDL_user_free( NlpComputerName.Buffer );
        }

    }
#endif // notdef

    return STATUS_SUCCESS;
}


NTSTATUS
NlWaitForEvent(
    LPWSTR EventName,
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for EventName to be triggered.

Arguments:

    EventName - Name of event to wait on

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;

    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;

    //
    // Create an event for us to wait on.
    //

    RtlInitUnicodeString( &EventNameString, EventName );
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL );

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if ( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );
        }
        if ( !NT_SUCCESS(Status)) {
            SspPrint((SSP_MISC, "OpenEvent failed %lx\n", Status ));
            return Status;
        }
    }

    //
    // Wait for NETLOGON to initialize.  Wait a maximum of Timeout seconds.
    //

    LocalTimeout.QuadPart = ((LONGLONG)(Timeout)) * (-10000000);
    Status = NtWaitForSingleObject( EventHandle, (BOOLEAN)FALSE, &LocalTimeout);
    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        if ( Status == STATUS_TIMEOUT ) {
            Status = STATUS_NETLOGON_NOT_STARTED;   // Map to an error condition
        }
        return Status;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
NlDoingSetup(
    VOID
    )

/*++

Routine Description:

    Returns TRUE if we're running setup.

Arguments:

    NONE.

Return Status:

    TRUE - We're currently running setup
    FALSE - We're not running setup or aren't sure.

--*/

{
    LONG RegStatus;

    HKEY KeyHandle = NULL;
    DWORD ValueType;
    DWORD Value;
    DWORD ValueSize;

    //
    // Open the key for HKLM\SYSTEM\Setup
    //

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    "SYSTEM\\Setup",
                    0,      //Reserved
                    KEY_QUERY_VALUE,
                    &KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        SspPrint((SSP_INIT, "NlDoingSetup: Cannot open registy key 'HKLM\\SYSTEM\\Setup' %ld.\n",
                  RegStatus ));
        return FALSE;
    }

    //
    // Get the value that says whether we're doing setup.
    //

    ValueSize = sizeof(Value);
    RegStatus = RegQueryValueExA(
                    KeyHandle,
                    "SystemSetupInProgress",
                    0,
                    &ValueType,
                    (LPBYTE)&Value,
                    &ValueSize );

    RegCloseKey( KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        SspPrint((SSP_INIT, "NlDoingSetup: Cannot query value of 'HKLM\\SYSTEM\\Setup\\SystemSetupInProgress' %ld.\n",
                  RegStatus ));
        return FALSE;
    }

    if ( ValueType != REG_DWORD ) {
        SspPrint((SSP_INIT, "NlDoingSetup: value of 'HKLM\\SYSTEM\\Setup\\SystemSetupInProgress'is not a REG_DWORD %ld.\n",
                  ValueType ));
        return FALSE;
    }

    if ( ValueSize != sizeof(Value) ) {
        SspPrint((SSP_INIT, "NlDoingSetup: value size of 'HKLM\\SYSTEM\\Setup\\SystemSetupInProgress'is not 4 %ld.\n",
                  ValueSize ));
        return FALSE;
    }

    if ( Value != 1 ) {
        // KdPrint(( "NlDoingSetup: not doing setup\n" ));
        return FALSE;
    }

    SspPrint((SSP_INIT, "NlDoingSetup: doing setup\n" ));
    return TRUE;

}


NTSTATUS
NlWaitForNetlogon(
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for the netlogon service to start.

Arguments:

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;


    //
    // If the netlogon service is currently running,
    //  skip the rest of the tests.
    //

    Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 0 );

    if ( NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // If we're in setup,
    //  don't bother waiting for netlogon to start.
    //

    if ( NlDoingSetup() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    //
    // Open a handle to the Netlogon Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        SspPrint((SSP_MISC, "NlWaitForNetlogon: OpenSCManager failed: "
                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_NETLOGON,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        SspPrint((SSP_MISC, "NlWaitForNetlogon: OpenService failed: "
                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    //
    // If the Netlogon service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            SspPrint((SSP_MISC, "NlWaitForNetlogon: QueryServiceConfig failed: "
                      "%lu\n", NetStatus));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        AllocServiceConfig = I_NtLmAllocate( ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            SspPrint((SSP_MISC, "NlWaitForNetlogon: QueryServiceConfig "
                      "failed again: %lu\n", GetLastError()));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType != SERVICE_AUTO_START ) {
        SspPrint((SSP_MISC, "NlWaitForNetlogon: Netlogon start type invalid:"
                          "%lu\n", ServiceConfig->dwStartType ));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    //
    // Loop waiting for the netlogon service to start.
    //  (Convert Timeout to a number of 10 second iterations)
    //

    Timeout = (Timeout+9)/10;
    for (;;) {


        //
        // Query the status of the Netlogon service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            SspPrint((SSP_MISC, "NlWaitForNetlogon: QueryServiceStatus failed: "
                          "%lu\n", GetLastError() ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the netlogon service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If Netlogon failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){

                SspPrint((SSP_MISC, "NlWaitForNetlogon: "
                          "Netlogon service couldn't start: %lu %lx\n",
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    SspPrint((SSP_MISC, "         Service specific error code: %lu %lx\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode ));
                }
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If Netlogon has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If Netlogon is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            SspPrint((SSP_MISC, "NlWaitForNetlogon: "
                      "Invalid service state: %lu\n",
                      ServiceStatus.dwCurrentState ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }

        //
        // Wait ten seconds for the netlogon service to start.
        //  If it has successfully started, just return now.
        //

        Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 10 );

        if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
            goto Cleanup;
        }

        //
        // If we've waited long enough for netlogon to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        I_NtLmFree( AllocServiceConfig );
    }
    return Status;
}


NTSTATUS
NlSamInitialize(
    ULONG Timeout
    )

/*++

Routine Description:

    Initialize the MSV1_0 Authentication Package's communication to the SAM
    database.  This initialization will take place once immediately prior
    to the first actual use of the SAM database.

Arguments:

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.

--*/

{
    NTSTATUS Status;

    //
    // locals that are staging area for globals.
    //

    UNICODE_STRING PrimaryDomainName;
    PSID SamDomainId = NULL;
    UNICODE_STRING SamDomainName;
    SAMPR_HANDLE SamDomainHandle = NULL;

    UNICODE_STRING DnsTreeName;

    PLSAPR_POLICY_INFORMATION PolicyPrimaryDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION PolicyAccountDomainInfo = NULL;

    SAMPR_HANDLE SamHandle = NULL;
#ifdef SAM
    PSAMPR_DOMAIN_INFO_BUFFER DomainInfo = NULL;
#endif // SAM

    PrimaryDomainName.Buffer = NULL;
    SamDomainName.Buffer = NULL;
    DnsTreeName.Buffer = NULL;

    //
    // Wait for SAM to finish initialization.
    //

    Status = NlWaitForEvent( L"\\SAM_SERVICE_STARTED", Timeout );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Determine the DomainName and DomainId of the Account Database
    //

    Status = I_LsarQueryInformationPolicy( NtLmGlobalPolicyHandle,
                                           PolicyAccountDomainInformation,
                                           &PolicyAccountDomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid == NULL ||
         PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainName.Length == 0 ) {
        SspPrint((SSP_MISC, "Account domain info from LSA invalid.\n"));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    Status = I_LsarQueryInformationPolicy(
                                NtLmGlobalPolicyHandle,
                                PolicyPrimaryDomainInformation,
                                &PolicyPrimaryDomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( PolicyPrimaryDomainInfo->PolicyPrimaryDomainInfo.Name.Length == 0 )
    {
        SspPrint((SSP_CRITICAL, "Primary domain info from LSA invalid.\n"));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // save PrimaryDomainName
    //

    PrimaryDomainName.Length = PolicyPrimaryDomainInfo->PolicyPrimaryDomainInfo.Name.Length;
    PrimaryDomainName.MaximumLength = PrimaryDomainName.Length;

    PrimaryDomainName.Buffer =
            (PWSTR)I_NtLmAllocate( PrimaryDomainName.MaximumLength );

    if ( PrimaryDomainName.Buffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( PrimaryDomainName.Buffer,
                    PolicyPrimaryDomainInfo->PolicyPrimaryDomainInfo.Name.Buffer,
                    PrimaryDomainName.Length );

    //
    // Save the domain id of this domain
    //

    SamDomainId = I_NtLmAllocate(
                        RtlLengthSid( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid )
                        );

    if ( SamDomainId == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( SamDomainId,
                   PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                   RtlLengthSid( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid ));

    //
    // Save the name of the account database on this machine.
    //
    // On a workstation, the account database is refered to by the machine
    // name and not the database name.

    // The above being true, the machine name is set to MACHINENAME during
    // setup and for the duration when the machine has a real machine name
    // until the end of setup, NlpSamDomainName will still have MACHINENAME.
    // This is not what the caller expects to authenticate against, so we
    // force a look from the Lsa all the time.

    // We assume that NlpSamDomainName will get the right info from the Lsa

    SamDomainName.Length = PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainName.Length;
    SamDomainName.MaximumLength = (USHORT)
        (SamDomainName.Length + sizeof(WCHAR));

    SamDomainName.Buffer =
        I_NtLmAllocate( SamDomainName.MaximumLength );

    if ( SamDomainName.Buffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( SamDomainName.Buffer,
                   PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainName.Buffer,
                   SamDomainName.MaximumLength );

    //
    // Open our connection with SAM
    //

    Status = I_SamIConnect( NULL,     // No server name
                            &SamHandle,
                            SAM_SERVER_CONNECT,
                            (BOOLEAN) TRUE );   // Indicate we are privileged

    if ( !NT_SUCCESS(Status) ) {
        SamHandle = NULL;
        SspPrint((SSP_CRITICAL, "Cannot SamIConnect %lX\n", Status));
        goto Cleanup;
    }

    //
    // Open the domain.
    //

    Status = I_SamrOpenDomain( SamHandle,
                               DOMAIN_ALL_ACCESS,
                               SamDomainId,
                               &SamDomainHandle );

    if ( !NT_SUCCESS(Status) ) {
        SamDomainHandle = NULL;
        SspPrint((SSP_CRITICAL, "Cannot SamrOpenDomain %lX\n", Status));
        goto Cleanup;
    }

    //
    // query the TreeName (since SAM was not up during package initialization)
    // update the various globals.
    //

    if( !NlpSamInitialized )
    {
        //
        // make the query before taking the exclusive lock, to avoid possible
        // deadlock conditions.
        //

        SsprQueryTreeName( &DnsTreeName );
    }

    Status = STATUS_SUCCESS;

    RtlAcquireResourceExclusive(&NtLmGlobalCritSect, TRUE);

    if( !NlpSamInitialized ) {

        NlpPrimaryDomainName = PrimaryDomainName;
        NlpSamDomainId = SamDomainId;
        NlpSamDomainName = SamDomainName;
        NlpSamDomainHandle = SamDomainHandle;

        if( NtLmGlobalUnicodeDnsTreeName.Buffer )
        {
            NtLmFree( NtLmGlobalUnicodeDnsTreeName.Buffer );
        }

        NtLmGlobalUnicodeDnsTreeName = DnsTreeName;
        SsprUpdateTargetInfo();

        NlpSamInitialized = TRUE;

        //
        // mark locals invalid so they don't get freed.
        //

        PrimaryDomainName.Buffer = NULL;
        SamDomainId = NULL;
        SamDomainName.Buffer = NULL;
        SamDomainHandle = NULL;
        DnsTreeName.Buffer = NULL;
    }

    RtlReleaseResource(&NtLmGlobalCritSect);

Cleanup:

    if( DnsTreeName.Buffer )
    {
        NtLmFree( DnsTreeName.Buffer );
    }

    if ( PrimaryDomainName.Buffer != NULL ) {
        I_NtLmFree( PrimaryDomainName.Buffer );
    }

    if ( SamDomainName.Buffer != NULL ) {
        I_NtLmFree( SamDomainName.Buffer );
    }

    if ( SamDomainHandle != NULL ) {
        (VOID) I_SamrCloseHandle( &SamDomainHandle );
    }

    if ( SamDomainId != NULL ) {
        I_NtLmFree( SamDomainId );
    }

    if ( PolicyAccountDomainInfo != NULL ) {
        I_LsaIFree_LSAPR_POLICY_INFORMATION( PolicyAccountDomainInformation,
                                             PolicyAccountDomainInfo );
    }

    if ( PolicyPrimaryDomainInfo != NULL ) {
        I_LsaIFree_LSAPR_POLICY_INFORMATION( PolicyPrimaryDomainInformation,
                                             PolicyPrimaryDomainInfo );
    }

    if ( SamHandle != NULL ) {
        (VOID) I_SamrCloseHandle( &SamHandle );
    }

    return Status;
}


NTSTATUS
MspLm20Challenge (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20ChallengeRequest.  It is called by
    the LanMan server to determine the Challenge to pass back to a
    redirector trying to establish a connection to the server.  The server
    is responsible remembering this Challenge and passing in back to this
    authentication package on a subsequent MsV1_0Lm20Logon request.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    PMSV1_0_LM20_CHALLENGE_REQUEST ChallengeRequest;
    PMSV1_0_LM20_CHALLENGE_RESPONSE ChallengeResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;


    UNREFERENCED_PARAMETER( ClientBufferBase );

    ASSERT( sizeof(LM_CHALLENGE) == MSV1_0_CHALLENGE_LENGTH );

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_LM20_CHALLENGE_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChallengeRequest = (PMSV1_0_LM20_CHALLENGE_REQUEST) ProtocolSubmitBuffer;

    ASSERT( ChallengeRequest->MessageType == MsV1_0Lm20ChallengeRequest );

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_LM20_CHALLENGE_RESPONSE);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_LM20_CHALLENGE_RESPONSE),
                                      *ReturnBufferSize );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ChallengeResponse = (PMSV1_0_LM20_CHALLENGE_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    ChallengeResponse->MessageType = MsV1_0Lm20ChallengeRequest;

    //
    // Compute a random seed.
    //

    Status = SspGenerateRandomBits(
                    ChallengeResponse->ChallengeToClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;

}


NTSTATUS
MspLm20GetChallengeResponse (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20GetChallengeResponse.  It is called by
    the LanMan redirector to determine the Challenge Response to pass to a
    server when trying to establish a connection to the server.

    This routine is passed a Challenge from the server.  This routine encrypts
    the challenge with either the specified password or with the password
    implied by the specified Logon Id.

    Two Challenge responses are returned.  One is based on the Unicode password
    as given to the Authentication package.  The other is based on that
    password converted to a multi-byte character set (e.g., ASCII) and upper
    cased.  The redirector should use whichever (or both) challenge responses
    as it needs them.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    PMSV1_0_GETCHALLENRESP_REQUEST GetRespRequest;

    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_GETCHALLENRESP_RESPONSE GetRespResponse;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    PMSV1_0_PRIMARY_CREDENTIAL PrimaryCredential = NULL;
    MSV1_0_PRIMARY_CREDENTIAL BuiltCredential = {0};

    //
    // Responses to return to the caller.
    //
    LM_RESPONSE LmResponse;
    STRING LmResponseString;

    NT_RESPONSE NtResponse;
    STRING NtResponseString;

    PMSV1_0_NTLM3_RESPONSE pNtlm3Response = NULL;

    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY UserSessionKey;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG NtLmProtocolSupported;

    //
    // Initialization
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    RtlInitUnicodeString( &UserName, NULL );
    RtlInitUnicodeString( &LogonDomainName, NULL );

    RtlZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
    RtlZeroMemory( LanmanSessionKey, sizeof(LanmanSessionKey) );

    //
    // If no credentials are associated with the client, a null session
    // will be used.  For a downlevel server, the null session response is
    // a 1-byte null string (\0).  Initialize LmResponseString to the
    // null session response.
    //

    RtlInitString( &LmResponseString, "" );
    LmResponseString.Length = 1;

    //
    // Initialize the NT response to the NT null session credentials,
    // which are zero length.
    //

    RtlInitString( &NtResponseString, NULL );

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_GETCHALLENRESP_REQUEST_V1) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GetRespRequest = (PMSV1_0_GETCHALLENRESP_REQUEST) ProtocolSubmitBuffer;

    ASSERT( GetRespRequest->MessageType == MsV1_0Lm20GetChallengeResponse );

    if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) == 0 ) {
        RELOCATE_ONE( &GetRespRequest->Password );
    }

    //
    // If we don't support the request (such as the caller is asking for an
    // LM challenge response and we do't support it, return an error here.
    //

    NtLmProtocolSupported = NtLmGlobalLmProtocolSupported;

    //
    // allow protocol to be downgraded to NTLM from NTLMv2 if so requested.
    //

    if ( (NtLmProtocolSupported >= UseNtlm3) 
         && (ClientRequest == (PLSA_CLIENT_REQUEST) -1) 
         && (GetRespRequest->ParameterControl & GCR_ALLOW_NTLM) )
    {
        NtLmProtocolSupported = NoLm;
    }

    if ( (GetRespRequest->ParameterControl & RETURN_NON_NT_USER_SESSION_KEY) 
         && (NtLmProtocolSupported >= NoLm) 
         // datagram can not negotiate, allow LM key
         && !( (ClientRequest == (PLSA_CLIENT_REQUEST) -1) 
               && (GetRespRequest->ParameterControl & GCR_ALLOW_LM) ) ) 
    {
        Status = STATUS_NOT_SUPPORTED;
        SspPrint((SSP_CRITICAL, 
            "MspLm20GetChallengeResponse: cannot do non NT user session key: "
            "ClientRequest %p, NtLmProtocolSupported %#x, ParameterControl %#x\n", 
            ClientRequest, NtLmProtocolSupported, GetRespRequest->ParameterControl));
        goto Cleanup;
    }

    if( GetRespRequest->ParameterControl & GCR_MACHINE_CREDENTIAL )
    {
        SECPKG_CLIENT_INFO ClientInfo;
        LUID SystemLuid = SYSTEM_LUID;

        //
        // if caller wants machine cred, check they are SYSTEM.
        // if so, whack the LogonId to point at the machine logon.
        //

        Status = LsaFunctions->GetClientInfo( &ClientInfo );

        if( !NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }

        if(!RtlEqualLuid( &ClientInfo.LogonId, &SystemLuid ))
        {
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        GetRespRequest->LogonId = NtLmGlobalLuidMachineLogon;
    }


    //
    // if caller wants NTLM++, so be it...
    //

    if ( (GetRespRequest->ParameterControl & GCR_NTLM3_PARMS) ) {
        PMSV1_0_AV_PAIR pAV;

        UCHAR TargetInfoBuffer[3*sizeof(MSV1_0_AV_PAIR) + (DNS_MAX_NAME_LENGTH+CNLEN+2)*sizeof(WCHAR)];

        NULL_RELOCATE_ONE( &GetRespRequest->UserName );
        NULL_RELOCATE_ONE( &GetRespRequest->LogonDomainName );
        NULL_RELOCATE_ONE( &GetRespRequest->ServerName );


        // if target is just a domain name or domain name followed by
        //  server name, make it into an AV pair list
        if (!(GetRespRequest->ParameterControl & GCR_TARGET_INFO)) {
            UNICODE_STRING DomainName;
            UNICODE_STRING ServerName = { 0, 0, NULL};
            unsigned int i;

            //
            // check length of name to make sure it fits in my buffer
            //

            if (GetRespRequest->ServerName.Length > (DNS_MAX_NAME_LENGTH+CNLEN+2)*sizeof(WCHAR)) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // init AV list in temp buffer
            //

            pAV = MsvpAvlInit(TargetInfoBuffer);

            //
            // see if there's a NULL in the middle of the server name
            //  that indicates that it's really a domain name followed by a server name
            //

            DomainName = GetRespRequest->ServerName;

            for (i = 0; i < (DomainName.Length/sizeof(WCHAR)); i++) {
                if ( DomainName.Buffer[i] == L'\0' )
                {
                    // take length of domain name without the NULL
                    DomainName.Length = (USHORT) i*sizeof(WCHAR);
                    // adjust server name and length to point after the domain name
                    ServerName.Length = (USHORT) (GetRespRequest->ServerName.Length - (i+1) * sizeof(WCHAR));
                    ServerName.Buffer = GetRespRequest->ServerName.Buffer + (i+1);
                    break;
                }
            }

            //
            // strip off possible trailing null after the server name
            //

            for (i = 0; i < (ServerName.Length / sizeof(WCHAR)); i++) {
                if (ServerName.Buffer[i] == L'\0')
                {
                    ServerName.Length = (USHORT)i*sizeof(WCHAR);
                    break;
                }
            }

            //
            // put both names in the AV list (if both exist)
            //

            MsvpAvlAdd(pAV, MsvAvNbDomainName, &DomainName, sizeof(TargetInfoBuffer));
            if (ServerName.Length > 0) {
                MsvpAvlAdd(pAV, MsvAvNbComputerName, &ServerName, sizeof(TargetInfoBuffer));
            }

            //
            // make the request point at AV list instead of names.
            //

            GetRespRequest->ServerName.Length = (USHORT)MsvpAvlLen(pAV, sizeof(TargetInfoBuffer));
            GetRespRequest->ServerName.Buffer = (PWCHAR)pAV;
        }

        //
        // if we're only using NTLMv2 or better, then complain if either
        //  computer name or server name missing
        //

        if (NtLmProtocolSupported >= RefuseNtlm3NoTarget) {
            pAV = (PMSV1_0_AV_PAIR)GetRespRequest->ServerName.Buffer;
            if ((pAV==NULL) ||
                MsvpAvlGet(pAV, MsvAvNbDomainName, GetRespRequest->ServerName.Length) == NULL ||
                MsvpAvlGet(pAV, MsvAvNbComputerName, GetRespRequest->ServerName.Length) == NULL) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }

    //
    // If the caller wants information from the credentials of a specified
    //  LogonId, get those credentials from the LSA.
    //
    // If there are no such credentials,
    //  tell the caller to use the NULL session.
    //

    if ( ((GetRespRequest->ParameterControl & PRIMARY_CREDENTIAL_NEEDED) != 0 ) && ((GetRespRequest->ParameterControl & NULL_SESSION_REQUESTED) == 0)) {
        Status = NlpGetPrimaryCredential(
                        &GetRespRequest->LogonId,
                        &PrimaryCredential,
                        NULL );

        if ( NT_SUCCESS(Status) ) {

            if ( GetRespRequest->ParameterControl & RETURN_PRIMARY_USERNAME ) {
                UserName = PrimaryCredential->UserName;
            }

            if ( GetRespRequest->ParameterControl &
                 RETURN_PRIMARY_LOGON_DOMAINNAME ) {

#ifndef DONT_MAP_DOMAIN_ON_REQUEST
                //
                // Map the user's logon domain against the current mapping
                // in the registry.
                //

                Status = NlpMapLogonDomain(
                            &LogonDomainName,
                            &PrimaryCredential->LogonDomainName
                            );
                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }
#else
                LogonDomainName = PrimaryCredential->LogonDomainName;
#endif
            }

        } else if ( Status == STATUS_NO_SUCH_LOGON_SESSION ||
                    Status == STATUS_UNSUCCESSFUL ) {

            //
            // Clean up the status code
            //

            Status = STATUS_NO_SUCH_LOGON_SESSION;

            //
            // If the caller wants at least the password from the primary
            //  credential, just use a NULL session primary credential.
            //

            if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD ) ==
                    USE_PRIMARY_PASSWORD ) {

                PrimaryCredential = NULL;

            //
            // If part of the information was supplied by the caller,
            //  report the error to the caller.
            //
            } else {
                SspPrint((SSP_CRITICAL, "MspLm20GetChallengeResponse: cannot "
                         " GetPrimaryCredential %lx\n", Status ));
                goto Cleanup;
            }
        } else {
                SspPrint((SSP_CRITICAL, "MspLm20GetChallengeResponse: cannot "
                         " GetPrimaryCredential %lx\n", Status ));
                goto Cleanup;
        }

        Credential = PrimaryCredential;
    }

    //
    // If the caller passed in a password to use,
    //  use it to build a credential.
    //

    if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) == 0 ) {

        NlpPutOwfsInPrimaryCredential( &(GetRespRequest->Password),
                                       (BOOLEAN) ((GetRespRequest->ParameterControl & GCR_USE_OWF_PASSWORD) != 0),
                                       &BuiltCredential );

        //
        // Use the newly allocated credential to get the password information
        // from.
        //
        Credential = &BuiltCredential;

    }

    //
    // Build the appropriate response.
    //

    if ( Credential != NULL ) {

        SspPrint((SSP_CRED, "MspLm20GetChallengeResponse: LogonId %#x:%#x, ParameterControl %#x, %wZ\\%wZ; Credential %wZ\\%wZ; %wZ\\%wZ\n", 
            GetRespRequest->LogonId.HighPart, GetRespRequest->LogonId.LowPart, GetRespRequest->ParameterControl,
            &GetRespRequest->LogonDomainName, &GetRespRequest->UserName, 
            &Credential->LogonDomainName, &Credential->UserName, 
            &LogonDomainName, &UserName));

        //
        // If the DC is asserted to have been upgraded, we should use NTLM3
        //  if caller supplies the NTLM3 parameters
        //

        if ((NtLmProtocolSupported >= UseNtlm3) &&
            (GetRespRequest->ParameterControl & GCR_NTLM3_PARMS)
            ) {

            USHORT Ntlm3ResponseSize;
            UNICODE_STRING Ntlm3UserName;
            UNICODE_STRING Ntlm3LogonDomainName;
            UNICODE_STRING Ntlm3ServerName;

            // use the server name supplied by the caller
            Ntlm3ServerName = GetRespRequest->ServerName;

            // even if user name and domain are supplied, use current logged
            //  in user if so requested

            if (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) {
                Ntlm3UserName = Credential->UserName;
                Ntlm3LogonDomainName = Credential->LogonDomainName;
            } else {
                Ntlm3UserName = GetRespRequest->UserName;
                Ntlm3LogonDomainName = GetRespRequest->LogonDomainName;
            }

            //
            // Allocate the response
            //

            Ntlm3ResponseSize =
                sizeof(MSV1_0_NTLM3_RESPONSE) + Ntlm3ServerName.Length;

            pNtlm3Response = (*Lsa.AllocatePrivateHeap)( Ntlm3ResponseSize );

            if ( pNtlm3Response == NULL ) {
                SspPrint((SSP_CRITICAL, "MspLm20GetChallengeResponse: No memory %ld\n",
                    Ntlm3ResponseSize ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Upcase LogonDomainName and UserName if outbound buffers use OEM
            // character set
            //

            if (GetRespRequest->ParameterControl & GCR_USE_OEM_SET) {
                Status = RtlUpcaseUnicodeString(&Ntlm3LogonDomainName, &Ntlm3LogonDomainName, FALSE);

                if (NT_SUCCESS(Status)) {
                    RtlUpcaseUnicodeString(&Ntlm3UserName, &Ntlm3UserName, FALSE);
                }

                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }
            }

            MsvpLm20GetNtlm3ChallengeResponse(
                &Credential->NtOwfPassword,
                &Ntlm3UserName,
                &Ntlm3LogonDomainName,
                &Ntlm3ServerName,
                GetRespRequest->ChallengeToClient,
                pNtlm3Response,
                (PMSV1_0_LM3_RESPONSE)&LmResponse,
                &UserSessionKey,
                (PLM_SESSION_KEY)LanmanSessionKey
                );

            NtResponseString.Buffer = (PCHAR) pNtlm3Response;
            NtResponseString.Length = Ntlm3ResponseSize;
            LmResponseString.Buffer = (PCHAR) &LmResponse;
            LmResponseString.Length = sizeof(LmResponse);
        } else {

            //
            // if requested, generate our own challenge, and mix it with that
            //  of the server's
            //

            if (GetRespRequest->ParameterControl & GENERATE_CLIENT_CHALLENGE) {

                Status = SspGenerateRandomBits(ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);

                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }

#ifdef USE_CONSTANT_CHALLENGE
                RtlZeroMemory(ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);
#endif

                RtlCopyMemory(
                    ChallengeToClient,
                    GetRespRequest->ChallengeToClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );

                MsvpCalculateNtlm2Challenge (
                    GetRespRequest->ChallengeToClient,
                    ChallengeFromClient,
                    GetRespRequest->ChallengeToClient
                    );

            }

            Status = RtlCalculateNtResponse(
                        (PNT_CHALLENGE) GetRespRequest->ChallengeToClient,
                        &Credential->NtOwfPassword,
                        &NtResponse );

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }


            //
            // send the client challenge back in the LM response slot if we made one
            //
            if (GetRespRequest->ParameterControl & GENERATE_CLIENT_CHALLENGE) {

                RtlZeroMemory(
                    &LmResponse,
                    sizeof(LmResponse)
                    );

                RtlCopyMemory(
                    &LmResponse,
                    ChallengeFromClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );
            //
            // Return the LM response if policy set that way for backwards compatibility.
            //

            } else if ((NtLmProtocolSupported <= AllowLm) ) {
                Status = RtlCalculateLmResponse(
                            (PLM_CHALLENGE) GetRespRequest->ChallengeToClient,
                            &Credential->LmOwfPassword,
                            &LmResponse );

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }

            //
            //
            //  Can't return LM response -- so use NT response
            //   (to allow LM_KEY generatation)
            //

            } else {
                RtlCopyMemory(
                        &LmResponse,
                        &NtResponse,
                        sizeof(LmResponse)
                        );
            }

            NtResponseString.Buffer = (PCHAR) &NtResponse;
            NtResponseString.Length = sizeof(NtResponse);
            LmResponseString.Buffer = (PCHAR) &LmResponse;
            LmResponseString.Length = sizeof(LmResponse);

            //
            // Compute the session keys
            //

            if (GetRespRequest->ParameterControl & GENERATE_CLIENT_CHALLENGE) {

                //
                // assert: we're talking to an NT4-SP4 or later server
                //          and the user's DC hasn't been upgraded to NTLM++
                //  generate session key from MD4(NT hash) -
                //  aka NtUserSessionKey - that is different for each session
                //

                Status = RtlCalculateUserSessionKeyNt(
                                &NtResponse,
                                &Credential->NtOwfPassword,
                                &UserSessionKey );

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }

                MsvpCalculateNtlm2SessionKeys(
                    &UserSessionKey,
                    ChallengeToClient,
                    ChallengeFromClient,
                    (PUSER_SESSION_KEY)&UserSessionKey,
                    (PLM_SESSION_KEY)LanmanSessionKey
                    );

            } else if ( GetRespRequest->ParameterControl & RETURN_NON_NT_USER_SESSION_KEY){

                //
                // If the redir didn't negotiate an NT protocol with the server,
                //  use the lanman session key.
                //

                if ( Credential->LmPasswordPresent ) {

                    ASSERT( sizeof(UserSessionKey) >= sizeof(LanmanSessionKey) );

                    RtlCopyMemory( &UserSessionKey,
                                   &Credential->LmOwfPassword,
                                   sizeof(LanmanSessionKey) );
                }

            } else {

                if ( !Credential->NtPasswordPresent ) {

                    RtlCopyMemory( &Credential->NtOwfPassword,
                                &NlpNullNtOwfPassword,
                                sizeof(Credential->NtOwfPassword) );
                }

                Status = RtlCalculateUserSessionKeyNt(
                                &NtResponse,
                                &Credential->NtOwfPassword,
                                &UserSessionKey );

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }
            }

            if ( Credential->LmPasswordPresent ) {
                RtlCopyMemory( LanmanSessionKey,
                               &Credential->LmOwfPassword,
                               sizeof(LanmanSessionKey) );
            }

        } // UseNtlm3
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_GETCHALLENRESP_RESPONSE) +
                        LogonDomainName.Length + sizeof(WCHAR) +
                        UserName.Length + sizeof(WCHAR) +
                        NtResponseString.Length + sizeof(WCHAR) +
                        LmResponseString.Length + sizeof(WCHAR);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_GETCHALLENRESP_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    GetRespResponse = (PMSV1_0_GETCHALLENRESP_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    GetRespResponse->MessageType = MsV1_0Lm20GetChallengeResponse;
    RtlCopyMemory( GetRespResponse->UserSessionKey,
                   &UserSessionKey,
                   sizeof(UserSessionKey));
    RtlCopyMemory( GetRespResponse->LanmanSessionKey,
                   LanmanSessionKey,
                   sizeof(LanmanSessionKey) );

    //
    // Copy the logon domain name (the string may be empty)
    //

    NlpPutClientString( &ClientBufferDesc,
                        &GetRespResponse->LogonDomainName,
                        &LogonDomainName );

    //
    // Copy the user name (the string may be empty)
    //

    NlpPutClientString( &ClientBufferDesc,
                        &GetRespResponse->UserName,
                        &UserName );

    //
    // Copy the Challenge Responses to the client buffer.
    //

    NlpPutClientString(
                &ClientBufferDesc,
                (PUNICODE_STRING)
                    &GetRespResponse->CaseSensitiveChallengeResponse,
                (PUNICODE_STRING) &NtResponseString );

    NlpPutClientString(
                &ClientBufferDesc,
                (PUNICODE_STRING)
                    &GetRespResponse->CaseInsensitiveChallengeResponse,
                (PUNICODE_STRING)&LmResponseString );

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Cleanup locally used resources
    //

    if ( PrimaryCredential != NULL ) {
        RtlZeroMemory(PrimaryCredential, sizeof(*PrimaryCredential));
        (*Lsa.FreeLsaHeap)( PrimaryCredential );
    }

#ifndef DONT_MAP_DOMAIN_ON_REQUEST

    if (LogonDomainName.Buffer != NULL) {
        NtLmFree(LogonDomainName.Buffer);
    }
#endif

    if ( pNtlm3Response != NULL ) {
        (*Lsa.FreePrivateHeap)( pNtlm3Response );
    }

    RtlSecureZeroMemory(&BuiltCredential, sizeof(BuiltCredential));

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


NTSTATUS
MspLm20EnumUsers (
    IN PLSA_CLIENT_REQUEST pClientRequest,
    IN PVOID pProtocolSubmitBuffer,
    IN PVOID pClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID* ppProtocolReturnBuffer,
    OUT PULONG pReturnBufferSize,
    OUT PNTSTATUS pProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20EnumerateUsers.  This routine
    enumerates all of the interactive, service, and batch logons to the MSV1_0
    authentication package.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    NTSTATUS Status;

    PMSV1_0_ENUMUSERS_REQUEST pEnumRequest = NULL;
    PMSV1_0_ENUMUSERS_RESPONSE pEnumResponse = NULL;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    ULONG LogonCount = 0;
    BOOLEAN bActiveLogonsAreLocked = FALSE;

    PUCHAR pWhere;
    LIST_ENTRY* pScan = NULL;
    ACTIVE_LOGON* pActiveLogon = NULL;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    NlpInitClientBuffer( &ClientBufferDesc, pClientRequest );
    UNREFERENCED_PARAMETER( pClientBufferBase );

    if ( SubmitBufferSize < sizeof(MSV1_0_ENUMUSERS_REQUEST) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pEnumRequest = (PMSV1_0_ENUMUSERS_REQUEST) pProtocolSubmitBuffer;

    ASSERT( pEnumRequest->MessageType == MsV1_0EnumerateUsers );

    //
    // Count the current number of active logons
    //

    NlpLockActiveLogonsRead();
    bActiveLogonsAreLocked = TRUE;

    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);

        //
        // don't count the machine account logon.
        //

        if ( RtlEqualLuid(&NtLmGlobalLuidMachineLogon, &pActiveLogon->LogonId) )
        {
            continue;
        }

        LogonCount ++;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *pReturnBufferSize = sizeof(MSV1_0_ENUMUSERS_RESPONSE) +
                            LogonCount * (sizeof(LUID) + sizeof(ULONG));


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_ENUMUSERS_RESPONSE),
                                      *pReturnBufferSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup;
    }

    pEnumResponse = (PMSV1_0_ENUMUSERS_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    pEnumResponse->MessageType = MsV1_0EnumerateUsers;
    pEnumResponse->NumberOfLoggedOnUsers = LogonCount;

    pWhere = (PUCHAR)(pEnumResponse + 1);

    //
    // Loop through the Active Logon Table copying the LogonId of each session.
    //

    pEnumResponse->LogonIds = (PLUID) (ClientBufferDesc.UserBuffer +
                                (pWhere - ClientBufferDesc.MsvBuffer));
    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);

        //
        // don't count the machine account logon.
        //

        if ( RtlEqualLuid(&NtLmGlobalLuidMachineLogon, &pActiveLogon->LogonId) )
        {
            continue;
        }

        *((PLUID)pWhere) = pActiveLogon->LogonId,
        pWhere += sizeof(LUID);
    }

    //
    // Loop through the Active Logon Table copying the EnumHandle of
    //  each session.
    //

    pEnumResponse->EnumHandles = (PULONG)(ClientBufferDesc.UserBuffer +
                                    (pWhere - ClientBufferDesc.MsvBuffer));
    for ( pScan = NlpActiveLogonListAnchor.Flink;
         pScan != &NlpActiveLogonListAnchor;
         pScan = pScan->Flink )
    {
        pActiveLogon = CONTAINING_RECORD(pScan, ACTIVE_LOGON, ListEntry);

        //
        // don't count the machine account logon.
        //

        if ( RtlEqualLuid(&NtLmGlobalLuidMachineLogon, &pActiveLogon->LogonId) )
        {
            continue;
        }

        *((PULONG)pWhere) = pActiveLogon->EnumHandle,
        pWhere += sizeof(ULONG);
    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ppProtocolReturnBuffer );

Cleanup:

    //
    // Be sure to unlock the lock on the Active logon list.
    //

    if ( bActiveLogonsAreLocked )
    {
        NlpUnlockActiveLogons();
    }

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) )
    {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Return status to the caller.
    //

    *pProtocolStatus = Status;
    return STATUS_SUCCESS;
}


NTSTATUS
MspLm20GetUserInfo (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0GetUserInfo.  This routine
    returns information describing a particular Logon Id.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;

    PMSV1_0_GETUSERINFO_REQUEST pGetInfoRequest;
    PMSV1_0_GETUSERINFO_RESPONSE pGetInfoResponse = NULL;

    CLIENT_BUFFER_DESC ClientBufferDesc;

    BOOLEAN bActiveLogonsAreLocked = FALSE;
    PACTIVE_LOGON pActiveLogon = NULL;
    ULONG SidLength;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    UNREFERENCED_PARAMETER( ClientBufferBase );

    if ( SubmitBufferSize < sizeof(MSV1_0_GETUSERINFO_REQUEST) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pGetInfoRequest = (PMSV1_0_GETUSERINFO_REQUEST) ProtocolSubmitBuffer;

    ASSERT( pGetInfoRequest->MessageType == MsV1_0GetUserInfo );

    //
    // Find the Active logon entry for this particular Logon Id.
    //

    NlpLockActiveLogonsRead();
    bActiveLogonsAreLocked = TRUE;

    pActiveLogon = NlpFindActiveLogon( &pGetInfoRequest->LogonId );

    if (!pActiveLogon)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    SidLength = RtlLengthSid( pActiveLogon->UserSid );
    *ReturnBufferSize = sizeof(MSV1_0_GETUSERINFO_RESPONSE) +
                            pActiveLogon->UserName.Length + sizeof(WCHAR) +
                            pActiveLogon->LogonDomainName.Length + sizeof(WCHAR) +
                            pActiveLogon->LogonServer.Length + sizeof(WCHAR) +
                            SidLength;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_GETUSERINFO_RESPONSE),
                                      *ReturnBufferSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup;
    }

    pGetInfoResponse = (PMSV1_0_GETUSERINFO_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    pGetInfoResponse->MessageType = MsV1_0GetUserInfo;
    pGetInfoResponse->LogonType = pActiveLogon->LogonType;

    //
    // Copy ULONG aligned data first
    //

    pGetInfoResponse->UserSid = ClientBufferDesc.UserBuffer +
                               ClientBufferDesc.StringOffset;

    RtlCopyMemory( ClientBufferDesc.MsvBuffer + ClientBufferDesc.StringOffset,
                   pActiveLogon->UserSid,
                   SidLength );

    ClientBufferDesc.StringOffset += SidLength;

    //
    // Copy WCHAR aligned data
    //

    NlpPutClientString( &ClientBufferDesc,
                        &pGetInfoResponse->UserName,
                        &pActiveLogon->UserName );

    NlpPutClientString( &ClientBufferDesc,
                        &pGetInfoResponse->LogonDomainName,
                        &pActiveLogon->LogonDomainName );

    NlpPutClientString( &ClientBufferDesc,
                        &pGetInfoResponse->LogonServer,
                        &pActiveLogon->LogonServer );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    //
    // Be sure to unlock the lock on the Active logon list.
    //

    if ( bActiveLogonsAreLocked )
    {
        NlpUnlockActiveLogons();
    }

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status))
    {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;

}


NTSTATUS
MspLm20ReLogonUsers (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0RelogonUsers.  For each logon session
    which was validated by the specified domain controller,  the logon session
    is re-established with that same domain controller.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{
    UNREFERENCED_PARAMETER( ClientRequest );
    UNREFERENCED_PARAMETER( ProtocolSubmitBuffer);
    UNREFERENCED_PARAMETER( ClientBufferBase);
    UNREFERENCED_PARAMETER( SubmitBufferSize);
    UNREFERENCED_PARAMETER( ReturnBufferSize);

    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_NOT_IMPLEMENTED;
    return STATUS_SUCCESS;

}


NTSTATUS
MspLm20GenericPassthrough (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20GenericPassthrough. It is called by
    a client wishing to make a CallAuthenticationPackage call against
    a domain controller.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    BOOLEAN Authoritative;
    PNETLOGON_VALIDATION_GENERIC_INFO ValidationGeneric = NULL;

    NETLOGON_GENERIC_INFO LogonGeneric;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInformation;

    //
    // WMI tracing helper struct
    //
    NTLM_TRACE_INFO TraceInfo = {0};

    //
    // Begin tracing a logon user
    //
    if (NtlmGlobalEventTraceFlag) {

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmGenericPassthroughGuid,
                         EVENT_TRACE_TYPE_START,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    *ProtocolStatus = STATUS_SUCCESS;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_PASSTHROUGH_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    PassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) ProtocolSubmitBuffer;

    RELOCATE_ONE( &PassthroughRequest->DomainName );
    RELOCATE_ONE( &PassthroughRequest->PackageName );

    //
    // Make sure the buffer fits in the supplied size
    //

    if (PassthroughRequest->LogonData != NULL) {

        if (PassthroughRequest->LogonData + PassthroughRequest->DataLength <
            PassthroughRequest->LogonData ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ((ULONG_PTR)ClientBufferBase + SubmitBufferSize < (ULONG_PTR)ClientBufferBase ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (PassthroughRequest->LogonData + PassthroughRequest->DataLength >
            (PUCHAR) ClientBufferBase + SubmitBufferSize) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Reset the pointers for the validation data
        //

        PassthroughRequest->LogonData =
                (PUCHAR) PassthroughRequest -
                (ULONG_PTR) ClientBufferBase +
                (ULONG_PTR) PassthroughRequest->LogonData;

    }

    //
    // Build the structure to pass to Netlogon
    //

    RtlZeroMemory(
        &LogonGeneric,
        sizeof(LogonGeneric)
        );

    LogonGeneric.Identity.LogonDomainName = PassthroughRequest->DomainName;
    LogonGeneric.PackageName = PassthroughRequest->PackageName;
    LogonGeneric.LogonData = PassthroughRequest->LogonData;
    LogonGeneric.DataLength = PassthroughRequest->DataLength;

    LogonInformation =
        (PNETLOGON_LOGON_IDENTITY_INFO) &LogonGeneric;

    //
    // Call Netlogon to remote the request
    //

    //
    // Wait for NETLOGON to finish initialization.
    //

    if ( !NlpNetlogonInitialized ) {

        Status = NlWaitForNetlogon( NETLOGON_STARTUP_TIME );

        if ( !NT_SUCCESS(Status) ) {
            if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
                goto Cleanup;
            }
        } else {

            NlpNetlogonInitialized = TRUE;
        }
    }

    if ( NlpNetlogonInitialized ) {

        //
        // Trace the domain name and package name
        //
        if (NtlmGlobalEventTraceFlag){

            //Header goo
            SET_TRACE_HEADER(TraceInfo,
                             NtlmGenericPassthroughGuid,
                             EVENT_TRACE_TYPE_INFO,
                             WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                             4);

            SET_TRACE_USTRING(TraceInfo,
                              TRACE_PASSTHROUGH_DOMAIN,
                              LogonGeneric.Identity.LogonDomainName);

            SET_TRACE_USTRING(TraceInfo,
                              TRACE_PASSTHROUGH_PACKAGE,
                              LogonGeneric.PackageName);

            TraceEvent(
                NtlmGlobalTraceLoggerHandle,
                (PEVENT_TRACE_HEADER)&TraceInfo
                );
        }

        Status = (*NlpNetLogonSamLogon)(
                    NULL,           // Server name
                    NULL,           // Computer name
                    NULL,           // Authenticator
                    NULL,           // ReturnAuthenticator
                    NetlogonGenericInformation,
                    (LPBYTE) &LogonInformation,
                    NetlogonValidationGenericInfo2,
                    (LPBYTE *) &ValidationGeneric,
                    &Authoritative );

        //
        // Reset Netlogon initialized flag if local netlogon cannot be
        //  reached.
        //  (Use a more explicit status code)
        //

        if ( Status == RPC_NT_SERVER_UNAVAILABLE ||
             Status == RPC_NT_UNKNOWN_IF ||
             Status == STATUS_NETLOGON_NOT_STARTED ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            NlpNetlogonInitialized = FALSE;
        }
    } else {

        //
        // no netlogon: see if the request is destined for the local domain,
        // to allow WORKGROUP support.
        //

        if (  LogonInformation->LogonDomainName.Length == 0 ||
             (LogonInformation->LogonDomainName.Length != 0 &&
              RtlEqualDomainName( &NlpSamDomainName,
                                     &LogonInformation->LogonDomainName ) )
            ) {


            PNETLOGON_GENERIC_INFO GenericInfo;
            NETLOGON_VALIDATION_GENERIC_INFO GenericValidation;
            NTSTATUS ProtocolStatus;

            GenericInfo = (PNETLOGON_GENERIC_INFO) LogonInformation;
            GenericValidation.ValidationData = NULL;
            GenericValidation.DataLength = 0;

            //
            // unwrap passthrough message and pass it off to dispatch.
            //

            Status = LsaICallPackagePassthrough(
                        &GenericInfo->PackageName,
                        0,  // Indicate pointers are relative.
                        GenericInfo->LogonData,
                        GenericInfo->DataLength,
                        (PVOID *) &GenericValidation.ValidationData,
                        &GenericValidation.DataLength,
                        &ProtocolStatus
                        );

            if (NT_SUCCESS( Status ) )
                Status = ProtocolStatus;

            //
            // If the call succeeded, allocate the return message.
            //

            if (NT_SUCCESS(Status)) {
                PNETLOGON_VALIDATION_GENERIC_INFO ReturnInfo;
                ULONG ValidationLength;

                ValidationLength = sizeof(*ReturnInfo) + GenericValidation.DataLength;

                ReturnInfo = (PNETLOGON_VALIDATION_GENERIC_INFO) MIDL_user_allocate(
                                ValidationLength
                                );

                if (ReturnInfo != NULL) {
                    if ( GenericValidation.DataLength == 0 ||
                         GenericValidation.ValidationData == NULL ) {
                        ReturnInfo->DataLength = 0;
                        ReturnInfo->ValidationData = NULL;
                    } else {

                        ReturnInfo->DataLength = GenericValidation.DataLength;
                        ReturnInfo->ValidationData = (PUCHAR) (ReturnInfo + 1);

                        RtlCopyMemory(
                            ReturnInfo->ValidationData,
                            GenericValidation.ValidationData,
                            ReturnInfo->DataLength );

                    }

                    ValidationGeneric = ReturnInfo;

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (GenericValidation.ValidationData != NULL) {
                    LsaIFreeReturnBuffer(GenericValidation.ValidationData);
                }
            }
        } else {
            Status = STATUS_NETLOGON_NOT_STARTED;
        }
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_PASSTHROUGH_RESPONSE) +
                        ValidationGeneric->DataLength;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_PASSTHROUGH_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    PassthroughResponse = (PMSV1_0_PASSTHROUGH_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    PassthroughResponse->MessageType = MsV1_0GenericPassthrough;
    PassthroughResponse->DataLength = ValidationGeneric->DataLength;
    PassthroughResponse->ValidationData = ClientBufferDesc.UserBuffer + sizeof(MSV1_0_PASSTHROUGH_RESPONSE);


    RtlCopyMemory(
        PassthroughResponse + 1,
        ValidationGeneric->ValidationData,
        ValidationGeneric->DataLength
        );

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if (ValidationGeneric != NULL) {
        MIDL_user_free(ValidationGeneric);
    }

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    if (NtlmGlobalEventTraceFlag){

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmGenericPassthroughGuid,
                         EVENT_TRACE_TYPE_END,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);

}


NTSTATUS
MspLm20CacheLogon (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20CacheLogon. It is called by
    a client wishing to cache logon information in the logon cache

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PMSV1_0_CACHE_LOGON_REQUEST CacheRequest;

    PNETLOGON_INTERACTIVE_INFO LogonInfo;
    NETLOGON_VALIDATION_SAM_INFO4 ValidationInfo;

    PVOID SupplementalCacheData = NULL;
    ULONG SupplementalCacheDataLength = 0;
    ULONG CacheRequestFlags = 0;

    //
    // NOTE: this entry point only allows callers within the LSA process
    //

    if (ClientRequest != NULL) {
        *ProtocolStatus = STATUS_ACCESS_DENIED;
        return(STATUS_SUCCESS);
    }

    CacheRequest = (PMSV1_0_CACHE_LOGON_REQUEST) ProtocolSubmitBuffer;

    if ( SubmitBufferSize <= sizeof( MSV1_0_CACHE_LOGON_REQUEST_OLD ) ||
         SubmitBufferSize > sizeof( MSV1_0_CACHE_LOGON_REQUEST ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( SubmitBufferSize >= sizeof( MSV1_0_CACHE_LOGON_REQUEST_W2K ))
    {
        SupplementalCacheData = CacheRequest->SupplementalCacheData;
        SupplementalCacheDataLength = CacheRequest->SupplementalCacheDataLength;

        if ( SubmitBufferSize == sizeof( MSV1_0_CACHE_LOGON_REQUEST ))
        {
            CacheRequestFlags = CacheRequest->RequestFlags;
        }
    }

    LogonInfo = (PNETLOGON_INTERACTIVE_INFO) CacheRequest->LogonInformation;

    if( (CacheRequestFlags & MSV1_0_CACHE_LOGON_REQUEST_INFO4) == 0 )
    {
        RtlZeroMemory( &ValidationInfo, sizeof(ValidationInfo));
        RtlCopyMemory( &ValidationInfo,
                       CacheRequest->ValidationInformation,
                       sizeof(NETLOGON_VALIDATION_SAM_INFO2) );
    } else {
        RtlCopyMemory( &ValidationInfo,
                       CacheRequest->ValidationInformation,
                       sizeof(NETLOGON_VALIDATION_SAM_INFO4) );
    }

    *ProtocolStatus = STATUS_SUCCESS;

    if (( CacheRequestFlags & MSV1_0_CACHE_LOGON_DELETE_ENTRY) != 0 )
    {
        *ProtocolStatus = NlpDeleteCacheEntry(
                            0, // no reason supplied, most likely this is STATUS_ACCOUNT_DISABLED
                            (USHORT) -1, // authoritative and indicates this is from CallAuthPackage
                            0, // no logon type supplied
                            FALSE,  // not invalidated by NTLM
                            LogonInfo 
                            );
    }
    else
    //
    // Actually add the cache entry
    //
    {
        *ProtocolStatus = NlpAddCacheEntry(
                                LogonInfo,
                                &ValidationInfo,
                                SupplementalCacheData,
                                SupplementalCacheDataLength,
                                CacheRequestFlags
                                );

    }

Cleanup:

    return (STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( ClientRequest);
    UNREFERENCED_PARAMETER( ProtocolReturnBuffer);
    UNREFERENCED_PARAMETER( ClientBufferBase);
    UNREFERENCED_PARAMETER( ReturnBufferSize);
}


NTSTATUS
MspLm20CacheLookup (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20CacheLookup. It is called by
    a client wishing to extract cache logon information and optionally
    verify the credential.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_CACHE_LOOKUP_REQUEST CacheRequest;
    PMSV1_0_CACHE_LOOKUP_RESPONSE CacheResponse;
    NETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo = NULL;
    CACHE_PASSWORDS cachePasswords;
    CLIENT_BUFFER_DESC ClientBufferDesc;

    PNT_OWF_PASSWORD pNtOwfPassword = NULL;
    NT_OWF_PASSWORD ComputedNtOwfPassword;

    PVOID SupplementalCacheData = NULL;
    ULONG SupplementalCacheDataLength;

    //
    // Ensure the client is from the LSA process
    //

    if (ClientRequest != NULL) {
        *ProtocolStatus = STATUS_ACCESS_DENIED;
        return(STATUS_SUCCESS);
    }

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProtocolStatus = STATUS_SUCCESS;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_CACHE_LOOKUP_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    CacheRequest = (PMSV1_0_CACHE_LOOKUP_REQUEST) ProtocolSubmitBuffer;
    RtlZeroMemory(
        &LogonInfo,
        sizeof(LogonInfo)
        );

    //
    // NOTE: this submit call only supports in-process calls within the LSA
    // so buffers within the submit buffer are assumed to be valid and
    // hence not validated in the same way that out-proc calls are.
    //

    LogonInfo.LogonDomainName = CacheRequest->DomainName;
    LogonInfo.UserName = CacheRequest->UserName;

    if( CacheRequest->CredentialType != MSV1_0_CACHE_LOOKUP_CREDTYPE_NONE &&
        CacheRequest->CredentialType != MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW &&
        CacheRequest->CredentialType != MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // get the cache entry
    //

    *ProtocolStatus = NlpGetCacheEntry(
                        &LogonInfo,
                        MSV1_0_CACHE_LOGON_REQUEST_SMARTCARD_ONLY, // allow smartcard only cache entry
                        NULL, // no need for credentials domain name
                        NULL, // no need for credentials user name
                        &ValidationInfo,
                        &cachePasswords,
                        &SupplementalCacheData,
                        &SupplementalCacheDataLength
                        );

    if (!NT_SUCCESS(*ProtocolStatus)) {
        goto Cleanup;
    }

    if( CacheRequest->CredentialType == MSV1_0_CACHE_LOOKUP_CREDTYPE_NONE ) {
        if( CacheRequest->CredentialInfoLength != 0 ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    //
    // verify the password, if necessary.
    //

    if ( CacheRequest->CredentialType == MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW ) {

        //
        // convert RAW to NTOWF.
        //

        UNICODE_STRING TempPassword;

        if ( CacheRequest->CredentialInfoLength > 0xFFFF ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TempPassword.Buffer = (PWSTR)&CacheRequest->CredentialSubmitBuffer;
        TempPassword.Length = (USHORT)CacheRequest->CredentialInfoLength;
        TempPassword.MaximumLength = TempPassword.Length;

        pNtOwfPassword = &ComputedNtOwfPassword;

        Status = RtlCalculateNtOwfPassword( &TempPassword, pNtOwfPassword );

        if( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        //
        // now, convert the request to NT_OWF style.
        //

        CacheRequest->CredentialType = MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF;
        CacheRequest->CredentialInfoLength = sizeof( NT_OWF_PASSWORD );
    }

    if ( CacheRequest->CredentialType == MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF ) {
        if( CacheRequest->CredentialInfoLength != sizeof( NT_OWF_PASSWORD ) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( !cachePasswords.SecretPasswords.NtPasswordPresent ) {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        if( pNtOwfPassword == NULL ) {
            pNtOwfPassword = (PNT_OWF_PASSWORD)&CacheRequest->CredentialSubmitBuffer;
        }

        Status = NlpComputeSaltedHashedPassword(
                    pNtOwfPassword,
                    pNtOwfPassword,
                    &ValidationInfo->EffectiveName
                    );

        if (!NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        if (RtlCompareMemory(
                    pNtOwfPassword,
                    &cachePasswords.SecretPasswords.NtOwfPassword,
                    sizeof( NT_OWF_PASSWORD )
                    ) != sizeof(NT_OWF_PASSWORD) )
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }

    //
    // Return the validation info here.
    //

    *ReturnBufferSize = sizeof(MSV1_0_CACHE_LOOKUP_RESPONSE);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_CACHE_LOOKUP_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    CacheResponse = (PMSV1_0_CACHE_LOOKUP_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    CacheResponse->MessageType = MsV1_0CacheLookup;
    CacheResponse->ValidationInformation = ValidationInfo;

    CacheResponse->SupplementalCacheData = SupplementalCacheData;
    CacheResponse->SupplementalCacheDataLength = SupplementalCacheDataLength;

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );

        if (ValidationInfo != NULL) {
            MIDL_user_free( ValidationInfo );
        }

        if (SupplementalCacheData != NULL) {
            MIDL_user_free( SupplementalCacheData );
        }
    }

    RtlSecureZeroMemory( &ComputedNtOwfPassword, sizeof( ComputedNtOwfPassword ) );
    RtlSecureZeroMemory( &cachePasswords, sizeof(cachePasswords) );

    return(STATUS_SUCCESS);
    UNREFERENCED_PARAMETER( ClientBufferBase);

}

NTSTATUS
MspSetProcessOption(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0SetProcessOption.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_SETPROCESSOPTION_REQUEST SetProcessOptionRequest;

    *ProtocolStatus = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(ClientBufferBase);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(ProtocolReturnBuffer);
    UNREFERENCED_PARAMETER(ClientRequest);

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_SETPROCESSOPTION_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    SetProcessOptionRequest = (PMSV1_0_SETPROCESSOPTION_REQUEST) ProtocolSubmitBuffer;

    if( NtLmSetProcessOption(
                            SetProcessOptionRequest->ProcessOptions,
                            SetProcessOptionRequest->DisableOptions
                            ) )
    {
        *ProtocolStatus = STATUS_SUCCESS;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return(Status);
}


NTSTATUS
LsaApLogonUserEx2 (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * SupplementalCredentials
    )

/*++

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    the user's initial logon.  A new LSA logon session will be established
    for the user and validation information for the user will be returned.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    LogonType - Identifies the type of logon being attempted.

    ProtocolSubmitBuffer - Supplies the authentication
        information specific to the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the authentication information was resident.
        This may be necessary to fix-up any pointers within the
        authentication information buffer.

    SubmitBufferSize - Indicates the Size, in bytes,
        of the authentication information buffer.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  The authentication package is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the LSA subsequently
        encounters an error which prevents a successful logon, then
        the LSA will take care of deallocating that buffer.  This
        buffer is expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    SubStatus - If the logon failed due to account restrictions, the
        reason for the failure should be returned via this parameter.
        The reason is authentication-package specific.  The substatus
        values for authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

    TokenInformationLevel - If the logon is successful, this field is
        used to indicate what level of information is being returned
        for inclusion in the Token to be created.  This information
        is returned via the TokenInformation parameter.

    TokenInformation - If the logon is successful, this parameter is
        used by the authentication package to return information to
        be included in the token.  The format and content of the
        buffer returned is indicated by the TokenInformationLevel
        return value.

    AccountName - A Unicode string describing the account name
        being logged on to.  This parameter must always be returned
        regardless of the success or failure of the operation.

    AuthenticatingAuthority - A Unicode string describing the Authenticating
        Authority for the logon.  This string may optionally be omitted.

    PrimaryCredentials - Returns primary credentials for handing to other
        packages.

    SupplementalCredentials - Array of supplemental credential blobs for
        other packages.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

    STATUS_NO_LOGON_SERVERS - Indicates that no domain controllers
        are currently able to service the authentication request.

    STATUS_LOGON_FAILURE - Indicates the logon attempt failed.  No
        indication as to the reason for failure is given, but typical
        reasons include mispelled usernames, mispelled passwords.

    STATUS_ACCOUNT_RESTRICTION - Indicates the user account and
        password were legitimate, but that the user account has some
        restriction preventing successful logon at this time.

    STATUS_BAD_VALIDATION_CLASS - The authentication information
        provided is not a validation class known to the specified
        authentication package.

    STATUS_INVALID_LOGON_CLASS - LogonType was invalid.

    STATUS_LOGON_SESSION_COLLISION- Internal Error: A LogonId was selected for
        this logon session.  The selected LogonId already exists.

    STATUS_NETLOGON_NOT_STARTED - The Sam Server or Netlogon service was
        required to perform this function.  The required server was not running.

    STATUS_NO_MEMORY - Insufficient virtual memory or pagefile quota exists.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LSA_TOKEN_INFORMATION_TYPE LsaTokenInformationType = LsaTokenInformationV2;

    PNETLOGON_VALIDATION_SAM_INFO4 NlpUser = NULL;

    ULONG ActiveLogonEntrySize;
    PACTIVE_LOGON pActiveLogonEntry = NULL;
    BOOLEAN bLogonEntryLinked = FALSE;

    BOOLEAN LogonSessionCreated = FALSE;
    BOOLEAN LogonCredentialAdded = FALSE;
    ULONG Flags = 0;
    BOOLEAN Authoritative = FALSE;
    BOOLEAN BadPasswordCountZeroed;
    BOOLEAN StandaloneWorkstation = FALSE;

    PSID UserSid = NULL;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    ULONG CredentialSize = 0;

    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;

    PUNICODE_STRING WorkStationName = NULL;

    // Need to figure out whether to delete the profile  buffer

    BOOLEAN fSubAuthEx = FALSE;

    //
    // deferred NTLM3 checks.
    //

    BOOLEAN fNtLm3 = FALSE;

    //
    // Whether to wait for network & netlogon. If we are attempting
    // forced cached credentials logon, we will avoid doing so.
    //

    BOOLEAN fWaitForNetwork = TRUE;

    BOOLEAN CacheTried = FALSE;

    //
    // Temporary storage while we try to figure
    // out what our username and authenticating
    // authority is.
    //

    UNICODE_STRING TmpName = { 0, 0, NULL };
    WCHAR TmpNameBuffer[UNLEN];
    UNICODE_STRING TmpAuthority = { 0, 0, NULL };
    WCHAR TmpAuthorityBuffer[DNS_MAX_NAME_LENGTH];

    //
    // Logon Information.
    //
    NETLOGON_LOGON_INFO_CLASS LogonLevel = 0;
    NETLOGON_INTERACTIVE_INFO LogonInteractive;
    NETLOGON_NETWORK_INFO LogonNetwork = {0};
    PNETLOGON_LOGON_IDENTITY_INFO LogonInformation = NULL;

    PMSV1_0_LM20_LOGON NetworkAuthentication = NULL;

    //
    // Secret information, if we are doing a service logon
    //
    LSAPR_HANDLE SecretHandle;
    PLSAPR_CR_CIPHER_VALUE SecretCurrent = NULL;
    UNICODE_STRING Prefix, SavedPassword = {0};
    BOOLEAN ServiceSecretLogon = FALSE;
    PMSV1_0_INTERACTIVE_LOGON Authentication = NULL;

    //
    // Credential manager stored credentials.
    //

    UNICODE_STRING CredmanUserName = {0, 0, NULL };
    UNICODE_STRING CredmanDomainName = {0, 0, NULL };
    UNICODE_STRING CredmanPassword = {0, 0, NULL };

    BOOLEAN TryCacheFirst = FALSE;
    NTSTATUS NetlogonStatus = STATUS_SUCCESS;
    LM_RESPONSE LmResponse = {0};
    NT_RESPONSE NtResponse = {0};

    //
    // interactive cached logon users can be mapped, therefore accountname 
    // can differ from credentails username. used to build primary credentials
    //
    
    UNICODE_STRING CredentialUserName = {0};     
    UNICODE_STRING CredentialDomainName = {0};     
    PUNICODE_STRING CredentialUserToUse = NULL;
    PUNICODE_STRING CredentialDomainToUse = NULL;

    //
    // WMI tracing helper struct
    //
    NTLM_TRACE_INFO TraceInfo = {0};

#if _WIN64
    PVOID pTempSubmitBuffer = ProtocolSubmitBuffer;
    SECPKG_CALL_INFO  CallInfo;
    BOOL  fAllocatedSubmitBuffer = FALSE;

    if ( ClientRequest == (PLSA_CLIENT_REQUEST)( -1 ) )
    {
        //
        // if the call originated inproc, the buffers have already been
        // marshalled/etc.
        //

        ZeroMemory( &CallInfo, sizeof(CallInfo) );
    } else {
        if (!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    }

#endif

    //
    // CachedInteractive logons are treated same as Interactive except
    // that we avoid hitting the network.
    //

    if (LogonType == CachedInteractive) {
        fWaitForNetwork = FALSE;
        LogonType = Interactive;
    }

    //
    // Begin tracing a logon user
    //
    if (NtlmGlobalEventTraceFlag){

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmLogonGuid,
                         EVENT_TRACE_TYPE_START,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    //
    // Initialize
    //

    *ProfileBuffer = NULL;
    *SubStatus = STATUS_SUCCESS;
    *AuthenticatingAuthority = NULL;
    *AccountName = NULL;

    TmpName.Buffer        = TmpNameBuffer;
    TmpName.MaximumLength = UNLEN * sizeof( WCHAR );
    TmpName.Length        = 0;

    TmpAuthority.Buffer        = TmpAuthorityBuffer;
    TmpAuthority.MaximumLength = DNS_MAX_NAME_LENGTH * sizeof( WCHAR );
    TmpAuthority.Length        = 0;

    CredmanUserName.Buffer      = NULL;
    CredmanDomainName.Buffer    = NULL;
    CredmanPassword.Buffer      = NULL;

    *SupplementalCredentials = 0;

    RtlZeroMemory(
        PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    //
    // Check the Authentication information and build a LogonInformation
    // structure to pass to SAM or Netlogon.
    //
    // NOTE: Netlogon treats Service and Batch logons as if they are
    //       Interactive.
    //

    switch ( LogonType ) {
    case Service:
    case Interactive:
    case Batch:
    case NetworkCleartext:
    case RemoteInteractive:
        {
            MSV1_0_PRIMARY_CREDENTIAL BuiltCredential;

#if _WIN64


        //
        // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
        // call came from a WOW client.
        //


        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            Authentication =
                (PMSV1_0_INTERACTIVE_LOGON) ProtocolSubmitBuffer;

            Status = MsvConvertWOWInteractiveLogonBuffer(
                                                ProtocolSubmitBuffer,
                                                ClientBufferBase,
                                                &SubmitBufferSize,
                                                &pTempSubmitBuffer
                                                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            fAllocatedSubmitBuffer = TRUE;

            //
            // Some macros below expand out to use ProtocolSubmitBuffer directly.
            // We've secretly replaced their usual ProtocolSubmitBuffer with
            // pTempSubmitBuffer -- let's see if they can tell the difference.
            //

            ProtocolSubmitBuffer = pTempSubmitBuffer;
        }

#endif  // _WIN64

            WorkStationName = &NlpComputerName;

            //
            // Ensure this is really an interactive logon.
            //

            Authentication =
                (PMSV1_0_INTERACTIVE_LOGON) ProtocolSubmitBuffer;

            if (SubmitBufferSize < sizeof(MSV1_0_INTERACTIVE_LOGON)) {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: bogus interactive logon info size %#x\n", SubmitBufferSize));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            if ( (Authentication->MessageType != MsV1_0InteractiveLogon ) &&
                 (Authentication->MessageType != MsV1_0WorkstationUnlockLogon) ) {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Bad Validation Class %d\n", Authentication->MessageType));
                Status = STATUS_BAD_VALIDATION_CLASS;
                goto Cleanup;
            }

            //
            // If the password length is greater than 255 (i.e., the
            // upper byte of the length is non-zero) then the password
            // has been run-encoded for privacy reasons.  Get the
            // run-encode seed out of the upper-byte of the length
            // for later use.
            //
            //

            SeedAndLength = (PSECURITY_SEED_AND_LENGTH)
                            &Authentication->Password.Length;
            Seed = SeedAndLength->Seed;
            SeedAndLength->Seed = 0;

            //
            // Enforce length restrictions on username and password.
            //

            if ( Authentication->UserName.Length > (UNLEN*sizeof(WCHAR)) ||
                Authentication->Password.Length > (PWLEN*sizeof(WCHAR)) )
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Name or password too long\n"));
                Status = STATUS_NAME_TOO_LONG;
                goto Cleanup;
            }

            //
            // Relocate any pointers to be relative to 'Authentication'
            //

            NULL_RELOCATE_ONE( &Authentication->LogonDomainName );

            RELOCATE_ONE( &Authentication->UserName );

            NULL_RELOCATE_ONE( &Authentication->Password );

            if ( (Authentication->LogonDomainName.Length <= sizeof(WCHAR)) &&
                (Authentication->Password.Length <= sizeof(WCHAR))
                )
            {
                Status = CredpProcessUserNameCredential(
                                &Authentication->UserName,
                                &CredmanUserName,
                                &CredmanDomainName,
                                &CredmanPassword
                                );
                if ( NT_SUCCESS(Status) )
                {
                    Authentication->UserName = CredmanUserName;
                    Authentication->LogonDomainName = CredmanDomainName;
                    Authentication->Password = CredmanPassword;
                } else if (Status == STATUS_NOT_SUPPORTED)
                {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUser: unsupported marshalled cred\n"));
                    goto Cleanup;
                }

                Status = STATUS_SUCCESS;
            }

#if 0
            //
            // Handle UPN and composite NETBIOS syntax
            //
            {
                UNICODE_STRING User = Authentication->UserName;
                UNICODE_STRING Domain = Authentication->LogonDomainName;

                Status =
                    NtLmParseName(
                        &User,
                        &Domain,
                        FALSE
                        );
                if(NT_SUCCESS(Status)){
                    Authentication->UserName = User;
                    Authentication->LogonDomainName = Domain;
                }
            }
#endif

            if ( LogonType == Service )
            {
                SECPKG_CALL_INFO CallInfo;

                if ( LsaFunctions->GetCallInfo(&CallInfo) &&
                   (CallInfo.Attributes & SECPKG_CALL_IS_TCB) )
                {
                    //
                    // If we have a service logon, the password we got is likely the name of the secret
                    // that is holding the account password.  Make sure to read that secret here
                    //
                    RtlInitUnicodeString( &Prefix, L"_SC_" );
                    if ( RtlPrefixUnicodeString( &Prefix, &Authentication->Password, TRUE ) )
                    {

                        Status = LsarOpenSecret( NtLmGlobalPolicyHandle,
                                                 ( PLSAPR_UNICODE_STRING )&Authentication->Password,
                                                 SECRET_QUERY_VALUE,
                                                 &SecretHandle );

                        if ( NT_SUCCESS( Status ) )
                        {

                            Status = LsarQuerySecret( SecretHandle,
                                                      &SecretCurrent,
                                                      NULL,
                                                      NULL,
                                                      NULL );

                            if ( NT_SUCCESS( Status ) && (SecretCurrent != NULL) )
                            {

                                RtlCopyMemory( &SavedPassword,
                                               &Authentication->Password,
                                               sizeof( UNICODE_STRING ) );
                                Authentication->Password.Length = ( USHORT )SecretCurrent->Length;
                                Authentication->Password.MaximumLength =
                                                                  ( USHORT )SecretCurrent->MaximumLength;
                                Authentication->Password.Buffer = ( USHORT * )SecretCurrent->Buffer;
                                ServiceSecretLogon = TRUE;
                                Seed = 0; // do not run RtlRunDecodeUnicodeString for this password
                            }

                            LsarClose( &SecretHandle );
                        }
                    }
                }

                if ( !NT_SUCCESS( Status ) ) {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUser: failed to querying service password\n"));

                    goto Cleanup;
                }
            }

            //
            // Now decode the password, if necessary
            //

            if (Seed != 0) {
                try {
                    RtlRunDecodeUnicodeString( Seed, &Authentication->Password);
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUser: failed to decode password\n"));
                    Status = STATUS_ILL_FORMED_PASSWORD;
                    goto Cleanup;
                }
            }

            //
            // Copy out the user name and Authenticating Authority so we can audit them.
            //

            RtlCopyUnicodeString( &TmpName, &Authentication->UserName );

            if ( Authentication->LogonDomainName.Buffer != NULL ) {

                RtlCopyUnicodeString( &TmpAuthority, &Authentication->LogonDomainName );
            }

            //
            // Put the password in the PrimaryCredential to pass to the sundry security packages.
            //

            PrimaryCredentials->Password.Length = PrimaryCredentials->Password.MaximumLength =
                Authentication->Password.Length;
            PrimaryCredentials->Password.Buffer = (*Lsa.AllocateLsaHeap)(Authentication->Password.Length);

            if (PrimaryCredentials->Password.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->Password.Buffer,
                Authentication->Password.Buffer,
                Authentication->Password.Length
                );
            PrimaryCredentials->Flags = PRIMARY_CRED_CLEAR_PASSWORD;

            //
            // We're all done with the cleartext password
            //  Don't let it get to the pagefile.
            //

            try {
                if ( Authentication->Password.Buffer != NULL ) {
                    RtlEraseUnicodeString( &Authentication->Password );
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: failed to decode password\n"));
                Status = STATUS_ILL_FORMED_PASSWORD;
                goto Cleanup;
            }

            //
            // Compute the OWF of the password.
            //

            NlpPutOwfsInPrimaryCredential( &PrimaryCredentials->Password,
                                           (BOOLEAN) (PrimaryCredentials->Flags & PRIMARY_CRED_OWF_PASSWORD),
                                           &BuiltCredential );


            //
            // Define the description of the user to log on.
            //
            LogonLevel = NetlogonInteractiveInformation;
            LogonInformation =
                (PNETLOGON_LOGON_IDENTITY_INFO) &LogonInteractive;

            LogonInteractive.Identity.LogonDomainName =
                Authentication->LogonDomainName;
            LogonInteractive.Identity.ParameterControl = 0;

            LogonInteractive.Identity.UserName = Authentication->UserName;
            LogonInteractive.Identity.Workstation = NlpComputerName;


            LogonInteractive.LmOwfPassword = BuiltCredential.LmOwfPassword;
            LogonInteractive.NtOwfPassword = BuiltCredential.NtOwfPassword;

            RtlSecureZeroMemory(&BuiltCredential, sizeof(BuiltCredential));
        }

        break;

    case Network:
        {
            PMSV1_0_LM20_LOGON Authentication;
            BOOLEAN EnforceTcb = FALSE;


            //
            // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
            // call came from a WOW client.
            //

#if _WIN64
            if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
            {
                Authentication =
                    (PMSV1_0_LM20_LOGON) ProtocolSubmitBuffer;

                Status = MsvConvertWOWNetworkLogonBuffer(
                                                    ProtocolSubmitBuffer,
                                                    ClientBufferBase,
                                                    &SubmitBufferSize,
                                                    &pTempSubmitBuffer
                                                    );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                fAllocatedSubmitBuffer = TRUE;

                //
                // Some macros below expand out to use ProtocolSubmitBuffer directly.
                // We've secretly replaced their usual ProtocolSubmitBuffer with
                // pTempSubmitBuffer -- let's see if they can tell the difference.
                //

                ProtocolSubmitBuffer = pTempSubmitBuffer;
            }
#endif

            //
            // Ensure this is really a network logon request.
            //

            Authentication =
                (PMSV1_0_LM20_LOGON) ProtocolSubmitBuffer;

            NetworkAuthentication = Authentication;

            if (SubmitBufferSize < sizeof(MSV1_0_LM20_LOGON)) {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: bogus network logon info size %#x\n", SubmitBufferSize));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            if ( Authentication->MessageType != MsV1_0Lm20Logon &&
                 Authentication->MessageType != MsV1_0SubAuthLogon  &&
                 Authentication->MessageType != MsV1_0NetworkLogon )
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Bad Validation Class\n"));
                Status = STATUS_BAD_VALIDATION_CLASS;
                goto Cleanup;
            }

            //
            // Relocate any pointers to be relative to 'Authentication'
            //

            NULL_RELOCATE_ONE( &Authentication->LogonDomainName );

            NULL_RELOCATE_ONE( &Authentication->UserName );

            RELOCATE_ONE( &Authentication->Workstation );

#if 0
            //
            // Handle UPN and composite NETBIOS syntax
            //
            {
                UNICODE_STRING User = Authentication->UserName;
                UNICODE_STRING Domain = Authentication->LogonDomainName;

                Status =
                    NtLmParseName(
                        &User,
                        &Domain,
                        FALSE
                        );
                if(NT_SUCCESS(Status)){
                    Authentication->UserName = User;
                    Authentication->LogonDomainName = Domain;
                }
            }
#endif

            //
            // Copy out the user name and Authenticating Authority so we can audit them.
            //

            if ( Authentication->UserName.Buffer != NULL ) {

                RtlCopyUnicodeString( &TmpName, &Authentication->UserName );
            }

            if ( Authentication->LogonDomainName.Buffer != NULL ) {

                RtlCopyUnicodeString( &TmpAuthority, &Authentication->LogonDomainName );
            }

            NULL_RELOCATE_ONE((PUNICODE_STRING)&Authentication->CaseSensitiveChallengeResponse );

            NULL_RELOCATE_ONE((PUNICODE_STRING)&Authentication->CaseInsensitiveChallengeResponse );


            //
            // Define the description of the user to log on.
            //
            LogonLevel = NetlogonNetworkInformation;
            LogonInformation =
                (PNETLOGON_LOGON_IDENTITY_INFO) &LogonNetwork;

            LogonNetwork.Identity.LogonDomainName =
                Authentication->LogonDomainName;

            if ( Authentication->ParameterControl & MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED )
            {
                NT_OWF_PASSWORD NtOwfPassword;
                LM_OWF_PASSWORD LmOwfPassword;
                CHAR LmPassword[LM20_PWLEN + 1] = {0};
                UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH] = {0};
                ULONG LmProtocolSupported = NtLmGlobalLmProtocolSupported;

                //
                // trash the challenge, to avoid allowing a challenge/response
                // replay through this (untrusted) interface.
                //

                Status = SspGenerateRandomBits(Authentication->ChallengeToClient, sizeof(Authentication->ChallengeToClient));

                if (NT_SUCCESS(Status))
                {
                    SspPrint((SSP_WARNING, "LsaApLogonUserEx2: ClearText password supplied, ChallengeToClient trashed\n"));
                    Authentication->ParameterControl &= ~MSV1_0_USE_CLIENT_CHALLENGE;

                    RtlCopyMemory(
                        LmPassword,
                        Authentication->CaseInsensitiveChallengeResponse.Buffer,
                        min(LM20_PWLEN, Authentication->CaseInsensitiveChallengeResponse.Length)
                        );
                    Status = RtlCalculateLmOwfPassword(LmPassword, &LmOwfPassword);
                }

                if (NT_SUCCESS(Status))
                {
                    Status = RtlCalculateNtOwfPassword(
                         (UNICODE_STRING*) &Authentication->CaseSensitiveChallengeResponse,
                         &NtOwfPassword
                         );
                }

                if (NT_SUCCESS(Status))
                {
                    if (LmProtocolSupported < NoLm)
                    {
                        Status = RtlCalculateLmResponse(
                            (PLM_CHALLENGE) Authentication->ChallengeToClient,
                            &LmOwfPassword,
                            &LmResponse
                            );
                        RtlCopyMemory(Challenge, Authentication->ChallengeToClient, sizeof(Challenge));
                    }
                    else if (LmProtocolSupported == NoLm)
                    {
                        Authentication->ParameterControl |= MSV1_0_USE_CLIENT_CHALLENGE;
                        Status = SspGenerateRandomBits(&LmResponse, MSV1_0_CHALLENGE_LENGTH);
                        if (NT_SUCCESS(Status))
                        {
                            MsvpCalculateNtlm2Challenge(
                                Authentication->ChallengeToClient,
                                (UCHAR*) &LmResponse,
                                Challenge
                                );
                        }
                    }
                    else if (LmProtocolSupported >= UseNtlm3)
                    {
                        MsvpLm3Response(
                            &NtOwfPassword,
                            &Authentication->UserName,
                            &Authentication->LogonDomainName,
                            Authentication->ChallengeToClient,
                            (MSV1_0_LM3_RESPONSE*) &LmResponse,
                            (UCHAR*) &LmResponse,
                            NULL,
                            NULL
                            );
                    }
                }
                if (NT_SUCCESS(Status))
                {
                    Authentication->ParameterControl &= ~(MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED | MSV1_0_CLEARTEXT_PASSWORD_ALLOWED);

                    Authentication->CaseInsensitiveChallengeResponse.MaximumLength =
                        Authentication->CaseInsensitiveChallengeResponse.Length = sizeof(LmResponse);
                    Authentication->CaseInsensitiveChallengeResponse.Buffer = (CHAR*) &LmResponse;

                    if (LmProtocolSupported < UseNtlm3)
                    {
                        Status = RtlCalculateNtResponse(
                                    (PNT_CHALLENGE) Challenge,
                                    &NtOwfPassword,
                                    &NtResponse
                                    );

                        if (NT_SUCCESS(Status))
                        {
                            Authentication->CaseSensitiveChallengeResponse.MaximumLength =
                                Authentication->CaseSensitiveChallengeResponse.Length = sizeof(NtResponse);
                            Authentication->CaseSensitiveChallengeResponse.Buffer = (CHAR*) &NtResponse;
                        }
                    }
                    else
                    {
                        Authentication->CaseSensitiveChallengeResponse.MaximumLength =
                                Authentication->CaseSensitiveChallengeResponse.Length = 0;
                    }
                }

                RtlSecureZeroMemory(&NtOwfPassword, sizeof(NtOwfPassword));
                RtlSecureZeroMemory(&LmOwfPassword, sizeof(LmOwfPassword));
                RtlSecureZeroMemory(LmPassword, sizeof(LmPassword));

                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUserEx2 failed cleartext logon\n"));
                    goto Cleanup;
                }
            } else {

                //
                // if cleartext was not supplied, caller must be trusted for inproc calls.
                //

                if ( ClientRequest != (PLSA_CLIENT_REQUEST)( -1 ) )
                {
                    EnforceTcb = TRUE;
                }
            }


            if ( Authentication->MessageType == MsV1_0Lm20Logon ) {
                LogonNetwork.Identity.ParameterControl = MSV1_0_CLEARTEXT_PASSWORD_ALLOWED;
            } else {

                ASSERT( CLEARTEXT_PASSWORD_ALLOWED == MSV1_0_CLEARTEXT_PASSWORD_ALLOWED );
                LogonNetwork.Identity.ParameterControl =
                    Authentication->ParameterControl;

                // For NT 5.0 SubAuth Packages, there is a SubAuthPackageId. Stuff
                // that into ParameterControl so pre 5.0 MsvSamValidate won't choke.

                if ( Authentication->MessageType == MsV1_0SubAuthLogon )
                {
                    PMSV1_0_SUBAUTH_LOGON SubAuthentication =
                        (PMSV1_0_SUBAUTH_LOGON)  ProtocolSubmitBuffer;

                    // Need to not delete return buffers even in case of error
                    // for MsV1_0SubAuthLogon (includes arap).

                    fSubAuthEx = TRUE;

                    LogonNetwork.Identity.ParameterControl |=
                        (SubAuthentication->SubAuthPackageId << MSV1_0_SUBAUTHENTICATION_DLL_SHIFT) | MSV1_0_SUBAUTHENTICATION_DLL_EX;

                    EnforceTcb = TRUE ;
                } else {
                    if ( Authentication->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL )
                    {
                        EnforceTcb = TRUE;
                    }
                }
            }

            if ( EnforceTcb )
            {
                SECPKG_CALL_INFO CallInfo;

                if (!LsaFunctions->GetCallInfo(&CallInfo) ||
                    (CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0)
                {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUser: subauth/chalresp caller isn't privileged\n"));
                    Status = STATUS_ACCESS_DENIED;
                    goto Cleanup;
                }
            }

            LogonNetwork.Identity.UserName = Authentication->UserName;
            LogonNetwork.Identity.Workstation = Authentication->Workstation;

            WorkStationName = &Authentication->Workstation;

            LogonNetwork.NtChallengeResponse =
                Authentication->CaseSensitiveChallengeResponse;
            LogonNetwork.LmChallengeResponse =
                Authentication->CaseInsensitiveChallengeResponse;
            ASSERT( LM_CHALLENGE_LENGTH ==
                    sizeof(Authentication->ChallengeToClient) );

            //
            // If using client challenge, then mix it with the server's challenge
            //  to get the challenge we pass on. It would make more sense to do this
            //  in MsvpPasswordValidate, except that would require the DCs to be upgraded.
            //  Doing it here only requires agreement between the client and server, because
            //  the modified challenge will be passed on to the DCs.
            //

            if ((Authentication->ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) &&
                (Authentication->CaseSensitiveChallengeResponse.Length == NT_RESPONSE_LENGTH) &&
                (Authentication->CaseInsensitiveChallengeResponse.Length >= MSV1_0_CHALLENGE_LENGTH))
            {
                MsvpCalculateNtlm2Challenge (
                    Authentication->ChallengeToClient,
                    (PUCHAR) Authentication->CaseInsensitiveChallengeResponse.Buffer,
                    (PUCHAR) &LogonNetwork.LmChallenge
                    );

            } else {
                RtlCopyMemory(
                    &LogonNetwork.LmChallenge,
                    Authentication->ChallengeToClient,
                    LM_CHALLENGE_LENGTH );
            }

            //
            // if using NTLM3, then check that the target info is for this machine.
            //

            if ((Authentication->ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) &&
                (Authentication->CaseSensitiveChallengeResponse.Length >= sizeof(MSV1_0_NTLM3_RESPONSE)))
            {

                fNtLm3 = TRUE;

                //
                // defer NTLM3 checks until later on when SAM initialized.
                //
            }

            //
            // Enforce length restrictions on username
            //

            if ( Authentication->UserName.Length > (UNLEN*sizeof(WCHAR)) )
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Name too long\n"));
                Status = STATUS_NAME_TOO_LONG;
                goto Cleanup;
            }

            //
            // If this is a null session logon,
            //  just build a NULL token.
            //

            if ( Authentication->UserName.Length == 0 &&
                 Authentication->CaseSensitiveChallengeResponse.Length == 0 &&
                 (Authentication->CaseInsensitiveChallengeResponse.Length == 0 ||
                  (Authentication->CaseInsensitiveChallengeResponse.Length == 1 &&
                  *Authentication->CaseInsensitiveChallengeResponse.Buffer == '\0') ) ) {

                LsaTokenInformationType = LsaTokenInformationNull;
            }
        }

        break;

    default:
        Status = STATUS_INVALID_LOGON_TYPE;
        goto CleanupShort;
    }

    //
    // Allocate a LogonId for this logon session.
    //

    Status = NtAllocateLocallyUniqueId( LogonId );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    NEW_TO_OLD_LARGE_INTEGER( (*LogonId), LogonInformation->LogonId );

    PrimaryCredentials->LogonId = *LogonId;
    PrimaryCredentials->Flags |= (RPC_C_AUTHN_WINNT << PRIMARY_CRED_LOGON_PACKAGE_SHIFT);

    //
    // Create a new logon session
    //

    Status = (*Lsa.CreateLogonSession)( LogonId );
    if ( !NT_SUCCESS(Status) ) {
        SspPrint((SSP_CRITICAL, "LsaApLogonUser: Collision from CreateLogonSession %x\n", Status));
        goto Cleanup;
    }

    LogonSessionCreated = TRUE;


    //
    // Don't worry about SAM or the LSA if this is a Null Session logon.
    //
    // The server does a Null Session logon during initialization.
    // It shouldn't have to wait for SAM to initialize.
    //

    if ( LsaTokenInformationType != LsaTokenInformationNull ) {

        //
        // If Sam is not yet initialized,
        //  do it now.
        //

        if ( !NlpSamInitialized ) {
            Status = NlSamInitialize( SAM_STARTUP_TIME );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        //
        // If this is a workstation,
        //  differentiate between a standalone workstation and a member
        //  workstation.
        //
        // (This is is done on every logon, rather than during initialization,
        // to allow the value to be changed via the UI).
        //

        if ( NlpWorkstation ) {
            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
            StandaloneWorkstation = (BOOLEAN) (NtLmGlobalTargetFlags == NTLMSSP_TARGET_TYPE_SERVER);
            RtlReleaseResource(&NtLmGlobalCritSect);

        } else {
            StandaloneWorkstation = FALSE;
        }
    }

    //
    // Try again to load netlogon.dll
    //
    if ( NlpNetlogonDllHandle == NULL ) {
        NlpLoadNetlogonDll();
    }

    //
    // do NTLM3 processing that was deferred until now due to initialization
    // requirements.
    //

    if ( fNtLm3 )
    {
        PMSV1_0_AV_PAIR pAV;
        PMSV1_0_NTLM3_RESPONSE pResp;
        LONG iRespLen;

        ULONG NtLmProtocolSupported = NtLmGlobalLmProtocolSupported;

        //
        // get the computer name from the response
        //

        pResp = (PMSV1_0_NTLM3_RESPONSE)
            NetworkAuthentication->CaseSensitiveChallengeResponse.Buffer;
        iRespLen = NetworkAuthentication->CaseSensitiveChallengeResponse.Length -
            sizeof(MSV1_0_NTLM3_RESPONSE);

        pAV = MsvpAvlGet((PMSV1_0_AV_PAIR)pResp->Buffer, MsvAvNbComputerName, iRespLen);

        //
        // if there is one (OK to be missing), see that it is us
        // REVIEW -- only allow it to be missing if registry says OK?
        //

        if (pAV) {
            UNICODE_STRING Candidate;

            Candidate.Buffer = (PWSTR)(pAV+1);
            Candidate.Length = (USHORT)(pAV->AvLen);
            Candidate.MaximumLength = Candidate.Length;

            if(!RtlEqualUnicodeString( &NlpComputerName, &Candidate, TRUE ))
            {
                SspPrint((SSP_WARNING, "LsaApLogonUserEx2 failed NbComputerName compare\n"));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

        } else if (NtLmProtocolSupported >= RefuseNtlm3NoTarget) {
            SspPrint((SSP_WARNING, "LsaApLogonUserEx2 no target supplied\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        //
        // get the domain name from the response
        //

        pAV = MsvpAvlGet((PMSV1_0_AV_PAIR)pResp->Buffer, MsvAvNbDomainName, iRespLen);

        //
        // must exist and must be us.
        //

        if (pAV) {

            UNICODE_STRING Candidate;

            Candidate.Buffer = (PWSTR)(pAV+1);
            Candidate.Length = pAV->AvLen;
            Candidate.MaximumLength = pAV->AvLen;


            if( StandaloneWorkstation ) {
                if( !RtlEqualDomainName(&NlpComputerName, &Candidate) ) {
                    SspPrint((SSP_WARNING, "LsaApLogonUserEx2 failed NbDomainName compare\n"));
                    Status = STATUS_LOGON_FAILURE;
                    goto Cleanup;
                }

            } else {
                if( !RtlEqualDomainName(&NlpPrimaryDomainName, &Candidate) ) {
                    SspPrint((SSP_WARNING, "LsaApLogonUserEx2 failed PrimaryDomainName compare\n"));
                    Status = STATUS_LOGON_FAILURE;
                    goto Cleanup;
                }
            }
        } else {
            SspPrint((SSP_WARNING, "LsaApLogonUserEx2 domain name not supplied\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }

    //
    // Do the actual logon now.
    //
    //
    // If a null token is being built,
    //  don't authenticate at all.
    //

    if ( LsaTokenInformationType == LsaTokenInformationNull ) {

        /* Nothing to do here. */

    //
    // Call Sam directly to get the validation information when:
    //
    //  The network is not installed, OR
    //  This is a standalone workstation (not a member of a domain).
    //  This is a workstation and we're logging onto an account on the
    //      workstation.
    //

    } else if ( NlpNetlogonDllHandle == NULL || !NlpLanmanInstalled ||
        
        //
        // StandaloneWorkstation and NtLmGlobalUnicodeDnsDomainNameString.Length != 0 means
        // the machine is joined to MIT realms
        //

       (StandaloneWorkstation && (NtLmGlobalUnicodeDnsDomainNameString.Length == 0)) 

       || ( NlpWorkstation 
            && (LogonInformation->LogonDomainName.Length != 0) 
            && RtlEqualDomainName( &NlpSamDomainName,
                   &LogonInformation->LogonDomainName )) ) {

        // Allow guest logons only

        DWORD AccountsToTry = MSVSAM_SPECIFIED | MSVSAM_GUEST;

        if ((LogonType == Network) &&
            (LogonNetwork.Identity.ParameterControl & MSV1_0_TRY_GUEST_ACCOUNT_ONLY))
        {
            AccountsToTry = MSVSAM_GUEST;
        }

        //
        // for local logons, CachedInteractive is not supported.
        //

        if ( !fWaitForNetwork )
        {
            Status = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        TryCacheFirst = FALSE;
        Authoritative = FALSE;

        //
        // Get the Validation information from the local SAM database
        //

        Status = MsvSamValidate(
                    NlpSamDomainHandle,
                    NlpUasCompatibilityRequired,
                    MsvApSecureChannel,
                    &NlpComputerName,   // Logon Server is this machine
                    &NlpSamDomainName,
                    NlpSamDomainId,
                    LogonLevel,
                    LogonInformation,
                    NetlogonValidationSamInfo4,
                    (PVOID *) &NlpUser,
                    &Authoritative,
                    &BadPasswordCountZeroed,
                    AccountsToTry);

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        // So we don't get a LOGON COLLISION from the old msv package

        Flags |= LOGON_BY_LOCAL;

    //
    // If we couldn't validate via one of the above mechanisms,
    //  call the local Netlogon service to get the validation information.
    //

    } else {

        // 
        // machines joined to MIT realms
        //

        if (StandaloneWorkstation) // NtLmGlobalUnicodeDnsDomainNameString.Length != 0
        {
            fWaitForNetwork = FALSE; // no netlogon service
            TryCacheFirst = TRUE; // need local fallback when cachedlogon fails
            Status = STATUS_NO_LOGON_SERVERS; // fake it
        }

        if ( fWaitForNetwork )
        {
            if ( (NtLmCheckProcessOption( MSV1_0_OPTION_TRY_CACHE_FIRST ) & MSV1_0_OPTION_TRY_CACHE_FIRST) )
            {
                TryCacheFirst = TRUE;
            }
        }

        //
        // If we are attempting cached credentials logon avoid getting stuck
        // on netlogon or the network.
        //

RetryNonCached:

        if (fWaitForNetwork && !TryCacheFirst) {

            //
            // Wait for NETLOGON to finish initialization.
            //

            if ( !NlpNetlogonInitialized ) {

                Status = NlWaitForNetlogon( NETLOGON_STARTUP_TIME );

                if ( !NT_SUCCESS(Status) ) {
                    if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
                        goto Cleanup;
                    }
                } else {
                    
                    NlpNetlogonInitialized = TRUE;
                }
            }

            //
            // Actually call the netlogon service.
            //

            if ( NlpNetlogonInitialized ) {

                Authoritative = FALSE;

                Status = (*NlpNetLogonSamLogon)(
                            NULL,           // Server name
                            NULL,           // Computer name
                            NULL,           // Authenticator
                            NULL,           // ReturnAuthenticator
                            LogonLevel,
                            (LPBYTE) &LogonInformation,
                            NetlogonValidationSamInfo4,
                            (LPBYTE *) &NlpUser,
                            &Authoritative );

                //
                // save the result from netlogon.
                //

                NetlogonStatus = Status;

                //
                // Reset Netlogon initialized flag if local netlogon cannot be
                //  reached.
                //  (Use a more explicit status code)
                //

                if ( !NT_SUCCESS(Status) )
                {
                    switch (Status)
                    {
                        //
                        // for documented errors that netlogon can return
                        // for authoritative failures, leave the status code as-is.
                        //

                        case STATUS_NO_TRUST_LSA_SECRET:
                        case STATUS_TRUSTED_DOMAIN_FAILURE:
                        case STATUS_INVALID_INFO_CLASS:
                        case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
                        case STATUS_ACCESS_DENIED:
                        case STATUS_NO_SUCH_USER:
                        case STATUS_WRONG_PASSWORD:
                        case STATUS_INVALID_LOGON_HOURS:
                        case STATUS_PASSWORD_EXPIRED:
                        case STATUS_ACCOUNT_DISABLED:
                        case STATUS_INVALID_PARAMETER:
                        case STATUS_PASSWORD_MUST_CHANGE:
                        case STATUS_ACCOUNT_EXPIRED:
                        case STATUS_ACCOUNT_LOCKED_OUT:
                        case STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
                        case STATUS_NOLOGON_SERVER_TRUST_ACCOUNT:
                        case STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
                        case STATUS_INVALID_WORKSTATION:
                        case STATUS_DLL_NOT_FOUND: // subauth dll not found
                        case STATUS_PROCEDURE_NOT_FOUND: // returned when subauth registry is not found or procedure is not found
                        case STATUS_ACCOUNT_RESTRICTION:  // Other Org check failed
                        case STATUS_AUTHENTICATION_FIREWALL_FAILED:  // Other Org check failed
                        {
                            break;
                        }

                        //
                        // for errors that are known to occur during unexpected
                        // conditions, over-ride status to allow cache lookup.
                        //

                        case RPC_NT_SERVER_UNAVAILABLE:
                        case RPC_NT_UNKNOWN_IF:
                        case RPC_NT_CALL_CANCELLED:
                        {                
                            NetlogonStatus = STATUS_NO_LOGON_SERVERS;
                            Status = NetlogonStatus;
                            NlpNetlogonInitialized = FALSE;
                            break;
                        }

                        // default will catch a host of RPC related errors.
                        // some mentioned below.
                        //case EPT_NT_NOT_REGISTERED:
                        //case RPC_NT_CALL_FAILED_DNE:
                        //case RPC_NT_SERVER_TOO_BUSY:
                        //case RPC_NT_CALL_FAILED:
                        // case STATUS_NETLOGON_NOT_STARTED:
                        default:
                        {
                            Status = STATUS_NETLOGON_NOT_STARTED;
                            NlpNetlogonInitialized = FALSE;
                            break;
                        }
                    } // switch
                } // if
            }
            else
            {
                NetlogonStatus = STATUS_NETLOGON_NOT_STARTED;
                Status = NetlogonStatus;
            }
        } else {

            //
            // We want to force cached credentials path by behaving as if no
            // network logon servers were available.
            //

            NetlogonStatus = STATUS_NO_LOGON_SERVERS;
            Status = NetlogonStatus;
        }

        //
        // If this is the requested domain,
        //  go directly to SAM if the netlogon service isn't available.
        //
        // We want to go to the netlogon service if it is available since it
        // does special handling of bad passwords and account lockout.  However,
        // if the netlogon service is down, the local SAM database makes a
        // better cache than any other mechanism.
        //

        if ( (!NlpNetlogonInitialized
               && (LogonInformation->LogonDomainName.Length != 0)
               && RtlEqualDomainName( &NlpSamDomainName,
                                      &LogonInformation->LogonDomainName )) 
             || (StandaloneWorkstation && !TryCacheFirst) // fallback case for machines joined to MIT realms
             ) {

            // Allow guest logons only

            DWORD AccountsToTry = MSVSAM_SPECIFIED | MSVSAM_GUEST;

            if ((LogonType == Network) &&
                (LogonNetwork.Identity.ParameterControl & MSV1_0_TRY_GUEST_ACCOUNT_ONLY))
            {
                AccountsToTry = MSVSAM_GUEST;
            }

            //
            // we aren't trying to satisfy from cache.
            //

            TryCacheFirst = FALSE;
            Authoritative = FALSE;

            //
            // Get the Validation information from the local SAM database
            //

            Status = MsvSamValidate(
                        NlpSamDomainHandle,
                        NlpUasCompatibilityRequired,
                        MsvApSecureChannel,
                        &NlpComputerName,   // Logon Server is this machine
                        &NlpSamDomainName,
                        NlpSamDomainId,
                        LogonLevel,
                        LogonInformation,
                        NetlogonValidationSamInfo4,
                        (PVOID *) &NlpUser,
                        &Authoritative,
                        &BadPasswordCountZeroed,
                        AccountsToTry);

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }

            // So we don't get a LOGON COLLISION from the old msv package

            Flags |= LOGON_BY_LOCAL;


        //
        // If Netlogon was successful,
        //  add this user to the logon cache.
        //

        } else if ( NT_SUCCESS( Status ) ) {

            //
            // Indicate this session was validated by the Netlogon
            //  service.
            //

            Flags |= LOGON_BY_NETLOGON;

            //
            // Cache interactive logon information.
            //
            //      NOTE: Batch and Service logons are treated
            //            the same as Interactive here.
            //

            if (LogonType == Interactive ||
                LogonType == Service ||
                LogonType == Batch ||
                LogonType == RemoteInteractive) {

                NTSTATUS ntStatus;

                LogonInteractive.Identity.ParameterControl = RPC_C_AUTHN_WINNT;

                ntStatus = NlpAddCacheEntry(
                                &LogonInteractive,
                                NlpUser,
                                NULL,
                                0,
                                MSV1_0_CACHE_LOGON_REQUEST_INFO4
                                );
            }

        //
        // If Netlogon is simply not available at this time,
        //  try to logon through the cache.
        //
        // STATUS_NO_LOGON_SERVERS indicates the netlogon service couldn't
        //  contact a DC to handle this request.
        //
        // STATUS_NETLOGON_NOT_STARTED indicates the local netlogon service
        //  isn't running.
        //
        //
        // We use the cache for ANY logon type.  This not only allows a
        // user to logon interactively, but it allows that same user to
        // connect from another machine while the DC is down.
        //

        } else if ( Status == STATUS_NO_LOGON_SERVERS ||
                    Status == STATUS_NETLOGON_NOT_STARTED ) {

            NTSTATUS ntStatus;
            CACHE_PASSWORDS cachePasswords;
            ULONG LocalFlags = 0;
           
            CacheTried = TRUE;
            
            //
            // reset Status to NetlogonStatus if an error was encountered.
            //

            if (!NT_SUCCESS( NetlogonStatus ))
            {
                Status = NetlogonStatus;
            }

            //
            // Try to logon via the cache.
            //
            //

            ntStatus = NlpGetCacheEntry(
                        LogonInformation,
                        0, // no lookup flags
                        &CredentialDomainName,
                        &CredentialUserName,
                        &NlpUser, 
                        &cachePasswords, 
                        NULL, // SupplementalCacheData
                        NULL // SupplementalCacheDataLength
                        );

            if (!NT_SUCCESS(ntStatus)) {

                //
                // The original status code is more interesting than
                // the fact that the cache didn't work.
                //

                NlpUser = NULL;     // NlpGetCacheEntry dirties this

                goto Cleanup;
            }

            if ( LogonType != Network )
            {

                //
                // The cache information contains salted hashed passwords,
                // so modify the logon information similarly.
                //

                ntStatus = NlpComputeSaltedHashedPassword(
                            &LogonInteractive.NtOwfPassword,
                            &LogonInteractive.NtOwfPassword,
                            &NlpUser->EffectiveName
                            );
                if (!NT_SUCCESS(ntStatus)) {
                    goto Cleanup;
                }

                ntStatus = NlpComputeSaltedHashedPassword(
                            &LogonInteractive.LmOwfPassword,
                            &LogonInteractive.LmOwfPassword,
                            &NlpUser->EffectiveName
                            );
                if (!NT_SUCCESS(ntStatus)) {
                    goto Cleanup;
                }

            } else {

                PMSV1_0_PRIMARY_CREDENTIAL TempPrimaryCredential;
                ULONG PrimaryCredentialSize;

                if (!UserSid)
                {
                    UserSid = NlpMakeDomainRelativeSid(NlpUser->LogonDomainId, NlpUser->UserId);

                    if (UserSid == NULL)
                    {
                        Status = STATUS_NO_MEMORY;
                        SspPrint((SSP_CRITICAL, "LsaApLogonUser: NlpMakeDomainRelativeSid no memory\n"));
                        goto Cleanup;
                    }
                }

                //
                // because the cache no longer stores OWFs, the cached salted OWF
                // is not useful for validation for network logon.
                // The only place we can get a OWF to match is the active logon
                // cache
                //

                ntStatus = NlpGetPrimaryCredentialByUserSid(
                                UserSid,
                                &TempPrimaryCredential,
                                &PrimaryCredentialSize
                                );

                if (!NT_SUCCESS(ntStatus))
                {
                    Status = STATUS_WRONG_PASSWORD;
                    goto Cleanup;
                }

                //
                // copy out the OWFs, then free the allocated buffer.
                //

                if (TempPrimaryCredential->NtPasswordPresent)
                {
                    RtlCopyMemory(&cachePasswords.SecretPasswords.NtOwfPassword, &TempPrimaryCredential->NtOwfPassword, sizeof(NT_OWF_PASSWORD));
                    cachePasswords.SecretPasswords.NtPasswordPresent = TRUE;
                }
                else
                {
                    cachePasswords.SecretPasswords.NtPasswordPresent = FALSE;
                }

                if (TempPrimaryCredential->LmPasswordPresent)
                {
                    RtlCopyMemory(&cachePasswords.SecretPasswords.LmOwfPassword, &TempPrimaryCredential->LmOwfPassword, sizeof(LM_OWF_PASSWORD));
                    cachePasswords.SecretPasswords.LmPasswordPresent = TRUE;
                }
                else
                {
                    cachePasswords.SecretPasswords.LmPasswordPresent = FALSE;
                }

                RtlZeroMemory(TempPrimaryCredential, PrimaryCredentialSize);
                (*Lsa.FreeLsaHeap)(TempPrimaryCredential);
            }

            //
            // Now we have the information from the cache, validate the
            // user's password
            //

            if (!MsvpPasswordValidate(
                    NlpUasCompatibilityRequired,
                    LogonLevel,
                    (PVOID)LogonInformation,
                    &cachePasswords.SecretPasswords,
                    &LocalFlags,
                    &NlpUser->UserSessionKey,
                    (PLM_SESSION_KEY)
                        &NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY]
                    )) {
                Status = STATUS_WRONG_PASSWORD;
                goto Cleanup;
            }

            Status = STATUS_SUCCESS;

            //
            // successful logon from cache.  Don't retry if a failure occurs below.
            //

            TryCacheFirst = FALSE;

            //
            // The cache always returns a NETLOGONV_VALIDATION_SAM_INFO2
            // structure so set the LOGON_EXTRA_SIDS flag, whether or not
            // there are extra sids. Also, if there was a package ID indicated
            // put it in the PrimaryCredentials and remove it from the
            // NlpUser structure so it doesn't confuse anyone else.
            //

            PrimaryCredentials->Flags &= ~PRIMARY_CRED_PACKAGE_MASK;
            PrimaryCredentials->Flags |= NlpUser->UserFlags & PRIMARY_CRED_PACKAGE_MASK;
            PrimaryCredentials->Flags |= PRIMARY_CRED_CACHED_LOGON;
            NlpUser->UserFlags &= ~PRIMARY_CRED_PACKAGE_MASK;
            NlpUser->UserFlags |= LOGON_CACHED_ACCOUNT | LOGON_EXTRA_SIDS | LocalFlags;
            Flags |= LOGON_BY_CACHE;

        //
        // If the account is permanently dead on the domain controller,
        //  Flush this entry from the cache.
        //
        // Notice that STATUS_INVALID_LOGON_HOURS is not in the list below.
        // This ensures a user will be able to remove his portable machine
        // from the net and use it after hours.
        //
        // Notice the STATUS_WRONG_PASSWORD is not in the list below.
        // We're as likely to flush the cache for typo'd passwords as anything
        // else.  What we'd really like to do is flush the cache if the
        // password on the DC is different than the one in cache; but that's
        // impossible to detect.
        //
        // ONLY DO THIS FOR INTERACTIVE LOGONS
        // (not Service or Batch).
        //

        } else if ( ((LogonType == Interactive) || (LogonType == RemoteInteractive)) &&
                    (Status == STATUS_NO_SUCH_USER ||
                     Status == STATUS_INVALID_WORKSTATION   ||
                     Status == STATUS_PASSWORD_EXPIRED      ||
                     Status == STATUS_ACCOUNT_DISABLED      ||
                     Status == STATUS_ACCOUNT_RESTRICTION   ||  // Other Org check failed
                     Status == STATUS_AUTHENTICATION_FIREWALL_FAILED) ) {  // Other Org check failed

            //
            // Delete the cache entry

            NTSTATUS ntStatus;

            ntStatus = NlpDeleteCacheEntry(
                            Status, // reason
                            Authoritative ? 1 : 0,
                            LogonType, // logon type
                            TRUE, // invalidated by NTLM
                            &LogonInteractive
                            );
            if (!NT_SUCCESS(ntStatus))
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: NlpDeleteCacheEntry returns %x\n", ntStatus));

                //
                // netlogon returns non-authoritative no_such_user error and 
                // there is a matching MIT cache entry, try cached logon
                //

                if (fWaitForNetwork && (Status == STATUS_NO_SUCH_USER) && (!Authoritative)                     
                    && (ntStatus == STATUS_NO_LOGON_SERVERS))
                {
                    fWaitForNetwork = FALSE; // fake it
                    Status = STATUS_NO_LOGON_SERVERS; 
                    goto RetryNonCached;
                }
            }

            goto Cleanup;

        } else {

            goto Cleanup;
        }
    }


    //
    // if this is PersonalSKU, only allow DOMAIN_USER_RID_ADMIN to logon
    // if doing safe-mode boot (NtLmGlobalSafeBoot == TRUE)
    //

    if ( NlpUser &&
        NlpUser->UserId == DOMAIN_USER_RID_ADMIN &&
        !NtLmGlobalSafeBoot &&
        NtLmGlobalPersonalSKU &&
        NlpSamDomainId &&
        RtlEqualSid( NlpUser->LogonDomainId, NlpSamDomainId )
        )
    {
        Status = STATUS_ACCOUNT_RESTRICTION;
        SspPrint((SSP_CRITICAL,
            "LsaApLogonUser: For Personal SKU Administrator cannot log on except during safe mode boot\n"));
        goto Cleanup;
    }

    //
    // For everything except network logons,
    //  save the credentials in the LSA,
    //  create active logon table entry,
    //  return the interactive profile buffer.
    //

    if ( LogonType == Interactive ||
         LogonType == Service     ||
         LogonType == Batch       ||
         LogonType == NetworkCleartext ||
         LogonType == RemoteInteractive
       )
    {
        PUCHAR pWhere;
        USHORT LogonCount;
        ULONG UserSidSize;
        UNICODE_STRING SamAccountName;
        UNICODE_STRING NetbiosDomainName;
        UNICODE_STRING DnsDomainName;
        UNICODE_STRING Upn;
        UNICODE_STRING LogonServer;

        //
        // Grab the various forms of the account name
        //

        NlpGetAccountNames( LogonInformation,
                            NlpUser,
                            &SamAccountName,
                            &NetbiosDomainName,
                            &DnsDomainName,
                            &Upn );

        if (CredentialUserName.Length == 0) 
        {
            CredentialUserToUse = &SamAccountName;
        } 
        else 
        {
            CredentialUserToUse = &CredentialUserName;
        }

        if (CredentialDomainName.Length == 0) 
        {
            CredentialDomainToUse = &NetbiosDomainName;
        } 
        else 
        {
            CredentialDomainToUse = &CredentialDomainName;
        }

        //
        // Build the NTLM primary credential using NetbiosDomainName\SamAccountName
        //
        //

#ifdef MAP_DOMAIN_NAMES_AT_LOGON
        {
            UNICODE_STRING MappedDomain;
            RtlInitUnicodeString(
                &MappedDomain,
                NULL
                );

            Status = NlpMapLogonDomain(
                        &MappedDomain,
                        &NetbiosDomainName );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            Status = NlpMakePrimaryCredential( &MappedDomain,
                                               &SamAccountName,
                                               &PrimaryCredentials->Password,
                                               &Credential,
                                               &CredentialSize );

            if (MappedDomain.Buffer != NULL) {
                NtLmFree(MappedDomain.Buffer);
            }

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }
        }
#else

        Status = NlpMakePrimaryCredential(&NetbiosDomainName,
                    &SamAccountName,
                    &PrimaryCredentials->Password,
                    &Credential,
                    &CredentialSize);

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }
#endif

        //
        // Add additional names to the logon session name map.  Ignore failure
        // as that just means GetUserNameEx calls for these name formats later
        // on will be satisfied by hitting the wire.
        //

        if (NlpUser->FullName.Length != 0)
        {
            I_LsaIAddNameToLogonSession(LogonId, NameDisplay, &NlpUser->FullName);
        }

        if (Upn.Length != 0)
        {
            I_LsaIAddNameToLogonSession(LogonId, NameUserPrincipal, &Upn);
        }

        if (DnsDomainName.Length != 0)
        {
            I_LsaIAddNameToLogonSession(LogonId, NameDnsDomain, &DnsDomainName);
        }

        //
        // Fill the username and domain name into the primary credential
        //  that's passed to the other security packages.
        //
        // The names filled in are the effective names after authentication.
        //  For instance, it isn't the UPN passed to this function.
        //

        PrimaryCredentials->DownlevelName.Length = CredentialUserToUse->Length;
        PrimaryCredentials->DownlevelName.MaximumLength = PrimaryCredentials->DownlevelName.Length; //  + sizeof(WCHAR);
        
        PrimaryCredentials->DownlevelName.Buffer = (*Lsa.AllocateLsaHeap)(PrimaryCredentials->DownlevelName.MaximumLength);

        if (PrimaryCredentials->DownlevelName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            PrimaryCredentials->DownlevelName.Buffer,
            CredentialUserToUse->Buffer,
            CredentialUserToUse->Length
            );

        PrimaryCredentials->DomainName.Length = CredentialDomainToUse->Length;
        PrimaryCredentials->DomainName.MaximumLength = PrimaryCredentials->DomainName.Length; // + sizeof(WCHAR);
            
        PrimaryCredentials->DomainName.Buffer = (*Lsa.AllocateLsaHeap)(PrimaryCredentials->DomainName.Length);

        if (PrimaryCredentials->DomainName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            PrimaryCredentials->DomainName.Buffer,
            CredentialDomainToUse->Buffer,
            CredentialDomainToUse->Length
            );

        RtlCopyMemory(&LogonServer, &NlpUser->LogonServer, sizeof(UNICODE_STRING));

        if ( LogonServer.Length != 0 ) {
            PrimaryCredentials->LogonServer.Length = PrimaryCredentials->LogonServer.MaximumLength =
                LogonServer.Length;
            PrimaryCredentials->LogonServer.Buffer = (*Lsa.AllocateLsaHeap)(LogonServer.Length);

            if (PrimaryCredentials->LogonServer.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->LogonServer.Buffer,
                LogonServer.Buffer,
                LogonServer.Length
                );
        }

        //
        // Save the credential in the LSA.
        //

        Status = NlpAddPrimaryCredential( LogonId,
                                          Credential,
                                          CredentialSize );

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL, "LsaApLogonUser: error from AddCredential %lX\n",
                Status));
            goto Cleanup;
        }
        LogonCredentialAdded = TRUE;

        //
        // Build a Sid for this user.
        //

        if (!UserSid)
        {
            UserSid = NlpMakeDomainRelativeSid(NlpUser->LogonDomainId,
                                               NlpUser->UserId);
            if (UserSid == NULL)
            {
                Status = STATUS_NO_MEMORY;
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: No memory\n"));
                goto Cleanup;
            }
        }

        PrimaryCredentials->UserSid = UserSid;
        UserSid = NULL;
        UserSidSize = RtlLengthSid( PrimaryCredentials->UserSid );

        //
        // Allocate an entry for the active logon table.
        //

        ActiveLogonEntrySize = ROUND_UP_COUNT(sizeof(ACTIVE_LOGON), ALIGN_DWORD) +
              ROUND_UP_COUNT(UserSidSize, sizeof(WCHAR)) +
              SamAccountName.Length + sizeof(WCHAR) +
              NetbiosDomainName.Length + sizeof(WCHAR) +
              NlpUser->LogonServer.Length + sizeof(WCHAR);

        pActiveLogonEntry = I_NtLmAllocate( ActiveLogonEntrySize );

        if ( pActiveLogonEntry == NULL )
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "LsaApLogonUser: No memory %ld\n", ActiveLogonEntrySize));
            goto Cleanup;
        }

        //
        // Fill in the logon table entry.
        //

        pWhere = (PUCHAR)(pActiveLogonEntry + 1);
        pActiveLogonEntry->Signature = NTLM_ACTIVE_LOGON_MAGIC_SIGNATURE;

        OLD_TO_NEW_LARGE_INTEGER(
            LogonInformation->LogonId,
            pActiveLogonEntry->LogonId );

        pActiveLogonEntry->Flags = Flags;
        pActiveLogonEntry->LogonType = LogonType;

        //
        // Copy DWORD aligned fields first.
        //

        pWhere = ROUND_UP_POINTER( pWhere, ALIGN_DWORD );
        Status = RtlCopySid(UserSidSize, (PSID)pWhere, PrimaryCredentials->UserSid);

        if ( !NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }

        pActiveLogonEntry->UserSid = (PSID) pWhere;
        pWhere += UserSidSize;

        //
        // Copy WCHAR aligned fields
        //

        pWhere = ROUND_UP_POINTER( pWhere, ALIGN_WCHAR );
        NlpPutString( &pActiveLogonEntry->UserName,
                      &SamAccountName,
                      &pWhere );

        NlpPutString( &pActiveLogonEntry->LogonDomainName,
                      &NetbiosDomainName,
                      &pWhere );

        NlpPutString( &pActiveLogonEntry->LogonServer,
                      &NlpUser->LogonServer,
                      &pWhere );

        //
        // Get the next enumeration handle for this session.
        //

        pActiveLogonEntry->EnumHandle = (ULONG)InterlockedIncrement((PLONG)&NlpEnumerationHandle);

        NlpLockActiveLogonsRead();

        //
        // Insert this entry into the active logon table.
        //

        if (NlpFindActiveLogon( LogonId ))
        {
            //
            // This Logon ID is already in use.
            //

            NlpUnlockActiveLogons();

            Status = STATUS_LOGON_SESSION_COLLISION;
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUserEx2: Collision from NlpFindActiveLogon for %#x:%#x\n",
                LogonId->HighPart, LogonId->LowPart));
            goto Cleanup;
        }

        //
        // LogonId is unique, the same LogonId wouldn't be added twice
        //

        NlpLockActiveLogonsReadToWrite();

        InsertTailList(&NlpActiveLogonListAnchor, &pActiveLogonEntry->ListEntry);
        NlpUnlockActiveLogons();

        SspPrint((SSP_LOGON_SESS, "LsaApLogonUserEx2 inserted %#x:%#x\n",
          pActiveLogonEntry->LogonId.HighPart, pActiveLogonEntry->LogonId.LowPart));

        bLogonEntryLinked = TRUE;

        //
        // Ensure the LogonCount is at least as big as it is for this
        //  machine.
        //

        LogonCount = (USHORT) NlpCountActiveLogon( &NetbiosDomainName,
                                                   &SamAccountName );
        if ( NlpUser->LogonCount < LogonCount )
        {
            NlpUser->LogonCount = LogonCount;
        }

        //
        // Alocate the profile buffer to return to the client
        //

        Status = NlpAllocateInteractiveProfile(
                    ClientRequest,
                    (PMSV1_0_INTERACTIVE_PROFILE *) ProfileBuffer,
                    ProfileBufferSize,
                    NlpUser );

        if ( !NT_SUCCESS( Status ) )
        {
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: Allocate Profile Failed: %lx\n", Status));
            goto Cleanup;
        }

    } else if ( LogonType == Network ) {

        //
        // if doing client challenge, and it's a vanilla NTLM response,
        //  and it's not a null session, compute unique per-session session keys
        //      N.B: not needed if it's NTLM++, not possible if LM
        //

        if ((NetworkAuthentication->ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) &&
            (NetworkAuthentication->CaseSensitiveChallengeResponse.Length == NT_RESPONSE_LENGTH ) && // vanilla NTLM response
            (NetworkAuthentication->CaseInsensitiveChallengeResponse.Length >= MSV1_0_CHALLENGE_LENGTH ) &&
            (NlpUser != NULL))       // NULL session iff NlpUser == NULL
        {
            MsvpCalculateNtlm2SessionKeys(
                &NlpUser->UserSessionKey,
                NetworkAuthentication->ChallengeToClient,
                (PUCHAR) NetworkAuthentication->CaseInsensitiveChallengeResponse.Buffer,
                (PUSER_SESSION_KEY) &NlpUser->UserSessionKey,
                (PLM_SESSION_KEY)&NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY]
                );
        }

        //
        // Alocate the profile buffer to return to the client
        //

        Status = NlpAllocateNetworkProfile(
                    ClientRequest,
                    (PMSV1_0_LM20_LOGON_PROFILE *) ProfileBuffer,
                    ProfileBufferSize,
                    NlpUser,
                    LogonNetwork.Identity.ParameterControl );
        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: Allocate Profile Failed: %lx. This could also be a status for a subauth logon.\n", Status));
            goto Cleanup;
        }


        if ( NlpUser != NULL )
        {
            UNICODE_STRING SamAccountName;
            UNICODE_STRING NetbiosDomainName;
            UNICODE_STRING DnsDomainName;
            UNICODE_STRING Upn;
            UNICODE_STRING LogonServer;

            //
            // Grab the various forms of the account name
            //

            NlpGetAccountNames( LogonInformation,
                                NlpUser,
                                &SamAccountName,
                                &NetbiosDomainName,
                                &DnsDomainName,
                                &Upn );

            //
            // Add additional names to the logon session name map.  Ignore failure
            // as that just means GetUserNameEx calls for these name formats later
            // on will be satisfied by hitting the wire.
            //

            if (NlpUser->FullName.Length != 0)
            {
                I_LsaIAddNameToLogonSession(LogonId, NameDisplay, &NlpUser->FullName);
            }

            if (Upn.Length != 0)
            {
                I_LsaIAddNameToLogonSession(LogonId, NameUserPrincipal, &Upn);
            }

            if (DnsDomainName.Length != 0)
            {
                I_LsaIAddNameToLogonSession(LogonId, NameDnsDomain, &DnsDomainName);
            }

            //
            // Fill the username and domain name into the primary credential
            //  that's passed to the other security packages.
            //
            // The names filled in are the effective names after authentication.
            //  For instance, it isn't the UPN passed to this function.
            //

            if ( SamAccountName.Length == 0 )
            {
                SamAccountName = TmpName;
            }

            PrimaryCredentials->DownlevelName.Length = PrimaryCredentials->DownlevelName.MaximumLength =
                SamAccountName.Length;
            PrimaryCredentials->DownlevelName.Buffer = (*Lsa.AllocateLsaHeap)(SamAccountName.Length);

            if (PrimaryCredentials->DownlevelName.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->DownlevelName.Buffer,
                SamAccountName.Buffer,
                SamAccountName.Length
                );

            PrimaryCredentials->DomainName.Length = PrimaryCredentials->DomainName.MaximumLength =
                NetbiosDomainName.Length;

            PrimaryCredentials->DomainName.Buffer = (*Lsa.AllocateLsaHeap)(NetbiosDomainName.Length);

            if (PrimaryCredentials->DomainName.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->DomainName.Buffer,
                NetbiosDomainName.Buffer,
                NetbiosDomainName.Length
                );

            RtlCopyMemory(&LogonServer, &NlpUser->LogonServer, sizeof(UNICODE_STRING));

            if ( LogonServer.Length != 0 ) {
                PrimaryCredentials->LogonServer.Length = PrimaryCredentials->LogonServer.MaximumLength =
                    LogonServer.Length;
                PrimaryCredentials->LogonServer.Buffer = (*Lsa.AllocateLsaHeap)(LogonServer.Length);

                if (PrimaryCredentials->LogonServer.Buffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    PrimaryCredentials->LogonServer.Buffer,
                    LogonServer.Buffer,
                    LogonServer.Length
                    );
            }

            //
            // Build a Sid for this user.
            //

            UserSid = NlpMakeDomainRelativeSid( NlpUser->LogonDomainId,
                                                NlpUser->UserId );

            if ( UserSid == NULL ) {
                Status = STATUS_NO_MEMORY;
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: No memory\n"));
                goto Cleanup;
            }

            PrimaryCredentials->UserSid = UserSid;
            UserSid = NULL;
        }
    }

    //
    // Build the token information to return to the LSA
    //

    switch (LsaTokenInformationType) {
    case LsaTokenInformationV2:

        Status = NlpMakeTokenInformationV2(
                        NlpUser,
                        (PLSA_TOKEN_INFORMATION_V2 *)TokenInformation );

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: MakeTokenInformationV2 Failed: %lx\n", Status));
            goto Cleanup;
        }
        break;

    case LsaTokenInformationNull:
        {
            PLSA_TOKEN_INFORMATION_NULL VNull;

            VNull = (*Lsa.AllocateLsaHeap)(sizeof(LSA_TOKEN_INFORMATION_NULL) );
            if ( VNull == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            VNull->Groups = NULL;

            VNull->ExpirationTime.HighPart = 0x7FFFFFFF;
            VNull->ExpirationTime.LowPart = 0xFFFFFFFF;

            *TokenInformation = VNull;
        }
    }

    *TokenInformationType = LsaTokenInformationType;

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // if we tried to logon from cache, try again if it failed.
    //

    if ( fWaitForNetwork && TryCacheFirst && CacheTried && !NT_SUCCESS(Status) )
    {
        if (CredentialUserName.Buffer) 
        {
            NtLmFreePrivateHeap(CredentialUserName.Buffer);
            RtlZeroMemory(&CredentialUserName, sizeof(CredentialUserName));
        }
        
        if (CredentialDomainName.Buffer) 
        {
            NtLmFreePrivateHeap(CredentialDomainName.Buffer);
            RtlZeroMemory(&CredentialDomainName, sizeof(CredentialDomainName));
        }

        if ( NlpUser != NULL )
        {
            MIDL_user_free( NlpUser );
            NlpUser = NULL;
        }

        TryCacheFirst = FALSE;
        goto RetryNonCached;
    }

    NtLmFreePrivateHeap( CredmanUserName.Buffer );
    NtLmFreePrivateHeap( CredmanDomainName.Buffer );
    NtLmFreePrivateHeap( CredmanPassword.Buffer );

    //
    // Restore the saved password
    //
    if ( ServiceSecretLogon ) {

        RtlCopyMemory( &Authentication->Password,
                       &SavedPassword,
                       sizeof( UNICODE_STRING ) );

        //
        // Free the secret value we read...
        //
        LsaIFree_LSAPR_CR_CIPHER_VALUE( SecretCurrent );
    }

    //
    // If the logon wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {

        if ( LogonSessionCreated ) {
            (VOID)(*Lsa.DeleteLogonSession)( LogonId );
        }

        if ( pActiveLogonEntry != NULL ) {
            if ( bLogonEntryLinked ) {
                LsaApLogonTerminated( LogonId );
            } else {
                if ( LogonCredentialAdded ) {
                    (VOID) NlpDeletePrimaryCredential(
                                LogonId );
                }
                I_NtLmFree( pActiveLogonEntry );
            }
        }

        // Special case for MsV1_0SubAuthLogon (includes arap).
        // (Don't free ProfileBuffer during error conditions which may not be fatal)

        if (!fSubAuthEx)
        {
            if ( *ProfileBuffer != NULL ) {
                if (ClientRequest != (PLSA_CLIENT_REQUEST) (-1))
                    (VOID)(*Lsa.FreeClientBuffer)( ClientRequest, *ProfileBuffer );
                else
                    (VOID)(*Lsa.FreeLsaHeap)( *ProfileBuffer );

                *ProfileBuffer = NULL;
            }
        }

        if (PrimaryCredentials->DownlevelName.Buffer != NULL) {
            (*Lsa.FreeLsaHeap)(PrimaryCredentials->DownlevelName.Buffer);
        }

        if (PrimaryCredentials->DomainName.Buffer != NULL) {
            (*Lsa.FreeLsaHeap)(PrimaryCredentials->DomainName.Buffer);
        }

        if (PrimaryCredentials->Password.Buffer != NULL) {

            RtlZeroMemory(
                PrimaryCredentials->Password.Buffer,
                PrimaryCredentials->Password.Length
                );

            (*Lsa.FreeLsaHeap)(PrimaryCredentials->Password.Buffer);
        }

        if (PrimaryCredentials->LogonServer.Buffer != NULL) {
            (*Lsa.FreeLsaHeap)(PrimaryCredentials->LogonServer.Buffer);
        }

        RtlZeroMemory(
            PrimaryCredentials,
            sizeof(SECPKG_PRIMARY_CRED)
            );
    }

    //
    // Copy out Authenticating authority and user name.
    //

    if ( NT_SUCCESS(Status) && LsaTokenInformationType != LsaTokenInformationNull ) {

        //
        // Use the information from the NlpUser structure, since it gives
        // us accurate information about what account we're logging on to,
        // rather than who we were.
        //

        if ( LogonType != Network )
        {
            TmpName = NlpUser->EffectiveName;
        }
        else
        {
            //
            // older servers may not return the effectivename for non-guest network logon.
            //

            if( NlpUser->EffectiveName.Length != 0 )
            {
                TmpName = NlpUser->EffectiveName;
            }
        }

        TmpAuthority = NlpUser->LogonDomainName;
    }

    *AccountName = (*Lsa.AllocateLsaHeap)( sizeof( UNICODE_STRING ) );

    if ( *AccountName != NULL ) {

        (*AccountName)->Buffer = (*Lsa.AllocateLsaHeap)(TmpName.Length + sizeof( UNICODE_NULL) );

        if ( (*AccountName)->Buffer != NULL ) {

            (*AccountName)->MaximumLength = TmpName.Length + sizeof( UNICODE_NULL );
            RtlCopyUnicodeString( *AccountName, &TmpName );

        } else if (NT_SUCCESS(Status)) {
            
            Status = STATUS_NO_MEMORY;
        
        } else {   

            RtlInitUnicodeString( *AccountName, NULL );
        }

    } else if (NT_SUCCESS(Status)) {

        Status = STATUS_NO_MEMORY;
    }

    *AuthenticatingAuthority = (*Lsa.AllocateLsaHeap)( sizeof( UNICODE_STRING ) );

    if ( *AuthenticatingAuthority != NULL ) {

        (*AuthenticatingAuthority)->Buffer = (*Lsa.AllocateLsaHeap)( TmpAuthority.Length + sizeof( UNICODE_NULL ) );

        if ( (*AuthenticatingAuthority)->Buffer != NULL ) {

            (*AuthenticatingAuthority)->MaximumLength = (USHORT)(TmpAuthority.Length + sizeof( UNICODE_NULL ));
            RtlCopyUnicodeString( *AuthenticatingAuthority, &TmpAuthority );
        
        } else if (NT_SUCCESS(Status)) {
            
            Status = STATUS_NO_MEMORY;
        
        } else {   

            RtlInitUnicodeString( *AuthenticatingAuthority, NULL );
        }

    } else if (NT_SUCCESS(Status)) {

        Status = STATUS_NO_MEMORY;
    }

    *MachineName = NULL;

    if (WorkStationName != NULL) {

        *MachineName = (*Lsa.AllocateLsaHeap)( sizeof( UNICODE_STRING ) );

        if ( *MachineName != NULL ) {

            (*MachineName)->Buffer = (*Lsa.AllocateLsaHeap)( WorkStationName->Length + sizeof( UNICODE_NULL ) );

            if ( (*MachineName)->Buffer != NULL ) {

                (*MachineName)->MaximumLength = (USHORT)(WorkStationName->Length + sizeof( UNICODE_NULL ));
                RtlCopyUnicodeString( *MachineName, WorkStationName );

            } else if (NT_SUCCESS(Status)) {

                Status = STATUS_NO_MEMORY;

            } else {   

                RtlInitUnicodeString( *MachineName, NULL );
            }

        } else if (NT_SUCCESS(Status)) {

            Status = STATUS_NO_MEMORY;
        }
    } 

    //
    // Map status codes to prevent specific information from being
    // released about this user.
    //
    switch (Status) {
    case STATUS_WRONG_PASSWORD:
    case STATUS_NO_SUCH_USER:
    case STATUS_DOMAIN_TRUST_INCONSISTENT:

        //
        // sleep 3 seconds to "discourage" dictionary attacks.
        // Don't worry about interactive logon dictionary attacks.
        // They will be slow anyway.
        //
        // per bug 171041, SField, RichardW, CliffV all decided this
        // delay has almost zero value for Win2000.  Offline attacks at
        // sniffed wire traffic are more efficient and viable.  Further,
        // opimizations in logon code path make failed interactive logons
        // very fast.
        //
        //        if (LogonType != Interactive) {
        //            Sleep( 3000 );
        //        }

        //
        // This is for auditing.  Make sure to clear it out before
        // passing it out of LSA to the caller.
        //

        *SubStatus = Status;
        Status = STATUS_LOGON_FAILURE;
        break;

    case STATUS_INVALID_LOGON_HOURS:
    case STATUS_INVALID_WORKSTATION:
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_ACCOUNT_DISABLED:
        *SubStatus = Status;
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;

    //
    // This means that the Other Organization check failed.
    // It would probably be better to set the substatus
    // to a more descriptive error but that could potentially
    // create compatibility problems.
    //
    case STATUS_ACCOUNT_RESTRICTION:
        *SubStatus = STATUS_ACCOUNT_RESTRICTION;
        break;

    default:
        break;

    }

    //
    // Cleanup locally used resources
    //

    if ( Credential != NULL ) {
        RtlZeroMemory(Credential, CredentialSize);
        (*Lsa.FreeLsaHeap)( Credential );
    }

    if ( NlpUser != NULL ) {
        MIDL_user_free( NlpUser );
    }

    if ( UserSid != NULL ) {
        (*Lsa.FreeLsaHeap)( UserSid );
    }

//
// Cleanup short was added to avoid returning from the middle of the function.
//

CleanupShort:

    //
    // End tracing a logon user
    //
    if (NtlmGlobalEventTraceFlag) {

        UNICODE_STRING strTempDomain = {0};

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmLogonGuid,
                         EVENT_TRACE_TYPE_END,
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                         6);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_LOGON_STATUS,
                        Status);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_LOGON_TYPE,
                        LogonType);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_LOGON_USERNAME,
                          (**AccountName));

        if (AuthenticatingAuthority)
            strTempDomain = **AuthenticatingAuthority;

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_LOGON_DOMAINNAME,
                          strTempDomain);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

#if _WIN64

    //
    // Do this last since some of the cleanup code above may refer to addresses
    // inside the pTempSubmitBuffer/ProtocolSubmitBuffer (e.g., copying out the
    // Workstation name, etc).
    //

    if (fAllocatedSubmitBuffer)
    {
        NtLmFreePrivateHeap( pTempSubmitBuffer );
    }

#endif  // _WIN64

    if (CredentialUserName.Buffer) 
    {
        NtLmFreePrivateHeap(CredentialUserName.Buffer);
    }

    if (CredentialDomainName.Buffer) 
    {
        NtLmFreePrivateHeap(CredentialDomainName.Buffer);
    }

    //
    // Return status to the caller
    //

    return Status;
}


VOID
LsaApLogonTerminated (
    IN PLUID pLogonId
    )

/*++

Routine Description:

    This routine is used to notify each authentication package when a logon
    session terminates.  A logon session terminates when the last token
    referencing the logon session is deleted.

Arguments:

    pLogonId - Is the logon ID that just logged off.

Return Status:

    None.

--*/

{
    PACTIVE_LOGON pActiveLogon = NULL;

    //
    // Find the entry and de-link it from the active logon table.
    //

    // this scheme assumes we won't be called concurrently, multiple times,
    // for the same LogonId. (would need to take write lock up front to support that).
    // (note that it's quite possible to frequently attempt deleting logon sessions
    // associated with other packages, which would not exist in the NTLM universe).
    //

    NlpLockActiveLogonsRead();

    if ( NULL == (pActiveLogon = NlpFindActiveLogon( pLogonId )) )
    {
        NlpUnlockActiveLogons();
        return;
    }

    NlpLockActiveLogonsReadToWrite();


    //
    // comment out the following assuming the same logon session can not be
    // deleted twice
    //

    #if 0

    if ( NULL == (pActiveLogon = NlpFindActiveLogon( pLogonId )) )
    {
         NlpUnlockActiveLogons();
         return;
    }

    #endif

    RemoveEntryList(&pActiveLogon->ListEntry);

    NlpUnlockActiveLogons();

    //
    // Delete the credential.
    //
    // (Currently the LSA deletes all of the credentials before calling
    // the authentication package.  This line is added to be compatible
    // with a more reasonable LSA.)
    //

    (VOID) NlpDeletePrimaryCredential( &pActiveLogon->LogonId );

    //
    // Deallocate the now orphaned entry.
    //

    I_NtLmFree( pActiveLogon );


    //
    // NB: We don't delete the logon session or credentials.
    //  That will be done by the LSA itself after we return.
    //

    return;

}

//+-------------------------------------------------------------------------
//
//  Function:   SspAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the Kerberos package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              PrimaryCredentials - Primary credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - If present, contains credentials
//                  from the account itself.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SspAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSECPKG_PRIMARY_CRED pPrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED pSupplementalCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMSV1_0_PRIMARY_CREDENTIAL pCredential = NULL;
    ULONG CredentialSize = 0;
    LUID SystemLuid = SYSTEM_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;   
    UNICODE_STRING DomainNameToUse;
    UNICODE_STRING RealDomainName = {0};
    PACTIVE_LOGON pActiveLogon = NULL;
    PACTIVE_LOGON pActiveLogonEntry = NULL;
    ULONG ActiveLogonEntrySize;
    ULONG UserSidSize;
    PUCHAR pWhere = NULL;
    BOOLEAN bLogonEntryLinked = FALSE;
    PMSV1_0_SUPPLEMENTAL_CREDENTIAL pMsvCredentials = NULL;

    LUID CredentialLuid;

    CredentialLuid = pPrimaryCredentials->LogonId;

    //
    // If there is no cleartext password, bail out here because we
    // can't build a real credential.
    //

    if ((pPrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD) == 0)
    {
        ASSERT((!(pPrimaryCredentials->Flags & PRIMARY_CRED_OWF_PASSWORD)) && "OWF password is not supported yet");
        
        if (!ARGUMENT_PRESENT(pSupplementalCredentials))
        {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }
        else
        {
            //
            // Validate the MSV credentials
            //

            pMsvCredentials = (PMSV1_0_SUPPLEMENTAL_CREDENTIAL) pSupplementalCredentials->Credentials;
            if (pSupplementalCredentials->CredentialSize < sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL))
            {
                //
                // LOGLOG: bad credentials - ignore them
                //

                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
            if (pMsvCredentials->Version != MSV1_0_CRED_VERSION)
            {
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
        }
    }

    //
    // stash the credential associated with SYSTEM under another logonID
    // this is done so we can utilize that credential at a later time if
    // requested by the caller.
    //

    if (RtlEqualLuid(
            &CredentialLuid,
            &SystemLuid
            ))
    {

        CredentialLuid = NtLmGlobalLuidMachineLogon;
    }

    if ( NtLmLocklessGlobalPreferredDomainString.Buffer != NULL )
    {
        DomainNameToUse = NtLmLocklessGlobalPreferredDomainString;
    }
    else
    {
        //
        // pick the correct names that are updated by policy callback
        //

        if (RtlEqualLuid(&pPrimaryCredentials->LogonId, &SystemLuid)
             || RtlEqualLuid(&pPrimaryCredentials->LogonId, &NetworkServiceLuid))
        {
            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
            Status = NtLmDuplicateUnicodeString(
                       &RealDomainName,
                       &NtLmGlobalUnicodePrimaryDomainNameString
                       );
            RtlReleaseResource(&NtLmGlobalCritSect);

            if (!NT_SUCCESS(Status)) 
            {
                goto Cleanup;
            }
            DomainNameToUse = RealDomainName;
        } 
        else
        {
            DomainNameToUse = pPrimaryCredentials->DomainName;
        }
    }

    //
    // Build the primary credential
    //

    if ((pPrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {
        Status = NlpMakePrimaryCredential( &DomainNameToUse,
                    &pPrimaryCredentials->DownlevelName,
                    &pPrimaryCredentials->Password,
                    &pCredential,
                    &CredentialSize );
    }
    else
    {
        ASSERT(pMsvCredentials && "SspAcceptCredentials must have supplemental credentials");

        Status = NlpMakePrimaryCredentialFromMsvCredential(
                    &DomainNameToUse,
                    &pPrimaryCredentials->DownlevelName,
                    pMsvCredentials,
                    &pCredential,
                    &CredentialSize );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is an update, just change the password
    //

    if ((pPrimaryCredentials->Flags & PRIMARY_CRED_UPDATE) != 0)
    {
        Status = NlpChangePwdCredByLogonId(
                    &CredentialLuid,
                    pCredential,
                    0 == (pPrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD) // need notification only when there is no cleartext password
                    );
        goto Cleanup;
    }

    //
    // Now create an entry in the active logon list
    //

    UserSidSize = RtlLengthSid( pPrimaryCredentials->UserSid );

    //
    // Allocate an entry for the active logon table.
    //

    ActiveLogonEntrySize = ROUND_UP_COUNT(sizeof(ACTIVE_LOGON), ALIGN_DWORD) +
          ROUND_UP_COUNT(UserSidSize, sizeof(WCHAR)) +
          pPrimaryCredentials->DownlevelName.Length + sizeof(WCHAR) +
          DomainNameToUse.Length + sizeof(WCHAR) +
          pPrimaryCredentials->LogonServer.Length + sizeof(WCHAR);

    pActiveLogonEntry = I_NtLmAllocate( ActiveLogonEntrySize );

    if ( pActiveLogonEntry == NULL )
    {
        Status = STATUS_NO_MEMORY;
        SspPrint((SSP_CRITICAL, "SpAcceptCredentials: no memory %ld\n", ActiveLogonEntrySize));
        goto Cleanup;
    }

    pActiveLogonEntry->Signature = NTLM_ACTIVE_LOGON_MAGIC_SIGNATURE;

    //
    // Fill in the logon table entry.
    //

    pWhere = (PUCHAR) (pActiveLogonEntry + 1);

    OLD_TO_NEW_LARGE_INTEGER(
        CredentialLuid,
        pActiveLogonEntry->LogonId
        );

    //
    // Indicate that this was a logon by another package because we don't want to
    // notify Netlogon of the logoff.
    //

    pActiveLogonEntry->Flags = LOGON_BY_OTHER_PACKAGE;
    pActiveLogonEntry->LogonType = LogonType;

    //
    // Copy DWORD aligned fields first.
    //

    pWhere = ROUND_UP_POINTER( pWhere, ALIGN_DWORD );
    Status = RtlCopySid(UserSidSize, (PSID)pWhere, pPrimaryCredentials->UserSid);

    if ( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    pActiveLogonEntry->UserSid = (PSID) pWhere;
    pWhere += UserSidSize;

    //
    // Copy WCHAR aligned fields
    //

    pWhere = ROUND_UP_POINTER( pWhere, ALIGN_WCHAR );
    NlpPutString( &pActiveLogonEntry->UserName,
                  &pPrimaryCredentials->DownlevelName,
                  &pWhere );

    NlpPutString( &pActiveLogonEntry->LogonDomainName,
                  &DomainNameToUse,
                  &pWhere );

    NlpPutString( &pActiveLogonEntry->LogonServer,
                  &pPrimaryCredentials->LogonServer,
                  &pWhere );

    //
    // Insert this entry into the active logon table.
    //

    // (sfield) LONGHORN: determine if/why there would ever be a collision.
    // LSA should enforce no collision is possible via locally unique id..
    //

    NlpLockActiveLogonsRead();
    pActiveLogon = NlpFindActiveLogon( &CredentialLuid );

    if (pActiveLogon)
    {
        //
        // This Logon ID is already in use.
        //

        //
        // Check to see if this was someone we logged on
        //

        if ((pActiveLogon->Flags & (LOGON_BY_CACHE | LOGON_BY_NETLOGON | LOGON_BY_LOCAL)) != 0)
        {
            //
            // Unlock early since we hold a write lock
            //

            NlpUnlockActiveLogons();

            //
            // We did the logon, so don't bother to add it again.
            //

            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // Unlock early since we hold a write lock
            //

            NlpUnlockActiveLogons();

            Status = STATUS_LOGON_SESSION_COLLISION;

            SspPrint((SSP_CRITICAL,
              "SpAcceptCredentials: Collision from NlpFindActiveLogon for %#x:%#x\n",
              pActiveLogonEntry->LogonId.HighPart, pActiveLogonEntry->LogonId.LowPart));
        }

        goto Cleanup;
    }

    pActiveLogonEntry->EnumHandle = (ULONG)InterlockedIncrement( (PLONG)&NlpEnumerationHandle );

    NlpLockActiveLogonsReadToWrite();

    //
    // if we worry about two SspAcceptCredentials accepting the same LogonId
    // at the same time, first it is extremely unlikely, second, it is benign
    //
    // if (!NlpFindActiveLogon( &CredentialLuid ))  // must sure this LogonId is not in the list
    // {
    //     InsertTailList(&NlpActiveLogonListAnchor, &pActiveLogonEntry->ListEntry);
    // }
    //

    InsertTailList(&NlpActiveLogonListAnchor, &pActiveLogonEntry->ListEntry);

    NlpUnlockActiveLogons();

    SspPrint((SSP_LOGON_SESS, "SpAcceptCredentials inserted %#x:%#x\n",
              pActiveLogonEntry->LogonId.HighPart, pActiveLogonEntry->LogonId.LowPart));

    bLogonEntryLinked = TRUE;

    //
    // Save the credential in the LSA.
    //

    Status = NlpAddPrimaryCredential(
                &CredentialLuid,
                pCredential,
                CredentialSize
                );

    if ( !NT_SUCCESS( Status ) )
    {
        SspPrint((SSP_CRITICAL, "SpAcceptCredentials: error from AddCredential %lX\n",
            Status));
        goto Cleanup;
    }

    pActiveLogonEntry = NULL;

Cleanup:

    if (pActiveLogonEntry)
    {
        if (bLogonEntryLinked)
        {
            LsaApLogonTerminated( &CredentialLuid );
        }
        else
        {
            I_NtLmFree( pActiveLogonEntry );
        }
    }

    if ( pCredential )
    {
        RtlZeroMemory(pCredential, CredentialSize);
        LsaFunctions->FreeLsaHeap( pCredential );
    }

    if (RealDomainName.Buffer) 
    {
        NtLmFreePrivateHeap(RealDomainName.Buffer);
    }

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   NlpMapLogonDomain
//
//  Synopsis:   This routine is called while MSV1_0 package is logging
//              a user on.  The logon domain name is mapped to another
//              domain to be stored in the credential.
//
//  Effects:    Allocates output string
//
//  Arguments:  MappedDomain - Receives mapped domain name
//              LogonDomain - Domain to which user is logging on
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NlpMapLogonDomain(
    OUT PUNICODE_STRING MappedDomain,
    IN PUNICODE_STRING LogonDomain
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( (NtLmLocklessGlobalMappedDomainString.Buffer == NULL) ||
        !RtlEqualDomainName( LogonDomain, &NtLmLocklessGlobalMappedDomainString )
        )
    {
        Status = NtLmDuplicateUnicodeString(
                    MappedDomain,
                    LogonDomain
                    );
        goto Cleanup;
    }


    if ( NtLmLocklessGlobalPreferredDomainString.Buffer == NULL )
    {
        Status = NtLmDuplicateUnicodeString(
                    MappedDomain,
                    LogonDomain
                    );
    } else {
        Status = NtLmDuplicateUnicodeString(
                    MappedDomain,
                    &NtLmLocklessGlobalPreferredDomainString
                    );
    }

Cleanup:
    return(Status);
}


// calculate NTLM2 challenge from client and server challenges
VOID
MsvpCalculateNtlm2Challenge (
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH]
    )
{
    MD5_CTX Md5Context;

    SspPrint((SSP_NTLM_V2, "MsvpCalculateNtlm2Challenge mixing ChallengeFromClient and ChallengeToClient\n"));

    MD5Init(
        &Md5Context
        );
    MD5Update(
        &Md5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    MD5Update(
        &Md5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    MD5Final(
        &Md5Context
        );
    ASSERT(MD5DIGESTLEN >= MSV1_0_CHALLENGE_LENGTH);

    RtlCopyMemory(
        Challenge,
        Md5Context.digest,
        MSV1_0_CHALLENGE_LENGTH
        );
}


// calculate NTLM2 session keys from User session key given
//  to us by the system with the user's account

VOID
MsvpCalculateNtlm2SessionKeys (
    IN PUSER_SESSION_KEY NtUserSessionKey,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PUSER_SESSION_KEY LocalUserSessionKey,
    OUT PLM_SESSION_KEY LocalLmSessionKey
    )
{
    // SESSKEY = HMAC(NtUserSessionKey, (ChallengeToClient, ChallengeFromClient))
    //  Lm session key is first 8 bytes of session key
    HMACMD5_CTX HMACMD5Context;

    HMACMD5Init(
        &HMACMD5Context,
        (PUCHAR)NtUserSessionKey,
        sizeof(*NtUserSessionKey)
        );
    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    HMACMD5Update(
        &HMACMD5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    HMACMD5Final(
        &HMACMD5Context,
        (PUCHAR)LocalUserSessionKey
        );
    RtlCopyMemory(
        LocalLmSessionKey,
        LocalUserSessionKey,
        sizeof(*LocalLmSessionKey)
        );
}


// calculate NTLM3 OWF from credentials
VOID
MsvpCalculateNtlm3Owf (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    OUT UCHAR Ntlm3Owf[MSV1_0_NTLM3_OWF_LENGTH]
    )
{
    HMACMD5_CTX HMACMD5Context;
    WCHAR UCUserName[UNLEN+1];
    UNICODE_STRING UCUserNameString;

    UCUserNameString.Length = 0;
    UCUserNameString.MaximumLength = UNLEN;
    UCUserNameString.Buffer = UCUserName;

    RtlUpcaseUnicodeString(
        &UCUserNameString,
        pUserName,
        FALSE
        );


    // Calculate NTLM3 OWF -- HMAC(MD4(P), (UserName, LogonDomainName))

    HMACMD5Init(
        &HMACMD5Context,
        (PUCHAR)pNtOwfPassword,
        sizeof(*pNtOwfPassword)
        );

    HMACMD5Update(
        &HMACMD5Context,
        (PUCHAR)UCUserNameString.Buffer,
        pUserName->Length
        );

    HMACMD5Update(
        &HMACMD5Context,
        (PUCHAR)pLogonDomainName->Buffer,
        pLogonDomainName->Length
        );

    HMACMD5Final(
        &HMACMD5Context,
        Ntlm3Owf
        );
}


// calculate LM3 response from credentials
VOID
MsvpLm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlm3Owf[MSV1_0_NTLM3_OWF_LENGTH];

    SspPrint((SSP_NTLM_V2, "MsvpLm3Response: %wZ\\%wZ\n", pLogonDomainName, pUserName));

    // get NTLM3 OWF

    MsvpCalculateNtlm3Owf (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlm3Owf
        );

    // Calculate NTLM3 Response
    // HMAC(Ntlm3Owf, (NS, V, HV, T, NC, S))

    HMACMD5Init(
        &HMACMD5Context,
        Ntlm3Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        (PUCHAR)pLm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_NTLM3_RESPONSE_LENGTH);

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    if( (UserSessionKey != NULL) && (LmSessionKey != NULL) )
    {
        // now compute the session keys
        //  HMAC(Kr, R)
        HMACMD5Init(
            &HMACMD5Context,
            Ntlm3Owf,
            MSV1_0_NTLM3_OWF_LENGTH
            );

        HMACMD5Update(
            &HMACMD5Context,
            Response,
            MSV1_0_NTLM3_RESPONSE_LENGTH
            );

        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
        HMACMD5Final(
            &HMACMD5Context,
            (PUCHAR)UserSessionKey
            );

        ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH <= MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(
            LmSessionKey,
            UserSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH);
    }

    return;
}


VOID
MsvpNtlm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN ULONG ServerNameLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlm3Owf[MSV1_0_NTLM3_OWF_LENGTH];

    SspPrint((SSP_NTLM_V2, "MsvpNtlm3Response: %wZ\\%wZ\n", pLogonDomainName, pUserName));

    // get NTLM3 OWF

    MsvpCalculateNtlm3Owf (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlm3Owf
        );

    // Calculate NTLM3 Response
    // HMAC(Ntlm3Owf, (NS, V, HV, T, NC, S))

    HMACMD5Init(
        &HMACMD5Context,
        Ntlm3Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        &pNtlm3Response->RespType,
        (MSV1_0_NTLM3_INPUT_LENGTH + ServerNameLength)
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_NTLM3_RESPONSE_LENGTH);

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    // now compute the session keys
    //  HMAC(Kr, R)
    HMACMD5Init(
        &HMACMD5Context,
        Ntlm3Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        Response,
        MSV1_0_NTLM3_RESPONSE_LENGTH
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
    HMACMD5Final(
        &HMACMD5Context,
        (PUCHAR)UserSessionKey
        );

    ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH <= MSV1_0_USER_SESSION_KEY_LENGTH);
    RtlCopyMemory(
        LmSessionKey,
        UserSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH);

    return;
}


NTSTATUS
MsvpLm20GetNtlm3ChallengeResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN PUNICODE_STRING pServerName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
/*++

Routine Description:

    This routine calculates the NT and LM response for the NTLM3
    authentication protocol
    It generates the time stamp, version numbers, and
    client challenge, and the NTLM3 and LM3 responses.

--*/

{

    NTSTATUS Status;

    // fill in version numbers, timestamp, and client's challenge

    pNtlm3Response->RespType = 1;
    pNtlm3Response->HiRespType = 1;
    pNtlm3Response->Flags = 0;
    pNtlm3Response->MsgWord = 0;

    Status = NtQuerySystemTime ( (PLARGE_INTEGER)&pNtlm3Response->TimeStamp );

    if (NT_SUCCESS(Status)) {
        Status = SspGenerateRandomBits(
                    pNtlm3Response->ChallengeFromClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );
    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#ifdef USE_CONSTANT_CHALLENGE
    pNtlm3Response->TimeStamp = 0;
    RtlZeroMemory(
        pNtlm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );
#endif

    RtlCopyMemory(
        pNtlm3Response->Buffer,
        pServerName->Buffer,
        pServerName->Length
        );

    // Calculate NTLM3 response, filling in response field
    MsvpNtlm3Response (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        pServerName->Length,
        ChallengeToClient,
        pNtlm3Response,
        pNtlm3Response->Response,
        UserSessionKey,
        LmSessionKey
        );

    // Use same challenge to compute the LM3 response
    RtlCopyMemory(
        pLm3Response->ChallengeFromClient,
        pNtlm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    // Calculate LM3 response
    MsvpLm3Response (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        ChallengeToClient,
        pLm3Response,
        pLm3Response->Response,
        NULL,
        NULL
        );

    return STATUS_SUCCESS;
}


// MsvAvInit -- function to initialize AV pair list

PMSV1_0_AV_PAIR
MsvpAvlInit(
    IN void * pAvList
    )
{
    PMSV1_0_AV_PAIR pAvPair;

    pAvPair = (PMSV1_0_AV_PAIR)pAvList;
    pAvPair->AvId = MsvAvEOL;
    pAvPair->AvLen = 0;
    return pAvPair;
}

// MsvpAvGet -- function to find a particular AV pair by ID

PMSV1_0_AV_PAIR
MsvpAvlGet(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to find
    IN LONG cAvList                         // size of AV list
    )
{
    MSV1_0_AV_PAIR AvPair = {0};
    MSV1_0_AV_PAIR* pAvPair = NULL;

    if (cAvList < sizeof(AvPair)) {
        return NULL;
    }

    pAvPair = pAvList;

    RtlCopyMemory(
        &AvPair, 
        pAvPair, 
        sizeof(AvPair)
        );

    while (1) {

        if ( (cAvList <= 0) || (((ULONG) cAvList < AvPair.AvLen + sizeof(MSV1_0_AV_PAIR))) ) {
            return NULL;
        }

        if (AvPair.AvId == AvId)
            return pAvPair;

        if (AvPair.AvId == MsvAvEOL)
            return NULL;
        
        cAvList -= (AvPair.AvLen + sizeof(MSV1_0_AV_PAIR));
        
        if (cAvList <= 0)
           return NULL;
        
        pAvPair = (PMSV1_0_AV_PAIR) ((PUCHAR) pAvPair + AvPair.AvLen + sizeof(MSV1_0_AV_PAIR));
        RtlCopyMemory(
            &AvPair, 
            pAvPair, 
            sizeof(AvPair)
            );
    }
}

// MsvpAvlLen -- function to find length of a AV list

ULONG
MsvpAvlLen(
    IN PMSV1_0_AV_PAIR pAvList,            // first pair of AV pair list
    IN LONG cAvList                        // max size of AV list
    )
{
    PMSV1_0_AV_PAIR pCurPair;

    // find the EOL
    pCurPair = MsvpAvlGet(pAvList, MsvAvEOL, cAvList);
    if( pCurPair == NULL )
        return 0;

    // compute length (not forgetting the EOL pair)
    return (ULONG)(((PUCHAR)pCurPair - (PUCHAR)pAvList) + sizeof(MSV1_0_AV_PAIR));
}

// MsvpAvlAdd -- function to add an AV pair to a list
// assumes buffer is long enough!
// returns NULL on failure.

PMSV1_0_AV_PAIR
MsvpAvlAdd(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to add
    IN PUNICODE_STRING pString,             // value of pair
    IN LONG cAvList                         // max size of AV list
    )
{
    PMSV1_0_AV_PAIR pCurPair;

    // find the EOL
    pCurPair = MsvpAvlGet(pAvList, MsvAvEOL, cAvList);
    if( pCurPair == NULL )
        return NULL;

    //
    // append the new AvPair (assume the buffer is long enough!)
    //

    pCurPair->AvId = (USHORT)AvId;
    pCurPair->AvLen = (USHORT)pString->Length;
    memcpy(pCurPair+1, pString->Buffer, pCurPair->AvLen);

    // top it off with a new EOL
    pCurPair = (PMSV1_0_AV_PAIR)((PUCHAR)pCurPair + sizeof(MSV1_0_AV_PAIR) + pCurPair->AvLen);
    pCurPair->AvId = MsvAvEOL;
    pCurPair->AvLen = 0;

    return pCurPair;
}


// MsvpAvlSize -- fucntion to calculate length needed for an AV list
ULONG
MsvpAvlSize(
    IN ULONG iPairs,            // number of AV pairs response will include
    IN ULONG iPairsLen          // total size of values for the pairs
    )
{
    return (
        iPairs * sizeof(MSV1_0_AV_PAIR) +   // space for the pairs' headers
        iPairsLen +                         // space for pairs' values
        sizeof(MSV1_0_AV_PAIR)              // space for the EOL
        );
}

NTSTATUS
MsvpAvlToString(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  LPWSTR *szAvlString
    )
{
    PMSV1_0_AV_PAIR pAV;
    MSV1_0_AV_PAIR AV = {0};

    *szAvlString = NULL;

    if ( AvlString->Buffer == NULL || AvlString->Length == 0 )
    {
        return STATUS_SUCCESS;
    }

    pAV = MsvpAvlGet(
            (PMSV1_0_AV_PAIR)AvlString->Buffer,
            AvId,
            AvlString->Length
            );

    if ( pAV != NULL )
    {
        LPWSTR szResult;

        RtlCopyMemory(&AV, pAV, sizeof(AV));

        szResult = NtLmAllocate( AV.AvLen + sizeof(WCHAR) );
        if ( szResult == NULL )
        {
            SspPrint(( SSP_CRITICAL, "MsvpAvlToString: Error allocating memory\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory( szResult, ( pAV + 1 ), AV.AvLen );
        szResult[ AV.AvLen /sizeof(WCHAR) ] = L'\0';
        *szAvlString = szResult;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MsvpAvlToFlag(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  ULONG *ulAvlFlag
    )
{
    PMSV1_0_AV_PAIR pAV;

    *ulAvlFlag = 0;

    if ( AvlString->Buffer == NULL || AvlString->Length == 0 )
    {
        return STATUS_SUCCESS;
    }

    pAV = MsvpAvlGet(
                (PMSV1_0_AV_PAIR)AvlString->Buffer,
                AvId,
                AvlString->Length
                );

    if ( pAV != NULL )
    {
        if( pAV->AvLen == sizeof( *ulAvlFlag ) )
        {
            CopyMemory( ulAvlFlag, (pAV+1), sizeof(ULONG) );
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\nlpcache.h ===
/*++

Copyright (c) 1991 - 1999  Microsoft Corporation

Module Name:

    nlpcache.h

Abstract:

    Structures and prototypes for nlpcache.c

Author:

    Richard L Firth (rfirth) 17-Mar-1992

Revision History:
  Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlpcache.h

--*/

#define CACHE_NAME          L"\\Registry\\Machine\\Security\\Cache"
#define CACHE_NAME_SIZE     (sizeof(CACHE_NAME) - sizeof(L""))
#define CACHE_TITLE_INDEX   100 // ?


//
// CACHE_PASSWORDS - passwords are stored (in secret storage) as two encrypted
// one way function (OWF) passwords concatenated together. They must be fixed
// length
//

typedef struct _CACHE_PASSWORDS {
    USER_INTERNAL1_INFORMATION SecretPasswords;
} CACHE_PASSWORDS, *PCACHE_PASSWORDS;

//
// LOGON_CACHE_ENTRY - this is what we store in the cache. We don't need to
// cache all the fields from the NETLOGON_VALIDATION_SAM_INFO - just the ones
// we can't easily invent.
//
// There is additional data following the end of the structure: There are
// <GroupCount> GROUP_MEMBERSHIP structures, followed by a SID which is the
// LogonDomainId. The rest of the data in the entry is the buffer areas for
// the UNICODE_STRING fields
//

typedef struct _LOGON_CACHE_ENTRY {
    USHORT  UserNameLength;
    USHORT  DomainNameLength;
    USHORT  EffectiveNameLength;
    USHORT  FullNameLength;

    USHORT  LogonScriptLength;
    USHORT  ProfilePathLength;
    USHORT  HomeDirectoryLength;
    USHORT  HomeDirectoryDriveLength;

    ULONG   UserId;
    ULONG   PrimaryGroupId;
    ULONG   GroupCount;
    USHORT  LogonDomainNameLength;

    //
    // The following fields are present in NT1.0A release and later
    // systems.
    //

    USHORT          LogonDomainIdLength; // was Unused1
    LARGE_INTEGER   Time;
    ULONG           Revision;
    ULONG           SidCount;   // was Unused2
    BOOLEAN         Valid;

    //
    // The following fields are present for NT 3.51 since build 622
    //

    CHAR            Unused[3];
    ULONG           SidLength;

    //
    // The following fields have been present (but zero) since NT 3.51.
    //  We started filling it in in NT 5.0
    //
    ULONG           LogonPackage; // The RPC ID of the package doing the logon.
    USHORT          DnsDomainNameLength;
    USHORT          UpnLength;

    //
    // The following fields were added for NT5.0 build 2053.
    //

    //
    // define a 128bit random key for this cache entry.  This is used
    // in conjunction with a per-machine LSA secret to derive an encryption
    // key used to encrypt CachePasswords & Opaque data.
    //

    CHAR            RandomKey[ 16 ];
    CHAR            MAC[ 16 ];      // encrypted data integrity check.

    //
    // store the CACHE_PASSWORDS with the cache entry, encrypted using
    // the RandomKey & per-machine LSA secret.
    // this improves performance and eliminates problems with storing data
    // in 2 locations.
    //
    // note: data from this point forward is encrypted and protected from
    // tampering via HMAC.  This includes the data marshalled beyond the
    // structure.
    //

    CACHE_PASSWORDS CachePasswords;

    //
    // Length of opaque supplemental cache data.
    //

    ULONG           SupplementalCacheDataLength;

    //
    // offset from LOGON_CACHE_ENTRY to SupplementalCacheData.
    //


    ULONG           SupplementalCacheDataOffset;


    //
    // Used for special cache properties, e.g. MIT cached logon.
    //
    ULONG           CacheFlags;

    //
    // LogonServer that satisfied the logon.
    //

    ULONG           LogonServerLength;  // was Spare2

    //
    // spare slots for future data, to potentially avoid revising the structure
    //


    ULONG           Spare3;
    ULONG           Spare4;
    ULONG           Spare5;
    ULONG           Spare6;


} LOGON_CACHE_ENTRY, *PLOGON_CACHE_ENTRY;


//
// pre-NT5 versions of the LOGON_CACHE_ENTRY structure, for sizing and
// field mapping purposes for backwards compatibility.
//

typedef struct _LOGON_CACHE_ENTRY_NT_4_SP4 {
    USHORT  UserNameLength;
    USHORT  DomainNameLength;
    USHORT  EffectiveNameLength;
    USHORT  FullNameLength;

    USHORT  LogonScriptLength;
    USHORT  ProfilePathLength;
    USHORT  HomeDirectoryLength;
    USHORT  HomeDirectoryDriveLength;

    ULONG   UserId;
    ULONG   PrimaryGroupId;
    ULONG   GroupCount;
    USHORT  LogonDomainNameLength;

    //
    // The following fields are present in NT1.0A release and later
    // systems.
    //

    USHORT          LogonDomainIdLength; // was Unused1
    LARGE_INTEGER   Time;
    ULONG           Revision;
    ULONG           SidCount;   // was Unused2
    BOOLEAN         Valid;

    //
    // The following fields are present for NT 3.51 since build 622
    //

    CHAR            Unused[3];
    ULONG           SidLength;

    //
    // The following fields have been present (but zero) since NT 3.51.
    //  We started filling it in in NT 5.0
    //
    ULONG           LogonPackage; // The RPC ID of the package doing the logon.
    USHORT          DnsDomainNameLength;
    USHORT          UpnLength;

} LOGON_CACHE_ENTRY_NT_4_SP4, *PLOGON_CACHE_ENTRY_NT_4_SP4;

#if 0

//
// NT1.0 logon structure.  left here for reference only.
//
typedef struct _LOGON_CACHE_ENTRY_1_0 {
    USHORT  UserNameLength;
    USHORT  DomainNameLength;
    USHORT  EffectiveNameLength;
    USHORT  FullNameLength;

    USHORT  LogonScriptLength;
    USHORT  ProfilePathLength;
    USHORT  HomeDirectoryLength;
    USHORT  HomeDirectoryDriveLength;

    ULONG   UserId;
    ULONG   PrimaryGroupId;
    ULONG   GroupCount;
    USHORT  LogonDomainNameLength;
} LOGON_CACHE_ENTRY_1_0, *PLOGON_CACHE_ENTRY_1_0;

#endif


//
// Windows2000 cached logon request structs
// Updated version in NTLMSV1_0.h
//
typedef struct _MSV1_0_CACHE_LOGON_REQUEST_OLD {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PVOID LogonInformation;
    PVOID ValidationInformation;
} MSV1_0_CACHE_LOGON_REQUEST_OLD, *PMSV1_0_CACHE_LOGON_REQUEST_OLD;

typedef struct _MSV1_0_CACHE_LOGON_REQUEST_W2K {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PVOID LogonInformation;
    PVOID ValidationInformation;
    PVOID SupplementalCacheData;
    ULONG SupplementalCacheDataLength;
} MSV1_0_CACHE_LOGON_REQUEST_W2K, *PMSV1_0_CACHE_LOGON_REQUEST_W2K;

//
// net logon cache prototypes
//

NTSTATUS
NlpCacheInitialize(
    VOID
    );

NTSTATUS
NlpCacheTerminate(
    VOID
    );

NTSTATUS
NlpAddCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN  PVOID SupplementalCacheData,
    IN  ULONG SupplementalCacheDataLength,
    IN  ULONG CacheFlags
    );

NTSTATUS
NlpGetCacheEntry(
    IN PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    IN ULONG CacheLookupFlags,
    OUT OPTIONAL PUNICODE_STRING CredentialDomainName, // domain/realm name
    OUT OPTIONAL PUNICODE_STRING CredentialUserName,
    OUT PNETLOGON_VALIDATION_SAM_INFO4* AccountInfo,
    OUT PCACHE_PASSWORDS Passwords,
    OUT OPTIONAL PVOID *ppSupplementalCacheData,
    OUT OPTIONAL PULONG pSupplementalCacheDataLength
    );

NTSTATUS
NlpDeleteCacheEntry(
    IN NTSTATUS FailedStatus,
    IN USHORT Authoritative,
    IN USHORT LogonType,
    IN BOOLEAN InvalidatedByNtlm,
    IN PNETLOGON_INTERACTIVE_INFO LogonInfo
    );

NTSTATUS
NlpChangeCachePassword(
    IN BOOLEAN Validated,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    );

NTSTATUS
NlpComputeSaltedHashedPassword(
    OUT PNT_OWF_PASSWORD SaltedOwfPassword,
    IN PNT_OWF_PASSWORD OwfPassword,
    IN PUNICODE_STRING UserName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlmcomn.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmcomn.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:
    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\ntlmcomn.h

--*/

#ifndef _NTLMCOMN_INCLUDED_
#define _NTLMCOMN_INCLUDED_

////////////////////////////////////////////////////////////////////////////
//
// Common include files needed by ALL NtLmSsp files
//
////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <ntmsv1_0.h>   // MSV 1.0 Authentication Package

#include <security.h>   // General definition of a Security Support Provider
#include <spseal.h>     // Prototypes for Seal & Unseal

#include <ntlmssp.h>    // External definition of the NtLmSsp service
#include <lmcons.h>
#include <debug.h>      // NtLmSsp debugging


////////////////////////////////////////////////////////////////////////
//
// Global Definitions
//
////////////////////////////////////////////////////////////////////////

#define NTLMSSP_KEY_SALT    0xbd


//
// Procedure forwards from utility.cxx
//

#if DBG

NTSTATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    );
#else
#define SspNtStatusToSecStatus( x, y ) (x)
#endif


BOOLEAN
SspTimeHasElapsed(
    IN ULONG StartTime,
    IN ULONG Timeout
    );

NTSTATUS
SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken
    );

LPWSTR
SspAllocWStrFromWStr(
    IN LPWSTR Unicode
    );

VOID
SspHidePassword(
    IN OUT PUNICODE_STRING Password
    );

VOID
SspRevealPassword(
    IN OUT PUNICODE_STRING HiddenPassword
    );

BOOLEAN
SspGetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    );

//
// Procedure forwards from credhand.cxx
//

NTSTATUS
SsprAcquireCredentialHandle(
    IN PLUID LogonId,
    IN PSECPKG_CLIENT_INFO ClientInfo,
    IN ULONG CredentialUseFlags,
    OUT PULONG_PTR CredentialHandle,
    OUT PTimeStamp Lifetime,
    IN OPTIONAL PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING UserName,
    IN OPTIONAL PUNICODE_STRING Password
    );

//
// Procedure forwards from context.cxx
//

PSSP_CONTEXT
SspContextAllocateContext(
    VOID
    );

NTSTATUS
SspContextGetMessage(
    IN PVOID InputMessage,
    IN ULONG InputMessageSize,
    IN NTLM_MESSAGE_TYPE ExpectedMessageType,
    OUT PVOID* OutputMessage
    );

BOOLEAN
SspConvertRelativeToAbsolute (
    IN PVOID MessageBase,
    IN ULONG MessageSize,
    IN PSTRING32 StringToRelocate,
    IN PSTRING OutputString,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString
    );

VOID
SspContextCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING32 OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    );

BOOL
SsprCheckMinimumSecurity(
    IN ULONG NegotiateFlags,
    IN ULONG MinimumSecurityFlags
    );

SECURITY_STATUS
SspContextReferenceContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext,
    OUT PSSP_CONTEXT *ContextResult
    );

VOID
SspContextDereferenceContext(
    PSSP_CONTEXT Context
    );

VOID
SspContextCopyStringAbsolute(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    );

SECURITY_STATUS
SsprMakeSessionKey(
    IN  PSSP_CONTEXT Context,
    IN  PSTRING LmChallengeResponse,
    IN  UCHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH], // from the DC or GetChalResp
    IN  UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH],     // from the DC of GetChalResp
    IN  PSTRING DatagramSessionKey
    );

NTSTATUS
SsprQueryTreeName(
    OUT  PUNICODE_STRING TreeName
    );

NTSTATUS
SsprUpdateTargetInfo(
    VOID
    );

TimeStamp
SspContextGetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN BOOLEAN GetExpirationTime
    );

VOID
SspContextSetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN LARGE_INTEGER ExpirationTime
    );

//
// Procedure forwards from ctxtcli.cxx
//

NTSTATUS
SsprHandleFirstCall(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN PUNICODE_STRING TargetServerName OPTIONAL,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    );


NTSTATUS
SsprHandleNegotiateMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    );

//
// Procedure forwards from ctxtsrv.cxx
//

NTSTATUS
SsprHandleChallengeMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN PUNICODE_STRING TargetServerName, OPTIONAL
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    IN OUT PULONG SecondOutputTokenSize,
    OUT PVOID *SecondOutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    );

NTSTATUS
SsprHandleAuthenticateMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags,
    OUT PHANDLE TokenHandle,
    OUT PNTSTATUS SubStatus,
    OUT PTimeStamp PasswordExpiry,
    OUT PULONG UserFlags
    );

NTSTATUS
SsprDeleteSecurityContext (
    ULONG_PTR ContextHandle
    );

BOOL
SspEnableAllPrivilegesToken(
    IN  HANDLE ClientTokenHandle
    );

//
// Procedure forwards from encrypt.cxx
//

BOOLEAN
IsEncryptionPermitted(VOID);

//
// Procedure forwards from userapi.cxx
//

NTSTATUS
SspMapContext(
    IN PULONG_PTR phContext,
    IN PUCHAR pSessionKey,
    IN ULONG NegotiateFlags,
    IN HANDLE TokenHandle,
    IN PTimeStamp PasswordExpiry OPTIONAL,
    IN ULONG UserFlags,
    OUT PSecBuffer ContextData
    );

//
// procedure forwards from nlmain.c
//

NTSTATUS
SspAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    );

#endif // ifndef _NTLMCOMN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlmfunc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        ntlmfunc.h
//
// Contents:    prototypes for export functions as in secpkg.h
//
//
// History:     ChandanS  26-Jul-96   Stolen from kerberos\client2\kerbfunc.h
//
//------------------------------------------------------------------------

#ifndef __NTLMFUNC_H__
#define __NTLMFUNC_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

SpInitializeFn                  SpInitialize;
SpGetInfoFn                     SpGetInfo;
LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH LsaApCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation ;
SpSetExtendedInformationFn      SpSetExtendedInformation ;
SpQueryContextAttributesFn      SpQueryLsaModeContextAttributes;
SpSetContextAttributesFn        SpSetContextAttributes;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes ;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __NTLMFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlmsspi.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmsspi.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:
    ChandanS  03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\ntlmsspi.h

--*/

#ifndef _NTLMSSPI_INCLUDED_
#define _NTLMSSPI_INCLUDED_

//
// init.c will #include this file with NTLMCOMN_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef NTLMSSPI_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Global Definitions
//
////////////////////////////////////////////////////////////////////////

//
// Description of a credential.
//

#define SSP_CREDENTIAL_TAG_ACTIVE  (ULONG)('AdrC')
#define SSP_CREDENTIAL_TAG_DELETE  (ULONG)('DdrC')

#define SSP_CREDENTIAL_FLAG_WAS_NETWORK_SERVICE 0x1

typedef struct _SSP_CREDENTIAL {

    //
    // Global list of all Credentials.
    //  (Serialized by SspCredentialCritSect)
    //

    LIST_ENTRY Next;

    //
    // Used to prevent this Credential from being deleted prematurely.
    //  (Serialized by SspCredentialCritSect)
    //

    ULONG References;

    //
    // Flag of how credential may be used.
    //
    // SECPKG_CRED_* flags
    //

    ULONG CredentialUseFlags;

    //
    // Logon ID of the client
    //

    LUID LogonId;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;

    //
    // Tag indicating credential is valid for fast reference.
    //

    ULONG CredentialTag;

    //
    // Impersonation level of caller at time of AcquireCredentialsHandle
    //

    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;

    //
    // Default credentials on client context, on server context UserName
    // holds a full user name (domain\user) and the other two should be
    // NULL.
    //

    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;

    //
    // This flag should be set when the credential is unlinked
    // from the list.
    //

    BOOLEAN Unlinked;

    //
    // This flag is set when the credential was granted to a
    // kernel mode caller
    //

    BOOLEAN KernelClient;

    //
    // ntlm specific credential usage flags
    //

    ULONG MutableCredFlags;

} SSP_CREDENTIAL, *PSSP_CREDENTIAL;

typedef enum {
    IdleState,
    NegotiateSentState,    // Outbound context only
    ChallengeSentState,    // Inbound context only
    AuthenticateSentState, // Outbound context only
    AuthenticatedState,    // Inbound context only
    PassedToServiceState   // Outbound context only
} SSP_CONTEXT_STATE, *PSSP_CONTEXT_STATE;

typedef struct _NTLM_VER_INFO {
    ULONG64 Major : 8;
    ULONG64 Minor : 8;
    ULONG64 Build : 16;
    ULONG64 Reserved : 24;
    ULONG64 Revision : 8;
} NTLM_VER_INFO, *PNTLM_VER_INFO;

//
// Description of a Context
//

#define SSP_CONTEXT_TAG_ACTIVE  (ULONG64)('AxtC')
#define SSP_CONTEXT_TAG_DELETE  (ULONG64)('DxtC')

typedef struct _SSP_CONTEXT {

    //
    // Tag indicating context is valid.
    //

    ULONG64 ContextTag;


    //
    // Timeout the context after awhile.
    //
    ULONG TickStart;

    LARGE_INTEGER StartTime;
    ULONG Interval;

    //
    // Used to prevent this Context from being deleted prematurely.
    //  (Serialized by SspContextCritSect)
    //

    ULONG References;



    //
    // Maintain the Negotiated protocol
    //

    ULONG NegotiateFlags;

    //
    // Maintain the context requirements
    //

    ULONG ContextFlags;

    //
    // State of the context
    //

    SSP_CONTEXT_STATE State;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //

    HANDLE TokenHandle;

    //
    // Referenced pointer to the credential used to create this
    // context.
    //

    PSSP_CREDENTIAL Credential;

    //
    // The challenge passed to the client.
    //  Only valid when in ChallengeSentState.
    //

    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];

    //
    // The session key calculated by the LSA
    //

    UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    //
    // Default credentials.
    //

    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;

    //
    // optional marshalled targetinfo for credential manager.
    //

    PCREDENTIAL_TARGET_INFORMATIONW TargetInfo;

    //
    // marshalled target info for DFS/RDR.
    //

    PBYTE       pbMarshalledTargetInfo;
    ULONG       cbMarshalledTargetInfo;

    //
    // context handle referenced to validate loopback operations.
    //

    ULONG_PTR ServerContextHandle;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;
    NTSTATUS LastStatus;

    BOOLEAN Server;         // client or server ? (can be implied by other fields...)

    BOOLEAN DownLevel;      // downlevel RDR/SRV ?

    //
    // This flag is set when the context was granted to a
    // kernel mode caller
    //

    BOOLEAN KernelClient;

    //
    // version control
    //

    union {
        NTLM_VER_INFO ClientVersion; // stored in server context
        NTLM_VER_INFO ServerVersion; // stored in client context
    };

    CHAR ContextMagicNumber[MSV1_0_USER_SESSION_KEY_LENGTH];

} SSP_CONTEXT, *PSSP_CONTEXT;

//
// Maximum lifetime of a context
//

#if DBG
#define NTLMSSP_MAX_LIFETIME (2*60*60*1000)    // 2 hours
#else
// used to be 2 minutes, changed to 5 minutes to allow negotiation in
// wide-area networks which can have long retry timeouts
#define NTLMSSP_MAX_LIFETIME (5*60*1000)    // 5 minutes
#endif // DBG



typedef struct _SSP_PROCESSOPTIONS {

    //
    // Global list of all process options.
    //  (Serialized by NtLmGlobalProcessOptionsLock
    //

    LIST_ENTRY Next;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;

    //
    // options bitmask.
    //

    ULONG ProcessOptions;

} SSP_PROCESSOPTIONS, *PSSP_PROCESSOPTIONS;



////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////


//
// Procedure forwards from credhand.cxx
//

NTSTATUS
SspCredentialInitialize(
    VOID
    );

VOID
SspCredentialTerminate(
    VOID
    );

NTSTATUS
SspCredentialReferenceCredential(
    IN ULONG_PTR CredentialHandle,
    IN BOOLEAN DereferenceCredential,
    OUT PSSP_CREDENTIAL * UserCredential
    );

VOID
SspCredentialDereferenceCredential(
    PSSP_CREDENTIAL Credential
    );

NTSTATUS
SspCredentialGetPassword(
    IN PSSP_CREDENTIAL Credential,
    OUT PUNICODE_STRING Password
    );

//
// Procedure forwards from context.cxx
//

NTSTATUS
SspContextInitialize(
    VOID
    );

VOID
SspContextTerminate(
    VOID
    );

//
// from ctxtcli.cxx
//

NTSTATUS
CredpParseUserName(
    IN OUT LPWSTR ParseName,
    OUT LPWSTR* pUserName,
    OUT LPWSTR* pDomainName
    );

NTSTATUS
CopyCredManCredentials(
    IN PLUID LogonId,
    IN CREDENTIAL_TARGET_INFORMATIONW* pTargetInfo,
    IN OUT PSSP_CONTEXT Context,
    IN BOOLEAN fShareLevel,
    IN BOOLEAN bAllowOwfPassword,
    OUT BOOLEAN* pbIsOwfPassword
    );

NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    );

NTSTATUS
CredpProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    );

//
// random number generator.
//

NTSTATUS
SspGenerateRandomBits(
    VOID        *pRandomData,
    ULONG       cRandomData
    );

//
// Procedure forwards from ntlm.cxx
//
VOID
NtLmCheckLmCompatibility(
    );

VOID
NtLmQueryMappedDomains(
    VOID
    );

VOID
NtLmFreeMappedDomains(
    VOID
    );


VOID
NTAPI
NtLmQueryDynamicGlobals(
    PVOID pvContext,
    BOOLEAN TimedOut
    );

ULONG
NtLmCheckProcessOption(
    IN  ULONG OptionRequest
    );

BOOLEAN
NtLmSetProcessOption(
    IN  ULONG OptionRequest,
    IN  BOOLEAN DisableOption
    );


//
// Procedure forwards from rng.cxx
//

VOID
NtLmCleanupRNG(VOID);

BOOL
NtLmInitializeRNG(VOID);


/*++

Brief description of the challenge/response algorithms for LM, NTLM, and NTLM3

  The basic outline is the same for all versions, just the OWF, RESP, and SESSKEY
  funcs are different:

1. Compute a "response key" (Kr) from the user's name (U), domain (UD) and password (P):

    Kr = OWF(U, UD, P)

2. Compute a response using the response key, server challenge (NS),
    client challenge (NC), timestamp (T), version (V), highest version
    client understands (HV), and the server's principal name (S)

    R = RESP(Kr, NS, NC, T, V, HV, S)

3. Compute a session key from Kr, U, UD

    Kx = SESSKEY(Kr, R, U, UD)


The are the OWF, RESP, and SESSKEY funcs for NTLM3

    OWF(U, UD, P) = MD5(MD4(P), U, UD)
    RESP(Kr, NS, NC, T, V, HV, S) = (V, HV, R, T, NC, HMAC(Kr, (NS, V, HV, T, NC, S)), S)
    SESSKEY(Ku, R, U, UD) = HMAC(Kr, R)

--*/



PMSV1_0_AV_PAIR
MsvpAvlInit(
    IN void * pAvList
    );

PMSV1_0_AV_PAIR
MsvpAvlGet(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to find
    IN LONG cAvList                         // size of AV list
    );

ULONG
MsvpAvlLen(
    IN PMSV1_0_AV_PAIR pAvList,            // first pair of AV pair list
    IN LONG cAvList                        // max size of AV list
    );

PMSV1_0_AV_PAIR
MsvpAvlAdd(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to add
    IN PUNICODE_STRING pString,             // value of pair
    IN LONG cAvList                         // max size of AV list
    );


ULONG
MsvpAvlSize(
    IN ULONG iPairs,            // number of AV pairs response will include
    IN ULONG iPairsLen          // total size of values for the pairs
    );

NTSTATUS
MsvpAvlToString(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  LPWSTR *szAvlString
    );

NTSTATUS
MsvpAvlToFlag(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  ULONG *ulAvlFlag
    );


VOID
MsvpCalculateNtlm2Challenge (
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH]
    );

VOID
MsvpCalculateNtlm2SessionKeys (
    IN PUSER_SESSION_KEY NtUserSessionKey,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PUSER_SESSION_KEY LocalUserSessionKey,
    OUT PLM_SESSION_KEY LocalLmSessionKey
    );


//
// calculate NTLM3 response from credentials and server name
// called with pNtlm3Response filled in with version, client challenge, timestamp
//

VOID
MsvpNtlm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN ULONG ServerNameLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    );

typedef struct {
        UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
        UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM3_RESPONSE, *PMSV1_0_LM3_RESPONSE;

//
// calculate LM3 response from credentials
//

VOID
MsvpLm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    );


NTSTATUS
MsvpLm20GetNtlm3ChallengeResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN PUNICODE_STRING pServerName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    );


#endif // ifndef _NTLMSSPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlm.cxx ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:       ntlm.cxx
//
// Contents:   main entrypoints for the ntlm security package
//               SpLsaModeInitialize
//               SpInitialize
//               SpShutdown
//               SpGetInfo
//
//             Helper functions:
//               NtLmSetPolicyInfo
//               NtLmPolicyChangeCallback
//               NtLmRegisterForPolicyChange
//               NtLmUnregisterForPolicyChange
//
// History:    ChandanS  26-Jul-1996   Stolen from kerberos\client2\kerberos.cxx
//             ChandanS  16-Apr-1998   No reboot on domain name change
//             JClark    28-Jun-2000   Added WMI Trace Logging Support
//
//---------------------------------------------------------------------

// Variables with the EXTERN storage class are declared here
#define NTLM_GLOBAL
#define DEBUG_ALLOCATE

#include <global.h>
#include <wow64t.h>
#include "trace.h"

extern "C"
{

#include "nlp.h"

NTSTATUS
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    );
}

BOOLEAN NtLmCredentialInitialized;
BOOLEAN NtLmContextInitialized;
BOOLEAN NtLmRNGInitialized;

LIST_ENTRY      NtLmProcessOptionsList;
RTL_RESOURCE    NtLmProcessOptionsLock;



//+--------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   This function is called by the LSA when this DLL is loaded.
//              It returns security package function tables for all
//              security packages in the DLL.
//
//  Arguments:  LsaVersion - Version number of the LSA
//              PackageVersion - Returns version number of the package
//              Tables - Returns array of function tables for the package
//              TableCount - Returns number of entries in array of
//                      function tables.
//
//  Returns:    PackageVersion (as above)
//              Tables (as above)
//              TableCount (as above)
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    )
{
#if DBG
    // SspGlobalDbflag = SSP_CRITICAL| SSP_API| SSP_API_MORE |SSP_INIT| SSP_MISC | SSP_NO_LOCAL;
    SspGlobalDbflag = SSP_CRITICAL;
    InitializeCriticalSection(&SspGlobalLogFileCritSect);
#endif
    SspPrint((SSP_API, "Entering SpLsaModeInitialize\n"));

    SECURITY_STATUS Status = SEC_E_OK;

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        SspPrint((SSP_CRITICAL, "Invalid LSA version: %d\n", LsaVersion));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    NtLmFunctionTable.InitializePackage        = NULL;
    NtLmFunctionTable.LogonUser                = NULL;
    NtLmFunctionTable.CallPackage              = LsaApCallPackage;
    NtLmFunctionTable.LogonTerminated          = LsaApLogonTerminated;
    NtLmFunctionTable.CallPackageUntrusted     = LsaApCallPackageUntrusted;
    NtLmFunctionTable.LogonUserEx              = NULL;
    NtLmFunctionTable.LogonUserEx2             = LsaApLogonUserEx2;
    NtLmFunctionTable.Initialize               = SpInitialize;
    NtLmFunctionTable.Shutdown                 = SpShutdown;
    NtLmFunctionTable.GetInfo                  = SpGetInfo;
    NtLmFunctionTable.AcceptCredentials        = SpAcceptCredentials;
    NtLmFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    NtLmFunctionTable.FreeCredentialsHandle    = SpFreeCredentialsHandle;
    NtLmFunctionTable.SaveCredentials          = SpSaveCredentials;
    NtLmFunctionTable.GetCredentials           = SpGetCredentials;
    NtLmFunctionTable.DeleteCredentials        = SpDeleteCredentials;
    NtLmFunctionTable.InitLsaModeContext       = SpInitLsaModeContext;
    NtLmFunctionTable.AcceptLsaModeContext     = SpAcceptLsaModeContext;
    NtLmFunctionTable.DeleteContext            = SpDeleteContext;
    NtLmFunctionTable.ApplyControlToken        = SpApplyControlToken;
    NtLmFunctionTable.GetUserInfo              = SpGetUserInfo;
    NtLmFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes ;
    NtLmFunctionTable.GetExtendedInformation   = SpGetExtendedInformation ;
    NtLmFunctionTable.SetExtendedInformation   = SpSetExtendedInformation ;
    NtLmFunctionTable.CallPackagePassthrough   = LsaApCallPackagePassthrough;
#if 0
    NtLmFunctionTable.QueryContextAttributes   = SpQueryLsaModeContextAttributes;
    NtLmFunctionTable.SetContextAttributes     = SpSetContextAttributes;

    *PackageVersion = SECPKG_INTERFACE_VERSION_2;
#else
    *PackageVersion = SECPKG_INTERFACE_VERSION;
#endif

    *Tables = &NtLmFunctionTable;
    *TableCount = 1;

    //
    // Get the Event Trace logging on board
    //
    NtlmInitializeTrace();

    SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                         SAFEALLOCA_USE_DEFAULT,
                         NtLmAllocate,
                         NtLmFree);

CleanUp:

    SspPrint((SSP_API, "Leaving SpLsaModeInitialize\n"));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   NtlmGetRandomOemName
//
//  Synopsis:   Fix up to get good looking yet pseudo random OEM names
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//+-------------------------------------------------------------------------
VOID
NtlmGetRandomOemName(
    IN ULONG OemNameBufferSize,
    IN OUT CHAR* OemNameBuffer
    )
{
    CHAR Scratch[13] = {0}; // 4 * 3 bytes + an NULL
    CHAR EncodedScratch[((RTL_NUMBER_OF(Scratch) - 1) / 3) * 4 + 1] = {0}; // 4 * 4 bytes + an NULL

    const UCHAR abEncode[] =
            /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            /* 26 thru 51: */ "!($%)'*+,-./:;#=&?[]_^{}|~"
            /* 52 thru 61: */ "0123456789"
            /* 62 and 63: */  "<>";

    C_ASSERT((RTL_NUMBER_OF(abEncode) >= 64));
    C_ASSERT((RTL_NUMBER_OF(Scratch) - 1) % 3 == 0);
    C_ASSERT(RTL_NUMBER_OF(EncodedScratch) > CNLEN);
    
    SspGenerateRandomBits(Scratch, RTL_NUMBER_OF(Scratch) - 1);

    ASSERT(OemNameBufferSize >= CNLEN);

    if (OemNameBufferSize < CNLEN) 
    {
        OemNameBuffer[OemNameBufferSize - 1] = '\0';
        return;
    }

    for (ULONG j = 0; j < (RTL_NUMBER_OF(Scratch) - 1) / 3; j++)  
    {
        EncodedScratch[j * 4 + 0] = RtlUpperChar(abEncode[(Scratch[j * 3 + 0] >> 2) & 0x3f]); // first 6 bits
        EncodedScratch[j * 4 + 1] = RtlUpperChar(abEncode[((Scratch[j * 3 + 0] << 4) | (Scratch[j * 3 + 1] >> 4)) & 0x3f]); // the second 6 bits
        EncodedScratch[j * 4 + 2] = RtlUpperChar(abEncode[((Scratch[j * 3 + 1] << 2) | (Scratch[j * 3 + 2] >> 6)) & 0x3f]); // the third 6 bits
        EncodedScratch[j * 4 + 3] = RtlUpperChar(abEncode[Scratch[j * 3 + 2] & 0x3f]); // the last 6 bits
    }

    RtlCopyMemory(OemNameBuffer, EncodedScratch, CNLEN - 1); 
    OemNameBuffer[CNLEN - 1] = '\0';
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmSetPolicyInfo
//
//  Synopsis:   Function to be called when policy changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//        if fInit is TRUE, this is called by the init routine in ntlm
//
//
//+-------------------------------------------------------------------------
NTSTATUS
NtLmSetPolicyInfo(
    IN PUNICODE_STRING DnsComputerName,
    IN PUNICODE_STRING ComputerName,
    IN PUNICODE_STRING DnsDomainName,
    IN PUNICODE_STRING DomainName,
    IN PSID DomainSid,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass,
    IN BOOLEAN fInit
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Buffers to delete on cleanup

    STRING ComputerNameAnsiString;
    STRING DomainNameAnsiString;

    UNICODE_STRING DnsTreeName = {0};

    ComputerNameAnsiString.Buffer = NULL;
    DomainNameAnsiString.Buffer = NULL;

    static TimeStamp NtlmSetPolicyInfoTime = {0};
    static ULONG NumOfUpdatedLuids = 0;

    NtQuerySystemTime(&NtlmSetPolicyInfoTime);
    
    //
    // grab the treename.  don't do this during Init, because the SAM
    // isn't initialized yet.
    //

    if (!fInit)
    {
        Status = SsprQueryTreeName( &DnsTreeName );
    }

    RtlAcquireResourceExclusive(&NtLmGlobalCritSect, TRUE);

    if (!fInit && NT_SUCCESS( Status ))
    {
        if ( NtLmGlobalUnicodeDnsTreeName.Buffer != NULL )
        {
            NtLmFree( NtLmGlobalUnicodeDnsTreeName.Buffer );
        }

        RtlCopyMemory(&NtLmGlobalUnicodeDnsTreeName, &DnsTreeName, sizeof(DnsTreeName));
    }

    //
    // Do this only if this is package init
    //

    if (fInit)
    {
        if (ComputerName && ComputerName->Buffer != NULL)
        {
            ULONG cLength = ComputerName->Length / sizeof(WCHAR);

            if ((ComputerName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodeComputerName))
            {
                // Bad ComputerName
                Status = STATUS_INVALID_COMPUTER_NAME;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad computer name length is %d\n", cLength));
                goto CleanUp;
            }

            wcsncpy(NtLmGlobalUnicodeComputerName,
               ComputerName->Buffer,
               cLength);

            NtLmGlobalUnicodeComputerName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodeComputerNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodeComputerNameString,
                                   NtLmGlobalUnicodeComputerName );

            // Save old buffers for deleting
            ComputerNameAnsiString = NtLmGlobalOemComputerNameString;

            Status = RtlUpcaseUnicodeStringToOemString(
                        &NtLmGlobalOemComputerNameString,
                        &NtLmGlobalUnicodeComputerNameString,
                        TRUE );

            if ( !NT_SUCCESS(Status) ) {
                                
                ComputerNameAnsiString.Buffer = NULL;
                
                NtlmGetRandomOemName(RTL_NUMBER_OF(NtLmGlobalOemComputerName), NtLmGlobalOemComputerName);

                RtlInitString(&NtLmGlobalOemComputerNameString, NtLmGlobalOemComputerName);

                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo error from RtlUpcaseUnicodeStringToOemString is %#x, random computer name is %s\n", 
                    Status, NtLmGlobalOemComputerName));

                ASSERT(!L"Non OEM compatible computer name encountered");

                Status = STATUS_SUCCESS;

                // goto CleanUp;
            }
        }
    }

    //
    // Initialize various forms of the primary domain name of the local system
    // Do this only if this is package init or it's DnsDomain info
    //

    if (fInit || (ChangedInfoClass == PolicyNotifyDnsDomainInformation))
    {
        if (DnsComputerName && DnsComputerName->Buffer != NULL ) {
            ULONG cLength = DnsComputerName->Length / sizeof(WCHAR);

            if((DnsComputerName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodeDnsComputerName))
            {
                // Bad ComputerName
                Status = STATUS_INVALID_COMPUTER_NAME;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad computer name length is %d\n", cLength));
                goto CleanUp;
            }

            wcsncpy(NtLmGlobalUnicodeDnsComputerName,
               DnsComputerName->Buffer,
               cLength);

            NtLmGlobalUnicodeDnsComputerName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodeDnsComputerNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodeDnsComputerNameString,
                                   NtLmGlobalUnicodeDnsComputerName );
        }

        if (DnsDomainName && DnsDomainName->Buffer != NULL ) {
            ULONG cLength = DnsDomainName->Length / sizeof(WCHAR);

            if((DnsDomainName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodeDnsDomainName))
            {
                // Bad ComputerName
                Status = STATUS_INVALID_COMPUTER_NAME;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad domain name length is %d\n", cLength));
                goto CleanUp;
            }

            wcsncpy(NtLmGlobalUnicodeDnsDomainName,
               DnsDomainName->Buffer,
               cLength);

            NtLmGlobalUnicodeDnsDomainName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodeDnsDomainNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodeDnsDomainNameString,
                                   NtLmGlobalUnicodeDnsDomainName );
        }

        if (DomainName && DomainName->Buffer != NULL)
        {
            ULONG cLength = DomainName->Length / sizeof(WCHAR);

            if ((DomainName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodePrimaryDomainName))
            {
                Status = STATUS_NAME_TOO_LONG;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad domain name length is %d\n", cLength));
                goto CleanUp;
            }
            wcsncpy(NtLmGlobalUnicodePrimaryDomainName,
               DomainName->Buffer,
               cLength);
            NtLmGlobalUnicodePrimaryDomainName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodePrimaryDomainNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodePrimaryDomainNameString,
                                   NtLmGlobalUnicodePrimaryDomainName );

            // Save old buffers for deleting
            DomainNameAnsiString = NtLmGlobalOemPrimaryDomainNameString;

            Status = RtlUpcaseUnicodeStringToOemString(
                        &NtLmGlobalOemPrimaryDomainNameString,
                        &NtLmGlobalUnicodePrimaryDomainNameString,
                        TRUE );

            if ( !NT_SUCCESS(Status) ) {

                DomainNameAnsiString.Buffer = NULL;
                
                NtlmGetRandomOemName(RTL_NUMBER_OF(NtLmGlobalOemPrimaryDomainName), NtLmGlobalOemPrimaryDomainName);

                RtlInitString(&NtLmGlobalOemPrimaryDomainNameString, NtLmGlobalOemPrimaryDomainName);

                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo error from RtlUpcaseUnicodeStringToOemString is %#x, random domain name is %s\n", 
                     Status, NtLmGlobalOemPrimaryDomainName));

                ASSERT(!L"Non OEM compatible domain name encountered");

                Status = STATUS_SUCCESS;

                // goto CleanUp;
            }
        }
    }

    //
    // If this is a standalone windows NT workstation,
    // use the computer name as the Target name.
    //

    if ( DomainSid != NULL)
    {
        NtLmGlobalUnicodeTargetName = NtLmGlobalUnicodePrimaryDomainNameString;
        NtLmGlobalOemTargetName = NtLmGlobalOemPrimaryDomainNameString;
        NtLmGlobalTargetFlags = NTLMSSP_TARGET_TYPE_DOMAIN;
        NtLmGlobalDomainJoined = TRUE;
    }
    else
    {
        NtLmGlobalUnicodeTargetName = NtLmGlobalUnicodeComputerNameString;
        NtLmGlobalOemTargetName = NtLmGlobalOemComputerNameString;
        NtLmGlobalTargetFlags = NTLMSSP_TARGET_TYPE_SERVER;
        NtLmGlobalDomainJoined = FALSE;
    }

    //
    // update the GlobalNtlm3 targetinfo.
    //

    Status = SsprUpdateTargetInfo();

    if (!NT_SUCCESS(Status)) 
    {
        goto CleanUp;
    }

    //
    // update the domain names and credentials if this is the really policy callback
    //

    if (!fInit) 
    {
        PACTIVE_LOGON ActiveLogon = NULL;
        LUID MachineSecretLuids[] = {NETWORKSERVICE_LUID, NtLmGlobalLuidMachineLogon};
        
        PMSV1_0_PRIMARY_CREDENTIAL PrimaryCredential = NULL;
        ULONG PrimaryCredentialSize = 0;
        PMSV1_0_PRIMARY_CREDENTIAL NewPrimaryCredential = NULL;
        ULONG NewPrimaryCredentialSize = 0;
        PACTIVE_LOGON NewActiveLogon = NULL;
        ULONG NewActiveLogonSize = 0;
        UCHAR* Where = NULL;
    
        NlpLockActiveLogonsWrite();

        for (ULONG i = 0; i < RTL_NUMBER_OF(MachineSecretLuids); i++) 
        {
            if (PrimaryCredential) 
            { 
                RtlZeroMemory(PrimaryCredential, PrimaryCredentialSize);
                LsaFunctions->FreeLsaHeap( PrimaryCredential );
                PrimaryCredential = NULL;
                PrimaryCredentialSize = 0;
            }

            if (NewPrimaryCredential) 
            { 
                RtlZeroMemory(NewPrimaryCredential, NewPrimaryCredentialSize);
                LsaFunctions->FreeLsaHeap( NewPrimaryCredential );
                NewPrimaryCredential = NULL;
                NewPrimaryCredentialSize = 0;
            }

            if (NewActiveLogon) 
            {
                I_NtLmFree(NewActiveLogon);
                NewActiveLogon = NULL;
            }
    
            ActiveLogon = NlpFindActiveLogon(MachineSecretLuids + i);
            
            if (ActiveLogon)
            {
                //
                // check for fake update
                //
    
                if (RtlEqualDomainName(
                        &ActiveLogon->LogonDomainName, 
                        &NtLmGlobalUnicodePrimaryDomainNameString
                        )) 
                {
                    SspPrint((SSP_UPDATES, "NtLmSetPolicyInfo domain name %wZ not really changed\n", &ActiveLogon->LogonDomainName));
                    Status = STATUS_SUCCESS;
                    break;
                }
                else
                {
                    SspPrint((SSP_UPDATES, 
                        "NtLmSetPolicyInfo domain name of %#x:%#x is changed from %wZ to %wZ\n", 
                        ActiveLogon->LogonId.HighPart, ActiveLogon->LogonId.LowPart,
                        &ActiveLogon->LogonDomainName,
                        &NtLmGlobalUnicodePrimaryDomainNameString));
                }

                //
                // Allocate an entry for the active logon table.
                //
            
                NewActiveLogonSize = ROUND_UP_COUNT(sizeof(ACTIVE_LOGON), ALIGN_QUAD) 
                      + ROUND_UP_COUNT(RtlLengthSid(ActiveLogon->UserSid), ALIGN_QUAD) 
                      + ActiveLogon->UserName.Length + sizeof(WCHAR)
                      + NtLmGlobalUnicodePrimaryDomainNameString.Length + sizeof(WCHAR)
                      + ActiveLogon->LogonServer.Length + sizeof(WCHAR);

                NewActiveLogon = (ACTIVE_LOGON*) I_NtLmAllocate( NewActiveLogonSize );

                if ( NewActiveLogon == NULL )
                {
                    Status = STATUS_NO_MEMORY;
                    SspPrint((SSP_CRITICAL, "NtlmSetPolicyInfo %#x No memory %#x\n", i, NewActiveLogonSize));
                    break;
                }

                //
                // Fill in the logon table entry
                //

                Where = (PUCHAR) (NewActiveLogon + 1);
                NewActiveLogon->Signature = NTLM_ACTIVE_LOGON_MAGIC_SIGNATURE;

                OLD_TO_NEW_LARGE_INTEGER(
                    ActiveLogon->LogonId,
                    NewActiveLogon->LogonId );

                NewActiveLogon->Flags = ActiveLogon->Flags;
                NewActiveLogon->LogonType = ActiveLogon->LogonType;

                //
                // copy DWORD aligned fields first
                //

                Where = (UCHAR*) ROUND_UP_POINTER( Where, ALIGN_DWORD );
                Status = RtlCopySid(RtlLengthSid(ActiveLogon->UserSid), (PSID)Where, ActiveLogon->UserSid);

                if ( !NT_SUCCESS(Status) )
                {
                    SspPrint((SSP_CRITICAL, "NtlmSetPolicyInfo: RtlLengthSid for %#x:%#x failed with %#x, NewActiveLogon %p, ActiveLogon %p, Where %p\n", 
                         MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart, Status, NewActiveLogon, ActiveLogon, Where));

                    ASSERT(!L"RtlCopySid should not fail");
                    break;
                }

                NewActiveLogon->UserSid = (PSID) Where;
                Where += RtlLengthSid(ActiveLogon->UserSid);

                //
                // Copy WCHAR aligned fields
                //

                Where = (UCHAR*) ROUND_UP_POINTER( Where, ALIGN_WCHAR );
                NlpPutString( &NewActiveLogon->UserName,
                              &ActiveLogon->UserName,
                              &Where );

                NlpPutString( &NewActiveLogon->LogonDomainName,
                              &NtLmGlobalUnicodePrimaryDomainNameString, // new domain name
                              &Where );

                NlpPutString( &NewActiveLogon->LogonServer,
                              &ActiveLogon->LogonServer,
                              &Where );

                //
                // Get the next enumeration handle for this session
                //

                NewActiveLogon->EnumHandle = ActiveLogon->EnumHandle;

                //
                // remove the old entry
                // 

                RemoveEntryList(&ActiveLogon->ListEntry);

                //
                // Insert new entry into the active logon table
                //

                InsertTailList(&NlpActiveLogonListAnchor, &NewActiveLogon->ListEntry);

                //
                // release ownership
                //

                NewActiveLogon = NULL;

                I_NtLmFree(ActiveLogon);

                ActiveLogon = NULL;

                //
                // Update credentials as well
                //
        
                Status = NlpGetPrimaryCredential( MachineSecretLuids + i,
                            &PrimaryCredential,
                            &PrimaryCredentialSize );
        
                if ( !NT_SUCCESS(Status) )
                {
                    SspPrint((SSP_WARNING, "NtlmSetPolicyInfo: NlpDeletePrimaryCredential for %#x:%#x failed with %#x\n", 
                        MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart, Status));

                    Status = STATUS_SUCCESS;
                    continue;
                }
        
                ASSERT(PrimaryCredential && L"Should have PrimaryCredential at this point");
    
                Status = NlpMakePrimaryCredential(
                             &NtLmGlobalUnicodePrimaryDomainNameString,
                             &NtLmGlobalUnicodeComputerNameString,
                             &NtLmGlobalUnicodeComputerNameString, // ok use machine name as password
                             &NewPrimaryCredential,
                             &NewPrimaryCredentialSize
                             );
                if ( !NT_SUCCESS(Status) )
                {
                    SspPrint((SSP_CRITICAL, "NtlmSetPolicyInfo: NlpMakePrimaryCredential for %#x:%#x failed with %#x\n", 
                        MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart, Status));
                    ASSERT(!L"NlpMakePrimaryCredential should not fail");

                    break;
                }

                //
                // set the passwords in it
                //
        
                NewPrimaryCredential->LmPasswordPresent = PrimaryCredential->LmPasswordPresent;
                NewPrimaryCredential->LmOwfPassword = PrimaryCredential->LmOwfPassword;
        
                NewPrimaryCredential->NtPasswordPresent = PrimaryCredential->NtPasswordPresent;
                NewPrimaryCredential->NtOwfPassword = PrimaryCredential->NtOwfPassword;
        
                NewPrimaryCredential->ShaPasswordPresent = PrimaryCredential->ShaPasswordPresent;
                NewPrimaryCredential->ShaOwfPassword = PrimaryCredential->ShaOwfPassword;
        
                ASSERT(NewPrimaryCredential && L"Should have NewPrimaryCredential at this point");
    
                //
                // Delete it from the LSA
                //
        
                Status = NlpDeletePrimaryCredential( MachineSecretLuids + i );
        
                if ( !NT_SUCCESS(Status) )
                {
                    SspPrint((SSP_CRITICAL, "NtlmSetPolicyInfo: NlpDeletePrimaryCredential for %#x:%#x failed with %#x\n", 
                        MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart, Status));
                    ASSERT(!L"NlpDeletePrimaryCredential should not fail");

                    Status = STATUS_SUCCESS;
                    continue;
                }
           
                //
                // Add it back to the LSA.
                //
        
                Status = NlpAddPrimaryCredential(
                            MachineSecretLuids + i,
                            NewPrimaryCredential,
                            NewPrimaryCredentialSize
                            );
                if ( !NT_SUCCESS(Status) )
                {
                    SspPrint((SSP_CRITICAL, "NtlmSetPolicyInfo: NlpAddPrimaryCredential for %#x:%#x failed with %#x\n", 
                        MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart, Status));
                    ASSERT(!L"NlpAddPrimaryCredential should not fail");
                    break;
                }

                SspPrint((SSP_UPDATES, 
                    "NtlmSetPolicyInfo successfully updated %#x:%#x\n", 
                    MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart));

                NumOfUpdatedLuids++;
            }
            else
            {
                SspPrint((SSP_UPDATES, 
                    "NtlmSetPolicyInfo no updates: %#x:%#x does not exist\n", 
                    MachineSecretLuids[i].HighPart, MachineSecretLuids[i].LowPart));
            }
        }
   
        NlpUnlockActiveLogons();

        if (PrimaryCredential) 
        {     
            RtlZeroMemory(PrimaryCredential, PrimaryCredentialSize);
            LsaFunctions->FreeLsaHeap( PrimaryCredential );
        }
        
        if (NewPrimaryCredential) 
        {        
            RtlZeroMemory(NewPrimaryCredential, NewPrimaryCredentialSize);
            LsaFunctions->FreeLsaHeap( NewPrimaryCredential );
        }

        if (NewActiveLogon) 
        {
            I_NtLmFree(NewActiveLogon);
        }
    }

CleanUp:

    RtlReleaseResource(&NtLmGlobalCritSect);

    if (ComputerNameAnsiString.Buffer)
    {
        RtlFreeOemString(&ComputerNameAnsiString);
    }

    if (DomainNameAnsiString.Buffer)
    {
        RtlFreeOemString(&DomainNameAnsiString);
    }

    return Status;
}

NET_API_STATUS
NtLmFlushLogonCache (
   VOID
   )
/*++

Routine Description:

    This function flushes the logon cache.  This is done on unjoin.

    If the cache were not flushed, a user could logon to cached credentials after the unjoin.
    That is especially bad since Winlogon now tries a cached logon to improve boot times.

Return Value:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus;
    HKEY hKey = NULL;

#define NETSETUPP_LOGON_CACHE_PATH   L"SECURITY\\Cache"
#define NETSETUPP_LOGON_CACHE_VALUE  L"NL$Control"


    //
    // Open the key containing the cache
    //

    NetStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              NETSETUPP_LOGON_CACHE_PATH,
                              0,
                              KEY_SET_VALUE,
                              &hKey );

    if ( NetStatus == ERROR_SUCCESS ) {

        //
        // Delete the value describing the size of the cache
        //  This ensures the values cannot be used
        //

        RegDeleteValue( hKey, NETSETUPP_LOGON_CACHE_VALUE );

        RegCloseKey( hKey );
    }

    return NetStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmPolicyChangeCallback
//
//  Synopsis:   Function to be called when domain policy changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID NTAPI
NtLmPolicyChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION Policy = NULL;
    GUID GuidNull = {0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    switch (ChangedInfoClass)
    {
        case PolicyNotifyDnsDomainInformation:
        {

            WCHAR UnicodeDnsComputerName[DNS_MAX_NAME_LENGTH + 1];
            UNICODE_STRING UnicodeDnsComputerNameString;
            ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);

            //
            // Get the new domain information
            //


            Status = I_LsaIQueryInformationPolicyTrusted(
                        PolicyDnsDomainInformation,
                        &Policy
                        );

            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL, "NtLmPolicyChangeCallback, Error from I_LsaIQueryInformationPolicyTrusted is %d\n", Status));
                goto Cleanup;
            }

            if ( Policy->PolicyDnsDomainInfo.DomainGuid == GuidNull )
            {
                NtLmGlobalDownlevelDomain = TRUE;
            }
            else
            {
                NtLmGlobalDownlevelDomain = FALSE;
            }


            //
            // get the new DNS computer name
            //

            if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                                      UnicodeDnsComputerName,
                                      &DnsComputerNameLength ) )
            {
                UnicodeDnsComputerName[ 0 ] = L'\0';
            }

            RtlInitUnicodeString(  &UnicodeDnsComputerNameString,
                               UnicodeDnsComputerName);


            Status = NtLmSetPolicyInfo(
                        &UnicodeDnsComputerNameString,
                        NULL,
                        (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.DnsDomainName,
                        (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.Name,
                        (PSID) Policy->PolicyDnsDomainInfo.Sid,
                        ChangedInfoClass,
                        FALSE);

            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL, "NtLmPolicyChangeCallback, Error from NtLmSetDomainName is %d\n", Status));
                goto Cleanup;
            }

            {
                BOOLEAN FlushLogonCache = FALSE;

                if( NtLmSecPkg.DomainSid == NULL &&
                    Policy->PolicyDnsDomainInfo.Sid != NULL
                    )
                {
                    FlushLogonCache = TRUE;
                }

                if( NtLmSecPkg.DomainSid != NULL &&
                    Policy->PolicyDnsDomainInfo.Sid == NULL
                    )
                {
                    FlushLogonCache = TRUE;
                }

                if( NtLmSecPkg.DomainSid != NULL &&
                    Policy->PolicyDnsDomainInfo.Sid != NULL
                    )
                {
                    if(!RtlEqualSid( NtLmSecPkg.DomainSid, Policy->PolicyDnsDomainInfo.Sid ))
                    {
                        FlushLogonCache = TRUE;
                    }
                }

                if( FlushLogonCache )
                {
                    //
                    // flush the logon cache...
                    //

                    NtLmFlushLogonCache();
                }
            }

        }
        break;
        default:
        break;
    }


Cleanup:

    if (Policy != NULL)
    {
        switch (ChangedInfoClass)
        {
            case PolicyNotifyDnsDomainInformation:
            {
                I_LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyDnsDomainInformation,
                    Policy
                    );
            }
            break;
            default:
            break;
        }
    }
    return;

}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmRegisterForPolicyChange
//
//  Synopsis:   Register with the LSA to be notified of policy changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmRegisterForPolicyChange(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    Status = I_LsaIRegisterPolicyChangeNotificationCallback(
                NtLmPolicyChangeCallback,
                ChangedInfoClass
                );
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL, "NtLmRegisterForPolicyChange, Error from I_LsaIRegisterPolicyChangeNotificationCallback is %d\n", Status));
    }
    SspPrint((SSP_MISC, "I_LsaIRegisterPolicyChangeNotificationCallback called with %d\n", ChangedInfoClass));
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmUnregisterForPolicyChange
//
//  Synopsis:   Unregister for policy change notification
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
NtLmUnregisterForPolicyChange(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    (VOID) I_LsaIUnregisterPolicyChangeNotificationCallback(
                NtLmPolicyChangeCallback,
                ChangedInfoClass
                );

}


//+--------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Initializes the Security package
//
//  Arguments:  PackageId - Contains ID for this package assigned by LSA
//              Parameters - Contains machine-specific information
//              FunctionTable - Contains table of LSA helper routines
//
//  Returns: None
//
//  Notes: Everything that was done in LsaApInitializePackage
//         should be done here. Lsa assures us that only
//         one thread is executing this at a time. Don't
//         have to worry about concurrency problems.
//         Most of the stuff was taken from SspCommonInitialize()
//         from svcdlls\ntlmssp\common\initcomn.c
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpInitialize(
    IN ULONG_PTR PackageId,
    IN PSECPKG_PARAMETERS Parameters,
    IN PLSA_SECPKG_FUNCTION_TABLE FunctionTable
    )
{
    SspPrint((SSP_API, "Entering SpInitialize\n"));

    SECURITY_STATUS Status = SEC_E_OK;
    WCHAR UnicodeComputerName[CNLEN + 1];
    UNICODE_STRING UnicodeComputerNameString;
    ULONG ComputerNameLength =
        (sizeof(UnicodeComputerName)/sizeof(WCHAR));

    WCHAR UnicodeDnsComputerName[DNS_MAX_NAME_LENGTH + 1];
    UNICODE_STRING UnicodeDnsComputerNameString;
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    GUID GuidNull = {0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    //
    // Init the global crit section
    //

    __try
    {
        RtlInitializeResource(&NtLmGlobalCritSect);

        RtlInitializeResource(&NtLmProcessOptionsLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanUp;
    }

    InitializeListHead( &NtLmProcessOptionsList );

    //
    // All the following are global
    //

    NtLmState                  = NtLmLsaMode;
    NtLmPackageId              = PackageId;

    // We really need this to be a day less than maxtime so when callers
    // of sspi convert to utc, they won't get time in the past.

    NtLmGlobalForever.HighPart = 0x7FFFFF36;
    NtLmGlobalForever.LowPart  = 0xD5969FFF;

    //
    // Following are local
    //

    NtLmCredentialInitialized = FALSE;
    NtLmContextInitialized    = FALSE;
    NtLmRNGInitialized        = FALSE;

    //
    // Save away the Lsa functions
    //

    LsaFunctions = FunctionTable;

    //
    // Save the Parameters info
    //

    NtLmSecPkg.MachineState = Parameters->MachineState;
    NtLmSecPkg.SetupMode    = Parameters->SetupMode;

    //
    // allocate a locally unique ID rereferencing the machine logon.
    //

    Status = NtAllocateLocallyUniqueId( &NtLmGlobalLuidMachineLogon );

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtAllocateLocallyUniqueId is %d\n", Status));
        goto CleanUp;
    }

    //
    // create a logon session for the machine logon.
    //
    Status = LsaFunctions->CreateLogonSession( &NtLmGlobalLuidMachineLogon );
    if( !NT_SUCCESS(Status) ) {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from CreateLogonSession is %d\n", Status));
        goto CleanUp;
    }

    Status = NtLmDuplicateUnicodeString(
                                 &NtLmSecPkg.DomainName,
                                 &Parameters->DomainName);

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmDuplicateUnicodeString is %d\n", Status));
        goto CleanUp;
    }

    Status = NtLmDuplicateUnicodeString(
                                 &NtLmSecPkg.DnsDomainName,
                                 &Parameters->DnsDomainName);

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmDuplicateUnicodeString is %d\n", Status));
        goto CleanUp;
    }

    if (Parameters->DomainSid != NULL) {
        Status = NtLmDuplicateSid( &NtLmSecPkg.DomainSid,
                                   Parameters->DomainSid );


        if (!NT_SUCCESS (Status))
        {
            SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmDuplicateSid is %d\n", Status));
            goto CleanUp;
        }
    }

    //
    // Determine if this machine is running NT Workstation or NT Server
    //

    if (!RtlGetNtProductType (&NtLmGlobalNtProductType))
    {
        SspPrint((SSP_API_MORE, "RtlGetNtProductType defaults to NtProductWinNt\n"));
    }

    //
    // Determine if we are running Personal SKU
    //

    {
        OSVERSIONINFOEXW osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
        if(GetVersionExW((OSVERSIONINFOW*)&osvi))
        {
            NtLmGlobalPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL));
        } else {
            SspPrint((SSP_API_MORE, "GetVersionEx defaults to non-personal\n"));
        }
    }


    Status = I_LsaIOpenPolicyTrusted(&NtLmGlobalPolicyHandle);

    if ( !NT_SUCCESS(Status) ) {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from I_LsaIOpenPolicyTrusted is %d\n", Status));
        goto CleanUp;
    }

    if ( !GetComputerNameW( UnicodeComputerName,
                            &ComputerNameLength ) ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from GetComputerNameW is %d\n", Status));
        goto CleanUp;
    }

    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {

        //
        // per CliffV, failure is legal.
        //

        UnicodeDnsComputerName[ 0 ] = L'\0';
    }

    {
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

        Status = RtlAllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_ANONYMOUS_LOGON_RID,
            0, 0, 0, 0, 0, 0, 0,
            &NtLmGlobalAnonymousSid
            );

        if (!NT_SUCCESS(Status))
        {
            goto CleanUp;
        }
    }

    //
    // pickup a copy of the Local System access token.
    //

    {
        HANDLE hProcessToken;
        NTSTATUS StatusToken;

        NtLmGlobalAccessTokenSystem = NULL;

        StatusToken = NtOpenProcessToken(
            NtCurrentProcess(),
            TOKEN_QUERY | TOKEN_DUPLICATE,
            &hProcessToken
            );

        if ( NT_SUCCESS( StatusToken ) )
        {
            TOKEN_STATISTICS LocalTokenStatistics;
            DWORD TokenStatisticsSize = sizeof(LocalTokenStatistics);
            LUID LogonIdSystem = SYSTEM_LUID;

            Status = NtQueryInformationToken(
                hProcessToken,
                TokenStatistics,
                &LocalTokenStatistics,
                TokenStatisticsSize,
                &TokenStatisticsSize
                );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // see if it's SYSTEM.
                //

                if (RtlEqualLuid(
                        &LogonIdSystem,
                        &(LocalTokenStatistics.AuthenticationId)
                        ))
                {
                    Status = SspDuplicateToken(
                        hProcessToken,
                        SecurityImpersonation,
                        &NtLmGlobalAccessTokenSystem
                        );
                }
            }

            NtClose( hProcessToken );
        }
    }

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, could not acquire SYSTEM token %d\n", Status));
        goto CleanUp;
    }

    //
    // Init the Credential stuff
    //

    Status = SspCredentialInitialize();
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from SspCredentialInitializeis %d\n", Status));
        goto CleanUp;
    }
    NtLmCredentialInitialized = TRUE;

    //
    // Init the Context stuff
    //
    Status = SspContextInitialize();
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from SspContextInitializeis %d\n", Status));
        goto CleanUp;
    }
    NtLmContextInitialized = TRUE;

    //
    // Get the locale and check if it is FRANCE, which doesn't allow
    // encryption
    //

    NtLmGlobalEncryptionEnabled = IsEncryptionPermitted();

    //
    // Init the random number generator stuff
    //

    if( !NtLmInitializeRNG() ) {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmInitializeRNG\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto CleanUp;
    }
    NtLmRNGInitialized = TRUE;

    NtLmCheckLmCompatibility();

    if( NtLmSecPkg.DomainSid != NULL )
    {
        NtLmGlobalDomainJoined = TRUE;
    }

    if ( NtLmSecPkg.DomainGuid == GuidNull )
    {
        NtLmGlobalDownlevelDomain = TRUE;
    }
    else
    {
        NtLmGlobalDownlevelDomain = FALSE;
    }

    NtLmQueryMappedDomains();

    //
    // Set all the globals relating to computer name, domain name, sid etc.
    // This routine is also used by the callback for notifications from the lsa
    //

    RtlInitUnicodeString(  &UnicodeComputerNameString,
                           UnicodeComputerName);

    RtlInitUnicodeString(  &UnicodeDnsComputerNameString,
                           UnicodeDnsComputerName);

    Status = NtLmSetPolicyInfo( &UnicodeDnsComputerNameString,
                &UnicodeComputerNameString,
                &NtLmSecPkg.DnsDomainName,
                &NtLmSecPkg.DomainName,
                NtLmSecPkg.DomainSid,
                PolicyNotifyAuditEventsInformation, // Ignored
                TRUE ); // yes, package init

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmSetDomainInfo %d\n", Status));
        goto CleanUp;
    }

    // Do the Init stuff for the MSV authentication package
    // Passing FunctionTable as a (PLSA_DISPATCH_TABLE).
    // Well, the first 11 entries are the same. Cheating a
    // bit.

    Status = LsaApInitializePackage(
                      (ULONG) PackageId,
                      (PLSA_DISPATCH_TABLE)FunctionTable,
                      NULL,
                      NULL,
                      NULL);

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from LsaApInitializePackage is %d\n", Status));
        goto CleanUp;
    }

    Status = NtLmRegisterForPolicyChange(PolicyNotifyDnsDomainInformation);
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmRegisterForPolicyChange is %d\n", Status));
        goto CleanUp;
    }

    Status = SspGenerateRandomBits(NtlmGlobalMagicNumber, MSV1_0_USER_SESSION_KEY_LENGTH);
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, error in generating global magic number\n", Status));
        goto CleanUp;
    }

CleanUp:

    if (!NT_SUCCESS (Status))
    {
        SpShutdown();
    }

    SspPrint((SSP_API, "Leaving SpInitialize\n"));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+--------------------------------------------------------------------
//
//  Function:   SpShutdown
//
//  Synopsis:   Exported function to shutdown the Security package.
//
//  Effects:    Forces the freeing of all credentials, contexts
//              and frees all global data
//
//  Arguments:  none
//
//  Returns:
//
//  Notes:      SEC_E_OK in all cases
//         Most of the stuff was taken from SspCommonShutdown()
//         from svcdlls\ntlmssp\common\initcomn.c
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpShutdown(
    VOID
    )
{
    SspPrint((SSP_API, "Entering SpShutdown\n"));

    //
    // comment out LSA mode cleanup code, per NTBUG 400026,
    // which can result in access violations during shutdown when
    // calls into package are still occuring during shutdown.
    //

#if 0

    if (NtLmContextInitialized)
    {
        SspContextTerminate();
        NtLmContextInitialized = FALSE;
    }

    if (NtLmCredentialInitialized)
    {
        SspCredentialTerminate();
        NtLmCredentialInitialized = FALSE;
    }

    if (NtLmGlobalOemComputerNameString.Buffer != NULL)
    {
        RtlFreeOemString(&NtLmGlobalOemComputerNameString);
        NtLmGlobalOemComputerNameString.Buffer = NULL;
    }

    if (NtLmGlobalOemPrimaryDomainNameString.Buffer != NULL)
    {
        RtlFreeOemString(&NtLmGlobalOemPrimaryDomainNameString);
        NtLmGlobalOemPrimaryDomainNameString.Buffer = NULL;
    }

    if (NtLmGlobalNtLm3TargetInfo.Buffer != NULL)
    {
        NtLmFree (NtLmGlobalNtLm3TargetInfo.Buffer);
        NtLmGlobalNtLm3TargetInfo.Buffer = NULL;
    }

    if ( NtLmSecPkg.DomainName.Buffer != NULL )
    {
        NtLmFree (NtLmSecPkg.DomainName.Buffer);
    }

    if ( NtLmSecPkg.DnsDomainName.Buffer != NULL )
    {
        NtLmFree (NtLmSecPkg.DnsDomainName.Buffer);
    }

    if ( NtLmSecPkg.DomainSid != NULL )
    {
        NtLmFree (NtLmSecPkg.DomainSid);
    }

    if (NtLmGlobalLocalSystemSid != NULL)
    {
        FreeSid( NtLmGlobalLocalSystemSid);
        NtLmGlobalLocalSystemSid = NULL;
    }

    if (NtLmGlobalAliasAdminsSid != NULL)
    {
        FreeSid( NtLmGlobalAliasAdminsSid);
        NtLmGlobalAliasAdminsSid = NULL;
    }

    if (NtLmGlobalProcessUserSid != NULL)
    {
        NtLmFree( NtLmGlobalProcessUserSid );
        NtLmGlobalProcessUserSid = NULL;
    }

    if( NtLmGlobalAnonymousSid )
    {
        FreeSid( NtLmGlobalAnonymousSid );
        NtLmGlobalAnonymousSid = NULL;
    }


    if (NtLmRNGInitialized)
    {
        NtLmCleanupRNG();
        NtLmRNGInitialized = FALSE;
    }

    NtLmFreeMappedDomains();

    NtLmUnregisterForPolicyChange(PolicyNotifyDnsDomainInformation);

    if (NtLmGlobalAccessTokenSystem != NULL) {
        NtClose( NtLmGlobalAccessTokenSystem );
        NtLmGlobalAccessTokenSystem = NULL;
    }

    RtlDeleteResource(&NtLmGlobalCritSect);

    if (NtLmGlobalPolicyHandle != NULL) {
        (VOID) I_LsarClose( &NtLmGlobalPolicyHandle );
    }

    SspPrint((SSP_API, "Leaving SpShutdown\n"));
#if DBG
    DeleteCriticalSection(&SspGlobalLogFileCritSect);
#endif

#endif  // NTBUG 400026

    return(SEC_E_OK);
}

//+--------------------------------------------------------------------
//
//  Function:   SpGetInfo
//
//  Synopsis:   Returns information about the package
//
//  Effects:    returns pointers to global data
//
//  Arguments:  PackageInfo - Receives security package information
//
//  Returns:    SEC_E_OK in all cases
//
//  Notes:      Pointers to constants ok. Lsa will copy the data
//              before sending it to someone else
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpGetInfo(
    OUT PSecPkgInfo PackageInfo
    )
{
    SspPrint((SSP_API, "Entering SpGetInfo\n"));

    PackageInfo->fCapabilities    = NTLMSP_CAPS;
    PackageInfo->wVersion         = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    PackageInfo->wRPCID           = RPC_C_AUTHN_WINNT;
    PackageInfo->cbMaxToken       = NTLMSP_MAX_TOKEN_SIZE;
    PackageInfo->Name             = NTLMSP_NAME;
    PackageInfo->Comment          = NTLMSP_COMMENT;

    SspPrint((SSP_API, "Leaving SpGetInfo\n"));

    return(SEC_E_OK);
}

NTSTATUS
NTAPI
SpGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSECPKG_EXTENDED_INFORMATION Information = NULL;
    ULONG Size ;

    switch ( Class )
    {
        case SecpkgContextThunks:

            Information = (PSECPKG_EXTENDED_INFORMATION)
                                NtLmAllocate(sizeof(SECPKG_EXTENDED_INFORMATION) + sizeof(DWORD));
            if (Information == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            Information->Class = SecpkgContextThunks;
            Information->Info.ContextThunks.InfoLevelCount = 1;
            Information->Info.ContextThunks.Levels[0] = SECPKG_ATTR_CREDENTIAL_NAME;
            *ppInformation = Information;
            Information = NULL;
            break;

        case SecpkgWowClientDll:

            //
            // This indicates that we're smart enough to handle wow client processes
            //

            Information = (PSECPKG_EXTENDED_INFORMATION)
                                NtLmAllocate( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                              (MAX_PATH * sizeof(WCHAR) ) );

            if ( Information == NULL )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                goto Cleanup ;
            }

            Information->Class = SecpkgWowClientDll ;
            Information->Info.WowClientDll.WowClientDllPath.Buffer = (PWSTR) (Information + 1);
            Size = ExpandEnvironmentStrings(
                        L"%SystemRoot%\\" WOW64_SYSTEM_DIRECTORY_U L"\\msv1_0.DLL",
                        Information->Info.WowClientDll.WowClientDllPath.Buffer,
                        MAX_PATH );
            Information->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
            Information->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );
            *ppInformation = Information ;
            Information = NULL ;

            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
    }

Cleanup:

    if ( Information != NULL )
    {
        NtLmFree( Information );
    }

    return Status ;
}

NTSTATUS
NTAPI
SpSetExtendedInformation(
    IN SECPKG_EXTENDED_INFORMATION_CLASS Class,
    IN PSECPKG_EXTENDED_INFORMATION Info
    )
{
    NTSTATUS Status ;


    switch ( Class )
    {
        case SecpkgMutualAuthLevel:
            NtLmGlobalMutualAuthLevel = Info->Info.MutualAuthLevel.MutualAuthLevel ;
            Status = SEC_E_OK ;
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
            break;
    }

    return Status ;
}


VOID
NtLmCheckLmCompatibility(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if we should support the LM challenge
    response protocol by looking in the registry under
    system\currentcontrolset\Control\Lsa\LmCompatibilityLevel. The level
    indicates whether to send the LM reponse by default and whether to
    ever send the LM response

Arguments:

    none.

Return Value:

    None

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;

    //
    // initialize defaults
    // Assume that LM is supported.
    //

    NtLmGlobalLmProtocolSupported = 0;
    NtLmGlobalRequireNtlm2 = FALSE;
    NtLmGlobalDatagramUse128BitEncryption = FALSE;
    NtLmGlobalDatagramUse56BitEncryption = FALSE;
    NtLmGlobalLsaKey = NULL;
    NtLmGlobalLsaMsv1_0Key = NULL;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return;
    }

    //
    // save away registry key so we can use it for notification events.
    //

    NtLmGlobalLsaKey = (HKEY)KeyHandle;

    // now open the MSV1_0 subkey...

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa\\Msv1_0"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return;
    }

    //
    // save away registry key so we can use it for notification events.
    //

    NtLmGlobalLsaMsv1_0Key = (HKEY)KeyHandle;
}

ULONG
NtLmValidMinimumSecurityFlagsMask(
    IN  ULONG   MinimumSecurity
    )
/*++

    This routine takes a NtLmMinimumClientSec or NtLmMinimumServerSec registry
    value and masks off the bits that are not relevant for enforcing the
    supported options.

--*/
{

    return (MinimumSecurity & (
                    NTLMSSP_NEGOTIATE_UNICODE |
                    NTLMSSP_NEGOTIATE_SIGN |
                    NTLMSSP_NEGOTIATE_SEAL |
                    NTLMSSP_NEGOTIATE_NTLM2 |
                    NTLMSSP_NEGOTIATE_128 |
                    NTLMSSP_NEGOTIATE_KEY_EXCH |
                    NTLMSSP_NEGOTIATE_56
                    ));

}

VOID
NTAPI
NtLmQueryDynamicGlobals(
    PVOID pvContext,
    BOOLEAN TimedOut // whether this callback occurred because of a timer expiration
    )
{
    SspPrint((SSP_API, "Entering NtLmQueryDynamicGlobals\n"));

    HKEY KeyHandle;     // open registry key to Lsa\MSV1_0
    LONG RegStatus;

    DWORD RegValueType;
    DWORD RegValue;
    DWORD RegValueSize;
    BOOLEAN PriorForceGuest;

    KeyHandle = NtLmGlobalLsaKey;

    if ( KeyHandle != NULL )
    {
        //
        // lm compatibility level.
        //

        RegValueSize = sizeof( RegValue );

        RegStatus = RegQueryValueExW(
            KeyHandle,
            L"LmCompatibilityLevel",
            NULL,
            &RegValueType,
            (PUCHAR)&RegValue,
            &RegValueSize
            );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                NtLmGlobalLmProtocolSupported = (ULONG)RegValue;
            }
        } else if ( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalLmProtocolSupported = 0;
        }

        //
        // handle ForceGuest
        //

        PriorForceGuest = NtLmGlobalForceGuest;

        if ( NtLmGlobalNtProductType != NtProductLanManNt )
        {
            RegValueSize = sizeof( RegValue );

            if ( NtLmGlobalPersonalSKU )
            {
                //
                // personal product always has ForceGuest turned on.
                //

                RegValueSize = sizeof(ULONG);
                RegValueType = REG_DWORD;
                RegValue = 1;
                RegStatus = ERROR_SUCCESS;

            } else {

                if ( NtLmGlobalDomainJoined )
                {
                    //
                    // joined product always has ForceGuest turned off.
                    //

                    RegValueSize = sizeof(ULONG);
                    RegValueType = REG_DWORD;
                    RegValue = 0;
                    RegStatus = ERROR_SUCCESS;

                } else {

                    RegStatus = RegQueryValueExW(
                        KeyHandle,
                        L"ForceGuest",
                        NULL,
                        &RegValueType,
                        (PUCHAR)&RegValue,
                        &RegValueSize
                        );
                }
            }

        } else {

            //
            // insure ForceGuest is disabled for domain controllers.
            //

            RegStatus = ERROR_FILE_NOT_FOUND;
        }

        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ( (RegValueSize >= sizeof(ULONG)) &&
                 (RegValueType == REG_DWORD) )
            {
                if( RegValue == 1 )
                {
                    NtLmGlobalForceGuest = TRUE;
                } else {
                    NtLmGlobalForceGuest = FALSE;
                }
            }
        } else if ( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalForceGuest = FALSE;
        }

        if ( (!TimedOut) &&
            (PriorForceGuest != NtLmGlobalForceGuest)
            )
        {
            //
            // update targetinfo.  the setting changed.
            //

            RtlAcquireResourceExclusive(&NtLmGlobalCritSect, TRUE);

            if ( NtLmGlobalNtLm3TargetInfo.Length != 0 )
            {
                SsprUpdateTargetInfo();
            }

            RtlReleaseResource(&NtLmGlobalCritSect);
        }

        //
        // handle LimitBlankPasswordUse
        //

        if ( NtLmGlobalNtProductType != NtProductLanManNt )
        {
            RegValueSize = sizeof( RegValue );

            RegStatus = RegQueryValueExW(
                            KeyHandle,
                            L"LimitBlankPasswordUse",
                            NULL,
                            &RegValueType,
                            (PUCHAR)&RegValue,
                            &RegValueSize
                            );
        } else {

            //
            // domain controllers always allow blank.
            //

            NtLmGlobalAllowBlankPassword = TRUE;

            RegStatus = ERROR_INVALID_PARAMETER;
        }

        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ( (RegValueSize >= sizeof(ULONG)) &&
                 (RegValueType == REG_DWORD) )
            {
                if ( RegValue == 0 )
                {
                    NtLmGlobalAllowBlankPassword = TRUE;
                } else {
                    NtLmGlobalAllowBlankPassword = FALSE;
                }
            }
        } else if ( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalAllowBlankPassword = FALSE;
        }
    }

    KeyHandle = NtLmGlobalLsaMsv1_0Key;

    if ( KeyHandle != NULL )
    {
        //
        // get minimum client security flag.
        //

        RegValueSize = sizeof( RegValue );

        RegStatus = RegQueryValueExW(
            KeyHandle,
            L"NtlmMinClientSec",
            NULL,
            &RegValueType,
            (PUCHAR)&RegValue,
            &RegValueSize
            );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                NtLmGlobalMinimumClientSecurity =
                    NtLmValidMinimumSecurityFlagsMask( (ULONG)RegValue );
            }
        } else if ( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalMinimumClientSecurity = 0 ;
        }

        //
        // get minimum server security flags.
        //

        RegValueSize = sizeof( RegValueSize );

        RegStatus = RegQueryValueExW(
            KeyHandle,
            L"NtlmMinServerSec",
            NULL,
            &RegValueType,
            (PUCHAR)&RegValue,
            &RegValueSize
            );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                NtLmGlobalMinimumServerSecurity =
                    NtLmValidMinimumSecurityFlagsMask( (ULONG)RegValue );
            }
        } else if ( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalMinimumServerSecurity = 0;
        }

        //
        // All datagram related flags need to be set.
        //

        if (NtLmGlobalMinimumClientSecurity & NTLMSSP_NEGOTIATE_NTLM2)
        {
            NtLmGlobalRequireNtlm2 = TRUE;
        }

        if (NtLmGlobalMinimumClientSecurity & NTLMSSP_NEGOTIATE_128)
        {
            NtLmGlobalDatagramUse128BitEncryption = TRUE;
        } else if (NtLmGlobalMinimumClientSecurity & NTLMSSP_NEGOTIATE_56) {
            NtLmGlobalDatagramUse56BitEncryption = TRUE;
        }

#if DBG

        //
        // get the debugging flag
        //


        RegValueSize = sizeof( RegValueSize );

        RegStatus = RegQueryValueExW(
            KeyHandle,
            L"DBFlag",
            NULL,
            &RegValueType,
            (PUCHAR)&RegValue,
            &RegValueSize
            );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                SspGlobalDbflag = (ULONG)RegValue;
            }
        }

#endif

    }

    //
    // (re)register the wait events.
    //

    if ( NtLmGlobalRegChangeNotifyEvent && NtLmGlobalLsaKey )
    {
        RegNotifyChangeKeyValue(
            NtLmGlobalLsaKey,
#if DBG
            TRUE, // catch change events by msv1_0\DBFlag
#else
            FALSE,
#endif
            REG_NOTIFY_CHANGE_LAST_SET,
            NtLmGlobalRegChangeNotifyEvent,
            TRUE
            );
    }

    SspPrint((SSP_API, "Leaving NtLmQueryDynamicGlobals\n"));

    return;
}


VOID
NtLmQueryMappedDomains(
    VOID
    )
{
    HKEY KeyHandle;     // open registry key to Lsa\MSV1_0
    LONG RegStatus;
    DWORD RegValueType;
    WCHAR RegDomainName[DNS_MAX_NAME_LENGTH+1];
    DWORD RegDomainSize;


    //
    // register the workitem that waits for the RegChangeNotifyEvent
    // to be signalled.  This supports dynamic refresh of configuration
    // parameters.
    //

    NtLmGlobalRegChangeNotifyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    //
    // query the globals once prior to registering the wait
    // if a registry change occurs, the globals will be re-read by the worker
    // thread.
    //

    NtLmQueryDynamicGlobals( NULL, TRUE );

    NtLmGlobalRegWaitObject = RegisterWaitForSingleObjectEx(
        NtLmGlobalRegChangeNotifyEvent,
        NtLmQueryDynamicGlobals,
        NULL,
        INFINITE,
        0 // dwFlags
        );

    KeyHandle = NtLmGlobalLsaMsv1_0Key;

    if ( KeyHandle == NULL )
        return;


    //
    // we only support loading the following globals once during initialization;
    // they are not re-read until next reboot.
    //

    //
    // Check the registry for a domain name to map
    //

    RegDomainSize = sizeof( RegDomainName );
    RegStatus = RegQueryValueExW(
        KeyHandle,
        L"MappedDomain",
        NULL,
        &RegValueType,
        (PUCHAR) RegDomainName,
        &RegDomainSize
        );

    if (RegStatus == ERROR_SUCCESS && RegDomainSize <= 0xFFFF) {

        NtLmLocklessGlobalMappedDomainString.Length = (USHORT)(RegDomainSize - sizeof(WCHAR));
        NtLmLocklessGlobalMappedDomainString.MaximumLength = (USHORT)RegDomainSize;
        NtLmLocklessGlobalMappedDomainString.Buffer = (PWSTR)NtLmAllocate( RegDomainSize );

        if( NtLmLocklessGlobalMappedDomainString.Buffer != NULL )
            CopyMemory( NtLmLocklessGlobalMappedDomainString.Buffer,
                        RegDomainName,
                        RegDomainSize );
    } else {
        RtlInitUnicodeString(
            &NtLmLocklessGlobalMappedDomainString,
            NULL
            );
    }


    //
    // Check the registry for a domain name to use
    //

    RegDomainSize = sizeof( RegDomainName );
    RegStatus = RegQueryValueExW(
        KeyHandle,
        L"PreferredDomain",
        NULL,
        &RegValueType,
        (PUCHAR) RegDomainName,
        &RegDomainSize
        );

    if (RegStatus == ERROR_SUCCESS && RegDomainSize <= 0xFFFF) {

        NtLmLocklessGlobalPreferredDomainString.Length = (USHORT)(RegDomainSize - sizeof(WCHAR));
        NtLmLocklessGlobalPreferredDomainString.MaximumLength = (USHORT)RegDomainSize;
        NtLmLocklessGlobalPreferredDomainString.Buffer = (PWSTR)NtLmAllocate( RegDomainSize );

        if( NtLmLocklessGlobalPreferredDomainString.Buffer != NULL )
            CopyMemory( NtLmLocklessGlobalPreferredDomainString.Buffer,
                        RegDomainName,
                        RegDomainSize );
    } else {
        RtlInitUnicodeString(
            &NtLmLocklessGlobalPreferredDomainString,
            NULL
            );
    }

    return;
}


VOID
NtLmFreeMappedDomains(
    VOID
    )
{
    if( NtLmGlobalRegWaitObject )
        UnregisterWait( NtLmGlobalRegWaitObject );

    if( NtLmGlobalRegChangeNotifyEvent )
        CloseHandle( NtLmGlobalRegChangeNotifyEvent );

    if( NtLmLocklessGlobalMappedDomainString.Buffer ) {
        NtLmFree( NtLmLocklessGlobalMappedDomainString.Buffer );
        NtLmLocklessGlobalMappedDomainString.Buffer = NULL;
    }

    if( NtLmLocklessGlobalPreferredDomainString.Buffer ) {
        NtLmFree( NtLmLocklessGlobalPreferredDomainString.Buffer );
        NtLmLocklessGlobalPreferredDomainString.Buffer = NULL;
    }
}

ULONG
NtLmCheckProcessOption(
    IN  ULONG OptionRequest
    )
{
    SECPKG_CALL_INFO CallInfo;
    ULONG OptionMask = 0;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEntry;

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        goto Cleanup;
    }

    RtlAcquireResourceShared( &NtLmProcessOptionsLock, TRUE );

    ListHead = &NtLmProcessOptionsList;

    //
    // Now walk the list looking for a match.
    //

    for ( ListEntry = ListHead->Flink;
          ListEntry != ListHead;
          ListEntry = ListEntry->Flink )
    {
        PSSP_PROCESSOPTIONS ProcessOptions;

        ProcessOptions = CONTAINING_RECORD( ListEntry, SSP_PROCESSOPTIONS, Next );

        if ( ProcessOptions->ClientProcessID == CallInfo.ProcessId )
        {
            OptionMask = ProcessOptions->ProcessOptions;
            break;
        }
    }

    RtlReleaseResource( &NtLmProcessOptionsLock );

Cleanup:

    return OptionMask;
}

BOOLEAN
NtLmSetProcessOption(
    IN  ULONG OptionRequest,
    IN  BOOLEAN DisableOption
    )
{
    SECPKG_CALL_INFO CallInfo;
    PSSP_PROCESSOPTIONS pProcessOption = NULL;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEntry;
    BOOLEAN fExisting = FALSE;
    BOOLEAN fSuccess = FALSE;

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        goto Cleanup;
    }

    pProcessOption = (PSSP_PROCESSOPTIONS)NtLmAllocate( sizeof(*pProcessOption) );
    if ( pProcessOption == NULL )
    {
        goto Cleanup;
    }

    pProcessOption->ClientProcessID = CallInfo.ProcessId;
    pProcessOption->ProcessOptions = OptionRequest;

    RtlAcquireResourceExclusive( &NtLmProcessOptionsLock, TRUE );

    ListHead = &NtLmProcessOptionsList;

    //
    // Now walk the list looking for a match.
    //

    for ( ListEntry = ListHead->Flink;
          ListEntry != ListHead;
          ListEntry = ListEntry->Flink )
    {
        PSSP_PROCESSOPTIONS ProcessOptions;

        ProcessOptions = CONTAINING_RECORD( ListEntry, SSP_PROCESSOPTIONS, Next );

        if( ProcessOptions->ClientProcessID == CallInfo.ProcessId )
        {
            if( DisableOption )
            {
                ProcessOptions->ProcessOptions &= ~OptionRequest;
            } else {
                ProcessOptions->ProcessOptions |= OptionRequest;
            }

            fExisting = TRUE;
            break;
        }
    }

    if( !fExisting && !DisableOption )
    {
        InsertHeadList( &NtLmProcessOptionsList, &pProcessOption->Next );
        pProcessOption = NULL;
    }

    RtlReleaseResource( &NtLmProcessOptionsLock );

    fSuccess = TRUE;

Cleanup:

    if( pProcessOption != NULL )
    {
        NtLmFree( pProcessOption );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlmssp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nllmssp.h

Abstract:

    Externally visible definition of the NT Lanman Security Support Provider
    (NtLmSsp) Service.

Author:

    Cliff Van Dyke (cliffv) 01-Jul-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Borrowed from the Ciaro's ntlmssp.h by PeterWi.

    ChandanS  03-Aug-1996  Stolen from net\svcdlls\ntlmssp\ntlmssp.h
--*/

#ifndef _NTLMSSP_
#define _NTLMSSP_

#include <ntverp.h>

//
// Defines for SecPkgInfo structure returned by SpGetInfo
//

#define NTLMSP_NAME           L"NTLM"
#define NTLMSP_COMMENT        L"NTLM Security Package"
#define NTLMSP_CAPS           (SECPKG_FLAG_TOKEN_ONLY | \
                               SECPKG_FLAG_MULTI_REQUIRED | \
                               SECPKG_FLAG_CONNECTION | \
                               SECPKG_FLAG_INTEGRITY | \
                               SECPKG_FLAG_PRIVACY | \
                               SECPKG_FLAG_IMPERSONATION | \
                               SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                               SECPKG_FLAG_NEGOTIABLE | \
                               SECPKG_FLAG_LOGON )

#define NTLMSP_MAX_TOKEN_SIZE  0x770
#define NTLM_CRED_NULLSESSION  SECPKG_CRED_RESERVED

// includes that should go elsewhere.

//
// Move to secscode.h
//

#define SEC_E_PACKAGE_UNKNOWN SEC_E_SECPKG_NOT_FOUND
#define SEC_E_INVALID_CONTEXT_REQ SEC_E_NOT_SUPPORTED
#define SEC_E_INVALID_CREDENTIAL_USE SEC_E_NOT_SUPPORTED
#define SEC_I_CALL_NTLMSSP_SERVICE 0xFFFFFFFF

//
// Could be in sspi.h
//

#define SSP_RET_REAUTHENTICATION 0x8000000

//
// client/server versions
//
// the version has the following format: (8 octets, little endian)
//
//   0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
//  -----------------------------------------------------------------
//  | major        | minor          | build                        |
//  -----------------------------------------------------------------
//  | reserved                                       | revision    |
//  -----------------------------------------------------------------
//

#define NTLMSSP_REVISION_W2K3_RC1                10
#define NTLMSSP_REVISION_W2K3                    15
#define NTLMSSP_REVISION_CURRENT                 NTLMSSP_REVISION_W2K3

#define NTLMSSP_ENGINE_VERSION                                      \
            ( ( VER_PRODUCTMAJORVERSION & 0xFF )                    \
            | ( ( VER_PRODUCTMINORVERSION & 0xFF ) << 8 )           \
            | ( ( VER_PRODUCTBUILD & 0xFFFF ) << 16 )               \
            | ( ( (ULONG64) NTLMSSP_REVISION_CURRENT & 0xFF ) << 56 ) )

#endif // _NTLMSSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlmutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntlmutil.h
//
// Contents:    prototypes for NtLm utility functions
//
//
// History:     ChandanS 25-Jul-1996   Stolen from kerberos\client2\kerbutil.h
//
//------------------------------------------------------------------------

#ifndef __NTLMUTIL_H__
#define __NTLMUTIL_H__

#include <malloc.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif

NTSTATUS
NtLmDuplicateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

NTSTATUS
NtLmDuplicateString(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    );

NTSTATUS
NtLmDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

NTSTATUS
NtLmDuplicateSid(
    OUT PSID *DestinationSid,
    IN PSID SourceSid
    );

VOID
NtLmFree(
    IN PVOID Buffer
    );

PVOID
NtLmAllocate(
    IN SIZE_T BufferSize
    );

PVOID
NtLmAllocateLsaHeap(
    IN ULONG BufferSize
    );

VOID
NtLmFreeLsaHeap(
    IN PVOID Buffer
    );


//
// internal versions for use when code only executed in LSA.
//

#if DBG

PVOID
NtLmAllocatePrivateHeap(
    IN SIZE_T BufferSize
    );

VOID
NtLmFreePrivateHeap(
    IN PVOID Buffer
    );

PVOID
I_NtLmAllocate(
    IN SIZE_T BufferSize
    );

VOID
I_NtLmFree(
    IN PVOID Buffer
    );

#else

//
// routines that use LsaHeap - necessary for buffers which
// LSA frees outside of package from LsaHeap
//

//
// routines that use LsaPrivateHeap.
//

#define NtLmAllocatePrivateHeap(x)  LsaFunctions->AllocatePrivateHeap(x)
#define NtLmFreePrivateHeap(x)      LsaFunctions->FreePrivateHeap(x)

#define I_NtLmAllocate(x)           Lsa.AllocatePrivateHeap(x)
#define I_NtLmFree(x)               Lsa.FreePrivateHeap(x)

#endif

#ifdef __cplusplus
}
#endif

#endif // __NTLMUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\ntlmutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntlmutil.cxx
//
// Contents:    Utility functions for NtLm package:
//                NtLmDuplicateUnicodeString
//                NtLmDuplicateSid
//                NtLmAllocate
//                NtLmFree
//
//
// History:     ChandanS  25-Jul-1996   Stolen from kerberos\client2\kerbutil.cxx
//
//------------------------------------------------------------------------
#include <global.h>



//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicateUnicodeString
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtLmDuplicateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicateUnicodeString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {

        DestinationString->Buffer = (LPWSTR) NtLmAllocatePrivateHeap(
                       SourceString->Length + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "NtLmDuplicateUnicodeString, NtLmAllocate returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    SspPrint((SSP_MISC, "Leaving NtLmDuplicateUnicodeString\n"));
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicateString
//
//  Synopsis:   Duplicates a STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtLmDuplicateString(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicateString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {

        DestinationString->Buffer = (LPSTR) NtLmAllocatePrivateHeap(
                       SourceString->Length + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "NtLmDuplicateString, NtLmAllocate returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    SspPrint((SSP_MISC, "Leaving NtLmDuplicateString\n"));
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicatePassword
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The MaximumLength contains
//              room for encryption padding data.
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtLmDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicatePassword\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        USHORT PaddingLength;

        PaddingLength = DESX_BLOCKLEN - (SourceString->Length % DESX_BLOCKLEN);

        if( PaddingLength == DESX_BLOCKLEN )
        {
            PaddingLength = 0;
        }

        DestinationString->Buffer = (LPWSTR) NtLmAllocatePrivateHeap(
                                                    SourceString->Length +
                                                    PaddingLength
                                                    );

        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + PaddingLength;

            if( DestinationString->MaximumLength == SourceString->MaximumLength )
            {
                //
                // duplicating an already padded buffer -- pickup the original
                // pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->MaximumLength
                    );
            } else {

                //
                // duplicating an unpadded buffer -- pickup only the string
                // and fill the rest with the boot time pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->Length
                    );

                //
                // CRYPTNOTE: consideration for ultra-paranoid:
                // use a boot time random pad for fill.
                //

            }

        }
        else
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "NtLmDuplicatePassword, NtLmAllocate returns NULL\n"));
        }
    }


    SspPrint((SSP_MISC, "Leaving NtLmDuplicatePassword\n"));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicateSid\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SidSize;

    ASSERT(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) NtLmAllocatePrivateHeap( SidSize );

    if (ARGUMENT_PRESENT(*DestinationSid))
    {
        RtlCopyMemory(
            *DestinationSid,
            SourceSid,
            SidSize
            );
    }
    else
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        SspPrint((SSP_CRITICAL, "NtLmDuplicateSid, NtLmAllocate returns NULL\n"));
        goto CleanUp;
    }

CleanUp:
    SspPrint((SSP_MISC, "Leaving NtLmDuplicateSid\n"));
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmAllocate
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
NtLmAllocate(
    IN SIZE_T BufferSize
    )
{
    PVOID Buffer;

    if (NtLmState == NtLmLsaMode)
    {
        ASSERT ((LsaFunctions->AllocatePrivateHeap));
        Buffer = LsaFunctions->AllocatePrivateHeap(BufferSize);
        // note: Lsa allocator zeroes the memory for us.
    }
    else
    {
        ASSERT(NtLmState == NtLmUserMode);
        Buffer = LocalAlloc(LPTR, BufferSize);
//        Buffer = CryptMemoryAlloc(BufferSize);
    }


    return Buffer;
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
NtLmFree(
    IN PVOID Buffer
    )
{

    if (ARGUMENT_PRESENT(Buffer))
    {
        if (NtLmState == NtLmLsaMode)
        {
            ASSERT ((LsaFunctions->FreePrivateHeap));
            LsaFunctions->FreePrivateHeap(Buffer);
        }
        else
        {
            ASSERT(NtLmState == NtLmUserMode);
            LocalFree(Buffer);
//            CryptMemoryFree(Buffer);
        }
    }

}



PVOID
NtLmAllocateLsaHeap(
    IN ULONG BufferSize // should update to SIZE_T once lsa allocator def updated
    )
{
    PVOID Buffer;

    if (NtLmState == NtLmLsaMode)
    {
        ASSERT ((LsaFunctions->AllocateLsaHeap));
        Buffer = LsaFunctions->AllocateLsaHeap(BufferSize);
        // note: Lsa allocator zeroes the memory for us.
    }
    else
    {
        ASSERT(NtLmState == NtLmUserMode);
        Buffer = LocalAlloc(LPTR, BufferSize);
//        Buffer = CryptMemoryAlloc(BufferSize);
    }

    return Buffer;
}

VOID
NtLmFreeLsaHeap(
    IN PVOID Buffer
    )
{

    if (ARGUMENT_PRESENT(Buffer))
    {
        if (NtLmState == NtLmLsaMode)
        {
            ASSERT ((LsaFunctions->FreeLsaHeap));
            LsaFunctions->FreeLsaHeap(Buffer);
        }
        else
        {
            ASSERT(NtLmState == NtLmUserMode);
            LocalFree(Buffer);
//            CryptMemoryFree(Buffer);
        }
    }
}




#if DBG

PVOID
NtLmAllocatePrivateHeap(
    IN SIZE_T BufferSize
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((LsaFunctions->AllocatePrivateHeap));

    // note: Lsa allocator zeroes the memory for us.
    return LsaFunctions->AllocatePrivateHeap(BufferSize);
}

VOID
NtLmFreePrivateHeap(
    IN PVOID Buffer
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((LsaFunctions->FreePrivateHeap));

    if (ARGUMENT_PRESENT(Buffer))
    {
        LsaFunctions->FreePrivateHeap(Buffer);
    }
}

PVOID
I_NtLmAllocate(
    IN SIZE_T BufferSize
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((Lsa.AllocatePrivateHeap));

    // note: Lsa allocator zeroes the memory for us.
    return Lsa.AllocatePrivateHeap(BufferSize);
}

VOID
I_NtLmFree(
    IN PVOID Buffer
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((Lsa.FreePrivateHeap));

    if (ARGUMENT_PRESENT(Buffer))
    {
        Lsa.FreePrivateHeap(Buffer);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\rng.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       rng.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-15-95   RichardW   Created
//              2-8-96    MikeSw     Copied to NTLMSSP from SSL
//              03-Aug-1996 ChandanS  Stolen from net\svcdlls\ntlmssp\common\rng.c
//              8-Dec-1997 SField    Use crypto group RNG
//
//----------------------------------------------------------------------------

#include <global.h>



NTSTATUS
SspGenerateRandomBits(
    VOID        *pRandomData,
    ULONG       cRandomData
    )
{

#if defined(USE_CONSTANT_CHALLENGE)

    ZeroMemory(pRandomData, cRandomData);

#endif

    if( RtlGenRandom( pRandomData, cRandomData ) )
    {
        return STATUS_SUCCESS;
    }

    //
    // return a nebulous error message.  this is better than returning
    // success which could compromise security with non-random key.
    //

    ASSERT( (STATUS_SUCCESS == STATUS_UNSUCCESSFUL) );

    return STATUS_UNSUCCESSFUL;
}


BOOL
NtLmInitializeRNG(VOID)
{
    return TRUE;
}

VOID
NtLmCleanupRNG(VOID)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\userapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to the NtLm security package
//
//              Main user mode entry points into this dll:
//                SpUserModeInitialize
//                SpInstanceInit
//                SpDeleteUserModeContext
//                SpInitUserModeContext
//                SpMakeSignature
//                SpVerifySignature
//                SpSealMessage
//                SpUnsealMessage
//                SpGetContextToken
//                SpQueryContextAttributes
//                SpCompleteAuthToken
//                SpFormatCredentials
//                SpMarshallSupplementalCreds
//                SpExportSecurityContext
//                SpImportSecurityContext
//
//              Helper functions:
//                ReferenceUserContext
//                FreeUserContext
//                DereferenceUserContext
//                SspGenCheckSum
//                SspEncryptBuffer
//                NtLmMakePackedContext(this is called in the client's process)
//                NtLmCreateUserModeContext
//                SspGetTokenUser
//                SspCreateTokenDacl
//                SspMapContext (this is called in Lsa mode)
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\userapi.cxx
//
//------------------------------------------------------------------------
#include <global.h> // Globals!
#include "crc32.h"  // How to use crc32

#include <wincrypt.h>
#include <kerberos.h>

extern "C"
{
#include <nlp.h>
}

// Keep this is sync with NTLM_KERNEL_CONTEXT defined in
// security\msv_sspi\kernel\krnlapi.cxx

typedef struct _NTLM_CLIENT_CONTEXT{
    union {
    LIST_ENTRY           Next;
    KSEC_LIST_ENTRY      KernelNext;
    };
    ULONG_PTR            LsaContext;
    ULONG                NegotiateFlags;
    HANDLE               ClientTokenHandle;
    PACCESS_TOKEN        AccessToken;
    PULONG                  pSendNonce;      // ptr to nonce to use for send
    PULONG                  pRecvNonce;      // ptr to nonce to use for receive
    struct RC4_KEYSTRUCT *  pSealRc4Sched;   // ptr to key sched used for Seal
    struct RC4_KEYSTRUCT *  pUnsealRc4Sched; // ptr to key sched used to Unseal
    ULONG                   SendNonce;
    ULONG                   RecvNonce;
    LPWSTR                  ContextNames;
    PUCHAR                  pbMarshalledTargetInfo;
    ULONG                   cbMarshalledTargetInfo;
    UCHAR                SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    ULONG                ContextSignature;
    ULONG                References ;
    TimeStamp            PasswordExpiry;
    ULONG                UserFlags;
    UCHAR                   SignSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   VerifySessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   SealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   UnsealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    ULONG64                 Pad1;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    SealRc4Sched;   // key struct used for Seal
    ULONG64                 Pad2;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    UnsealRc4Sched; // key struct used to Unseal
} NTLM_CLIENT_CONTEXT, * PNTLM_CLIENT_CONTEXT;

typedef struct _NTLM_PACKED_CONTEXT {
    ULONG   Tag ;
    ULONG   NegotiateFlags ;
    ULONG   ClientTokenHandle ;
    ULONG   SendNonce ;
    ULONG   RecvNonce ;
    UCHAR   SessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    ULONG   ContextSignature ;
    TimeStamp   PasswordExpiry ;
    ULONG   UserFlags ;
    ULONG   ContextNames ;
    ULONG   ContextNameLength ;
    ULONG   MarshalledTargetInfo;       // offset
    ULONG   MarshalledTargetInfoLength;
    UCHAR   SignSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   VerifySessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   SealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   UnsealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    struct RC4_KEYSTRUCT    SealRc4Sched;
    struct RC4_KEYSTRUCT    UnsealRc4Sched;
} NTLM_PACKED_CONTEXT, * PNTLM_PACKED_CONTEXT ;

#define NTLM_PACKED_CONTEXT_MAP     0
#define NTLM_PACKED_CONTEXT_EXPORT  1

#define CSSEALMAGIC "session key to client-to-server sealing key magic constant"
#define SCSEALMAGIC "session key to server-to-client sealing key magic constant"
#define CSSIGNMAGIC "session key to client-to-server signing key magic constant"
#define SCSIGNMAGIC "session key to server-to-client signing key magic constant"

#define             NTLM_USERLIST_COUNT             (16)    // count of lists
#define             NTLM_USERLIST_LOCK_COUNT_MAX    (4)     // count of locks

LIST_ENTRY          NtLmUserContextList[ NTLM_USERLIST_COUNT ];             // list array.
RTL_RESOURCE        NtLmUserContextLock[ NTLM_USERLIST_LOCK_COUNT_MAX ];    // lock array
ULONG               NtLmUserContextCount[ NTLM_USERLIST_COUNT ];            // count of active contexts
ULONG               NtLmUserContextLockCount;


// Counter for exported handles;never de-refed
// Should probably do a GetSystemInfo and get a space of handles that cannot
// be valid in the Lsa process
ULONG_PTR ExportedContext = 0;

NTSTATUS
SspCreateTokenDacl(
    HANDLE Token
    );

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    );


//+-------------------------------------------------------------------------
//
//  Function:   SpUserModeInitialize
//
//  Synopsis:   Initialize an the MSV1_0 DLL in  a client's
//              address space
//
//  Effects:
//
//  Arguments:  LsaVersion - Version of the security dll loading the package
//              PackageVersion - Version of the MSV1_0 package
//              UserFunctionTable - Receives a copy of Kerberos's user mode
//                  function table
//              pcTables - Receives count of tables returned.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes: we do what was done in SspInitLocalContexts()
//         from net\svcdlls\ntlmssp\client\sign.c and more.
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    if ( NtLmState != NtLmLsaMode )
    {
        SspGlobalDbflag = SSP_CRITICAL;

        InitializeCriticalSection(&SspGlobalLogFileCritSect);
    } 
#endif

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION;

    NtLmUserFunctionTable.InstanceInit = SpInstanceInit;
    NtLmUserFunctionTable.MakeSignature = SpMakeSignature;
    NtLmUserFunctionTable.VerifySignature = SpVerifySignature;
    NtLmUserFunctionTable.SealMessage = SpSealMessage;
    NtLmUserFunctionTable.UnsealMessage = SpUnsealMessage;
    NtLmUserFunctionTable.GetContextToken = SpGetContextToken;
    NtLmUserFunctionTable.QueryContextAttributes = SpQueryContextAttributes;
    NtLmUserFunctionTable.CompleteAuthToken = SpCompleteAuthToken;
    NtLmUserFunctionTable.InitUserModeContext = SpInitUserModeContext;
    NtLmUserFunctionTable.DeleteUserModeContext = SpDeleteUserModeContext;
    NtLmUserFunctionTable.FormatCredentials = SpFormatCredentials;
    NtLmUserFunctionTable.MarshallSupplementalCreds = SpMarshallSupplementalCreds;
    NtLmUserFunctionTable.ExportContext = SpExportSecurityContext;
    NtLmUserFunctionTable.ImportContext = SpImportSecurityContext;

    *UserFunctionTable = &NtLmUserFunctionTable;
    *pcTables = 1;


    if ( NtLmState != NtLmLsaMode)
    {
        //
        // SafeAllocaInitialize was already called in SpLsaModeInitialize
        //

        SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                             SAFEALLOCA_USE_DEFAULT,
                             NtLmAllocate,
                             NtLmFree);
    }

Cleanup:

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   ReferenceUserContext
//
//  Synopsis:   locates a user context in the list, refrences it
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    the context, if it is found, else NULL
//
//  Notes: This was SspContextReferenceContext() in
//         net\svcdlls\ntlmssp\common\context.c
//
//
//--------------------------------------------------------------------------
PNTLM_CLIENT_CONTEXT
ReferenceUserContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext )
{
    SspPrint(( SSP_API_MORE, "Entering ReferenceUserContext for 0x%x\n", ContextHandle ));
    PLIST_ENTRY ListEntry;
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    ULONG ListIndex;
    ULONG LockIndex;

    ListIndex = HandleToListIndex( ContextHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceShared(&NtLmUserContextLock[LockIndex], TRUE);

    //
    // Look for a match for the LsaContext, not user context
    //

    for ( ListEntry = NtLmUserContextList[ListIndex].Flink;
          ListEntry != &NtLmUserContextList[ListIndex];
          ListEntry = ListEntry->Flink ) 
    {

        pContext = CONTAINING_RECORD(ListEntry, NTLM_CLIENT_CONTEXT, Next);

        if (pContext->LsaContext != ContextHandle)
        {
            pContext = NULL;
            continue;
        }

        //
        // Found it!
        //

        if (!RemoveContext)
        {
            InterlockedIncrement( (PLONG)&pContext->References );
        }
        else
        {
            RtlConvertSharedToExclusive(&NtLmUserContextLock[LockIndex]);

            //
            // pContext can be deleted at this moment, in which case, 
            // applications would simply AV in their own process spaces, this 
            // is acceptable because there is no need to validate the handle
            // in the first place 
            //

            RemoveEntryList(&pContext->Next);
            NtLmUserContextCount[ListIndex]--;
            
            SspPrint(( SSP_API_MORE, "ReferenceUserContext delinked Context %p\n", pContext ));
        }

        break;
    }

    RtlReleaseResource(&NtLmUserContextLock[LockIndex]);

    SspPrint(( SSP_API_MORE, "Leaving ReferenceUserContext for %p, returning %p\n", ContextHandle, pContext ));
    return pContext;
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeUserContext
//
//  Synopsis:   frees alloced pointers in this context and
//              then frees the context
//
//  Arguments:  lContext  - the unlinked user context
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
FreeUserContext (
    PNTLM_CLIENT_CONTEXT UserContext
    )
{
    SspPrint(( SSP_API_MORE, "Entering FreeUserContext for context 0x%x\n", UserContext ));

    NTSTATUS Status = STATUS_SUCCESS;

    if (UserContext->ContextNames != NULL)
    {
        NtLmFree (UserContext->ContextNames);
    }

    if (UserContext->pbMarshalledTargetInfo != NULL)
    {
        NtLmFree (UserContext->pbMarshalledTargetInfo);
    }

    if (UserContext->ClientTokenHandle != NULL)
    {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose(UserContext->ClientTokenHandle);
        ASSERT (NT_SUCCESS (IgnoreStatus));
    }

    SspPrint(( SSP_API_MORE, "Deleting Context 0x%x\n", UserContext));

    ZeroMemory( UserContext, sizeof(*UserContext) );
    NtLmFree (UserContext);

    SspPrint(( SSP_API_MORE, "Leaving FreeUserContext for context 0x%x, status = 0x%x\n", Status ));

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DereferenceUserContext
//
//  Synopsis:   frees alloced elements in the context, frees context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:     None
//
//  Notes: This was SspContextDereferenceContext() in
//         net\svcdlls\ntlmssp\common\context.c
//
//
//--------------------------------------------------------------------------
NTSTATUS
DereferenceUserContext (
    PNTLM_CLIENT_CONTEXT pContext
    )
{
    SspPrint(( SSP_API_MORE, "Entering DereferenceUserContext 0x%lx\n", pContext ));
    NTSTATUS Status = STATUS_SUCCESS;

    LONG References;

    //
    // Decrement the reference count
    //

///    RtlAcquireResourceShared(&NtLmUserContextLock, TRUE);
////    ASSERT (pContext->References >= 1);
////    References = -- pContext->References;
    References = InterlockedDecrement( (PLONG)&pContext->References );
    ASSERT( References >= 0 );
////    RtlReleaseResource(&NtLmUserContextLock);

    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (References == 0)
    {
        Status = FreeUserContext(pContext);
    }
    SspPrint(( SSP_API_MORE, "Leaving DereferenceUserContext\n" ));
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpInstanceInit
//
//  Synopsis:   Initialize an instance of the NtLm package in a client's
//              address space
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//              FunctionTable - Contains helper routines for use by NtLm
//              UserFunctions - Receives a copy of NtLm's user mode
//                  function table
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes: we do what was done in SspInitLocalContexts()
//         from net\svcdlls\ntlmssp\client\sign.c and more.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    SspPrint(( SSP_API, "Entering SpInstanceInit\n" ));
    NTSTATUS Status = STATUS_SUCCESS;
    NT_PRODUCT_TYPE ProductType;
    ULONG Index;
    ULONG cResourcesInitialized = 0;


    // Save the Alloc/Free functions
    if( NtLmState != NtLmLsaMode )
    {
        NtLmState = NtLmUserMode;
    }

    UserFunctions = DllFunctionTable;

    for( Index=0 ; Index < NTLM_USERLIST_COUNT ; Index++ )
    {
        InitializeListHead (&NtLmUserContextList[Index]);
    }


    NtLmUserContextLockCount = 1;


    RtlGetNtProductType( &ProductType );

    if( ProductType == NtProductLanManNt ||
        ProductType == NtProductServer )
    {
        SYSTEM_INFO si;

        GetSystemInfo( &si );

        //
        // if not an even power of two, bump it up.
        //

        if( si.dwNumberOfProcessors & 1 )
        {
            si.dwNumberOfProcessors++;
        }

        //
        // insure it fits in the confines of the max allowed.
        //

        if( si.dwNumberOfProcessors > NTLM_USERLIST_LOCK_COUNT_MAX )
        {
            si.dwNumberOfProcessors = NTLM_USERLIST_LOCK_COUNT_MAX;
        }

        if( si.dwNumberOfProcessors )
        {
            NtLmUserContextLockCount = si.dwNumberOfProcessors;
        }
    }

    //
    // list count is 1, or a power of two, for index purposes.
    //

    ASSERT( (NtLmUserContextLockCount == 1) || ((NtLmUserContextLockCount % 2) == 0) );

    for (Index=0; Index < NtLmUserContextLockCount; Index++)
    {
        __try
        {
            RtlInitializeResource(&NtLmUserContextLock[Index]);
            cResourcesInitialized++; // keep track of Resources that are initialized
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    //
    // avoiding deleting RTL_RESOURCEs with un-initialized fields
    //

    if (!NT_SUCCESS(Status))
    {
        for (Index = 0; Index < cResourcesInitialized; Index++)
        {
             RtlDeleteResource(&NtLmUserContextLock[Index]);
        }
    }

    SspPrint(( SSP_API, "Leaving SpInstanceInit: 0x%lx\n", Status ));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//        If this is an exported context, send a flag back to the LSA so that
//        Lsa does not call the SecpDeleteSecurityContext in the lsa process
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN ULONG_PTR ContextHandle
    )
{
    SspPrint(( SSP_API, "Entering SpDeleteUserModeContext 0x%lx\n", ContextHandle ));
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS, SaveStatus = STATUS_SUCCESS;

    //
    // Find the currently existing user context and delink it
    // so that another context cannot Reference it before we
    // Dereference this one.
    //

    pContext = ReferenceUserContext(ContextHandle, TRUE);

    if (pContext == NULL)
    {
        //
        // pContext is legally NULL when we are dealing with an incomplete
        // context.  This can often be the case when the second call to
        // InitializeSecurityContext() fails.
        //
///        Status = STATUS_INVALID_HANDLE;
        Status = STATUS_SUCCESS;
        SspPrint(( SSP_API_MORE, "SpDeleteUserModeContext, local pContext is NULL\n" ));
        goto CleanUp;
    }


    if ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT) != 0)
    {
        // Ignore all other errors and pass back
        SaveStatus = SEC_I_NO_LSA_CONTEXT;
    }


CleanUp:

    if (pContext != NULL)
    {
        Status = DereferenceUserContext(pContext);
    }

    if (SaveStatus == SEC_I_NO_LSA_CONTEXT)
    {
        Status = SaveStatus;
    }

    SspPrint(( SSP_API, "Leaving SpDeleteUserModeContext: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


VOID
SspRc4Key(
    IN ULONG                NegotiateFlags,
    OUT struct RC4_KEYSTRUCT *pRc4Key,
    IN PUCHAR               pSessionKey
    )
/*++

RoutineDescription:

    Create an RC4 key schedule, making sure key length is OK for export

Arguments:

    NegotiateFlags  negotiate feature flags; NTLM2 bit is only one looked at
    pRc4Key         pointer to RC4 key schedule structure; filled in by this routine
    pSessionKey     pointer to session key -- must be full 16 bytes

Return Value:

--*/
{
    //
    // For NTLM2, effective length was already cut down
    //

    if ((NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) != 0) {

        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);

    } else if( NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
        UCHAR Key[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
        ULONG KeyLen;

        ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH == 8);

        // prior to Win2k, negotiated key strength had no bearing on
        // key size.  So, to allow proper interop to NT4, we don't
        // worry about 128bit.  56bit and 40bit are the only supported options.
        // 56bit is enabled because this was introduced in Win2k, and
        // Win2k -> Win2k interops correctly.
        //
#if 0
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_128 ) {
            KeyLen = 8;

        } else
#endif
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_56 ) {
            KeyLen = 7;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 56 bits.
            //

            Key[7] = 0xa0;
        } else {
            KeyLen = 5;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 40 bits.
            //

            Key[5] = 0xe5;
            Key[6] = 0x38;
            Key[7] = 0xb0;
        }

        RtlCopyMemory(Key,pSessionKey,KeyLen);

        SspPrint(( SSP_SESSION_KEYS, "Non NTLMv2 LM_KEY session key size: %lu key=%lx%lx\n",
                    KeyLen,
                    ((DWORD*)Key)[0],
                    ((DWORD*)Key)[1]
                    ));

        rc4_key(pRc4Key, MSV1_0_LANMAN_SESSION_KEY_LENGTH, Key);

    } else {

        SspPrint(( SSP_SESSION_KEYS, "Non NTLMv2 (not LM_KEY) session key size: %lu\n", 16));
        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    ASSERT(PackedContext);

    SspPrint(( SSP_API, "Entering SpInitUserModeContext 0x%lx\n", ContextHandle ));
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    PNTLM_PACKED_CONTEXT pTmpContext  = (PNTLM_PACKED_CONTEXT) PackedContext->pvBuffer;
    ULONG ListIndex;
    ULONG LockIndex;

    if (PackedContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        SspPrint(( SSP_CRITICAL, "SpInitUserModeContext, ContextData size < NTLM_CLIENT_CONTEXT\n" ));
        goto Cleanup;
    }

    pContext = (PNTLM_CLIENT_CONTEXT) NtLmAllocate(sizeof(NTLM_CLIENT_CONTEXT));

    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        SspPrint(( SSP_CRITICAL, "SpInitUserModeContext, NtLmAllocate returns NULL\n" ));
        goto Cleanup;
    }

    //
    // If ClientTokenHandle is NULL, we are being called as
    // as an effect of InitializeSecurityContext, else we are
    // being called because of AcceptSecurityContext
    //

    if (pTmpContext->ClientTokenHandle != NULL )
    {
        pContext->ClientTokenHandle = (HANDLE) ULongToPtr(pTmpContext->ClientTokenHandle);

        Status = SspCreateTokenDacl(pContext->ClientTokenHandle);

        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL,
                       "SpInitUserModeContext, SspCreateTokenDacl failed %x, Status\n" ));

            goto Cleanup;
        }
    }

    // Copy contents of PackedContext->pvBuffer to pContext

    pContext->LsaContext = ContextHandle;
    pContext->NegotiateFlags = pTmpContext->NegotiateFlags;


    SspPrint((SSP_NEGOTIATE_FLAGS, "SpInitUserModeContext NegotiateFlags: %lx\n", pContext->NegotiateFlags));

    pContext->References = 1;


    //
    // keep all 128 bits here, so signing can be strong even if encrypt can't be
    //

    RtlCopyMemory(  pContext->SessionKey,
                        pTmpContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

    //
    // if doing full duplex as part of NTLM2, generate different sign
    // and seal keys for each direction
    //  all we do is MD5 the base session key with a different magic constant
    //

    if ( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {
        MD5_CTX Md5Context;
        ULONG KeyLen;

        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

        if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_128 )
            KeyLen = 16;
        else if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_56 )
            KeyLen = 7;
        else
            KeyLen = 5;

        SspPrint(( SSP_SESSION_KEYS, "NTLMv2 session key size: %lu\n", KeyLen));

        //
        // make client to server encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)CSSEALMAGIC, sizeof(CSSEALMAGIC));
        MD5Final(&Md5Context);

        //
        // if TokenHandle == NULL, this is the client side
        //  put key in the right place: for client it's seal, for server it's unseal
        //

        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)SCSEALMAGIC, sizeof(SCSEALMAGIC));
        MD5Final(&Md5Context);
        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make client to server signing key -- always 128 bits!
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)CSSIGNMAGIC, sizeof(CSSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client signing key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)SCSIGNMAGIC, sizeof(SCSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to different key schedule and nonce for each direction
        //  key schedule will be filled in later...
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->UnsealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->RecvNonce;
   } else {

        //
        // just copy session key to all four keys
        //  leave them 128 bits -- they get cut to 40 bits later
        //

        RtlCopyMemory(  pContext->SealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->UnsealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->SignSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->VerifySessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to share a key schedule and nonce for each direction
        //  (OK because half duplex!)
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->SealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->SendNonce;
    }

    if ( pTmpContext->ContextNames )
    {
       pContext->ContextNames = (PWSTR) NtLmAllocate( pTmpContext->ContextNameLength );

       if ( pContext->ContextNames == NULL )
       {
           Status = STATUS_INSUFFICIENT_RESOURCES ;
           goto Cleanup ;
       }

       RtlCopyMemory(
           pContext->ContextNames,
           ((PUCHAR) pTmpContext) + pTmpContext->ContextNames,
           pTmpContext->ContextNameLength );
    }
    else
    {
        pContext->ContextNames = NULL ;
    }

    if ( pTmpContext->MarshalledTargetInfo )
    {
        pContext->pbMarshalledTargetInfo = (PUCHAR) NtLmAllocate( pTmpContext->MarshalledTargetInfoLength );

        if (pContext->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        pContext->cbMarshalledTargetInfo = pTmpContext->MarshalledTargetInfoLength;

        RtlCopyMemory(  pContext->pbMarshalledTargetInfo,
                        (PUCHAR) pTmpContext + pTmpContext->MarshalledTargetInfo,
                        pTmpContext->MarshalledTargetInfoLength );
    }

    pContext->SendNonce = pTmpContext->SendNonce;
    pContext->RecvNonce = pTmpContext->RecvNonce;

    SspRc4Key(pContext->NegotiateFlags, &pContext->SealRc4Sched, pContext->SealSessionKey);
    SspRc4Key(pContext->NegotiateFlags, &pContext->UnsealRc4Sched, pContext->UnsealSessionKey);

    pContext->PasswordExpiry = pTmpContext->PasswordExpiry;
    pContext->UserFlags = pTmpContext->UserFlags;


    ListIndex = HandleToListIndex( pContext->LsaContext );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceExclusive(&NtLmUserContextLock[LockIndex], TRUE);

    InsertHeadList ( &NtLmUserContextList[ListIndex], &pContext->Next );
    NtLmUserContextCount[ListIndex]++;

    RtlReleaseResource(&NtLmUserContextLock[LockIndex]);


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (pContext != NULL)
        {
            FreeUserContext(pContext);
        }
    }

    // Let FreeContextBuffer handle freeing the virtual allocs

    if (PackedContext->pvBuffer != NULL)
    {
        FreeContextBuffer(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }

    SspPrint(( SSP_API, "Leaving SpInitUserModeContext: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//
// Bogus add-shift check sum
//

void
SspGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    )

/*++

RoutineDescription:

    Generate a crc-32 checksum for a buffer

Arguments:

Return Value:
Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
       routine SspGenCheckSum. It's possible that
       bugs got copied too

--*/

{
    Crc32(pSig->CheckSum,pMessage->cbBuffer,pMessage->pvBuffer,&pSig->CheckSum);
}


VOID
SspEncryptBuffer(
    IN PNTLM_CLIENT_CONTEXT pContext,
    IN struct RC4_KEYSTRUCT * pRc4Key,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
    )

/*++

RoutineDescription:

    Encrypts a buffer with the RC4 key in the context.  If the context
    is for a datagram session, then the key is copied before being used
    to encrypt the buffer.

Arguments:

    pContext - Context containing the key to encrypt the data

    BufferSize - Length of buffer in bytes

    Buffer - Buffer to encrypt.
    Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
           routine SspEncryptBuffer. It's possible that
           bugs got copied too

Return Value:

--*/

{
    struct RC4_KEYSTRUCT TemporaryKey;
///    struct RC4_KEYSTRUCT * EncryptionKey = &pContext->Rc4Key;
    struct RC4_KEYSTRUCT * EncryptionKey = pRc4Key;

    if (BufferSize == 0)
    {
        return;
    }

    //
    // For datagram (application supplied sequence numbers) before NTLM2
    // we used to copy the key before encrypting so we don't
    // have a changing key; but that reused the key stream. Now we only
    // do that when backwards compatibility is explicitly called for.
    //

    if (((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) &&
        ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0) ) {

        RtlCopyMemory(
            &TemporaryKey,
            EncryptionKey,
            sizeof(struct RC4_KEYSTRUCT)
            );
        EncryptionKey = &TemporaryKey;

    }

    rc4(
        EncryptionKey,
        BufferSize,
        (PUCHAR) Buffer
        );
}


typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;

SECURITY_STATUS
SspSignSealHelper(
    IN PNTLM_CLIENT_CONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PNTLMSSP_MESSAGE_SIGNATURE pSig,
    OUT PNTLMSSP_MESSAGE_SIGNATURE * ppSig
    )
/*++

RoutineDescription:

    Handle signing a message

Arguments:

Return Value:

--*/

{

    HMACMD5_CTX HMACMD5Context;
    UCHAR TempSig[MD5DIGESTLEN];
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    int Signature;
    ULONG i;
    PUCHAR pKey;                            // ptr to key to use for encryption
    PUCHAR pSignKey;                        // ptr to key to use for signing
    PULONG pNonce;                          // ptr to nonce to use
    struct RC4_KEYSTRUCT * pRc4Sched;       // ptr to key schedule to use

    NTLMSSP_MESSAGE_SIGNATURE  AlignedSig;  // aligned copy of input sig data

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    if (pMessage->pBuffers[Signature].cbBuffer < NTLMSSP_MESSAGE_SIGNATURE_SIZE)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    *ppSig = (NTLMSSP_MESSAGE_SIGNATURE*)pMessage->pBuffers[Signature].pvBuffer;

    RtlCopyMemory( &AlignedSig, *ppSig, sizeof(AlignedSig) );

    //
    // If sequence detect wasn't requested, put on an empty
    // security token . Don't do the check if Seal/Unseal is called.
    //

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) &&
       (Op == eSign || Op == eVerify))
    {
        RtlZeroMemory(pSig,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        pSig->Version = NTLM_SIGN_VERSION;
        return(SEC_E_OK);
    }

    // figure out which key, key schedule, and nonce to use
    //  depends on the op. SspAddLocalContext set up so that code on client
    //  and server just (un)seals with (un)seal key or key schedule, etc.
    //  and also sets pointers to share sending/receiving key schedule/nonce
    //  when in half duplex mode. Hence, this code gets to act as if it were
    //  always in full duplex mode.
    switch (Op) {
    case eSeal:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eUnseal:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    case eSign:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;        // might be used to encrypt the signature
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eVerify:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;      // might be used to decrypt the signature
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    default:
        ASSERT(FALSE);
        return(STATUS_INVALID_LEVEL);
    }

    //
    // Either we can supply the sequence number, or
    // the application can supply the message sequence number.
    //

    Sig.Version = NTLM_SIGN_VERSION;

    // if we're doing the new NTLM2 version:
    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) {

        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce = *pNonce;    // use our sequence number
            (*pNonce) += 1;
        }
        else {

            if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
                Sig.Nonce = MessageSeqNo;
            else
                Sig.Nonce = AlignedSig.Nonce;

            //   if using RC4, must rekey for each packet
            //   RC4 is used for seal, unseal; and for encrypting the HMAC hash if
            //   key exchange was negotiated (we use just HMAC if no key exchange,
            //   so that a good signing option exists with no RC4 encryption needed)

            if (Op == eSeal || Op == eUnseal || pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            {
                MD5_CTX Md5ContextReKey;

                MD5Init(&Md5ContextReKey);
                MD5Update(&Md5ContextReKey, pKey, MSV1_0_USER_SESSION_KEY_LENGTH);
                MD5Update(&Md5ContextReKey, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));
                MD5Final(&Md5ContextReKey);
                ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
                SspRc4Key(pContext->NegotiateFlags, pRc4Sched, Md5ContextReKey.digest);
            }
        }

        //
        // using HMAC hash, init it with the key
        //

        HMACMD5Init(&HMACMD5Context, pSignKey, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // include the message sequence number
        //

        HMACMD5Update(&HMACMD5Context, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                if ((pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                    == (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                {
                    //
                    // FESTER: returning INVALID token because of data buffers
                    //

                    return SEC_E_INVALID_TOKEN;
                }

                // decrypt (before checksum...) if it's not READ_ONLY
                if ( (Op == eUnseal)
                    && !(pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM) )
                   )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                HMACMD5Update(
                            &HMACMD5Context,
                            (unsigned char*)pMessage->pBuffers[i].pvBuffer,
                            pMessage->pBuffers[i].cbBuffer);

                //
                // Encrypt if its not READ_ONLY
                //

                if ( (Op == eSeal)
                    && !(pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM) )
                   )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        HMACMD5Final(&HMACMD5Context, TempSig);

        //
        // use RandomPad and Checksum fields for 8 bytes of MD5 hash
        //

        RtlCopyMemory(&Sig.RandomPad, TempSig, 8);

        //
        // if we're using crypto for KEY_EXCH, may as well use it for signing too...
        //

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            SspEncryptBuffer(
                pContext,
                pRc4Sched,
                8,
                &Sig.RandomPad
                );
    }
    //
    // pre-NTLM2 methods
    //
    else {

        //
        // required by CRC-32 algorithm
        //
        Sig.CheckSum = 0xffffffff;

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                if ((pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                    == (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                {
                    //
                    // FESTER: returning INVALID token because of data buffers
                    //

                    return SEC_E_INVALID_TOKEN;
                }

                //
                // retain the "read-only" semantics for NTLMv1
                //

                if (pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY)
                {
                    continue;
                }

                // decrypt (before checksum...)
                if ( (Op == eUnseal)
                     && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM) )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                SspGenCheckSum(&pMessage->pBuffers[i], &Sig);


                // Encrypt
                if ( (Op == eSeal)
                     && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM) )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        //
        // Required by CRC-32 algorithm
        //

        Sig.CheckSum ^= 0xffffffff;

        // when we encrypt 0, we will get the cipher stream for the nonce!
        Sig.Nonce = 0;

        SspEncryptBuffer(
            pContext,
            pRc4Sched,
            sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
            &Sig.RandomPad
            );

        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce ^= *pNonce;    // use our sequence number and encrypt it
            (*pNonce) += 1;
        }
        else if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
            Sig.Nonce ^= MessageSeqNo;   // use caller's sequence number and encrypt it
        else
            Sig.Nonce = AlignedSig.Nonce;    // use sender's sequence number

        //
        // for SignMessage calling, does nothing (copies garbage)
        // For VerifyMessage calling, allows it to compare sig block
        // upon return to Verify without knowing whether its MD5 or CRC32
        //

        Sig.RandomPad = AlignedSig.RandomPad;
    }

    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );

    return(SEC_E_OK);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpMakeSignature(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    SspPrint(( SSP_API, "Entering SpMakeSignature\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;

    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    NTLMSSP_MESSAGE_SIGNATURE  *pSig;

    UNREFERENCED_PARAMETER(fQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (pContext == NULL)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpMakeSignature, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }


    Status = SspSignSealHelper(
                        pContext,
                        eSign,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );

    if( !NT_SUCCESS(Status) ) {
        SspPrint(( SSP_CRITICAL, "SpMakeSignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );


CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpMakeSignature: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleVerifyMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpVerifySignature(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    SspPrint(( SSP_API, "Entering SpVerifySignature\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer with sig in it
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // Aligned sig buffer.

    UNREFERENCED_PARAMETER(pfQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (!pContext)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }

    Status = SspSignSealHelper(
                        pContext,
                        eVerify,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }


    RtlCopyMemory( &AlignedSig, pSig, sizeof( AlignedSig ) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, unknown Version wanted=%lx got=%lx\n",
                    NTLM_SIGN_VERSION,
                    AlignedSig.Version
                    ));
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, CheckSum mis-match wanted=%lx got=%lx\n",
                    Sig.CheckSum,
                    AlignedSig.CheckSum
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    // with MD5 sig, this now matters!
    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, RandomPad mis-match wanted=%lx got=%lx\n",
                    Sig.RandomPad,
                    AlignedSig.RandomPad
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, Nonce mis-match wanted=%lx got=%lx\n",
                    Sig.Nonce,
                    AlignedSig.Nonce
                    ));

        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }


CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpVerifySignature: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

}


//+-------------------------------------------------------------------------
//
//  Function:   SpSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpSealMessage(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    SspPrint(( SSP_API, "Entering SpSealMessage\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;    // pointer to buffer where sig goes

    ULONG i;

    UNREFERENCED_PARAMETER(fQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (!pContext)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpSealMessage, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }

    Status = SspSignSealHelper(
                    pContext,
                    eSeal,
                    pMessage,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );


    //
    // for gss style sign/seal, strip the padding as RC4 requires none.
    // (in fact, we rely on this to simplify the size computation in DecryptMessage).
    // if we support some other block cipher, need to rev the NTLM_ token version to make blocksize
    //

    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_PADDING)
        {
            //
            // no padding required!
            //

            pMessage->pBuffers[i].cbBuffer = 0;
            break;
        }
    }


CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpSealMessage: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

}

//+-------------------------------------------------------------------------
//
//  Function:   SpUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpUnsealMessage(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    SspPrint(( SSP_API, "Entering SpUnsealMessage\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer where sig goes
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // aligned buffer.

    PSecBufferDesc MessageBuffers = pMessage;
    ULONG Index;
    PSecBuffer SignatureBuffer = NULL;
    PSecBuffer StreamBuffer = NULL;
    PSecBuffer DataBuffer = NULL;
    SecBufferDesc ProcessBuffers;
    SecBuffer wrap_bufs[2];

    UNREFERENCED_PARAMETER(pfQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (!pContext)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if ((MessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((MessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_STREAM)
        {
            StreamBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((MessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_DATA)
        {
            DataBuffer = &MessageBuffers->pBuffers[Index];
        }
    }

    if( StreamBuffer != NULL )
    {

        if( SignatureBuffer != NULL )
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL, "SpUnsealMessage, Both stream and signature buffer present.\n"));
            goto CleanUp;
        }

        //
        // for version 1 NTLM blobs, padding is never present, since RC4 is stream cipher.
        //

        wrap_bufs[0].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        wrap_bufs[1].cbBuffer = StreamBuffer->cbBuffer - NTLMSSP_MESSAGE_SIGNATURE_SIZE;

        if( StreamBuffer->cbBuffer < wrap_bufs[0].cbBuffer )
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL, "SpUnsealMessage, invalid buffer present in STREAM.\n"));
            goto CleanUp;
        }


        wrap_bufs[0].BufferType = SECBUFFER_TOKEN;
        wrap_bufs[0].pvBuffer = StreamBuffer->pvBuffer;

        wrap_bufs[1].BufferType = SECBUFFER_DATA;
        wrap_bufs[1].pvBuffer = (PBYTE)wrap_bufs[0].pvBuffer + wrap_bufs[0].cbBuffer;

        if( DataBuffer == NULL )
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL, "SpUnsealMessage, gss missing SECBUFFER_DATA.\n"));
            goto CleanUp;
        }

        DataBuffer->cbBuffer = wrap_bufs[1].cbBuffer;
        DataBuffer->pvBuffer = wrap_bufs[1].pvBuffer;

        ProcessBuffers.cBuffers = 2;
        ProcessBuffers.pBuffers = wrap_bufs;
        ProcessBuffers.ulVersion = SECBUFFER_VERSION;

    } else {
        ProcessBuffers = *MessageBuffers;
    }

    Status = SspSignSealHelper(
                    pContext,
                    eUnseal,
                    &ProcessBuffers,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory( &AlignedSig, pSig, sizeof(AlignedSig) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, unknown Version wanted=%lx got=%lx\n",
                    NTLM_SIGN_VERSION,
                    AlignedSig.Version
                    ));
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, CheckSum mis-match wanted=%lx got=%lx\n",
                    Sig.CheckSum,
                    AlignedSig.CheckSum
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, RandomPad mis-match wanted=%lx got=%lx\n",
                    Sig.RandomPad,
                    AlignedSig.RandomPad
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, Nonce mis-match wanted=%lx got=%lx\n",
                    Sig.Nonce,
                    AlignedSig.Nonce
                    ));
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpUnsealMessage: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetContextToken(
    IN ULONG_PTR ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    SspPrint(( SSP_API, "Entering SpGetContextToken\n" ));
    NTSTATUS Status = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (pContext && pContext->ClientTokenHandle)
    {
        *ImpersonationToken = pContext->ClientTokenHandle;
        Status= S_OK;
        goto CleanUp;
    }

    Status = STATUS_INVALID_HANDLE;
    SspPrint(( SSP_CRITICAL, "SpGetContextToken, no token handle\n" ));

CleanUp:

    if (pContext != NULL)
    {
        Status = DereferenceUserContext(pContext);
    }

    SspPrint(( SSP_API, "Leaving SpGetContextToken: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_NOT_SUPPORTED -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpQueryContextAttributes(
    IN ULONG_PTR ContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    PSecPkgContext_Sizes ContextSizes;
    PSecPkgContext_Flags ContextFlags;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_Names ContextNames = NULL;
    PSecPkgContext_PackageInfo PackageInfo;
    PSecPkgContext_NegotiationInfo NegInfo ;
    PSecPkgContext_PasswordExpiry PasswordExpires;
    PSecPkgContext_UserFlags UserFlags;
    PSecPkgContext_SessionKey  SessionKeyInfo;
    PSecPkgContext_AccessToken AccessToken;
    PSecPkgContext_TargetInformation TargetInformation;
    PSecPkgContext_KeyInfo KeyInfo;
    ULONG PackageInfoSize = 0;

    SspPrint(( SSP_API, "Entering SpQueryContextAttributes\n" ));

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (pContext == NULL) {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_API_MORE, "SpQueryContextAttributes, ReferenceUserContext returns NULL (possible incomplete context)\n" ));
        goto Cleanup;
    }

    //
    // Handle each of the various queried attributes
    //

    SspPrint(( SSP_API_MORE, "SpQueryContextAttributes : 0x%lx\n", Attribute ));
    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ContextSizes->cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

        if (pContext->NegotiateFlags & (NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                       NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL) ) {
            ContextSizes->cbMaxSignature = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        } else {
            ContextSizes->cbMaxSignature = 0;
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            ContextSizes->cbBlockSize = 1;
            ContextSizes->cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            if((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) ||
               (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN))
            {
                ContextSizes->cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
            } else {
                ContextSizes->cbSecurityTrailer = 0;
            }
        }

        break;

    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;

        if (pContext->ContextNames)
        {
            UINT Length = (UINT) wcslen(pContext->ContextNames);
            ContextDceInfo->pPac = (LPWSTR)UserFunctions->AllocateHeap((Length + 1) * sizeof(WCHAR));
            if (ContextDceInfo->pPac == NULL) {
                Status = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL, "SpQueryContextAttributes, NtLmAllocate returns NULL\n" ));
                goto Cleanup;
            }

            RtlCopyMemory(
                (LPWSTR) ContextDceInfo->pPac,
                pContext->ContextNames,
                Length * sizeof(WCHAR)
                );
            *((LPWSTR)(ContextDceInfo->pPac) + Length) = L'\0';
        }
        else
        {
            SspPrint(( SSP_API_MORE, "SpQueryContextAttributes no ContextNames\n" ));
            ContextDceInfo->pPac = (LPWSTR) UserFunctions->AllocateHeap(sizeof(WCHAR));
            *((LPWSTR)(ContextDceInfo->pPac)) = L'\0';
        }

        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_TARGET_INFORMATION:
    {
        ULONG Length;

        TargetInformation = (PSecPkgContext_TargetInformation) Buffer;

        if (TargetInformation == NULL)
        {
            SspPrint(( SSP_CRITICAL, "Null buffer SECPKG_ATTR_TARGET_INFORMATION.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TargetInformation->MarshalledTargetInfo = NULL;

        if (pContext->pbMarshalledTargetInfo == NULL)
        {
            TargetInformation->MarshalledTargetInfo = NULL;
            TargetInformation->MarshalledTargetInfoLength = 0;
            goto Cleanup;
        }

        Length = pContext->cbMarshalledTargetInfo;
        SspPrint(( SSP_API_MORE, "NtLmQueryContextAttributes: TargetInformation length is 0x%lx\n", Length));

        TargetInformation->MarshalledTargetInfo = (PUCHAR)UserFunctions->AllocateHeap(
                                                                    Length
                                                                    );

        if (TargetInformation->MarshalledTargetInfo != NULL)
        {
            RtlCopyMemory(
                TargetInformation->MarshalledTargetInfo,
                pContext->pbMarshalledTargetInfo,
                Length
                );

            TargetInformation->MarshalledTargetInfoLength = Length;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        break;
    }

    case SECPKG_ATTR_SESSION_KEY:
    {
        if (NtLmState != NtLmLsaMode)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
        SessionKeyInfo->SessionKeyLength = sizeof(pContext->SessionKey);

        SessionKeyInfo->SessionKey = (PUCHAR) UserFunctions->AllocateHeap(
                                                    SessionKeyInfo->SessionKeyLength
                                                    );
        if (SessionKeyInfo->SessionKey != NULL)
        {
            RtlCopyMemory(
                SessionKeyInfo->SessionKey,
                pContext->SessionKey,
                SessionKeyInfo->SessionKeyLength
                );
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    }

    case SECPKG_ATTR_KEY_INFO:
    {
        LPWSTR EncryptAlgorithm = L"RSADSI RC4";

        KeyInfo = (PSecPkgContext_KeyInfo) Buffer;

        if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_128 )
        {
            KeyInfo->KeySize = 128;
        } else if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_56 )
        {
            KeyInfo->KeySize = 56;
        } else {
            KeyInfo->KeySize = 40;
        }

        KeyInfo->EncryptAlgorithm = CALG_RC4;
        if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 )
        {
            KeyInfo->SignatureAlgorithm = (unsigned long)KERB_CHECKSUM_HMAC_MD5;
        } else {
            KeyInfo->SignatureAlgorithm = (unsigned long)KERB_CHECKSUM_REAL_CRC32;
        }

        KeyInfo->sSignatureAlgorithmName = NULL;
        KeyInfo->sEncryptAlgorithmName = NULL;

        //
        // The checksum doesn't include a name, so don't fill it in - leave
        // it as an empty string, so callers don't die when they
        // try to manipulate it.
        //

        KeyInfo->sEncryptAlgorithmName = (LPWSTR)
            UserFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG) wcslen(EncryptAlgorithm) + 1));

        if (KeyInfo->sEncryptAlgorithmName != NULL)
        {
            wcscpy(
                KeyInfo->sEncryptAlgorithmName,
                EncryptAlgorithm
                );

            KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                UserFunctions->AllocateHeap(sizeof(WCHAR));

            if (KeyInfo->sSignatureAlgorithmName != NULL)
            {
                *KeyInfo->sSignatureAlgorithmName = L'\0';
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                UserFunctions->FreeHeap(KeyInfo->sEncryptAlgorithmName);
                KeyInfo->sEncryptAlgorithmName = NULL;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    }

    case SECPKG_A