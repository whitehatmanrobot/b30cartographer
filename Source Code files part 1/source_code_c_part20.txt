{
        // Cycle thro, this is not a good design as there may
        // be buttons with dup command ids. Alternative is
        // to use a set to keep track of available command ids.
        if (MMC_TOOLBUTTON_ID_LAST == s_idCommand)
            s_idCommand = MMC_TOOLBUTTON_ID_FIRST;

        return (s_idCommand++);
    }

    CMMCToolBar* GetMainToolbar() {return m_pMainToolbar;}

    // Helpers
    SC ScInsertButtonToToolbar  (CMMCToolbarButton* pToolButton);
    SC ScInsertButtonToDataStr  (CToolbarNotify* pNotifyCallbk, int nIndex,
                                 LPMMCBUTTON lpButton, CMMCToolbarButton **ppToolButton);

    SC ScDeleteButtonFromToolbar(CMMCToolbarButton* pToolButton);

    SC ScSetButtonStateInToolbar(CMMCToolbarButton* pToolButton, BYTE nState, BOOL bState);
    SC ScGetButtonStateInToolbar(CMMCToolbarButton *pToolButton, BYTE nState, BOOL* pbState);

    SC ScValidateButton(int nButtons, LPMMCBUTTON lpButtons);
    SC ScSetButtonHelper(int nIndex, CMMCToolbarButton* pToolButton);

    // Members to search our data structures.
    CMMCToolbarButton* GetToolbarButton(int nUniqueCommandID);
    CMMCToolbarButton* GetToolbarButton(CToolbarNotify* pNotifyCallbk, int idCommandIDFromSnapin);

    CImageList* GetImageList() {return CImageList::FromHandle(m_ImageList);}
    int         GetImageCount() {return m_ImageList.GetImageCount();}

    bool IsToolbarAttached(CToolbarNotify* pNotifyCallbk)
    {
        return (m_setOfAttachedToolbars.end() != m_setOfAttachedToolbars.find(pNotifyCallbk) );
    }

    void SetToolbarAttached(CToolbarNotify* pNotifyCallbk, bool bAttach)
    {
        if (bAttach)
            m_setOfAttachedToolbars.insert(pNotifyCallbk);
        else
            m_setOfAttachedToolbars.erase(pNotifyCallbk);
    }

    // The toolbar can be hidden using the customize view dialog.
    // This actually hides the toolbuttons in the toolbar. But the
    // toolbutton is unaware of this hidden information.
    // In other words if the toolbar is hidden then its buttons are
    // hidden but the fsState in CMMCToolbarButton is not set hidden.
    bool IsToolbarHidden(CToolbarNotify* pNotifyCallbk)
    {
        return (m_setOfHiddenToolbars.end() != m_setOfHiddenToolbars.find(pNotifyCallbk) );
    }

    void SetToolbarStatusHidden(CToolbarNotify* pNotifyCallbk, bool bHide)
    {
        if (bHide)
            m_setOfHiddenToolbars.insert(pNotifyCallbk);
        else
            m_setOfHiddenToolbars.erase(pNotifyCallbk);
    }

    bool IsThereAVisibleButton();

private:
    /*
     * There is only one imagelist for this object. All the snapin toolbars
     * and stdbar will add their bitmaps to this single imagelist.
     * So when we add bitmaps for a toolbar we need to know where it starts
     * in the imagelist and how many are added.
     * So we maintain a data struct between toolbar (CToolbarNotify*) and an
     * object (MMCToolbarImages) containing start index & number of images.
     *
     * A snapin may add bitmaps multiple times for single toolbar. Each bitmap
     * is added at different start index.
     * So the data struct is a multi-map  between toolbar (CToolbarNotify*)
     * and MMCToolbarImages.
     *
     * Assume a snapin adds 3 bitmaps initialy & then 4. Then while adding
     * buttons it will specify bitmap index as 5.
     *
     * The first  MMCToolbarImages has cCount = 3, iStartWRTSnapin = 0, thus
     * images from 0 (iStartWRTSnapin) to 3 (iStartWRTSnapin + cCount) with respect
     * to snapin.
     * The second MMCToolbarImages has cCount = 4, iStartWRTSnapin = 3, thus
     * images from 3(iStartWRTSnapin) to 7(iStartWRTSnapin + cCount) wrt snapin.
     * So MMCToolbarImages has iStartWRTSnapin member in addition.
     *
     */

    typedef struct MMCToolbarImages
    {
        int iStart;         // Start index.
        int cCount;         // Number of images.
        int iStartWRTSnapin; // Start index w.r.t snapin
    };

    // This is a multi-map so that snapin can call AddBitmap for same toolbar more than once.
    typedef std::multimap<CToolbarNotify*, MMCToolbarImages> TBarToBitmapIndex;

    // Store toolbars on which attach is called.
    typedef std::set<CToolbarNotify*>                        AttachedToolbars;
    // Store toolbars that are hidden.
    typedef std::set<CToolbarNotify*>                        HiddenToolbars;

    // All toolbuttons for this view.
    typedef std::vector<CMMCToolbarButton>                   ToolbarButtons;

private:
    static int            s_idToolbar;
    static int            s_idCommand;

    ToolbarButtons        m_vToolbarButtons;
    TBarToBitmapIndex     m_mapTBarToBitmapIndex;

    AttachedToolbars      m_setOfAttachedToolbars;
    HiddenToolbars        m_setOfHiddenToolbars;

	/*
	 * Theming: use WTL::CImageList instead of MFC's CImageList so we can
	 * insure a theme-correct imagelist will be created.
	 */
    WTL::CImageList       m_ImageList;

    bool                  m_fViewActive : 1;

    CMMCToolBar*          m_pMainToolbar;
    CAMCView*             m_pAMCViewOwner;

    bool                  m_bLastActiveView;
};

//+-------------------------------------------------------------------
//
//  class:     CMMCToolBar
//
//  Purpose:   The toolbar UI that is shown in mainframe. It observes
//             each CAMCViewToolbar and stores active CAMCViewToolbar
//             so that it can notify that object of button click &
///            tooltip notifications.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMMCToolBar : public CMMCToolBarCtrlEx,
                    public CAMCViewToolbarsObserver
{
    // Needed to lazy update (not update after adding
    // each button, cache all the buttons) of toolbar size.
    static const int s_nUpdateToolbarSizeMsg;

public:
    CMMCToolBar() : m_pActiveAMCViewToolbars(NULL)
    {
    }

    // CAMCViewToolbarsObserver.
    virtual SC  ScOnActivateAMCViewToolbars   (CAMCViewToolbars *pAMCViewToolbars);
    virtual SC  ScOnDeactivateAMCViewToolbars ();

    // Generated message map functions
protected:
    afx_msg void OnButtonClicked(UINT nID);
    afx_msg LRESULT OnUpdateToolbarSize(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateAllCmdUI (CCmdUI*  pCmdUI)
    {
        // The idle update looks for this handler else it disables the
        // toolbuttons. This method does nothing. The buttons are already
        // in right state so dont do anything.
    }

    DECLARE_MESSAGE_MAP()

public:
    // Helpers.
    void UpdateSeparators (int idCommand, BOOL fHiding);
    void UpdateToolbarSize(bool bAsync);
    SC   ScInit(CRebarDockWindow* pRebar);
    SC   ScHideButton(int idCommand, BOOL fHiding);

    // Attributes
private:
    CAMCViewToolbars* m_pActiveAMCViewToolbars;
};

#endif /* TOOLBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\treectrl.cpp ===
// TreeCtrl.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amctreectrl.cpp
//
//  Contents:  AMC Tree control implementation
//
//  History:   16-Jul-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------



#include "stdafx.h"

#include "AMCDoc.h"         // AMC Console Document
#include "amcview.h"
#include "childfrm.h"

#include "macros.h"
#include "AMCPriv.h"

#include "AMC.h"
#include "mainfrm.h"
#include "TreeCtrl.h"
#include "resource.h"

#include "guidhelp.h" // LoadRootDisplayName
#include "histlist.h"
#include "websnk.h"
#include "webctrl.h"
#include "..\inc\mmcutil.h"
#include "amcmsgid.h"
#include "resultview.h"
#include "eventlock.h"

extern "C" UINT dbg_count;

//############################################################################
//############################################################################
//
// Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagTree(TEXT("Tree View"), TEXT("Tree View"));
#endif //DBG

//############################################################################
//############################################################################
//
// Implementation of class CTreeViewMap
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScOnItemAdded
 *
 * PURPOSE: Called when an item is added. Indexes the item.
 *
 * PARAMETERS:
 *    TVINSERTSTRUCT * pTVInsertStruct :
 *    HTREEITEM        hti :
 *    HMTNODE          hMTNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScOnItemAdded   (TVINSERTSTRUCT *pTVInsertStruct, HTREEITEM hti, HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScOnItemAdded"));

    // validate parameters
    sc = ScCheckPointers(pTVInsertStruct);
    if(sc)
        return sc;

    if(!hti || !hMTNode)
        return (sc = E_INVALIDARG);

    // create a new map info structure.
    TreeViewMapInfo *pMapInfo = new TreeViewMapInfo;
    if(!pMapInfo)
        return (sc = E_OUTOFMEMORY);

    // fill in the values
    pMapInfo->hNode   = CAMCTreeView::NodeFromLParam (pTVInsertStruct->item.lParam);
    pMapInfo->hti     = hti;
    pMapInfo->hMTNode = hMTNode;

    // set up the indexes
    ASSERT(m_hMTNodeMap.find(pMapInfo->hMTNode) == m_hMTNodeMap.end());
    ASSERT(m_hNodeMap.find(pMapInfo->hNode)     == m_hNodeMap.end());

    m_hMTNodeMap [pMapInfo->hMTNode] = pMapInfo;
    m_hNodeMap   [pMapInfo->hNode]   = pMapInfo;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScOnItemDeleted
 *
 * PURPOSE: Called when a tree item is deleted. Removes the item from the
 *          indexes.
 *
 * PARAMETERS:
 *    HNODE      hNode :
 *    HTREEITEM  hti :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScOnItemDeleted (HNODE hNode, HTREEITEM hti)
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScOnItemDeleted"));

    // validate parameters
    sc = ScCheckPointers((LPVOID) hNode, (LPVOID) hti);
    if(sc)
        return sc;


    // remove the TreeViewMapInfo pointer from all the maps
    HNodeLookupMap::iterator iter = m_hNodeMap.find(hNode);
    if(iter == m_hNodeMap.end())
        return (sc = E_UNEXPECTED);

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    HMTNODE   hMTNode = pMapInfo->hMTNode;

#ifdef DBG
    // verify that the same structure is pointed to by the other maps.
    ASSERT(m_hMTNodeMap.find(hMTNode)->second == pMapInfo);
#endif

    m_hMTNodeMap.erase(hMTNode);
    m_hNodeMap.erase(hNode);

    // finally delete the TreeViewMapInfo structure
    delete pMapInfo;

    return sc;
}


// Fast lookup methods
/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScGetHNodeFromHMTNode
 *
 * PURPOSE: Quickly (log n time) retrieves the HNODE for an HMTNODE.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode :
 *    ou       t :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScGetHNodeFromHMTNode    (HMTNODE hMTNode,  /*out*/ HNODE*     phNode)    // fast conversion from hNode to hMTNode.
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScGetHNode"));

    // validate parameters
    sc = ScCheckPointers((LPVOID) hMTNode, phNode);
    if(sc)
        return sc;

    // find the mapinfo structure.
    HMTNodeLookupMap::iterator iter = m_hMTNodeMap.find(hMTNode);
    if(iter == m_hMTNodeMap.end())
        return (sc = ScFromMMC(IDS_NODE_NOT_FOUND));

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    *phNode = pMapInfo->hNode;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScGetHTreeItemFromHNode
 *
 * PURPOSE:  Quickly (log n time) retrieves the HTREEITEM for an HNODE.
 *
 * PARAMETERS:
 *    HNODE    hNode :
 *    ou       t :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScGetHTreeItemFromHNode(HNODE   hNode,    /*out*/ HTREEITEM* phti)    // fast conversion from HTREEITEM to HNODE
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScGetHTreeItem"));

    // validate parameters
    sc = ScCheckPointers((LPVOID) hNode, phti);
    if(sc)
        return sc;

    // find the mapinfo structure.
    HNodeLookupMap::iterator iter = m_hNodeMap.find(hNode);
    if(iter == m_hNodeMap.end())
        return (sc = E_UNEXPECTED);

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    *phti = pMapInfo->hti;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScGetHTreeItemFromHMTNode
 *
 * PURPOSE: Quickly (log n time) retrieves the HTREEITEM for an HMTNODE.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode :
 *    ou       t :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScGetHTreeItemFromHMTNode(HMTNODE hMTNode,  /*out*/ HTREEITEM* phti)      // fast conversion from HMTNode to HTREEITEM.
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScGetHTreeItem"));

    // validate parameters
    //sc = ScCheckPointers(hMTNode, phti);
    if(sc)
        return sc;

    // find the mapinfo structure.
    HMTNodeLookupMap::iterator iter = m_hMTNodeMap.find(hMTNode);
    if(iter == m_hMTNodeMap.end())
        return (sc = E_UNEXPECTED);

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    *phti = pMapInfo->hti;

    return sc;
}


//############################################################################
//############################################################################
//
// Implementation of class CAMCTreeView
//
//############################################################################
//############################################################################

/////////////////////////////////////////////////////////////////////////////
// CAMCTreeView

DEBUG_DECLARE_INSTANCE_COUNTER(CAMCTreeView);

CAMCTreeView::CAMCTreeView()
    :   m_FontLinker (this)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CAMCTreeView);

    m_fInCleanUp = FALSE;
    m_fInExpanding = FALSE;

    m_pAMCView = NULL;

    SetHasList(TRUE);
    SetTempSelectedItem (NULL);
    ASSERT (!IsTempSelectionActive());

    AddObserver(static_cast<CTreeViewObserver&>(m_treeMap)); // add an observer to this control.
}

CAMCTreeView::~CAMCTreeView()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAMCTreeView);
    // Smart pointer are released during their destructor
}


IMPLEMENT_DYNCREATE(CAMCTreeView, CTreeView)

BEGIN_MESSAGE_MAP(CAMCTreeView, CTreeView)
    //{{AFX_MSG_MAP(CAMCTreeView)
    ON_WM_CREATE()
    ON_NOTIFY_REFLECT(TVN_SELCHANGED,  OnSelChanged)
    ON_NOTIFY_REFLECT(TVN_SELCHANGING, OnSelChanging)
    ON_NOTIFY_REFLECT(TVN_GETDISPINFO, OnGetDispInfo)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemExpanded)
    ON_WM_DESTROY()
    ON_WM_KEYDOWN()
    ON_WM_SYSKEYDOWN()
    ON_WM_SYSCHAR()
    ON_WM_MOUSEACTIVATE()
    ON_WM_SETFOCUS()
    ON_NOTIFY_REFLECT(TVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(TVN_BEGINRDRAG, OnBeginRDrag)
    ON_WM_KILLFOCUS()
    //}}AFX_MSG_MAP

    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)
END_MESSAGE_MAP()


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::ScSetTempSelection
 *
 * Applies temporary selection to the specified HTREEITEM.
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::ScSetTempSelection (HTREEITEM htiTempSelect)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCTreeView::ScSetTempSelection"));

    /*
     * Don't use ScSetTempSelection(NULL) to remove temporary selection;
     * use ScRemoveTempSelection instead.
     */
    ASSERT (htiTempSelect != NULL);
    if (htiTempSelect == NULL)
        return (sc = E_FAIL);

    /*
     * If this fails, you must first call ScRemoveTempSelection to remove
     * the temporary selection state (TVIS_SELECTED) from the current
     * temporary selection.
     */
    ASSERT (!IsTempSelectionActive());

    SetTempSelectedItem (htiTempSelect);
    ASSERT (GetTempSelectedItem() == htiTempSelect);

    HTREEITEM htiSelected = GetSelectedItem();

    if (htiSelected != htiTempSelect)
    {
        SetItemState (htiSelected,   0,             TVIS_SELECTED);
        SetItemState (htiTempSelect, TVIS_SELECTED, TVIS_SELECTED);
    }

    ASSERT (IsTempSelectionActive());
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::ScRemoveTempSelection
 *
 * Removes the temporary selection from the current temporarily selected
 * item, if there is one, and restores it to the item that was selected
 * when the temp selection was applied.
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::ScRemoveTempSelection ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCTreeView::ScRemoveTempSelection"));

    if (!IsTempSelectionActive())
        return (sc = S_FALSE);

    HTREEITEM htiTempSelect = GetTempSelectedItem();
    HTREEITEM htiSelected   = GetSelectedItem();

    if (htiTempSelect != htiSelected)
    {
        SetItemState (htiTempSelect, 0,             TVIS_SELECTED);
        SetItemState (htiSelected,   TVIS_SELECTED, TVIS_SELECTED);
    }

    SetTempSelectedItem (NULL);
    ASSERT (!IsTempSelectionActive());

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::ScReselect
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::ScReselect ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    NM_TREEVIEW nmtv;

    nmtv.itemOld.hItem = nmtv.itemNew.hItem = GetSelectedItem();

    if (nmtv.itemOld.hItem)
    {
        nmtv.itemOld.lParam = nmtv.itemNew.lParam = GetItemData(nmtv.itemOld.hItem);

        LRESULT lUnused;
        OnSelChangingWorker (&nmtv, &lUnused);
        OnSelChangedWorker  (&nmtv, &lUnused);
    }

    return (S_OK);
}

/////////////////////////////////////////////////////////////////////////////
// CAMCTreeView message handlers


BOOL CAMCTreeView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style     |= TVS_EDITLABELS | TVS_HASBUTTONS | TVS_HASLINES | TVS_SHOWSELALWAYS;
    cs.dwExStyle |= WS_EX_CLIENTEDGE;

    // do not paint over the children
    cs.style |= WS_CLIPCHILDREN;

    return CTreeView::PreCreateWindow(cs);
}


INodeCallback*  CAMCTreeView::GetNodeCallback()
{
    return m_pAMCView->GetNodeCallback();
}

inline IScopeTreeIter* CAMCTreeView::GetScopeIterator()
{
    return m_pAMCView->GetScopeIterator();
}

inline IScopeTree* CAMCTreeView::GetScopeTree()
{
    return m_pAMCView->GetScopeTree();
}

void CAMCTreeView::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult)
{
    HRESULT hr;
    TV_DISPINFO* ptvdi = (TV_DISPINFO*)pNMHDR;

    HNODE hNode = NodeFromLParam (ptvdi->item.lParam);
    ASSERT(m_pAMCView != NULL);

    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);
    if (hNode)
    {
        if (ptvdi->item.mask & TVIF_TEXT)
        {
            tstring strName;
            hr = spCallback->GetDisplayName(hNode, strName);
            if (hr != S_OK)
            {
                ptvdi->item.pszText[0] = _T('\0');
                ASSERT(FALSE);
            }
            else
            {
                // copy the text, but not too much
                ASSERT (!IsBadWritePtr (ptvdi->item.pszText, ptvdi->item.cchTextMax));
                _tcsncpy (ptvdi->item.pszText, strName.data(), ptvdi->item.cchTextMax);

                /*
                 * _tcsncpy won't terminate the destination if the
                 * source is bigger than the buffer; make sure the
                 * string is NULL-terminated
                 */
                ptvdi->item.pszText[ptvdi->item.cchTextMax-1] = _T('\0');

                /*
                 * If this is the selected item and it's text has changed,
                 * fire an event so observers can know.
                 */
                if ((m_strSelectedItemText != strName.data()) &&
                    (GetSelectedItem() == ptvdi->item.hItem))
                {
                    m_strSelectedItemText = strName.data();
                    SC sc = ScFireEvent (CTreeViewObserver::ScOnSelectedItemTextChanged,
                                         (LPCTSTR) m_strSelectedItemText);
                    if (sc)
                        sc.TraceAndClear();
                }
            }
        }

        int nImage, nSelectedImage;
        hr = spCallback->GetImages(hNode, &nImage, &nSelectedImage);

#ifdef DBG
        if (hr != S_OK)
        {
            ASSERT(nImage == 0 && nSelectedImage == 0);
        }
#endif
        if (ptvdi->item.mask & TVIF_IMAGE)
            ptvdi->item.iImage = nImage;

        if (ptvdi->item.mask & TVIF_SELECTEDIMAGE)
            ptvdi->item.iSelectedImage = nSelectedImage;

        // We will get this request once, the first time the scope item comes into view
        if (ptvdi->item.mask & TVIF_CHILDREN)
        {
            ptvdi->item.cChildren = (spCallback->IsExpandable(hNode) != S_FALSE);

            // set children to fixed value, to avoid any more callbacks
            SetCountOfChildren(ptvdi->item.hItem, ptvdi->item.cChildren);
        }
    }
    else
    {
        ASSERT(0 && "OnGetDispInfo(HNODE is NULL)");
    }

    *pResult = 0;
}


//
// Description:  This method will set the folders Button(+/-) on or
// of depending on the value of bState
//
// Parameters:
//      hItem: the tree item affected
//      bState: TRUE = Enable for folder to show it has children
//              FALSE = Disable for folder to show it has NO children
//
void CAMCTreeView::SetButton(HTREEITEM hItem, BOOL bState)
{
    ASSERT(hItem != NULL);

    TV_ITEM item;
    ZeroMemory(&item, sizeof(item));

    item.hItem = hItem;
    item.mask =  TVIF_HANDLE | TVIF_CHILDREN;
    item.cChildren = bState;

    SetItem(&item);
}

//+-------------------------------------------------------------------
//
//  Member:    CAMCTreeView::ExpandNode
//
//  Synopsis:  This method populates hItem's(parent folder) children into
//             the tree control.
//             In the first phase, Expand notifications are sent to the snapin
//             which causes all children to be inserted to the master scope 
//             tree.
//             In the second phase, we step through these children and insert 
//             them to the tree controls. 
//             For performance reasons, we walk the child list in reverse order
//             (last child to first child) inserting the current item at the 
//             first position. 
//             If we were to walk the child list in normal order (first to last
//             child) inserting the current item at the last position -- the
//             underlying tree control takes time that grows exponentially in
//             the number of children (as opposed to linearly).
//
//  Arguments: hItem: the parent 
//
//  Returns:   TRUE on success and FALSE on failure 
//
//--------------------------------------------------------------------
BOOL CAMCTreeView::ExpandNode(HTREEITEM hItem)
{
    TRACE_METHOD(CAMCTreeView, ExpandNode);

    // not frequently, but... snap-in will display the dialog, dismissing that will
    // activate the frame again. Tree item will be automatically selected if there
    // is none selected yet. Following will prevent the recursion.
    if (m_fInExpanding)
        return FALSE;

    HRESULT hr;

    // Get the HNODE from the tree node
    HNODE hNode = GetItemNode(hItem);
    ASSERT(hNode != NULL);
    ASSERT(m_pAMCView != NULL);

    HMTNODE hMTNode;
    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);
    hr = spCallback->GetMTNode(hNode, &hMTNode);
    ASSERT(hr == S_OK);

    if (hr == S_OK)
    {
        // The notify will return S_FALSE to indicate already expanded
        // or E_xxxx to indicate an error.

        hr = spCallback->Notify(hNode, NCLBK_EXPAND, FALSE, 0);

        if (hr == S_FALSE)
        {

            __try
            {
                m_fInExpanding = TRUE;
                hr = spCallback->Notify(hNode, NCLBK_EXPAND, TRUE, 0);
            }
            __finally
            {
                m_fInExpanding = FALSE;
            }

            if (SUCCEEDED(hr))
            {
                IScopeTreeIter* spIterator = m_pAMCView->GetScopeIterator();
                hr = spIterator->SetCurrent(hMTNode);
                HMTNODE hMTChildNode;

                // Get the last child for the current iterator node:
                // (Starting node for walking the child list in reverse order)
                if ((spIterator->LastChild(&hMTChildNode) == S_OK) && 
                    (hMTChildNode)) // Do nothing if last child is NULL
                {
                    IScopeTree* spScopeTree = m_pAMCView->GetScopeTree();
                    HNODE hNewNode;

                    // Set the last child as the "current" iterator node
                    if (spIterator->SetCurrent(hMTChildNode) == S_OK)
                    {
                        HMTNODE hCurrentChildNode = hMTChildNode;
                        do
                        {
                            // Insert current node into the tree control
                            spScopeTree->CreateNode(hCurrentChildNode,
                              reinterpret_cast<LONG_PTR>(m_pAMCView->GetViewData()),
                              FALSE, &hNewNode);

#include "pushwarn.h"
#pragma warning(disable: 4552)      // "!=" operator has no effect
                            // Insert at the first position
                            VERIFY(InsertNode(hItem, hNewNode, TVI_FIRST) != NULL);
#include "popwarn.h"

                            // give 'em a chance to do the "preload" thing, if applicable
                            spCallback->PreLoad (hNewNode);

                            // Traverse the child list in reverse order:
                            // Set current iterator node to the previous sibling
                            hr = spIterator->Prev(&hCurrentChildNode);
                            if(FAILED(hr))
                                return FALSE;

                            // child list completely traversed. 
                            if (!hCurrentChildNode)
                                break;

                        } while (1);
                    }
                }

                spCallback->Notify(hNode, NCLBK_EXPANDED, 0, 0);
            }
        }
    }

    return SUCCEEDED(hr);
}

HTREEITEM CAMCTreeView::InsertNode(HTREEITEM hParent, HNODE hNode,
                                   HTREEITEM hInsertAfter)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::InsertNode"));
    ASSERT(hParent != NULL);
    ASSERT(hNode != NULL);
    HRESULT hr;

    TV_INSERTSTRUCT tvInsertStruct;
    TV_ITEM& item = tvInsertStruct.item;

    ZeroMemory(&tvInsertStruct, sizeof(tvInsertStruct));

    // Insert item at the end of the hItem chain
    tvInsertStruct.hParent = hParent;
    tvInsertStruct.hInsertAfter = hInsertAfter;

    item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN |
                TVIF_PARAM | TVIF_TEXT;

    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam = LParamFromNode (hNode);

    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);

    // Set callback mode for children, so we don't have to determine this
    // until the scope item becomes visible (it can be expensive).
    item.cChildren = I_CHILDRENCALLBACK;

    spCallback->GetImages(hNode, &item.iImage, &item.iSelectedImage);

    HTREEITEM hti = InsertItem(&tvInsertStruct);

    HMTNODE hMTNode = NULL;

    sc = spCallback->GetMTNode(hNode, &hMTNode);
    if(sc)
        sc.TraceAndClear();

    // send an event to all interested observers
    sc = ScFireEvent(CTreeViewObserver::ScOnItemAdded, &tvInsertStruct, hti, hMTNode);
    if(sc)
        sc.TraceAndClear();

    if (hParent != TVI_ROOT && hti != NULL)
        SetCountOfChildren(hParent, 1);

    return hti;
}

void CAMCTreeView::ResetNode(HTREEITEM hItem)
{
    if (hItem == NULL)
        return;

    TV_ITEM item;
    ZeroMemory(&item, sizeof(item));

    item.hItem = hItem;
    item.mask =  TVIF_HANDLE | TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE |
                 TVIF_STATE | TVIF_TEXT | TVIF_CHILDREN;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.iImage = I_IMAGECALLBACK;
    item.iSelectedImage = I_IMAGECALLBACK;
    item.cChildren = I_CHILDRENCALLBACK;
    item.lParam = GetItemData(hItem);

    SetItem(&item);
}


void CAMCTreeView::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
    TRACE_METHOD(CAMCTreeView, OnItemExpanding);

    HRESULT hr;

    NM_TREEVIEW* pNotify = (NM_TREEVIEW*)pNMHDR;
    ASSERT(pNotify != NULL);

    HTREEITEM &hItem = pNotify->itemNew.hItem;
    ASSERT(hItem != NULL);

    BOOL bExpand = FALSE;

    // Iteratate the folders below this item
    if (pNotify->action == TVE_EXPAND)
    {
        /*
         * Bug 333971:  Node expansion might take awhile.  Supply a wait cursor
         * for all of the UI-challenged snap-ins out there.
         */
        SetCursor (LoadCursor (NULL, IDC_WAIT));

        ExpandNode(hItem);
        bExpand = TRUE;

        /*
         * return the arrow
         */
        SetCursor (LoadCursor (NULL, IDC_ARROW));
    }

    INodeCallback* pCallback = GetNodeCallback();
    ASSERT(pCallback != NULL);
    HNODE hNode = GetItemNode (hItem);
    pCallback->Notify(hNode, NCLBK_SETEXPANDEDVISUALLY, bExpand, 0);

    // If item has no children remove the + sign
    if (GetChildItem(hItem) == NULL)
        SetButton(hItem, FALSE);

    *pResult = 0;
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnItemExpanded
 *
 * TVN_ITEMEXPANDED handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC (sc, _T("CAMCTreeView::OnItemExpanded"));

    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
    sc = ScCheckPointers (pnmtv);
    if (sc)
        return;

    /*
     * Bug 23153:  when collapsing, totally collapse the tree beneath the
     * collapsing item.  We do this in OnItemExpanded rather than
     * OnItemExpanding so we won't see the collapse happen.
     */
    if (pnmtv->action == TVE_COLLAPSE)
    {
        CWaitCursor wait;
        CollapseChildren (pnmtv->itemNew.hItem);
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CollapseChildren
 *
 * Collapses each descendent node of htiParent.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::CollapseChildren (HTREEITEM htiParent)
{
    HTREEITEM htiChild;

    for (htiChild  = GetChildItem (htiParent);
         htiChild != NULL;
         htiChild  = GetNextItem (htiChild, TVGN_NEXT))
    {
        Expand (htiChild, TVE_COLLAPSE);
        CollapseChildren (htiChild);
    }
}

void CAMCTreeView::OnDeSelectNode(HNODE hNode)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnDeSelectNode"));

    {
        // tell all interested observers about the deselection.
        // NOTE: the order is important - legacy snapins believe they can access the
        // result pane at this point and have the items still there.
        // But this is intermediate state, so Com events are locked out until the
        // results are cleared.
        // see windows bug (ntbug09) bug# 198660. (10/11/00)
        LockComEventInterface(AppEvents);
        sc = ScFireEvent(CTreeViewObserver::ScOnItemDeselected, hNode);
        if(sc)
            return;

        // Ensure the result view is clean.
        if (HasList())
        {
            // First findout if the result view is properly
            // set in the nodemgr by asking IFramePrivate.
            IFramePrivatePtr spFrame = m_spResultData;
            if (NULL != spFrame)
            {
                BOOL bIsResultViewSet = FALSE;
                sc = spFrame->IsResultViewSet(&bIsResultViewSet);

                // The result view is set, clean it up.
                if (bIsResultViewSet)
                {
                    m_spResultData->DeleteAllRsltItems();
                    m_spResultData->ResetResultData();
                }
            }
        }
    }

    // don't have a valid result pane type anymore.
    SetHasList(false);
}



// Note that OnSelectNode will return S_FALSE if the snap-in changes
// the selection during the process of selecting the requested node.
// A caller that gets an S_FALSE should assume that a different node
// is selected and continue accordingly.
HRESULT CAMCTreeView::OnSelectNode(HTREEITEM hItem, HNODE hNode)
{
    DECLARE_SC(sc, _T("CAMCTreeView::OnSelectNode"));

    if (!hItem)
    {
        TraceError(_T("Null hItem ptr\n"), sc);
        sc = S_FALSE;
        return sc.ToHr();
    }

    if (!hNode)
    {
        TraceError(_T("Null hNode ptr\n"), sc);
        sc = S_FALSE;
        return sc.ToHr();
    }


    // First ensure that the node has been enumerated by calling expand node.
    ExpandNode(hItem);


    // set up the AMCView correctly.
    BOOL bAddSubFolders = FALSE;

    sc = m_pAMCView->ScOnSelectNode(hNode, bAddSubFolders);
    if(sc)
        return sc.ToHr();

    SetHasList(m_pAMCView->HasList());

    // add subfolders if necessary.
    if(bAddSubFolders)
    {
        sc = AddSubFolders(hItem, m_spResultData);
        if (sc)
            return sc.ToHr();
    }

    if (HasList())
        m_spResultData->SetLoadMode(FALSE); // SetLoadMode(FALSE) was called by CAMCView::OnSelectNode.
                                            // Need to change so that both calls are from the same function.

    // get the node callback
    INodeCallback* spNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(spNodeCallBack, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // send preload notify to children
    HTREEITEM hti = GetChildItem (hItem);
    while (hti != NULL)
    {
        HNODE hNode = GetItemNode (hti);
        if (hNode != 0)
            spNodeCallBack->PreLoad (hNode);
        hti = GetNextItem(hti, TVGN_NEXT);
    }


    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::SetNavigatingWithKeyboard
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCTreeView::SetNavigatingWithKeyboard (bool fKeyboardNav)
{
    /*
     * if the requested state doesn't match the current state,
     * change the current state to match the request
     */
    if (fKeyboardNav != IsNavigatingWithKeyboard())
    {
        m_spKbdNavDelay = std::auto_ptr<CKeyboardNavDelay>(
                                (fKeyboardNav)
                                        ? new CKeyboardNavDelay (this)
                                        : NULL /*assigning NULL deletes*/);
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnSelChanging
 *
 * TVN_SELCHANGING handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnSelChanging(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    if (!IsNavigatingWithKeyboard())
        OnSelChangingWorker ((NM_TREEVIEW*) pNMHDR, pResult);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnSelChanged
 *
 * TVN_SELCHANGED handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pNMHDR;
    *pResult = 0;

    if (IsNavigatingWithKeyboard())
        m_spKbdNavDelay->ScStopTimer();

    SetNavigatingWithKeyboard (pnmtv->action == TVC_BYKEYBOARD);

    bool fDelayedSelection = IsNavigatingWithKeyboard() &&
                             !m_spKbdNavDelay->ScStartTimer(pnmtv).IsError();

    if (!fDelayedSelection)
        OnSelChangedWorker (pnmtv, pResult);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CKeyboardNavDelay::CKeyboardNavDelay
 *
 *
 *--------------------------------------------------------------------------*/

CAMCTreeView::CKeyboardNavDelay::CKeyboardNavDelay (CAMCTreeView* pTreeView) :
    m_pTreeView (pTreeView)
{
    ZeroMemory (&m_nmtvSelChanged, sizeof (m_nmtvSelChanged));
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CKeyboardNavDelay::OnTimer
 *
 * Called when the keyboard navigation delay timer fires.  When that happens,
 * we need to perform the selection
 *--------------------------------------------------------------------------*/

void CAMCTreeView::CKeyboardNavDelay::OnTimer()
{
    /*
     * we don't need any more ticks from this timer (ignoring errors)
     */
    ScStopTimer();
    Trace (tagKeyboardNavDelay, _T("Applying delayed scope selection change"));

    LRESULT lUnused = 0;
    m_pTreeView->OnSelChangedWorker (&m_nmtvSelChanged,  &lUnused);
    m_pTreeView->SetNavigatingWithKeyboard (false);

    /*
     * HANDS OFF!  CAMCTreeView::SetNavigatingWithKeyboard deleted this object!
     */
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CKeyboardNavDelay::ScStartTimer
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::CKeyboardNavDelay::ScStartTimer(NMTREEVIEW* pnmtv)
{
    DECLARE_SC (sc, _T("CAMCTreeView:CKeyboardNavDelay::ScStartTimer"));

    /*
     * let the base class start the timer
     */
    sc = BaseClass::ScStartTimer();
    if (sc)
        return (sc);

    /*
     * copy the notification struct so we can send it when our timer ticks
     */
    m_nmtvSelChanged = *pnmtv;

    return (sc);
}


void CAMCTreeView::OnSelChangedWorker(NM_TREEVIEW* pnmtv, LRESULT* pResult)
{
    TRACE_METHOD(CAMCTreeView, OnSelChangedWorker);

    if (m_fInCleanUp == TRUE)
        return;

    // See which pane has focus. Some snapins/ocx may steal the focus
    // so we restore the focus after selecting the node.
    ASSERT (m_pAMCView != NULL);
    const CConsoleView::ViewPane ePane = m_pAMCView->GetFocusedPane();

    //
    // Select the new node
    //

    // Disable drawing to avoid seeing intermediate tree states.
    UpdateWindow();
    HRESULT hr = OnSelectNode(pnmtv->itemNew.hItem, (HNODE)pnmtv->itemNew.lParam);

    if (hr == S_OK)
    {
        CStandardToolbar* pStdToolbar = m_pAMCView->GetStdToolbar();
        ASSERT(NULL != pStdToolbar);
        if (NULL != pStdToolbar)
        {
            pStdToolbar->ScEnableUpOneLevel(GetRootItem() != pnmtv->itemNew.hItem);

            pStdToolbar->ScEnableExportList(m_pAMCView->HasListOrListPad());
        }
        *pResult = 0;
    }
    else if (hr == S_FALSE)
    {
        // snap-in changed the selection on us, so don't continue with this node.
        return;
    }
    else
    {
        // something wrong with the node we are trying to select, reselect the old one
//      SelectItem(pnmtv->itemOld.hItem);
        MMCMessageBox(IDS_SNAPIN_FAILED_INIT);
        *pResult = hr;
    }

    /*
     * Even if the active view hasn't changed always restore the active view.
     * Reason being, for OCX's even though they have the focus, they require
     * MMC to inform that OCX being selected. (see bug: 180964)
     */
    switch (ePane)
    {
        case CConsoleView::ePane_ScopeTree:
        {
            // if another view was made active, switch it back.
            // View could still be active, but have focus stolen by
            // a snap-in or ocx, so ensure view has focus too.
            CFrameWnd* pFrame = GetParentFrame();

            if (pFrame->GetActiveView() != this)
                pFrame->SetActiveView(this);

            else if (::GetFocus() != m_hWnd)
                SetFocus();

            break;
        }

        case CConsoleView::ePane_Results:
            // If the result pane has the focus before and after
            // the node was selected, then the last event snapin
            // receives is scope selected which is incorrect.
            // So we first set scope pane as active view but do
            // not send notifications. Then we set result pane
            // as active view which sends scope de-select and
            // result pane select.


            // Set Scope pane as active view and we also want to
            // be notified about this active view so that our
            // view activation observers will know who is the
            // active view.
            GetParentFrame()->SetActiveView(this, true);

            // Now set result pane as active view and ask for notifications.
            m_pAMCView->ScDeferSettingFocusToResultPane();
            break;

        case CConsoleView::ePane_None:
            // no pane is active, do nothing
            break;

        default:
            m_pAMCView->ScSetFocusToPane (ePane);
            break;
    }

    /*
     * Bug 345402:  Make sure the focus rect is on the list control (if it
     * actually has the focus) to wake up any accessibility tools that might
     * be watching for input and focus changes.
     */
    m_pAMCView->ScJiggleListViewFocus ();
}


void CAMCTreeView::OnSelChangingWorker (NM_TREEVIEW* pnmtv, LRESULT* pResult)
{
    TRACE_METHOD(CAMCTreeView, OnSelChangingWorker);

    if (m_fInCleanUp == TRUE)
        return;

    //
    // De-select the current node
    //
    OnDeSelectNode ((HNODE)pnmtv->itemOld.lParam);

    *pResult = 0;
}




HRESULT CAMCTreeView::AddSubFolders(MTNODEID* pIDs, int length)
{
    ASSERT(pIDs != NULL && length != 0);

    HRESULT hr = E_FAIL;

    // first make sure the specified node is expanded in the tree ctrl
    HTREEITEM hti = ExpandNode(pIDs, length, TRUE, false /*bExpandVisually*/);
    ASSERT(hti != NULL);

    // if successful, add the node's subfolders to the list view
    if (hti != NULL)
    {
        hr = AddSubFolders(hti, m_spResultData);
        ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT CAMCTreeView::AddSubFolders(HTREEITEM hti, LPRESULTDATA pResultData)
{
    HRESULT hr;
    RESULTDATAITEM tRDI;
    ::ZeroMemory(&tRDI, sizeof(tRDI));

    tRDI.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    tRDI.nCol = 0;
    tRDI.str = MMC_TEXTCALLBACK;
    tRDI.nImage = MMC_IMAGECALLBACK;
    tRDI.nIndex = -1;

    hti = GetChildItem(hti);

    ASSERT(m_pAMCView != NULL);
    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);

    while (hti != NULL)
    {
        HNODE hNode = GetItemNode (hti);

        if (hNode != 0)
        {
            tRDI.lParam = LParamFromNode (hNode);

            hr = pResultData->InsertItem(&tRDI);
            CHECK_HRESULT(hr);

            if (SUCCEEDED(hr))
                hr = spCallback->SetResultItem(hNode, tRDI.itemID);

            // add custom image if any
            spCallback->AddCustomFolderImage (hNode, m_spRsltImageList);
        }

        hti = GetNextItem(hti, TVGN_NEXT);
    }

    return S_OK;
}


int CAMCTreeView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC (sc, _T("CAMCTreeView::OnCreate"));
    TRACE_METHOD(CAMCTreeView, OnCreate);

    if (CTreeView::OnCreate(lpCreateStruct) == -1)
        return -1;

    m_pAMCView = ::GetAMCView (this);
    
    if (NULL == m_pAMCView)
    {
        ASSERT(m_pAMCView != NULL);
        sc = E_UNEXPECTED;
        return (-1);
    }

    IScopeTree* spScopeTree = m_pAMCView->GetScopeTree();
    ASSERT(spScopeTree != NULL);

    HIMAGELIST hImageList;
    spScopeTree->GetImageList(reinterpret_cast<PLONG_PTR>(&hImageList));

    CBitmap bmp;
    bmp.LoadBitmap(MAKEINTRESOURCE(IDB_AMC_NODES16));
    int i = ImageList_AddMasked(hImageList, (HBITMAP) bmp.GetSafeHandle(), RGB(255,0,255));

    ASSERT(i != -1 && "ImageList_Add failed.");

    TreeView_SetImageList( *this, hImageList, TVSIL_NORMAL );

    sc = ScRegisterAsDropTarget(m_hWnd);
    if (sc)
        return (-1);

    sc = CreateNodeManager();
    if (sc)
        return (-1);

    return 0;
}

BOOL CAMCTreeView::DestroyWindow()
{
    TRACE_METHOD(CAMCTreeView, DestroyWindow);

    CleanUp();

    return CTreeView::DestroyWindow();
}

void
CAMCTreeView::DeleteNode(
    HTREEITEM htiToDelete,
    BOOL fDeleteThis)
{
    // Ensure curr sel is not a child of the item to be deleted.
    for (HTREEITEM hti = GetSelectedItem();
         hti != NULL;
         hti = GetParentItem(hti))
    {
        if (htiToDelete == hti)
        {
            if (fDeleteThis == TRUE)
            {
                hti = GetParentItem(hti);
                if (hti)
                    SelectItem(hti);
            }
            break;
        }
    }

    // There are two paths to this function.  Path 1, the view is deleted and there is no
    // longer a root node.  Path 2. When a node is manually deleted, the selection is updated
    // in CAMCView::OnUpdateSelectionForDelete, therefore, the above code traverses to the root node

    ASSERT(hti == NULL || fDeleteThis == FALSE);

    // Collapse the node for performance reasons:
    // For each node deleted, the underlying tree control re-adjusts
    // the scroll bar dimensions. This involves walking the succeeding
    // visible nodes; collapsing reduces the number of such nodes.
    Expand(htiToDelete, TVE_COLLAPSE);

    SDeleteNodeInfo dniLocal = {htiToDelete, hti, fDeleteThis};
    _DeleteNode(dniLocal);
}

void CAMCTreeView::_DeleteNode(SDeleteNodeInfo& dni)
{
   ASSERT(&dni != NULL);
   ASSERT(dni.htiToDelete != NULL);

    if (dni.htiToDelete == NULL)
        return;

   SDeleteNodeInfo dniLocal = {GetChildItem(dni.htiToDelete),
                               dni.htiSelected, TRUE};
   // delete all the child nodes of the node being deleted
   while (dniLocal.htiToDelete != NULL)
   {
       _DeleteNode(dniLocal);
       dniLocal.htiToDelete = GetChildItem(dni.htiToDelete);
   }

   if (dni.fDeleteThis == TRUE)
   {
       // Reset the temp selection cache.
       // This deals with items that are right click selected (temporary) on the context
       // menu
       if (IsTempSelectionActive() && (GetTempSelectedItem() == dni.htiToDelete))
       {
           SC sc = ScRemoveTempSelection ();
           if (sc)
               sc.TraceAndClear();
       }

       HNODE hNode = (HNODE)GetItemData(dni.htiToDelete);

       HTREEITEM htiParentOfItemToDelete = GetParentItem(dni.htiToDelete);

       // If the item is in list view remove it. We do not want to do this
       // if it is virtual list or if selected item is "Console Root"
       // in which case then parent is NULL.
       if (HasList() && !m_pAMCView->IsVirtualList() &&
           (NULL != htiParentOfItemToDelete) &&
           (htiParentOfItemToDelete == dni.htiSelected) )
       {
           HRESULTITEM itemID;
           HRESULT hr;
           hr = m_spResultData->FindItemByLParam(LParamFromNode(hNode), &itemID);
           if (SUCCEEDED(hr))
           {
               hr = m_spResultData->DeleteItem(itemID, 0);
               ASSERT(SUCCEEDED(hr));
           }
       }

       // tell the tree control to nuke it
       DeleteItem(dni.htiToDelete);

       // send an event to all interested observers
       SC sc = ScFireEvent(CTreeViewObserver::ScOnItemDeleted, hNode, dni.htiToDelete);
       if(sc)
           sc.TraceAndClear();

       // tell the master tree to nuke it.
       m_pAMCView->GetScopeTree()->DestroyNode(hNode);

       // maintain history
       m_pAMCView->GetHistoryList()->DeleteEntry (hNode);
   }
}

void CAMCTreeView::DeleteScopeTree()
{
    DECLARE_SC(sc, _T("CAMCTreeView::DeleteScopeTree"));

    m_fInCleanUp = TRUE;

    // Release the ResultView from the IFrame in the primary snapin in
    // the selected node.
    //      This is necessary to release the result view if the selected node
    //      is a snap-in node.

    // Free all the nodes
    HTREEITEM htiRoot = GetRootItem();
    if (htiRoot != NULL)
        DeleteNode(htiRoot, TRUE);

    // First findout if the result view is properly
    // set in the nodemgr by asking IFramePrivate.
    IFramePrivatePtr spFrame = m_spResultData;
    if (NULL != spFrame)
    {
        BOOL bIsResultViewSet = FALSE;
        sc = spFrame->IsResultViewSet(&bIsResultViewSet);

        // The result view is set, clean it up.
        if (bIsResultViewSet)
            sc = m_spResultData->DeleteAllRsltItems();
    }

    m_fInCleanUp = FALSE;
}

void CAMCTreeView::CleanUp()
{
    TRACE_METHOD(CAMCTreeView, CleanUp);

    m_fInCleanUp = TRUE;

    m_spNodeManager = NULL;
    m_spHeaderCtrl = NULL;
    m_spResultData = NULL;
    m_spRsltImageList = NULL;
    m_spScopeData = NULL;

    m_fInCleanUp = FALSE;
}

void CAMCTreeView::OnDestroy()
{
    TRACE_METHOD(CAMCTreeView, OnDestroy);

    //CleanUp();

    CTreeView::OnDestroy();

    CleanUp();
}

HRESULT CAMCTreeView::CreateNodeManager(void)
{
    TRACE_METHOD(CAMCTreeView, CreateNodeManager);

    if (m_spScopeData)
        return S_OK;

    #if _MSC_VER >= 1100
    IFramePrivatePtr pIFrame(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
    #else
    IFramePrivatePtr pIFrame(CLSID_NodeInit, MMC_CLSCTX_INPROC);
    #endif
    ASSERT(pIFrame != NULL); if (pIFrame == NULL) return E_FAIL;

    m_spScopeData = pIFrame;
    m_spHeaderCtrl = pIFrame;

    if (m_spHeaderCtrl)
        pIFrame->SetHeader(m_spHeaderCtrl);

    m_spResultData = pIFrame;
    m_spRsltImageList = pIFrame;
    m_spNodeManager = pIFrame;

    pIFrame->SetComponentID(TVOWNED_MAGICWORD);

    return S_OK;
}

HTREEITEM CAMCTreeView::GetClickedNode()
{
    TV_HITTESTINFO tvhi;
    tvhi.pt = (POINT)GetCaretPos();
    tvhi.flags = TVHT_ONITEMLABEL;
    tvhi.hItem = 0;

    HTREEITEM htiClicked = HitTest(&tvhi);
    return htiClicked;
}


void CAMCTreeView::GetCountOfChildren(HTREEITEM hItem, LONG* pcChildren)
{
    TV_ITEM tvi;
    tvi.hItem = hItem;
    tvi.mask = TVIF_CHILDREN;
    tvi.cChildren = 0;

    GetItem(&tvi);
    *pcChildren = tvi.cChildren;
}


void CAMCTreeView::SetCountOfChildren(HTREEITEM hItem, int cChildren)
{
    TV_ITEM tvi;
    tvi.hItem = hItem;
    tvi.mask = TVIF_HANDLE | TVIF_CHILDREN;
    tvi.cChildren = cChildren;

    SetItem(&tvi);
}


HTREEITEM CAMCTreeView::FindNode(HTREEITEM hti, MTNODEID id)
{
    INodeCallback* pCallback = GetNodeCallback();
    static MTNODEID nID = -1;
    static HRESULT hr = S_OK;

    hr = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return NULL;

    if (nID == id)
        return hti;

    HTREEITEM htiTemp = GetChildItem(hti);

    if (htiTemp != NULL)
        htiTemp = FindNode(htiTemp, id);

    if (htiTemp == NULL)
    {
        htiTemp = GetNextSiblingItem(hti);

        if (htiTemp != NULL)
            htiTemp = FindNode(htiTemp, id);
    }

    return htiTemp;

}


HTREEITEM CAMCTreeView::FindSiblingItem(HTREEITEM hti, MTNODEID id)
{
    INodeCallback* pCallback = GetNodeCallback();
    if (!pCallback)
        return NULL;

    static MTNODEID nID = -1;
    static HRESULT hr = S_OK;

    while (hti != NULL)
    {
        hr = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
        if (FAILED(hr))
            return NULL;

        if (nID == id)
            return hti;

        hti = GetNextSiblingItem(hti);
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCTreeView::SelectNode
//
//  Synopsis:    Given path to a node, select the node. If bSelectExactNode
//               is false then walk the path as much as possible and select
//               the last node in the best matched path. If bSelectExactNode
//               is true then select the node if available else do nothing.
//
//  Arguments:   [pIDs]             - [in] Array of node-id's (the path)
//               [length]           - [in] length of the above array
//               [bSelectExactNode] - [in] select the exact node or not?
//
//  Returns:     SC, return ScFromMMC(IDS_NODE_NOT_FOUND) if select exact node is specified
//               and it cannot be selected
//
//--------------------------------------------------------------------
SC CAMCTreeView::ScSelectNode(MTNODEID* pIDs, int length, bool bSelectExactNode /*= false*/)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScSelectNode"));
    sc = ScCheckPointers(pIDs);
    if (sc)
        return sc;

    if (m_fInExpanding)
        return (sc);

    HTREEITEM hti = GetRootItem();
    sc = ScCheckPointers( (void*)hti, E_UNEXPECTED);
    if (sc)
        return sc;

    if (pIDs[0] != ROOTNODEID)
        return (sc = E_INVALIDARG);

    INodeCallback* pCallback = GetNodeCallback();
    sc = ScCheckPointers(pCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    MTNODEID nID = 0;
    sc = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
    if (sc)
        return sc;

    bool bExactNodeFound = false;

    for (int i=0; i<length; ++i)
    {
        if (pIDs[i] == nID)
            break;
    }

    for (++i; i < length; ++i)
    {
        if (GetChildItem(hti) == NULL)
            Expand(hti, TVE_EXPAND);

        hti = FindSiblingItem(GetChildItem(hti), pIDs[i]);

        if (hti == NULL)
            break;
    }

    if (length == i)
        bExactNodeFound = true;

    if (hti)
    {
        // If exact node is to be selected make sure we have walked through the entire path.
        if ( (bSelectExactNode) && (! bExactNodeFound) )
            return ScFromMMC(IDS_NODE_NOT_FOUND); // do not trace this error.

        if (GetSelectedItem() == hti)
            ScReselect();
        else
            SelectItem(hti);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::Expand
 *
 * PURPOSE: Expands a particular tree item. This is just a wrapper around the
 *          tree control's expand method, which allows items to be expanded
 *          without changing the visual appearance of the tree.
 *
 * PARAMETERS:
 *    HTREEITEM  hItem :
 *    UINT       nCode :
 *    bool       bExpandVisually :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL
CAMCTreeView::Expand(HTREEITEM hItem, UINT nCode, bool bExpandVisually)
{
   if( (nCode==TVE_EXPAND) && (!bExpandVisually) )
    {
        bool bExpand = true;
        // code repeated here from OnItemExpand - we just mimic the effect of TVN_ITEMEXPANDING.
        ExpandNode(hItem);

        INodeCallback* pCallback = GetNodeCallback();
        ASSERT(pCallback != NULL);
        HNODE hNode = GetItemNode(hItem);
        pCallback->Notify(hNode, NCLBK_SETEXPANDEDVISUALLY, bExpand, 0);

        // If item has no children remove the + sign
        if (GetChildItem(hItem) == NULL)
            SetButton(hItem, FALSE);
        return true;
    }
    else
       return Expand(hItem, nCode);
 }

/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::ExpandNode
 *
 * PURPOSE: Expands a particular node in the tree.
 *
 * PARAMETERS:
 *    MTNODEID* pIDs :
 *    int       length :
 *    bool      bExpand :
 *    bool      bExpandVisually : valid only if bExpand is true. If bExpandVisually
 *                                is true, the items appear in the tree. If false,
 *                                the tree appears unchanged, although items have been
 *                                added.
 *
 * RETURNS:
 *    HTREEITEM
 *
 *+-------------------------------------------------------------------------*/
HTREEITEM
CAMCTreeView::ExpandNode(MTNODEID* pIDs, int length, bool bExpand, bool bExpandVisually)
{
    HTREEITEM hti = GetRootItem();
    ASSERT(hti != NULL);
    ASSERT(pIDs[0] == ROOTNODEID);

    INodeCallback* pCallback = GetNodeCallback();
    if (!pCallback)
        return NULL;

    MTNODEID nID = 0;
    HRESULT hr = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
    if (FAILED(hr))
        return NULL;

    for (int i=0; i<length; ++i)
    {
        if (pIDs[i] == nID)
            break;
    }

    for (++i; i < length; ++i)
    {
        if (GetChildItem(hti) == NULL)
            Expand(hti, TVE_EXPAND, bExpandVisually);

        hti = FindSiblingItem(GetChildItem(hti), pIDs[i]);

        if (hti == NULL)
            break;
    }

    if (hti)
        Expand(hti, bExpand ? TVE_EXPAND : TVE_COLLAPSE, bExpandVisually);

    return hti;
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnKeyDown
 *
 * WM_KEYDOWN handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
        case VK_DELETE:
            if (m_pAMCView->IsVerbEnabled(MMC_VERB_DELETE))
            {
                HTREEITEM hti = GetSelectedItem();
                if (hti != NULL)
                {
                    HNODE hNodeSel = GetItemNode(hti);
                    ASSERT(hNodeSel != NULL);

                    INodeCallback* pNC = GetNodeCallback();
                    ASSERT(pNC != NULL);
                    pNC->Notify(hNodeSel, NCLBK_DELETE, TRUE, 0);
                }
                return;
            }
            break;
    }

    CTreeView::OnKeyDown(nChar, nRepCnt, nFlags);
}


#ifdef DBG
void CAMCTreeView::DbgDisplayNodeName(HNODE hNode)
{
    ASSERT(hNode != NULL);

    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);

    tstring strName;
    HRESULT hr = spCallback->GetDisplayName(hNode, strName);

    ::MMCMessageBox( strName.data() );
}

void CAMCTreeView::DbgDisplayNodeName(HTREEITEM hti)
{
    DbgDisplayNodeName((HNODE)GetItemData(hti));
}

#endif

/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::OnSysKeyDown and CAMCTreeView::OnSysChar
 *
 * PURPOSE: Handle the WM_SYSKEYDOWN and WM_SYSCHAR messages. Note:
 *          VK_RETURN causes a beep if handled in WM_SYSKEYDOWN. And VK_LEFT and
 *          VK_RIGHT don't cause a WM_SYSCHAR. Thats why we need to handle these
 *          differently.
 *
 * PARAMETERS:
 *    UINT  nChar :
 *    UINT  nRepCnt :
 *    UINT  nFlags :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCTreeView::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
    case VK_LEFT:
    case VK_RIGHT:
    {
        CWnd* pwndParent = GetParent();
        ASSERT(pwndParent != NULL);
        if (pwndParent != NULL)
            pwndParent->SendMessage (WM_SYSKEYDOWN, nChar,
                                     MAKELPARAM (nRepCnt, nFlags));
        return;
    }

    default:
        break;
    }

    CTreeView::OnSysKeyDown(nChar, nRepCnt, nFlags);
}
void CAMCTreeView::OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnSysChar"));
    switch (nChar)
    {
    case VK_RETURN:
    {
        INodeCallback* pCallback = GetNodeCallback();
        CAMCView*      pAMCView  = GetAMCView();
        sc = ScCheckPointers(pAMCView, pCallback, E_UNEXPECTED);
        if (sc)
            return;

        if (! pAMCView->IsVerbEnabled(MMC_VERB_PROPERTIES))
            return;

        HTREEITEM hti = GetSelectedItem();
        if (!hti)
            break;

        HNODE hNode = (HNODE)GetItemData(hti);
        if (hNode != 0)
            pCallback->Notify(hNode, NCLBK_PROPERTIES, TRUE, 0);

        return;
    }

    default:
        break;
    }

    CTreeView::OnSysChar(nChar, nRepCnt, nFlags);
}


BOOL CAMCTreeView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (CTreeView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view didn't handle it, give parent view a chance
    if (m_pAMCView != NULL)
        return static_cast<CWnd*>(m_pAMCView)->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    else
        return FALSE;
}

int CAMCTreeView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
    /*------------------------------------------------------------------------*/
    /* Short out the WM_MOUSEACTIVATE here to prevent default processing,     */
    /* which is to send the message on to succeeding parent windows until     */
    /* one answers the message.  In our case, it goes all the way up to       */
    /* the main frame, which invariably decides to activate.  This is a       */
    /* problem for two reasons:                                               */
    /*                                                                        */
    /* 1.  On the way back down from the main frame, the message passes       */
    /*     through CAMCView, which lets CView::OnMouseActivate do the         */
    /*     work.  CView::OnMouseActivate will set itself (CAMCView) as        */
    /*     the active view, which in turn causes focus to be set to           */
    /*     the view.  CAMCView never wants the focus, since it is just        */
    /*     a frame for the scope and result panes, so it will deflect         */
    /*     the activation to the scope pane (CAMCTreeView) in                 */
    /*     CAMCView::OnSetFocus, which is where we want it to be.  If         */
    /*     we short out the processing here, we avoid excessive focus         */
    /*     churn.  It is essential that CAMCTreeView::OnSetFocus set          */
    /*     itself as the active view to keep the bookkeeping straight.        */
    /*                                                                        */
    /* 2.  If we don't short out here and avoid excessive focus churn,        */
    /*     we have a problem with sometimes erroneously entering rename       */
    /*     mode when the tree isn't active and the user clicks (once) on      */
    /*     the selected item.  An ordinary activation sequence goes like      */
    /*     this:  WM_MOUSEACTIVATE, WM_xBUTTONDOWN, WM_SETFOUS -- all to      */
    /*     the tree view.  The tree's button down processing doesn't enter    */
    /*     the label edit (i.e. rename) sequence because it recognizes        */
    /*     that it doesn't have the focus when the click happens.  When       */
    /*     the tree view is a CView, as in this case, CView::OnMouseActivate  */
    /*     sets the focus to the tree view, causing the activation sequence   */
    /*     to look like this:  WM_MOUSEACTIVATE, WM_SETFOCUS, WM_xBUTTONDOWN. */
    /*     Now the tree's button down processing sees that the tree has       */
    /*     the focus, so it enters label edit mode.  BUG!  Shorting out       */
    /*     here (and relying on CAMCTreeView::OnSetFocus to properly activate */
    /*     the view) fixes all that.                                          */
    /*------------------------------------------------------------------------*/

    return (MA_ACTIVATE);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnSetFocus
 *
 * WM_SETFOCUS handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnSetFocus(CWnd* pOldWnd)
{
    Trace(tagTree, TEXT("OnSetFocus"));

    /*
     * if this view has the focus, it should be the active view
     */
    GetParentFrame()->SetActiveView (this);

    CTreeView::OnSetFocus(pOldWnd);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnKillFocus
 *
 * WM_KILLFOCUS handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnKillFocus(CWnd* pNewWnd)
{
    Trace(tagTree, TEXT("OnKillFocus"));

    CTreeView::OnKillFocus(pNewWnd);

    /*
     * Bug 114948 (from the "Windows NT Bugs" database, aka "the overlapping
     * rectangle problem"):  The tree control has code to invalidate the
     * selected item when focus is lost.  If we have a temp selection, we've
     * made a temporary item appear selected by fiddling with TVIS_SELECTED
     * states (see ScSet/RemoveTempSelection). We need to do it that way
     * instead of sending TVM_SELECTITEM so we don't get unwanted
     * TVN_SELCHANGED notifications, but it has the side effect of fooling
     * the tree control's WM_KILLFOCUS handler into invalidating the non-temp
     * selected item instead of the item that is really showing selection, the
     * temp item.
     *
     * This bug was originally fixed with a sledgehammer, specifically by
     * forcing the entire main frame and all of its children to be totally
     * redrawn after displaying any context menu.  This caused bug 139541
     * (in the "Windows Bugs" database).
     *
     * A much more surgical fix to 114948, which also avoids 139541, is to
     * manually invalidate the temporarily selected item.  It's important
     * that we do this after calling the base class so it will be redrawn
     * in the "we don't have the focus" color (usually gray), rather than
     * the standard selection color.
     */
    if (IsTempSelectionActive())
    {
        CRect rectItem;
        GetItemRect (GetTempSelectedItem(), rectItem, false);
        RedrawWindow (rectItem);
    }
}


void CAMCTreeView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnActivateView"));

    #ifdef DBG
    Trace(tagTree, _T("TreeView::OnActivateView (%s, pAct=0x%08x, pDeact=0x%08x))\n"),
         (bActivate) ? _T("true") : _T("false"), pActivateView, pDeactiveView);
    #endif

    if ( (pActivateView != pDeactiveView) &&
         (bActivate) )
    {
        sc = ScFireEvent(CTreeViewObserver::ScOnTreeViewActivated);
        if (sc)
            sc.TraceAndClear();
    }

    CTreeView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnCustomDraw
 *
 * NM_CUSTOMDRAW handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult)
{
    NMCUSTOMDRAW* pnmcd = reinterpret_cast<NMCUSTOMDRAW *>(pNMHDR);
    ASSERT (CWnd::FromHandle (pnmcd->hdr.hwndFrom) == this);

    *pResult = m_FontLinker.OnCustomDraw (pnmcd);
}


/*+-------------------------------------------------------------------------*
 * CTreeFontLinker::GetItemText
 *
 *
 *--------------------------------------------------------------------------*/

std::wstring CTreeFontLinker::GetItemText (NMCUSTOMDRAW* pnmcd) const
{
    USES_CONVERSION;
    HTREEITEM  hItem = reinterpret_cast<HTREEITEM>(pnmcd->dwItemSpec);
    CTreeCtrl& tc    = m_pTreeView->GetTreeCtrl();

    return (std::wstring (T2CW (tc.GetItemText (hItem))));
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCTreeView::ScGetTreeItemIconInfo
//
//  Synopsis:    Get the given node's small icon.
//
//  Arguments:   [hNode] - for which info is needed.
//               [phIcon] - [out], ptr to HICON.
//
//  Note:        Caller calls DestroyIcon on the HICON returned.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCTreeView::ScGetTreeItemIconInfo(HNODE hNode, HICON *phIcon)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScGetTreeItemIconInfo"));
    sc = ScCheckPointers(hNode, phIcon);
    if (sc)
        return sc;

    INodeCallback* spNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(spNodeCallBack, m_pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the index.
    int nImage = -1;
    int nSelectedImage = -1;
    sc = spNodeCallBack->GetImages(hNode, &nImage, &nSelectedImage);
    if (sc)
        return sc;

    // Get the imagelist.
    HIMAGELIST hImageList = NULL;
    hImageList = TreeView_GetImageList(GetSafeHwnd(), TVSIL_NORMAL);
    if (! hImageList)
        return (sc = E_FAIL);

    *phIcon = ImageList_GetIcon(hImageList, nImage, ILD_TRANSPARENT);
    if (!*phIcon)
        return (sc = E_FAIL);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::ScRenameScopeNode
 *
 * PURPOSE: put the specified scope node into rename mode.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCTreeView::ScRenameScopeNode(HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScRenameScopeNode"));

    if(!IsWindowVisible())
        return (sc = E_FAIL);

    HTREEITEM hti = NULL;
    sc = m_treeMap.ScGetHTreeItemFromHMTNode(hMTNode,  &hti);
    if(sc)
        return sc;

    // must have the focus to rename
    if (::GetFocus() != m_hWnd)
        SetFocus();

    if(NULL==EditLabel(hti))
        return (sc = E_FAIL); // if for any reason the operation failed, return an error

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\treectrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       treectrl.h
//
//--------------------------------------------------------------------------

// TreeCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAMCTreeView window

#ifndef __TREECTRL_H__
#define __TREECTRL_H__

#include "fontlink.h"
#include "contree.h"        // for CConsoleTree
#include "kbdnav.h"			// for CKeyboardNavDelayTimer
#include "dd.h"

struct SDeleteNodeInfo
{
    HTREEITEM   htiToDelete;
    HTREEITEM   htiSelected;
    BOOL        fDeleteThis;
};


class CAMCTreeView;


class CTreeFontLinker : public CFontLinker
{
public:
    CTreeFontLinker (CAMCTreeView* pTreeView) : m_pTreeView (pTreeView)
        { ASSERT (m_pTreeView != NULL); }

protected:
    virtual std::wstring GetItemText (NMCUSTOMDRAW* pnmcd) const;

private:
    CAMCTreeView* const m_pTreeView;
};


/*+-------------------------------------------------------------------------*
 * class CTreeViewMap
 *
 *
 * PURPOSE: Maintains a fast lookup for converting between tree items,
 *          HNODES and HMTNODES.
 *
 *+-------------------------------------------------------------------------*/
class CTreeViewMap : public CTreeViewObserver
{
    // CTreeViewObserver methods
public:
    virtual SC ScOnItemAdded   (TVINSERTSTRUCT *pTVInsertStruct, HTREEITEM hti, HMTNODE hMTNode);
    virtual SC ScOnItemDeleted (HNODE hNode, HTREEITEM hti);

    // possible conversions
    // 1) HMTNODE   to HNODE     - slow. This class adds a fast lookup.
    // 2) HNODE     to HTREEITEM - slow. This class adds a fast lookup.
    // 3) HMTNODE   to HTREEITEM - slow. This class adds a fast lookup.
    // 4) HTREEITEM to HNODE     - already fast. This class does not need to do this.
    // 5) HTREEITEM to HMTNODE   - already fast. This class does not need to do this.
    // 6) HNODE     to HMTNODE   - already fast. This class does not need to do this.

    // Fast lookup methods
    SC ScGetHNodeFromHMTNode    (HMTNODE hMTNode,  /*out*/ HNODE*     phNode);    // fast conversion from hNode to hMTNode.
    SC ScGetHTreeItemFromHNode  (HNODE   hNode,    /*out*/ HTREEITEM* phti);    // fast conversion from HTREEITEM to HNODE
    SC ScGetHTreeItemFromHMTNode(HMTNODE hMTNode,  /*out*/ HTREEITEM* phti);      // fast conversion from HMTNode to HTREEITEM.

    // implementation
private:

    // This structure holds two pieces to the puzzle together:
    typedef struct TreeViewMapInfo
    {
        HTREEITEM hti;         // a tree item
        HMTNODE   hMTNode;     // the corresponding HMTNODE
        HNODE     hNode;       // the corresponding HNODE for the tree view control being observed.
    } *PTREEVIEWMAPINFO;

    typedef std::map<HNODE,     PTREEVIEWMAPINFO> HNodeLookupMap;
    typedef std::map<HMTNODE,   PTREEVIEWMAPINFO> HMTNodeLookupMap;

    HNodeLookupMap   m_hNodeMap;
    HMTNodeLookupMap m_hMTNodeMap;
};

/*+-------------------------------------------------------------------------*
 * class CAMCTreeView
 *
 *
 * PURPOSE: The scope pane tree control. Responsible for adding and removing
 *          items from the tree and also for sending events to
 *          tree observers.
 *
 *+-------------------------------------------------------------------------*/
class CAMCTreeView :
public CTreeView,
public CConsoleTree,
public CEventSource<CTreeViewObserver>,
public CMMCViewDropTarget
{
    DECLARE_DYNCREATE (CAMCTreeView)
    typedef CTreeView BC;

// Construction
public:
    CAMCTreeView();

// Operations
public:
    // Inserts a node into the tree control
    void ResetNode(HTREEITEM hItem);
    HTREEITEM InsertNode(HTREEITEM hParent, HNODE hNode,
                         HTREEITEM hInsertAfter = TVI_LAST);

    // Sets the folder button(+/-) on or off
    void SetButton(HTREEITEM hItem, BOOL bState);

    // Worker function to expand hItem's hNode
    BOOL ExpandNode(HTREEITEM hItem);

    void DeleteScopeTree(void);
    void CleanUp(void);
    SC   ScSelectNode(MTNODEID* pIDs, int length, bool bSelectExactNode = false); // Select the given node
    HTREEITEM ExpandNode(MTNODEID* pIDs, int length, bool bExpand, bool bExpandVisually=true);
    BOOL IsSelectedItemAStaticNode(void);
    HRESULT AddSubFolders(HTREEITEM hti, LPRESULTDATA pResultData);
    HRESULT AddSubFolders(MTNODEID* pIDs, int length);
    CWnd * GetCtrlFromParent(HTREEITEM hti, LPCTSTR pszResultPane);
    void GetCountOfChildren(HTREEITEM hItem, LONG* pcChildren);
    void SetCountOfChildren(HTREEITEM hItem, int cChildren);
    void DeleteNode(HTREEITEM hti, BOOL fDeleteThis);
    IResultData* GetResultData() { ASSERT(m_spResultData != NULL); return m_spResultData; }
    IFramePrivate*  GetNodeManager() { ASSERT(m_spNodeManager != NULL); return m_spNodeManager; }

    BOOL IsRootItemSel(void)
    {
        return (GetRootItem() == GetSelectedItem());
    }

    CTreeViewMap * GetTreeViewMap() {return &m_treeMap;} // returns the tree map for fast indexing.

    HNODE GetItemNode (HTREEITEM hItem) const
        { return (NodeFromLParam (GetItemData (hItem))); }

    static HNODE NodeFromLParam (LPARAM lParam)
        { return (reinterpret_cast<HNODE>(lParam)); }

    static LPARAM LParamFromNode (HNODE hNode)
        { return (reinterpret_cast<LPARAM>(hNode)); }

public:
    // CConsoleTree methods
    virtual SC ScSetTempSelection    (HTREEITEM htiSelected);
    virtual SC ScRemoveTempSelection ();
    virtual SC ScReselect            ();

private:
	bool		IsTempSelectionActive() const					{ return (m_htiTempSelect != NULL); }
	HTREEITEM	GetTempSelectedItem() const						{ return (m_htiTempSelect); }
	void		SetTempSelectedItem(HTREEITEM htiTempSelect)	{ m_htiTempSelect = htiTempSelect; }

    HTREEITEM   m_htiTempSelect;

public:
#ifdef DBG
    void DbgDisplayNodeName(HNODE hNode);
    void DbgDisplayNodeName(HTREEITEM hti);
#endif

    INodeCallback*  GetNodeCallback();

    // REVIEW:  why are we caching this information here when it's already in CAMCView?
    void    SetHasList(BOOL bHasList) {m_bHasListCurrently = bHasList;}
    BOOL    HasList()       const   {return m_bHasListCurrently;}

protected:
    SC ScGetTreeItemIconInfo(HNODE hNode, HICON *phIcon);

private:
    BOOL    m_bHasListCurrently;

public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCTreeView)
    public:
    virtual BOOL DestroyWindow();
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    //}}AFX_VIRTUAL

// Implementation
public:

    virtual SC   ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint pt, bool& bCopyOperation);
    virtual void RemoveDropTargetHiliting();

    virtual ~CAMCTreeView();
    CAMCView* GetAMCView()
    {
        if (m_pAMCView && ::IsWindow(*m_pAMCView))
            return m_pAMCView;
        return NULL;
    }

friend class CNodeInitObject;
friend class CAMCView;
protected:

    IFramePrivatePtr          m_spNodeManager;
    IScopeDataPrivatePtr      m_spScopeData;
    IHeaderCtrlPtr            m_spHeaderCtrl;
    IResultDataPrivatePtr     m_spResultData;
    IImageListPrivatePtr      m_spRsltImageList;

    BOOL                      m_fInCleanUp;
    BOOL                      m_fInExpanding;
    CAMCView*                 m_pAMCView;
    CTreeViewMap              m_treeMap; // fast indexing

    HRESULT CreateNodeManager(void);
    HTREEITEM GetClickedNode();

private:

    inline IScopeTreeIter* GetScopeIterator();
    inline IScopeTree* GetScopeTree();

    void OnDeSelectNode(HNODE hNode);
    void InitDefListView(LPUNKNOWN pUnkResultsPane);
    HRESULT OnSelectNode(HTREEITEM hItem, HNODE hNode);
    HTREEITEM FindNode(HTREEITEM hti, MTNODEID id);
    HTREEITEM FindSiblingItem(HTREEITEM hti, MTNODEID id);
    void _DeleteNode(SDeleteNodeInfo& dni);
	void CollapseChildren (HTREEITEM htiParent);

    void OnButtonUp();

    CTreeFontLinker m_FontLinker;

	/*
	 * this caches the text for the selected item, so we'll know whether
	 * to fire the ScOnSelectedItemTextChanged event to observers
	 */
	CString			m_strSelectedItemText;

    // Generated message map functions
protected:
    //{{AFX_MSG(CAMCTreeView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChanging(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG

    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangedWorker(NM_TREEVIEW* pnmtv, LRESULT* pResult);
    afx_msg void OnSelChangingWorker(NM_TREEVIEW* pnmtv, LRESULT* pResult);

    DECLARE_MESSAGE_MAP()

private:    // used for the keyboard timer
    class CKeyboardNavDelay : public CKeyboardNavDelayTimer
    {
		typedef CKeyboardNavDelayTimer BaseClass;

    public:
        CKeyboardNavDelay(CAMCTreeView* pTreeView);

        SC ScStartTimer(NMTREEVIEW* pnmtv);
        virtual void OnTimer();

    private:
        CAMCTreeView* const	m_pTreeView;
        NMTREEVIEW			m_nmtvSelChanged;
    };

    friend class CKeyboardNavDelay;
    std::auto_ptr<CKeyboardNavDelay> m_spKbdNavDelay;

    void SetNavigatingWithKeyboard (bool fKeyboardNav);

    bool IsNavigatingWithKeyboard () const
    {
        return (m_spKbdNavDelay.get() != NULL);
    }

public:
    SC ScRenameScopeNode(HMTNODE hMTNode); // put the specified scope node into rename mode.

public:
    CImageList* CreateDragImage(HTREEITEM hItem)
    {
        return GetTreeCtrl().CreateDragImage(hItem);
    }
    BOOL DeleteItem(HTREEITEM hItem)
    {
        return GetTreeCtrl().DeleteItem(hItem);
    }
    CEdit* EditLabel(HTREEITEM hItem)
    {
        return GetTreeCtrl().EditLabel(hItem);
    }
    BOOL EnsureVisible(HTREEITEM hItem)
    {
        return GetTreeCtrl().EnsureVisible(hItem);
    }
    BOOL Expand(HTREEITEM hItem, UINT nCode, bool bExpandVisually);
    BOOL Expand(HTREEITEM hItem, UINT nCode)
    {
        return GetTreeCtrl().Expand(hItem, nCode);
    }
    HTREEITEM GetChildItem(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetChildItem(hItem);
    }
    HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode) const
    {
        return GetTreeCtrl().GetNextItem(hItem, nCode);
    }
    HTREEITEM GetNextSiblingItem(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetNextSiblingItem(hItem);
    }
    HTREEITEM GetParentItem(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetParentItem(hItem);
    }
    BOOL GetItem(TV_ITEM* pItem) const
    {
        return GetTreeCtrl().GetItem(pItem);
    }
    DWORD_PTR GetItemData(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetItemData(hItem);
    }
    BOOL GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
    {
        return GetTreeCtrl().GetItemRect(hItem, lpRect, bTextOnly);
    }
    HTREEITEM GetSelectedItem()
    {
        return GetTreeCtrl().GetSelectedItem();
    }
    HTREEITEM InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
    {
        return GetTreeCtrl().InsertItem(lpInsertStruct);
    }
    BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
    {
        return GetTreeCtrl().SetItemState(hItem, nState, nStateMask);
    }
    BOOL SetItem(TV_ITEM* pItem)
    {
        return GetTreeCtrl().SetItem(pItem);
    }
    HTREEITEM HitTest(CPoint pt, UINT* pFlags = NULL) const
    {
        return GetTreeCtrl().HitTest(pt, pFlags);
    }
    HTREEITEM HitTest(TV_HITTESTINFO* pHitTestInfo) const
    {
        return GetTreeCtrl().HitTest(pHitTestInfo);
    }
    BOOL SelectItem(HTREEITEM hItem)
    {
        return GetTreeCtrl().SelectItem(hItem);
    }
    HTREEITEM GetRootItem()
    {
        return GetTreeCtrl().GetRootItem();
    }
};

#endif // __TREECTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\trobimpl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       trobimpl.h
//
//--------------------------------------------------------------------------

// trobimpl.h : header file
//
#ifndef _TROBIMPL_H_
#define _TROBIMPL_H_

#include "treeobsv.h"

/////////////////////////////////////////////////////////////////////////////
// CTreeObserverTreeImpl 

class CTreeObserverTreeImpl : public CTreeCtrl, public CTreeObserver
{
// Construction
public:
    CTreeObserverTreeImpl();
    virtual ~CTreeObserverTreeImpl();

// Attributes
public:

// Operations
public:
    STDMETHOD(SetStyle) (DWORD dwStyle);
    STDMETHOD(SetTreeSource) (CTreeSource* pTreeSrc);
    STDMETHOD_(TREEITEMID, GetSelection) ();
    STDMETHOD_(HTREEITEM, FindHTI)(TREEITEMID tid, BOOL bAutoExpand = FALSE);
	STDMETHOD_(void, SetSelection)   (TREEITEMID tid);
	STDMETHOD_(void, ExpandItem)     (TREEITEMID tid);
    STDMETHOD_(BOOL, IsItemExpanded) (TREEITEMID tid);

    // CTreeObserver methods
    STDMETHOD_(void, ItemAdded)   (TREEITEMID tid);
    STDMETHOD_(void, ItemRemoved) (TREEITEMID tidParent, TREEITEMID tidRemoved);
    STDMETHOD_(void, ItemChanged) (TREEITEMID tid, DWORD dwAttrib);

// Implementation
private:
    HTREEITEM FindChildHTI(HTREEITEM hitParent, TREEITEMID tid);    
    HTREEITEM AddOneItem(HTREEITEM hti, HTREEITEM htiAfter, TREEITEMID tid);
    void AddChildren(HTREEITEM hti);

    bool WasItemExpanded(HTREEITEM hti)
    {
        return (hti == TVI_ROOT) ||
               (hti != NULL && (GetItemState(hti, TVIS_EXPANDEDONCE) & TVIS_EXPANDEDONCE));
    }

    BOOL IsItemExpanded(HTREEITEM hti)
    {
        return (hti == TVI_ROOT) ||
               (hti != NULL && (GetItemState(hti, TVIS_EXPANDED) & TVIS_EXPANDED));
    }

    // Generated message map functions
protected:
    afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSingleExpand(NMHDR* pNMHDR, LRESULT* pResult);

    BOOL RootHidden()      { return m_dwStyle & TOBSRV_HIDEROOT; }
    BOOL ShowFoldersOnly() { return m_dwStyle & TOBSRV_FOLDERSONLY; }

    DECLARE_MESSAGE_MAP()

    CTreeSource*    m_pTreeSrc;
    DWORD           m_dwStyle;
    TREEITEMID      m_tidRoot;      // tid of hidden root
};

    
#endif // _TROBIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\vwtrack.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      vwtrack.cpp
 *
 *  Contents:  Implementation file for CViewTracker
 *
 *  History:   01-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "windowsx.h"
#include "vwtrack.h"
#include "subclass.h"       // for CSubclasser

IMPLEMENT_DYNAMIC (CViewTracker, CObject)

// Tracker subclasser base class
class CTrackingSubclasserBase : public CSubclasser
{
public:
    CTrackingSubclasserBase(CViewTracker*, HWND);
    virtual ~CTrackingSubclasserBase();

    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn) = 0;

protected:
    HWND          const m_hwnd;
    CViewTracker* const m_pTracker;
};


// Focus window subclasser
class CFocusSubclasser : public CTrackingSubclasserBase
{
public:
    CFocusSubclasser(CViewTracker*, HWND);
    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn);
};

// View window subclasser
class CViewSubclasser : public CTrackingSubclasserBase
{
public:
    CViewSubclasser(CViewTracker*, HWND);
    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn);
};

// Frame window subclasser
class CFrameSubclasser : public CTrackingSubclasserBase
{
public:
    CFrameSubclasser(CViewTracker*, HWND);
    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn);
};


/*+-------------------------------------------------------------------------*
 * IsFullWindowDragEnabled
 *
 * Returns true if the user has enabled the "Show window contents while
 * dragging" on the Effects page of the Display Properties property sheet.
 *--------------------------------------------------------------------------*/

static bool IsFullWindowDragEnabled ()
{
	BOOL fEnabled;
	if (!SystemParametersInfo (SPI_GETDRAGFULLWINDOWS, 0, &fEnabled, 0))
		return (false);

	return (fEnabled != FALSE);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::CViewTracker
 *
 * CViewTracker ctor.  This function is private so we can control how
 * CViewTrackers are allocated.  We want to insure that they're allocated
 * from the heap so it's safe to "delete this".
 *--------------------------------------------------------------------------*/

CViewTracker::CViewTracker (TRACKER_INFO& TrackerInfo)
	:	m_fFullWindowDrag			(IsFullWindowDragEnabled()),
		m_fRestoreClipChildrenStyle	(false),
		m_Info						(TrackerInfo),
        m_dc						(PrepTrackedWindow (TrackerInfo.pView)),
        m_pFocusSubclasser			(NULL),
        m_pViewSubclasser			(NULL),
        m_pFrameSubclasser			(NULL),
		m_lOriginalTrackerLeft		(TrackerInfo.rectTracker.left)
{
	DECLARE_SC (sc, _T("CViewTracker::CViewTracker"));
	sc = ScCheckPointers (m_Info.pView);
	if (sc)
		sc.Throw();

    ASSERT_VALID (m_Info.pView);

    // subclass the focus window to catch VK_ESCAPE
    HWND hwndFocus = ::GetFocus();

    if (hwndFocus != NULL)
	{
        m_pFocusSubclasser = new CFocusSubclasser (this, hwndFocus);
		if (m_pFocusSubclasser == NULL)
			AfxThrowMemoryException();
	}

    // subclass view window to get mouse events
    ASSERT(IsWindow(m_Info.pView->m_hWnd));
    m_pViewSubclasser = new CViewSubclasser (this, m_Info.pView->m_hWnd);
	if (m_pViewSubclasser == NULL)
		AfxThrowMemoryException();

    // subclass the frame window to catch WM_CANCELMODE
    HWND hwndFrame = m_Info.pView->GetTopLevelFrame()->GetSafeHwnd();

    if ((hwndFrame != NULL))
	{
        m_pFrameSubclasser = new CFrameSubclasser (this, hwndFrame);
		if (m_pFrameSubclasser == NULL)
			AfxThrowMemoryException();
	}

    // Draw initial tracker bar
    DrawTracker(m_Info.rectTracker);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::StartTracking
 *
 * CViewTracker factory.  It allocates CViewTrackers from the heap.
 *--------------------------------------------------------------------------*/

bool CViewTracker::StartTracking (TRACKER_INFO* pInfo)
{
    ASSERT(pInfo != NULL);

    CViewTracker* pTracker = NULL;

    try
    {
        /*
         * This doesn't leak. CViewTracker ctor fills in a back-pointer
         * that tracks the new object.  pTracker is also not dereferenced
		 * after allocation, so it doesn't need to be checked.
         */
        pTracker = new CViewTracker(*pInfo);
    }
    catch (CException* pe)
    {
        pe->Delete();
    }

    return (pTracker != NULL);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::StopTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CViewTracker::StopTracking (BOOL bAcceptChange)
{
    // unsubclass the windows we subclassed
    delete m_pFrameSubclasser;
    delete m_pFocusSubclasser;
    delete m_pViewSubclasser;

    // erase tracker rectangle
    DrawTracker (m_Info.rectTracker);

    // undo changes we made to the view
    UnprepTrackedWindow (m_Info.pView);

	/*
	 * if we're continuously resizing, but the user pressed Esc, restore
	 * the original size
	 */
	if (m_fFullWindowDrag && !bAcceptChange)
	{
		m_Info.rectTracker.left = m_lOriginalTrackerLeft;
		bAcceptChange = true;
	}

    // notify client through callback function
    ASSERT(m_Info.pCallback != NULL);
    (*m_Info.pCallback)(&m_Info, bAcceptChange, m_fFullWindowDrag);

    delete this;
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::Track
 *
 * Mouse movement handler for CViewTracker.
 *--------------------------------------------------------------------------*/

void CViewTracker::Track(CPoint pt)
{
    // if we lost the capture, terminate tracking
    if (CWnd::GetCapture() != m_Info.pView)
	{
		Trace (tagSplitterTracking, _T("Stopping tracking, lost capture)"));
        StopTracking (false);
	}

    // Apply movement limits
    //  if outside area and pane hiding allowed, snap to area edge
    //  else if outside bounds, snap to bounds edge
    if (pt.x < m_Info.rectArea.left && m_Info.bAllowLeftHide)
        pt.x = m_Info.rectArea.left;

    else if (pt.x < m_Info.rectBounds.left)
        pt.x = m_Info.rectBounds.left;

    else if (pt.x > m_Info.rectArea.right && m_Info.bAllowRightHide)
        pt.x = m_Info.rectArea.right;

    else if (pt.x > m_Info.rectBounds.right)
        pt.x = m_Info.rectBounds.right;

    // Erase and redraw tracker rect if moved
    if (pt.x != m_Info.rectTracker.left)
    {
        DrawTracker (m_Info.rectTracker);
        m_Info.rectTracker.OffsetRect (pt.x - m_Info.rectTracker.left, 0);
		Trace (tagSplitterTracking, _T("new tracker x=%d"), m_Info.rectTracker.left);

		/*
		 * if full window drag is enabled, tell the callback the size has
		 * changed
		 */
		if (m_fFullWindowDrag)
			(*m_Info.pCallback)(&m_Info, true, true);

        DrawTracker (m_Info.rectTracker);
    }
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::DrawTracker
 *
 *
 *--------------------------------------------------------------------------*/

void CViewTracker::DrawTracker (CRect& rect) const
{
	/*
	 * we don't draw a tracker bar if we're doing full window drag
	 */
	if (m_fFullWindowDrag)
		return;

    ASSERT (!rect.IsRectEmpty());
    ASSERT ((m_Info.pView->GetStyle() & WS_CLIPCHILDREN) == 0);

    // invert the brush pattern (looks just like frame window sizing)
    m_dc.PatBlt (rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::PrepTrackedWindow
 *
 * Prepares the tracked window prior to obtaining a DC for it.
 *--------------------------------------------------------------------------*/

CWnd* CViewTracker::PrepTrackedWindow (CWnd* pView)
{
    // make sure no updates are pending
    pView->UpdateWindow ();

    // steal capture (no need to steal focus)
    pView->SetCapture();

    // we need to draw in children, so remove clip-children while we track
	if (!m_fFullWindowDrag && (pView->GetStyle() & WS_CLIPCHILDREN))
	{
		pView->ModifyStyle (WS_CLIPCHILDREN, 0);
		m_fRestoreClipChildrenStyle = true;
	}

    return (pView);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::UnprepTrackedWindow
 *
 * "Unprepares" the tracked window prior to obtaining a DC for it.
 *--------------------------------------------------------------------------*/

void CViewTracker::UnprepTrackedWindow (CWnd* pView)
{
	if (m_fRestoreClipChildrenStyle)
		pView->ModifyStyle (0, WS_CLIPCHILDREN);

    ReleaseCapture();
}


/*+-------------------------------------------------------------------------*
 * CTrackingSubclasserBase::CTrackingSubclasserBase
 *
 *
 *--------------------------------------------------------------------------*/

CTrackingSubclasserBase::CTrackingSubclasserBase (CViewTracker* pTracker, HWND hwnd)
    :   m_hwnd     (hwnd),
        m_pTracker (pTracker)
{
    GetSubclassManager().SubclassWindow (m_hwnd, this);
}


/*+-------------------------------------------------------------------------*
 * CTrackingSubclasserBase::~CTrackingSubclasserBase
 *
 *
 *--------------------------------------------------------------------------*/

CTrackingSubclasserBase::~CTrackingSubclasserBase ()
{
    GetSubclassManager().UnsubclassWindow (m_hwnd, this);
}


/*+-------------------------------------------------------------------------*
 * CFocusSubclasser::CFocusSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CFocusSubclasser::CFocusSubclasser (CViewTracker* pTracker, HWND hwnd)
    :   CTrackingSubclasserBase (pTracker, hwnd)
{
}


/*+-------------------------------------------------------------------------*
 * CFrameSubclasser::CFrameSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CFrameSubclasser::CFrameSubclasser (CViewTracker* pTracker, HWND hwnd)
    :   CTrackingSubclasserBase (pTracker, hwnd)
{
}

/*+-------------------------------------------------------------------------*
 * CViewSubclasser::CViewSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CViewSubclasser::CViewSubclasser (CViewTracker* pTracker, HWND hwnd)
    :   CTrackingSubclasserBase (pTracker, hwnd)
{
}


/*+-------------------------------------------------------------------------*
 * CFocusSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CFocusSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    if (((msg == WM_CHAR) && (wParam == VK_ESCAPE)) ||
         (msg == WM_KILLFOCUS))
    {
#ifdef DBG
		if (msg == WM_CHAR)
			Trace (tagSplitterTracking, _T("Stopping tracking, user pressed Esc"));
		else
			Trace (tagSplitterTracking, _T("Stopping tracking, lost focus to hwnd=0x%08x"), ::GetFocus());
#endif

        m_pTracker->StopTracking (false);
        fPassMessageOn = false;
    }

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CFrameSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CFrameSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    if (msg == WM_CANCELMODE)
	{
		Trace (tagSplitterTracking, _T("Stopping tracking, got WM_CANCELMODE"));
        m_pTracker->StopTracking (false);
	}

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CViewSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CViewSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    switch (msg)
    {
        case WM_MOUSEMOVE:
        {
            CPoint pt(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            m_pTracker->Track (pt);
        }
        break;

		case WM_LBUTTONUP:
			Trace (tagSplitterTracking, _T("Stopping tracking, accepting new position"));
            m_pTracker->StopTracking (true);
            break;
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\vwtrack.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      vwtrack.h
 *
 *  Contents:  Interface file for CViewTracker
 *
 *  History:   01-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef VWTRACK_H
#define VWTRACK_H
#pragma once

#include "amcview.h"

class CFocusSubclasser;
class CFrameSubclasser;
class CViewSubclasser;
struct TRACKER_INFO;

typedef void (CALLBACK *TRACKER_CALLBACK)(TRACKER_INFO* pTrackerInfo, bool bAccept, bool bSyncLayout);

/*
 * This structure is copied in the CViewTracker using its (default) copy
 * constructor.  If you add any members for which member-wise copy is not
 * appropriate, you *must* define a copy constructor for this structure.
 */
typedef struct TRACKER_INFO
{
    CView*    pView;            // View to manage
    CRect     rectArea;         // Total area available
    CRect     rectTracker;      // Current tracker position
    CRect     rectBounds;       // Tracker movement bounds
    BOOL      bAllowLeftHide;   // Can left pane be hidden
    BOOL      bAllowRightHide;  // Can right pane be hidden
    LONG_PTR  lUserData;        // User data
    TRACKER_CALLBACK pCallback; // Tracking completion callback
} TRACKER_INFO;


class CHalftoneClientDC : public CClientDC
{
public:
    CHalftoneClientDC (CWnd* pwnd)
        :   CClientDC (pwnd), m_hBrush(NULL)
        { 
            CBrush *pBrush = SelectObject (GetHalftoneBrush ()); 
            if (pBrush != NULL)
                m_hBrush = *pBrush;
        }

    ~CHalftoneClientDC ()
        { 
            if (m_hBrush != NULL)
                SelectObject ( CBrush::FromHandle(m_hBrush) ); 
        }

private:
    HBRUSH  m_hBrush;
};

class CViewTracker : public CObject
{
    DECLARE_DYNAMIC (CViewTracker)

    // private ctor, use StartTracking to create one
    CViewTracker (TRACKER_INFO& TrackerInfo);

    // private dtor
    ~CViewTracker() {};

public:
    static bool StartTracking (TRACKER_INFO* pTrackerInfo);
    void StopTracking (BOOL fAcceptNewPosition);
    void Track(CPoint pt);

private:
    void DrawTracker (CRect& rect) const;
    CWnd* PrepTrackedWindow (CWnd* pwnd);
    void UnprepTrackedWindow (CWnd* pwnd);

private:
	/*
	 * m_fFullWindowDrag must be first, so it will be initialized first;
	 * other member initializers will use m_fFullWindowDrag's setting
	 */
	const bool					m_fFullWindowDrag;

	bool						m_fRestoreClipChildrenStyle;
    TRACKER_INFO                m_Info;
    CHalftoneClientDC mutable   m_dc;
    CFocusSubclasser *          m_pFocusSubclasser;
    CViewSubclasser  *          m_pViewSubclasser;
    CFrameSubclasser *          m_pFrameSubclasser;
	const LONG					m_lOriginalTrackerLeft;

};  /* class CViewTracker */


#endif /* VWTRACK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\trobimpl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       trobimpl.cpp
//
//--------------------------------------------------------------------------


// trobimpl.cpp : implementation file
//

#include "stdafx.h"
#include "amc.h"
#include "trobimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CTreeObserverTreeImpl

CTreeObserverTreeImpl::CTreeObserverTreeImpl() : 
    m_pTreeSrc(NULL), m_dwStyle(0), m_tidRoot(NULL)
{
}

CTreeObserverTreeImpl::~CTreeObserverTreeImpl()
{
}

HRESULT CTreeObserverTreeImpl::SetStyle(DWORD dwStyle)
{
    ASSERT((dwStyle & ~(TOBSRV_HIDEROOT | TOBSRV_FOLDERSONLY)) == 0);

    m_dwStyle = dwStyle;

    return S_OK;
}


HRESULT CTreeObserverTreeImpl::SetTreeSource(CTreeSource* pTreeSrc)
{
    // Window may be gone before source is disconnected 
    if (IsWindow(m_hWnd))
        DeleteAllItems();

    m_pTreeSrc = pTreeSrc;

    if (pTreeSrc == NULL)
        return S_OK;

    // Must have window before populating tree
    ASSERT(IsWindow(m_hWnd));

    // populate top level of tree
    TREEITEMID tidRoot = m_pTreeSrc->GetRootItem();
    if (tidRoot != NULL)
    {
        // Trigger handler as though item were just added
        ItemAdded(tidRoot);
    }

    return S_OK;
}


TREEITEMID CTreeObserverTreeImpl::GetSelection()
{
    HTREEITEM hti = GetSelectedItem();
    
    if (hti)
        return static_cast<TREEITEMID>(GetItemData(hti));
    else
        return NULL;
}

void CTreeObserverTreeImpl::SetSelection(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);

    HTREEITEM hti = FindHTI(tid, TRUE);
    ASSERT(hti != NULL);

    SelectItem(hti);
    EnsureVisible(hti);
}

void CTreeObserverTreeImpl::ExpandItem(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    HTREEITEM hti = FindHTI(tid, TRUE);

    if (hti != NULL)
        Expand(hti, TVE_EXPAND);
}

BOOL CTreeObserverTreeImpl::IsItemExpanded(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    HTREEITEM hti = FindHTI(tid, TRUE);

    return (IsItemExpanded(hti));
}

HTREEITEM CTreeObserverTreeImpl::FindChildHTI(HTREEITEM htiParent, TREEITEMID tid)
{
    HTREEITEM htiTemp;

    if (htiParent == TVI_ROOT)
        htiTemp = GetRootItem();
    else
        htiTemp = GetChildItem(htiParent);

    while (htiTemp && GetItemData(htiTemp) != tid)
    {
        htiTemp = GetNextSiblingItem(htiTemp);
    }

    return htiTemp;
}


HTREEITEM CTreeObserverTreeImpl::FindHTI(TREEITEMID tid, BOOL bAutoExpand)
{
    ASSERT(m_pTreeSrc != NULL);

    if (tid == NULL || (tid == m_tidRoot && RootHidden()))
        return TVI_ROOT;

    HTREEITEM htiParent = FindHTI(m_pTreeSrc->GetParentItem(tid), bAutoExpand);
    
    if (htiParent == NULL)
        return NULL;

    if (bAutoExpand && !WasItemExpanded(htiParent))
        Expand(htiParent, TVE_EXPAND);

    return FindChildHTI(htiParent, tid);
}


HTREEITEM CTreeObserverTreeImpl::AddOneItem(HTREEITEM htiParent, HTREEITEM htiAfter, TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);

    TVINSERTSTRUCT insert;

    insert.hParent = htiParent;
    insert.hInsertAfter = htiAfter;

    insert.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    insert.item.lParam = tid;
    insert.item.iImage = m_pTreeSrc->GetItemImage(tid);
    insert.item.iSelectedImage = insert.item.iImage;
    insert.item.cChildren = m_pTreeSrc->GetChildItem(tid) ? 1 : 0;

    TCHAR name[MAX_PATH];
    m_pTreeSrc->GetItemName(tid, name, countof(name));
    insert.item.pszText = name;

    return InsertItem(&insert);
}


void CTreeObserverTreeImpl::AddChildren(HTREEITEM hti)
{
    ASSERT(m_pTreeSrc != NULL);

    TREEITEMID tidChild;

    // if adding top level item
    if (hti == TVI_ROOT)
    {
        if (RootHidden())
        {
            // if root is hidden, add its children
            ASSERT(m_tidRoot != 0);
            tidChild = m_pTreeSrc->GetChildItem(m_tidRoot);
        }
        else
        {
            // else add root item itself
            tidChild = m_pTreeSrc->GetRootItem();
        }
    }
    else
    {
       // convert to TID, then get its child 
       TREEITEMID tid = static_cast<TREEITEMID>(GetItemData(hti));
       ASSERT(tid != 0);
            
       tidChild = m_pTreeSrc->GetChildItem(tid);
    }

    while (tidChild)
    {
        // Add visible items
        if (!ShowFoldersOnly() || m_pTreeSrc->IsFolderItem(tidChild))
            AddOneItem(hti, TVI_LAST, tidChild);

        tidChild = m_pTreeSrc->GetNextSiblingItem(tidChild);
    }
}


void CTreeObserverTreeImpl::ItemAdded(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    ASSERT(tid != 0);

    // if only folders visible, skip this item
    if (ShowFoldersOnly() && !m_pTreeSrc->IsFolderItem(tid))
        return;

    // Get parent tree item
    TREEITEMID tidParent = m_pTreeSrc->GetParentItem(tid);

    // if this is the tree root and the root is not displayed
    if (tidParent == NULL && RootHidden())
    {
        // Can only have one hidden root
        ASSERT(m_tidRoot == NULL);

        // Just save TID as the hidden root and return
        m_tidRoot = tid;

        // since root is hidden, add its children to the tree
        AddChildren(TVI_ROOT);

        return;
    }

    // Add new item to tree
    HTREEITEM htiParent = FindHTI(tidParent);

    // Parent exists and has been expanded
    if (WasItemExpanded(htiParent)) 
    {
        // Determine previous tree item
        //   Because the source doesn't support GetPrevSibling
        //   we have to get the next TID then use our own tree to
        //   back up to the previous item
        //
        HTREEITEM htiPrev;
        TREEITEMID tidNext = m_pTreeSrc->GetNextSiblingItem(tid);
        if (tidNext)
        {
            HTREEITEM htiNext = FindChildHTI(htiParent, tidNext);
            ASSERT(htiNext);

            htiPrev = GetPrevSiblingItem(htiNext);
            if (htiPrev == NULL)
                htiPrev = TVI_FIRST;
        }
        else
        {
            htiPrev = TVI_LAST;
        }

        // Insert the new tree item
        AddOneItem(htiParent, htiPrev, tid);
    }
    else if (htiParent)
    {
        // Set child count so parent can expand
        TV_ITEM item;
        item.mask = TVIF_CHILDREN;
        item.hItem = htiParent;
        item.cChildren = 1;

        SetItem(&item);
    }

}


void CTreeObserverTreeImpl::ItemRemoved(TREEITEMID tidParent, TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    ASSERT(tid != 0);

    // if deleting hidden root, clear tree and return
    if (tid == m_tidRoot)
    {
        DeleteAllItems();
        m_tidRoot = NULL;

        return;
    }

    // Get parent tree item
    HTREEITEM htiParent = FindHTI(tidParent);

    if (WasItemExpanded(htiParent))
    {
        // Find removed item
        HTREEITEM hti = FindChildHTI(htiParent, tid);

        // Remove the item
        DeleteItem(hti);
    }
}


void CTreeObserverTreeImpl::ItemChanged(TREEITEMID tid, DWORD dwAttrib)
{
    ASSERT(m_pTreeSrc != NULL);
    ASSERT(tid != 0);

    if (dwAttrib & TIA_NAME)
    {
        // Get changed tree item
        HTREEITEM hti = FindHTI(tid);

        // Force item update
        if (hti != 0)
        {
            TCHAR name[MAX_PATH];
            m_pTreeSrc->GetItemName(tid, name, countof(name));

            TVITEM item;
            item.hItem = hti;
            item.mask = TVIF_TEXT;
            item.pszText = name;
            
            SetItem(&item);
        }
    }
}


void CTreeObserverTreeImpl::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNotify = (NM_TREEVIEW*)pNMHDR;
    ASSERT(pNotify != NULL);

    HTREEITEM hti = pNotify->itemNew.hItem;
    ASSERT(hti != NULL);

    // Enumerate the folders below this item
    if (pNotify->action == TVE_EXPAND)
    {
        // Only add children on first expansion
        if (!(pNotify->itemNew.state & TVIS_EXPANDEDONCE))
            AddChildren(hti);
    }

    // Flip state of icon open/closed
    ASSERT(m_pTreeSrc != NULL);

    TREEITEMID tid = pNotify->itemNew.lParam;
    ASSERT(m_pTreeSrc->IsFolderItem(tid));

    int iImage = (pNotify->action == TVE_EXPAND) ? 
                    m_pTreeSrc->GetItemOpenImage(tid) : m_pTreeSrc->GetItemImage(tid);
    TVITEM item;
    item.hItem = hti;
    item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    item.iImage = item.iSelectedImage = iImage;    
    SetItem(&item);
    

    *pResult = 0;
}

     
void CTreeObserverTreeImpl::OnSingleExpand(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = TVNRET_DEFAULT;
}


BEGIN_MESSAGE_MAP(CTreeObserverTreeImpl, CTreeCtrl)
    ON_NOTIFY_REFLECT(TVN_SINGLEEXPAND, OnSingleExpand)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFavoritesView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\webctrl.cpp ===
// WebCtrl.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amcwebviewctrl.cpp
//
//  Contents:  AMC Private web view control hosting IE 3.x and 4.x
//
//  History:   16-Jul-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "amc.h"
#include "amcview.h"
#include "histlist.h"
#include "exdisp.h" // for the IE dispatch interfaces.
#include "websnk.h"
#include "evtsink.h"
#include "WebCtrl.h"
#include "atliface.h"
#include "mainfrm.h"
#include "statbar.h"

#ifdef DBG
CTraceTag tagVivekDefaultWebContextMenu (_T("Vivek"), _T("Use default web context menu"));
#endif

/*+-------------------------------------------------------------------------*
 * class CDocHostUIHandlerDispatch
 *
 *
 * PURPOSE: Implements the interface required by ATL to find out about
 *          UI hosting.
 *
 *+-------------------------------------------------------------------------*/
class CDocHostUIHandlerDispatch :
    public IDocHostUIHandlerDispatch,
    public CComObjectRoot
{
private:
    ViewPtr  m_spView; // a pointer to the parent AMCView's dispatch interface

public:
    BEGIN_COM_MAP(CDocHostUIHandlerDispatch)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDocHostUIHandlerDispatch)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CDocHostUIHandlerDispatch)

    // initialization
    SC  ScInitialize(PVIEW pView)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::ScInitialize"));

        sc = ScCheckPointers(pView);
        if(sc)
            return sc;

        // should not initialize twice
        if(m_spView)
            return (sc=E_UNEXPECTED);

        m_spView = pView;

        return sc;
    }

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)                          {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo) {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
        LCID lcid, DISPID* rgdispid)                                    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)                          {return E_NOTIMPL;}



    // IDocHostUIHandlerDispatch

    STDMETHODIMP ShowContextMenu (DWORD dwID, DWORD x, DWORD y, IUnknown* pcmdtReserved,
                                  IDispatch* pdispReserved, HRESULT* dwRetVal);
    STDMETHODIMP GetHostInfo( DWORD* pdwFlags, DWORD* pdwDoubleClick);

    // a helper function for all the methods that return S_FALSE;
    SC ScFalse(HRESULT* dwRetVal)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::ScFalse"));
        sc = ScCheckPointers(dwRetVal);
        if(sc)
            return sc.ToHr();

        *dwRetVal = S_FALSE;

        return sc.ToHr();
    }

    STDMETHODIMP ShowUI(DWORD dwID, IUnknown* pActiveObject, IUnknown* pCommandTarget,
                         IUnknown* pFrame, IUnknown* pDoc, HRESULT* dwRetVal)
                                                               {return ScFalse(dwRetVal).ToHr();}
    STDMETHODIMP HideUI()                                      {return S_OK;}
    STDMETHODIMP UpdateUI()                                    {return S_OK;}
    STDMETHODIMP EnableModeless(VARIANT_BOOL fEnable)          {return E_NOTIMPL;}
    STDMETHODIMP OnDocWindowActivate(VARIANT_BOOL fActivate)   {return S_OK;}
    STDMETHODIMP OnFrameWindowActivate(VARIANT_BOOL fActivate) {return S_OK;}
    STDMETHODIMP ResizeBorder(long left, long top, long right,
                               long bottom, IUnknown* pUIWindow,
                               VARIANT_BOOL fFrameWindow)       {return E_NOTIMPL;}
    STDMETHODIMP TranslateAccelerator( DWORD hWnd, DWORD nMessage,
                                        DWORD wParam, DWORD lParam,
                                        BSTR bstrGuidCmdGroup,
                                        DWORD nCmdID,
                                        HRESULT* dwRetVal)      {return ScFalse(dwRetVal).ToHr();}

    STDMETHODIMP GetOptionKeyPath( BSTR* pbstrKey, DWORD dw)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::GetOptionKeyPath"));
        sc = ScCheckPointers(pbstrKey);
        if(sc)
            return sc.ToHr();

        *pbstrKey = NULL;

        return S_FALSE;
    }
    STDMETHODIMP GetDropTarget( IUnknown* pDropTarget,  IUnknown** ppDropTarget)    {return E_NOTIMPL;}
    STDMETHODIMP GetExternal( IDispatch **ppDispatch) // returns a pointer to the view.
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::GetExternal"));

        // set up the connection to the external object.
        sc = ScCheckPointers(m_spView, E_UNEXPECTED);
        if(sc)
            return sc.ToHr();

        *ppDispatch = m_spView;
        (*ppDispatch)->AddRef(); // addref for the client.

        return sc.ToHr();
    }

    STDMETHODIMP TranslateUrl( DWORD dwTranslate, BSTR bstrURLIn, BSTR* pbstrURLOut)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::TranslateUrl"));

        sc = ScCheckPointers(pbstrURLOut);
        if(sc)
            return sc.ToHr();

        *pbstrURLOut = NULL;
        return S_FALSE;
    }

    STDMETHODIMP FilterDataObject(IUnknown*pDO, IUnknown**ppDORet)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::FilterDataObject"));

        sc = ScCheckPointers(ppDORet);
        if(sc)
            return sc.ToHr();

        *ppDORet = NULL;
        return S_FALSE;
    }
};


/*+-------------------------------------------------------------------------*
 * ShouldShowDefaultWebContextMenu
 *
 * Returns true if we should display the default MSHTML context menu,
 * false if we want to display our own (or suppress it altogether)
 *--------------------------------------------------------------------------*/

bool IsDefaultWebContextMenuDesired ()
{
#ifdef DBG
	return (tagVivekDefaultWebContextMenu.FAny());
#else
	return (false);
#endif
}


/*+-------------------------------------------------------------------------*
 *
 * CDocHostUIHandlerDispatch::ShowContextMenu
 *
 * PURPOSE: Handles IE's hook to display context menus. Does not do anything
 *          and returns to IE with the code to not display menus.
 *
 * PARAMETERS:
 *    DWORD      dwID :
 *    DWORD      x :
 *    DWORD      y :
 *    IUnknown*  pcmdtReserved :
 *    IDispatch* pdispReserved :
 *    HRESULT*   dwRetVal :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CDocHostUIHandlerDispatch::ShowContextMenu (DWORD dwID, DWORD x, DWORD y, IUnknown* pcmdtReserved,
                              IDispatch* pdispReserved, HRESULT* dwRetVal)
{
    DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::ShowContextMenu"));

    // validate input
    sc = ScCheckPointers(dwRetVal);
    if(sc)
        return sc.ToHr();

    *dwRetVal = S_OK; // default: don't display.

    // Create context menu for console taskpads.
    // must be in author mode for a menu to show up.
    if (AMCGetApp()->GetMode() != eMode_Author)
        return sc.ToHr(); // prevent browser from displaying its menus.

    // Is it a console taskpad
    CMainFrame* pFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    CConsoleView* pConsoleView;
    sc = pFrame->ScGetActiveConsoleView (pConsoleView);
    if (sc)
        return sc.ToHr();

    /*
     * ScGetActiveConsoleView will return success (S_FALSE) even if there's no
     * active view.  This is a valid case, occuring when there's no console
     * file open.  In this particular circumstance, it is an unexpected
     * failure since we shouldn't get to this point in the code if there's
     * no view.
     */
    sc = ScCheckPointers (pConsoleView, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());


	/*
	 * it we want to let the web browser show it own context menu, return
	 * S_FALSE so it will do so; otherwise, display the context menu we want
	 */
	sc = (IsDefaultWebContextMenuDesired())
				? SC(S_FALSE)
				: pConsoleView->ScShowWebContextMenu ();

    // the real return value is in the out parameter.
    *dwRetVal = sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CDocHostUIHandlerDispatch::GetHostInfo
 *
 * PURPOSE: Indicates to IE not to display context menus.
 *
 * PARAMETERS:
 *    DWORD* pdwFlags :
 *    DWORD* pdwDoubleClick :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CDocHostUIHandlerDispatch::GetHostInfo( DWORD* pdwFlags, DWORD* pdwDoubleClick)
{
    DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::GetHostInfo"));

    sc = ScCheckPointers(pdwFlags, pdwDoubleClick);
    if(sc)
        return sc.ToHr();

    // Disable context menus
    *pdwFlags =  DOCHOSTUIFLAG_DISABLE_HELP_MENU;
    *pdwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return sc.ToHr();
}


/////////////////////////////////////////////////////////////////////////////
// CAMCWebViewCtrl

IMPLEMENT_DYNCREATE(CAMCWebViewCtrl, COCXHostView)

CAMCWebViewCtrl::CAMCWebViewCtrl() : m_dwAdviseCookie(0)
{
}

LPUNKNOWN CAMCWebViewCtrl::GetIUnknown(void)
{

    return m_spWebBrowser2;
}


CAMCWebViewCtrl::~CAMCWebViewCtrl()
{
}


BEGIN_MESSAGE_MAP(CAMCWebViewCtrl, CAMCWebViewCtrl::BaseClass)
    //{{AFX_MSG_MAP(CAMCWebViewCtrl)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCWebViewCtrl message handlers

void CAMCWebViewCtrl::OnDraw(CDC* pDC)
{
}


void
CAMCWebViewCtrl::OnDestroy()
{
    if(m_spWebBrowser2)
    {
        if (m_dwAdviseCookie != 0)
        {
            AtlUnadvise(m_spWebBrowser2, DIID_DWebBrowserEvents, m_dwAdviseCookie /*the connection ID*/);
            m_dwAdviseCookie = 0;
        }

        m_spWebBrowser2.Release();
    }

    BaseClass::OnDestroy();
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCWebViewCtrl::ScCreateWebBrowser
 *
 * PURPOSE: Creates the IWebBrowser2 object, and sets up the external UI
 *          handler and event sink.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCWebViewCtrl::ScCreateWebBrowser()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::ScCreateWebBrowser"));

    sc = ScCheckPointers(GetAMCView(), GetAxWindow());
    if(sc)
        return sc;

    // create the OCX host window
    RECT rcClient;
    GetClientRect(&rcClient);
    GetAxWindow()->Create(m_hWnd, rcClient, _T(""), (WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS) );

   // create the web control
    CCoTaskMemPtr<OLECHAR> spstrWebBrowser;
    sc = StringFromCLSID(CLSID_WebBrowser, &spstrWebBrowser);
    if (sc)
        return sc;
 
    sc = GetAxWindow()->CreateControl(spstrWebBrowser);
    if(sc)
        return sc;

    // get a pointer to the web browser control.
    sc = GetAxWindow()->QueryControl(IID_IWebBrowser2, (void **) &m_spWebBrowser2);
    if(sc)
        return sc;

    sc = ScCheckPointers((IWebBrowser2 *)m_spWebBrowser2);
    if(sc)
        return sc;

    // attach the control to the history list, if history is enabled
    if (IsHistoryEnabled())
    {
        sc = ScCheckPointers(GetAMCView()->GetHistoryList());
        if(sc)
            return sc;

        GetAMCView()->GetHistoryList()->Attach (this);
    }

    // get a pointer to the view object
    ViewPtr spView;
    sc = GetAMCView()->ScGetMMCView(&spView);
    if(sc)
        return sc;


    // Set up the External UI Handler.
    typedef CComObject<CDocHostUIHandlerDispatch> CDocHandler;
    CDocHandler *pDocHandler = NULL;
    sc = CDocHandler::CreateInstance(&pDocHandler);
    if(sc)
        return sc;

    if(!pDocHandler)
        return (sc = E_UNEXPECTED);


    CComPtr<IDocHostUIHandlerDispatch> spIDocHostUIHandlerDispatch = pDocHandler;
    if(!spIDocHostUIHandlerDispatch)
        return (sc = E_UNEXPECTED);

    // initialize the dochandler
    sc = pDocHandler->ScInitialize(spView);
    if(sc)
        return sc;

    sc = GetAxWindow()->SetExternalUIHandler(spIDocHostUIHandlerDispatch); // no need to addref.
    if(sc)
        return sc;

    // set up the Web Event Sink, if requested
    if (IsSinkEventsEnabled())
    {
        typedef CComObject<CWebEventSink> CEventSink;
        CEventSink *pEventSink;
        sc = CEventSink::CreateInstance(&pEventSink);
        if(sc)
            return sc;

        sc = pEventSink->ScInitialize(this);
        if(sc)
            return sc;

        m_spWebSink = pEventSink; // addref's it.

        // create the connection
        sc = AtlAdvise(m_spWebBrowser2, (LPDISPATCH)(IWebSink *)m_spWebSink,
                       DIID_DWebBrowserEvents, &m_dwAdviseCookie/*the connection ID*/);
        if(sc)
            return sc;

        if (m_dwAdviseCookie == 0)
            return (sc = E_UNEXPECTED);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCWebViewCtrl::OnCreate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPCREATESTRUCT  lpCreateStruct :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CAMCWebViewCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::OnCreate"));

    if (BaseClass::OnCreate(lpCreateStruct) == -1)
        return -1;

    sc = ScCreateWebBrowser();
    if(sc)
        return 0;

    /*
     * The client edge is supplied by the OCX host view now.  We do this so
     * we can give a nice edge to OCX's that don't support IDispatch (like
     * CMessageView).  ModifyStyleEx for OCX's is implemented as a change
     * to the Border Style stock property, which is done via IDispatch.
     * If the OCX doesn't support IDispatch, we can't change its border.
     * If the client edge is supplied by the OCX host view, we don't need
     * to change the OCX's border
     */
    ModifyStyleEx (WS_EX_CLIENTEDGE, 0);

    return 0;
}


// REVIEW add other members from old file
void CAMCWebViewCtrl::Navigate(LPCTSTR lpszWebSite, LPCTSTR lpszFrameTarget)
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::ScNavigate"));

    USES_CONVERSION;

    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = NULL;

    if (IsHistoryEnabled())
    {
        pHistoryList = GetAMCView()->GetHistoryList();

        if(!pHistoryList)
        {
            sc = E_POINTER;
            return;
        }
    }

    CComBSTR    bstrURL     (T2COLE(lpszWebSite));
    CComVariant vtFlags     ( (long) 0);
    CComVariant vtTarget    (T2COLE(lpszFrameTarget));
    CComVariant vtPostData;
    CComVariant vtHeaders;

    // What does this DoVerb do?
    /*
    if (FAILED((hr=DoVerb(OLEIVERB_PRIMARY))))
    {
        TRACE(_T("DoVerb failed: %X\n"), hr);
        return hr;
    } */

    sc = m_spWebBrowser2->Navigate(bstrURL, &vtFlags, &vtTarget, &vtPostData, &vtHeaders);
    if(sc)
        return;

    // check errors here.
    if (pHistoryList != NULL)
        pHistoryList->UpdateWebBar (HB_STOP, TRUE);  // turn on "stop" button
}


void CAMCWebViewCtrl::Back()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Back"));

    /*
     * if history isn't enabled, we can't go back
     */
    if (!IsHistoryEnabled())
    {
        sc = E_FAIL;
        return;
    }

    // check parameters.
    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = GetAMCView()->GetHistoryList();
    if(!pHistoryList)
    {
        sc = E_POINTER;
        return;
    }

    Stop();

    // give a chance to History to handle the Back notification.
    // If not handled, use the web browser
    bool bHandled = false;
    pHistoryList->Back (bHandled);
    if(!bHandled)
    {
        sc = m_spWebBrowser2->GoBack();
        if(sc)
            return;
    }
}

void CAMCWebViewCtrl::Forward()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Forward"));

    /*
     * if history isn't enabled, we can't go forward
     */
    if (!IsHistoryEnabled())
    {
        sc = E_FAIL;
        return;
    }

    // check parameters.
    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = GetAMCView()->GetHistoryList();
    if(!pHistoryList)
    {
        sc = E_POINTER;
        return;
    }

    Stop();

    // give a chance to History to handle the Forward notification.
    // If not handled, use the web browser
    bool bHandled = false;
    pHistoryList->Forward (bHandled);
    if(!bHandled)
    {
        sc = m_spWebBrowser2->GoForward();
        if(sc)
            return;
    }
}

void CAMCWebViewCtrl::Stop()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Stop"));

    // check parameters.
    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = NULL;
    if (IsHistoryEnabled())
    {
        pHistoryList = GetAMCView()->GetHistoryList();
        if(!pHistoryList)
        {
            sc = E_POINTER;
            return;
        }
    }

    sc = m_spWebBrowser2->Stop();
    if(sc)
        return;

    if (pHistoryList != NULL)
        pHistoryList->UpdateWebBar (HB_STOP, FALSE);  // turn off "stop" button
}

void CAMCWebViewCtrl::Refresh()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Refresh"));

    sc = ScCheckPointers(m_spWebBrowser2);
    if(sc)
        return;

    sc = m_spWebBrowser2->Refresh();
    if(sc)
        return;
}

SC CAMCWebViewCtrl::ScGetReadyState(READYSTATE& readyState)
{
    DECLARE_SC (sc, _T("CAMCWebViewCtrl::ScGetReadyState"));
    readyState = READYSTATE_UNINITIALIZED;

    sc = ScCheckPointers(m_spWebBrowser2);
    if(sc)
        return sc;

    sc = m_spWebBrowser2->get_ReadyState(&readyState);
    if(sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\webctrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       webctrl.h
//
//--------------------------------------------------------------------------

// WebCtrl.h : header file
//

#ifndef __WEBCTRL_H__
#define __WEBCTRL_H__

#include "ocxview.h"

/////////////////////////////////////////////////////////////////////////////
// CAMCWebViewCtrl window

class CAMCWebViewCtrl : public COCXHostView
{
public:
    typedef COCXHostView BaseClass;

    enum
    {
        WS_HISTORY    = 0x00000001,     // integrate with history
        WS_SINKEVENTS = 0x00000002,     // act as sink for DIID_DWebBrowserEvents
    };

// Construction
public:
    CAMCWebViewCtrl();
    DECLARE_DYNCREATE(CAMCWebViewCtrl)

    // attributes
private:

    CMMCAxWindow        m_wndAx;                // This ActiveX control will host the web browser.
    IWebBrowser2Ptr     m_spWebBrowser2;        // the interface implemented by the web browser.
    DWORD               m_dwAdviseCookie;       // the connection ID established by the web browser with the event sink.
    CComPtr<IWebSink>   m_spWebSink;

protected:
    virtual CMMCAxWindow * GetAxWindow()           {return &m_wndAx;}

private:
    SC  ScCreateWebBrowser();

    bool IsHistoryEnabled() const;
    bool IsSinkEventsEnabled() const;

// Operations
public:
   void Navigate(LPCTSTR lpszWebSite, LPCTSTR lpszFrameTarget);
   void Back();
   void Forward();
   void Refresh();
   void Stop();
   LPUNKNOWN GetIUnknown(void);
   SC ScGetReadyState(READYSTATE& state);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCWebViewCtrl)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    //}}AFX_VIRTUAL


// Implementation
public:
    virtual ~CAMCWebViewCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CAMCWebViewCtrl)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#include "webctrl.inl"

#endif //__WEBCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\webctrl.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      webctrl.inl
 *
 *  Contents:  Inline functions for CAMCWebViewCtrl
 *
 *  History:   15-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*+-------------------------------------------------------------------------*
 * CAMCWebViewCtrl::IsHistoryEnabled 
 *
 * Returns true if the window has the WS_HISTORY style, false otherwise.
 *--------------------------------------------------------------------------*/

inline bool CAMCWebViewCtrl::IsHistoryEnabled () const
{
    return ((GetStyle() & WS_HISTORY) != 0);
}


/*+-------------------------------------------------------------------------*
 * CAMCWebViewCtrl::IsSinkEventsEnabled 
 *
 * Returns true if the window has the WS_SINKEVENTS style, false otherwise.
 *--------------------------------------------------------------------------*/

inline bool CAMCWebViewCtrl::IsSinkEventsEnabled () const
{
    return ((GetStyle() & WS_SINKEVENTS) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\wrapper.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      wrapper.cpp
 *
 *  Contents:  Implementation file for simple wrapper classes
 *
 *  History:   02-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "wrapper.h"


/*+-------------------------------------------------------------------------*
 * CAccel::CAccel
 *
 *
 *--------------------------------------------------------------------------*/

CAccel::CAccel (HACCEL hAccel /* =NULL */)
    :
    m_hAccel (hAccel)
{
}

CAccel::CAccel (LPACCEL paccl, int cEntries)
    :
    m_hAccel (::CreateAcceleratorTable (paccl, cEntries))
{
}


/*+-------------------------------------------------------------------------*
 * CAccel::~CAccel
 *
 *
 *--------------------------------------------------------------------------*/

CAccel::~CAccel ()
{
    DestroyAcceleratorTable ();
}


/*+-------------------------------------------------------------------------*
 * CAccel::CreateAcceleratorTable
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::CreateAcceleratorTable (LPACCEL paccl, int cEntries)
{
    DestroyAcceleratorTable ();
    ASSERT (m_hAccel == NULL);
    if(paccl != NULL)
        m_hAccel = ::CreateAcceleratorTable (paccl, cEntries);

    return (m_hAccel != NULL);
}


/*+-------------------------------------------------------------------------*
 * CAccel::CopyAcceleratorTable
 *
 *
 *--------------------------------------------------------------------------*/

int CAccel::CopyAcceleratorTable (LPACCEL paccl, int cEntries) const
{
    return (::CopyAcceleratorTable (m_hAccel, paccl, cEntries));
}


/*+-------------------------------------------------------------------------*
 * CAccel::DestroyAcceleratorTable
 *
 *
 *--------------------------------------------------------------------------*/

void CAccel::DestroyAcceleratorTable ()
{
    if (m_hAccel != NULL)
    {
        ::DestroyAcceleratorTable (m_hAccel);
        m_hAccel = NULL;
    }
}


/*+-------------------------------------------------------------------------*
 * CAccel::LoadAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::LoadAccelerators (int nAccelID)
{
    return (LoadAccelerators (MAKEINTRESOURCE (nAccelID)));
}


/*+-------------------------------------------------------------------------*
 * CAccel::LoadAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::LoadAccelerators (LPCTSTR pszAccelName)
{
    HINSTANCE hInst = AfxFindResourceHandle (pszAccelName, RT_ACCELERATOR);
    return (LoadAccelerators (hInst, pszAccelName));
}


/*+-------------------------------------------------------------------------*
 * CAccel::LoadAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::LoadAccelerators (HINSTANCE hInst, LPCTSTR pszAccelName)
{
    DestroyAcceleratorTable ();
    ASSERT (m_hAccel == NULL);
    m_hAccel = ::LoadAccelerators (hInst, pszAccelName);

    return (m_hAccel != NULL);
}


/*+-------------------------------------------------------------------------*
 * CAccel::TranslateAccelerator
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::TranslateAccelerator (HWND hwnd, LPMSG pmsg) const
{
    return ((m_hAccel != NULL) &&
            ::TranslateAccelerator (hwnd, m_hAccel, pmsg));
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::CDeferWindowPos
 *
 *
 *--------------------------------------------------------------------------*/

CDeferWindowPos::CDeferWindowPos (
    int     cWindows,
    bool    fSynchronousPositioningForDebugging)
    :   m_hdwp (NULL),
        m_fSynchronousPositioningForDebugging (fSynchronousPositioningForDebugging)
{
	Begin (cWindows);
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::~CDeferWindowPos
 *
 *
 *--------------------------------------------------------------------------*/

CDeferWindowPos::~CDeferWindowPos ()
{
    if (m_hdwp)
        End();
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::Begin
 *
 *
 *--------------------------------------------------------------------------*/

bool CDeferWindowPos::Begin (int cWindows)
{
    ASSERT (m_hdwp == NULL);
    ASSERT (cWindows > 0);

    m_hdwp = ::BeginDeferWindowPos (cWindows);
    return (m_hdwp != NULL);
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::End
 *
 *
 *--------------------------------------------------------------------------*/

bool CDeferWindowPos::End ()
{
    ASSERT (m_hdwp != NULL);
    HDWP hdwp = m_hdwp;
    m_hdwp = NULL;

	if ( hdwp == NULL )
		return false;

    return (::EndDeferWindowPos (hdwp) != 0);
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::AddWindow
 *
 *
 *--------------------------------------------------------------------------*/

bool CDeferWindowPos::AddWindow (
    const CWnd*     pwnd,
    const CRect&    rect,
    DWORD           dwFlags,
    const CWnd*     pwndInsertAfter /* =NULL */)
{
    ASSERT (IsWindow (pwnd->GetSafeHwnd()));

    if (pwndInsertAfter == NULL)
        dwFlags |= SWP_NOZORDER;

	if ( m_hdwp == NULL )
		return false;

    m_hdwp = ::DeferWindowPos (m_hdwp,
                               pwnd->GetSafeHwnd(),
                               pwndInsertAfter->GetSafeHwnd(),
                               rect.left, rect.top,
                               rect.Width(), rect.Height(),
                               dwFlags);

#ifdef DBG
    if (m_fSynchronousPositioningForDebugging)
    {
        End ();
        Begin (1);
    }
#endif

    return (m_hdwp != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\assert.cpp ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>
#include <vector>       // to keep mmcdebug.h happy
#include "mmcdebug.h"

//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>

#ifdef DBG

#define new DEBUG_NEW

#include "..\inc\admindbg.h"
#include "malloc.h" // alloca

//
//  Globals
//

ULONG AdminInfoLevel = DEF_INFOLEVEL;
ULONG AdminInfoMask = 0xffffffff;
ULONG AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fCritSecInit = FALSE;
static CRITICAL_SECTION s_csMessageBuf;
const size_t g_cchMessageBuf = 500;         // size of the message buffer in chars
static TCHAR g_szMessageBuf[500];        // this is the message buffer

//
//  Forward declration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  InitializeDebugging(void);
void  CleanUpDebugging(void);
void  smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
int   w4dprintf(LPTSTR format, ...);
int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4smprintf(LPTSTR  format, va_list arglist)
{
    EnterCriticalSection(&s_csMessageBuf);
    HRESULT hr = StringCchVPrintf(g_szMessageBuf, g_cchMessageBuf, format, arglist);
    if(FAILED(hr))
        return -1;
    OutputDebugString(g_szMessageBuf);
    LeaveCriticalSection(&s_csMessageBuf);
    return lstrlen(g_szMessageBuf);
}


//+------------------------------------------------------------
// Function:    SetAdminInfoLevel(ULONG ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
//
// Returns:     Old info level
//
//-------------------------------------------------------------

ULONG SetAdminInfoLevel(ULONG ulNewLevel)
{
    ULONG ul;

    ul = AdminInfoLevel;
    AdminInfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetAdminInfoMask(ULONG ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
//
// Returns:     Old info mask
//
//-------------------------------------------------------------

ULONG SetAdminInfoMask(ULONG ulNewMask)
{
    ULONG ul;

    ul = AdminInfoMask;
    AdminInfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetAdminAssertLevel(ULONG ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
//
// Returns:     Old assert level
//
//-------------------------------------------------------------

ULONG SetAdminAssertLevel(ULONG ulNewLevel)
{
    ULONG ul;

    ul = AdminAssertLevel;
    AdminAssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

void smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | AdminInfoLevel) & AdminInfoMask))
    {
        EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((AdminInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
            }
            w4smprintf(ppszfmt, pargs);
        }

        //if (AdminInfoLevel & DEB_STDOUT)
        //{
        //    if (! (ulCompMask & DEB_NOCOMPNAME))
        //    {
        //        printf("%x.%03x> %s: ", pid, tid, pszComp);
        //    }
        //    vprintf(ppszfmt, pargs);
        //}

        LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
#define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    if (!fCritSecInit) InitializeDebugging();

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADMINDEBUGKEY, 0,
                                       KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                  KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, 
                &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;

            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                        (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}

void InitializeDebugging(void)
{
    if (fCritSecInit) return;
    InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    fCritSecInit = TRUE;
}

void CleanUpDebugging(void)
{
    if (fCritSecInit)
    {
        DeleteCriticalSection(&s_csMessageBuf);
        DeleteCriticalSection(&s_csDebugPrint);
    }
}



// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':')
                            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return (LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];
    static int cchAssertCaption = 128;
    //
    // get process
    //

    static CHAR szModuleName[128];
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    StringCchPrintf(szAssertCaption, cchAssertCaption, _T("%hs: Assertion Failed"), pProcess);


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    int cchDetails = 1024;
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    StringCchPrintf(szDetails, cchDetails, 
                        _T(" Assertion:\t %s\n\n")
                        _T(" File:   \t\t %hs\n")
                        _T(" Line:   \t\t %d\n\n")
                        _T(" Module:   \t %hs\n")
                        _T(" Thread ID:\t %d.%d\n\n")
                        _T(" Press Cancel to debug the application\n")
                        _T(" Press OK to ignore the assertion"),
                        szMsg, szFile, iLine, pszModuleName, pid, tid);


    int id = MessageBox(NULL,
                    szDetails,
                    szAssertCaption,
                    MB_SETFOREGROUND
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
            szMessage, pszFileName, iLine, tid);
    }

    if (AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            MMCDebugBreak();
        }
    }
    else if (AdminAssertLevel & ASSRT_BREAK)
    {
        MMCDebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________

// Initialize the number of CDbg instances.
long CDbg::s_cCDbgObjCount = 0;

CDbg::CDbg(LPTSTR  str)
    :
    m_InfoLevelString(str),
    m_InfoLevel(DEF_INFOLEVEL)
{
    CheckInit(m_InfoLevelString, &m_InfoLevel);
    
    // Increment # of CDbg instances.
    InterlockedIncrement(&s_cCDbgObjCount);         
}

CDbg::~CDbg()
{
    // If this is last CDbg instance destroy the 
    // static objects.
    if (InterlockedDecrement(&s_cCDbgObjCount) == 0)
        CleanUpDebugging();
}

void CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
    if(NULL == pszfmt)
    {
        MMCDebugBreak();
        return;
    }
#ifdef UNICODE
    int cbFormatBuffer = (strlen(pszfmt) + 1) * sizeof(WCHAR);
    LPWSTR pszFormatBuffer = (LPWSTR)alloca(cbFormatBuffer);
    if(NULL == pszFormatBuffer)
    {
        MMCDebugBreak();
        return;
    }
    pszFormatBuffer[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, pszFormatBuffer, cbFormatBuffer);
#else
    LPSTR pszFormatBuffer = pszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, pszFormatBuffer, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPWSTR pwszfmt, ...)
{
    if(NULL == pwszfmt)
    {
        MMCDebugBreak();
        return;
    }
#ifndef UNICODE
    int cbFormatBuffer = (wcslen(pwszfmt) + 1) * sizeof(CHAR);
    LPTSTR pszFormatBuffer = (LPSTR)alloca(cbFormatBuffer);
    if(NULL == pszFormatBuffer)
    {
        MMCDebugBreak();
        return;
    }
    pszFormatBuffer[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, pszFormatBuffer, cbFormatBuffer, NULL, NULL);
#else
    LPTSTR pszFormatBuffer = pwszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, pszFormatBuffer, va);
        va_end(va);
    }
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                                                      err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
    AdminAssertEx(pszFile, iLine, pszMsg);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\base64.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      base64.cpp
 *
 *  Contents:  Implements encoding / decoding table for base64 format
 *
 *  History:   17-Dec-99 audriusz   Created
 *
 *--------------------------------------------------------------------------*/

#include <windows.h>
#include <comdef.h>
#include <memory.h>
#include "base64.h"

/*+-------------------------------------------------------------------------*
 *
 * TABLE base64_table::_six2pr64
 *
 * PURPOSE: for conversion from binary to base64
 *
 *+-------------------------------------------------------------------------*/
BYTE base64_table::_six2pr64[64] = 
{
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

/*+-------------------------------------------------------------------------*
 *
 * TABLE base64_table::_six2pr64
 *
 * PURPOSE: for conversion from base64 to binary 
 * [filled by base64_table::base64_table()]
 *
 *+-------------------------------------------------------------------------*/
BYTE  base64_table::_pr2six[256]; 

/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::base64_table
 *
 * PURPOSE: c-tor. fills the table
 *
 *+-------------------------------------------------------------------------*/
base64_table::base64_table()
{
    memset(_pr2six,-1,sizeof(_pr2six));
    // Build up the reverse index from base64 characters to values
    for (int i = 0; i < sizeof(_six2pr64)/sizeof(_six2pr64[0]); i++)
        _pr2six[_six2pr64[i]] = (BYTE)i;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::decode
 *
 * PURPOSE: decodes 0-3 bytes of data ( as much as available )
 *
 *+-------------------------------------------------------------------------*/
bool base64_table::decode(LPCOLESTR &src, BYTE * &dest)
{
    BYTE Inputs[4] = { 0, 0, 0, 0 };
    int  nChars = 0;
    // force table initialization on first call
    static base64_table table_init;

    // collect 4 characters if possible.
    while (*src && *src != '=' && nChars < 4)
    {
        BYTE bt = table_init.map2six(static_cast<BYTE>(*src++));
        if (bt != 0xff)
            Inputs[nChars++] = bt;
    }

    dest += table_init.decode4(Inputs, nChars, dest);

    return (nChars == 4);
}


/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::encode
 *
 * PURPOSE: encodes 1-3 bytes of data. pads if the last set
 *
 *+-------------------------------------------------------------------------*/
void base64_table::encode(const BYTE * &src, DWORD &cbInput, LPOLESTR &dest)
{
    BYTE chr0 = src[0];
    BYTE chr1 = cbInput > 1 ? src[1] : 0;
    BYTE chr2 = cbInput > 2 ? src[2] : 0;
    *(dest++) = _six2pr64[chr0 >> 2];                                     // c1 
    *(dest++) = _six2pr64[((chr0 << 4) & 060) | ((chr1 >> 4) & 017)];     // c2
    *(dest++) = _six2pr64[((chr1 << 2) & 074) | ((chr2 >> 6) & 03) ];     // c3
    *(dest++) = _six2pr64[chr2 & 077];                                    // c4 
    src += 3;

    if (cbInput == 1)
    {
        *(dest-1) = '=';
        *(dest-2) = '=';
        cbInput = 0;
    }
    else if (cbInput == 2)
    {
        *(dest-1) = '=';
        cbInput = 0;
    }
    else
        cbInput -= 3;

    if (!cbInput)
        *dest = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\bitmap.cpp ===
// bitmap.cpp : implementation file
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      bitmap.cpp
//
//  Contents:  Helper functions to copy bitmaps
//
//  History:   27-Feb-97 WayneSc    Created
//
//
//--------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>


//+-------------------------------------------------------------------
//
//  Member:      CopyBitmap
//
//  Synopsis:    Make a copy of given bitmap & return handle to the copy.
//
//  Returns:     HBITMAP - NULL if error
//
// Note:         Cannot use SC as we need to include too may headers.
//               which will make this dependent on mmcbase.lib, but
//               mmcbase.lib is dependent on this (UICore.lib).
//
//--------------------------------------------------------------------
HBITMAP CopyBitmap(HBITMAP hbm)
{
    if (!hbm)
        return NULL;

    HDC hdc        = NULL;
    HDC hMemDCsrc  = NULL;
    HDC hMemDCdst  = NULL;

    HBITMAP hNewBm = NULL;
    BITMAP  bm;
    ZeroMemory(&bm, sizeof(bm));

    hdc = GetDC (NULL);
    if (!hdc)
        goto Error;

    hMemDCsrc = CreateCompatibleDC (hdc);
    if (!hMemDCsrc)
        goto Error;

    hMemDCdst = CreateCompatibleDC (hdc);
    if (!hMemDCdst)
        goto Error;

    if (! GetObject (hbm, sizeof(BITMAP), (LPSTR)&bm))
        goto Error;

    /*hNewBm = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++ (dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL);*/
    hNewBm = CreateBitmap(bm.bmWidth, bm.bmHeight, bm.bmPlanes, bm.bmBitsPixel, NULL);
    if (hNewBm){
        HBITMAP hbmSrcOld = (HBITMAP) SelectObject (hMemDCsrc, hbm);
        HBITMAP hbmDstOld = (HBITMAP) SelectObject (hMemDCdst, hNewBm);

        BitBlt (hMemDCdst,
                0,
                0,
                bm.bmWidth,
                bm.bmHeight,
                hMemDCsrc,
                0,
                0,
                SRCCOPY);

        SelectObject (hMemDCsrc, hbmSrcOld);
        SelectObject (hMemDCdst, hbmDstOld);
    }

Cleanup:
    if (hdc)
        ReleaseDC (NULL,hdc);

    if (hMemDCsrc)
        DeleteDC (hMemDCsrc);

    if (hMemDCdst)
        DeleteDC (hMemDCdst);

    return hNewBm;

Error:
#ifdef DBG
   /*
    * Cannot use SC as we need to include too may headers.
    * which will make this dependent on mmcbase.lib, but
    * mmcbase.lib is dependent on this (UICore.lib).
    * So call outputstring in case of error.
    */
    LPVOID lpMsgBuf;
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf, 0, NULL );

    OutputDebugString((LPTSTR)lpMsgBuf);
    LocalFree( lpMsgBuf );
#endif

    hNewBm = NULL;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\columninfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      columninfo.cpp
//
//  Contents:   Classes related to column persistence.
//
//
//  Note:       The classes in this file (CColumnInfo, CColumnInfoList)
//              were in nodemgr/colwidth.h. They are moved here so that
//              if columns change conui can ask nodemgr to persist data
//              or conui can set headers by asking nodemgr for data.
//
//  History:    04-Apr-00 AnandhaG     Created
//
//--------------------------------------------------------------------------
#include "stgio.h"
#include "serial.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include <string>
#include "cstr.h"
#include "xmlbase.h"
#include "countof.h"
#include "columninfo.h"

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Read the CColumnInfo object from the stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - The version of the object being read.
//
//                          The format is :
//                              INT    column index
//                              INT    column width
//                              INT    column format
//
//--------------------------------------------------------------------
HRESULT CColumnInfo::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            stm >> m_nCol;
            stm >> m_nWidth;
            stm >> m_nFormat;

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CColumnInfo::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnInfo::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_COLUMN_INFO_COLUMN, m_nCol) ;
    persistor.PersistAttribute(XML_ATTR_COLUMN_INFO_WIDTH,  m_nWidth) ;

    static const EnumLiteral mappedFormats[] =
    {
        { LVCFMT_LEFT,      XML_ENUM_COL_INFO_LVCFMT_LEFT },
        { LVCFMT_RIGHT,     XML_ENUM_COL_INFO_LVCFMT_RIGHT },
        { LVCFMT_CENTER,    XML_ENUM_COL_INFO_LVCFMT_CENTER },
    };

    CXMLEnumeration formatPersistor(m_nFormat, mappedFormats, countof(mappedFormats) );

    persistor.PersistAttribute(XML_ATTR_COLUMN_INFO_FORMAT, formatPersistor) ;
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Reads CColumnInfoList data from stream for the given version.
//
//  Format:     number of columns : each CColumnInfo entry.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - Version of CColumnInfoList to be read.
//
//
//--------------------------------------------------------------------
HRESULT CColumnInfoList::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            // Number of columns.
            DWORD dwCols;
            stm >> dwCols;

            clear();

            for (int i = 0; i < dwCols; i++)
            {
                CColumnInfo colEntry;

                // Read the colEntry data.
                if (colEntry.Read(stm) != S_OK)
                    continue;

                push_back(colEntry);
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\wrapper.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      wrapper.h
 *
 *  Contents:  Interface file for simple wrapper classes
 *
 *  History:   02-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef WRAPPER_H
#define WRAPPER_H


/*----------------*/
/* HACCEL wrapper */
/*----------------*/
class CAccel : public CObject
{
public:
    HACCEL  m_hAccel;

    CAccel (HACCEL hAccel = NULL);
    CAccel (LPACCEL paccl, int cEntries);
    ~CAccel ();

    bool CreateAcceleratorTable (LPACCEL paccl, int cEntries);
    int  CopyAcceleratorTable (LPACCEL paccl, int cEntries) const;
    bool TranslateAccelerator (HWND hwnd, LPMSG pmsg) const;
    void DestroyAcceleratorTable ();

    bool LoadAccelerators (int nAccelID);
    bool LoadAccelerators (LPCTSTR pszAccelName);
    bool LoadAccelerators (HINSTANCE hInst, LPCTSTR pszAccelName);

    bool operator== (int i) const
        { ASSERT (i == NULL); return (m_hAccel == NULL); }

    bool operator!= (int i) const
        { ASSERT (i == NULL); return (m_hAccel != NULL); }

    operator HACCEL() const
        { return (m_hAccel); }
};



/*---------------------------------*/
/* Begin/EndDeferWindowPos wrapper */
/*---------------------------------*/
class CDeferWindowPos
{
public:
    HDWP    m_hdwp;

    CDeferWindowPos (int cWindows = 0, bool fSynchronousPositioningForDebugging = false);
    ~CDeferWindowPos ();

    bool Begin (int cWindows);
    bool End ();
    bool AddWindow (const CWnd* pwnd, const CRect& rect, DWORD dwFlags, const CWnd* pwndInsertAfter = NULL);

    bool operator== (int i) const
        { ASSERT (i == NULL); return (m_hdwp == NULL); }

    bool operator!= (int i) const
        { ASSERT (i == NULL); return (m_hdwp != NULL); }

    operator HDWP() const
        { return (m_hdwp); }


private:
    const bool m_fSynchronousPositioningForDebugging;

};


/*-------------------*/
/* Rectangle helpers */
/*-------------------*/
class CWindowRect : public CRect
{
public:
    CWindowRect (const CWnd* pwnd)
    {
        if (pwnd != NULL)
            pwnd->GetWindowRect (this);
        else
            SetRectEmpty();
    }

    /*
     * just forward other ctors
     */
    CWindowRect(int l, int t, int r, int b)         : CRect(l, t, r, b) {} 
    CWindowRect(const RECT& srcRect)                : CRect(srcRect) {} 
    CWindowRect(LPCRECT lpSrcRect)                  : CRect(lpSrcRect) {} 
    CWindowRect(POINT point, SIZE size)             : CRect(point, size) {} 
    CWindowRect(POINT topLeft, POINT bottomRight)   : CRect(topLeft, bottomRight) {} 
};

class CClientRect : public CRect
{
public:
    CClientRect (const CWnd* pwnd)
    {
        if (pwnd != NULL)
            pwnd->GetClientRect (this);
        else
            SetRectEmpty();
    }

    /*
     * just forward other ctors
     */
    CClientRect(int l, int t, int r, int b)         : CRect(l, t, r, b) {} 
    CClientRect(const RECT& srcRect)                : CRect(srcRect) {} 
    CClientRect(LPCRECT lpSrcRect)                  : CRect(lpSrcRect) {} 
    CClientRect(POINT point, SIZE size)             : CRect(point, size) {} 
    CClientRect(POINT topLeft, POINT bottomRight)   : CRect(topLeft, bottomRight) {} 
};


/*+-------------------------------------------------------------------------*
 * AMCGetSysColorBrush 
 *
 * Returns a (temporary) MFC-friendly system color brush.
 *--------------------------------------------------------------------------*/

inline CBrush* AMCGetSysColorBrush (int nIndex)
{
    return (CBrush::FromHandle (::GetSysColorBrush (nIndex)));
}


#endif /* WRAPPER.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\cstr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include <stdio.h>
#include <objbase.h>

#include <basetyps.h>
#include "dbg.h"
#include "..\inc\cstr.h"


/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
TCHAR strChNil = '\0';      // extractstring

// for creating empty key strings
const CStr strEmptyString;

// begin_extractstring
void CStr::Init()
{
    m_nDataLength = m_nAllocLength = 0;
    m_pchData = (LPTSTR)&strChNil;
}

// declared static
void CStr::SafeDelete(LPTSTR lpch)
{
    if (lpch != (LPTSTR)&strChNil)
        delete[] lpch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

// begin_extractstring
CStr::CStr()
{
    Init();
}

CStr::CStr(const CStr& stringSrc)
{
    // if constructing a String from another String, we make a copy of the
    // original string data to enforce value semantics (i.e. each string
    // gets a copy of its own

    stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CStr::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0);

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception

		if (m_pchData != NULL)
		{
			m_pchData[nLen] = '\0';
			m_nDataLength = nLen;
			m_nAllocLength = nLen;
		}
		else
			Init();
    }
}

void CStr::Empty()
{
    SafeDelete(m_pchData);
    Init();
    ASSERT(m_nDataLength == 0);
    ASSERT(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
    SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlen(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;

    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
    if (lpsz != NULL && (DWORD_PTR)lpsz <= 0xffff)
    {
        Init();
        UINT nID = LOWORD((DWORD_PTR)lpsz);
        // REVIEW hInstance for LoadString(hInst, nID);
    }
    else
    {
        int nLen;
        if ((nLen = SafeStrlen(lpsz)) == 0)
            Init();
        else
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
        }
    }
}

// end_extractstring
/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef UNICODE
CStr::CStr(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen == 0)
        Init();
    else
    {
        AllocBuffer(nSrcLen);
        mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    }
}
#else //UNICODE
CStr::CStr(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen == 0)
        Init();
    else
    {
        AllocBuffer(nSrcLen*2);
        mmc_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif //!UNICODE

// begin_extractstring

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
    AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
    return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}
// end_extractstring

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef UNICODE
const CStr& CStr::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
    return *this;
}
#else //!UNICODE
const CStr& CStr::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    nSrcLen *= 2;
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
    {
        mmc_wcstombsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
    return *this;
}
#endif  //!UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = TCHAR, LPCTSTR
//          String + ?
//          ? + String

void CStr::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
    int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

    int nNewLen = nSrc1Len + nSrc2Len;
    AllocBuffer(nNewLen);
    memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
    memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
}

CStr STRAPI operator+(const CStr& string1, const CStr& string2)
{
    CStr s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
        string2.m_nDataLength, string2.m_pchData);
    return s;
}

CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    CStr s;
    s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlen(lpsz), lpsz);
    return s;
}

CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    CStr s;
    s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStr::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (m_nDataLength + nSrcLen > m_nAllocLength)
    {
        // we have to grow the buffer, use the Concat in place routine
        LPTSTR lpszOldData = m_pchData;
        ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
        ASSERT(lpszOldData != NULL);
        SafeDelete(lpszOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(TCHAR));
        m_nDataLength += nSrcLen;
    }
    ASSERT(m_nDataLength <= m_nAllocLength);
    m_pchData[m_nDataLength] = '\0';
}

const CStr& CStr::operator+=(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStr& CStr::operator+=(TCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CStr& CStr::operator+=(const CStr& string)
{
    ConcatInPlace(string.m_nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CStr::GetBuffer(int nMinBufLength)
{
    ASSERT(nMinBufLength >= 0);

    if (nMinBufLength > m_nAllocLength)
    {
        // we have to grow the buffer
        LPTSTR lpszOldData = m_pchData;
        int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, lpszOldData, nOldLen*sizeof(TCHAR));
        m_nDataLength = nOldLen;
        m_pchData[m_nDataLength] = '\0';

        SafeDelete(lpszOldData);
    }

    // return a pointer to the character storage for this string
    ASSERT(m_pchData != NULL);
    return m_pchData;
}

void CStr::ReleaseBuffer(int nNewLength)
{
    if (nNewLength == -1)
        nNewLength = lstrlen(m_pchData); // zero terminated

    ASSERT(nNewLength <= m_nAllocLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
}

LPTSTR CStr::GetBufferSetLength(int nNewLength)
{
    ASSERT(nNewLength >= 0);

    GetBuffer(nNewLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
    return m_pchData;
}

void CStr::FreeExtra()
{
    ASSERT(m_nDataLength <= m_nAllocLength);
    if (m_nDataLength != m_nAllocLength)
    {
        LPTSTR lpszOldData = m_pchData;
        AllocBuffer(m_nDataLength);
        memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(TCHAR));
        ASSERT(m_pchData[m_nDataLength] == '\0');
        SafeDelete(lpszOldData);
    }
    ASSERT(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStr::Find(TCHAR ch) const
{
    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData, ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStr::FindOneOf(LPCTSTR lpszCharSet) const
{
    ASSERT(IsValidString(lpszCharSet, FALSE));
    LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
// String conversion helpers (these use the current system locale)

int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
        return 0;

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
        mbstr, count, NULL, NULL);
    ASSERT(mbstr == NULL || result <= (int)count);
    if (result > 0)
        mbstr[result-1] = 0;
    return result;
}

int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);
    ASSERT(wcstr == NULL || result <= (int)count);
    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStr::LoadString(HINSTANCE hInst, UINT nID)
{
    ASSERT(nID != 0);       // 0 is an illegal string ID

    // Note: resource strings limited to 511 characters
    TCHAR szBuffer[512];
    UINT nSize = StrLoadString(hInst, nID, szBuffer);
    AssignCopy(nSize, szBuffer);
    return nSize > 0;
}


int STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf)
{
    ASSERT(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
    // LoadString without annoying warning from the Debug kernel if the
    //  segment containing the string is not present
    if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
    {
        lpszBuf[0] = '\0';
        return 0; // not found
    }
#endif //DBG
    int nLen = ::LoadString(hInst, nID, lpszBuf, 511);
    if (nLen == 0)
        lpszBuf[0] = '\0';
    return nLen;
}

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;

    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStr::AllocSysString()
{
    BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
    if (bstr == NULL)
        ;//REVIEW AfxThrowMemoryException();

    return bstr;
}

BSTR CStr::SetSysString(BSTR* pbstr)
{
    ASSERT(IsValidAddressz(pbstr, sizeof(BSTR)));

    if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
        ; //REVIEW AfxThrowMemoryException();

    ASSERT(*pbstr != NULL);
    return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp


CStr::CStr(TCHAR ch, int nLength)
{
#ifndef UNICODE
    ASSERT(!IsDBCSLeadByte(ch));    // can't create a lead byte string
#endif
    if (nLength < 1)
    {
        // return empty string if invalid repeat count
        Init();
    }
    else
    {
        AllocBuffer(nLength);
#ifdef UNICODE
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
#else
        memset(m_pchData, ch, nLength);
#endif
    }
}

CStr::CStr(LPCTSTR lpch, int nLength)
{
    if (nLength == 0)
        Init();
    else
    {
        ASSERT(IsValidAddressz(lpch, nLength, FALSE));
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStr& CStr::operator=(TCHAR ch)
{
#ifndef UNICODE
    ASSERT(!IsDBCSLeadByte(ch));    // can't set single lead byte
#endif
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStr STRAPI operator+(const CStr& string1, TCHAR ch)
{
    CStr s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CStr STRAPI operator+(TCHAR ch, const CStr& string)
{
    CStr s;
    s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStr CStr::Mid(int nFirst) const
{
    return Mid(nFirst, m_nDataLength - nFirst);
}

CStr CStr::Mid(int nFirst, int nCount) const
{
    ASSERT(nFirst >= 0);
    ASSERT(nCount >= 0);

    // out-of-bounds requests return sensible things
    if (nFirst + nCount > m_nDataLength)
        nCount = m_nDataLength - nFirst;
    if (nFirst > m_nDataLength)
        nCount = 0;

    CStr dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CStr CStr::Right(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CStr dest;
    AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
    return dest;
}

CStr CStr::Left(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CStr dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CStr CStr::SpanIncluding(LPCTSTR lpszCharSet) const
{
    ASSERT(IsValidString(lpszCharSet, FALSE));
    return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStr CStr::SpanExcluding(LPCTSTR lpszCharSet) const
{
    ASSERT(IsValidString(lpszCharSet, FALSE));
    return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStr::ReverseFind(TCHAR ch) const
{
    // find last single character
    LPTSTR lpsz = _tcsrchr(m_pchData, ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStr::Find(LPCTSTR lpszSub) const
{
    ASSERT(IsValidString(lpszSub, FALSE));

    // find first matching substring
    LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStr::Format(LPCTSTR lpszFormat, ...)
{
    ASSERT(IsValidString(lpszFormat, FALSE));

    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}


void CStr::FormatV(LPCTSTR lpszFormat, va_list argList)
{

    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
        {
            nMaxLen += _tclen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _ttoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                ;
        }
        ASSERT(nWidth >= 0);

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = _tcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = _tcsinc(lpsz);
            }
            else
            {
                nPrecision = _ttoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                    ;
            }
            ASSERT(nPrecision >= 0);
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = _tcsinc(lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = _tcsinc(lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = _tcsinc(lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, char);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR);
            break;

        // strings
        case 's':
        case 'S':
            nItemLen = lstrlen(va_arg(argList, LPCTSTR));
            nItemLen = __max(1, nItemLen);
            break;
        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
            nItemLen = lstrlenA(va_arg(argList, LPCSTR));
            nItemLen = __max(1, nItemLen);
            break;
#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
            nItemLen = wcslen(va_arg(argList, LPWSTR));
            nItemLen = __max(1, nItemLen);
            break;
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = __max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = __min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = __max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, _STR_DOUBLE);
                nItemLen = 128;
                nItemLen = __max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = __max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                ASSERT(FALSE);  // unknown formatting option
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }
    va_end(argList);

    // finally, set the buffer length and format the string
    GetBuffer(nMaxLen);

#include "pushwarn.h"
#pragma warning(disable: 4552)      // "<=" operator has no effect
    VERIFY(_vstprintf(m_pchData, lpszFormat, argListSave) <= nMaxLen);
#include "popwarn.h"

    ReleaseBuffer();
    va_end(argListSave);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void __cdecl CStr::FormatMessage(LPCTSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
//      AfxThrowMemoryException();
        return;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}
#endif //!_MAC

void CStr::TrimRight()
{
    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPTSTR lpsz = m_pchData;
    LPTSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = _tcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        m_nDataLength = int(lpszLast - m_pchData);
    }
}

void CStr::TrimLeft()
{
    // find first non-space character
    LPCTSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
        lpsz = _tcsinc(lpsz);

    // fix up data and length
    int nDataLength = m_nDataLength - int(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    m_nDataLength = nDataLength;
}

#if 0

//
// JonCaves 1/28/02
//
// These function are never used and in any case as there are no proceeding
// template function definition it is illegal: so I am removing them 
//

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

template<>
void STRAPI ConstructElements(CStr* pElements, int nCount)
{
    ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

    for (; nCount--; ++pElements)
        memcpy(pElements, &strEmptyString, sizeof(*pElements));
}

template<>
void STRAPI DestructElements(CStr* pElements, int nCount)
{
    ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

    for (; nCount--; ++pElements)
        pElements->Empty();
}

template<>
UINT STRAPI HashKey(LPCTSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "StdDbg.h"

#ifdef DBG
    DECLARE_DEBUG(AMCCore)
    #define DBG_COMP    AMCCoreInfoLevel

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\memento.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      memento.cpp
 *
 *  Contents:  Implements the CMemento class
 *
 *  History:   21-April-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include "serial.h"
#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "cstr.h"
#include <vector>
#include "mmcdebug.h"
#include "mmcerror.h"
#include "mmc.h"
#include "commctrl.h"
#include "bookmark.h"
#include "resultview.h"
#include "viewset.h"
#include "memento.h"

bool
CMemento::operator!=(const CMemento& memento)
{
    return (!operator == (memento));
}

bool
CMemento::operator==(const CMemento& memento)
{
    if(m_viewSettings != memento.m_viewSettings)
        return false;

    if(m_bmTargetNode != memento.m_bmTargetNode)
        return false;

    return true;
}


HRESULT
CMemento::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume unknown version

    if (nVersion == 1)
    {
        try
        {
            stm >> m_bmTargetNode;
            hr = m_viewSettings.Read(stm);
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}

void CMemento::Persist(CPersistor& persistor)
{
    persistor.Persist(m_viewSettings);
    persistor.Persist(m_bmTargetNode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\guidhelp.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       guidhelp.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/18/1996   JonN    Created
//
//____________________________________________________________________________


#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"

DECLARE_INFOLEVEL(AMCCore);

#include "commctrl.h" // for LV_ITEM needed by ndmgrpriv.h

// This defines the GUID's in the headers below.
#ifndef DECLSPEC_UUID
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#endif

#include "mmc.h"
#include "ndmgr.h"
#include "ndmgrpriv.h"
#include "guidhelp.h"
#include "comdef.h"
#include "atlbase.h"	// USES_CONVERSION
#include "macros.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static CLIPFORMAT g_CFNodeType    = 0;
static CLIPFORMAT g_CFSnapInCLSID = 0;
static CLIPFORMAT g_CFDisplayName = 0;

HRESULT ExtractData( IDataObject* piDataObject,
                     CLIPFORMAT   cfClipFormat,
                     BYTE*        pbData,
                     DWORD        cbData )
{
    IF_NULL_RETURN_INVALIDARG2( piDataObject, pbData );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
//          ASSERT( FALSE );
            break;
        }

        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
#if (_MSC_VER >= 1200)
#pragma warning (push)
#endif
#pragma warning(disable: 4553)      // "==" operator has no effect
        VERIFY( NULL == ::GlobalFree(stgmedium.hGlobal) );
#if (_MSC_VER >= 1200)
#pragma warning (pop)
#endif
    }
    return hr;
} // ExtractData()



HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    if( !g_CFSnapInCLSID )
    {
        USES_CONVERSION;
        g_CFSnapInCLSID = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID));
    }

    return ExtractData( piDataObject, g_CFSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    if( !g_CFNodeType )
    {
        USES_CONVERSION;
        g_CFNodeType = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_NODETYPE));
    }

    return ExtractData( piDataObject, g_CFNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}

HRESULT GuidToCStr( CStr* pstr, const GUID& guid )
{
    WCHAR awch[MAX_PATH];
    HRESULT hr = StringFromGUID2(guid, awch, sizeof(awch)/sizeof(awch[0]));
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    USES_CONVERSION;
    LPTSTR lptstr = OLE2T(awch);
    *pstr = lptstr;
    return hr;
}

HRESULT CStrToGuid( const CStr& str, GUID* pguid )
{
    USES_CONVERSION;
    LPOLESTR lpolestr = T2OLE(((LPTSTR)(LPCTSTR)str));
    HRESULT hr = CLSIDFromString(lpolestr, pguid);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT ExtractObjectTypeCStr( IDataObject* piDataObject, CStr* pstr )
{
    GUID guidObjectType;
    HRESULT hr = ExtractObjectTypeGUID( piDataObject, &guidObjectType );
    ASSERT(SUCCEEDED(hr));
    return GuidToCStr( pstr, guidObjectType );
}


HRESULT LoadRootDisplayName(IComponentData* pIComponentData,
                            CStr& strDisplayName)
{
    IDataObjectPtr spIDataObject;
    HRESULT hr = pIComponentData->QueryDataObject(NULL, CCT_SNAPIN_MANAGER, &spIDataObject);
    CHECK_HRESULT(hr);
    if ( FAILED(hr) )
        return hr;

    if( !g_CFDisplayName )
    {
        USES_CONVERSION;
        g_CFDisplayName = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME));
    }

    hr = ExtractString( spIDataObject,
                        g_CFDisplayName,
                        strDisplayName);

    CHECK_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\serial.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      serial.cpp
 *
 *  Contents:  Object serialization class implementation
 *
 *  History:   11-Feb-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include "serial.h"

/*+-------------------------------------------------------------------------*
 *
 * CSerialObject::Write
 *
 * PURPOSE:  Writes an object with version and size information. This information
 *           is used when the object is read. If an unknown version of the object
 *           is presented, the data is discarded. This way, all known data can 
 *           still be retrieved. (Useful for backward as well as forward compatibility.)
 *
 * PARAMETERS: 
 *    IStream & stm :
 *
 * RETURNS: 
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSerialObjectRW::Write(IStream &stm)
{
    HRESULT         hr              = S_OK;
    UINT            nVersion        = GetVersion();
    ULARGE_INTEGER  nSeekPosMarker;
    ULARGE_INTEGER  nSeekPosNextObj;
    LARGE_INTEGER   lZero;
    LARGE_INTEGER   lint;

    try
    {
        do  // not a loop
        {
            lZero.LowPart = 0;
            lZero.HighPart= 0;
            lZero.QuadPart= 0; // just to be safe.

            stm << nVersion;        // save the version information

            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosMarker);  // get the current location of the pointer
            BREAK_ON_FAIL(hr);

            ::ZeroMemory(&nSeekPosNextObj, sizeof(nSeekPosNextObj) );
            // should we use the low part only? Or will this cause a Y2K like crisis?
            stm << nSeekPosNextObj.QuadPart;  // not the correct value; need to come back and fix (done below)

#ifdef DBG
            ULARGE_INTEGER  nSeekPosMarker2;
            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosMarker2);  // get the current location of the pointer
            BREAK_ON_FAIL(hr);
#endif

            hr = WriteSerialObject(stm);  // write the internal data
            BREAK_ON_FAIL(hr);

            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosNextObj);
            BREAK_ON_FAIL(hr);


            // go back to the placeholder marker
            lint.QuadPart = nSeekPosMarker.QuadPart;
            hr = stm.Seek(lint, STREAM_SEEK_SET, NULL);
            BREAK_ON_FAIL(hr);

            stm << nSeekPosNextObj.QuadPart; // the correct value of the marker

#ifdef DBG
            ULARGE_INTEGER  nSeekPosMarker3;
            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosMarker3);  // get the current location of the pointer
            BREAK_ON_FAIL(hr);

            // make sure we're back in the same place
            ASSERT( (nSeekPosMarker2.QuadPart == nSeekPosMarker3.QuadPart) );
#endif

            lint.QuadPart = nSeekPosNextObj.QuadPart;
            hr = stm.Seek(lint, STREAM_SEEK_SET, NULL);
            BREAK_ON_FAIL(hr);

        } while (false);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }
    
    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CSerialObject::Read
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStream & stm :
 *
 * RETURNS: 
 *    HRESULT - S_OK     if able to read the object.
 *              S_FALSE  if skipped reading the object.
 *              E_FAIL   Could not skip the object or something catastrophic.
 *
 *+-------------------------------------------------------------------------*/
HRESULT 
CSerialObject::Read(IStream &stm)
{
    HRESULT         hr              = S_OK;
    UINT            nVersion        = 0;
    ULARGE_INTEGER  nSeekPosMarker;
    ULARGE_INTEGER  nSeekPosNextObj;
    LARGE_INTEGER   lint;    

    try
    {
        stm >> nVersion;    // get the version number

        stm >> nSeekPosNextObj.QuadPart;  // get the offset to the next object

        hr = ReadSerialObject(stm, nVersion);

        if (hr==S_FALSE)    // data skipped?
        {
            // an unknown version. Throw the data for that object away and continue to read other objects
            lint.QuadPart = nSeekPosNextObj.QuadPart;
            hr = stm.Seek(lint, STREAM_SEEK_SET, NULL);

            if (SUCCEEDED (hr))
                hr = S_FALSE;       // propagate "data skipped"
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\picon.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      picon.cpp
 *
 *  Contents:  Implementation file for CPersistableIcon
 *
 *  History:   19-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "picon.h"
#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include "util.h"
#include <comdef.h>
#include <shellapi.h>   // for ExtractIconEx
#include <commctrl.h>   // for HIMAGELIST

/*
 * for comdbg.h (assumes client code is ATL-based)
 */
#include <atlbase.h>    // for CComModule
extern CComModule _Module;
#include "comdbg.h"


const LPCWSTR g_pszCustomDataStorage                = L"Custom Data";
const LPCWSTR CPersistableIcon::s_pszIconFileStream = L"Icon";
const LPCWSTR CPersistableIcon::s_pszIconBitsStream = L"Icon Bits";


static HRESULT ReadIcon  (IStream* pstm, CSmartIcon& icon);


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::~CPersistableIcon
 *
 *
 *--------------------------------------------------------------------------*/

CPersistableIcon::~CPersistableIcon()
{
    Cleanup();
}


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::Cleanup
 *
 *
 *--------------------------------------------------------------------------*/

void CPersistableIcon::Cleanup()
{
	m_icon32.Release();
	m_icon16.Release();
    m_Data.Clear();
}


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::operator=
 *
 *
 *--------------------------------------------------------------------------*/

CPersistableIcon& CPersistableIcon::operator= (const CPersistableIconData& data)
{
    if (&data != &m_Data)
    {
        m_Data = data;
        ExtractIcons ();
    }

    return (*this);
}


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::GetIcon
 *
 * Returns an icon of the requested size.
 *
 * NOTE: this method cannot use SC's because it is used in mmcshext.dll,
 * which doesn't have access to mmcbase.dll, where SC is implemented.
 *--------------------------------------------------------------------------*/

HRESULT CPersistableIcon::GetIcon (int nIconSize, CSmartIcon& icon) const
{
	HRESULT hr = S_OK;

	switch (nIconSize)
	{
		/*
		 * standard sizes can be returned directly
		 */
		case 16:	icon = m_icon16;	break;
        case 32:	icon = m_icon32;	break;

		/*
		 * non-standard sizes need to be scaled
		 */
		default:
			/*
			 * find the icon whose size is nearest to the requested size;
			 * that one should scale with the most fidelity
			 */
			const CSmartIcon& iconSrc = (abs (nIconSize-16) < abs (nIconSize-32))
											? m_icon16
											: m_icon32;

			icon.Attach ((HICON) CopyImage ((HANDLE)(HICON) iconSrc, IMAGE_ICON,
											nIconSize, nIconSize, 0));

			/*
			 * if the CopyImage failed, get the error code
			 */
			if (icon == NULL)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());

				/*
				 * just in case CopyImage failed without setting the last error
				 */
				if (SUCCEEDED (hr))
					hr = E_FAIL;
			}
			break;
	}

	return (hr);
}


/*+-------------------------------------------------------------------------*
 * ExtractIcons
 *
 *
 *--------------------------------------------------------------------------*/

bool CPersistableIcon::ExtractIcons ()
{
	/*
	 * clean out existing contents of our CSmartIcons
	 */
	m_icon32.Release();
	m_icon16.Release();

	/*
	 * extract the icons from the icon file
	 */
	HICON hLargeIcon = NULL;
	HICON hSmallIcon = NULL;
	bool fSuccess = ExtractIconEx (m_Data.m_strIconFile.data(), m_Data.m_nIndex,
								   &hLargeIcon, &hSmallIcon, 1);

	/*
	 * if successful, attach them to our smart icons for resource management;
	 * otherwise, clean up anything that might have been returned
	 */
    if (fSuccess)
    {
		m_icon32.Attach (hLargeIcon);
		m_icon16.Attach (hSmallIcon);
    }
	else
	{
        if (hLargeIcon != NULL)
			DestroyIcon (hLargeIcon);

        if (hSmallIcon != NULL)
			DestroyIcon (hSmallIcon);
	}

    return (fSuccess);
}

/*+-------------------------------------------------------------------------*
 * CPersistableIcon::Load
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CPersistableIcon::Load (LPCWSTR pszFilename)
{
    HRESULT hr = E_FAIL;

    do  // not a loop
    {
        IStoragePtr spRootStg;
        IStoragePtr spDefaultIconStg;

        hr = OpenDebugStorage (pszFilename,
                             STGM_READ | STGM_SHARE_DENY_WRITE,
                             &spRootStg);
        BREAK_ON_FAIL (hr);

        hr = OpenDebugStorage (spRootStg, g_pszCustomDataStorage,
                                     STGM_READ | STGM_SHARE_EXCLUSIVE,
                                     &spDefaultIconStg);

        BREAK_ON_FAIL (hr);

        hr = Load (spDefaultIconStg);

    } while (false);

    return (hr);
}


HRESULT CPersistableIcon::Load (IStorage* pStorage)
{
    HRESULT hr;

    try
    {
        /*
         * read the icon data from the stream
         */
        IStreamPtr spStm;
        hr = OpenDebugStream (pStorage, s_pszIconFileStream,
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   &spStm);
        THROW_ON_FAIL (hr);

        *spStm >> m_Data;

		hr = OpenDebugStream (pStorage, s_pszIconBitsStream,
								   STGM_READ | STGM_SHARE_EXCLUSIVE,
								   &spStm);
		THROW_ON_FAIL (hr);

		hr = ReadIcon (spStm, m_icon32);
		THROW_ON_FAIL (hr);

		hr = ReadIcon (spStm, m_icon16);
		THROW_ON_FAIL (hr);
    }
    catch (_com_error& err)
    {
        /*
         * Bug 393868: If anything failed, make sure we clean up anything
         * that was partially completed, to leave us in a coherent
         * (uninitialized) state.
         */
        Cleanup();

        hr = err.Error();
    }

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * ReadIcon
 *
 *
 *--------------------------------------------------------------------------*/

static HRESULT ReadIcon (IStream* pstm, CSmartIcon& icon)
{
    HIMAGELIST  himl = NULL;
	HRESULT		hr   = ReadCompatibleImageList (pstm, himl);

    if (himl != NULL)
    {
        icon.Attach (ImageList_GetIcon (himl, 0, ILD_NORMAL));

		if (icon != NULL)
			hr = S_OK;

        ImageList_Destroy (himl);
    }

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CPersistableIconData from a stream.
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, CPersistableIconData& icon)
{
    /*
     * Read the stream version
     */
    DWORD dwVersion;
    stm >> dwVersion;

    switch (dwVersion)
    {
        case 1:
            stm >> icon.m_nIndex;
            stm >> icon.m_strIconFile;
            break;

        /*
         * beta custom icon format, migrate it forward
         */
        case 0:
        {
            /*
             * Read the custom icon index
             */
            WORD wIconIndex;
            stm >> wIconIndex;
            icon.m_nIndex = wIconIndex;

            /*
             * Read the length, in bytes, of the filename
             */
            WORD cbFilename;
            stm >> cbFilename;

            /*
             * Read the custom icon filename (always in Unicode)
             */
            WCHAR wszFilename[MAX_PATH];

            if (cbFilename > sizeof (wszFilename))
                _com_issue_error (E_FAIL);

            DWORD cbRead;
            HRESULT hr = stm.Read (&wszFilename, cbFilename, &cbRead);
            THROW_ON_FAIL (hr);

            USES_CONVERSION;
            icon.m_strIconFile = W2T (wszFilename);
            break;
        }

        default:
            _com_issue_error (E_FAIL);
            break;
    }

    return (stm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=     uicore
TARGETPATH=     obj
TARGETTYPE=     LIBRARY

SYNCHRONIZE_BLOCK = 1
USE_NATIVE_EH     = 1
USE_STATIC_ATL    = 1
USE_CRTDLL        = 1
ATL_VER           = 30
USE_WTL           = 1
USE_STL=1         = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

C_DEFINES = $(C_DEFINES) -DISOLATION_AWARE_ENABLED

# We need $(SHELL_INC_PATH) for uastrfnc.h
INCLUDES = \
	..\;					\
	..\..\inc;				\
	..\..\types\idl\$(O);	\
	$(SHELL_INC_PATH);		\

SOURCES=\
	..\assert.cpp   	\
	..\bitmap.cpp   	\
	..\crc32.c      	\
	..\cstr.cpp     	\
	..\guidhelp.cpp 	\
	..\memento.cpp  	\
	..\picon.cpp    	\
	..\serial.cpp   	\
	..\stddbg.cpp   	\
	..\stgio.cpp    	\
	..\strings.cpp  	\
	..\tstring.cpp  	\
	..\util.cpp     	\
	..\viewset.cpp  	\
	..\xmlbase.cpp  	\
	..\base64.cpp   	\
	..\columninfo.cpp	\
	..\smarticon.cpp	\
	..\xmlicon.cpp		\
	..\xmlimage.cpp		\

UMTYPE= windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\smarticon.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      smarticon.cpp
 *
 *  Contents:  Implementation file for CSmartIcon
 *
 *  History:   25-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "smarticon.h"


/*+-------------------------------------------------------------------------*
 * CSmartIcon::~CSmartIcon
 *
 * Destroys a CSmartIcon object.
 *--------------------------------------------------------------------------*/

CSmartIcon::~CSmartIcon ()
{
	Release();
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::CSmartIcon
 *
 * Copy constructor for a CSmartIcon object.
 *--------------------------------------------------------------------------*/

CSmartIcon::CSmartIcon (const CSmartIcon& other)
{
	m_pData = other.m_pData;

	if (m_pData)
		m_pData->AddRef();
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::operator=
 *
 * Assignment operator for CSmartIcon.
 *--------------------------------------------------------------------------*/

CSmartIcon& CSmartIcon::operator= (const CSmartIcon& rhs)
{
	if (&rhs != this)
	{
		Release();

		m_pData = rhs.m_pData;
		if (m_pData)
			m_pData->AddRef();
	}

	return *this;
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::Attach
 *
 * Releases the currently held icon and creates a CSmartIconData to hold
 * a reference to the given icon.
 *
 * You would use this method in the same way you'd use CComPtr<T>::Attach.
 *
 * This method will destroy the icon if the underlying CSmartIconData object
 * cannot be created because of insufficient memory.
 *--------------------------------------------------------------------------*/

void CSmartIcon::Attach (HICON hIcon)
{
	/*
	 * if we're already attached to this icon, there's nothing to do
	 */
	if (operator HICON() == hIcon)
		return;

	Release();
	ASSERT (m_pData == NULL);

	/*
	 * if we couldn't create a CSmartIconData to hold hIcon, destroy hIcon
	 */
	if ( (hIcon != NULL) &&
		((m_pData = CSmartIconData::CreateInstance (hIcon)) == NULL))
	{
		DestroyIcon (hIcon);
	}
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::Detach
 *
 * Releases the currently held icon, passing ownership (and responsibility
 * for deletion) to the caller.
 *
 * You would use this method in the same way you'd use CComPtr<T>::Detach.
 *--------------------------------------------------------------------------*/

HICON CSmartIcon::Detach ()
{
	HICON hIcon = NULL;

	/*
	 * if we've got an icon, detach it from our CSmartIconData
	 */
	if (m_pData != NULL)
	{
		hIcon   = m_pData->Detach();
		m_pData = NULL;
	}

	return (hIcon);
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::Release
 *
 * Releases this CSmartIcon's reference on its icon.  It is safe to call
 * this on a CSmartIcon that doesn't refer to an icon.
 *
 * You would use this method in the same way you'd use CComPtr<T>::Release.
 *--------------------------------------------------------------------------*/

void CSmartIcon::Release()
{
	if (m_pData)
	{
		m_pData->Release();
		m_pData = NULL;
	}
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::CSmartIconData::Detach
 *
 * Releases the currently held icon, passing ownership (and responsibility
 * for deletion) to the caller.
 *--------------------------------------------------------------------------*/

HICON CSmartIcon::CSmartIconData::Detach ()
{
	HICON hIcon = NULL;

	/*
	 * if there's only one reference on us, then we can return the icon
	 * we holding directly to the caller
	 */
	if (m_dwRefs == 1)
	{
		hIcon = m_hIcon;
		m_hIcon = NULL;		// so our d'tor won't delete it
	}

	/*
	 * otherwise, we have more than one reference on us; we need to copy
	 * the icon we're holding so others who refer to us won't have their
	 * icons destroyed from underneath them
	 */
	else
		hIcon = CopyIcon (m_hIcon);

	/*
	 * let go of our reference
	 */
	Release();

	/*
	 * Hands off!  Release() may have deleted this object.
	 */

	return (hIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\stddbg.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stddbg.cpp
 *
 *  Contents:  Implementation file for CDebugLeakDetector
 *
 *  History:   26-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/
#ifdef DBG

#include "windows.h"
#include "stddbg.h"
#include "tstring.h"
#include <map>
#include "atlbase.h" // USES_CONVERSION
//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>
DECLARE_INFOLEVEL(AMCCore);
DECLARE_HEAPCHECKING;


class CDebugLeakDetector : public CDebugLeakDetectorBase
{
public:
    CDebugLeakDetector()
    {}

    virtual ~CDebugLeakDetector()
    {
        DumpLeaks();
    }

    virtual void DumpLeaks()
    {
        RefCountsMap::iterator it;
        std::string strError;

        for (it = m_RefCounts.begin(); it != m_RefCounts.end(); ++it)
        {
            const std::string&  strClass = it->first;
            int                 cRefs    = it->second;

            if (cRefs != 0)
            {
                if (!strError.empty())
                    strError += "\n";

                char szMessage[512];
                int cchMessage = 512;
                StringCchPrintfA (szMessage, cchMessage, "%s has %d instances left over",
                           strClass.data(), cRefs);

                strError += szMessage;
            }
        }

        if (!strError.empty())
            ::MessageBoxA(NULL, strError.data(), "MMC: Memory Leaks!!!", MB_OK | MB_SERVICE_NOTIFICATION);
    }

    virtual int AddRef(const std::string& strClass)
    {
        return (++m_RefCounts[strClass]);
    }

    virtual int Release(const std::string& strClass)
    {
        /*
         * if this assert fails, you're releasing something that 
         * hasn't been addref'd -- check the spelling in your
         * DEBUG_DECREMENT_INSTANCE_COUNTER macro usage
         */
        ASSERT (m_RefCounts.find (strClass) != m_RefCounts.end());

        /*
         * If this assert fails, you have excessive releases.
         * One possible cause of this is you might be using a 
         * compiler-generated copy constructor for your object,
         * which won't call DEBUG_INCREMENT_INSTANCE_COUNTER.
         * Define your own copy constructor.
         */
        ASSERT (m_RefCounts[strClass] > 0);

        return (--m_RefCounts[strClass]);
    }

private:
    class RefCounter
    {
    public:
        RefCounter() : m_cRefs(0) {}

        operator int()
        {
            return (m_cRefs);
        }

        int operator++()    // pre-increment
        {
            return (++m_cRefs);
        }

        int operator++(int) // post-increment
        {
            int t = m_cRefs++;
            return (t);
        }

        operator--()        // pre-decrement
        {
            return (--m_cRefs);
        }

        int operator--(int) // post-decrement
        {
            int t = m_cRefs--;
            return (t);
        }

    private:
        int m_cRefs;
    };

    typedef std::map<std::string, RefCounter>   RefCountsMap;
    RefCountsMap m_RefCounts;
};


CDebugLeakDetectorBase& GetLeakDetector()
{
    static CDebugLeakDetector detector;
    return (detector);
}

DBG_PersistTraceData::DBG_PersistTraceData() : 
bIComponent(false), 
bIComponentData(false),
pTraceFN(NULL)
{
} 

void DBG_PersistTraceData::SetTraceInfo(DBG_PersistTraceData::PTraceErrorFn pFn, bool bComponent, const tstring& owner)
{
    ASSERT(pFn);
    pTraceFN = pFn;
    bIComponent = bComponent;
    bIComponentData = !bComponent;
    strSnapin = owner;
}

void DBG_PersistTraceData::TraceErr(LPCTSTR strInterface, LPCTSTR msg)
{
    if (!pTraceFN)
        return;

    tstring formatted;

    formatted += tstring(_T("\"")) + (strSnapin) + _T("\"");

    formatted += tstring(_T(" Interface ")) + strInterface;

    if (bIComponent)
        formatted += _T("[IComponent]");
    else if (bIComponentData)
        formatted += _T("[IComponentData]");

    formatted += _T(" - ");
    formatted += msg;

    pTraceFN(formatted.c_str());
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       strings.cpp
//
//--------------------------------------------------------------------------

#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

// put actual strings here
#define INIT_MMC_BASE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\stgio.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stgio.h
 *
 *  Contents:  Interface file structured storage I/O utilities
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include <tchar.h>


/*+-------------------------------------------------------------------------*
 * ReadScalar 
 *
 * Reads a scalar value from a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& ReadScalar (IStream& stm, T& t)
{
    ULONG cbActuallyRead;
    HRESULT hr = stm.Read (&t, sizeof (t), &cbActuallyRead);
    THROW_ON_FAIL (hr);

    if (cbActuallyRead != sizeof (t))
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * WriteScalar 
 *
 * Writes a scalar value to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& WriteScalar (IStream& stm, const T& t)
{
    ULONG cbActuallyWritten;
    HRESULT hr = stm.Write (&t, sizeof (t), &cbActuallyWritten);
    THROW_ON_FAIL (hr);

    if (cbActuallyWritten != sizeof (t))
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * ReadString 
 *
 * Reads a std::basic_string from a stream.  The string should have been 
 * written with a DWORD character count preceding an array of characters
 * that is not NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class E, class Tr, class A>
static IStream& ReadString (IStream& stm, std::basic_string<E,Tr,A>& str)
{
    /*
     * read the length
     */
    DWORD cch;
    stm >> cch;

    /*
     * allocate a buffer for the characters
     */
    std::auto_ptr<E> spBuffer (new (std::nothrow) E[cch + 1]);
    E* pBuffer = spBuffer.get();

    if (pBuffer == NULL)
        _com_issue_error (E_OUTOFMEMORY);

    /*
     * read the characters
     */
    ULONG cbActuallyRead;
    const ULONG cbToRead = cch * sizeof (E);
    HRESULT hr = stm.Read (pBuffer, cbToRead, &cbActuallyRead);
    THROW_ON_FAIL (hr);

    if (cbToRead != cbActuallyRead)
        _com_issue_error (E_FAIL);

    /*
     * terminate the character array and assign it to the string
     */
    pBuffer[cch] = 0;

    /*
     * assign it to the string (clear the string first to work around
     * the bug described in KB Q172398)
     */
    str.erase();
    str = pBuffer;

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * WriteString 
 *
 * Writes a std::basic_string to a stream.  The string is written with a 
 * DWORD character count preceding an array of characters that is not 
 * NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class E, class Tr, class A>
static IStream& WriteString (IStream& stm, const std::basic_string<E,Tr,A>& str)
{
    /*
     * write the length
     */
    DWORD cch = str.length();
    stm << cch;

    if (cch > 0)
    {
        /*
         * write the characters
         */
        ULONG cbActuallyWritten;
        const ULONG cbToWrite = cch * sizeof (E);
        HRESULT hr = stm.Write (str.data(), cbToWrite, &cbActuallyWritten);
        THROW_ON_FAIL (hr);

        if (cbToWrite != cbActuallyWritten)
            _com_issue_error (E_FAIL);
    }

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<, operator>>
 *
 * Stream insertion and extraction operators for various types
 *--------------------------------------------------------------------------*/

#define DefineScalarStreamOperators(scalar_type)                \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, scalar_type t)           \
        { return (WriteScalar (stm, t)); }          
                                                    
#define DefineScalarStreamOperatorsByRef(scalar_type)           \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, const scalar_type& t)    \
        { return (WriteScalar (stm, t)); }

DefineScalarStreamOperators      (bool);
DefineScalarStreamOperators      (         char);
DefineScalarStreamOperators      (unsigned char);
DefineScalarStreamOperators      (         short);
DefineScalarStreamOperators      (unsigned short);
DefineScalarStreamOperators      (         int);
DefineScalarStreamOperators      (unsigned int);
DefineScalarStreamOperators      (         long);
DefineScalarStreamOperators      (unsigned long);
DefineScalarStreamOperators      (         __int64);
DefineScalarStreamOperators      (unsigned __int64);
DefineScalarStreamOperators      (float);
DefineScalarStreamOperators      (double);
DefineScalarStreamOperators      (long double);
DefineScalarStreamOperatorsByRef (CLSID);

IStream& operator>> (IStream& stm, std::string& str)
    { return (ReadString (stm, str)); }
IStream& operator<< (IStream& stm, const std::string& str)
    { return (WriteString (stm, str)); }

IStream& operator>> (IStream& stm, std::wstring& str)
    { return (ReadString (stm, str)); }
IStream& operator<< (IStream& stm, const std::wstring& str)
    { return (WriteString (stm, str)); }


/*+-------------------------------------------------------------------------*
 * ReadScalarVector 
 *
 * Reads an entire vector collection of scalar types (written by 
 * insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
static void ReadScalarVector (IStream* pstm, std::vector<T>& v)
{
    /*
     * clear out the current container
     */
    v.clear();

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    if (cItems > 0)
    {
        /*
         * allocate a buffer for the elements
         */
        std::auto_ptr<T> spBuffer (new (std::nothrow) T[cItems]);
        T* pBuffer = spBuffer.get();

        if (pBuffer == NULL)
            _com_issue_error (E_OUTOFMEMORY);

        /*
         * read the elements
         */
        ULONG cbActuallyRead;
        const ULONG cbToRead = cItems * sizeof (T);
        HRESULT hr = pstm->Read (pBuffer, cbToRead, &cbActuallyRead);
        THROW_ON_FAIL (hr);

        if (cbToRead != cbActuallyRead)
            _com_issue_error (E_FAIL);

        /*
         * assign the elements to the vector
         */
        v.assign (pBuffer, pBuffer + cItems);
    }
}


/*+-------------------------------------------------------------------------*
 * WriteScalarVector 
 *
 * Writes an entire vector of scalar types to an IStream.  Note that this
 * code assumes that vectors store their elements sequentially.
 *--------------------------------------------------------------------------*/

template<class T>
static void WriteScalarVector (IStream* pstm, const std::vector<T>& v)
{
    /*
     * write the size
     */
    DWORD cItems = v.size();
    *pstm << cItems;

    if (cItems > 0)
    {
        /*
         * write the elements
         */
        ULONG cbActuallyWritten;
        const ULONG cbToWrite = cItems * sizeof (T);
        HRESULT hr = pstm->Write (v.begin(), cbToWrite, &cbActuallyWritten);
        THROW_ON_FAIL (hr);

        if (cbToWrite != cbActuallyWritten)
            _com_issue_error (E_FAIL);
    }
}


/*+-------------------------------------------------------------------------*
 * extract_vector (specialization for std::vector<scalar>)
 *      Efficiently extracts an entire vector collection of scalar types 
 *      (written by insert_collection) from an IStream.
 * 
 * insert_collection (specializations for std::vector<scalar>)
 *      Efficiently inserts an entire vector of scalar types into an IStream.
 *--------------------------------------------------------------------------*/

#define DefineScalarVectorStreamFunctions(scalar_type)                  \
    void extract_vector (IStream* pstm, std::vector<scalar_type>& v)    \
        { ReadScalarVector (pstm, v); }                                 \
    void insert_collection (IStream* pstm, const std::vector<scalar_type>& v)\
        { WriteScalarVector (pstm, v); }                                    
                                                    
DefineScalarVectorStreamFunctions (bool);
DefineScalarVectorStreamFunctions (         char);
DefineScalarVectorStreamFunctions (unsigned char);
DefineScalarVectorStreamFunctions (         short);
DefineScalarVectorStreamFunctions (unsigned short);
DefineScalarVectorStreamFunctions (         int);
DefineScalarVectorStreamFunctions (unsigned int);
DefineScalarVectorStreamFunctions (         long);
DefineScalarVectorStreamFunctions (unsigned long);
DefineScalarVectorStreamFunctions (         __int64);
DefineScalarVectorStreamFunctions (unsigned __int64);
DefineScalarVectorStreamFunctions (float);
DefineScalarVectorStreamFunctions (double);
DefineScalarVectorStreamFunctions (long double);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\tstring.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tstring.h
 *
 *  Contents:  Implementation file for tstring
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "tstring.h"
#include "stgio.h"
#include <atlbase.h>
#include <comutil.h>
#include "macros.h"
#include "countof.h"


/*+-------------------------------------------------------------------------*
 * tstring::LoadString
 *
 *
 *--------------------------------------------------------------------------*/

bool tstring::LoadString (HINSTANCE hInst, UINT nID)
{
#ifdef UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

    // try fixed buffer first (to avoid wasting space in the heap)
    TCHAR szTemp[256];
    int nCount = sizeof(szTemp) / sizeof(szTemp[0]);
    int nLen   = ::LoadString(hInst, nID, szTemp, nCount);

    if (nCount - nLen > CHAR_FUDGE)
        *this = szTemp;

    else
    {
        // try buffer size of 512, then larger size until entire string is retrieved
        LPTSTR  pszBuffer = NULL;
        int nSize = 256;

        do
        {
            nSize += 256;
            delete[] pszBuffer;
            pszBuffer = new TCHAR[nSize];
            if (!pszBuffer)
            {
                return false; // Memory alloc failed.
            }

            nLen = ::LoadString(hInst, nID, pszBuffer, nSize);
        } while (nSize - nLen <= CHAR_FUDGE);

        *this = pszBuffer;
        delete[] pszBuffer;
    }

    return (nLen > 0);
}


#ifndef UNICODE

/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * ANSI only:  Extracts a string from a stream in Unicode format, then
 * converts it to ANSI.
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, tstring& str)
{
    USES_CONVERSION;

    std::wstring wstr;
    stm >> wstr;
    str = W2CA (wstr.data());

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * ANSI only:  Inserts a tstring into a stream in Unicode format.
 *--------------------------------------------------------------------------*/

IStream& operator<< (IStream& stm, const tstring& str)
{
    USES_CONVERSION;
    return (stm << std::wstring (A2W (str.data())));
}

#endif // UNICODE




/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::CStringTableStringBase
 *
 *
 *--------------------------------------------------------------------------*/

CStringTableStringBase::CStringTableStringBase (IStringTablePrivate* pstp)
    :   m_spStringTable (pstp),
        m_id            (eNoValue)
{
}

CStringTableStringBase::CStringTableStringBase (const CStringTableStringBase& other)
    :   m_spStringTable (other.m_spStringTable),
        m_id            (eNoValue)
{
    Assign (other);
}

CStringTableStringBase::CStringTableStringBase (
    IStringTablePrivate*    pstp,
    const tstring&          str)
    :   m_spStringTable (pstp),
        m_id            (eNoValue),
        m_str           (str)
{
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::operator=
 *
 *
 *--------------------------------------------------------------------------*/

CStringTableStringBase& CStringTableStringBase::operator= (const CStringTableStringBase& other)
{
    if (&other != this)
    {
        RemoveFromStringTable();
        Assign (other);
    }

    return (*this);
}

CStringTableStringBase& CStringTableStringBase::operator= (const tstring& str)
{
    /*
     * string table operations are relatively expensive, so a string
     * comparision before we do any string table stuff is warranted
     */
    if (m_str != str)
    {
        RemoveFromStringTable();

        /*
         * copy the text, but delay committing to the string table
         */
        m_str = str;
    }

    return (*this);
}

CStringTableStringBase& CStringTableStringBase::operator= (LPCTSTR psz)
{
    return (operator= (tstring (psz)));
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::Assign
 *
 *
 *--------------------------------------------------------------------------*/

void CStringTableStringBase::Assign (const CStringTableStringBase& other)
{
    ASSERT (m_id == eNoValue);

    /*
     * copy the other's value
     */
    m_str = other.m_str;

    /*
     * if the source string is already committed to
     * the string table, this one should be, too
     */
    if (other.m_id != eNoValue)
        CommitToStringTable ();
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::~CStringTableStringBase
 *
 *
 *--------------------------------------------------------------------------*/

CStringTableStringBase::~CStringTableStringBase ()
{
    RemoveFromStringTable();
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::CommitToStringTable
 *
 * Attaches the current string to the given string table
 *--------------------------------------------------------------------------*/

MMC_STRING_ID CStringTableStringBase::CommitToStringTable () const
{
    /*
     * Commit the string if:
     *
     * 1. the string's not already in the string table, and
     * 2. it's not empty, and
     * 3. we have a string table
     */
    if ((m_id == eNoValue) && !m_str.empty() && (m_spStringTable != NULL))
    {
        USES_CONVERSION;
        m_spStringTable->AddString (T2CW (m_str.data()), &m_id, NULL);
    }

    return (m_id);
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::RemoveFromStringTable
 *
 * Detaches the current string from the current string table.
 *--------------------------------------------------------------------------*/

void CStringTableStringBase::RemoveFromStringTable () const
{
    /*
     * if we have a string ID from the current string table, delete it
     */
    if (m_id != eNoValue)
    {
        /*
         * shouldn't be removing a string from a string table unless
         * we have already added it (and therefore obtained an interface)
         */
        ASSERT (m_spStringTable != NULL);

        m_spStringTable->DeleteString (m_id, NULL);
        m_id = eNoValue;
    }
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 *
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, CStringTableStringBase& str)
{
    str.RemoveFromStringTable();

    stm >> str.m_id;

    if (str.m_id != CStringTableStringBase::eNoValue)
    {
        try
        {
            USES_CONVERSION;
            HRESULT hr;
            ULONG cch;

            if (str.m_spStringTable == NULL)
                _com_issue_error (E_NOINTERFACE);

            hr = str.m_spStringTable->GetStringLength (str.m_id, &cch, NULL);
            THROW_ON_FAIL (hr);

            // allow for NULL terminator
            cch++;

            std::auto_ptr<WCHAR> spszText (new (std::nothrow) WCHAR[cch]);
            LPWSTR pszText = spszText.get();

            if (pszText == NULL)
                _com_issue_error (E_OUTOFMEMORY);

            hr = str.m_spStringTable->GetString (str.m_id, cch, pszText, NULL, NULL);
            THROW_ON_FAIL (hr);

            str.m_str = W2T (pszText);
        }
        catch (_com_error& err)
        {
            ASSERT (false && "Caught _com_error");
            str.m_id = CStringTableStringBase::eNoValue;
            str.m_str.erase();
            throw;
        }
    }
    else
        str.m_str.erase();

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 *
 *--------------------------------------------------------------------------*/

IStream& operator<< (IStream& stm, const CStringTableStringBase& str)
{
    str.CommitToStringTable();

#ifdef DBG
    /*
     * make sure CommitToStringTable really committed
     */
    if (str.m_id != CStringTableStringBase::eNoValue)
    {
        WCHAR sz[256];
        ASSERT (str.m_spStringTable != NULL);
        HRESULT hr = str.m_spStringTable->GetString (str.m_id, countof(sz), sz, NULL, NULL);

        ASSERT (SUCCEEDED(hr) && "Persisted a CStringTableString to a stream that's not in the string table");
    }
#endif

    stm << str.m_id;

    return (stm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\stgutil.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       stgutil.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/3/1996   RaviR   Created
//
//____________________________________________________________________________

#include "headers.hxx"
#pragma hdrstop

#include <afxconv.h>
#include "stgutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//____________________________________________________________________________
//
//  Member:     CIStream::Read
//
//  Synopsis:   Reads cb count of bytes from the stream passed into the
//              buffer, pv.  Insures the count read equals the count
//              requested.
//
//  Arguments:  [pv]   -- buffer to read into.
//              [cb]   -- read request byte count.
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes read != bytes expected>.
//____________________________________________________________________________

void
CIStream::Read(VOID * pv, ULONG cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pv != NULL);

    ULONG cbRead = 0;

    HRESULT hr = m_pstm->Read(pv, cb, &cbRead);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cb != cbRead)
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}


//____________________________________________________________________________
//
//  Member:     CIStream::Write
//
//  Synopsis:   Writes cb count of bytes from the stream passed from the
//              buffer, pv.  Insures the count written equals the count
//              specified.
//
//  Arguments:  [pv]   -- buffer to write from.
//              [cb]   -- write request byte count.
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes written != bytes expected>.
//____________________________________________________________________________

void
CIStream::Write(
    const VOID * pv,
    ULONG        cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pv != NULL);

    ULONG cbWritten = 0;

    HRESULT hr = m_pstm->Write(pv, cb, &cbWritten);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cb != cbWritten)
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}



//____________________________________________________________________________
//
//  Member:     CIStream::CopyTo
//
//  Synopsis:   Copies cb number of bytes from the current seek pointer in
//              the stream to the current seek pointer in another stream
//
//  Arguments:  [pstm] -- Points to the destination stream
//              [cb]   -- Specifies the number of bytes to copy
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes read != bytes written>.
//____________________________________________________________________________

void
CIStream::CopyTo(
    IStream * pstm,
    ULARGE_INTEGER cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pstm != NULL);

    ULARGE_INTEGER cbRead = {0};
    ULARGE_INTEGER cbWritten = {0};

    HRESULT hr = m_pstm->CopyTo(pstm, cb, &cbRead, &cbWritten);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cbWritten.LowPart != cbRead.LowPart ||
             cbWritten.HighPart != cbRead.HighPart )
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\util.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       util.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7/8/1996   RaviR   Created
//
//____________________________________________________________________________

#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"
#include <Atlbase.h>
#include <winnls.h>
#include "tstring.h"
#include "strings.h"

//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>

/* define these ourselves until they're defined properly in commctrl.h */
#ifndef ILP_DOWNLEVEL
#define ILP_NORMAL          0           // Writes or reads the stream using new sematics for this version of comctl32
#define ILP_DOWNLEVEL       1           // Write or reads the stream using downlevel sematics.

WINCOMMCTRLAPI HRESULT WINAPI ImageList_ReadEx(DWORD dwFlags, LPSTREAM pstm, REFIID riid, PVOID* ppv);
WINCOMMCTRLAPI HRESULT WINAPI ImageList_WriteEx(HIMAGELIST himl, DWORD dwFlags, LPSTREAM pstm);
#endif


ULONG _ttoul(LPTSTR psz)
{
    ULONG ul;

    for (ul = 0; *psz != TEXT('\0'); ++psz)
    {
        ul = ul * 10 + (*psz - TEXT('0'));
    }

    return ul;
}


WORD I_SplitModuleAndResourceID(LPCTSTR szBuf)
{
    WORD wID = (WORD)-1;

    // String must be in the form "module, res_id"

    for (TCHAR *ptc = (TCHAR *)szBuf;
         *ptc != TEXT('\0') && *ptc != TEXT(',');
         ptc++);

    // If no comma - return
    if (*ptc != TEXT(','))
        return wID;

    *ptc = TEXT('\0');

    ++ptc;

    while (*ptc == TEXT(' ') && *ptc != TEXT('\0'))
    {
        ++ptc;
    }

    // If it does not have a res_id break.
    if (*ptc == TEXT('\0'))
        return wID;

    // Get the res-id
    wID = (WORD)_ttoul(ptc);

    return wID;
}


BOOL
I_GetStrFromModule(
    LPCTSTR     pszModule,
    ULONG       ulMsgNo,
    CStr        &strBuf)
{
    TCHAR       szBuf[512];
    ULONG       cchBuf = 512;

    HINSTANCE hinst = LoadLibraryEx(pszModule, NULL,
                                    LOAD_LIBRARY_AS_DATAFILE);
    if (hinst)
    {
        LANGID lidUser = LANGIDFROMLCID(GetUserDefaultLCID());

        DWORD cChars = ::FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                            (HMODULE)hinst,
                            ulMsgNo,
                            lidUser,
                            szBuf,
                            cchBuf,
                            NULL);

        FreeLibrary(hinst);

        if (cChars != 0)
        {
            strBuf = szBuf;
            return TRUE;
        }
    }

    //Dbg(DEB_USER1, _T("I_GetStringFromModule failed<%dL>\n"), GetLastError());

    return FALSE;
}

HICON I_GetHicon(LPCTSTR pszModule, ULONG ulId)
{
    HICON hIcon = NULL;

    HINSTANCE hinst = LoadLibraryEx(pszModule, NULL,
                                    LOAD_LIBRARY_AS_DATAFILE);
    if (hinst)
    {
        hIcon = LoadIcon(hinst, MAKEINTRESOURCE(ulId));

        FreeLibrary(hinst);
    }

    return hIcon;
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDupString
//
//  Synopsis:   Allocates memory & duplicates a given string.
//
//  Arguments:  [lpszIn]   -- IN the string to duplicate.
//
//  Returns:    The duplicated string. Throws exception if out of memory.
//
//+---------------------------------------------------------------------------

LPTSTR NewDupString(LPCTSTR lpszIn)
{
    if(NULL == lpszIn)
    {
        ASSERT(FALSE);
        return NULL;
    }

    register ULONG len = lstrlen(lpszIn) + 1;

    TCHAR * lpszOut = new TCHAR[len];
    if (lpszOut == NULL)
        return NULL;

    if(FAILED(StringCchCopy(lpszOut, len, lpszIn)))
    {
        ASSERT(FALSE);
        lpszOut[0] = '\0';
    }
    return lpszOut;
}


//+---------------------------------------------------------------------------
//
//  Function:   CoTaskDupString
//
//  Synopsis:   Allocates memory & duplicates a given string.
//
//  Arguments:  [lpszIn]   -- IN the string to duplicate.
//
//  Returns:    The duplicated string. Throws exception if out of memory.
//
//+---------------------------------------------------------------------------
// Tony
LPSTR CoTaskDupString(LPCSTR lpszIn)
{
    if (lpszIn == NULL)
        return NULL;

    ULONG cchTemp = (strlen(lpszIn) + 1); 
    LPSTR lpszOut = (LPSTR) CoTaskMemAlloc(cchTemp * sizeof(CHAR));

    if (lpszOut != NULL)
    {
        if(FAILED(StringCchCopyA(lpszOut, cchTemp, lpszIn)))
        {
            ASSERT(FALSE);
        }
    }

    return (lpszOut);
}

LPWSTR CoTaskDupString(LPCWSTR lpszIn)
{
    if (lpszIn == NULL)
        return NULL;

    ULONG cchTemp = (wcslen(lpszIn) + 1);
    LPWSTR lpszOut = (LPWSTR) CoTaskMemAlloc(cchTemp * sizeof(WCHAR));

    if (lpszOut != NULL)
    {
        if(FAILED(StringCchCopyW(lpszOut, cchTemp, lpszIn)))
        {
            ASSERT(FALSE);
        }
    }

    return (lpszOut);
}

//+---------------------------------------------------------------------------
//
//  Function:   GUIDToString
//              GUIDFromString
//
//  Synopsis:   Converts between GUID& and CStr
//
//  Returns:    FALSE for invalid string, or CMemoryException
//
//+---------------------------------------------------------------------------

HRESULT GUIDToCStr(CStr& str, const GUID& guid)
{
    LPOLESTR lpolestr = NULL;
    HRESULT hr = StringFromIID( guid, &lpolestr );
    if (FAILED(hr))
    {
        //TRACE("GUIDToString error %ld\n", hr);
        return hr;
    }
    else
    {
        str = lpolestr;
        CoTaskMemFree(lpolestr);
    }
    return hr;
}

HRESULT GUIDFromCStr(const CStr& str, GUID* pguid)
{
    USES_CONVERSION;

    HRESULT hr = IIDFromString( T2OLE( const_cast<LPTSTR>((LPCTSTR)str) ), pguid );
    if (FAILED(hr))
    {
        //TRACE("GUIDFromString error %ld\n", hr);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoesFileExist
//
//  Synopsis:   Determines if the specified file exists. The file path may
//              include environment variables.
//
//  Returns:    TRUE/FALSE
//
//+---------------------------------------------------------------------------

BOOL DoesFileExist(LPCTSTR pszFilePath)
{
    TCHAR szExpandedPath[MAX_PATH];

    DWORD dwCnt = ExpandEnvironmentStrings(pszFilePath, szExpandedPath, MAX_PATH);
    if (dwCnt == 0 || dwCnt > MAX_PATH)
        return FALSE;

    return (::GetFileAttributes(szExpandedPath) != 0xffffffff);
}


/*+-------------------------------------------------------------------------*
 *
 * GetHelpFile
 *
 * PURPOSE: Returns a path to the help file
 *
 * RETURNS:
 *    static LPCTSTR
 *
 *+-------------------------------------------------------------------------*/
LPCTSTR GetHelpFile()
{
    static const TCHAR NEW_HELP_FILE_STR[] = _T("%windir%\\Help\\MMC_DLG.HLP");
    static const TCHAR OLD_HELP_FILE_STR[] = _T("%windir%\\Help\\MMC.HLP");

    static LPCTSTR pszHelpFile = NULL;

    // See if help file is present. Check new name first, then old name.
    // This is done because the old help file may be overwritten by
    // an MMC 1.0 installation (see NT bug 299590)

    if (pszHelpFile == NULL)
    {
        if (DoesFileExist(NEW_HELP_FILE_STR))
        {
            pszHelpFile = NEW_HELP_FILE_STR;
        }
        else if (DoesFileExist(OLD_HELP_FILE_STR))
        {
            pszHelpFile = OLD_HELP_FILE_STR;
        }
        else
        {
            // if neither file is present, then use the new file name.
            // This will let WinHelp display an error message indicating
            // that the file is missing and needs to be installed.
            pszHelpFile = NEW_HELP_FILE_STR;
        }
    }

    return pszHelpFile;
}

//+---------------------------------------------------------------------------
//
//  Function:   HelpWmHelp
//
//  Synopsis:   Calls WinHelp with the ID passed to display help
//
//  Returns:    none
//
//+---------------------------------------------------------------------------

void HelpWmHelp(LPHELPINFO pHelpInfo, const DWORD* pHelpIDs)
{
     if (pHelpInfo != NULL)
    {
        if (pHelpInfo->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            ASSERT(pHelpIDs != NULL);
            if (pHelpIDs)
            {
                ::WinHelp((HWND)pHelpInfo->hItemHandle, GetHelpFile(),
                          HELP_WM_HELP, (ULONG_PTR)(LPVOID)pHelpIDs);

            }
        }
    }
}

/*+-------------------------------------------------------------------------*
 *
 * HelpContextMenuHelp
 *
 * PURPOSE: Handle context menu help. Invoked when the user right-clicks
 *          on a dialog item and selects "What's this?"
 *
 * PARAMETERS:
 *    HWND       hWnd :
 *    ULONG_PTR  p :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void HelpContextMenuHelp(HWND hWnd, ULONG_PTR p)
{
    ::WinHelp (hWnd, GetHelpFile(), HELP_CONTEXTMENU, p);
}

/*+-------------------------------------------------------------------------*
 * InflateFont
 *
 * Inflates a LOGFONT by the a given number of points
 *--------------------------------------------------------------------------*/

bool InflateFont (LOGFONT* plf, int nPointsToGrowBy)
{
    if (nPointsToGrowBy != 0)
    {
        HDC hdc = GetWindowDC (NULL);

        if (hdc == NULL)
            return (FALSE);

        int nLogPixelsY = GetDeviceCaps (hdc, LOGPIXELSY);
        int nPoints     = -MulDiv (plf->lfHeight, 72, nLogPixelsY);
        nPoints        += nPointsToGrowBy;
        plf->lfHeight   = -MulDiv (nPoints, nLogPixelsY, 72);

        ReleaseDC (NULL, hdc);
    }

    return (true);
}

//+-------------------------------------------------------------------
//
//  Member:     GetTBBtnTextAndStatus
//
// Synopsis:   Helper routine to get one/two part button text resource.
//
//  Arguments:  [hInst]       - Instance handle.
//              [nID]         - String resource id.
//              [ppszButton]  - Button text.
//              [ppszToolTip] - Button status text.
//
//  Note:       Uses MFC CString.
//
//  Returns:    bool
//
//--------------------------------------------------------------------
bool GetTBBtnTextAndStatus(HINSTANCE hInst, int nID, std::wstring& szButton, std::wstring& szToolTip)
{
    USES_CONVERSION;

    CStr str;
    str.LoadString(hInst, nID);
    ASSERT(!str.IsEmpty());

    if (str.IsEmpty())
        return false;

    int iPos = str.Find(_T('\n'));
    if (-1 != iPos)
    {
        // Two strings. First from 0 to iPos-1
        // and second from iPos+1 to end.
        szButton = T2CW((LPCTSTR)str.Left(iPos));
        szToolTip = T2CW((LPCTSTR)str.Right(str.GetLength() - iPos - 1));
    }
    else
    {
        szButton = (LPCWSTR) NULL;
        LPCTSTR pszStr = (LPCTSTR)str;

        if (NULL != pszStr)
        {
            szButton = T2CW(pszStr);
        }

        szToolTip = szButton;
    }

    return true;
}


#ifdef DBG

/*+-------------------------------------------------------------------------*
 * DrawOnDesktop
 *
 * Draws a bitmap, icon, or imagelist to a specific location on the desktop.
 *--------------------------------------------------------------------------*/

void DrawOnDesktop (HBITMAP hbm, int x, int y)
{
	HDC hdcDesktop = GetWindowDC (NULL);
	HDC hdcMem = CreateCompatibleDC (NULL);

	BITMAP bm;
	GetObject ((HGDIOBJ) hbm, sizeof(bm), &bm);
	HGDIOBJ hbmOld = SelectObject (hdcMem, (HGDIOBJ) hbm);
	BitBlt (hdcDesktop, x, y, bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);
	SelectObject (hdcMem, hbmOld);

	DeleteDC  (hdcMem);
	ReleaseDC (NULL, hdcDesktop);
}


void DrawOnDesktop (HICON hIcon, int x, int y)
{
	HDC hdcDesktop = GetWindowDC (NULL);
	DrawIconEx (hdcDesktop, x, y, hIcon, 0, 0, 0, NULL, DI_NORMAL);
	ReleaseDC (NULL, hdcDesktop);
}


void DrawOnDesktop (HIMAGELIST himl, int x, int y, int iImage /*=-1*/)
{
	HDC hdcDesktop = GetWindowDC (NULL);

	/*
	 * draw all images?
	 */
	if (iImage == -1)
	{
		int cImages = ImageList_GetImageCount (himl);
		int cxImage, cyImage;
		ImageList_GetIconSize (himl, &cxImage, &cyImage);

		for (int i = 0; i < cImages; i++, x += cxImage)
		{
			ImageList_Draw (himl, i, hdcDesktop, x, y, ILD_NORMAL);
		}
	}
	else
	{
		/*
		 * draw a specific image
		 */
		ImageList_Draw (himl, iImage, hdcDesktop, x, y, ILD_NORMAL);
	}

	ReleaseDC (NULL, hdcDesktop);
}

#endif	// DBG


/*+-------------------------------------------------------------------------*
 * StripTrailingWhitespace
 *
 * Removes the whitespace at the end of the input string.  Returns a pointer
 * the the beginning of the string.
 *--------------------------------------------------------------------------*/

LPTSTR StripTrailingWhitespace (LPTSTR pszStart)
{
    for (LPTSTR pch = pszStart + _tcslen(pszStart) - 1; pch > pszStart; pch--)
    {
        /*
         * if this isn't a whitespace character, terminate just after this position
         */
        if (!_istspace (*pch))
        {
            *++pch = 0;
            break;
        }
    }

    return (pszStart);
}

/***************************************************************************\
 *
 * METHOD:  PrivateSetLayout
 *
 * PURPOSE: Wrapper to invoke GDI function when it is available,
 *			but not to depend on its availability
 *
 * PARAMETERS:
 *    HDC hdc
 *    DWORD dwLayout
 *
 * RETURNS:
 *    DWORD    - previous layout, GDI_ERROR on error
 *
\***************************************************************************/
DWORD PrivateSetLayout( HDC hdc, DWORD dwLayout )
{
	// static pointer to function
	static BOOL (WINAPI* pfnSetLayout)(HDC, DWORD) = NULL;
	static bool bTriedToGetFunction = false;

	if ( !bTriedToGetFunction )
	{
		bTriedToGetFunction = true;
		HINSTANCE hmodGdi = GetModuleHandle (_T("Gdi32.dll"));

		if (hmodGdi != NULL)
			(FARPROC&)pfnSetLayout = GetProcAddress (hmodGdi, "SetLayout");
	}

    if (pfnSetLayout == NULL)
		return GDI_ERROR;

	return (*pfnSetLayout)(hdc, dwLayout);
}

/***************************************************************************\
 *
 * METHOD:  PrivateGetLayout
 *
 * PURPOSE: Wrapper to invoke GDI function when it is available,
 *			but not to depend on its availability
 *
 * PARAMETERS:
 *    HDC hdc
 *
 * RETURNS:
 *    DWORD    - layout, 0 if function not found
 *
\***************************************************************************/
DWORD PrivateGetLayout( HDC hdc )
{
	// static pointer to function
	static BOOL (WINAPI* pfnGetLayout)(HDC) = NULL;
	static bool bTriedToGetFunction = false;

	if ( !bTriedToGetFunction )
	{
		bTriedToGetFunction = true;
		HINSTANCE hmodGdi = GetModuleHandle (_T("Gdi32.dll"));

		if (hmodGdi != NULL)
			(FARPROC&)pfnGetLayout = GetProcAddress (hmodGdi, "GetLayout");
	}

    if (pfnGetLayout == NULL)
		return 0; // at least not LAYOUT_RTL

	return (*pfnGetLayout)(hdc);
}


/*+-------------------------------------------------------------------------*
 * IsWhistler
 *
 * Returns true if we're running on Whistler or higher, false otherwise.
 *--------------------------------------------------------------------------*/
bool IsWhistler ()
{
	static bool fFirstTime = true;
	static bool fWhistler  = false;

	if (fFirstTime)
	{
		fFirstTime = false;

		OSVERSIONINFO vi;
		vi.dwOSVersionInfoSize = sizeof(vi);
		GetVersionEx (&vi);

		fWhistler = (vi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
					((vi.dwMajorVersion >  5) ||
					 (vi.dwMajorVersion == 5) && (vi.dwMinorVersion >= 1));
	}

	return (fWhistler);
}


/*+-------------------------------------------------------------------------*
 * WriteCompatibleImageList
 *
 * Writes an imagelist to a stream in a format that's guaranteed to be
 * compatible with comctl32 version 5 imagelists.
 *--------------------------------------------------------------------------*/
HRESULT WriteCompatibleImageList (HIMAGELIST himl, IStream* pstm)
{
	/*
	 * If we're running on Whistler, we might be trying to write a v6
	 * imagelist.  Try to write it in a v5-compatible format with
	 * ImageList_WriteEx.
	 */
	if (IsWhistler())
	{
		/*
		 * ImageList_WriteEx will return E_NOINTERFACE if we're actually
		 * writing a v5 imagelist, in which case we want to write with
		 * ImageList_Write.  In any other case (success or failure), we
		 * just want to return.
		 */
		HRESULT hr = ImageList_WriteEx (himl, ILP_DOWNLEVEL, pstm);
		if (hr != E_NOINTERFACE)
			return (hr);
	}

	/*
	 * if we get here, we have a v5 imagelist -- just write it
	 */
	return (ImageList_Write (himl, pstm));
}


/*+-------------------------------------------------------------------------*
 * ReadCompatibleImageList
 *
 * Reads an imagelist from a stream that's in version 5 format.
 *--------------------------------------------------------------------------*/
HRESULT ReadCompatibleImageList (IStream* pstm, HIMAGELIST& himl)
{
	HRESULT hr = S_OK;

	/*
	 * init the out parameter
	 */
	himl = NULL;

	/*
	 * If we're running on Whistler, we're trying to create a v6
	 * imagelist from the stream.  Do it in a v5-compatible manner
	 * with ImageList_ReadEx.
	 */
	if (IsWhistler())
	{
		/*
		 * HACK:  We have to query ImageList_ReadEx for IID_IImageList -- the
		 * one defined by the shell, not the one defined by MMC.  If we
		 * just refer to "IID_IImageList" in the code here, we'll get MMC's
		 * version, not the shell's.  The right way to fix it is to rename
		 * the shell's IImageList interface (since MMC's interface was defined
		 * and published first), but that's not going to happen.
		 *
		 * We'll hardcode the IID's value in a string here and convert it
		 * to an IID on the fly.  Ugh.
		 */
		IID iidShellImageList = {0};
		hr = CLSIDFromString (L"{46eb5926-582e-4017-9fdf-e8998daa0950}", &iidShellImageList);
		if (FAILED (hr))
			return (hr);

		/*
		 * ImageList_ReadEx will return E_NOINTERFACE if we're actually
		 * writing a v5 imagelist, in which case we want to write with
		 * ImageList_Write.  In any other case (success or failure), we
		 * just want to return.
		 */
		IUnknownPtr spUnk;
		hr = ImageList_ReadEx (ILP_DOWNLEVEL, pstm, iidShellImageList, (void**) &spUnk);
		if (FAILED (hr))
			return (hr);

		/*
		 * The IUnknown *is* the HIMAGELIST.  Don't release it here,
		 * ImageList_Destroy will take care of it.
		 */
		himl = reinterpret_cast<HIMAGELIST>(spUnk.Detach());
	}
	else
	{
		/*
		 * non-Whistler, just read it normally
		 */
		himl = ImageList_Read (pstm);

		/*
		 * If the read failed, get the last error.  Just in case ImageList_Read
		 * didn't set the last error, make sure we return a failure code.
		 */
		if (himl == NULL)
		{
			hr = HRESULT_FROM_WIN32 (GetLastError());
			if (!FAILED (hr))
				hr = E_FAIL;
		}
	}

	return (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     MmcDownlevelActivateActCtx
//
//  Synopsis:   Calls ActivateActCtx to set the activation context to V5
//              common controls. This is needed before calling into snapins
//              so that snapin created windows are not themed accidentally.
//
//              The snapin can theme its windows by calling appropriate
//              fusion apis while calling create-window.
//
// Description:
//              When MMC calls into the snapin if the last winproc which
//              received a window message is themed and will result in a
//              call to snapin then we will call the snapin in themed
//              context. If snapin creates & displays any UI then it will
//              be themed. This function is to de-activate the theming
//              before calling the snapin.
//
//  Arguments:
//              [hActCtx]    - 	See ActivateActCtx API details
//              [pulCookie]  -  See ActivateActCtx API details
//
//  Returns:    BOOL, TRUE if we could de-activate V6 context and switch to V5 context
//                         or if we are in V5 context (W2K, Win95, Win98...)
//                    FALSE if ActivateActCtx returns failure.
//
//--------------------------------------------------------------------
BOOL WINAPI MmcDownlevelActivateActCtx(HANDLE hActCtx, ULONG_PTR* pulCookie) 
{
    typedef BOOL (WINAPI* PFN)(HANDLE hActCtx, ULONG_PTR* pulCookie);
    static PFN s_pfn;
    static DWORD s_dwError;

    if (s_pfn == NULL && s_dwError == 0)
        if ((s_pfn = (PFN)GetProcAddress(GetModuleHandleA("Kernel32.dll"), "ActivateActCtx")) == NULL)
            s_dwError = (GetLastError() == NO_ERROR) ? ERROR_INTERNAL_ERROR : GetLastError();

    if (s_pfn != NULL)
        return s_pfn(hActCtx, pulCookie);

    SetLastError(s_dwError);

	if (s_dwError == ERROR_PROC_NOT_FOUND)
		return TRUE;

    return FALSE;
}


//+-------------------------------------------------------------------
//
//  Member:     MmcDownlevelDeactivateActCtx
//
//  Synopsis:   Calls DeactivateActCtx to restore the activation context.
//              This is needed after calling into snapins, so that
//              if we called from themed context then it is restored.
//
// Description:
//              When MMC calls into the snapin if the last winproc which
//              received a window message is themed and will result in a
//              call to snapin then we will call the snapin in themed
//              context. If snapin creates & displays any UI then it will
//              be themed. This function is to de-activate the theming
//              before calling the snapin.
//
//  Arguments:
//              [dwFlags]   -  See DeactivateActCtx API details
//              [ulCookie]  -  See DeactivateActCtx API details
//
//  Returns:    None
//
//--------------------------------------------------------------------
VOID WINAPI MmcDownlevelDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie) 
{
    typedef VOID (WINAPI* PFN)(DWORD dwFlags, ULONG_PTR ulCookie);
    static PFN s_pfn;
    static BOOL s_fInited;

    if (!s_fInited)
        s_pfn = (PFN)GetProcAddress(GetModuleHandleA("Kernel32.dll"), "DeactivateActCtx");

    s_fInited = TRUE;

    if (s_pfn != NULL)
        s_pfn(dwFlags, ulCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\viewset.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      viewset.cpp
 *
 *  Contents:  Implements CViewSettings.
 *
 *  History:   21-April-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/
#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include "serial.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include "ndmgr.h"
#include <string>
#include "atlbase.h"
#include "cstr.h"
#include "xmlbase.h"
#include "resultview.h"
#include "viewset.h"
#include "countof.h"
//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>

CViewSettings::CViewSettings()
: m_ulViewMode(0), m_guidTaskpad(GUID_NULL),
  m_dwRank(-1), m_bInvalid(FALSE), m_dwMask(0)
{
}


bool
CViewSettings::IsViewModeValid()    const
{
    return ( (m_RVType.HasList()) &&
             (m_dwMask & VIEWSET_MASK_VIEWMODE) );
}

bool
CViewSettings::operator == (const CViewSettings& viewSettings)
{
    if (m_dwMask != viewSettings.m_dwMask)
    {
        return false;
    }

    if (IsViewModeValid() &&
        (m_ulViewMode != viewSettings.m_ulViewMode) )
    {
        return false;
    }

    if (IsTaskpadIDValid() &&
        (m_guidTaskpad != viewSettings.m_guidTaskpad))
    {
        return false;
    }

    if (IsResultViewTypeValid() &&
        (m_RVType != viewSettings.m_RVType))
    {
        return false;
    }

    return true;
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScInitialize
//
//  Synopsis:    Private member to read 1.2 console files and init
//               the object.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScInitialize(bool  bViewTypeValid, const VIEW_TYPE& viewType, const long lViewOptions, const wstring& wstrViewName)
{
    DECLARE_SC(sc, _T("CViewSettings::ScInitialize"));

    LPOLESTR pViewName = NULL;
    if (wstrViewName.length() > 0)
    {
        int cchViewName = (wstrViewName.length() + 1);
        pViewName = (LPOLESTR) CoTaskMemAlloc(cchViewName * sizeof(OLECHAR));
        sc = ScCheckPointers(pViewName);
        if(sc)
            return sc;
        sc = StringCchCopyW(pViewName, cchViewName, wstrViewName.data());
        if(sc)
            return sc;
    }

	sc = m_RVType.ScInitialize(pViewName, lViewOptions);
	if (sc)
		return sc;

	SetResultViewTypeValid( bViewTypeValid );

	if ( bViewTypeValid )
	{
		// Now put these data in CViewSettings.
		switch(viewType)
		{
		case VIEW_TYPE_OCX:
		case VIEW_TYPE_WEB:
			break;

		case VIEW_TYPE_DEFAULT:
			// What is this?
			ASSERT(FALSE);
			break;

		case VIEW_TYPE_LARGE_ICON:
			m_ulViewMode = MMCLV_VIEWSTYLE_ICON;
			SetViewModeValid();
			break;

		case VIEW_TYPE_SMALL_ICON:
			m_ulViewMode = MMCLV_VIEWSTYLE_SMALLICON;
			SetViewModeValid();
			break;

		case VIEW_TYPE_REPORT:
			m_ulViewMode = MMCLV_VIEWSTYLE_REPORT;
			SetViewModeValid();
			break;

		case VIEW_TYPE_LIST:
			m_ulViewMode = MMCLV_VIEWSTYLE_LIST;
			SetViewModeValid();
			break;

		case VIEW_TYPE_FILTERED:
			m_ulViewMode = MMCLV_VIEWSTYLE_FILTERED;
			SetViewModeValid();
			break;

		default:
			// Should never come here.
			ASSERT(FALSE);
			break;
		}
	}

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Reads the given version of CViewSettings from stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - version of CColumnSortInfo to be read.
//
//                          The format is :
//                              VIEW_TYPE
//                              View Options
//                              String (If VIEW_TYPE is OCX or Web).
//
//--------------------------------------------------------------------
HRESULT CViewSettings::ReadSerialObject(IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume unknown version

    if  ( (4 <= nVersion))
    {
        try
        {
            VIEW_TYPE viewType;
            long      lViewOptions;

            // ugly hackery required to extract directly into an enum
            stm >> *((int *) &viewType);
            stm >> lViewOptions;

            wstring wstrViewName;

            if( (VIEW_TYPE_OCX==viewType) || (VIEW_TYPE_WEB==viewType) )
                stm >> wstrViewName;

            if(2<=nVersion)             // taskpads were added in version 2 of this object.
            {
                stm >> m_guidTaskpad;
                SetTaskpadIDValid(GUID_NULL != m_guidTaskpad);
            }

            if (3<=nVersion)
                stm >> m_dwRank;

            DWORD dwMask = 0;
			bool bViewTypeValid = true;
            if (4 <= nVersion)
			{
                stm >> dwMask;

				const DWORD MMC12_VIEWSET_MASK_TYPE        = 0x0001;
				bViewTypeValid = ( dwMask & MMC12_VIEWSET_MASK_TYPE );
			}

            hr = ScInitialize(bViewTypeValid, viewType, lViewOptions, wstrViewName).ToHr();
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CViewSettings::Persist
//
//  Synopsis:   persist to / from XML document.
//
//  Arguments:  [persistor]  - target or source.
//
//--------------------------------------------------------------------
void CViewSettings::Persist(CPersistor& persistor)
{
    // First Load or Save the mask. (Mask tells which members are valid).

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedMasks[] =
    {
        { VIEWSET_MASK_VIEWMODE,        XML_BITFLAG_VIEWSET_MASK_VIEWMODE },
        { VIEWSET_MASK_RVTYPE,          XML_BITFLAG_VIEWSET_MASK_RVTYPE },
        { VIEWSET_MASK_TASKPADID,       XML_BITFLAG_VIEWSET_MASK_TASKPADID },
    };

    // create wrapper to persist flag values as strings
    CXMLBitFlags maskPersistor(m_dwMask, mappedMasks, countof(mappedMasks));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_MASK, maskPersistor);

    if (IsTaskpadIDValid())
        persistor.Persist(m_guidTaskpad);

	// it is important to load this first - IsViewModeValid() uses m_RVType
	// see windows bug #496964 (11/20/2001)
    if (persistor.IsLoading() && IsResultViewTypeValid())
        // Call CResultViewType to persist itself.
        persistor.Persist(m_RVType);

    if (IsViewModeValid())
    {
        // define the table to map enumeration values to strings
        static const EnumLiteral mappedModes[] =
        {
            { MMCLV_VIEWSTYLE_ICON,         XML_ENUM_LV_STYLE_ICON },
            { MMCLV_VIEWSTYLE_SMALLICON,    XML_ENUM_LV_STYLE_SMALLICON },
            { MMCLV_VIEWSTYLE_LIST,         XML_ENUM_LV_STYLE_LIST },
            { MMCLV_VIEWSTYLE_REPORT,       XML_ENUM_LV_STYLE_REPORT },
            { MMCLV_VIEWSTYLE_FILTERED,     XML_ENUM_LV_STYLE_FILTERED },
        };

        // create wrapper to persist flag values as strings
        CXMLEnumeration modePersistor(m_ulViewMode, mappedModes, countof(mappedModes));
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_VIEW_SETNGS_VIEW_MODE, modePersistor);
    }

    if (persistor.IsStoring() && IsResultViewTypeValid())
        // Call CResultViewType to persist itself.
        persistor.Persist(m_RVType);

    bool bPeristRank = true;
    if (persistor.IsLoading())
        m_dwRank = (DWORD)-1; // make sure it's initialized if fails to load
    else
        bPeristRank = (m_dwRank != (DWORD)-1); // persist only if is used

    if (bPeristRank)
        persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_RANK, m_dwRank, attr_optional);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScGetViewMode
//
//  Synopsis:    Gets the view mode in list view.
//
//  Arguments:   [ulViewMode] - New view mode.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScGetViewMode (ULONG& ulViewMode)
{
    SC sc;

    if (!IsViewModeValid())
        return (sc = E_FAIL);

    ulViewMode = m_ulViewMode;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScSetViewMode
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScSetViewMode (const ULONG ulViewMode)
{
    SC sc;

    m_ulViewMode = ulViewMode;
    SetViewModeValid();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScGetTaskpadID
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScGetTaskpadID (GUID& guidTaskpad)
{
    SC sc;

    if (! IsTaskpadIDValid())
        return (sc = E_FAIL);

    guidTaskpad = m_guidTaskpad;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScSetTaskpadID
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScSetTaskpadID (const GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CViewSettings::ScSetTaskpadID"));

    m_guidTaskpad = guidTaskpad;
	SetTaskpadIDValid(true);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScGetResultViewType
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScGetResultViewType (CResultViewType& rvt)
{
    SC sc;

    if (! IsResultViewTypeValid())
        return (sc = E_FAIL);

    rvt = m_RVType;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScSetResultViewType
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScSetResultViewType (const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CViewSettings::ScSetResultViewType"));

    m_RVType = rvt;
    SetResultViewTypeValid();

    // ResultViewType changes, if new result-pane contains list use
    // current view mode if one exists else invalidate view mode data.
	if (!rvt.HasList())
	    SetViewModeValid(false);

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\xmlicon.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlicon.cpp
 *
 *  Contents:  Implementation file for CXMLIcon
 *
 *  History:   26-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "xmlicon.h"
#include "xmlimage.h"
#include <atlapp.h>
#include <atlgdi.h>


/*+-------------------------------------------------------------------------*
 * ScGetIconSize
 *
 * Returns the width/height of a given icon (the width and height of icons
 * are always equal).
 *--------------------------------------------------------------------------*/

SC ScGetIconSize (HICON hIcon, int& nIconSize)
{
	DECLARE_SC (sc, _T("ScGetIconSize"));

	ICONINFO ii;
	if (!GetIconInfo (hIcon, &ii))
		return (sc.FromLastError());

	/*
	 * GetIconInfo creates bitmaps that we're responsible for deleting;
	 * attach the bitmaps to smart objects so cleanup is assured
	 */
	WTL::CBitmap bmMask  = ii.hbmMask;
	WTL::CBitmap bmColor = ii.hbmColor;

	/*
	 * get the dimensions of the mask bitmap (don't use the color bitmap,
	 * since that's not present for monochrome icons)
	 */
	BITMAP bmData;
	if (!bmMask.GetBitmap (bmData))
		return (sc.FromLastError());

	nIconSize = bmData.bmWidth;
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CXMLIcon::Persist
 *
 * Saves/loads a CXMLIcon to a CPersistor.
 *--------------------------------------------------------------------------*/

void CXMLIcon::Persist (CPersistor &persistor)
{
	DECLARE_SC (sc, _T("CXMLIcon::Persist"));

	CXMLImageList iml;

	try
	{
		if (persistor.IsStoring())
		{
			ASSERT (operator HICON() != NULL);

			/*
			 * find out how big the icon is
			 */
			int cxIcon;
			sc = ScGetIconSize (*this, cxIcon);
			if (sc)
				sc.Throw();

			/*
			 * create an imagelist to accomodate it
			 */
			if (!iml.Create (cxIcon, cxIcon, ILC_COLOR16 | ILC_MASK, 1, 1))
				sc.FromLastError().Throw();

			/*
			 * add the icon to the imagelist
			 */
			if (iml.AddIcon(*this) == -1)
				sc.FromLastError().Throw();
		}

		iml.Persist (persistor);

		if (persistor.IsLoading())
		{
			/*
			 * extract the icon from the imagelist
			 */
			Attach (iml.GetIcon (0));
		}
	}
	catch (...)
	{
		/*
		 * WTL::CImageList doesn't auto-destroy its HIMAGELIST, so we have to do it manually
		 */
		iml.Destroy();
		throw;
	}

	/*
	 * WTL::CImageList doesn't auto-destroy its HIMAGELIST, so we have to do it manually
	 */
	iml.Destroy();
}


/*+-------------------------------------------------------------------------*
 * CXMLIcon::GetBinaryEntryName
 *
 * Returns the name to be attached to this CXMLIcon's entry in the XML
 * binary data collection.
 *--------------------------------------------------------------------------*/

LPCTSTR CXMLIcon::GetBinaryEntryName()			
{
	if (m_strBinaryEntryName.empty())
		return (NULL);

	return (m_strBinaryEntryName.data());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\xmlimage.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlimage.cpp
 *
 *  Contents:  Implementation file for CXMLImageList
 *
 *  History:   10-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "xmlimage.h"
#include "util.h"


/*+-------------------------------------------------------------------------*
 * CXMLImageList::Persist
 *
 * Saves/loads a CXMLImageList to a CPersistor.
 *--------------------------------------------------------------------------*/

void CXMLImageList::Persist (CPersistor &persistor)
{
	DECLARE_SC (sc, _T("CXMLImageList::Persist"));

    // try to get IStream first, to avoid cleanup if it fails [and throws] (audriusz)
    CXML_IStream xmlStream;

    if (persistor.IsStoring())
    {
        ASSERT (!IsNull());

		/*
		 * write the imagelist to the stream
		 */
        IStreamPtr spStream;
        sc = xmlStream.ScGetIStream( &spStream );
        if (sc)
            sc.Throw();

        sc = WriteCompatibleImageList (m_hImageList, spStream);
        if (sc)
            sc.Throw();
    }

    xmlStream.Persist (persistor);

    if (persistor.IsLoading())
    {
		/*
		 * get rid of the imagelist that's there, if any
		 */
		Destroy();
		ASSERT (IsNull());

		/*
		 * reconstitute the imagelist from the stream
		 */
        IStreamPtr spStream;
        sc = xmlStream.ScGetIStream( &spStream );
        if (sc)
            sc.Throw();

        sc = ReadCompatibleImageList (spStream, m_hImageList);
        if (sc)
            sc.Throw();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\xmlbase.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <hlink.h>
#include <dispex.h>
#include "mshtml.h"
#include "msxml.h"
#include <winnls.h>
#include "atlbase.h" // USES_CONVERSION
#include "dbg.h"
#include "..\inc\cstr.h"
#include "macros.h"
#include <comdef.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <map>
#include <list>
#include <vector>
#include "mmcdebug.h"
#include "mmcerror.h"
#include "..\inc\xmlbase.h"
#include "countof.h"
#include <commctrl.h>
#include "picon.h"
#include "base64.h"
#include "strings.h"
#include "autoptr.h"
#include <shlobj.h>
#include "zlib.h"
#include "xmlicon.h"
//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>

SC ScEncodeBinary(CComBSTR& bstrResult, const CXMLBinary& binSrc);
SC ScDecodeBinary(const CComBSTR& bstrSource, CXMLBinary *pBinResult);
SC ScSaveXMLDocumentToString(CXMLDocument& xmlDocument, std::wstring& strResult);

// Traces
#ifdef DBG
CTraceTag tagXMLCompression(TEXT("Console Files"), TEXT("Compression"));
#endif


//############################################################################
//############################################################################
//
//  helper classes used in this file
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CXMLBinaryValue
 *
 * PURPOSE: Persists the contents of XMLValue on binary storage
 *          It's a simle wrapper needed to inform CPersistor about
 *          values wish to be persisted on Binary storage
 *          [see comment "CONCEPT OF BINARY STORAGE" in "xmbase.h"]
 *
 *+-------------------------------------------------------------------------*/
class CXMLBinaryValue : public CXMLObject
{
    CXMLValue m_xval;
public:
    CXMLBinaryValue(CXMLValue xval) : m_xval(xval) {}
    virtual LPCTSTR GetXMLType() { return m_xval.GetTypeName(); }
    virtual void Persist(CPersistor &persistor)
    {
        persistor.PersistContents (m_xval);
    }
    virtual bool    UsesBinaryStorage() { return true; }
};

//############################################################################
//############################################################################
//
//  Implementation of class CXMLElementCollection
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CXMLElementCollection::get_count
 *
 * PURPOSE: // returns count of elements in the collection
 *
 * PARAMETERS:
 *    long *plLength    [out] - count of the elements
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElementCollection::get_count(long *plCount)
{
    DECLARE_SC(sc, TEXT("CXMLElementCollection::get_count"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    sc = m_sp->get_length(plCount);
    if (sc)
        sc.Throw();
}


/***************************************************************************\
 *
 * METHOD:  CXMLElementCollection::item
 *
 * PURPOSE: wraps item method from IXMLDOMNodeList
 *
 * PARAMETERS:
 *    VARIANT Var1          [in] parameter #1
 *    VARIANT Var2          [in] parameter #2
 *    CXMLElement *pElem    [out] resulting element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElementCollection::item(LONG lIndex, CXMLElement *pElem)
{
    DECLARE_SC(sc, TEXT("CXMLElementCollection::item"));

    // check params
    sc = ScCheckPointers(pElem);
    if (sc)
        sc.Throw();

    // init ret val
    *pElem = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spNode;
    sc = m_sp->get_item(lIndex , &spNode);
    if(sc)
        sc.Throw();

    // return the object
    *pElem = CXMLElement(spNode);
}

//############################################################################
//############################################################################
//
//  Implementation of class CXMLElement
//
//############################################################################
//############################################################################
/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_tagName
 *
 * PURPOSE: returns tag name of the element
 *
 * PARAMETERS:
 *    CStr &strTagName  [out] element's name
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_tagName(CStr &strTagName)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_tagName"));

    USES_CONVERSION;

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR bstr;
    sc = spEl->get_tagName(&bstr);
    if(sc)
        sc.Throw();
    strTagName=OLE2T(bstr);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_parent
 *
 * PURPOSE: returns parent element
 *
 * PARAMETERS:
 *    CXMLElement * pParent - [out] parent element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_parent(CXMLElement * pParent)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_parent"));

    // parameter check
    sc = ScCheckPointers(pParent);
    if (sc)
        sc.Throw();

    // init return value
    *pParent = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spParent;
    sc = m_sp->get_parentNode(&spParent);
    if(sc)
        sc.Throw();

    *pParent = CXMLElement(spParent);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::setAttribute
 *
 * PURPOSE: assigns attribute to the element
 *
 * PARAMETERS:
 *    const CStr &strPropertyName       - attribute name
 *    const CComBSTR &bstrPropertyValue - attribute value
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::setAttribute(const CStr &strPropertyName, const CComBSTR &bstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CXMLElement::setAttribute"));

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR bstrPropertyName (strPropertyName);
    CComVariant varPropertyValue(bstrPropertyValue);
    sc = spEl->setAttribute(bstrPropertyName, varPropertyValue);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::getAttribute
 *
 * PURPOSE: gets attribute from element
 *
 * PARAMETERS:
 *    const CStr &strPropertyName   - [in] attribute name
 *    CComBSTR &bstrPropertyValue   - [out] attribute value
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
bool
CXMLElement::getAttribute(const CStr &strPropertyName,       CComBSTR &bstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CXMLElement::getAttribute"));

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR    bstrPropertyName (strPropertyName);
    CComVariant varPropertyValue;
    sc = spEl->getAttribute(bstrPropertyName, &varPropertyValue);
    if(sc) // no resuls cannot be read either
        sc.Throw();

    if (sc.ToHr() == S_FALSE)
        return false;

    // check if we've got the expected value type
    if ( varPropertyValue.vt != VT_BSTR )
        sc.Throw( E_UNEXPECTED );

    bstrPropertyValue = varPropertyValue.bstrVal;

    return true;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::removeAttribute
 *
 * PURPOSE: removes attribute from the elament
 *
 * PARAMETERS:
 *    const CStr &strPropertyName   - [in] atrtibute name
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::removeAttribute(const CStr &strPropertyName)
{
    DECLARE_SC(sc, TEXT("CXMLElement::removeAttribute"));

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR    bstrPropertyName (strPropertyName);
    sc = spEl->removeAttribute(bstrPropertyName);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_children
 *
 * PURPOSE: returns collection of children which belong to element
 *
 * PARAMETERS:
 *    CXMLElementCollection *pChildren - [out] collection
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_children(CXMLElementCollection *pChildren)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_children"));

    sc = ScCheckPointers(pChildren);
    if (sc)
        sc.Throw();

    // init ret value
    *pChildren = CXMLElementCollection();
    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNodeList> spChildren;
    sc = m_sp->get_childNodes(&spChildren);
    if(sc)
        sc.Throw();

    // return the object
    *pChildren = CXMLElementCollection(spChildren);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_type
 *
 * PURPOSE: returns the type of the element
 *
 * PARAMETERS:
 *    long *plType  - [out] element's type
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_type(DOMNodeType *pType)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_type"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    sc = m_sp->get_nodeType(pType);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_text
 *
 * PURPOSE: retrieves contents of the text element
 *          NOTE: it only works for text elements!
 *
 * PARAMETERS:
 *    CComBSTR &bstrContent - storage for resulting string
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_text(CComBSTR &bstrContent)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_text"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    bstrContent.Empty();
    sc = m_sp->get_text(&bstrContent);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::addChild
 *
 * PURPOSE: adds the new child element to current element
 *
 * PARAMETERS:
 *    CXMLElement& rChildElem   [in] element to become a child
 *    long lIndex               [in] index for new element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::addChild(CXMLElement& rChildElem)
{
    DECLARE_SC(sc, TEXT("CXMLElement::addChild"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spCreated;
    sc = m_sp->appendChild(rChildElem.m_sp, &spCreated);
    if(sc)
        sc.Throw();

    rChildElem.m_sp = spCreated;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::removeChild
 *
 * PURPOSE: removes child element
 *
 * PARAMETERS:
 *    CXMLElement& rChildElem   - [in] child to remove
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::removeChild(CXMLElement& rChildElem)
{
    DECLARE_SC(sc, TEXT("CXMLElement::removeChild"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spRemoved;
    sc = m_sp->removeChild(rChildElem.m_sp, &spRemoved);
    if(sc)
        sc.Throw();

    rChildElem.m_sp = spRemoved;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::GetTextIndent
 *
 * PURPOSE: returns indentation for the child element \ closing tag
 *          Indentation is calulated by element depth in the tree
 *
 * PARAMETERS:
 *    CComBSTR& bstrIndent   [out] string conatining required indent
 *    bool bForAChild       [in]  if the indent is for a child
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
bool CXMLElement::GetTextIndent(CComBSTR& bstrIndent, bool bForAChild)
{
    DECLARE_SC(sc, TEXT("CXMLElement::GetTextIndent"));

    const size_t nIdentStep = 2;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    // initialize the result
    bstrIndent.Empty();


    CComPtr<IXMLDOMNode> spNext;
    CComPtr<IXMLDOMNode> spParent;

    // calculate node depth
    int nNodeDepth = 0;
    spNext = m_sp;
    while ( S_OK == spNext->get_parentNode(&spParent) && spParent != NULL)
    {
        ++nNodeDepth;
        spNext = spParent;
        spParent.Release();
    }

    // no indent for topmost things
    if (nNodeDepth < 1)
        return false;

    // do not count root node - not ours
    --nNodeDepth;

    // child is indented more
    if (bForAChild)
        ++nNodeDepth;

    if (bForAChild)
    {
        // it may already have indent for the closing tag (if its' not the first element)
        // than we just need a little increase

        // see if the we have child elements added;
        CXMLElementCollection colChildren;
        get_children(&colChildren);

        // count all elements
        long nChildren = 0;
        if (!colChildren.IsNull())
            colChildren.get_count(&nChildren);

        // we will have at least 2 for normal elements
        // since the indent (text element) will be added prior to the first one
        if (nChildren > 1)
        {
            bstrIndent = std::wstring( nIdentStep, ' ' ).c_str();
            return true;
        }
    }

    std::wstring strResult(nIdentStep * (nNodeDepth) + 1/*for new line*/, ' ');
    // new line for each (1st) new item
    strResult[0] = '\n';
    bstrIndent = strResult.c_str();

    return true;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::replaceChild
 *
 * PURPOSE: replaces the element with the new on
 *
 * PARAMETERS:
 *    CXMLElement& rNewChildElem    [in] new element
 *    CXMLElement& rOldChildElem    [in/out] old element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLElement::replaceChild(CXMLElement& rNewChildElem, CXMLElement& rOldChildElem)
{
    DECLARE_SC(sc, TEXT("CXMLElement::replaceChild"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    // forward to MSXML
    CComPtr<IXMLDOMNode> spRemoved;
    sc = m_sp->replaceChild(rNewChildElem.m_sp, rOldChildElem.m_sp, &spRemoved);
    if (sc)
        sc.Throw();

    rOldChildElem = CXMLElement(spRemoved);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::getNextSibling
 *
 * PURPOSE: returns sibling to this element
 *
 * PARAMETERS:
 *    CXMLElement * pNext [out] sibling element
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CXMLElement::getNextSibling(CXMLElement * pNext)
{
    DECLARE_SC(sc, TEXT("CXMLElement::getNextSibling"));

    // parameter check;
    sc = ScCheckPointers(pNext);
    if (sc)
        sc.Throw();

    // initialization
    *pNext = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    // forward to MSXML
    CComPtr<IXMLDOMNode> spNext;
    sc = m_sp->get_nextSibling(&spNext);
    if (sc)
        sc.Throw();

    *pNext = CXMLElement(spNext);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::getChildrenByName
 *
 * PURPOSE: returns children by specified name
 *
 * PARAMETERS:
 *    LPTCSTR szTagName                 - [in] tag name
 *    CXMLElementCollection *pChildren  - [out] collection
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLElement::getChildrenByName(LPCTSTR szTagName, CXMLElementCollection *pChildren)
{
    DECLARE_SC(sc, TEXT("CXMLElement::getChildrenByName"));

    sc = ScCheckPointers(pChildren);
    if (sc)
        sc.Throw();

    // init ret value
    *pChildren = CXMLElementCollection();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNodeList> spChildren;
    sc = m_sp->selectNodes(CComBSTR(szTagName), &spChildren);
    if(sc)
        sc.Throw();

    // return the object
    *pChildren = CXMLElementCollection(spChildren);
}

/*+-------------------------------------------------------------------------*
 *
 * CXMLElement::put_text
 *
 * PURPOSE: Per IXMLDOMNode
 *
 * PARAMETERS:
 *    BSTR  bstrValue :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CXMLElement::put_text(BSTR bstrValue)
{
    DECLARE_SC(sc, TEXT("CXMLElement::put_text"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    sc = m_sp->put_text(bstrValue);
    if(sc)
        sc.Throw();
}


//############################################################################
//############################################################################
//
//  Implementation of class CXMLDocument
//
//  These are documented in the Platform SDK.
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::get_root
 *
 * PURPOSE: returns root element of the document
 *
 * PARAMETERS:
 *    CXMLElement *pElem
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLDocument::get_root(CXMLElement *pElem)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::get_root"));

    // parameter check
    sc = ScCheckPointers(pElem);
    if (sc)
        sc.Throw();

    // init ret value
    *pElem = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMElement> spElem;
    sc = m_sp->get_documentElement(&spElem);
    if(sc)
        sc.Throw();

    *pElem = CXMLElement(spElem);
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::createElement
 *
 * PURPOSE: creates new element in XML document
 *
 * PARAMETERS:
 *    NODE_TYPE type       - type of the element requested
 *    CIXMLElement *pElem  - resulting element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLDocument::createElement(DOMNodeType type, BSTR bstrTag, CXMLElement *pElem)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::createElement"));

    // parameter check
    sc = ScCheckPointers(pElem);
    if (sc)
        sc.Throw();

    // init ret val
    *pElem = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    if (type == NODE_ELEMENT)
    {
        CComPtr<IXMLDOMElement> spElem;
        sc = m_sp->createElement(bstrTag, &spElem);
        if(sc)
            sc.Throw();

        *pElem = CXMLElement(spElem);
    }
    else if (type == NODE_TEXT)
    {
        CComPtr<IXMLDOMText> spText;
        sc = m_sp->createTextNode(bstrTag, &spText);
        if(sc)
            sc.Throw();

        *pElem = CXMLElement(spText);
    }
    else
    {
        sc.Throw(E_UNEXPECTED);
    }
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::CreateBinaryStorage
 *
 * PURPOSE: Creates XML element to be used for subsequent persist operations
 *          the object informs Persistor if it wants to be saved as binary data.
 *          If so, only reference will be saved in original place of the object
 *
 * PARAMETERS:
 *    const CStr &strElementType        - type of the element
 *    LPCTSTR szElementName             - name of the element
*
* RETURNS:
*
\***************************************************************************/
void
CXMLDocument::CreateBinaryStorage()
{
    DECLARE_SC(sc, TEXT("CXMLDocument::CreateBinaryStorage"));

    // check if it is attachment is not a doubled
    if (!m_XMLElemBinaryStorage.IsNull())
        sc.Throw(E_UNEXPECTED);

    CXMLElement elemRoot;
    get_root(&elemRoot);

    // create persistor on parent element
    CPersistor persistorParent(*this, elemRoot);
    persistorParent.SetLoading(false);
    CPersistor persistorStor(persistorParent, XML_TAG_BINARY_STORAGE, NULL);

    m_XMLElemBinaryStorage = persistorStor.GetCurrentElement();
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::LocateBinaryStorage
 *
 * PURPOSE: Locates XML element to be used for subsequent persist operations
 *          the object informs Persistor if it wants to be saved as binary data.
 *          If so, only reference will be saved in original place of the object
 *
 * PARAMETERS:
 *    const CStr &strElementType        - type of the element
 *    LPCTSTR szElementName             - name of the element
*
* RETURNS:
*
\***************************************************************************/
void
CXMLDocument::LocateBinaryStorage()
{
    DECLARE_SC(sc, TEXT("CXMLDocument::LocateBinaryStorage"));

    // check if it is attachment is not a doubled
    if (!m_XMLElemBinaryStorage.IsNull())
        sc.Throw(E_UNEXPECTED);

    CXMLElement elemRoot;
    get_root(&elemRoot);

    // create persistor on parent element
    CPersistor persistorParent(*this, elemRoot);
    persistorParent.SetLoading(true);
    CPersistor persistorStor(persistorParent, XML_TAG_BINARY_STORAGE, NULL);
    // find the element
    m_XMLElemBinaryStorage = persistorStor.GetCurrentElement();
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::CommitBinaryStorage
 *
 * PURPOSE: makes binary storage the last element in the collection
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
void
CXMLDocument::CommitBinaryStorage()
{
    DECLARE_SC(sc, TEXT("CXMLDocument::CommitBinaryStorage"));

    if (m_XMLElemBinaryStorage.IsNull())
        sc.Throw(E_UNEXPECTED);

    CXMLElement elemRoot;
    get_root(&elemRoot);

    // get the next siblings
    CXMLElement elNext;
    m_XMLElemBinaryStorage.getNextSibling(&elNext);

    // drag itself and the next element (indent text) to the end
    elemRoot.removeChild(m_XMLElemBinaryStorage);  // remove element

    // the element was padded to have proper indentation - need to remove it
    DOMNodeType elType = NODE_INVALID;
    while (!elNext.IsNull() && (elNext.get_type(&elType), elType == NODE_TEXT))
    {
        CXMLElement elNext2;
        elNext.getNextSibling(&elNext2);

        elemRoot.removeChild(elNext);  // remove element (that was just an indent)
        elNext = elNext2;
    }

    // create persistor on parent element
    CPersistor persistorParent(*this, elemRoot);
    persistorParent.SetLoading(false);
    // create the new binary storage
    CPersistor persistorStor(persistorParent, XML_TAG_BINARY_STORAGE, NULL);

    // replace the current element with the one which hass all the binary storage
    elemRoot.replaceChild(m_XMLElemBinaryStorage, persistorStor.GetCurrentElement());

    m_XMLElemBinaryStorage = NULL;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScCoCreate
 *
 * PURPOSE:     (co)creates new xml document. puts charset and version
 *
 * PARAMETERS:
 *    LPCTSTR lpstrCharSet - charset (NULL - use default)
 *    CXMLDocument& doc    - created document
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScCoCreate(bool bPutHeader)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScCoCreate"));

    // cannot use this on co-created doc!
    if (m_sp)
        return sc = E_UNEXPECTED;

    // Create an empty XML document
    sc = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                            IID_IXMLDOMDocument, (void**)&m_sp);
    if(sc)
        return sc;

    m_sp->put_preserveWhiteSpace(-1);

    try
    {
        CXMLElement elemDoc = m_sp;

        // put the document version
        if (bPutHeader)
        {
            // valid document must have a top element - add the dummy one
            WCHAR szVersion[] = L"<?xml version=\"1.0\"?>\n<DUMMY/>";

            // load
            sc = ScLoad(szVersion);
            if (sc)
                return sc;

            // we can now strip the dummy el.
            CXMLElement elemRoot;
            get_root(&elemRoot);
            elemDoc.removeChild(elemRoot);
            if (sc)
                return sc;
        }

    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScLoad
 *
 * PURPOSE: lods XML document from given IStream
 *
 * PARAMETERS:
 *    IStream *pStream      [in] - stream to load from
 *    bool bSilentOnErrors  [in] - do not trace if open fails
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScLoad(IStream *pStream, bool bSilentOnErrors /*= false*/ )
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScLoad"));

    // check params
    sc = ScCheckPointers(pStream);
    if (sc)
        return sc;

    // get the interface
    IPersistStreamInitPtr spPersistStream = m_sp;
    sc = ScCheckPointers(spPersistStream, E_UNEXPECTED);
    if (sc)
        return sc;

    // load (do not trace the error - it may be that the old console
    // is attempted to load - mmc will revert to old format after this failure)
    SC sc_no_trace = spPersistStream->Load(pStream);
    if ( sc_no_trace )
    {
        if ( !bSilentOnErrors )
            sc = sc_no_trace;
        return sc_no_trace;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScLoad
 *
 * PURPOSE: lods XML document from given string
 *
 * PARAMETERS:
 *    LPCWSTR strSource  [in] - string to load from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScLoad(LPCWSTR strSource)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScLoad"));

    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        return sc;

    CComBSTR bstrSource(strSource);
    VARIANT_BOOL  bOK;

    sc = m_sp->loadXML(bstrSource, &bOK);
    if (sc)
        return sc;

    if (bOK != VARIANT_TRUE)
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScSaveToFile
 *
 * PURPOSE: saves xml document to given stream
 *
 * PARAMETERS:
 *    LPCTSTR lpcstrFileName  - [in] file to save to
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScSaveToFile(LPCTSTR lpcstrFileName)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScSaveToFile"));

    // check params
    sc = ScCheckPointers(lpcstrFileName);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComVariant var(lpcstrFileName);
    sc = m_sp->save(var);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScSave
 *
 * PURPOSE: saves xml document to given string
 *
 * PARAMETERS:
 *    CComBSTR &bstrResult  - [out] string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScSave(CComBSTR &bstrResult)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScSave"));

    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    bstrResult.Empty();
    sc = m_sp->get_xml(&bstrResult);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScSaveToString
 *
 * PURPOSE: saves XML object to string (in raw UNICODE or UTF-8 fromat)
 *
 * PARAMETERS:
 *    tstring *pString  - resulting string
 *    bool bPutHeader   - whether to put xml header info
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/

SC CXMLObject::ScSaveToString(std::wstring *pString, bool bPutHeader /*= false*/)
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScSaveToString"));

    // check parameter
    sc = ScCheckPointers(pString);
    if (sc)
        return sc;

    //initialize output
    pString->erase();

    // Create an empty XML document
    CXMLDocument xmlDocument;
    sc = xmlDocument.ScCoCreate(bPutHeader);
    if(sc)
        return sc;

    // persist the contents
    try
    {
        CXMLElement elemDoc = xmlDocument;

        CPersistor persistor(xmlDocument, elemDoc);
        persistor.SetLoading(false);
        persistor.EnableValueSplit(false); // disable split (no string table, no binary storage)
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    // dump it to the string
    sc = ScSaveXMLDocumentToString(xmlDocument, *pString);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScSaveToDocument
 *
 * PURPOSE: saves XML object to file as XML document
 *
 * PARAMETERS:
 *    CXMLDocument& xmlDocument - xmlDocument to save to
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLObject::ScSaveToDocument( CXMLDocument& xmlDocument )
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScSaveToDocument"));

    // Create an empty XML document
    sc = xmlDocument.ScCoCreate(true/*bPutHeader*/);
    if(sc)
        return sc;

    // persist the contents
    try
    {
        CXMLElement elemDoc = xmlDocument;

        CPersistor persistor(xmlDocument, elemDoc);
        persistor.SetLoading(false);
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScLoadFromString
 *
 * PURPOSE: loads XML object from data stored in string
 *
 * PARAMETERS:
 *    LPCTSTR lpcwstrSource
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLObject::ScLoadFromString(LPCWSTR lpcwstrSource, PersistorMode mode)
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScLoadFromString"));

    // check parameter
    sc = ScCheckPointers(lpcwstrSource);
    if (sc)
        return sc;

    // Create an empty XML document
    CXMLDocument xmlDocument;
    sc = xmlDocument.ScCoCreate(false/*bPutHeader*/);
    if(sc)
        return sc;

    sc = xmlDocument.ScLoad(lpcwstrSource);
    if(sc)
        return sc;

    // persist the contents
    try
    {
        CPersistor persistor(xmlDocument, CXMLElement(xmlDocument));
        persistor.SetLoading(true);
        persistor.SetMode(mode);
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScLoadFromDocument
 *
 * PURPOSE: loads XML object from xml document saved as file
 *
 * PARAMETERS:
 *    CXMLDocument& xmlDocument - xml document to read from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLObject::ScLoadFromDocument( CXMLDocument& xmlDocument )
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScLoadFromDocument"));

    // persist the contents
    try
    {
        CPersistor persistor(xmlDocument, CXMLElement(xmlDocument));
        persistor.SetLoading(true);
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }


    return sc;
}

//############################################################################
//############################################################################
//
//  Implementation of class CPersistor
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CPersistor::CommonConstruct
 *
 * PURPOSE: common constructor, not to be used from outside.
 *          provided as common place for member initialization
 *          all the constructors should call it prior to doing anything specific.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
void CPersistor::CommonConstruct()
{
    // smart pointers are initialized by their constructors
    ASSERT (m_XMLElemCurrent.IsNull());
    ASSERT (m_XMLDocument.IsNull());

    m_bIsLoading = false;
    m_bLockedOnChild = false;
    m_dwModeFlags = persistorModeDefault; // the default mode.
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::BecomeAChildOf
 *
 * PURPOSE: Initialization (second part of construction) of a child persistor
 *          All members, inherited from the parent persistor, are initialized here
 *
 * PARAMETERS:
 *    CPersistor &persistorParent   - [in] (to be) parent persistor of current persistor
 *    CXMLElement elem              - [in] element on which current persistor is based
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CPersistor::BecomeAChildOf(CPersistor &persistorParent, CXMLElement elem)
{
    DECLARE_SC(sc, TEXT("CPersistor::BecomeAChildOf"));

    // assign the element
    m_XMLElemCurrent = elem;

    // we do not inherit m_bLockedOnChild from parent!!!
    m_bLockedOnChild = false;

    // inherited members are copied here
    m_XMLDocument = persistorParent.GetDocument();
    m_bIsLoading  = persistorParent.m_bIsLoading;
    m_dwModeFlags = persistorParent.m_dwModeFlags;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::CPersistor
 *
 * PURPOSE: construct a persistor from a parent persistor.
 *          this creates a new XML element with the given name,
 *          and everything persisted to the new persistor
 *          is persisted under this element.
 *
 * PARAMETERS:
 *    CPersistor &persistorParent       - parent persistor
 *    const CStr &strElementType        - element type [element tag in XML file]
 *    LPCTSTR szElementName             - "Name" attribute [optional]
 *
\***************************************************************************/
CPersistor::CPersistor(CPersistor &persistorParent, const CStr &strElementType, LPCTSTR szElementName /*= NULL*/)
{
    // initialize using common constructor
    CommonConstruct();

    CXMLElement elem;
    if (persistorParent.IsStoring())
        elem = persistorParent.AddElement(strElementType, szElementName);
    else if (persistorParent.m_bLockedOnChild)
    {
        // if we already have the child located - just take it from parent!
        // plus recheck to see it XML document actually has such an element
        elem = persistorParent.CheckCurrentElement(strElementType, szElementName);
    }
    else
        elem = persistorParent.GetElement(strElementType, szElementName);

    // construct child persistor on elem
    BecomeAChildOf(persistorParent, elem);
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::CPersistor
 *
 * PURPOSE: creates new persistor for XML document
 *
 * PARAMETERS:
 *    IXMLDocument * pDocument  - document
 *    CXMLElement &rElemCurrent - root element for persistor
 *
\***************************************************************************/
CPersistor::CPersistor(CXMLDocument &document, CXMLElement& rElemCurrent)
{
    // initialize using common constructor
    CommonConstruct();
    m_XMLDocument = document;
    m_XMLElemCurrent = rElemCurrent;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::CPersistor
 *
 * PURPOSE: Creates new persistor based on parent an supplied element
 *
 * PARAMETERS:
 *    const CPersistor &other       - parent persistor
 *    CXMLElement &rElemCurrent     - root element for persistor
 *    bool bLockedOnChild           - if new persistor should be a fake parent
 *                                    to be used to create persistors
 *
\***************************************************************************/
CPersistor::CPersistor(CPersistor &other, CXMLElement& rElemCurrent, bool bLockedOnChild /*= false*/)
{
    // initialize using common constructor
    CommonConstruct();

    // inherit...
    BecomeAChildOf(other, rElemCurrent);

    // this prevents locating the element on load (assuming the persistor is on element already)
    // used to load items for collections
    m_bLockedOnChild = bLockedOnChild;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::Persist
 *
 * PURPOSE: persists XML object
 *
 * PARAMETERS:
 *    LPCTSTR lpstrName     - "Name" attribute for element [optional = NULL]
 *    CXMLObject & object   - object to persist
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CPersistor::Persist(CXMLObject & object, LPCTSTR lpstrName /*= NULL*/)
{
    DECLARE_SC(sc, TEXT("CPersistor::Persist"));

    // persist w/o splitting if saved to string
    if (!object.UsesBinaryStorage() || !FEnableValueSplit())
    {
        // ordinary object;
        CPersistor persistorNew(*this,object.GetXMLType(),lpstrName);
        object.Persist(persistorNew);
    }
    else
    {
        // this element should be split in 2 places
        // see comment "CONCEPT OF BINARY STORAGE" in "xmbase.h"

        CXMLElement elemBinStorage = GetDocument().GetBinaryStorage();
        if (elemBinStorage.IsNull())
            sc.Throw(E_UNEXPECTED);

        // get elements enumeration in binaries
        CXMLElementCollection colChildren;
        elemBinStorage.getChildrenByName(XML_TAG_BINARY, &colChildren);

        long nChildren = 0;

        if (!colChildren.IsNull())
            colChildren.get_count(&nChildren);

        int iReffIndex = nChildren;

        // save reference instead of contents
        CPersistor persistorNew(*this, object.GetXMLType(), lpstrName);
        persistorNew.PersistAttribute(XML_ATTR_BINARY_REF_INDEX, iReffIndex);

        // persist the object
        CPersistor persistorBinaries(*this, elemBinStorage);
        // locate/create the element [cannot reuse constructor since we have collection here]
        CXMLElement elem;
        if (IsLoading())
        {
            // locate the element
            elem = persistorBinaries.GetElement(XML_TAG_BINARY, object.GetBinaryEntryName(), iReffIndex );
        }
        else
        {
            // storing - just create sub-persistor
            elem = persistorBinaries.AddElement(XML_TAG_BINARY, object.GetBinaryEntryName());
        }
        CPersistor persistorThisBinary(persistorBinaries, elem);

        // start from new line
        if (IsStoring())
        {
            persistorThisBinary.AddTextElement(CComBSTR(L"\n"));
        }

        object.Persist(persistorThisBinary);

        // new line after contents
        if (IsStoring())
        {
            CComBSTR bstrIndent;
            if (persistorThisBinary.GetCurrentElement().GetTextIndent(bstrIndent, false /*bForAChild*/))
                persistorThisBinary.AddTextElement(bstrIndent);
        }
    }
}


/***************************************************************************\
 *
 * METHOD:  CPersistor::Persist
 *
 * PURPOSE: persists XML value as stand-alone object
 *
 * PARAMETERS:
 *    CXMLValue xval        - value to persist
 *    LPCTSTR name          - "Name" attribute for element [optional = NULL]
*
* RETURNS:
*    void
*
\***************************************************************************/
void
CPersistor::Persist(CXMLValue xval, LPCTSTR name /*= NULL*/)
{
    if (xval.UsesBinaryStorage())
    {
        // binary value to be saved to Binary storage.
        // see comment "CONCEPT OF BINARY STORAGE" in "xmbase.h"
        // wrap it into special object, which handles it and pass to Perist method
        CXMLBinaryValue val(xval);
        Persist(val, name);
    }
    else
    {
        // standard value, persist as ordinary element
        CPersistor   persistorNew(*this,xval.GetTypeName(),name);
        persistorNew.PersistContents(xval);
    }
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistAttribute
 *
 * PURPOSE: Persists attribute
 *
 * PARAMETERS:
 *    LPCTSTR name                  - Name of attribute
 *    CXMLValue xval                - Value of attribute
 *    const XMLAttributeType type   - type of attribute [ required/ optional ]
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CPersistor::PersistAttribute(LPCTSTR name, CXMLValue xval, const XMLAttributeType type /*= attr_required*/)
{
    DECLARE_SC(sc, TEXT("CPersistor::PersistAttribute"));

    if(IsLoading())
    {
        CComBSTR bstrPropertyValue;
        bool bValueSupplied = GetCurrentElement().getAttribute(name, bstrPropertyValue);

        if (bValueSupplied)
        {
            sc = xval.ScReadFromBSTR(bstrPropertyValue);
            if (sc)
                sc.Throw(E_FAIL);
        }
        else if (type != attr_optional)
            sc.Throw(E_FAIL);
    }
    else    // IsStoring
    {
        CComBSTR bstr; // must be empty!
        sc = xval.ScWriteToBSTR(&bstr);
        if (sc)
            sc.Throw();
        GetCurrentElement().setAttribute(name, bstr);
    }

}


/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistContents
 *
 * PURPOSE: perists XMLValues as a contents of xml element
 *          <this_element>persisted_contents</this_element>
 *          to be used insted of PersistAttribute where apropriate
 *
 * PARAMETERS:
 *    CXMLValue xval    - value to persist as contents of the element
 *
 * NOTE:    element cannot have both value-as-contents and sub-elements
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CPersistor::PersistContents(CXMLValue xval)
{
    DECLARE_SC(sc, TEXT("CPersistor::PersistContents"));

    if (IsStoring())
    {
        CComBSTR bstr; // must be empty!
        sc = xval.ScWriteToBSTR(&bstr);
        if (sc)
            sc.Throw();

        AddTextElement(bstr);
    }
    else
    {
        CComBSTR bstrPropertyValue;
        GetTextElement(bstrPropertyValue);

        sc = xval.ScReadFromBSTR(bstrPropertyValue);
        if (sc)
            sc.Throw();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::AddElement
 *
 * PURPOSE: Creates a new element below this element with the specified name.
 *          All persistence to the new persistor will write underneath this
 *          new element.
 *
 * PARAMETERS:
 *    const       CStr :
 *    CPersistor& persistorNew :
 *
 * RETURNS:
 *    CXMLElement - created child element
 *
 *+-------------------------------------------------------------------------*/
CXMLElement
CPersistor::AddElement(const CStr &strElementType, LPCTSTR szElementName)
{
    DECLARE_SC(sc, TEXT("CPersistor::AddElement"));

    CXMLElement elem;
    GetDocument().createElement(NODE_ELEMENT, CComBSTR(strElementType), &elem);

    CComBSTR bstrIndent;
    if (GetCurrentElement().GetTextIndent(bstrIndent, true /*bForAChild*/))
        AddTextElement(bstrIndent);

    GetCurrentElement().addChild(elem);  // add the new element to the end.

    if (szElementName)
    {
        CPersistor persistorNew(*this, elem);
        persistorNew.SetName(szElementName);
    }

    // sub element was added - that means this element will have a closing tag
    // add the indent for it in advance
    if (GetCurrentElement().GetTextIndent(bstrIndent, false /*bForAChild*/))
        AddTextElement(bstrIndent);

    return elem;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::AddTextElement
 *
 * PURPOSE: creates new element of type "text"
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CXMLElement - created child element
 *
\***************************************************************************/
void
CPersistor::AddTextElement(BSTR bstrData)
{
    DECLARE_SC(sc, TEXT("CPersistor::AddTextElement"));

    CXMLElement elem;
    GetDocument().createElement(NODE_TEXT, bstrData, &elem);
    GetCurrentElement().addChild(elem);  // add the new element to the end.
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::GetElement
 *
 * PURPOSE: Retrievs child element of the current element with the specified type [and name].
 *          All persistence to the new persistor will read underneath this element.
 *
 * PARAMETERS:
 *    const CStr& strElementType  : type name of the element
 *    LPCTSTR szElementName       : name of the element or NULL if doesn't matter
 *    int iIndex                  : index of the element [optional = -1]
 *
 * RETURNS:
 *    CXMLElement   - resulting new element
 *
 *+-------------------------------------------------------------------------*/
CXMLElement
CPersistor::GetElement(const CStr &strElementType, LPCTSTR szElementName, int iIndex /*= -1*/ )
{
    DECLARE_SC(sc, TEXT("CPersistor::GetElement"));
    CXMLElement elem;

    CXMLElementCollection colChildren;
    GetCurrentElement().getChildrenByName(strElementType, &colChildren);

    long nChildren = 0;

    if (!colChildren.IsNull())
        colChildren.get_count(&nChildren);

    if (nChildren == 0)
        sc.Throw(E_FAIL);

    long nChild = 0;
    if (iIndex >= 0)
    {
        // limit iteration to one loop, if we have index supplied
        nChild = iIndex;
        nChildren = iIndex + 1;
    }
    for (; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            if (szElementName)
            {
                CPersistor temp(*this,el);
                CStr strName(temp.GetName());
                if (0 != strName.CompareNoCase(szElementName))
                    continue;
            }
            elem = el;
            break;
        }
    }

    if(elem.IsNull())
        sc.Throw(E_FAIL);

    return elem;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::GetTextElement
 *
 * PURPOSE: Gets text element attached to the new element
 *          NOTE: returned CPersistor may have current element equal NULL -
 *                this should indicate to caller that the contents is empty
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CXMLElement   - resulting new element
 *
\***************************************************************************/
void
CPersistor::GetTextElement(CComBSTR &bstrData)
{
    DECLARE_SC(sc, TEXT("CPersistor::GetTextElement"));

    bstrData = L"";

    CXMLElement elem;

    CXMLElementCollection colChildren;
    GetCurrentElement().get_children(&colChildren);

    long nChildren = 0;

    if (!colChildren.IsNull())
        colChildren.get_count(&nChildren);

    if (nChildren == 0)
        return; // no text element means "there is no contents"

    for (long nChild = 0; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            DOMNodeType lType = NODE_INVALID;
            el.get_type(&lType);
            if (lType == NODE_TEXT)
            {
                elem = el;
                break;
            }
        }
    }

    if (elem.IsNull())
        return;

    elem.get_text(bstrData);
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::HasElement
 *
 * PURPOSE: checks if persistor has a specified element
 *
 * PARAMETERS:
 *    const       CStr& strElementType  : type name of the element
 *    LPCTSTR szElementName             : name of the element or NULL if doesn't matter
 *
 * RETURNS:
 *    bool       true == requested element exist
 *
 *+-------------------------------------------------------------------------*/
bool
CPersistor::HasElement(const CStr &strElementType, LPCTSTR szElementName)
{
    DECLARE_SC(sc, TEXT("CPersistor::HasElement"));

    if(GetCurrentElement().IsNull())
        sc.Throw(E_POINTER);

    CXMLElementCollection colChildren;
    GetCurrentElement().getChildrenByName(strElementType, &colChildren);

    if (colChildren.IsNull())
        return false;

    long nChildren = 0;
    colChildren.get_count(&nChildren);

    if (nChildren == 0)
        return false;

    for (long nChild = 0; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            if (szElementName)
            {
                CPersistor temp(*this,el);
                CStr strName(temp.GetName());
                if (0 != strName.CompareNoCase(szElementName))
                    continue;
            }
            return true;
        }
    }

    return false;
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::CheckCurrentElement
 *
 * PURPOSE: Checks if current element is of specified type [and name]
 *          used to check collection elements
 *
 * PARAMETERS:
 *    const     CStr& strElementType    : type name of the element
 *    LPCTSTR   szElementName           : name of the element or NULL if doesn't matter
 *
 * RETURNS:
 *    CXMLElement   - pointer to current element
 *
 *+-------------------------------------------------------------------------*/
CXMLElement
CPersistor::CheckCurrentElement(const CStr &strElementType, LPCTSTR szElementName)
{
    DECLARE_SC(sc, TEXT("CPersistor::CheckCurrentElement"));

    CXMLElement elem = GetCurrentElement();

    if(elem.IsNull())
        sc.Throw(E_POINTER);

    CStr strTagName;
    elem.get_tagName(strTagName);
    if (0 != strTagName.CompareNoCase(strElementType))
        sc.Throw(E_FAIL);

    if (szElementName)
    {
        CPersistor temp(*this, elem);
        CStr strName(temp.GetName());
        if (0 != strName.CompareNoCase(szElementName))
            sc.Throw(E_FAIL);
    }

    return elem;
}

void
CPersistor::SetName(const CStr &strName)
{
    DECLARE_SC(sc, TEXT("CPersistor::SetName"));
    CStr _strName = strName;
    ASSERT(IsStoring());
    PersistAttribute(XML_ATTR_NAME, _strName);
}

CStr
CPersistor::GetName()
{
    DECLARE_SC(sc, TEXT("CPersistor::GetName"));
    CStr _strName;
    ASSERT(IsLoading());
    // just return empty string if there is no name
    PersistAttribute(XML_ATTR_NAME, _strName, attr_optional);
    return _strName;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistString
 *
 * PURPOSE: persists stringtable string
 *
 * PARAMETERS:
 *    const CStr &strTag            - tag name for the new element
 *    CStringTableStringBase &str   - string to persist
 *    LPCTSTR lpstrName             - name [optional]
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CPersistor::PersistString(LPCTSTR lpstrName, CStringTableStringBase &str)
{
    DECLARE_SC(sc, TEXT("CPersistor::PersistString"));

    USES_CONVERSION;

    CPersistor subPersistor(*this, XML_TAG_STRING_TABLE_STRING, lpstrName);
    if (subPersistor.IsLoading())
    {
        str.m_id = CStringTableStringBase::eNoValue;
        str.m_str.erase();

        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_ID, str.m_id, attr_optional);
        if (str.m_id != CStringTableStringBase::eNoValue)
        {

            sc = ScCheckPointers(str.m_spStringTable);
            if (sc)
                sc.Throw();

            ULONG cch = 0;
            sc = str.m_spStringTable->GetStringLength (str.m_id, &cch, NULL);
            if (sc)
                sc.Throw();

            // allow for NULL terminator
            cch++;
            std::auto_ptr<WCHAR> spszText (new (std::nothrow) WCHAR[cch]);
            LPWSTR pszText = spszText.get();

            sc = ScCheckPointers(pszText,E_OUTOFMEMORY);
            if (sc)
                sc.Throw();

            sc = str.m_spStringTable->GetString (str.m_id, cch, pszText, NULL, NULL);
            if (sc)
                sc.Throw();

            str.m_str = W2T (pszText);

            return;
        }
        std::wstring text;
        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_VALUE, text, attr_optional);
        str.m_str = W2CT(text.c_str());
        return;
    }

    str.CommitToStringTable();
    if (FEnableValueSplit() && str.m_id != CStringTableStringBase::eNoValue)
    {
#ifdef DBG
        /*
         * make sure CommitToStringTable really committed
         */
        if (str.m_id != CStringTableStringBase::eNoValue)
        {
            WCHAR sz[256];
            ASSERT (str.m_spStringTable != NULL);
            HRESULT hr = str.m_spStringTable->GetString (str.m_id, countof(sz), sz, NULL, NULL);
            ASSERT (SUCCEEDED(hr) && "Persisted a CStringTableString to a stream that's not in the string table");
        }
#endif
        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_ID, str.m_id);
    }
    else
    {
        if (str.m_id == CStringTableStringBase::eNoValue)
            str.m_str.erase();
        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_VALUE, str.m_str);
    }
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistAttribute
 *
 * PURPOSE: special method to persist bitflags
 *
 * PARAMETERS:
 *    LPCTSTR name          [in] name of the flags
 *    CXMLBitFlags& flags   [in] flags to persist
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CPersistor::PersistAttribute(LPCTSTR name, CXMLBitFlags& flags )
{
    flags.PersistMultipleAttributes(name, *this);
}

//############################################################################
//############################################################################
//
//  Implementation of class XMLPoint
//
//############################################################################
//############################################################################
XMLPoint::XMLPoint(const CStr &strObjectName, POINT &point)
:m_strObjectName(strObjectName), m_point(point)
{
}

/*+-------------------------------------------------------------------------*
 *
 * XMLPoint::Persist
 *
 * PURPOSE: Persists an XMLPoint to a persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
XMLPoint::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLPoint::Persist"));
    if (persistor.IsStoring())
        persistor.SetName(m_strObjectName);
    persistor.PersistAttribute(XML_ATTR_POINT_X, m_point.x);
    persistor.PersistAttribute(XML_ATTR_POINT_Y, m_point.y);
}

//############################################################################
//############################################################################
//
//  Implementation of class XMLRect
//
//############################################################################
//############################################################################
XMLRect::XMLRect(const CStr strObjectName, RECT &rect)
:m_strObjectName(strObjectName), m_rect(rect)
{
}

void
XMLRect::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLRect::Persist"));
    if (persistor.IsStoring())
        persistor.SetName(m_strObjectName);
    persistor.PersistAttribute(XML_ATTR_RECT_TOP,       m_rect.top);
    persistor.PersistAttribute(XML_ATTR_RECT_BOTTOM,    m_rect.bottom);
    persistor.PersistAttribute(XML_ATTR_RECT_LEFT,      m_rect.left);
    persistor.PersistAttribute(XML_ATTR_RECT_RIGHT,     m_rect.right);
}

//############################################################################
//############################################################################
//
//  Implementation of class CXMLValue
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CXMLValue::GetTypeName
 *
 * PURPOSE: returns tag name (usually type name) to be used as element tag
 *          when value is persisted as element via CPersistor.Persist(val)
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    LPCTSTR    - tag name
 *
\***************************************************************************/
LPCTSTR CXMLValue::GetTypeName() const
{
    switch(m_type)
    {
    case XT_I4 :        return XML_TAG_VALUE_LONG;
    case XT_UI4 :       return XML_TAG_VALUE_ULONG;
    case XT_UI1 :       return XML_TAG_VALUE_BYTE;
    case XT_I2 :        return XML_TAG_VALUE_SHORT;
    case XT_DW :        return XML_TAG_VALUE_DWORD;
    case XT_BOOL :      return XML_TAG_VALUE_BOOL;
    case XT_CPP_BOOL :  return XML_TAG_VALUE_BOOL;
    case XT_UINT :      return XML_TAG_VALUE_UINT;
    case XT_INT  :      return XML_TAG_VALUE_INT;
    case XT_STR :       return XML_TAG_VALUE_CSTR;
    case XT_WSTR :      return XML_TAG_VALUE_WSTRING;
    case XT_GUID :      return XML_TAG_VALUE_GUID;
    case XT_BINARY :    return XML_TAG_VALUE_BIN_DATA;
    case XT_EXTENSION:  return m_val.pExtension->GetTypeName();
    default:            return XML_TAG_VALUE_UNKNOWN;
    }
}


/***************************************************************************\
 *
 * METHOD:  CXMLValue::ScWriteToBSTR
 *
 * PURPOSE: Converts an XML value to a bstring.
 *          internally uses WCHAR buffer on the stack for the conversion of integer
 *          types.
 *
 * PARAMETERS:
 *    BSTR * pbstr  - [out] resulting string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLValue::ScWriteToBSTR (BSTR * pbstr) const
{
    DECLARE_SC(sc, TEXT("CXMLValue::ScWriteToBSTR"));

    // check parameter
    sc = ScCheckPointers(pbstr);
    if (sc)
        return sc;

    // initialize
    *pbstr = NULL;

    WCHAR szBuffer[40];
    int cchBuffer = 40;
    CComBSTR bstrResult;
    USES_CONVERSION;

    switch(m_type)
    {
    case XT_I4:  //LONG
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"%d\0", *m_val.pL);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_UI4:  //LONG
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"%u\0", *m_val.pUl);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_UI1: //BYTE
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"0x%02.2x\0", (int)*m_val.pByte);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_I2:  //SHORT
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"%d\0", (int)*m_val.pS);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_DW:  //DWORD
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"0x%04.4x\0", *m_val.pDw);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_BOOL://BOOL: can either print true/false
        bstrResult = ( *m_val.pBOOL ? XML_VAL_BOOL_TRUE : XML_VAL_BOOL_FALSE );
        break;

    case XT_CPP_BOOL://bool: can either print true/false
        bstrResult = ( *m_val.pbool ? XML_VAL_BOOL_TRUE : XML_VAL_BOOL_FALSE );
        break;

    case XT_UINT:  //UINT
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"%u\0", *m_val.pUint);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_INT:  //UINT
        sc = StringCchPrintfW(szBuffer, cchBuffer, L"%d\0", *m_val.pInt);
        if(sc)
            return sc;
        bstrResult = szBuffer;
        break;

    case XT_STR: //CStr
        bstrResult = T2COLE(static_cast<LPCTSTR>(*m_val.pStr));
        break;

    case XT_WSTR: //wstring
        bstrResult = m_val.pWStr->c_str();
        break;

    case XT_TSTR: //tstring
        bstrResult = T2COLE(m_val.pTStr->c_str());
        break;

    case XT_GUID: //GUID
        {
            LPOLESTR sz;
            StringFromCLSID(*m_val.pGuid, &sz);
            bstrResult = sz;
            CoTaskMemFree(sz);
        }
        break;

    case XT_BINARY:
        sc = ScEncodeBinary(bstrResult, *m_val.pXmlBinary);
        if (sc)
            return sc;

        break;

    case XT_EXTENSION:
        sc = m_val.pExtension->ScWriteToBSTR (&bstrResult);
        if (sc)
            return sc;

        break;

    default:
        //ASSERT(0 && "Should not come here!!");
        return sc = E_NOTIMPL;
    }

    *pbstr = bstrResult.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLValue::ScReadFromBSTR
 *
 * PURPOSE: Converts a string an XML value
 *
 * PARAMETERS:
 *    const BSTR bstr - [in] string to be read
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLValue::ScReadFromBSTR(const BSTR bstr)
{
    DECLARE_SC(sc, TEXT("CXMLValue::ScReadFromBSTR"));

    LPCOLESTR olestr = bstr;
    if (olestr == NULL)     // make sure we always have a valid pointer
        olestr = L"";       // in case of NULL we use own empty string

    USES_CONVERSION;
    switch(m_type)
    {
    case XT_I4:  //LONG
        *m_val.pL = wcstol(olestr,NULL,10);
        break;

    case XT_UI4:  //LONG
        *m_val.pUl = wcstoul(olestr,NULL,10);
        break;

    case XT_UI1: //BYTE
        *m_val.pByte = static_cast<BYTE>(wcstol(olestr,NULL,10));
        break;

    case XT_I2:  //SHORT
        *m_val.pS = static_cast<SHORT>(wcstol(olestr,NULL,10));
        break;

    case XT_DW:  //DWORD
        *m_val.pDw = wcstoul(olestr,NULL,10);
        break;

    case XT_BOOL://BOOL: can either be true/false
        {
            *m_val.pBOOL = FALSE;
            LPCWSTR pszXmlBool = T2CW(XML_VAL_BOOL_TRUE);
            if (NULL != pszXmlBool)
            {
                *m_val.pBOOL = (0 == _wcsicmp(olestr, pszXmlBool));
            }
        }
        break;
    case XT_CPP_BOOL://bool: can either be true/false
        {
            *m_val.pbool = FALSE;
            LPCWSTR pszXmlBool = T2CW(XML_VAL_BOOL_TRUE);
            if (NULL != pszXmlBool)
            {
                *m_val.pbool = (0 == _wcsicmp(olestr, pszXmlBool));
            }
        }
        break;
    case XT_UINT:  //UINT
        *m_val.pUint = wcstoul(olestr,NULL,10);
        break;

    case XT_INT:  //UINT
        *m_val.pInt = wcstol(olestr,NULL,10);
        break;

    case XT_STR: //CStr
        *m_val.pStr = OLE2CT(olestr);
        break;

    case XT_WSTR: //CString
        *m_val.pWStr = olestr;
        break;

    case XT_TSTR: //tstring
        *m_val.pTStr = OLE2CT(olestr);
        break;

    case XT_GUID: //GUID
        sc = CLSIDFromString(const_cast<LPOLESTR>(olestr), m_val.pGuid);
        if (sc)
            return sc;

        break;

    case XT_BINARY:
        sc = ScDecodeBinary(olestr, m_val.pXmlBinary);
        if (sc)
            return sc;

        break;

    case XT_EXTENSION:
        sc = m_val.pExtension->ScReadFromBSTR(bstr);
        if (sc)
            return sc;

        break;

    default:
        //ASSERT(0 && "Should not come here!!");
        return sc = E_NOTIMPL;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: XMLListCollectionBase::Persist
 *
 * PURPOSE: implements persisting of list contents from XML file
 *          iterates child elements calling virtual mem. OnNewElement for each
 *
 * PARAMETERS:
 *    CPersistor& persistorNew          : persistor object
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void XMLListCollectionBase::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLListCollectionBase::Persist"));
    ASSERT(persistor.IsLoading());

    CXMLElementCollection colChildren;
    persistor.GetCurrentElement().get_children(&colChildren);

    if (colChildren.IsNull())
    {
        // no children -> we are done!
        return;
    }

    long nChildren = 0;
    colChildren.get_count(&nChildren);

    for (long nChild = 0; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            DOMNodeType lType = NODE_INVALID;
            el.get_type(&lType);

            if (lType == NODE_ELEMENT)
            {
                CPersistor persistorNewLocked(persistor, el, true);
                OnNewElement(persistorNewLocked);
            }
        }
    }
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: XMLMapCollectionBase::Persist
 *
 * PURPOSE: implements persisting of map contents from XML file
 *          iterates child elements calling virtual mem. OnNewElement for each pair
 *
 * PARAMETERS:
 *    CPersistor& persistorNew          : persistor object
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void XMLMapCollectionBase::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLMapCollectionBase::Persist"));
    ASSERT(persistor.IsLoading());

    CXMLElementCollection colChildren;
    persistor.GetCurrentElement().get_children(&colChildren);

    if (colChildren.IsNull())
    {
        // no children -> we are done!
        return;
    }

    long nChildren = 0;
    colChildren.get_count(&nChildren);

    // collect all elements of proper type
    std::vector<CXMLElement> vecChilds;

    for (long nChild = 0; nChild < nChildren; nChild ++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            DOMNodeType lType = NODE_INVALID;
            el.get_type(&lType);

            if (lType == NODE_ELEMENT)
                vecChilds.push_back(el);
        }
    }


    for (nChild = 0; nChild + 1 < vecChilds.size(); nChild += 2)
    {
        CXMLElement el(vecChilds[nChild]);
        CXMLElement el2(vecChilds[nChild+1]);

        CPersistor persistorNew1(persistor, el, true);
        CPersistor persistorNew2(persistor, el2, true);
        OnNewElement(persistorNew1,persistorNew2);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * ScEncodeBinary
 *
 * PURPOSE: converts data to encoded format for xml
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC - error code
 *
 *+-------------------------------------------------------------------------*/
static SC ScEncodeBinary(CComBSTR& bstrResult, const CXMLBinary& binSrc)
{
    DECLARE_SC(sc, TEXT("ScEncodeBinary"));

    // initialize
    bstrResult.Empty();

    // nothing if binary is zero size...
    if (binSrc.GetSize() == 0)
        return sc;

    // line length for the binary data. maximum allowed by base64 per line is 76
    const int   line_len = 76;
    // symbols to be placed as terminators of each line
    const WCHAR line_end[] = { 0x0d, 0x0a };
    DWORD dwBytesLeft = binSrc.GetSize();
    // space required for encription
    DWORD dwCount = (dwBytesLeft*8+5)/6;
    // ... plus up to three '='
    dwCount += (4 - dwCount%4) & 0x03;
    // allow space for white_spaces inerted and terminating zero
    dwCount += (dwCount / line_len)*countof(line_end) + 1;

    BOOL bOk = SysReAllocStringLen(&bstrResult,NULL,dwCount);
    if (bOk != TRUE || (LPOLESTR)bstrResult == NULL)
        return sc = E_OUTOFMEMORY;

    LPOLESTR pstrResult = bstrResult;
    *pstrResult = 0;

    if (!dwBytesLeft)
        return sc; // emty seq? - we are done

    const BYTE *pData = NULL;
    sc = binSrc.ScLockData((const void **)&pData);
    if (sc)
        return sc;

    sc = ScCheckPointers(pData, E_UNEXPECTED);
    if(sc)
        return sc;

    DWORD dwCharsStored = 0;
    while (dwBytesLeft)
    {
        base64_table::encode(pData, dwBytesLeft, pstrResult);
        dwCharsStored += 4;
        if (0 == (dwCharsStored % line_len) && dwBytesLeft)
            for (int i = 0; i < countof(line_end); i++)
                *pstrResult++ = line_end[i];
    }

    // terminate
    *pstrResult = 0;

    sc = binSrc.ScUnlockData();
    if (sc)
        sc.TraceAndClear();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScDecodeBinary
 *
 * PURPOSE: converts encoded data back to image
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
static SC ScDecodeBinary(const CComBSTR& bstrSource, CXMLBinary *pBinResult)
{
    DECLARE_SC(sc, TEXT("ScDecodeBinary"));

    DWORD  dwCount = bstrSource.Length();
    DWORD  dwSize = (dwCount*6+7)/8;

    sc = ScCheckPointers(pBinResult);
    if (sc)
        return sc;

    sc = pBinResult->ScFree(); // ignore the error here
    if (sc)
        sc.TraceAndClear();

    if (!dwSize) // no data? - good
        return sc;

    sc = pBinResult->ScAlloc(dwSize);
    if(sc)
        return sc;

    CXMLBinaryLock sLock(*pBinResult);

    BYTE *pData = NULL;
    sc = sLock.ScLock(&pData);
    if(sc)
        return sc;

    // recheck
    sc = ScCheckPointers(pData, E_UNEXPECTED);
    if (sc)
        return sc;

    BYTE * const pDataStart = pData;

    LPOLESTR pInput = bstrSource;

    while(base64_table::decode(pInput, pData));

    sc = sLock.ScUnlock();
    if (sc)
        sc.TraceAndClear();

    DWORD dwDataDecoded = pData - pDataStart;

    // fix data size , if required

    if (dwDataDecoded != dwSize)
    {
        if (dwDataDecoded == 0)
            sc = pBinResult->ScFree();
        else
            sc = pBinResult->ScRealloc(dwDataDecoded);

        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStorage::ScInitialize
 *
 * PURPOSE: Initializes object. Creates new storage if does not have one
 *
 * PARAMETERS:
 *    bool& bCreatedNewOne  [out] - created new stream
 *
 * RETURNS:
 *    SC    - result code.
 *
\***************************************************************************/
SC CXML_IStorage::ScInitialize(bool& bCreatedNewOne)
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScInitialize"));

    // short cut if initialized oalready
    if (m_Storage != NULL)
    {
        bCreatedNewOne = false;
        return sc;
    }

    bCreatedNewOne = true;

    // create the ILockBytes
    sc = CreateILockBytesOnHGlobal(NULL, TRUE, &m_LockBytes);
    if(sc)
        return sc;

    // create the IStorage
    sc = StgCreateDocfileOnILockBytes( m_LockBytes, 
                                       STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                       0, &m_Storage);
    if(sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStorage::ScInitializeFrom
 *
 * PURPOSE: Initializes object. copies contents from provided source
 *
 * PARAMETERS:
 *    IStorage *pSource [in] initial contents of the storage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStorage::ScInitializeFrom( IStorage *pSource )
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScInitializeFrom"));

    // parameter check
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // init empty
    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize(bCreatedNewOne);
    if (sc)
        return sc;

    ASSERT( m_Storage != NULL );

    // copy contents
    sc = pSource->CopyTo( 0, NULL, NULL, m_Storage );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStorage::ScGetIStorage
 *
 * PURPOSE: returns pointer to maintained storage.
 *
 * PARAMETERS:
 *    IStorage **ppStorage [out] pointer to the storage
 *
 * RETURNS:
 *    SC    - result code. 
 *
\***************************************************************************/
SC CXML_IStorage::ScGetIStorage( IStorage **ppStorage )
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScGetIStorage"));

    // parameter check
    sc = ScCheckPointers( ppStorage );
    if (sc)
        return sc;

    // init out parameter
    *ppStorage = NULL;

    // make sure we have storage - initialize
    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    // recheck if the member is set
    sc = ScCheckPointers ( m_Storage, E_UNEXPECTED );
    if (sc)
        return sc;

    // return the pointer
    *ppStorage = m_Storage;
    (*ppStorage)->AddRef();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: CXML_IStorage::ScRequestSave
 *
 * PURPOSE: asks snapin to save using snapin's IPersistStorage
 *
 *+-------------------------------------------------------------------------*/
SC
CXML_IStorage::ScRequestSave( IPersistStorage * pPersistStorage )
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScRequestSave"));

    bool bCreatedNewOne = false;
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers( m_Storage, E_UNEXPECTED );
    if (sc)
        return sc;

    sc = pPersistStorage->Save(m_Storage, !bCreatedNewOne);
    if(sc)
        return sc;

    sc = pPersistStorage->SaveCompleted(NULL);
    // we were always passing a storage in MMC 1.2, so some of the
    // snapins did not expect it to be NULL (which is correct value when
    // storage does not change)
    // to be able to save such snapins we need to to ignore this error
    // see bug 96344
    if (sc == SC(E_INVALIDARG))
    {
		#ifdef DBG
            m_dbg_Data.TraceErr(_T("IPersistStorage::SaveCompleted"), _T("legal argument NULL passed to snapin, but error returned"));
		#endif

        sc = pPersistStorage->SaveCompleted(m_Storage);
    }

    if(sc)
        return sc;

    // commit the changes - this ensures everything is in HGLOBAL
    sc = m_Storage->Commit( STGC_DEFAULT );
    if(sc)
        return sc;

#ifdef DBG
    if (S_FALSE != pPersistStorage->IsDirty())
        m_dbg_Data.TraceErr(_T("IPersistStorage"), _T("Reports 'IsDirty' right after 'Save'"));
#endif // #ifdef DBG

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * m_Storage: CXML_IStorage::Persist
 *
 * PURPOSE: dumps data to HGLOBAL and persists
 *
 *+-------------------------------------------------------------------------*/
void
CXML_IStorage::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::Persist"));

    if (persistor.IsStoring())
    {
        bool bCreatedNewOne = false; // not used here
        sc = ScInitialize( bCreatedNewOne );
        if (sc)
            sc.Throw();

        HANDLE hStorage = NULL;
        sc = GetHGlobalFromILockBytes(m_LockBytes, &hStorage);
        if(sc)
            sc.Throw();

        STATSTG statstg;
        ZeroMemory(&statstg, sizeof(statstg));

        sc = m_LockBytes->Stat(&statstg, STATFLAG_NONAME);
        if (sc)
            sc.Throw();

        CXMLBinary binInitial;
        binInitial.Attach(hStorage, statstg.cbSize.LowPart);

        // persist the contents
        persistor.PersistContents(binInitial);

        return; // done
    }

    //--- Loading ---
    CXMLAutoBinary binLoaded;
    persistor.PersistContents(binLoaded);

    // Need to recreate storage...
    ASSERT(persistor.IsLoading()); // should not reallocate else!!
    m_LockBytes = NULL;

    ULARGE_INTEGER new_size = { binLoaded.GetSize(), 0 };
    sc = CreateILockBytesOnHGlobal(binLoaded.GetHandle(), TRUE, &m_LockBytes);
    if(sc)
        sc.Throw();

    // control transferred to ILockBytes
    binLoaded.Detach();

    sc = m_LockBytes->SetSize(new_size);
    if(sc)
        sc.Throw();

    sc = StgOpenStorageOnILockBytes(m_LockBytes, NULL , STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                    NULL, 0, &m_Storage);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScInitialize
 *
 * PURPOSE: initializes object. creates empty stream if does not have one
 *
 * PARAMETERS:
 *    bool& bCreatedNewOne  [out] - created new stream
 *
 * RETURNS:
 *    SC    - result code. 
 *
\***************************************************************************/
SC CXML_IStream::ScInitialize( bool& bCreatedNewOne )
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScInitialize"));

    if (m_Stream != NULL)
    {
        bCreatedNewOne = false;
        return sc;
    }

    bCreatedNewOne = true;

    sc = CreateStreamOnHGlobal( NULL, TRUE, &m_Stream);
    if(sc)
        return sc;

    const ULARGE_INTEGER zero_size = {0,0};
    sc = m_Stream->SetSize(zero_size);
    if(sc)
        return sc;

    sc = ScSeekBeginning();
    if(sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScInitializeFrom
 *
 * PURPOSE: Initializes object. Copies contents from provided source
 *
 * PARAMETERS:
 *    IStream *pSource [in] initial contents of the stream
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStream::ScInitializeFrom( IStream *pSource )
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScInitializeFrom"));

    // parameter check
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // initialize empty
    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    ASSERT( m_Stream != NULL );

    // reset stream pointer
    sc = ScSeekBeginning();
    if(sc)
        return sc;

    // copy contents from source
    STATSTG statstg;
    sc = pSource->Stat(&statstg, STATFLAG_NONAME);
    if (sc)
       return sc;

    // copy contents
    ULARGE_INTEGER cbRead;
    ULARGE_INTEGER cbWritten;
    sc = pSource->CopyTo( m_Stream, statstg.cbSize, &cbRead, &cbWritten );
    if (sc)
       return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScSeekBeginning
 *
 * PURPOSE: resets stream pointer to the beginning of the stream
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStream::ScSeekBeginning()
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScSeekBeginning"));
    
    LARGE_INTEGER null_offset = { 0, 0 };
    sc = m_Stream->Seek(null_offset, STREAM_SEEK_SET, NULL);
    if(sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScGetIStream
 *
 * PURPOSE: returns the pointer to maintained stream
 *
 * PARAMETERS:
 *    IStream **ppStream
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStream::ScGetIStream( IStream **ppStream )
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScGetIStream"));

    // parameter check
    sc = ScCheckPointers( ppStream );
    if (sc)
        return sc;

    // init out parameter
    *ppStream = NULL;

    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    sc = ScSeekBeginning();
    if (sc)
        return sc;

    // recheck if the member is set
    sc = ScCheckPointers ( m_Stream, E_UNEXPECTED );
    if (sc)
        return sc;
    
    *ppStream = m_Stream;
    (*ppStream)->AddRef();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: CXML_IStream::Persist
 *
 * PURPOSE: persist data of maintained IStream
 *
 * NOTE: Object may point to another Stream after this method
 *
 *+-------------------------------------------------------------------------*/
void
CXML_IStream::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CXML_IStream::Persist"));

    if (persistor.IsStoring())
    {
        bool bCreatedNewOne = false; // not used here
        sc = ScInitialize( bCreatedNewOne );
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(m_Stream, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        HANDLE hStream = NULL;
        sc = GetHGlobalFromStream( m_Stream, &hStream );
        if(sc)
            sc.Throw();

        STATSTG statstg;
        ZeroMemory(&statstg, sizeof(statstg));

        sc = m_Stream->Stat(&statstg, STATFLAG_NONAME);
        if (sc)
            sc.Throw();

        CXMLBinary binInitial;
        binInitial.Attach(hStream, statstg.cbSize.LowPart);

        // persist the contents
        persistor.PersistContents(binInitial);

        return; // done
    }

    //--- Loading ---
    CXMLAutoBinary binLoaded;
    persistor.PersistContents(binLoaded);

    // Need to recreate stream...
    ULARGE_INTEGER new_size = { binLoaded.GetSize(), 0 };
    sc = CreateStreamOnHGlobal(binLoaded.GetHandle(), TRUE, &m_Stream);
    if(sc)
        sc.Throw();

    // control transferred to IStream
    binLoaded.Detach();

    sc = m_Stream->SetSize(new_size);
    if(sc)
        sc.Throw();

    // reset stream pointer
    sc = ScSeekBeginning();
    if(sc)
        sc.Throw();
}

/***************************************************************************\
| trace support helper for CHK builds
\***************************************************************************/
#ifdef DBG
void CXML_IStream::DBG_TraceNotResettingDirty(LPCSTR strIntfName)
{
    USES_CONVERSION;
    tstring inft = A2CT(strIntfName); // get the name of interface
    inft.erase(inft.begin(), inft.begin() + strlen("struct "));  // cut the 'struct' off

    m_dbg_Data.TraceErr(inft.c_str(), _T("Reports 'IsDirty' right after 'Save'"));
}
#endif

/*+-------------------------------------------------------------------------*
 *
 * METHOD: CXMLPersistableIcon::Persist
 *
 * PURPOSE: persists icon contents
 *
 *+-------------------------------------------------------------------------*/

void CXMLPersistableIcon::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CXMLPersistableIcon::Persist"));

    persistor.PersistAttribute(XML_ATTR_ICON_INDEX, m_Icon.m_Data.m_nIndex);
    CStr strIconFile = m_Icon.m_Data.m_strIconFile.c_str();
    persistor.PersistAttribute(XML_ATTR_ICON_FILE, strIconFile);
    m_Icon.m_Data.m_strIconFile = strIconFile;

    CXMLIcon iconLarge (XML_ATTR_CONSOLE_ICON_LARGE);
    CXMLIcon iconSmall (XML_ATTR_CONSOLE_ICON_SMALL);

	if (persistor.IsStoring())
	{
		iconLarge = m_Icon.m_icon32;
		iconSmall = m_Icon.m_icon16;
	}

    // keep this order intact to allow icon lookup by shellext
    persistor.Persist (iconLarge, XML_NAME_ICON_LARGE);
    persistor.Persist (iconSmall, XML_NAME_ICON_SMALL);

	if (persistor.IsLoading())
	{
		m_Icon.m_icon32 = iconLarge;
		m_Icon.m_icon16 = iconSmall;
	}
}


/*+-------------------------------------------------------------------------*
 *
 * FUNCTION: ScReadDataFromFile
 *
 * PURPOSE: reads file data to global memory
 *
 *+-------------------------------------------------------------------------*/
static SC ScReadDataFromFile(LPCTSTR strName, CXMLBinary *pBinResult)
{
    DECLARE_SC(sc, TEXT("ScReadDataFromFile"));

    // check parameter
    sc = ScCheckPointers(pBinResult);
    if (sc)
        return sc;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    // try to open existing file
    hFile = CreateFile(strName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    // check if we are unable to get to the file
    if (hFile == INVALID_HANDLE_VALUE)
    {
        sc.FromWin32(GetLastError());
        return sc;
    }

    // see how large the file is
    ULARGE_INTEGER cbCurrSize;
    cbCurrSize.LowPart = GetFileSize(hFile,&cbCurrSize.HighPart);
    if (cbCurrSize.HighPart != 0 || (LONG)(cbCurrSize.LowPart) < 0) // limiting to 2GB
    {
        sc = E_UNEXPECTED;
        goto CleanUpAndExit;
    }

    if (!cbCurrSize.LowPart)
    {
        // empty file. ok at this point
        goto CleanUpAndExit;
    }

    sc = pBinResult->ScAlloc(cbCurrSize.LowPart);
    if (sc)
        goto CleanUpAndExit;

    { // scoping for vars

        // no the time to do some reading
        DWORD dwRead = 0;
        BOOL bRead = FALSE;

        CXMLBinaryLock sLock(*pBinResult); // will unlock in destructor

        LPVOID pData = NULL;
        sc = sLock.ScLock(&pData);
        if (sc)
            goto CleanUpAndExit;

        sc = ScCheckPointers(pData,E_OUTOFMEMORY);
        if (sc)
            goto CleanUpAndExit;

        bRead = ReadFile(hFile,pData,cbCurrSize.LowPart,&dwRead,NULL);
        if (!bRead)
        {
            sc.FromLastError();
            goto CleanUpAndExit;
        }
        else if (dwRead != cbCurrSize.LowPart)
        {
            // something strange
            sc = E_UNEXPECTED;
            goto CleanUpAndExit;
        }
    } // scoping for vars

CleanUpAndExit:

    CloseHandle(hFile);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * FUNCTION: ScSaveXMLDocumentToString
 *
 * PURPOSE: stores contents of XML document into the string
 *
 *+-------------------------------------------------------------------------*/
SC ScSaveXMLDocumentToString(CXMLDocument& xmlDocument, std::wstring& strResult)
{
    DECLARE_SC(sc, TEXT("ScSaveXMLDocumentToString"));

    CComBSTR bstrResult;
    sc =  xmlDocument.ScSave(bstrResult);
    if (sc)
        return sc;

    // allocate and copy string
    strResult = bstrResult;

    // now remove all the \n and \r characters
    tstring::size_type pos;
    while ((pos = strResult.find_first_of(L"\n\r")) != strResult.npos)
        strResult.erase(pos, 1);

    return sc;
}

/*+-------------------------------------------------------------------------*
 * CXMLVariant::Persist
 *
 * Persists a CXMLVariant to/from an XML persistor.
 *--------------------------------------------------------------------------*/

#define ValNamePair(x) { x, L#x }

struct VARTYPE_MAP
{
    VARENUM vt;
    LPCWSTR pszName;
};

void CXMLVariant::Persist (CPersistor &persistor)
{
    DECLARE_SC (sc, _T("CXMLVariant::Persist"));

    static const VARTYPE_MAP TypeMap[] =
    {
        ValNamePair (VT_EMPTY),
        ValNamePair (VT_NULL),
        ValNamePair (VT_I2),
        ValNamePair (VT_I4),
        ValNamePair (VT_R4),
        ValNamePair (VT_R8),
        ValNamePair (VT_CY),
        ValNamePair (VT_DATE),
        ValNamePair (VT_BSTR),
        ValNamePair (VT_ERROR),
//      ValNamePair (VT_BOOL),      VT_BOOL is handled as a special case
        ValNamePair (VT_DECIMAL),
        ValNamePair (VT_I1),
        ValNamePair (VT_UI1),
        ValNamePair (VT_UI2),
        ValNamePair (VT_UI4),
        ValNamePair (VT_INT),
        ValNamePair (VT_UINT),
    };

    std::wstring strValue, strType;

    /*
     * storing?
     */
    if (persistor.IsStoring())
    {
        /*
         * can't store variants that aren't "simple" (i.e. by-ref, array, etc.)
         */
        if (!IsPersistable())
            (sc = E_FAIL).Throw();

        /*
         * special case for VT_BOOL
         */
        if (V_VT(this) == VT_BOOL)
        {
            strValue = (V_BOOL(this) == VARIANT_FALSE) ? L"False" : L"True";
            strType  = L"VT_BOOL";
        }
        else
        {
            /*
             * we can only VARIANTs that can be converted to text
             */
            CComVariant varPersist;
            sc = varPersist.ChangeType (VT_BSTR, this);
            if (sc)
                sc.Throw();

            /*
             * find the name for the type we're persisting
             */
            for (int i = 0; i < countof (TypeMap); i++)
            {
                if (V_VT(this) == TypeMap[i].vt)
                    break;
            }

            /*
             * unrecognized type that's convertible to string?
             */
            if (i >= countof (TypeMap))
                (sc = E_FAIL).Throw();

            /*
             * set the values that'll get saved
             */
            strValue = V_BSTR(&varPersist);
            strType  = TypeMap[i].pszName;
        }
    }

    /*
     * put to/get from the persistor
     */
    persistor.PersistAttribute (XML_ATTR_VARIANT_VALUE, strValue);
    persistor.PersistAttribute (XML_ATTR_VARIANT_TYPE,  strType);

    /*
     * loading?
     */
    if (persistor.IsLoading())
    {
        /*
         * clear out the current contents
         */
        Clear();

        /*
         * special case for VT_BOOL
         */
        if (strType == L"VT_BOOL")
        {
            V_VT  (this) = VT_BOOL;
            V_BOOL(this) = (_wcsicmp (strValue.data(), L"False")) ? VARIANT_FALSE : VARIANT_TRUE;
        }

        else
        {
            /*
             * find the VARIANT type in our map so we can convert back
             * to the right type
             */
            for (int i = 0; i < countof (TypeMap); i++)
            {
                if (strType == TypeMap[i].pszName)
                    break;
            }

            /*
             * unrecognized type that's convertible to string?
             */
            if (i >= countof (TypeMap))
                (sc = E_FAIL).Throw();

            /*
             * convert from string back to the original type
             */
            CComVariant varPersisted (strValue.data());
            sc = ChangeType (TypeMap[i].vt, &varPersisted);
            if (sc)
                sc.Throw();

        }
    }
}


/***************************************************************************\
 *
 * METHOD:  CXMLEnumeration::ScReadFromBSTR
 *
 * PURPOSE: reads value from BSTR and evaluates (decodes) it
 *
 * PARAMETERS:
 *    const BSTR bstr - [in] string containing the value
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLEnumeration::ScReadFromBSTR(const BSTR bstr)
{
    DECLARE_SC(sc, TEXT("CXMLEnumeration::ScReadFromBSTR"));

    // parameter check. (null BSTR is legal, but we do not support empty values either)
    sc = ScCheckPointers(bstr);
    if (sc)
        return sc;

    // convert to TSTRING
    USES_CONVERSION;
    LPCTSTR strInput = OLE2CT(bstr);

    // find a match in the mapping array
    for (size_t idx = 0; idx < m_count; idx ++)
    {
        if ( 0 == _tcscmp(strInput, m_pMaps[idx].m_literal) )
        {
            // found! set enum to proper value
            m_rVal = static_cast<enum_t>(m_pMaps[idx].m_enum);
            return sc;
        }
    }
    // didn't find? - too bad
    return sc = E_INVALIDARG;
}

/***************************************************************************\
 *
 * METHOD:  CXMLEnumeration::ScWriteToBSTR
 *
 * PURPOSE: Strores (prints) value into BSTR to be used in XML document
 *
 * PARAMETERS:
 *    BSTR * pbstr [out] resulting string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLEnumeration::ScWriteToBSTR (BSTR * pbstr ) const
{
    DECLARE_SC(sc, TEXT("CXMLEnumeration::ScWriteToBSTR"));

    // parameter check
    sc = ScCheckPointers(pbstr);
    if (sc)
        return sc;

    // initialization
    *pbstr = NULL;

    // find string representation for enum
    for (size_t idx = 0; idx < m_count; idx ++)
    {
        if ( m_pMaps[idx].m_enum == (UINT)m_rVal )
        {
            // found! - return it
            *pbstr = CComBSTR(m_pMaps[idx].m_literal).Detach();
            return sc;
        }
    }

    // didn't find? - too bad
    return sc = E_INVALIDARG;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBitFlags::PersistMultipleAttributes
 *
 * PURPOSE: perists bitflags as separate attributes. These are stored as
 *          attributes of the PARENT object, using the names specified in the
 *          name map. Any unknown flags are stored in an attribute
 *          specified by the name parameter, in numerical form.
 *
 * PARAMETERS:
 *    LPCTSTR name          [in] flag name (used only for not recognized flags)
 *    CPersistor &persistor [in] persistor to perform operation on
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLBitFlags::PersistMultipleAttributes(LPCTSTR name, CPersistor &persistor)
{
    // temporaries
    UINT uiValToSave = persistor.IsStoring() ? m_rVal : 0;
    UINT uiValLoaded = 0;

    // iterate thru all the entries in the map
    for (size_t idx = 0; idx < m_count; idx ++)
    {
        UINT uiMask = m_pMaps[idx].m_enum;

        // we do only care about true flags - any nonzero value.
        if (!uiMask)
            continue;

        // initialize the value properly for storing
        // when loading (it will remain the same if attribute isn't found)
        bool bValue = false;
        if ( (uiValToSave & uiMask) == uiMask )
        {
            bValue = true;
            uiValToSave &= ~uiMask; // since we have taken care of this, remove the bits.
                                    // anything left over is saved numerically (see below)
        }

        // do not store "false" values - they are useless
        bool bNeedsPersisting = persistor.IsLoading() || bValue;

        if (bNeedsPersisting)
            persistor.PersistAttribute( m_pMaps[idx].m_literal, CXMLBoolean(bValue), attr_optional );

        uiValLoaded |= bValue ? uiMask : 0;
    }

    /* If there are any flags which do not have a corresponding text version,
       these are persisted using the original name of the attribute, with the numerical
       value of the flags*/
    UINT uiValTheRest = uiValToSave;
    bool bNeedsPersisting = persistor.IsLoading() || (uiValTheRest != 0);
    if (bNeedsPersisting)
        persistor.PersistAttribute( name, uiValTheRest, attr_optional );

    uiValLoaded |= uiValTheRest;

    if (persistor.IsLoading())
        m_rVal = uiValLoaded;
}


/***************************************************************************\
 *
 * METHOD:  CXMLBinary::CXMLBinary
 *
 * PURPOSE: default constructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CXMLBinary::CXMLBinary() :
m_Handle(NULL),
m_Size(0),
m_Locks(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::CXMLBinary
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *    HGLOBAL handle - handle to attach to
 *    size_t size    - real size of data
 *
\***************************************************************************/
CXMLBinary::CXMLBinary(HGLOBAL handle, size_t size) :
m_Handle(handle),
m_Size(size),
m_Locks(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::Attach
 *
 * PURPOSE: Attaches object to allocated data. Will free the data it already has
 *
 * PARAMETERS:
 *    HGLOBAL handle - handle to attach to
 *    size_t size    - real size of data
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLBinary::Attach(HGLOBAL handle, size_t size)
{
    DECLARE_SC(sc, TEXT("CXMLBinary::Attach"));

    sc = ScFree();
    if (sc)
        sc.TraceAndClear();

    ASSERT(m_Handle == NULL && m_Size == 0 && m_Locks == 0);
    m_Handle = handle;
    m_Size = size;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::Detach
 *
 * PURPOSE: transfers control to the caller
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HGLOBAL    - handle of allocated memory
 *
\***************************************************************************/
HGLOBAL CXMLBinary::Detach()
{
    HGLOBAL ret = m_Handle;
    m_Handle = NULL;
    m_Size = 0;
    m_Locks = 0;
    return ret;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::GetSize
 *
 * PURPOSE: returns the size of binary data
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    size_t    - size
 *
\***************************************************************************/
size_t  CXMLBinary::GetSize()   const
{
    return m_Size;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::GetHandle
 *
 * PURPOSE: returns handle to allocated memory (NULL if size is zero)
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HGLOBAL    - handle
 *
\***************************************************************************/
HGLOBAL CXMLBinary::GetHandle() const
{
    return m_Handle;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScAlloc
 *
 * PURPOSE: allocates the memory for binary data. Previosly allocated date will
 *          be fred.
 *
 * NOTE:    0 in general is a valid size, GetHandle will return NULL in that case
 *          ScLock however will fail
 *
 * PARAMETERS:
 *    size_t size   - new size of binary data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScAlloc(size_t size, bool fZeroInit /* =false */)
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScAlloc"));

    if (size == 0) // use ScFree to free the data
        return sc = E_INVALIDARG;

    sc = ScFree();
    if (sc)
        sc.TraceAndClear();

    ASSERT(m_Handle == NULL && m_Size == 0 && m_Locks == 0);

	DWORD dwFlags = GMEM_MOVEABLE;
	if (fZeroInit)
		dwFlags |= GMEM_ZEROINIT;

    m_Handle = GlobalAlloc(dwFlags, size);
    if (!m_Handle)
        return sc.FromLastError(), sc;

    m_Size = size;
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScRealloc
 *
 * PURPOSE: reallocates the data. If data is present it will be coppied over
 *
 * PARAMETERS:
 *    size_t new_size   - new binary data size
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScRealloc(size_t new_size, bool fZeroInit /* =false */)
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScRealloc"));

    if (new_size == 0) // use ScFree to fre the data
        return sc = E_INVALIDARG;

    if (m_Size == 0)  // use Alloc to allocate new data
        return sc = E_UNEXPECTED;

    ASSERT(m_Handle != NULL && m_Locks == 0);

    if (m_Handle == NULL)
        return sc = E_UNEXPECTED;

    HGLOBAL hgNew = GlobalReAlloc(m_Handle, new_size, fZeroInit ? GMEM_ZEROINIT : 0);
    if (!hgNew)
        return sc.FromLastError(), sc;

    m_Handle = hgNew;
    m_Size = new_size;
    m_Locks = 0;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScUnlock
 *
 * PURPOSE: Remove one lock from binary data
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScUnlockData() const
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScUnlockData()"));

    ASSERT(m_Handle != NULL && m_Locks != 0);

    if (!m_Locks || m_Handle == NULL)
        return sc = E_UNEXPECTED;

    GlobalUnlock(m_Handle);
    --m_Locks;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::Free
 *
 * PURPOSE: Frees data asociated with the object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
SC CXMLBinary::ScFree()
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScFree"));

    while(m_Locks)
    {
        sc = ScUnlockData();
        if (sc)
            sc.TraceAndClear();
    }

    if (m_Handle)
        GlobalFree(m_Handle);

    Detach(); // null the handle, etc.

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScLockData
 *
 * PURPOSE: Helper function used frol ScLock templates
 *
 * PARAMETERS:
 *    const void **ppData
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScLockData(const void **ppData) const
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScLockData"));

    // paramter check
    sc = ScCheckPointers(ppData);
    if (sc)
        return sc;

    // initialization
    *ppData = NULL;

    // data allocated?
    if (!m_Handle)
        return sc = E_POINTER;

    // lock
    *ppData = GlobalLock(m_Handle);

    // recheck
    if (*ppData == NULL)
        return sc.FromLastError(), sc;

    ++m_Locks; // keep count of locks

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::CXMLBinaryLock
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *    CXMLBinary& binary - object to perform locking on
 *
\***************************************************************************/
CXMLBinaryLock::CXMLBinaryLock(CXMLBinary& binary) :
m_rBinary(binary),
m_bLocked(false)
{
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::~CXMLBinaryLock
 *
 * PURPOSE: destructor; also removes existing lock
 *
 * PARAMETERS:
 *
\***************************************************************************/
CXMLBinaryLock::~CXMLBinaryLock()
{
    DECLARE_SC(sc, TEXT("CXMLBinaryLock::~CXMLBinaryLock"));

    if (m_bLocked)
    {
        sc = ScUnlock();
        if (sc)
            sc.TraceAndClear();
    }
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::ScLockWorker
 *
 * PURPOSE: type-insensitive lock method (helper)
 *
 * PARAMETERS:
 *    void **ppData - pointer to locked data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinaryLock::ScLockWorker(void **ppData)
{
    DECLARE_SC(sc, TEXT("CXMLBinaryLock::ScLockWorker"));

        if (m_bLocked)
            return sc = E_UNEXPECTED;

        sc = m_rBinary.ScLockData(reinterpret_cast<void**>(ppData));
        if (sc)
            return sc;

        m_bLocked = true;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::ScUnlock
 *
 * PURPOSE: removes the lock
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinaryLock::ScUnlock()
{
    DECLARE_SC(sc, TEXT("ScUnlock"));

    if (!m_bLocked)
        return sc = E_UNEXPECTED;

    sc = m_rBinary.ScUnlockData();
    if (sc)
        return sc;

    m_bLocked = false;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  ScGetConsoleFileChecksum
 *
 * PURPOSE: inspects the contents and validates if it looks like valid XML document
 *
 * PARAMETERS:
 *    LPCTSTR   lpszPathName - [in] path to the document
 *    bool&     bXmlBased    - [out] true if file is xml based
 *    tstring&  pstrFileCRC  - [out] crc for the file
 *
 * RETURNS:
 *    SC - error or validation result (S_OK / S_FALSE)
 *
\***************************************************************************/
SC ScGetConsoleFileChecksum(LPCTSTR lpszPathName, tstring&  strFileCRC)
{
    DECLARE_SC(sc, TEXT("ScGetConsoleFileChecksum"));

    // parameter check
    sc = ScCheckPointers(lpszPathName);
    if (sc)
        return sc;

    // init out parameters;
    strFileCRC.erase();

    // open the file
    CAutoWin32Handle shFile( CreateFile(lpszPathName, GENERIC_READ, FILE_SHARE_READ,
                                        NULL, OPEN_EXISTING, 0, NULL) );

    if ( !shFile.IsValid() )
        return sc.FromLastError();

    // we are sure here the sizeHi is zero. mapping should fail else
    DWORD dwLenHi = 0;
    DWORD dwLen = GetFileSize(shFile, &dwLenHi);

    if ( dwLenHi != 0 )
        return sc = E_OUTOFMEMORY;

    // allocate memory for whole file
    CAutoArrayPtr<BYTE> spData( new BYTE[dwLen] );
    if ( spData == NULL )
        return sc = E_OUTOFMEMORY;

    // read the file into the memory
    DWORD dwRead = 0;
    if ( TRUE != ReadFile( shFile, spData, dwLen, &dwRead, NULL ) )
        return sc.FromLastError();

    // assert all the data was read
    if ( dwRead != dwLen )
        return sc = E_UNEXPECTED;

    // calculate the crc
    ULONG init_crc = 0; /*initial crc - do not change this, or you will have different
                        checksums calculated - thus existing user data discarded */

    ULONG crc = crc32( init_crc, spData, dwLen );

    // convert
    TCHAR buff[20] = {0};
    strFileCRC = _ultot(crc, buff, 10 /*radix*/);

    // done
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScOpenDocAsStructuredStorage
 *
 * PURPOSE: Opens the file and reads the contents into the memory
 *          returns the pointer to memory based IStorage
 *
 * PARAMETERS:
 *    LPCTSTR lpszPathName [in] - file name
 *    IStorage **ppStorage [out] - pointer to IStorage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScOpenDocAsStructuredStorage(LPCTSTR lpszPathName, IStorage **ppStorage)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScOpenDocAsStructuredStorage"));

    // check out parameter
    sc = ScCheckPointers(ppStorage);
    if (sc)
        return sc;

    // init out parameter
    *ppStorage = NULL;

    // check in parameter
    sc = ScCheckPointers(lpszPathName);
    if (sc)
        return sc;

    CAutoWin32Handle hFile(CreateFile(lpszPathName, GENERIC_READ, FILE_SHARE_READ,
                                      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    if (!hFile.IsValid())
        return sc.FromLastError();

    // get file data
    ULARGE_INTEGER cbFileSize;
    cbFileSize.LowPart = GetFileSize(hFile, &cbFileSize.HighPart);

    // will not handle files bigger than 2Gb
    if (cbFileSize.HighPart)
        return E_UNEXPECTED;

    // alocate memory blob and read the data
    CXMLAutoBinary binData;
    if (cbFileSize.LowPart)
    {
        // allocate
        sc = binData.ScAlloc(cbFileSize.LowPart);
        if (sc)
            return sc;

        // get pointer to data
        CXMLBinaryLock lock(binData);
        BYTE *pData = NULL;
        sc = lock.ScLock(&pData);
        if (sc)
            return sc;

        // read file contents
        DWORD dwBytesRead = 0;
        BOOL bOK = ReadFile(hFile, pData, cbFileSize.LowPart, &dwBytesRead, NULL);
        if (!bOK)
            return sc.FromLastError();
        else if (cbFileSize.LowPart != dwBytesRead)
            return sc = E_UNEXPECTED;
    }

    // create lockbytes
    ILockBytesPtr spLockBytes;
    sc = CreateILockBytesOnHGlobal(binData.GetHandle(), TRUE, &spLockBytes);
    if(sc)
        return sc;

    // ILockBytes took control over HGLOBAL block, detach from it
    binData.Detach();

    // set correct size for data
    sc = spLockBytes->SetSize(cbFileSize);
    if(sc)
        return sc;

    // ask ole to open storage for client
    const DWORD grfMode = STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE;
    sc = StgOpenStorageOnILockBytes(spLockBytes, NULL, grfMode, NULL, 0, ppStorage);
    if(sc)
        return sc;

    // done...
    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScGetUserDataFolder
 *
 * PURPOSE: Calculates location (dir) for user data folder
 *
 * PARAMETERS:
 *    tstring& strUserDataFolder [out] - user data folder path
 *    * for instance 'E:\Documents and Settings\John\Application Data\Microsoft\MMC' *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScGetUserDataFolder(tstring& strUserDataFolder)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScGetUserDataFolder"));

    // init out parameter
    strUserDataFolder.erase();

    // get owner for error boxes
    HWND hwndOwner = IsWindowVisible(sc.GetHWnd()) ? sc.GetHWnd() : NULL;

    // get shell folder
    TCHAR szFolderPath[_MAX_PATH] = {0};
    BOOL bOK = SHGetSpecialFolderPath(hwndOwner, szFolderPath, CSIDL_APPDATA, TRUE/*fCreate*/);
    if ( !bOK )
        return sc = E_FAIL;

    // return the path;
    strUserDataFolder = szFolderPath;
    strUserDataFolder += _T('\\');
    strUserDataFolder += g_szUserDataSubFolder;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScGetUserDataPath
 *
 * PURPOSE: Calculates location (dir) for user data file by given original console path
 *
 * PARAMETERS:
 *    LPCTSTR lpstrOriginalPath [in] - original console path
 *    * for instance 'c:\my consoles\my_tool.msc' *
 *    tstring& strUserDataPath  [out] - user data file path
 *    * for instance 'E:\Documents and Settings\John\Application Data\Microsoft\MMC\my_tool.msc' *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScGetUserDataPath(LPCTSTR lpstrOriginalPath, tstring& strUserDataPath)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScGetUserDataPath"));

    // parameter check
    sc = ScCheckPointers(lpstrOriginalPath);
    if ( sc )
        return sc;

    // init out parameter
    strUserDataPath.erase();

    // get only the filename from the path
    LPCTSTR lpstrOriginalFileName = _tcsrchr( lpstrOriginalPath, _T('\\') );
    if ( lpstrOriginalFileName == NULL )
        lpstrOriginalFileName = lpstrOriginalPath;
    else
        ++lpstrOriginalFileName;

    // skip whitespaces
    while ( *lpstrOriginalFileName && _istspace(*lpstrOriginalFileName) )
        ++lpstrOriginalFileName;

    // check if the name is non-empty
    if ( !*lpstrOriginalFileName )
        return sc = E_INVALIDARG;

    // get folder
    sc = ScGetUserDataFolder(strUserDataPath);
    if (sc)
        return sc;

    // ensure mmc folder exists
    DWORD dwFileAtts = ::GetFileAttributes( strUserDataPath.c_str() );
    if ( 0 == ( dwFileAtts & FILE_ATTRIBUTE_DIRECTORY ) || (DWORD)-1 == dwFileAtts )
    {
        // create the directory
        if ( !CreateDirectory( strUserDataPath.c_str(), NULL ) )
            return sc.FromLastError();
    }

    // get the length of the file
    int iFileNameLen = _tcslen( lpstrOriginalFileName );
    int iConsoleExtensionLen = _tcslen( g_szDEFAULT_CONSOLE_EXTENSION );

    // subtract 'msc' extension if such was added
    if ( iFileNameLen > iConsoleExtensionLen ) 
    {
        if ( 0 == _tcsicmp( g_szDEFAULT_CONSOLE_EXTENSION, lpstrOriginalFileName + iFileNameLen - iConsoleExtensionLen ) )
        {
            iFileNameLen -= (iConsoleExtensionLen - 1); // will add the dot to prevent assumming the different extension
                                                        // so that a.b.msc won't have b extension after msc is removed 
        }
    }

    strUserDataPath += _T('\\');
    strUserDataPath.append( lpstrOriginalFileName, iFileNameLen ); // excludes .msc extension

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFilePersistor::GetBinaryCollection
 *
 * PURPOSE: Returns a handle to the collection of Binary elements in the specified
 *          document
 *
 * PARAMETERS:
 *    CXMLDocument&          xmlDocument : [in]: the specified console file document
 *    CXMLElementCollection& colBinary :  [out]: the collection
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleFilePersistor::GetBinaryCollection(CXMLDocument& xmlDocument, CXMLElementCollection&  colBinary)
{
    // get the root elements of the source and the destination documents
    CPersistor persistorRoot        (xmlDocument,         CXMLElement(xmlDocument        ));

    // set the navigation to loading
    persistorRoot.SetLoading(true);

    // navigate to the MMC_ConsoleFile node
    CPersistor persistorConsole        (persistorRoot,         XML_TAG_MMC_CONSOLE_FILE);

    // navigate to the binary storage node
    CPersistor persistorBinaryStorage        (persistorConsole,         XML_TAG_BINARY_STORAGE);

    // get the collection of binary objects
    persistorBinaryStorage        .GetCurrentElement().getChildrenByName(XML_TAG_BINARY, &colBinary);
}

/*+-------------------------------------------------------------------------*
 *
 * CompareStrings
 *
 * PURPOSE: Does a whitespace-insensitive, but case-SENSITIVE comparison
 *          of the two strings.
 *
 * PARAMETERS:
 *    CComBSTR&  bstr1 :
 *    CComBSTR & bstr2 :
 *
 * RETURNS:
 *    static bool : true if match. else false
 *
 *+-------------------------------------------------------------------------*/
static bool
CompareStrings(CComBSTR& bstr1, CComBSTR &bstr2)
{
    UINT length1 = bstr1.Length();
    UINT length2 = bstr2.Length();

    // the current indexes
    UINT i1 = 0;
    UINT i2 = 0;

    bool bEnd1 = false; // is the first string over?
    bool bEnd2 = false; // is the second string over?

    BSTR sz1 = bstr1;
    BSTR sz2 = bstr2;

    // either both should be null or neither should be
    if( (NULL == sz1) && (NULL==sz2) )
        return true;

    if( (NULL == sz1) || (NULL==sz2) )
        return false;

    // compare the strings
    while( (!bEnd1) || (!bEnd2) )
    {
        WCHAR ch1 = sz1[i1];
        WCHAR ch2 = sz2[i2];

        // 1. get the next non-whitespace char of the first string
        if (i1 == length1)
            bEnd1 = true;
        else
        {
            if(iswspace(ch1))
            {
                ++i1;
                continue;
            }
        }

        // 2. get the next non-whitespace char of the second string
        if (i2 == length2)
            bEnd2 = true;
        else
        {
            if(iswspace(ch2))
            {
                ++i2;
                continue;
            }
        }

        // 3. if either of the strings have ended, break. Taken care of below.
        if(bEnd1 || bEnd2)
            break;

        // 4. compare the characters (must be a case sensitive comparison)
        if(ch1 != ch2)
            return false;

        // 5. increment the counters
        ++i1;
        ++i2;
    }

    // both strings should have ended together for a match
    if(bEnd1 && bEnd2)
        return true;

    return false;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFilePersistor::ScCompressUserStateFile
 *
 * PURPOSE: Compresses the user-state console file to avoid redundancies. Most of a
 *          console file's size is in the binary elements. These are also usually the
 *          least likely to change in user mode. For instance, the console file icons
 *          and console task icons cannot be changed in user mode.
 *
 *          Therefore, the compression algorithm iterates through all <BINARY> elements
 *          in the user state file, and looks for matches in the original console file.
 *          If a <BINARY> element has the same contents as a <BINARY> element in the
 *          original console file, the contents are replaced by a SourceIndex attribute
 *          that gives the index of the matching <BINARY> element in the source.
 *          This usually results in a >80% reduction of user state file size.
 *
 * PARAMETERS:
 *    LPCTSTR        szConsoleFilePath : [IN]: the (authored) console file path
 *    CXMLDocument & xmlDocument : [IN/OUT]: The user state document, which is compressed
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleFilePersistor::ScCompressUserStateFile(LPCTSTR szConsoleFilePath, CXMLDocument & xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScCompressUserStateFile"));

    sc = ScCheckPointers(szConsoleFilePath);
    if(sc)
        return sc;

    CXMLDocument xmlDocumentOriginal; // the original file
    sc = xmlDocumentOriginal.ScCoCreate( false/*bPutHeader*/ ); // initialize it.
    if(sc)
        return sc;

    sc = /*CConsoleFilePersistor::*/ScLoadXMLDocumentFromFile(xmlDocumentOriginal, szConsoleFilePath, true /*bSilentOnErrors*/);
    if(sc)
    {
        // ignore the error - this just means that original console is not 
        // an XML based - we are not able to compress it - not an error
        sc.Clear();
        return sc;
    }

    try
    {
        // get the collection of Binary tags
        CXMLElementCollection colBinaryOrignal, colBinary;
        GetBinaryCollection(xmlDocumentOriginal, colBinaryOrignal);
        GetBinaryCollection(xmlDocument,         colBinary);

        long cItemsOriginal = 0;
        long cItems         = 0;

        colBinaryOrignal.get_count(&cItemsOriginal);
        colBinary       .get_count(&cItems);

        // look for matches
        for(int i = 0; i< cItems; i++)
        {
            CXMLElement elemBinary = NULL;
            colBinary.item(i, &elemBinary); // get the i'th Binary element in the dest. file
            CComBSTR bstrBinary;
            elemBinary.get_text(bstrBinary);

            for(int j = 0; j< cItemsOriginal; j++)
            {
                CXMLElement elemBinaryOriginal = NULL;
                colBinaryOrignal.item(j, &elemBinaryOriginal); // get the j'th Binary element in the dest. file
                CComBSTR bstrBinaryOriginal;
                elemBinaryOriginal.get_text(bstrBinaryOriginal);

                // compare
                if(CompareStrings(bstrBinaryOriginal, bstrBinary))
                {
                    // yahoo!! compress.
                    Trace(tagXMLCompression, TEXT("Found match!"));

                    // 1. nuke the contents
                    elemBinary.put_text(NULL); // NULL is a valid value for a BSTR

                    CStr strValue;
                    strValue.Format(TEXT("%d"), j);

                    // 2. set the contents
                    elemBinary.setAttribute(XML_ATTR_SOURCE_INDEX, CComBSTR(strValue));

                    // done.
                    break;
                }
            }
        }
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }



    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFilePersistor::ScUncompressUserStateFile
 *
 * PURPOSE: Uncompresses user data files that were compressed by ScCompressUserStateFile.
 *          Applies the compression algorithm in reverse.
 *
 * PARAMETERS:
 *    CXMLDocument & xmlDocumentOriginal :
 *    CXMLDocument&  xmlDocument :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleFilePersistor::ScUncompressUserStateFile(CXMLDocument &xmlDocumentOriginal, CXMLDocument& xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScUncompressUserStateFile"));

    try
    {
        // get the collection of Binary tags
        CXMLElementCollection colBinaryOrignal, colBinary;
        GetBinaryCollection(xmlDocumentOriginal, colBinaryOrignal);
        GetBinaryCollection(xmlDocument,         colBinary);

        long cItems         = 0;

        colBinary       .get_count(&cItems);

        // decompress each item in colBinary
        for(int i = 0; i< cItems; i++)
        {
            CXMLElement elemBinary = NULL;
            colBinary.item(i, &elemBinary); // get the i'th Binary element in the dest. file

            CComBSTR bstrSourceIndex;

            if(elemBinary.getAttribute(XML_ATTR_SOURCE_INDEX, bstrSourceIndex))
            {
                int j = _wtoi(bstrSourceIndex);

                CXMLElement elemBinaryOriginal;
                colBinaryOrignal.item(j, &elemBinaryOriginal); // get the j'th Binary element in the dest. file
                CComBSTR bstrBinaryOriginal;
                elemBinaryOriginal.get_text(bstrBinaryOriginal);

                // replace the destination binary contents (which should be empty) with the original.
                elemBinary.put_text(bstrBinaryOriginal);

                // don't need to delete the SourceIndex attribute because the xmlDocument is thrown away after reading it in.
            }
        }
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScLoadConsole
 *
 * PURPOSE: Loads the mmc console from file
 *
 * PARAMETERS:
 *    LPCTSTR lpstrConsolePath      [in] path, where the console resides.
 *    bool& bXmlBased               [out] whether document is XML-based
 *    CXMLDocument& xmlDocument     [out] xmlDocument containing data (only if xml-Based)
 *    IStorage **ppStorage          [out] storage containing data(only if non xml-Based)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScLoadConsole(LPCTSTR lpstrConsolePath, bool& bXmlBased,
                                        CXMLDocument& xmlDocument, IStorage **ppStorage)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScLoadConsole"));

    // parameter check
    sc = ScCheckPointers(lpstrConsolePath, ppStorage);
    if (sc)
        return sc;

    // init out parameters
    bXmlBased = false;
    *ppStorage = NULL;

    // Create an empty XML document
    CXMLDocument xmlOriginalDoc;
    sc = xmlOriginalDoc.ScCoCreate(false/*bPutHeader*/);
    if(sc)
        return sc;

    //  inspect original console file by trying to load XML document
    bool bOriginalXmlBased = false;
    sc = ScLoadXMLDocumentFromFile(xmlOriginalDoc, lpstrConsolePath, true /*bSilentOnErrors*/);
    if( !sc.IsError() )
        bOriginalXmlBased = true;

    sc.Clear(); // ignore the error - assume it is not XML based

    // test it is not a user data which is being opened - cannot be so!
    if ( bOriginalXmlBased )
    {
        try
        {
            // construct persistor
            CPersistor persistor(xmlOriginalDoc, CXMLElement(xmlOriginalDoc));
            persistor.SetLoading(true);

            // navigate to CRC storage
            CPersistor persistorConsole( persistor, XML_TAG_MMC_CONSOLE_FILE );
            if ( persistorConsole.HasElement(XML_TAG_ORIGINAL_CONSOLE_CRC, NULL) )
                return sc = E_UNEXPECTED;
        }
        catch(SC sc_thrown)
        {
            return sc = sc_thrown;
        }
    }

    tstring strFileCRC;
    sc = ScGetConsoleFileChecksum( lpstrConsolePath, strFileCRC );
    if (sc)
        return sc;

    // store data to be used for saving
    m_strFileCRC = strFileCRC;
    m_bCRCValid = true;

    // get the path to user data
    tstring strUserDataPath;
    sc = ScGetUserDataPath( lpstrConsolePath, strUserDataPath);
    if (sc)
    {
        // don't fail - trace only - missing user data not a reason to fail loading
        sc.TraceAndClear();
    }

    // go get the user data
    bool bValidUserData = false;
    sc = ScGetUserData( strUserDataPath, strFileCRC, bValidUserData, xmlDocument );
    if (sc)
    {
        // don't fail - trace only - missing user data not a reason to fail loading
        bValidUserData = false;
        sc.TraceAndClear();
    }

    // user data loaded?
    if (bValidUserData)
    {

        // uncompress the user data if the original was XML
        if(bOriginalXmlBased)
        {
            sc = ScUncompressUserStateFile(xmlOriginalDoc, xmlDocument);
            if(sc)
                return sc;
        }

        // done, just return the staff
        bXmlBased = true; // user data always is XML
        // pxmlDocument is already updated by ScGetUserData
        return sc;
    }

    // no luck with user data, lets load the original file

    // XML contents
    if ( bOriginalXmlBased )
    {
        // return the data
        bXmlBased = true;
        xmlDocument = xmlOriginalDoc;

        return sc;
    }

    // old, ole-storage based file:
    sc = ScOpenDocAsStructuredStorage( lpstrConsolePath, ppStorage );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScGetUserData
 *
 * PURPOSE: inspects if user data matches console file, loads the xml document if it does
 *
 * PARAMETERS:
 *    tstring& strUserDataConsolePath   [in] - path to the user data
 *    const tstring& strFileCRC,        [in] - crc of original console file
 *    bool& bValid                      [out] - if user data is valid
 *    CXMLDocument& xmlDocument         [out] - loaded document (only if valid)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScGetUserData(const tstring& strUserDataConsolePath, const tstring& strFileCRC,
                                        bool& bValid, CXMLDocument& xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScGetUserData"));

    // assume invalid initially
    bValid = false;

    // check if user file exist
    DWORD dwFileAtts = ::GetFileAttributes( strUserDataConsolePath.c_str() );

    // if file is missing dwFileAtts will be -1, so bValidUserData will be eq. to false
    bool bValidUserData = ( ( dwFileAtts & FILE_ATTRIBUTE_DIRECTORY ) == 0 );
    if ( !bValidUserData )
        return sc;

    // Create an empty XML document
    CXMLDocument xmlDoc;
    sc = xmlDoc.ScCoCreate( false/*bPutHeader*/ );
    if(sc)
        return sc;

    // upload the data
    sc = ScLoadXMLDocumentFromFile( xmlDoc, strUserDataConsolePath.c_str() );
    if(sc)
        return sc;

    // get the CRC
    try
    {
        CPersistor persistor(xmlDoc, CXMLElement(xmlDoc));
        persistor.SetLoading(true);

        // navigate to CRC storage
        CPersistor persistorConsole( persistor, XML_TAG_MMC_CONSOLE_FILE );
        CPersistor persistorCRC( persistorConsole, XML_TAG_ORIGINAL_CONSOLE_CRC );

        tstring strCRC;
        persistorCRC.PersistContents(strCRC);

        // valid if CRC matches
        if ( strCRC == strFileCRC )
        {
            // return the document
            bValid = true;

            xmlDocument = xmlDoc;
        }
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}



/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScSaveConsole
 *
 * PURPOSE: Saves console to file
 *
 * PARAMETERS:
 *    LPCTSTR lpstrConsolePath          [in] - console file path
 *    bool bForAuthorMode               [in] - if console was authored
 *    const CXMLDocument& xmlDocument   [in] - document conatining data to be saved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScSaveConsole(LPCTSTR lpstrConsolePath, bool bForAuthorMode, const CXMLDocument& xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScSaveConsole"));

    // parameter check
    sc = ScCheckPointers( lpstrConsolePath );
    if (sc)
        return sc;

    // sanity check - if saving in user mode, have to be loaded from file.
    // To save in user mode CRC of the original document must be known.
    // It is calculated on loading, but seems like loading was never done.
    if ( !bForAuthorMode && !m_bCRCValid )
        return sc = E_UNEXPECTED;

    // prepare data for save
    tstring         strDestinationFile( lpstrConsolePath );
    CXMLDocument    xmlDocumentToSave( xmlDocument );

    // need to modify slightly if saving just the user data
    if ( !bForAuthorMode )
    {
        // get user data file path
        sc = ScGetUserDataPath( lpstrConsolePath, strDestinationFile );
        if (sc)
            return sc;

        // optimize the file to be saved, to remove redundancies
        sc = ScCompressUserStateFile(lpstrConsolePath, xmlDocumentToSave);
        if(sc)
            return sc;

        // add crc to the document
        try
        {
            CPersistor persistor(xmlDocumentToSave, CXMLElement(xmlDocumentToSave));
            persistor.SetLoading(true); // navigate like 'loading'

            // navigate to CRC storage
            CPersistor persistorConsole( persistor, XML_TAG_MMC_CONSOLE_FILE );

            // create the crc record
            persistorConsole.SetLoading(false);
            CPersistor persistorCRC( persistorConsole, XML_TAG_ORIGINAL_CONSOLE_CRC );

            // save data
            persistorCRC.PersistContents( m_strFileCRC );
        }
        catch(SC sc_thrown)
        {
            return sc = sc_thrown;
        }
    }

    // save document contents
    sc = xmlDocumentToSave.ScSaveToFile( strDestinationFile.c_str() );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScLoadXMLDocumentFromFile
 *
 * PURPOSE: reads CXMLDocument contents from file
 *
 * PARAMETERS:
 *    CXMLDocument& xmlDocument [out] document to be receive contents
 *    LPCTSTR szFileName        [in]  source file name
 *    bool bSilentOnErrors      [in]  if true - does not trace opennning errors
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScLoadXMLDocumentFromFile(CXMLDocument& xmlDocument, LPCTSTR szFileName, bool bSilentOnErrors /*= false*/)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScLoadXMLDocumentFromFile"));

    // read data
    CXMLAutoBinary binData;
    sc = ScReadDataFromFile(szFileName, &binData);
    if (sc)
        return sc;

    // create stream - NOTE it will take care of HGLOBAL if succeeds
    IStreamPtr spStream;
    sc = CreateStreamOnHGlobal(binData.GetHandle(), TRUE, &spStream);
    if (sc)
        return sc;

    const ULARGE_INTEGER new_size = { binData.GetSize(), 0 };
    binData.Detach(); // not the owner anymore (IStream took ownership)

    sc = ScCheckPointers(spStream, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spStream->SetSize(new_size);
    if (sc)
        return sc;

    // load data (do not trace by default - it is used to inspect the document as well)
    SC sc_no_trace = xmlDocument.ScLoad(spStream, bSilentOnErrors);
    if(sc_no_trace)
    {
        if ( !bSilentOnErrors )
            sc = sc_no_trace;
        return sc_no_trace;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helpsvcs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Oct 02 14:40:12 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HELPSVCS.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __HelpSvcs_h__
#define __HelpSvcs_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __VsHelpServices_FWD_DEFINED__
#define __VsHelpServices_FWD_DEFINED__

#ifdef __cplusplus
typedef class VsHelpServices VsHelpServices;
#else
typedef struct VsHelpServices VsHelpServices;
#endif /* __cplusplus */

#endif 	/* __VsHelpServices_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "helpsys.h"
#include "helpinit.h"
#include "helputil.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __VsHelpServices_LIBRARY_DEFINED__
#define __VsHelpServices_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: VsHelpServices
 * at Thu Oct 02 14:40:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_VsHelpServices;

EXTERN_C const CLSID CLSID_VsHelpServices;

#ifdef __cplusplus

class DECLSPEC_UUID("854d7ac5-bc3d-11d0-b421-00a0c90f9dc4")
VsHelpServices;
#endif
#endif /* __VsHelpServices_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\core\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.3, July 9th, 1998

  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.3"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helpinit.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Oct 02 14:40:08 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HelpInit.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HelpInit_h__
#define __HelpInit_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpInit_FWD_DEFINED__
#define __IVsHelpInit_FWD_DEFINED__
typedef interface IVsHelpInit IVsHelpInit;
#endif 	/* __IVsHelpInit_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IVsHelpInit_INTERFACE_DEFINED__
#define __IVsHelpInit_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpInit
 * at Thu Oct 02 14:40:08 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac3-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpInit : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOwner( 
            /* [in] */ const HWND hwndOwner) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadUIResources( 
            /* [in] */ LCID lcidResources) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCollection( 
            /* [in] */ LPCOLESTR pszCollectionPathname,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetApplicationHelpDirectory( 
            /* [in] */ LPCOLESTR pszHelpDirectory,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetApplicationHelpLCID( 
            /* [in] */ LCID lcidCollection,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpInit __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOwner )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ const HWND hwndOwner);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadUIResources )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LCID lcidResources);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCollection )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszCollectionPathname,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationHelpDirectory )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszHelpDirectory,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationHelpLCID )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LCID lcidCollection,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IVsHelpInitVtbl;

    interface IVsHelpInit
    {
        CONST_VTBL struct IVsHelpInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpInit_SetOwner(This,hwndOwner)	\
    (This)->lpVtbl -> SetOwner(This,hwndOwner)

#define IVsHelpInit_LoadUIResources(This,lcidResources)	\
    (This)->lpVtbl -> LoadUIResources(This,lcidResources)

#define IVsHelpInit_SetCollection(This,pszCollectionPathname,dwReserved)	\
    (This)->lpVtbl -> SetCollection(This,pszCollectionPathname,dwReserved)

#define IVsHelpInit_SetApplicationHelpDirectory(This,pszHelpDirectory,dwReserved)	\
    (This)->lpVtbl -> SetApplicationHelpDirectory(This,pszHelpDirectory,dwReserved)

#define IVsHelpInit_SetApplicationHelpLCID(This,lcidCollection,dwReserved)	\
    (This)->lpVtbl -> SetApplicationHelpLCID(This,lcidCollection,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetOwner_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ const HWND hwndOwner);


void __RPC_STUB IVsHelpInit_SetOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_LoadUIResources_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LCID lcidResources);


void __RPC_STUB IVsHelpInit_LoadUIResources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetCollection_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszCollectionPathname,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpInit_SetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetApplicationHelpDirectory_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszHelpDirectory,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpInit_SetApplicationHelpDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetApplicationHelpLCID_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LCID lcidCollection,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpInit_SetApplicationHelpLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpInit_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helputil.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Oct 02 14:40:10 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HelpUtil.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HelpUtil_h__
#define __HelpUtil_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpUtilities_FWD_DEFINED__
#define __IVsHelpUtilities_FWD_DEFINED__
typedef interface IVsHelpUtilities IVsHelpUtilities;
#endif 	/* __IVsHelpUtilities_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IVsHelpUtilities_INTERFACE_DEFINED__
#define __IVsHelpUtilities_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpUtilities
 * at Thu Oct 02 14:40:10 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac9-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpUtilities : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BuildFullPathName( 
            /* [in] */ LPCOLESTR pszHelpFileName,
            /* [out] */ BSTR __RPC_FAR *bstrHelpFullPathName,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpUtilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpUtilities __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpUtilities __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpUtilities __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BuildFullPathName )( 
            IVsHelpUtilities __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszHelpFileName,
            /* [out] */ BSTR __RPC_FAR *bstrHelpFullPathName,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IVsHelpUtilitiesVtbl;

    interface IVsHelpUtilities
    {
        CONST_VTBL struct IVsHelpUtilitiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpUtilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpUtilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpUtilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpUtilities_BuildFullPathName(This,pszHelpFileName,bstrHelpFullPathName,dwReserved)	\
    (This)->lpVtbl -> BuildFullPathName(This,pszHelpFileName,bstrHelpFullPathName,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpUtilities_BuildFullPathName_Proxy( 
    IVsHelpUtilities __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszHelpFileName,
    /* [out] */ BSTR __RPC_FAR *bstrHelpFullPathName,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpUtilities_BuildFullPathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpUtilities_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helpsys.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Wed Nov 19 15:26:49 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HelpSys.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HelpSys_h__
#define __HelpSys_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpSystem_FWD_DEFINED__
#define __IVsHelpSystem_FWD_DEFINED__
typedef interface IVsHelpSystem IVsHelpSystem;
#endif 	/* __IVsHelpSystem_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_HelpSys_0000
 * at Wed Nov 19 15:26:49 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


typedef /* [v1_enum] */ 
enum _VHS_COMMANDS
    {	VHS_Default	= 0,
	VHS_NoErrorMessages	= 0x8,
	VHS_UseBrowser	= 0x1,
	VHS_UseHelp	= 0x2,
	VHS_Localize	= 0x4
    }	VHS_COMMAND;



extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0000_v0_0_s_ifspec;

#ifndef __IVsHelpSystem_INTERFACE_DEFINED__
#define __IVsHelpSystem_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpSystem
 * at Wed Nov 19 15:26:49 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac0-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearch( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ALinkSearch( 
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearchDlg( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FullTextSearchDlg( 
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentURL( 
            /* [out] */ BSTR __RPC_FAR *ppszURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromURL( 
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromIdentifier( 
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD Id,
            /* [in] */ const DWORD Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ActivateHelpSystem( 
            /* [in] */ const DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpSystem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpSystem __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeywordSearch )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ALinkSearch )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeywordSearchDlg )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FullTextSearchDlg )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentURL )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *ppszURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromURL )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromIdentifier )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD Id,
            /* [in] */ const DWORD Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ActivateHelpSystem )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ const DWORD dwFlags);
        
        END_INTERFACE
    } IVsHelpSystemVtbl;

    interface IVsHelpSystem
    {
        CONST_VTBL struct IVsHelpSystemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpSystem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpSystem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpSystem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpSystem_KeywordSearch(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearch(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_ALinkSearch(This,pszALink,dwFlags,dwReserved)	\
    (This)->lpVtbl -> ALinkSearch(This,pszALink,dwFlags,dwReserved)

#define IVsHelpSystem_KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)	\
    (This)->lpVtbl -> FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)

#define IVsHelpSystem_GetCurrentURL(This,ppszURL)	\
    (This)->lpVtbl -> GetCurrentURL(This,ppszURL)

#define IVsHelpSystem_DisplayTopicFromURL(This,pszURL,Command)	\
    (This)->lpVtbl -> DisplayTopicFromURL(This,pszURL,Command)

#define IVsHelpSystem_DisplayTopicFromIdentifier(This,pszFile,Id,Command)	\
    (This)->lpVtbl -> DisplayTopicFromIdentifier(This,pszFile,Id,Command)

#define IVsHelpSystem_ActivateHelpSystem(This,dwFlags)	\
    (This)->lpVtbl -> ActivateHelpSystem(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearch_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ALinkSearch_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszALink,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_ALinkSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearchDlg_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_FullTextSearchDlg_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszQuery,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_FullTextSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_GetCurrentURL_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *ppszURL);


void __RPC_STUB IVsHelpSystem_GetCurrentURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromURL_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszURL,
    /* [in] */ const DWORD Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromIdentifier_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFile,
    /* [in] */ const DWORD Id,
    /* [in] */ const DWORD Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ActivateHelpSystem_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ const DWORD dwFlags);


void __RPC_STUB IVsHelpSystem_ActivateHelpSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpSystem_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_HelpSys_0136
 * at Wed Nov 19 15:26:49 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SVsHelpService IID_IVsHelpSystem
#define SID_SHelpService IID_IVsHelpSystem

enum VsHelpErrors
    {	VSHELP_E_HTMLHELP_UNKNOWN	= 0x80000000 | 4 << 16 | 0x1000,
	VSHELP_E_COLLECTIONDOESNOTEXIST	= 0x80000000 | 4 << 16 | 0x1001,
	VSHELP_E_COLLECTIONNOTREGISTERED	= 0x80000000 | 4 << 16 | 0x1002,
	VSHELP_E_REGISTRATION	= 0x80000000 | 4 << 16 | 0x1003,
	VSHELP_E_PREFERREDCOLLECTION	= 0x80000000 | 4 << 16 | 0x1004
    };


extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\setup\vbsnapcleanup\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$O\amc.res: ..\..\types\idl\websnk.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98\inc\ad98.h ===
//=--------------------------------------------------------------------------=
// AD98.H
//=--------------------------------------------------------------------------=
// Copyright (c) 1997-1998, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
// ActiveX[tm] Designer interfaces that are new for 1998.
//=--------------------------------------------------------------------------=
#ifndef _AD98_H_
#define _AD98_H_

#include "designer.h"

//=--------------------------------------------------------------------------=
// DesignerFeatures
//=--------------------------------------------------------------------------=
#define DESIGNERFEATURE_CANBEPUBLIC             0x00000001
#define DESIGNERFEATURE_MUSTBEPUBLIC            0x00000002
#define DESIGNERFEATURE_CANCREATE               0x00000004
#define DESIGNERFEATURE_PREDECLAREDID           0x00000008
#define DESIGNERFEATURE_DONTSITE                0x00000010
#define DESIGNERFEATURE_REGISTRATION            0x00000020
#define DESIGNERFEATURE_INPROCONLY              0x00000040
#define DESIGNERFEATURE_DELAYEVENTSINKING       0x00000080
#define DESIGNERFEATURE_NOTIFYBEFORERUN         0x00000100
#define DESIGNERFEATURE_NOTIFYAFTERRUN          0x00000200
#define DESIGNERFEATURE_STARTUPINFO             0x00000400

//=--------------------------------------------------------------------------=
// CATID_DesignerStatus
//=--------------------------------------------------------------------------=
DEFINE_GUID(CATID_DesignerFeatures, 0x3831d1b0, 0xef3a, 0x11d0, 0x94, 0xce, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);


//=--------------------------------------------------------------------------=
// Designer Ambients Property
//
//   DISPID_AMBIENT_CLSID     - CLSID of public designer object
//   DISPID_AMBIENT_SAVDEMODE - Ambient indicating where the designer is
//      being saved:
//          DESIGNERSAVEMODE_NORMAL     (user's project file),
//          DESIGNERSAVEMODE_EXE        (EXE or DLL file), 
//          DESIGNERSAVEMODE_TEMPORARY  (temp file for running in the IDE)
//      The value of this ambient property is valid only during the call
//      to IPersist[Stream|PropertyBag|etc.]::Save on the designer.
//=--------------------------------------------------------------------------=
#define DISPID_AMBIENT_CLSID                   (-740)
#define DISPID_AMBIENT_SAVEMODE                (-741)
#define DISPID_AMBIENT_PROGID                  (-742)
#define DISPID_AMBIENT_PROJECTDIRECTORY        (-743)
#define DISPID_AMBIENT_BUILDDIRECTORY          (-744)
#define DISPID_AMBIENT_INTERACTIVE             (-745)

#define DESIGNERSAVEMODE_NORMAL                 0
#define DESIGNERSAVEMODE_EXE                    1
#define DESIGNERSAVEMODE_TEMPORARY              2


//=--------------------------------------------------------------------------=
// IDesignerRegistration
//=--------------------------------------------------------------------------=

#define DESIGNERREGFLAG_INPROCSERVER    0x00000001
#define DESIGNERREGFLAG_LOCALSERVER     0x00000002

// DESIGNERREGINFO
typedef struct tagDESIGNERREGINFO
{
    ULONG     cb;
    DWORD     dwFlags;
    LPCOLESTR pszProgID;
    CLSID     clsid;
    GUID      guidTypeLib;
    WORD      wVerMajor;
    WORD      wVerMinor;
    BYTE *    rgbRegInfo;
} DESIGNERREGINFO;

// 48d36f82-e8c2-11d0-94c4-00a0c91110ed
DEFINE_GUID(IID_IDesignerRegistration, 0x48d36f82, 0xe8c2, 0x11d0, 0x94, 0xc4, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#undef  INTERFACE
#define INTERFACE IDesignerRegistration

DECLARE_INTERFACE_(IDesignerRegistration, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerRegistration
    STDMETHOD(GetRegistrationInfo)(THIS_ BYTE** ppbRegInfo, ULONG* pcbRegInfo) PURE;
};

//=--------------------------------------------------------------------------=
// IDesignerDebugging
//=--------------------------------------------------------------------------=

#define DESIGNERSTARTUPINFO_URL     0x00000001
#define DESIGNERSTARTUPINFO_EXE     0x00000002

typedef struct tagDESIGNERSTARTUPINFO
{
    ULONG cb;
    DWORD dwStartupFlags;
    BSTR  bstrStartupData;
} DESIGNERSTARTUPINFO;

// 48d36f83-e8c2-11d0-94c4-00a0c91110ed
DEFINE_GUID(IID_IDesignerDebugging, 0x48d36f83, 0xe8c2, 0x11d0, 0x94, 0xc4, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#undef  INTERFACE
#define INTERFACE IDesignerDebugging

DECLARE_INTERFACE_(IDesignerDebugging, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerDebugging methods
    STDMETHOD(BeforeRun)(LPVOID FAR* ppvData) PURE;
    STDMETHOD(AfterRun)(LPVOID pvData) PURE;
    STDMETHOD(GetStartupInfo)(THIS_ DESIGNERSTARTUPINFO * pStartupInfo) PURE;
};

//=--------------------------------------------------------------------------=
// CF_CLSID, CF_DESIGNERTOOLBOXITEM, and CF_CLSIDCLASSNAME
//=--------------------------------------------------------------------------=
#ifndef CF_CLSID
#define CF_CLSID                "CLSID"
#endif
#define CF_DESIGNERTOOLBOXITEM  "DesignerToolboxItem"
#define CF_CLSIDCLASSNAME	"ClsdIdClassName"

//=--------------------------------------------------------------------------=
// IDesignerToolbox
//=--------------------------------------------------------------------------=

// 48d36f85-e8c2-11d0-94c4-00a0c91110ed
DEFINE_GUID(IID_IDesignerToolbox, 0x48d36f85, 0xe8c2, 0x11d0, 0x94, 0xc4, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#undef  INTERFACE
#define INTERFACE IDesignerToolbox

DECLARE_INTERFACE_(IDesignerToolbox, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerToolbox methods
    STDMETHOD(IsSupported)(THIS_ IDataObject* pdo) PURE;
    STDMETHOD(ItemPicked)(THIS_ IDataObject* pdo) PURE;
    STDMETHOD(GetControlsInUse)(THIS_ DWORD * pcControls, CLSID ** prgClsid) PURE;
};

//=--------------------------------------------------------------------------=
// IDesignerToolboxSite
//=--------------------------------------------------------------------------=

// 06d1e0a0-fc81-11d0-94dd-00a0c91110ed
DEFINE_GUID(IID_IDesignerToolboxSite, 0x06d1e0a0, 0xfc81, 0x11d0, 0x94, 0xdd, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#define SID_DesignerToolboxSite IID_IDesignerToolboxSite

#undef  INTERFACE
#define INTERFACE IDesignerToolboxSite

DECLARE_INTERFACE_(IDesignerToolboxSite, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerToolboxSite methods
    STDMETHOD(GetData)(THIS_ IDataObject** ppdo) PURE;
    STDMETHOD(OnItemPicked)(THIS) PURE;
    STDMETHOD(AddControl)(THIS_ REFCLSID rclsid) PURE;
};


//=--------------------------------------------------------------------------=
// IDesignerProgrammability
//=--------------------------------------------------------------------------=

// 06d1e0a1-fc81-11d0-94dd-00a0c91110ed
DEFINE_GUID(IID_IDesignerProgrammability, 0x06d1e0a1, 0xfc81, 0x11d0, 0x94, 0xdd, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#define SID_DesignerProgrammability IID_IDesignerProgrammability

#undef  INTERFACE
#define INTERFACE IDesignerProgrammability

DECLARE_INTERFACE_(IDesignerProgrammability, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerProgrammability methods
    STDMETHOD(IsValidIdentifier)(THIS_ LPCOLESTR pszId) PURE;
    STDMETHOD(IsValidEventName)(THIS_ LPCOLESTR pszEvent) PURE;
    STDMETHOD(MakeValidIdentifier)(THIS_ LPCOLESTR pszId, LPOLESTR * ppszValidId) PURE;
};

//=--------------------------------------------------------------------------=
// IActiveDesignerRuntimeSite
//=--------------------------------------------------------------------------=
DEFINE_GUID(IID_IActiveDesignerRuntimeSite, 0xcf2abba0, 0x9450, 0x11d1, 0x89, 0x34, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x49);

#undef  INTERFACE
#define INTERFACE IActiveDesignerRuntimeSite

DECLARE_INTERFACE_(IActiveDesignerRuntimeSite, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    STDMETHOD(GetAdviseSink)(THIS_ MEMBERID memid, IUnknown ** ppunkSink) PURE;
};

//=--------------------------------------------------------------------------=
// IActiveDesignerRuntime
//=--------------------------------------------------------------------------=
DEFINE_GUID(IID_IActiveDesignerRuntime, 0xcf2abba1, 0x9450, 0x11d1, 0x89, 0x34, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x49);

#undef  INTERFACE
#define INTERFACE IActiveDesignerRuntime

DECLARE_INTERFACE_(IActiveDesignerRuntime, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IActiveDesignerRuntime
    STDMETHOD(SetSite)(THIS_ IActiveDesignerRuntimeSite * pSite) PURE;
};

#endif // _AD98_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\setup\vbsnapcleanup\vbsnapcleanup.cpp ===
#include <windows.h>
#include <tchar.h>
#include <atlbase.h>
#include <atlimpl.cpp>

#define CLSID_LENGTH   256
#define MAX_PATH_LEN   2048

const CHAR  g_MMCVBSnapinsKey[] = "Software\\Microsoft\\Visual Basic\\6.0\\SnapIns";
const CHAR  g_MMCKey[]          = "Software\\Microsoft\\MMC";
const CHAR  g_SnapIns[]         = "SnapIns";
const CHAR  g_NodeTypes[]       = "NodeTypes";

// Remove the MMC VB snapin entries from the registry
int __cdecl main(int argc, char* argv[])
{
    HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
        return 0;

    BOOL bOleInitialized = TRUE;

    do
    {
        // Open HKLM\Software\Microsoft\Visual Basic\6.0\SnapIns.
        LONG lRetVal = 0;
        ATL::CRegKey regVBSnapinsKey;
        lRetVal = regVBSnapinsKey.Open(HKEY_LOCAL_MACHINE, g_MMCVBSnapinsKey, KEY_READ);

        // If no VB Snapins then return.
        if (ERROR_SUCCESS != lRetVal)
            break;

        ATL::CRegKey regCLSIDKey;
        lRetVal = regCLSIDKey.Open(HKEY_CLASSES_ROOT, "CLSID");
        ATLASSERT(ERROR_SUCCESS == lRetVal);
        if (ERROR_SUCCESS != lRetVal)
            break;

        ATL::CRegKey regMMCKey;
        // Open the other required keys.
        lRetVal = regMMCKey.Open(HKEY_LOCAL_MACHINE, g_MMCKey, KEY_READ | KEY_WRITE);
        // If MMC Key remove VB Snapins key.
        if (ERROR_SUCCESS != lRetVal)
        {
            // BUGBUG
            break;
        }

        // Enumerate the regVBSnapinsKey, this yields NodeTypeGuid key with
        // default value as snapin class id.
        CHAR  szNodeType[CLSID_LENGTH];
        CHAR  szClsid[CLSID_LENGTH];
        DWORD dwLength;

        for (DWORD dwIndex = 0; TRUE; dwIndex++)
        {
            lRetVal = RegEnumKeyEx( (HKEY)regVBSnapinsKey, 0, szNodeType, &dwLength, NULL, NULL, NULL, NULL);
            if ( (lRetVal == ERROR_NO_MORE_ITEMS) ||
                 (lRetVal != ERROR_SUCCESS) )
                 break;

            // Got the NodeTypeGuid value, now open that key.
            ATL::CRegKey regTempKey;
            lRetVal = regTempKey.Open((HKEY)regVBSnapinsKey, szNodeType, KEY_READ);
            if (ERROR_SUCCESS != lRetVal)
                continue;

            // Read the default value (Snapin CLSID).
			dwLength = CLSID_LENGTH;
            lRetVal = regTempKey.QueryValue(szClsid, NULL, &dwLength);
            if (ERROR_SUCCESS != lRetVal)
                continue;


#if 0 // Disable this code for this release
			// Now we have the snapin class id
			// Find the inproc server, Load it and call its DllUnRegisterServer
			lRetVal = regTempKey.Open((HKEY) regCLSIDKey, szClsid, KEY_READ);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

			lRetVal = regTempKey.Open((HKEY) regTempKey,  TEXT("InprocServer32"), KEY_READ);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

			TCHAR szPath[MAX_PATH_LEN];
			dwLength = MAX_PATH_LEN;
			lRetVal = regTempKey.QueryValue(szPath, NULL, &dwLength);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

			HINSTANCE hInstance = LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
			if (hInstance && bOleInitialized)
			{
				HRESULT (STDAPICALLTYPE* lpDllEntryPoint)(void);
				(FARPROC&) lpDllEntryPoint = GetProcAddress(hInstance, "DllUnregisterServer");
				if (lpDllEntryPoint)
					hr = (*lpDllEntryPoint)();

				FreeLibrary(hInstance);
			}
#endif // #if 0

            // Now we have snapin class id and nodetype guid. Delete them under mmc key.
            lRetVal = regTempKey.Open((HKEY) regMMCKey, g_NodeTypes);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

            regTempKey.RecurseDeleteKey(szNodeType);

            lRetVal = regTempKey.Open((HKEY) regMMCKey, g_SnapIns);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;
            regTempKey.RecurseDeleteKey(szClsid);
            regCLSIDKey.RecurseDeleteKey(szClsid);

            // Finally delete the key under enumerator
            regVBSnapinsKey.RecurseDeleteKey(szNodeType);
        }
    } while ( FALSE );

	if (bOleInitialized)
        CoUninitialize();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98\inc\designer.h ===
//=--------------------------------------------------------------------------=
// Designer.H
//=--------------------------------------------------------------------------=
// Copyright (c) 1988-1996, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
// just about everything you might find useful in an ActiveX[tm] Designer.
//
#ifndef _DESIGNER_H_


// CATID for Designers
//
// {4EB304D0-7555-11cf-A0C2-00AA0062BE57}
DEFINE_GUID(CATID_Designer, 0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// IActiveDesigner
//
// {51AAE3E0-7486-11cf-A0C2-00AA0062BE57}
DEFINE_GUID(IID_IActiveDesigner, 0x51aae3e0, 0x7486, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);


#undef  INTERFACE
#define INTERFACE IActiveDesigner

DECLARE_INTERFACE_(IActiveDesigner, IUnknown)
{
	// IUnknown methods
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IActiveDesigner methods
	//
	STDMETHOD(GetRuntimeClassID)(THIS_ CLSID *pclsid) PURE;
	STDMETHOD(GetRuntimeMiscStatusFlags)(THIS_ DWORD *pdwMiscFlags) PURE;
	STDMETHOD(QueryPersistenceInterface)(THIS_ REFIID riidPersist) PURE;
	STDMETHOD(SaveRuntimeState)(THIS_ REFIID riidPersist, REFIID riidObjStgMed, void *pObjStgMed) PURE;
	STDMETHOD(GetExtensibilityObject)(THIS_ IDispatch **ppvObjOut) PURE;
};


//-------------------------------------------------------------------------
//  IServiceProvider Interface
//    This interface is implemented by an object that wish to provide "services"
//
//-------------------------------------------------------------------------
#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__
#ifndef __IServiceProvider_INTERFACE_DEFINED
#define __IServiceProvider_INTERFACE_DEFINED

// { 6d5140c1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IServiceProvider, 0x6d5140c1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IServiceProvider
DECLARE_INTERFACE_(IServiceProvider, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_
                /* [in]  */ REFGUID rsid,
                /* [in]  */ REFIID iid,
                /* [out] */ void ** ppvObj) PURE;
};

#endif // __IServiceProvider_INTERFACE_DEFINED
#endif // __IServiceProvider_INTERFACE_DEFINED__



//-------------------------------------------------------------------------
//  SCodeNavigate Service.
//    This service let's an extended object show the code module
//    behind it.
//
//  interfaces implemented:
//    ICodeNavigate
//    ICodeNavigate2
//-------------------------------------------------------------------------

// { 6d5140c4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ICodeNavigate, 0x6d5140c4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SCodeNavigate IID_ICodeNavigate

#undef  INTERFACE
#define INTERFACE  ICodeNavigate
DECLARE_INTERFACE_(ICodeNavigate, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICodeNavigate methods ***
    STDMETHOD(DisplayDefaultEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName) PURE;
};

// { 2702ad60-3459-11d1-88fd-00a0c9110049 }
DEFINE_GUID(IID_ICodeNavigate2, 0x2702ad60, 0x3459, 0x11d1, 0x88, 0xfd, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x49);

#undef  INTERFACE
#define INTERFACE  ICodeNavigate2
DECLARE_INTERFACE_(ICodeNavigate2, ICodeNavigate)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICodeNavigate methods ***
    STDMETHOD(DisplayDefaultEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName) PURE;

    // *** ICodeNavigate2 methods ***
    STDMETHOD(DisplayEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName, LPCOLESTR lpstrEventName) PURE;
};


//-------------------------------------------------------------------------
//  STrackSelection Service
//    This service is used by the host to help designer track the
//    currently selected object in the host
//
//  interfaces implemented:
//    ITrackSelection
//-------------------------------------------------------------------------
#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2

#define SELOBJS_ACTIVATE_WINDOW   1

// { 6d5140c6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ISelectionContainer, 0x6d5140c6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  ISelectionContainer
DECLARE_INTERFACE_(ISelectionContainer, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ISelectionContainer methods ***
    STDMETHOD(CountObjects)(THIS_
                /* [in]  */ DWORD dwFlags, 
                /* [out] */ ULONG * pc) PURE;
    STDMETHOD(GetObjects)(THIS_
              /* [in]  */ DWORD dwFlags, 
              /* [in]  */ ULONG cObjects,
              /* [out] */ IUnknown **apUnkObjects) PURE;
    STDMETHOD(SelectObjects)(THIS_
              /* [in] */ ULONG cSelect,
              /* [in] */ IUnknown **apUnkSelect,
              /* [in] */ DWORD dwFlags) PURE;
};

// { 6d5140c5-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ITrackSelection, 0x6d5140c5, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_STrackSelection IID_ITrackSelection

#undef  INTERFACE
#define INTERFACE  ITrackSelection
DECLARE_INTERFACE_(ITrackSelection, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ITrackSelection methods ***
    STDMETHOD(OnSelectChange)(THIS_ 
                  /* [in] */ ISelectionContainer * pSC) PURE;
};

//-------------------------------------------------------------------------
//  SProfferTypelib Service
//    this service allows components and hosts to allow
//    them to add typelibs to the project
//
//  interfaces implemented:
//    IProfferTypelib
//-------------------------------------------------------------------------

// { 718cc500-0a76-11cf-8045-00aa006009fa }
DEFINE_GUID(IID_IProfferTypeLib, 0x718cc500, 0x0A76, 0x11cf, 0x80, 0x45, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SProfferTypeLib IID_IProfferTypeLib

#define CONTROLTYPELIB	                            (0x00000001)

#undef  INTERFACE
#define INTERFACE  IProfferTypeLib
DECLARE_INTERFACE_(IProfferTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferTypelib methods ***
    STDMETHOD(ProfferTypeLib)(THIS_ 
              /* [in]  */ REFGUID guidTypeLib,
              /* [in]  */ UINT    uVerMaj,
              /* [in]  */ UINT    uVerMin,
              /* [in]  */ DWORD   dwFlags) PURE;
};

// { 468cfb80-b4f9-11cf-80dd-00aa00614895 }
DEFINE_GUID(IID_IProvideDynamicClassInfo, 0x468cfb80, 0xb4f9, 0x11cf, 0x80, 0xdd, 0x00, 0xaa, 0x00, 0x61, 0x48, 0x95);

#undef  INTERFACE
#define INTERFACE  IProvideDynamicClassInfo
DECLARE_INTERFACE_(IProvideDynamicClassInfo, IProvideClassInfo)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProvideDynamicClassInfo ***
    STDMETHOD(GetDynamicClassInfo)(THIS_ ITypeInfo ** ppTI, DWORD * pdwCookie) PURE;
    STDMETHOD(FreezeShape)(void) PURE;
};


//-------------------------------------------------------------------------
//  SApplicationObject Service
//    Host applications proffer their application [add-in model] object as
//    this service.
//    Various objects implement the "Application" property by returning 
//    this service.
//      
//-------------------------------------------------------------------------

// { 0c539790-12e4-11cf-b661-00aa004cd6d8 }
DEFINE_GUID(SID_SApplicationObject, 0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8);

#define _DESIGNER_H_
#endif // _DESIGNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98\inc\objext.h ===
//+------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  
//  File:       objext.h
//  
//  Contents:   header file for Object Extensions interfaces
//  
//-------------------------------------------------------------------------

#ifndef __OBJEXT_H
#define __OBJEXT_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#include "Designer.H"

///////////////////////////////////////////////////////////////////////////
//
// forward declares
//
///////////////////////////////////////////////////////////////////////////

#define IClassDesigner IDocumentSite
#define IID_IClassDesigner IID_IDocumentSite

///////////////////////////////////////////////////////////////////////////
//
// Object Extension Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  IServiceProvider Interface
//    This interface is implemented by an object that wish to provide "services"
//
//-------------------------------------------------------------------------
#ifndef __IServiceProvider_INTERFACE_DEFINED
#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED
#define __IServiceProvider_INTERFACE_DEFINED__


// { 6d5140c1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IServiceProvider, 0x6d5140c1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IServiceProvider
DECLARE_INTERFACE_(IServiceProvider, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_
                /* [in]  */ REFGUID rsid,
                /* [in]  */ REFIID iid,
                /* [out] */ void ** ppvObj) PURE;
};

#endif // __IServiceProvider_INTERFACE_DEFINED__
#endif // __IServiceProvider_INTERFACE_DEFINED


//-------------------------------------------------------------------------
//  IDocumentSite Interface
//    This interface is implemented by a document object that can be customized
//
//-------------------------------------------------------------------------

// { 94A0F6F1-10BC-11d0-8D09-00A0C90F2732 }
DEFINE_GUID(IID_IDocumentSite, 0x94a0f6f1, 0x10bc, 0x11d0, 0x8d, 0x09, 0x00, 0xa0, 0xc9, 0x0f, 0x27, 0x32);

typedef DWORD ACTFLAG;
#define ACT_DEFAULT 0x00000000
#define ACT_SHOW    0x00000001

#undef  INTERFACE
#define INTERFACE  IDocumentSite
DECLARE_INTERFACE_(IDocumentSite, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IDocumentSite methods ***
    STDMETHOD(SetSite)(THIS_
               /* [in]  */ IServiceProvider * pSP) PURE;
    STDMETHOD(GetSite)(THIS_
               /* [out] */ IServiceProvider** ppSP) PURE;
    STDMETHOD(GetCompiler)(THIS_
               /* [in]  */ REFIID iid,
               /* [out] */ void **ppvObj) PURE;
    STDMETHOD(ActivateObject)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(IsObjectShowable)(THIS) PURE;
};


///////////////////////////////////////////////////////////////////////////
//
// Standard Services and Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  SLicensedClassManager
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILicensedClassManager
//-------------------------------------------------------------------------
// { 6d5140d0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IRequireClasses
DECLARE_INTERFACE_(IRequireClasses, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRequireClasses methods ***
    STDMETHOD(CountRequiredClasses)(THIS_
                    /* [out] */ ULONG * pcClasses ) PURE;
    STDMETHOD(GetRequiredClasses)(THIS_
                  /* [in]  */ ULONG index,
                  /* [out] */ CLSID * pclsid ) PURE;
};

// { 6d5140d4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILicensedClassManager, 0x6d5140d4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLicensedClassManager  IID_ILicensedClassManager

#undef  INTERFACE
#define INTERFACE  ILicensedClassManager
DECLARE_INTERFACE_(ILicensedClassManager, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILicensedClassManager methods ***
    STDMETHOD(OnChangeInRequiredClasses)(THIS_
                     /* [in] */ IRequireClasses *pRequireClasses) PURE;
};

//-------------------------------------------------------------------------
//  SCreateExtendedTypeLib Service
//    This service is used by components to create a typelib
//    describing controls merged with their extender
//
//  interfaces implemented:
//    ICreateExtendedTypeLib
//-------------------------------------------------------------------------
// { 6d5140d6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IExtendedTypeLib, 0x6d5140d6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SExtendedTypeLib IID_IExtendedTypeLib

#undef  INTERFACE
#define INTERFACE  IExtendedTypeLib
DECLARE_INTERFACE_(IExtendedTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IExtendedTypeLib ***
    STDMETHOD(CreateExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;

    STDMETHOD(AddRefExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD	   dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;
    STDMETHOD(AddRefExtendedTypeLibOfClsid)(THIS_
                     /* [in]  */ REFCLSID rclsidControl,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeInfo **pptinfo) PURE;
    STDMETHOD(SetExtenderInfo)(THIS_ 
		     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved) PURE;
};

//-------------------------------------------------------------------------
//  SLocalRegistry Service
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILocalRegistry
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILocalRegistry, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLocalRegistry IID_ILocalRegistry

#undef  INTERFACE
#define INTERFACE  ILocalRegistry
DECLARE_INTERFACE_(ILocalRegistry, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILocalRegistry methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ CLSID      clsid,     
                  /* [in]  */ IUnknown * punkOuter,
                  /* [in]  */ REFIID     riid,
                  /* [in]  */ DWORD      dwFlags,
                  /* [out] */ void **    ppvObj ) PURE;
    STDMETHOD(GetTypeLibOfClsid)(THIS_
                 /* [in]  */ CLSID       clsid,
                 /* [out] */ ITypeLib ** ptlib ) PURE;
    STDMETHOD(GetClassObjectOfClsid)(THIS_
                     /* [in]  */ REFCLSID clsid,
                                 /* [in]  */ DWORD    dwClsCtx,
                     /* [in]  */ LPVOID   lpReserved,
                     /* [in]  */ REFIID   riid,
                     /* [out] */ void **  ppcClassObject ) PURE;
};

//-------------------------------------------------------------------------
//  IUIElement interface
//    components can implement services to allow external control of pieces 
//    of their UI by implementing this interface
//
//-------------------------------------------------------------------------
// { 759d0500-d979-11ce-84ec-00aa00614f3e }
DEFINE_GUID(IID_IUIElement, 0x759d0500, 0xd979, 0x11ce, 0x84, 0xec, 0x00, 0xaa, 0x00, 0x61, 0x4f, 0x3e);

#undef  INTERFACE
#define INTERFACE  IUIElement
DECLARE_INTERFACE_(IUIElement, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IUIElement methods ****
    STDMETHOD(Show)(THIS) PURE;
    STDMETHOD(Hide)(THIS) PURE;
    STDMETHOD(IsVisible)(THIS) PURE;
};

//-------------------------------------------------------------------------
//  SProfferService Service
//    VBA provides this service to it's components and hosts to allow
//    them to dynamically provide services.
//
//  interfaces implemented:
//    IProfferService
//-------------------------------------------------------------------------

// {CB728B20-F786-11ce-92AD-00AA00A74CD0}
DEFINE_GUID(IID_IProfferService, 0xcb728b20, 0xf786, 0x11ce, 0x92, 0xad, 0x0, 0xaa, 0x0, 0xa7, 0x4c, 0xd0);
#define SID_SProfferService IID_IProfferService

#undef  INTERFACE
#define INTERFACE  IProfferService
DECLARE_INTERFACE_(IProfferService, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferService methods ***
    STDMETHOD(ProfferService)(THIS_ 
                  /* [in]  */ REFGUID rguidService,
                  /* [in]  */ IServiceProvider * psp,
                  /* [out] */ DWORD *pdwCookie) PURE;

    STDMETHOD(RevokeService)(THIS_ /* [in]  */ DWORD dwCookie) PURE;
};

// {4D07FC10-F931-11ce-B001-00AA006884E5}
DEFINE_GUID(IID_ICategorizeProperties, 0x4d07fc10, 0xf931, 0x11ce, 0xb0, 0x1, 0x0, 0xaa, 0x0, 0x68, 0x84, 0xe5);

// NOTE : CATID should no longer be used.  Use PROPCAT instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new typedef.
#ifdef OBJEXT_OLD_CATID
typedef int CATID;
#else
typedef int PROPCAT;
#endif

#undef  INTERFACE
#define INTERFACE  ICategorizeProperties
DECLARE_INTERFACE_(ICategorizeProperties, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICategorizeProperties ***
    STDMETHOD(MapPropertyToCategory)(THIS_ 
                                     /* [in]  */ DISPID dispid,
                                     /* [out] */ PROPCAT* ppropcat) PURE;
    STDMETHOD(GetCategoryName)(THIS_
                               /* [in]  */ PROPCAT propcat, 
                               /* [in]  */ LCID lcid,
                               /* [out] */ BSTR* pbstrName) PURE;
};

typedef ICategorizeProperties FAR* LPCATEGORIZEPROPERTIES;

// category ID: negative values are 'standard' categories,  positive are control-specific
// Note! This is a temporary list!
#ifdef OBJEXT_OLD_CATID
// NOTE : The following #defines should no longer be used.  Use PROPCAT_ instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new #defines.
#define CI_Nil -1
#define CI_Misc -2
#define CI_Font -3
#define CI_Position -4
#define CI_Appearance -5
#define CI_Behavior -6
#define CI_Data -7
#define CI_List -8
#define CI_Text -9
#define CI_Scale -10
#define CI_DDE -11
#else
#define PROPCAT_Nil -1
#define PROPCAT_Misc -2
#define PROPCAT_Font -3
#define PROPCAT_Position -4
#define PROPCAT_Appearance -5
#define PROPCAT_Behavior -6
#define PROPCAT_Data -7
#define PROPCAT_List -8
#define PROPCAT_Text -9
#define PROPCAT_Scale -10
#define PROPCAT_DDE -11
#endif

//
//  Extra interfaces (chrisz)
//

//+-------------------------------------------------------------------------
//
//  Help service. (robbear)
//
//--------------------------------------------------------------------------

#define HELPINFO_WHATS_THIS_MODE_ON     1

// { 6d5140c7-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(SID_SHelp, 0x6d5140c7, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

// { 6d5140c8-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IHelp, 0x6d5140c8, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IHelp
DECLARE_INTERFACE_(IHelp, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IHelp methods ***
    STDMETHOD(GetHelpFile) (THIS_ BSTR * pbstr) PURE;
    STDMETHOD(GetHelpInfo) (THIS_ DWORD * pdwHelpInfo) PURE;
    STDMETHOD(ShowHelp) (THIS_
                         LPOLESTR szHelp,
                         UINT fuCommand,
                         DWORD dwHelpContext) PURE;
};

#endif // __OBJEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\classf.h ===
//=--------------------------------------------------------------------------=
// AutoCF.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _AUTOCF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _AUTOCF_H_
#endif // _AUTOCF_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\autoobj.cpp ===
//=--------------------------------------------------------------------------=
// AutomationObject.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.
//
#include "pch.h"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "StdEnum.H"


// for ASSERT and FAIL
//
SZTHISFILE

// private function prototypes
//
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyConnectData(void *, const void *, DWORD);

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObject::CAutomationObject 
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable
)
: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
    m_fLoadedTypeInfo = FALSE;

#ifdef MDAC_BUILD
    m_pTypeLibId = g_pLibid;
#endif
}


//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=
// "I have a rendezvous with Death, At some disputed barricade"
// - Alan Seeger (1888-1916)
//
// Notes:
//
CAutomationObject::~CAutomationObject ()
{
    // if we loaded up a type info, release our count on the globally stashed
    // type infos, and release if it becomes zero.
    //
    if (m_fLoadedTypeInfo) {

        // we have to crit sect this since it's possible to have more than
        // one thread partying with this object.
        //
        ENTERCRITICALSECTION1(&g_CriticalSection);
        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
        CTYPEINFOOFOBJECT(m_ObjectType)--;

        // if we're the last one, free that sucker!
        //
        if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
            PTYPEINFOOFOBJECT(m_ObjectType)->Release();
            PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
        }
        LEAVECRITICALSECTION1(&g_CriticalSection);
    }

    return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObject::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    ASSERT(ppvObjOut, "controlling Unknown should be checking this!");

    // start looking for the guids we support, namely IDispatch, and the
    //
    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
        *ppvObjOut = (void *)(IDispatch *)m_pvInterface;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }

    // just get our parent class to process it from here on out.
    //
    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//    UINT *            - [out] the number of interfaces supported.
//
// Output:
//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfoCount
(
    UINT *pctinfo
)
{
    // arg checking
    //
    if (!pctinfo)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.
    //
    *pctinfo = 1;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//    UINT              - [in]  the type information they'll want returned
//    LCID              - [in]  the LCID of the type info we want
//    ITypeInfo **      - [out] the new type info object.
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, etc.
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    DWORD       dwPathLen;
    char        szDllPath[MAX_PATH];
    HRESULT     hr;
    ITypeLib   *pTypeLib;
    ITypeInfo **ppTypeInfo =NULL;

    // arg checking
    //
    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load the sucker.
        //
    #ifdef MDAC_BUILD
        hr = LoadRegTypeLib(*m_pTypeLibId, (USHORT)VERSIONOFOBJECT(m_ObjectType),
                            (USHORT)VERSIONMINOROFOBJECT(m_ObjectType),
                            LANG_NEUTRAL, &pTypeLib);
    #else
        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType),
                            (USHORT)VERSIONMINOROFOBJECT(m_ObjectType),
                            LANG_NEUTRAL, &pTypeLib);
    #endif

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.
        //
        if (FAILED(hr)) {

            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
            hr = LoadTypeLib(pwsz, &pTypeLib);
            CLEANUP_ON_FAILURE(hr);
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.
        //
        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        CLEANUP_ON_FAILURE(hr);

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the non dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        CLEANUP_ON_FAILURE(hr);

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

  CleanUp:
    LEAVECRITICALSECTION1(&g_CriticalSection);
    return hr;
}



//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//    REFIID            - [in]  must be IID_NULL
//    OLECHAR **        - [in]  array of names to map.
//    UINT              - [in]  count of names in the array.
//    LCID              - [in]  LCID on which to operate
//    DISPID *          - [in]  place to put the corresponding DISPIDs.
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//                        DISP_E_UNKNOWNLCID
//
// Notes:
//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//      and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cNames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // use the standard provided routines to do all the work for us.
    //
    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//    DISPID            - [in]  identifies the member we're working with.
//    REFIID            - [in]  must be IID_NULL.
//    LCID              - [in]  language we're working under
//    USHORT            - [in]  flags, propput, get, method, etc ...
//    DISPPARAMS *      - [in]  array of arguments.
//    VARIANT *         - [out] where to put result, or NULL if they don't care.
//    EXCEPINFO *       - [out] filled in in case of exception
//    UINT *            - [out] where the first argument with an error is.
//
// Output:
//    HRESULT           - tonnes of them.
//
// Notes:
//    
STDMETHODIMP CAutomationObject::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // Clear exceptions
    //
    SetErrorInfo(0L, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.
    //
    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();
    return hr;

}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// See also the version of Exception() that takes a resource ID instead
// of the actual string for the error message.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    LPWSTR           - [in] the text of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    LPWSTR wszException,
    DWORD   dwHelpContextID
)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    WCHAR   wszTmp[256];
    HRESULT hr;


    // first get the createerrorinfo object.
    //
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hr)) return hrExcep;
    
    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));    

    // set up some default information on it.
    //
    hr = pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
    ASSERT(SUCCEEDED(hr), "Unable to set GUID of error");
    hr = pCreateErrorInfo->SetHelpFile(HELPFILEOFOBJECT(m_ObjectType) ? wszHelpFile : NULL);
    ASSERT(SUCCEEDED(hr), "Uable to set help file of error");
    hr = pCreateErrorInfo->SetHelpContext(dwHelpContextID);
    ASSERT(SUCCEEDED(hr), "Unable to set help context of error");
    hr = pCreateErrorInfo->SetDescription(wszException);
    ASSERT(SUCCEEDED(hr), "Unable to set description of error");

    // load in the source
    //
    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
    hr = pCreateErrorInfo->SetSource(wszTmp);
    ASSERT(SUCCEEDED(hr), "Unable to set source name of error");

    // now set the Error info up with the system
    //
    hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
    CLEANUP_ON_FAILURE(hr);

    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

  CleanUp:
    pCreateErrorInfo->Release();
    return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// See also the version of Exception() that takes the actual string of the
// error message instead of a resource ID.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    WORD             - [in] the RESOURCE ID of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    WORD    idException,
    DWORD   dwHelpContextID
)
{
    char szTmp[256];
    WCHAR wszTmp[256];
    int cch;

    // load in the actual error string value.  max of 256.
    //
    cch = LoadString(GetResourceHandle(), idException, szTmp, 256);
    ASSERT(cch != 0, "Resource string for exception not found");
    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
    return Exception(hrExcep, wszTmp, dwHelpContextID);
}


//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//    REFIID        - [in] the interface we want the answer for.
//
// Output:
//    HRESULT       - S_OK = Yes, S_FALSE = No.
//
// Notes:
//
HRESULT CAutomationObject::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    // see if it's the interface for the type of object that we are.
    //
    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
        return S_OK;

    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetResourceHandle    [helper]
//=--------------------------------------------------------------------------=
// virtual routine to get the resource handle.  virtual, so that inheriting
// objects, such as COleControl can use theirs instead, which goes and gets
// the Host's version ...
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CAutomationObject::GetResourceHandle
(
    void
)
{
    return ::GetResourceHandle();
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                      CAutomationObjectWEvents                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CAutomationObjectWEvents
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObjectWEvents::CAutomationObjectWEvents
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable
)
: CAutomationObject(pUnkOuter, ObjType, pVTable),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)

{
    // not much to do yet.
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::~CAutomationObjectWEvents
//=--------------------------------------------------------------------------=
// virtual destructor
//
// Notes:
//
CAutomationObjectWEvents::~CAutomationObjectWEvents()
{
    // homey don't play that
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::InternalQueryInterface
//=--------------------------------------------------------------------------=
// our internal query interface routine.  we only add IConnectionPtContainer
// on top of CAutomationObject
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObjectWEvents::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    // we only add one interface
    //
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPointContainer)) {
        *ppvObjOut = (IConnectionPointContainer *)this;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }

    // just get our parent class to process it from here on out.
    //
    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//    REFIID              - [in]  interfaces they want
//    IConnectionPoint ** - [out] where the cp should go
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::FindConnectionPoint
(
    REFIID             riid,
    IConnectionPoint **ppConnectionPoint
)
{
    CHECK_POINTER(ppConnectionPoint);

    // we support the event interface, and IDispatch for it, and we also
    // support IPropertyNotifySink.
    //
    if ((ISVALIDEVENTIID(m_ObjectType) && DO_GUIDS_MATCH(riid, EVENTIIDOFOBJECT(m_ObjectType))) || 
	 DO_GUIDS_MATCH(riid, IID_IDispatch))
        *ppConnectionPoint = &m_cpEvents;
    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
        *ppConnectionPoint = &m_cpPropNotify;
    else
        return E_NOINTERFACE;

    // generic post-processing.
    //
    (*ppConnectionPoint)->AddRef();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::EnumConnectionPoints    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//    IEnumConnectionPoints **    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::EnumConnectionPoints
(
    IEnumConnectionPoints **ppEnumConnectionPoints
)
{
    IConnectionPoint **rgConnectionPoints;

    CHECK_POINTER(ppEnumConnectionPoints);

    // HeapAlloc an array of connection points [since our standard enum
    // assumes this and HeapFree's it later ]
    //
    rgConnectionPoints = (IConnectionPoint **)CtlHeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2);
    RETURN_ON_NULLALLOC(rgConnectionPoints);

    // we support the event interface for this dude as well as IPropertyNotifySink
    //
    rgConnectionPoints[0] = &m_cpEvents;
    rgConnectionPoints[1] = &m_cpPropNotify;

    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) New CStandardEnum(IID_IEnumConnectionPoints,
                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                                CopyAndAddRefObject);
    if (!*ppEnumConnectionPoints) {
        CtlHeapFree(g_hHeap, 0, rgConnectionPoints);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::m_pObject
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//    CAutomationObjectWEvents *
//
// Notes:
//
inline CAutomationObjectWEvents *CAutomationObjectWEvents::CConnectionPoint::m_pObject
(
    void
)
{
    return (CAutomationObjectWEvents *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                          ? offsetof(CAutomationObjectWEvents, m_cpEvents)
                                          : offsetof(CAutomationObjectWEvents, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        *ppvObjOut = (IConnectionPoint *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::AddRef
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CAutomationObjectWEvents::CConnectionPoint::AddRef
(
    void
)
{
    return m_pObject()->ExternalAddRef();
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::Release
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CAutomationObjectWEvents::CConnectionPoint::Release
(
    void
)
{
    return m_pObject()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//    IID *        - [out] interface we support.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::GetConnectionInterface
(
    IID *piid
)
{
    if (m_bType == SINK_TYPE_EVENT && ISVALIDEVENTIID(m_pObject()->m_ObjectType))	
	*piid = EVENTIIDOFOBJECT(m_pObject()->m_ObjectType);
    else
        *piid = IID_IPropertyNotifySink;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//    IConnectionPointContainer **ppCPC
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::GetConnectionPointContainer
(
    IConnectionPointContainer **ppCPC
)
{
    return m_pObject()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//    IUnknown *        - [in]  guy who wants to be advised.
//    DWORD *           - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::Advise
(
    IUnknown *pUnk,
    DWORD    *pdwCookie
)
{
    HRESULT    hr = E_FAIL;
    void      *pv;

    CHECK_POINTER(pdwCookie);

    // first, make sure everybody's got what they thinks they got
    //
    if (m_bType == SINK_TYPE_EVENT) 
    {
        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find
        // connection point on IDispatch, and they just happened to also support
        // the Event IID, we'd advise on that.  this is not awesome, but will
        // prove entirely acceptable short term.
        //
	ASSERT(hr == E_FAIL, "Somebody has changed our assumption that hr is initialized to E_FAIL");
	if (ISVALIDEVENTIID(m_pObject()->m_ObjectType))
	    hr = pUnk->QueryInterface(EVENTIIDOFOBJECT(m_pObject()->m_ObjectType), &pv);

        if (FAILED(hr))
            hr = pUnk->QueryInterface(IID_IDispatch, &pv);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
    }

    RETURN_ON_FAILURE(hr);

    // finally, add the sink.  it's now been cast to the correct type and has
    // been AddRef'd.
    //
    return AddSink(pv, pdwCookie);
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//    void *        - [in]  the sink to add. it's already been addref'd
//    DWORD *       - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CAutomationObjectWEvents::CConnectionPoint::AddSink
(
    void  *pv,
    DWORD *pdwCookie
)
{
    IUnknown **rgUnkNew;
    int        i = 0;

    // we optimize the case where there is only one sink to not allocate
    // any storage.  turns out very rarely is there more than one.
    //
    switch (m_cSinks) {

        case 0:
            ASSERT(!m_rgSinks, "this should be null when there are no sinks");
            m_rgSinks = (IUnknown **)pv;
            break;

        case 1:
            // go ahead and do the initial allocation.  we'll get 8 at a time
            //
            rgUnkNew = (IUnknown **)CtlHeapAlloc(g_hHeap, 0, 8 * sizeof(IUnknown *));
            RETURN_ON_NULLALLOC(rgUnkNew);
            rgUnkNew[0] = (IUnknown *)m_rgSinks;
            rgUnkNew[1] = (IUnknown *)pv;
            m_rgSinks = rgUnkNew;
            break;

        default:
            // if we're out of sinks, then we have to increase the size
            // of the array
            //
            if (!(m_cSinks & 0x7)) {
                rgUnkNew = (IUnknown **)CtlHeapReAlloc(g_hHeap, 0, m_rgSinks, (m_cSinks + 8) * sizeof(IUnknown *));
                RETURN_ON_NULLALLOC(rgUnkNew);
                m_rgSinks = rgUnkNew;
            } else
                rgUnkNew = m_rgSinks;

            rgUnkNew[m_cSinks] = (IUnknown *)pv;
            break;
    }

    *pdwCookie = (DWORD)pv;
    m_cSinks++;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//    DWORD        - [in]  the cookie we gave 'em.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::Unadvise
(
    DWORD dwCookie
)
{
    IUnknown *pUnk;
    int       x;

    if (!dwCookie)
        return S_OK;

    // see how many sinks we've currently got, and deal with things based
    // on that.
    //
    switch (m_cSinks) {
        case 1:
            // it's the only sink.  make sure the ptrs are the same, and
            // then free things up
            //
            if ((DWORD)m_rgSinks != dwCookie)
                return CONNECT_E_NOCONNECTION;
            m_rgSinks = NULL;
            break;

        case 2:
            // there are two sinks.  go back down to one sink scenario
            //
            if ((DWORD)m_rgSinks[0] != dwCookie && (DWORD)m_rgSinks[1] != dwCookie)
                return CONNECT_E_NOCONNECTION;

            pUnk = ((DWORD)m_rgSinks[0] == dwCookie)
                   ? m_rgSinks[1]
                   : ((DWORD)m_rgSinks[1] == dwCookie) ? m_rgSinks[0] : NULL;

            if (!pUnk) return CONNECT_E_NOCONNECTION;

            CtlHeapFree(g_hHeap, 0, m_rgSinks);
            m_rgSinks = (IUnknown **)pUnk;
            break;

        default:
            // there are more than two sinks.  just clean up the hole we've
            // got in our array now.
            //
            for (x = 0; x < m_cSinks; x++) {
                if ((DWORD)m_rgSinks[x] == dwCookie)
                    break;
            }
            if (x == m_cSinks) return CONNECT_E_NOCONNECTION;
            if (x < m_cSinks - 1) 
                memcpy(&(m_rgSinks[x]), &(m_rgSinks[x + 1]), (m_cSinks -1 - x) * sizeof(IUnknown *));
            else
                m_rgSinks[x] = NULL;
            break;
    }


    // we're happy
    //
    m_cSinks--;
    ((IUnknown *)dwCookie)->Release();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::EnumConnections
(
    IEnumConnections **ppEnumOut
)
{
    CONNECTDATA *rgConnectData = NULL;
    int i;

    if (m_cSinks) {
        // allocate some memory big enough to hold all of the sinks.
        //
        rgConnectData = (CONNECTDATA *)CtlHeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA));
        RETURN_ON_NULLALLOC(rgConnectData);

        // fill in the array
        //
        if (m_cSinks == 1) {
            rgConnectData[0].pUnk = (IUnknown *)m_rgSinks;
            rgConnectData[0].dwCookie = (DWORD)m_rgSinks;
        } else {
            // loop through all available sinks.
            //
            for (i = 0; i < m_cSinks; i++) {
                rgConnectData[i].pUnk = m_rgSinks[i];
                rgConnectData[i].dwCookie = (DWORD)m_rgSinks[i];
            }
        }
    }

    // create yon enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)New CStandardEnum(IID_IEnumConnections,
                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyConnectData);
    if (!*ppEnumOut) {
        CtlHeapFree(g_hHeap, 0, rgConnectData);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
CAutomationObjectWEvents::CConnectionPoint::~CConnectionPoint ()
{
    int x;

    // clean up some memory stuff
    //
    if (!m_cSinks)
        return;
    else if (m_cSinks == 1)
        ((IUnknown *)m_rgSinks)->Release();
    else {
        for (x = 0; x < m_cSinks; x++)
            QUICK_RELEASE(m_rgSinks[x]);
        CtlHeapFree(g_hHeap, 0, m_rgSinks);
    }
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//    DISPID            - [in] event to fire.
//    DISPPARAMS        - [in]
//
// Notes:
//
void CAutomationObjectWEvents::CConnectionPoint::DoInvoke
(
    DISPID      dispid,
    DISPPARAMS *pdispparams
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //
    if (m_cSinks == 0)
        return;
    else if (m_cSinks == 1)
        ((IDispatch *)m_rgSinks)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
    else
        for (iConnection = 0; iConnection < m_cSinks; iConnection++)
            ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//    DISPID            - [in] dude that changed.
//
// Output:
//    none
//
// Notes:
//
void CAutomationObjectWEvents::CConnectionPoint::DoOnChanged
(
    DISPID dispid
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        return;
    else if (m_cSinks == 1)
        ((IPropertyNotifySink *)m_rgSinks)->OnChanged(dispid);
    else
        for (iConnection = 0; iConnection < m_cSinks; iConnection++)
            ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//    DISPID             - [in] dispid user wants to change.
//
// Output:
//    BOOL               - false means you cant
//
// Notes:
//
BOOL CAutomationObjectWEvents::CConnectionPoint::DoOnRequestEdit
(
    DISPID dispid
)
{
    HRESULT hr;
    int     iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        hr = S_OK;
    else if (m_cSinks == 1)
        hr =((IPropertyNotifySink *)m_rgSinks)->OnRequestEdit(dispid);
    else {
        for (iConnection = 0; iConnection < m_cSinks; iConnection++) {
            hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
            if (hr != S_OK) break;
        }
    }

    return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.  handles arbitrary number of arguments.
//
// Parameters:
//    EVENTINFO *        - [in] struct that describes the event.
//    ...                - arguments to the event
//
// Output:
//    none
//
// Notes:
//    - use stdarg's va_* macros.
//
void __cdecl CAutomationObjectWEvents::FireEvent
(
    EVENTINFO *pEventInfo,
    ...
)
{
    va_list    valist;
    DISPPARAMS dispparams;
    VARIANT    rgvParameters[MAX_ARGS];
    VARIANT   *pv;
    VARTYPE    vt;
    int        iParameter;
    int        cbSize;

    ASSERT(pEventInfo->cParameters <= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry.");

    va_start(valist, pEventInfo);

    // copy the Parameters into the rgvParameters array.  make sure we reverse
    // them for automation
    //
    pv = &(rgvParameters[pEventInfo->cParameters - 1]);
    for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

        // CONSIDER: are we properly handling all vartypes, e.g., VT_DECIMAL
        vt = pEventInfo->rgTypes[iParameter];

        // if it's a by value variant, then just copy the whole
        // dang thing
        //
        if (vt == VT_VARIANT)
            *pv = va_arg(valist, VARIANT);
        else {
            // copy the vt and the data value.
            //
            pv->vt = vt;
            if (vt & VT_BYREF)
                cbSize = sizeof(void *);
            else
                cbSize = g_rgcbDataTypeSize[vt];

            // small optimization -- we can copy 2/4 bytes over quite
            // quickly.
            //
            if (cbSize == sizeof(short))
                V_I2(pv) = va_arg(valist, short);
            else if (cbSize == 4) {
                if (vt == VT_R4)
                    V_R4(pv) = va_arg(valist, float);
                else
                    V_I4(pv) = va_arg(valist, long);
            }
            else {
                // copy over 8 bytes
                //
                ASSERT(cbSize == 8, "don't recognize the type!!");
                if ((vt == VT_R8) || (vt == VT_DATE)) 
                    V_R8(pv) = va_arg(valist, double);
                else
                    V_CY(pv) = va_arg(valist, CURRENCY);
            }
        }

        pv--;
    }

    // fire the event
    //
    dispparams.rgvarg = rgvParameters;
    dispparams.cArgs = pEventInfo->cParameters;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cNamedArgs = 0;

    m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

    va_end(valist);
}

//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size, ignored, since it's always 4
//
// Notes:
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((IUnknown **)pDest) = *((IUnknown **)pSource);
    ADDREF_OBJECT(*((IUnknown **)pDest));
}

//=--------------------------------------------------------------------------=
// CopyConnectData
//=--------------------------------------------------------------------------=
// copies over a connectdata structure and addrefs the pointer
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size
//
// Notes:
//
void WINAPI CopyConnectData
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((CONNECTDATA *)pDest) = *((const CONNECTDATA *)pSource);
    ADDREF_OBJECT(((CONNECTDATA *)pDest)->pUnk);
}

#ifdef DEBUG

//=--------------------------------------------------------------------------=
// DebugVerifyData1Guids [helper]
//=--------------------------------------------------------------------------=
// Given an array of match Data1_ #define and interface guid values, this
// function validates that all entries match.
//
void DebugVerifyData1Guids(GUIDDATA1_COMPARE *pGuidData1_Compare)
{
	while(pGuidData1_Compare->dwData1a)
	{
		ASSERT(pGuidData1_Compare->pdwData1b, "Data1 pointer is NULL");
		ASSERT(pGuidData1_Compare->dwData1a == *pGuidData1_Compare->pdwData1b, 
				"Data1_ #define value doesn't match interface guid value");

		pGuidData1_Compare++;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\classf.cpp ===
//=--------------------------------------------------------------------------=
// ClassFactory.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the implementation of the ClassFactory object. we support 
// IClassFactory and IClassFactory2
//
#include "pch.h"
#include "LocalSrv.H"

#include "ClassF.H"
#include "Unknown.H"                    // for CREATEFNOFOBJECT

//=--------------------------------------------------------------------------=
// private module level data
//=--------------------------------------------------------------------------=
//

// ASSERT and FAIL require this
//
SZTHISFILE

// private routines for this file
//
HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

// This is the GUID for a "phantom" interface which VB5 UserControls query
// for to determine if the control doesn't require its license key to be
// present if it's part of a composite UserControl being used in the
// design environment.
//
static const GUID IID_ILicOnCompositeCtl =
{ 0x6e6e9780, 0x165d, 0x11d0, { 0xb3, 0xe6, 0x00, 0xa0, 0xc9, 0x0f, 0x27, 0x31 } };

//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    int            - [in] index into our global table of objects for this guy
//
// Notes:
//
CClassFactory::CClassFactory
(
    int iIndex
)
: m_iIndex(iIndex)
{
    InterlockedIncrement(&g_cLocks);
    m_cRefs = 1;
}


//=--------------------------------------------------------------------------=
// CClassFactory::~CClassFactory
//=--------------------------------------------------------------------------=
// "Life levels all men.  Death reveals the eminent."
// - George Bernard Shaw (1856 - 1950)
//
// Notes:
//
CClassFactory::~CClassFactory ()
{
    ASSERT(m_cRefs == 0, "Object being deleted with refs!");
    InterlockedDecrement(&g_cLocks);
    return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    void *pv;

    CHECK_POINTER(ppvObjOut);

    // we support IUnknown, and the two CF interfaces
    //
    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
        pv = (void *)(IClassFactory *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
        pv = (void *)(IClassFactory2 *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        pv = (void *)(IUnknown *)this;
    } else if (g_fUseRuntimeLicInCompositeCtl && riid == IID_ILicOnCompositeCtl) {
        pv = (void *)(IUnknown *)this;
    } else {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)pv)->AddRef();
    *ppvObjOut = pv;
    return S_OK;
}




//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CClassFactory::AddRef
(
    void
)
{
    return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CClassFactory::Release
(
    void
)
{
    ASSERT(m_cRefs, "No Refs, and we're being released!");
    if(--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//    IUnknown *        - [in]  controlling IUknonwn for aggregation
//    REFIID            - [in]  interface id for new object
//    void **           - [out] pointer to new interface object.
//
// Output:
//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED,
//                        E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
    IUnknown *pUnkOuter,
    REFIID    riid,
    void    **ppvObjOut
)
{
    // check args
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // check to see if we've done our licensing work.  we do this as late
    // as possible that people calling CreateInstanceLic don't suffer from
    // a performance hit here.
    //
    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // check to see if they have the appropriate license to create this stuff
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    // try to create one of the objects that we support
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//    BOOL        - [in] TRUE means addref, false means release lock count.
//
// Output:
//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP CClassFactory::LockServer
(
    BOOL fLock
)
{
    // update the lock count.  crit sect these in case of another thread.
    //
    if (fLock)  
        InterlockedIncrement(&g_cLocks);
    else {
        ASSERT(g_cLocks, "D'oh! Lock Counting Problem");
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//    LICINFO *          - unclear
//
// Output:
//    HRESULT            - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
    LICINFO *pLicInfo
)
{
    CHECK_POINTER(pLicInfo);

    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // This says whether RequestLicKey will work
    //
    pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

    // This says whether the standard CreateInstance will work
    //
    pLicInfo->fLicVerified = g_fMachineHasLicense;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//    DWORD             - [in]  reserved
//    BSTR *            - [out] unclear
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::RequestLicKey
(
    DWORD  dwReserved,
    BSTR  *pbstr
)
{
    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // if the machine isn't licensed, then we're not about to give this to them !
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    *pbstr = GetLicenseKey();
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//    IUnknown *        - [in]  controlling IUnknown for aggregation
//    IUnknown *        - [in]  reserved, must be NULL
//    REFIID            - [in]  IID We're looking for.
//    BSTR              - [in]  license key
//    void **           - [out] where to put the new object.
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
    IUnknown *pUnkOuter,
    IUnknown *pUnkReserved,
    REFIID    riid,
    BSTR      bstrKey,
    void    **ppvObjOut
)
{
    *ppvObjOut = NULL;

    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // go and see if the key they gave us matches.
    //
    if (!CheckLicenseKey(bstrKey))
        return CLASS_E_NOTLICENSED;

    // if it does, then go and create the object.
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation
//    int              - [in]  index into our global table
//    void **          - [out] where to put resulting object.
//    REFIID           - [in]  the interface they want resulting object to be.
//
// Output:
//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE
//
// Notes:
//
HRESULT CreateOleObjectFromIndex
(
    IUnknown *pUnkOuter,
    int       iIndex,
    void    **ppvObjOut,
    REFIID    riid
)
{
    IUnknown *pUnk = NULL;
    HRESULT   hr;

    // If the object specifies a pre-Create static function call that first.
    //
    if (PRECREATEFNOFOBJECT(iIndex) != NULL) {
        hr = PRECREATEFNOFOBJECT(iIndex)();
        IfFailRet(hr);
    }
      
    // go and create the object
    //
    ASSERT(CREATEFNOFOBJECT(iIndex), "WARNING: Attempt to create an object that doesn't have a Create function.");
	if (!CREATEFNOFOBJECT(iIndex))
		return E_FAIL;

    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

    // sanity check and make sure the object actually got allocated.
    //
    RETURN_ON_NULLALLOC(pUnk);

    // make sure we support aggregation here properly -- if they gave us
    // a controlling unknown, then they -must- ask for IUnknown, and we'll
    // give them the private unknown the object gave us.
    //
    if (pUnkOuter) {
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
            pUnk->Release();
            return E_INVALIDARG;
        }

        *ppvObjOut = (void *)pUnk;
        hr = S_OK;
    } else {

        // QI for whatever the user wants.
        //
        hr = pUnk->QueryInterface(riid, ppvObjOut);
        pUnk->Release();
        RETURN_ON_FAILURE(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlembed.cpp ===
//=--------------------------------------------------------------------------=
// ControlEmbedding.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl
//
#include "pch.h"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "StdEnum.H"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// all controls support the following in-place verbs at an absolute minimum.
//
#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
    { OLEIVERB_SHOW,            0, 0, 0},
    { OLEIVERB_HIDE,            0, 0, 0},
    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
    { OLEIVERB_PRIMARY,         0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000
//
const VERBINFO ovProperties =
    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
    { OLEIVERB_UIACTIVATE, 0, 0, 0};


//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo    (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//    CONTROLINFO *        - [in]  where to put said information
//
// Output:
//    HRESULT              - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetControlInfo
(
    CONTROLINFO *pControlInfo
)
{
    CHECK_POINTER(pControlInfo);

    // certain hosts have a bug in which it doesn't initialize the cb in the
    // CONTROLINFO structure, so we can only assert on that here.
    //
    ASSERT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

    // NOTE: control writers should override this routine if they want to
    // return accelerator information in their control.
    //
    pControlInfo->hAccel = NULL;
    pControlInfo->cAccel = NULL;
    pControlInfo->dwFlags = 0; //joejo - Vegas #VBE9106 uninitialized dwFlags

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic    [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.  default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//    LPMSG                - [in] message for this mnemonic
//
// Output:
//    HRESULT              - S_OK, E_POINTER
//
// Notes:
//
STDMETHODIMP COleControl::OnMnemonic
(
    LPMSG pMsg
)
{
    // OVERRIDE: default implementation is to just activate our control.  
    // user can override if they want more interesting behaviour.
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange    [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//    DISPID            - [in] dispid of the property that changed.
//
// Output:
//    HRESULT           - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnAmbientPropertyChange
(
    DISPID dispid
)
{
    // if we're being told about a change in mode [design/run] then
    // remember that so our stashing of mode will update itself
    // correctly
    //
    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
        m_fModeFlagValid = FALSE;

    if (dispid == DISPID_AMBIENT_LOCALEID || dispid == DISPID_UNKNOWN)
    {
      ENTERCRITICALSECTION1(&g_CriticalSection);  // Should be a crit sect around this.
      g_fHaveLocale = FALSE;	// Cause the lcid to be re-browsed when its needed
      LEAVECRITICALSECTION1(&g_CriticalSection);
    }

    // just pass this on to the derived control and see if they want
    // to do anything with it.
    //
    AmbientPropertyChanged(dispid);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents    [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//    - we maintain an internal count of freezes versus thaws.
//
STDMETHODIMP COleControl::FreezeEvents
(
    BOOL fFreeze
)
{
    // OVERRIDE: by default, we don't care.  user can override if they want to.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetClientSite
(
    IOleClientSite *pClientSite
)
{
    // make sure we free up all site pointers we're holding on to!  otherwise,
    // we can run into problems during aggregation
    //
    RELEASE_OBJECT(m_pClientSite);
    RELEASE_OBJECT(m_pControlSite);
    RELEASE_OBJECT(m_pSimpleFrameSite);

    // store away the new client site
    //
    m_pClientSite = pClientSite;

    // if we've actually got one, then get some other interfaces we want to keep
    // around, and keep a handle on it
    //
    if (m_pClientSite) {
        m_pClientSite->AddRef();
        m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
            m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
    } else {
        // if they're telling us to clear our site pointers, go and release
        // everything else as well
        //
        RELEASE_OBJECT(m_pInPlaceSite);
        RELEASE_OBJECT(m_pInPlaceSiteWndless);
        RELEASE_OBJECT(m_pDispAmbient);
    }

    // now get the user to clear out/re-establish the pointers they want
    //
    return OnSetClientSite();
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//    IOleClientSite **        - [out]
//
// Output:
//    HRESULT                  - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetClientSite
(
    IOleClientSite **ppClientSite
)
{
    CHECK_POINTER(ppClientSite);

    *ppClientSite = m_pClientSite;
    ADDREF_OBJECT(*ppClientSite);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames    [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//    LPCOLESTR        - [in] name of container application
//    LPCOLESTR        - [in] name of container document
//
// Output:
//    HRESULT          - S_OK
//
// Notes:
//    - we don't care about this
//
STDMETHODIMP COleControl::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObject
)
{
    // we don't care about these
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//    DWORD             - [in] indicates whether to save the object before closing
//
// Output:
//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED
//
// Notes:
//
STDMETHODIMP COleControl::Close
(
    DWORD dwSaveOption
)
{
    HRESULT hr;

    if (m_fInPlaceActive) {
        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
    }

    // handle the save flag.
    //
    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
        if (m_pClientSite) m_pClientSite->SaveObject();
        if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//    DWORD                - [in] which moniker is being set
//    IMoniker *           - [in] the moniker
//
// Output:
//    HRESULT              - S_OK, E_FAIL
//
// Notes:
//    - we don't support monikers.
//
STDMETHODIMP COleControl::SetMoniker
(
    DWORD     dwWhichMoniker,
    IMoniker *pMoniker
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//    DWORD            - [in]  how it's assigned
//    DWORD            - [in]  which moniker
//    IMoniker **      - [out] duh.
//
// Output:
//    HRESULT          - E_NOTIMPL
//
// Notes:
//    - we don't support monikers
//
STDMETHODIMP COleControl::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppMonikerOut
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData    [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//    IDataObject*    - [in] data object with the data
//    BOOL            - [in] how object is created
//    DWORD           - reserved
//
// Output:
//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't have data object support
//
STDMETHODIMP COleControl::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//    DWORD          - reserved
//    IDataObject ** - [out] data object for this control
//
// Output:
//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    *ppDataObject = NULL;        // be a good neighbour
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//    LONG             - [in]  verb to be performed
//    LPMSG            - [in]  event that invoked the verb
//    IOleClientSite * - [in]  the controls active client site
//    LONG             - [in]  reserved
//    HWND             - [in]  handle of window containing the object.
//    LPCRECT          - [in]  pointer to objects's display rectangle
//
// Output:
//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                       OLE_CLASSDIFF, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    HRESULT hr;

    switch (lVerb) {
      case OLEIVERB_SHOW:
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
        return InPlaceActivate(lVerb);

      case OLEIVERB_HIDE:
        UIDeactivate();
        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE);
        return S_OK;

      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
      // turns out that the CDK and certain hosts expect this to show the
      // properties instead.  Users can change what this verb does at will.
      //
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
        {
        int iPage;		
        CLSID *prgPropPages;

		// Only allow the Property Page to be displayed in design-mode.
		//
		if (!DesignMode())
				return S_OK;

        // show the frame ourselves if the host can't.
        //
        if (m_pControlSite) {
            hr = m_pControlSite->ShowPropertyFrame();
            if (hr != E_NOTIMPL)
                return hr;
        }

        IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

        // Allocate an array of CLSIDs
        //
        prgPropPages = (CLSID *) CtlHeapAlloc(g_hHeap, 0, CPROPPAGESOFCONTROL(m_ObjectType) * sizeof(CLSID));		
        if (!prgPropPages)
            return E_OUTOFMEMORY;

        // Copy the CLSIDs pointed to by the array of CLSID pointers to
        // an array of CLSIDs.  This conversion is necessary since OleCreatePropertyFrame
        // expects a pointer to an array of CLSIDs.  CPROPPAGESOFCONTROL(index) returns
        // a pointer to an array of CLSID pointers.
        //
        for (iPage = 0; iPage < CPROPPAGESOFCONTROL(m_ObjectType); iPage++)
            prgPropPages[iPage] = *((PPROPPAGESOFCONTROL(m_ObjectType))[iPage]);

        ModalDialog(TRUE);
        ENTERCRITICALSECTION1(&g_CriticalSection);  // This is for g_lcidLocale.
        hr = OleCreatePropertyFrame(GetActiveWindow(),
                            GetSystemMetrics(SM_CXSCREEN) / 2,
                            GetSystemMetrics(SM_CYSCREEN) / 2,
                            pwsz,
                            1,
                            &pUnk,
                            CPROPPAGESOFCONTROL(m_ObjectType),
                            prgPropPages,
                            g_lcidLocale,
                            NULL, NULL);
        LEAVECRITICALSECTION1(&g_CriticalSection);

        ModalDialog(FALSE);
        CtlHeapFree(g_hHeap, 0, prgPropPages);

        return hr;
        }

      default:
        // if it's a derived-control defined verb, pass it on to them
        //
        if (lVerb > 0) {
            hr = DoCustomVerb(lVerb);

            if (hr == OLEOBJ_S_INVALIDVERB) {
                // unrecognised verb -- just do the primary verb and
                // activate the sucker.
                //
                hr = InPlaceActivate(OLEIVERB_PRIMARY);
                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
            } else
                return hr;
        } else {
            // it's a verb we don't implement.
            //
            return E_NOTIMPL;
        }
        break;
    }

    // dead code
    FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs    [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//    IEnumOleVERB **    - [out] new enumerator.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::EnumVerbs
(
    IEnumOLEVERB **ppEnumVerbs
)
{
    int cVerbs;
    OLEVERB *rgVerbs, *pVerb;

    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
    BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

    // count up all the verbs
    //
    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
             + (fHasProperties ? 1 : 0) + cVerbExtra;

    // if there aren't any, this suddenly gets really easy !
    //
    if (cVerbs == 0)
        return OLEOBJ_E_NOVERBS;

    // HeapAlloc some storage for these dudes so that we can pass them on to
    // the standard enumerator!
    //
    if (! (rgVerbs = (OLEVERB *)CtlHeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB))))
        return E_OUTOFMEMORY;
  
    // start copying over verbs.  first, the in-place guys
    //
    pVerb = rgVerbs;
    if (fCanInPlace) {
        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
        pVerb += CINPLACEVERBS;
      }

    if (fCanUIActivate)
        memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

    // if their control has properties, copy that over now.
    //
    if (fHasProperties) {
        memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
        pVerb++;
    }

    // finally, any custom verbs!
    //
    if (cVerbExtra) {
        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
    }

    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) New CStandardEnum(IID_IEnumOLEVERB,
                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
    if (!*ppEnumVerbs)
        return E_OUTOFMEMORY;

    // this forces us to go and look for the Localized DLLs.  This is necessary here
    // because the CopyOleVerb will get information from localized resources, but
    // will only use the global GetResourceHandle, which only uses the global value
    // for the LCID.  This turns out to not be a big performance hit, since this
    // function is typically only called in design mode, and we stash this value.
    //
    GetResourceHandle();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.
//
// Output:
//    HRESULT            - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::Update
(
    void
)
{
    // nothing to do!!!
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate    [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.
//
// Output:
//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE
//
// Notes:
//
STDMETHODIMP COleControl::IsUpToDate
(
    void
)
{
    // we're always up to date
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//    CLSID *      - [in] where to put the CLSID
//
// Output:
//    HRESULT      - S_OK, E_FAIL
//
// Notes:
//
STDMETHODIMP COleControl::GetUserClassID
(
    CLSID *pclsid
)
{
    // this is the same as IPersist::GetClassID
    //
    return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//    DWORD        - [in]  specifies the form of the type name.
//    LPOLESTR *   - [out] where to put user type
//
// Output:
//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::GetUserType
(
    DWORD     dwFormOfType,
    LPOLESTR *ppszUserType
)
{
    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//    DWORD            - [in] which form or 'aspect'  is to be displayed.
//    SIZEL *          - [in] size limit for the control.
//
// Output:
//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::SetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *psizel
)
{
    SIZEL sl, slOld;
    RECT  rect;
    BOOL  f;


    if (dwDrawAspect & DVASPECT_CONTENT) {

	// Call to OnPosRectChange may cause our extents to be set again.  Accept the extents if this happens.
	//
	if (m_fChangingExtents)
	    return S_OK;    

	m_fChangingExtents = TRUE;

        // change the units to pixels, and resize the control.
        //
        HiMetricToPixel(psizel, &sl);

        // first call the user version.  if they return FALSE, they want
        // to keep their current size
        //	
        slOld = m_Size;
        f = OnSetExtent(&sl);
        if (f)			
            m_Size = sl;      /// Note: subclassing control may change the passed in &sl extents				

        if (slOld.cx != m_Size.cx || slOld.cy != m_Size.cy)
            m_fDirty = TRUE;

        // set things up with our HWND if we've got one.
        //
        if (!m_pInPlaceSiteWndless) 
		{
            if (m_fInPlaceActive) 
			{
    
                // theoretically, one should not need to call OnPosRectChange
                // here, but there appear to be a few host related issues that
                // will make us keep it here.  we won't, however, both with
                // windowless ole controls, since they are all new hosts who
                // should know better
                //
				if (m_hwnd) 
				{

					rect = m_rcLocation;
			
					rect.right = rect.left + m_Size.cx;
					rect.bottom = rect.top + m_Size.cy;
					GetInPlaceSite()->OnPosRectChange(&rect);  // May cause container to call our SetObjectRects
				}
	                    
            } 
			else if (m_hwnd) 
			{
                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            } 
			else 
			{
                ViewChanged();
            }
        }

		if (!m_fInPlaceActive)
		{
			// Due to trident, we need to call RequestNewObjectLayout
			// here so we visually display our new extents.

			if (m_pClientSite)
				m_pClientSite->RequestNewObjectLayout();
		}

	m_fChangingExtents = FALSE;

        // return code depending on whether or not user accepted given
        // size
        //
        return (f) ? S_OK : E_FAIL;

    } else {
        // we don't support any other aspects.
        //
        return DV_E_DVASPECT;
    }

    // dead code
    FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//    DWORD            - [in] aspect
//    SIZEL *          - [in] where to put results
//
// Output:
//    S_OK, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *pSizeLOut
)
{

    if (dwDrawAspect & DVASPECT_CONTENT) {
        PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//    IAdviseSink *     - [in]  advise sink of calling object
//    DWORD             - [out] cookie
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::Advise
(
    IAdviseSink *pAdviseSink,
    DWORD       *pdwConnection
)
{
    HRESULT hr;

    // if we haven't yet created a standard advise holder object, do so
    // now
    //
    if (!m_pOleAdviseHolder) {
        hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
        RETURN_ON_FAILURE(hr);
    }

    // just get it to do the work for us!
    //
    return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//    DWORD         - [in] connection cookie
//
// Output:
//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION
//
// Notes:
//
STDMETHODIMP COleControl::Unadvise
(
    DWORD dwConnection
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
        CONNECT_E_NOCONNECTION;
    }

    return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//    IEnumSTATDATA **    - [out] where to put enumerator
//
// Output:
//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::EnumAdvise
(
    IEnumSTATDATA **ppEnumOut
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody Called EnumAdvise without setting up any connections");
        *ppEnumOut = NULL;
        return E_FAIL;
    }

    return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//    DWORD         - [in]  aspect desired
//    DWORD *       - [out] where to put the bits.
//
// Output:
//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//
STDMETHODIMP COleControl::GetMiscStatus
(
    DWORD  dwAspect,
    DWORD *pdwStatus
)
{
    CHECK_POINTER(pdwStatus);

    if (dwAspect == DVASPECT_CONTENT) {
        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme    [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//    LOGPALETTE *     - [in] new palette
//
// Output:
//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't care.
//
STDMETHODIMP COleControl::SetColorScheme
(
    LOGPALETTE *pLogpal
)
{
    // OVERRIDE: control writers can use this if they want to
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//    HWND *        - [out] where to return window handle.
//
// Output:
//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//    - this routine has slightly different semantics for windowless controls
//
STDMETHODIMP COleControl::GetWindow
(
    HWND *phwnd
)
{
    // if we're windowles, then we want to return E_FAIL for this so hosts
    // know we're windowless.  we'll also fail if we're not in-place active
    //
    if (m_pInPlaceSiteWndless || !m_fInPlaceActive)
        return E_FAIL;

    // otherwise, just return our outer window.
    //
    *phwnd = GetOuterWindow();

    return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//    BOOL            - [in] whether or not to enter help mode.
//
// Output:
//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::ContextSensitiveHelp
(
    BOOL fEnterMode
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//    LONG         - [in] the verb that caused us to activate
//
// Output:
//    HRESULT
//
// Notes:
//    - this is spaghetti code at it's worst.  effectively, we have to
//      be able to handle three types of site pointers -- IOleInPlaceSIte,
//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//      pretty.
//
HRESULT COleControl::InPlaceActivate
(
    LONG lVerb
)
{
    BOOL f;
    SIZEL sizel;
    IOleInPlaceSiteEx *pIPSEx = NULL;
    HRESULT hr;
    BOOL    fNoRedraw = FALSE;
    HWND    hwndParent;

    // if we don't have a client site, then there's not much to do.
    //
    if (!m_pClientSite)
        return S_OK;

    // get an InPlace site pointer.
    //
    if (!GetInPlaceSite()) {

        // if they want windowless support, then we want IOleInPlaceSiteWindowless
        //
        if (FCONTROLISWINDOWLESS(m_ObjectType))
            m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

        // if we're not able to do windowless siting, then we'll just get an
        // IOleInPlaceSite pointer.
        //
        if (!m_pInPlaceSiteWndless) {
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            RETURN_ON_FAILURE(hr);
        }
    }

    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
    // activation.  if we're windowless, we've already got it, else we need to
    // try and get it
    //
    if (m_pInPlaceSiteWndless) {
        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
        pIPSEx->AddRef();
    } else
        m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

    // if we're not already active, go and do it.
    //
    if (!m_fInPlaceActive || !m_fInPlaceVisible) {
        OLEINPLACEFRAMEINFO InPlaceFrameInfo;
        RECT rcPos, rcClip;
	BOOL fJustSetPosition  = m_fInPlaceActive;

        // if we have a windowless site, see if we can go in-place windowless
        // active
        //
        hr = S_FALSE;

	if (fJustSetPosition)
		hr = S_OK;
        else if (m_pInPlaceSiteWndless) {
            hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
            CLEANUP_ON_FAILURE(hr);

            // if they refused windowless, we'll try windowed
            //
            if (S_OK != hr) {
                ASSERT(m_pInPlaceSite == NULL, "In-place site is non-NULL.  We're gonna leak.");
                RELEASE_OBJECT(m_pInPlaceSiteWndless);
                hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
                CLEANUP_ON_FAILURE(hr);
            }
        }

        // just try regular windowed in-place activation
        //
        if (hr != S_OK) {
            hr = m_pInPlaceSite->CanInPlaceActivate();
            if (hr != S_OK) {
                hr = (FAILED(hr)) ? E_FAIL : hr;
                goto CleanUp;
            }
        }

	if (!fJustSetPosition)
	{
		// if we are here, then we have permission to go in-place active.
		// now, announce our intentions to actually go ahead and do this.
		//
		hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
			       : m_pInPlaceSite->OnInPlaceActivate();
		CLEANUP_ON_FAILURE(hr);

		// if we're here, we're ready to go in-place active.  we just need
		// to set up some flags, and then create the window [if we have
		// one]
		//
		m_fInPlaceActive = TRUE;
	}

	// In VB4, the position could have been changed while we
	// were invisible, so if we were already InPlaceActive but not visible
	// we need to get our size.
	// REVIEW: Is this much of a performance hit? Is there a way to tell
	// we've been resized in this case?

        // we need to get some information about our location in the parent
        // window, as well as some information about the parent
        //
        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        hr = GetInPlaceSite()->GetWindow(&hwndParent);
        if (SUCCEEDED(hr))
        {

#ifdef MDAC_BUILD
#if 0 
            //	hack fix for MDAC 8536 & 8738. 
            //	To be used if VB doesn't/can't fix the real bug(s); hwndParent (or it's parent) is not sized properly.
            //	Unfortunately, this code also affects the hf grid. If we need to add a virtual function bool ResizeParentBeforeCreation() 
            //	to COleControl (it should return false) and to the de.
            if ( ResizeParentBeforeCreation() )
            {
	            SIZE parent_size = m_Size;
	            if ( HWND grandparent = GetParent(hwndParent) )
	            {
		            RECT grandparent_bounds;
		            GetClientRect(grandparent,&grandparent_bounds);
		            parent_size.cx = grandparent_bounds.right;
		            parent_size.cy = grandparent_bounds.bottom;
	            }
	            if ( parent_size.cx > 0 && parent_size.cy > 0 )
	            {
		            SetWindowPos(hwndParent,NULL,0,0,parent_size.cx,parent_size.cy,SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
	            }
            }
#endif
#endif

          if(m_pInPlaceFrame)
            RELEASE_OBJECT(m_pInPlaceFrame);

          if(m_pInPlaceUIWindow)
            RELEASE_OBJECT(m_pInPlaceUIWindow);

          hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
        }
        CLEANUP_ON_FAILURE(hr);

        // make sure we'll display ourselves in the correct location with the correct size
        //
        sizel.cx = rcPos.right - rcPos.left;
        sizel.cy = rcPos.bottom - rcPos.top;
        f = OnSetExtent(&sizel);
        if (f) m_Size = sizel;
        SetObjectRects(&rcPos, &rcClip);

        // finally, create our window if we have to!
        //
	if (!fJustSetPosition && 
		!m_pInPlaceSiteWndless) {
    
            SetInPlaceParent(hwndParent);

            // create the window, and display it.  die horribly if we couldnt'
            //
            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
                hr = E_FAIL;
                goto CleanUp;
            }

            // finally, tell the host of this
            //
            if (m_pClientSite)
                m_pClientSite->ShowObject();
        }
    }

    // don't need this any more
    //
    RELEASE_OBJECT(pIPSEx);

    // if we're not inplace visible yet, do so now.
    //
    if (!m_fInPlaceVisible)
        SetInPlaceVisible(TRUE);

    // if we weren't asked to UIActivate, then we're done.
    //
    if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
        return S_OK;

    // if we're not already UI active, do sow now.
    //
    if (!m_fUIActive) {
        m_fUIActive = TRUE;

        // inform the container of our intent
        //
        GetInPlaceSite()->OnUIActivate();

        // take the focus  [which is what UI Activation is all about !]
        //
        SetFocus(TRUE);

        // set ourselves up in the host.
        //
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

        // we have to explicitly say we don't wany any border space.
        //
        m_pInPlaceFrame->SetBorderSpace(NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetBorderSpace(NULL);
    }

    // be-de-be-de-be-de that's all folks!
    //
    return S_OK;

  CleanUp:
    // something catastrophic happened [or, at least something bad].
    // die a horrible fiery mangled painful death.
    //
    QUICK_RELEASE(pIPSEx);
    m_fInPlaceActive = FALSE;
    return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//    HRESULT        - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::InPlaceDeactivate
(
    void
)
{
    // if we're not in-place active yet, then this is easy.
    //
    if (!m_fInPlaceActive)
        return S_OK;

    // transition from UIActive back to active
    //
    if (m_fUIActive)
        UIDeactivate();

    // tell the host we're going away
    //
    GetInPlaceSite()->OnInPlaceDeactivate();

    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;


    // if we have a window, tell it to go away.
    //
    if (m_hwnd) {
        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up");
        
        DestroyWindow(m_hwnd);

        if (m_hwndReflect) {
            SetWindowLong(m_hwndReflect, GWL_USERDATA, 0);
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }
    }

    RELEASE_OBJECT(m_pInPlaceFrame);
    RELEASE_OBJECT(m_pInPlaceUIWindow);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//    HRESULT         - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::UIDeactivate
(
    void
)
{
    // if we're not UIActive, not much to do.
    //
    if (!m_fUIActive)
        return S_OK;

    m_fUIActive = FALSE;

    // notify frame windows, if appropriate, that we're no longer ui-active.
    //
    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
    m_pInPlaceFrame->SetActiveObject(NULL, NULL);

    // we don't need to explicitly release the focus here since somebody
    // else grabbing the focus is what is likely to cause us to get lose it
    //
    GetInPlaceSite()->OnUIDeactivate(FALSE);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//    LPCRECT        - [in] position of the control.
//    LPCRECT        - [in] clipping rectangle for the control.
//
// Output:
//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetObjectRects
(
    LPCRECT prcPos,
    LPCRECT prcClip
)
{

#ifdef DEBUG
    RECT rcDebug;
    POINT ptDebug;
#endif

    BOOL fRemoveWindowRgn;

    // save out our current location.  windowless controls want this more
    // that windowed ones do, but everybody can have it just in case
    //
	// VEGAS#25109: a-cmai 3/9/98 -- Update m_rcLocation prior to doing
	// work for windowed controls.  This is because the SetWindowPos call
	// may reenter when the control resizes itself.  SetExtent requires that
	// m_rcLocation contains the recent window location
	//
    m_rcLocation = *prcPos;

    // move our window to the new location and handle clipping. not applicable
    // for windowless controls, since the container will be responsible for all
    // clipping.
    //
    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to
            //
            RECT rcIXect;
            if ( IntersectRect(&rcIXect, prcPos, prcClip) ) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
                    SetWindowRgn(GetOuterWindow(), CreateRectRgnIndirect(&rcIXect), TRUE);
                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(GetOuterWindow(), NULL, TRUE);
            m_fUsingWindowRgn = FALSE;
        }

        RECT rc;
        POINT pt;

        pt.x = pt.y = 0;

        ClientToScreen(GetParent(GetOuterWindow()), &pt);
        GetWindowRect(GetOuterWindow(), &rc);

        OffsetRect(&rc, - pt.x, - pt.y);

        DWORD dwFlags = SWP_NOZORDER | SWP_NOACTIVATE;

        if (rc.left == prcPos->left && rc.top == prcPos->top)
            dwFlags |= SWP_NOMOVE;
        if ((rc.right - rc.left) == (prcPos->right - prcPos->left) && 
            (rc.bottom - rc.top) == (prcPos->bottom - prcPos->top))
            dwFlags |= SWP_NOSIZE;

        // We don't support zooming.  Instead we resize the window
        // to the given size and redraw within the new size.
        //
        // Note: The OuterWindow is either the reflector or control window
        //
        SetWindowPos(GetOuterWindow(), NULL, prcPos->left, 
			prcPos->top, 
			prcPos->right - prcPos->left, 
			prcPos->bottom - prcPos->top, 
			dwFlags);
#if DEBUG

        // Make sure we caused a size change
        //
        if (!(dwFlags & SWP_NOSIZE))
        {
            ptDebug.x = ptDebug.y = 0;

            ClientToScreen(GetParent(GetOuterWindow()), &ptDebug);
            GetWindowRect(GetOuterWindow(), &rcDebug);

            OffsetRect(&rcDebug, - ptDebug.x, - ptDebug.y);

            // If these asserts get tripped that means the size changed between the SetWindowPos call and here
            // Note: SetWindowPos will generate WM_NCCALCSIZE, WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED along with
            //       possible WM_NCPAINT, WM_PAINT and WM_SIZE.  If in response to any of these messages we end up changing
            //       the size, then we may have a problem.
            //        
            if ((prcPos->right - prcPos->left) != (rcDebug.right - rcDebug.left))
                OutputDebugString("Width not set to expected value");
            if ((prcPos->bottom - prcPos->top) != (rcDebug.bottom - rcDebug.top))
                OutputDebugString("Height not set to expected value");            
        }
            
#endif            
	
        // VEGAS#25109: a-cmai 3/9/98 -- Update m_rcLocation
		// after the call to SetWindowPos, since the window pos
		// and or size may have been altered by the control
		//
		GetWindowRect(GetOuterWindow(), &m_rcLocation);
        OffsetRect(&m_rcLocation, - pt.x, - pt.y);

        // No need to resize the window again if GetOuterWindow is the same
        //
        if (m_hwnd && GetOuterWindow() != m_hwnd)
            // We're position within the reflector window, so set position to 0, 0 
            //
            SetWindowPos(m_hwnd, 0, 0, 0, 
                m_rcLocation.right - m_rcLocation.left, 
                m_rcLocation.bottom - m_rcLocation.top,
                SWP_NOZORDER | SWP_NOACTIVATE);				
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//    HRESULT        - S_OK, E_NOTUNDOABLE
//
// Notes:
//
STDMETHODIMP COleControl::ReactivateAndUndo
(
    void
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//    UINT                - [in]  the message
//    WPARAM              - [in]  the messages wparam
//    LPARAM              - [in]  duh.
//    LRESULT *           - [out] the output value
//
// Output:
//    HRESULT             - S_OK
//
// Notes:
//    - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//      writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//
STDMETHODIMP COleControl::OnWindowMessage
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *plResult
)
{
    // little bit of pre-processing -- we need to handle some cases here
    // before passing the messages on
    //
    switch (msg) {
        // make sure our UI Activation correctly matches the focus
        //
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            // give the control site focus notification
            //
            if (m_fInPlaceActive && m_pControlSite)
                m_pControlSite->OnFocus(msg == WM_SETFOCUS);
            break;
    }

    // just pass it to the control's window proc.
    //
    *plResult = WindowProc(msg, wParam, lParam);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//    IDropTarget **        - [out]
//
// Output:
//    HRESULT               - S_OK, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::GetDropTarget
(
    IDropTarget **ppDropTarget
)
{
    // OVERRIDE: if you want to do drag and drop and you're windowless,
    // override me.
    //
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//    LPMSG            - [in] the message that has the special key in it.
//
// Output:
//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::TranslateAccelerator
(
    LPMSG    pmsg
)
{
    // see if we want it or not.
    //
    if (OnSpecialKey(pmsg))
        return S_OK;

    // if not, then we want to forward it back to the site for further processing
    //
    if (m_pControlSite)
        return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

    // we didn't want it.
    //
    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//    BOOL        - [in] state of containers top level window.
//
// Output:
//    HRESULT     - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnFrameWindowActivate
(
    BOOL fActivate
)
{
    // OVERRIDE:  override this routine if you want floating toolbars,
    // toolboxes, etc.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//    BOOL            - state of mdi child window.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnDocWindowActivate
(
    BOOL fActivate
)
{
    // OVERRIDE: override this routine if you want floating toolbars,
    // toolboxes, etc.

    // if we're supposed to activate and we're UI active, then just go and
    // default to clearing out the toolbar space.
    //
    if (m_fUIActive && fActivate)
        m_pInPlaceFrame->SetBorderSpace(NULL);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//    LPCRECT               - [in] new outer rectangle for border space
//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//    BOOL                  - [in] true if it was the fram window taht called.
//
// Output:
//    HRESULT               - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::ResizeBorder
(
    LPCRECT              prcBorder,
    IOleInPlaceUIWindow *pInPlaceUIWindow,
    BOOL                 fFrame
)
{
    // this is largely uninteresting to us, since we have no border.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//    BOOL            - [in] enable or disable modeless dialogs.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::EnableModeless
(
    BOOL fEnable
)
{
    // phenomenally uninteresting
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo    [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//    ITypeInfo **        - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassInfo
(
    ITypeInfo **ppTypeInfo
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;

    CHECK_POINTER(ppTypeInfo);
    *ppTypeInfo = NULL;

    // go and get our type library.
    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.
    // CONSIDER: - consider trying to register our typelib if this fails.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);  // This is for g_lcidlocale.
    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 
			(USHORT)VERSIONMINOROFOBJECT(m_ObjectType),
                        LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
    LEAVECRITICALSECTION1(&g_CriticalSection);
    RETURN_ON_FAILURE(hr);

    // got the typelib.  get typeinfo for our coclass.
    //
    hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
    pTypeLib->Release();
    RETURN_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange    [callable]
//=--------------------------------------------------------------------------=
// called whenever the view of the object has changed.
//
// Notes:
//
void COleControl::ViewChanged
(
    void
)
{
    // send the view change notification to anybody listening.
    //
    if (m_pViewAdviseSink) {
        m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

        // if they only asked to be advised once, kill the connection
        //
        if (m_fViewAdviseOnlyOnce)
            SetAdvise(DVASPECT_CONTENT, 0, NULL);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//    BOOL        - TRUE shows FALSE hides.
//
// Notes:
//
void COleControl::SetInPlaceVisible
(
    BOOL fShow
)
{
    BOOL fVisible;

    m_fInPlaceVisible = fShow;

    // don't do anything if we don't have a window.  otherwise, set it
    //
    if (m_hwnd) {
        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) & WS_VISIBLE) != 0);

        if (fVisible && !fShow)
            ShowWindow(GetOuterWindow(), SW_HIDE);
        else if (!fVisible && fShow)
            ShowWindow(GetOuterWindow(), SW_SHOWNA);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::AmbientPropertyChanged    [overridable]
//=--------------------------------------------------------------------------=
// a method that derived controls can override to do whatever they want.
// we don't particularily care about this event.
//
// Parameters:
//    DISPID            - [in] dispid of prop that changed.
//
// Notes:
//
void COleControl::AmbientPropertyChanged
(
    DISPID dispid
)
{
    // do nothing
}

//=--------------------------------------------------------------------------=
// COleControl::DoCustomVerb    [overridable]
//=--------------------------------------------------------------------------=
// we were asked to execute a verb we don't know about right away.  see if
// it's a verb that the dervied-control defined.
//
// Parameters:
//    LONG            - [in] the verb.
//
// Output:
//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB
//
// Notes:
//
HRESULT COleControl::DoCustomVerb
(
    LONG    lVerb
)
{
    return OLEOBJ_S_INVALIDVERB;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetExtent    [overridable]
//=--------------------------------------------------------------------------=
// let the user do something in the resize, if they care.
//
// Parameters:
//    SIZEL *        - [in] new values.
//
// Output:
//    BOOL           - FALSE means keep current size
//
// Notes:
//
BOOL COleControl::OnSetExtent
(
    SIZEL *pSizeL
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSpecialKey    [overridable]
//=--------------------------------------------------------------------------=
// allows controls to handle special keys such as arrows, CTRL+, etc ...
//
// Parameters:
//    LPMSG        - [in] the special key msg.
//
// Output:
//    BOOL         - TRUE we processed it, FALSE we didn't.
//
// Notes:
//
BOOL COleControl::OnSpecialKey
(
    LPMSG pmsg
)
{
    // do nothing.
    //
    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ModalDialog    [callable, utility]
//=--------------------------------------------------------------------------=
// should be called when the control is about to show and hide a modal dialog.
//
// Parameters:
//    BOOL        - [in] true means showing a modal dialog, false means done
//
// Notes:
//
void COleControl::ModalDialog
(
    BOOL fShow
)
{
    // notify the container of our intention to show a modal dialog...
    //
    if (m_pInPlaceFrame)
        m_pInPlaceFrame->EnableModeless(!fShow);
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we destroy a window.  gives the user the opportunity to
// save information out, especially if they're a subclassed control, and this
// is an interesting thing to do.
//
// Notes:
//
void COleControl::BeforeDestroyWindow
(
    void
)
{
    // fweeee
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetClientSite    [overrideable]
//=--------------------------------------------------------------------------=
// controls should implement this if they hold on to anything off the site.
// this is important to correctly support aggregation.  they must free up
// everything they hold on to, and if m_pClientSite is not NULL, then they
// can re-establish things as they wish.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::OnSetClientSite
(
    void
)
{
    // by default, the framework frees up everything in SetClientSite
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlhelp.cpp ===
//=--------------------------------------------------------------------------=
// CtlHelper.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// helper routines for our COleControl implementation
//
#include "pch.h"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include <windowsx.h>

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// this is used by the window reflection code.
//
extern BYTE g_fRegisteredReflect;
extern const char g_szReflectClassName [];


// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.
//
static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };


//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.
//
// Notes:
//
short _SpecialKeyState()
{
    // don't appear to be able to reduce number of calls to GetKeyState
    //
    BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
    BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
    BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

    return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}

//=--------------------------------------------------------------------------=
// CopyOleVerb    [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//    void *        - [out] where to copy to
//    const void *  - [in]  where to copy from
//    DWORD         - [in]  bytes to copy
//
// Notes:
//
void WINAPI CopyOleVerb
(
    void       *pvDest,
    const void *pvSrc,
    DWORD       cbCopy
)
{
    VERBINFO * pVerbDest = (VERBINFO *) pvDest;
    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

    *pVerbDest = *pVerbSrc;
    ((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown    [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//    IUnknown *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
COleControl *ControlFromUnknown
(
    IUnknown *pUnk
)
{
	HRESULT hr;
    IControlPrv *pControlPrv = NULL;
	COleControl *pCtl = NULL;

    if (!pUnk) return NULL;
    hr = pUnk->QueryInterface(IID_IControlPrv, (void **)&pControlPrv);
	ASSERT(SUCCEEDED(hr), "Failed to get IControlPrv interface");

	hr = pControlPrv->GetControl(&pCtl);
	ASSERT(SUCCEEDED(hr), "Failed to get COleControl pointer");
	QUICK_RELEASE(pControlPrv);
	
    return pCtl;
}

//=--------------------------------------------------------------------------=
// CreateReflectWindow    [blech]
//=--------------------------------------------------------------------------=
// unfortunately, in certain cases, we have to create two windows, one of
// which exists strictly to reflect messages on to the control.  Majorly
// lame.  Fortunately, the number of hosts which require this is quite small.
//
// Parameters:
//    BOOL        - [in] should it be created visible?
//    HWND        - [in] parent window
//    int         - [in] x pos
//    int         - [in] y pos
//    SIZEL *     - [in] size
//
// Output:
//    HWND        - reflecting hwnd or NULL if it failed.
//
// Notes:
//
HWND CreateReflectWindow
(
    BOOL   fVisible,
    HWND   hwndParent,
    int    x,
    int    y,
    SIZEL *pSize
)
{
    WNDCLASS wndclass;

    // first thing to do is register the window class.  crit sect this
    // so we don't have to move it into the control
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fRegisteredReflect) {

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.lpfnWndProc = COleControl::ReflectWindowProc;
        wndclass.hInstance   = g_hInstance;
        wndclass.lpszClassName = g_szReflectClassName;

        if (!RegisterClass(&wndclass)) {
            FAIL("Couldn't Register Parking Window Class!");
            LEAVECRITICALSECTION1(&g_CriticalSection);
            return NULL;
        }
        g_fRegisteredReflect = TRUE;
    }

    LEAVECRITICALSECTION1(&g_CriticalSection);

    // go and create the window.
    //
    return CreateWindowEx(0, g_szReflectClassName, NULL,
                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0),
                          x, y, pSize->cx, pSize->cy,
                          hwndParent,
                          NULL, g_hInstance, NULL);
}

//=--------------------------------------------------------------------------=
// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.
//
// Note: As of VB6 we added ParkingWindowProc to the framework.
//       The ParkingWindowProc supports message reflection which is normally
//       the code you add to your implementation of ParkingWindowProc.
//       In most cases you can probably set this to NULL in your control's
//       implementation 
//
extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//    HWND                - our parking window
//
// Notes:
//
HWND GetParkingWindow
(
    void
)
{
    WNDCLASS wndclass;

    // crit sect this creation for apartment threading support.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (g_hwndParking)
        goto CleanUp;

    ZeroMemory(&wndclass, sizeof(wndclass));
    
    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : COleControl::ParkingWindowProc;
    wndclass.hInstance   = g_hInstance;
    wndclass.lpszClassName = "CtlFrameWork_Parking";

    if (!RegisterClass(&wndclass)) {
        FAIL("Couldn't Register Parking Window Class!");
        goto CleanUp;
    }

    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL);
    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!");


  CleanUp:
    LEAVECRITICALSECTION1(&g_CriticalSection);
    return g_hwndParking;
}

//=--------------------------------------------------------------------------=
// ParkingWindowProc
//=--------------------------------------------------------------------------=
// Provides default processing for the parking window.  Since your control
// may be parented by the parking window, we provide message reflection.
//
LRESULT CALLBACK COleControl::ParkingWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lResult;

    // If the message is reflected then return the result of the OCM_ message
    //
    if (ReflectOcmMessage(hwnd, msg, wParam, lParam, &lResult))
        return lResult;
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlhelp.h ===
//=--------------------------------------------------------------------------=
// CtlHelper.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// routines to help out our implementation of COleControl.
//


//=--------------------------------------------------------------------------=
// misc functions
//
short       _SpecialKeyState(void);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

HWND        CreateReflectWindow(BOOL fVisible, HWND hwndParent, int, int, SIZEL *);
void        CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlmisc.cpp ===
//=--------------------------------------------------------------------------=
// ControlMisc.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// things that aren't elsewhere, such as property pages, and connection
// points.
//
#include "pch.h"
#include "CtrlObj.H"
#include "CtlHelp.H"

#include <stdarg.h>

// for ASSERT and FAIL
//
SZTHISFILE

// this is used in our window proc so that we can find out who was last created
//
static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//    IUnknown *          - [in] controlling Unknown
//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_*
//    void *              - [in] pointer to entire object
//
// Notes:
//
COleControl::COleControl
(
    IUnknown *pUnkOuter,
    int       iPrimaryDispatch,
    void     *pMainInterface
)
: CAutomationObjectWEvents(pUnkOuter, iPrimaryDispatch, pMainInterface)
{
    // initialize all our variables -- we decided against using a memory-zeroing
    // memory allocator, so we sort of have to do this work now ...
    //
    m_pClientSite = NULL;
    m_pControlSite = NULL;
    m_pInPlaceSite = NULL;
    m_pInPlaceFrame = NULL;
    m_pInPlaceUIWindow = NULL;


    m_pInPlaceSiteWndless = NULL;

    // certain hosts don't like 0,0 as your initial size, so we're going to set
    // our initial size to 100,50 [so it's at least sort of visible on the screen]
    //
    m_Size.cx = 100;
    m_Size.cy = 50;
    memset(&m_rcLocation, 0, sizeof(m_rcLocation));

    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_hwndReflect = NULL;
    m_fHostReflects = TRUE;
    m_fCheckedReflecting = FALSE;

    m_pSimpleFrameSite = NULL;
    m_pOleAdviseHolder = NULL;
    m_pViewAdviseSink = NULL;
    m_pDispAmbient = NULL;

    m_fDirty = FALSE;
    m_fModeFlagValid = FALSE;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_fSaveSucceeded = FALSE;
    m_fViewAdvisePrimeFirst = FALSE;
    m_fViewAdviseOnlyOnce = FALSE;
    m_fRunMode = FALSE;
    m_fChangingExtents = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//    - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
    ASSERT(!m_hwnd, "We shouldn't have a window any more!");

    if (m_hwndReflect) {
        SetWindowLong(m_hwndReflect, GWL_USERDATA, 0);
        DestroyWindow(m_hwndReflect);
    }

    // clean up all the pointers we're holding around.
    //
    QUICK_RELEASE(m_pClientSite);
    QUICK_RELEASE(m_pControlSite);
    QUICK_RELEASE(m_pInPlaceSite);
    QUICK_RELEASE(m_pInPlaceFrame);
    QUICK_RELEASE(m_pInPlaceUIWindow);
    QUICK_RELEASE(m_pSimpleFrameSite);
    QUICK_RELEASE(m_pOleAdviseHolder);
    QUICK_RELEASE(m_pViewAdviseSink);
    QUICK_RELEASE(m_pDispAmbient);

    QUICK_RELEASE(m_pInPlaceSiteWndless);
}

#ifndef DEBUG
#pragma optimize("t", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//    - NOTE: this function is speed critical!!!!
//
HRESULT COleControl::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    switch (riid.Data1) 
	{
        // private interface for prop page support
        QI_INHERITS(this, IOleControl);
        QI_INHERITS(this, IPointerInactive);
        QI_INHERITS(this, IQuickActivate);
        QI_INHERITS(this, IOleObject);
        QI_INHERITS((IPersistStorage *)this, IPersist);
        QI_INHERITS(this, IPersistStreamInit);
        QI_INHERITS(this, IOleInPlaceObject);
        QI_INHERITS(this, IOleInPlaceObjectWindowless);
        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
        QI_INHERITS(this, IOleInPlaceActiveObject);
        QI_INHERITS(this, IViewObject);
        QI_INHERITS(this, IViewObject2);
        QI_INHERITS(this, IViewObjectEx);
        QI_INHERITS(this, ISpecifyPropertyPages);
        QI_INHERITS(this, IPersistStorage);
        QI_INHERITS(this, IPersistPropertyBag);
        QI_INHERITS(this, IProvideClassInfo);
		QI_INHERITS(this, IControlPrv);

        default:
            goto NoInterface;
    }

    // we like the interface, so addref and return
    //
    ((IUnknown *)(*ppvObjOut))->AddRef();
    return S_OK;

  NoInterface:
    // delegate to super-class for automation interfaces, etc ...
    //
    return CAutomationObjectWEvents::InternalQueryInterface(riid, ppvObjOut);
}

#ifndef DEBUG
#pragma optimize("s", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyObject   [overridden]
//=--------------------------------------------------------------------------=
// if we're in the process of shutting down and destroying ourselves, then we
// need to trash our window here so we can avoid pure virtual calls from 
// within colecontol's destructor
//
// Notes:
//
void COleControl::BeforeDestroyObject
(
    void
)
{
    if (m_hwnd) {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }
}

//=--------------------------------------------------------------------------=
// COleControl::GetPages    [ISpecifyPropertyPages]
//=--------------------------------------------------------------------------=
// returns a counted array with the guids for our property pages.
//
// parameters:
//    CAUUID *    - [out] where to put the counted array.
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::GetPages
(
    CAUUID *pPages
)
{
    const GUID **pElems;
    void *pv;
    WORD  x;

    // if there are no property pages, this is actually pretty easy.
    //
    if (!CPROPPAGESOFCONTROL(m_ObjectType)) {
        pPages->cElems = 0;
        pPages->pElems = NULL;
        return S_OK;
    }

    // fill out the Counted array, using IMalloc'd memory.
    //
    pPages->cElems = CPROPPAGESOFCONTROL(m_ObjectType);
    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages->cElems));
    RETURN_ON_NULLALLOC(pv);
    pPages->pElems = (GUID *)pv;

    // loop through our array of pages and get 'em.
    //
    pElems = PPROPPAGESOFCONTROL(m_ObjectType);
    for (x = 0; x < pPages->cElems; x++)
        pPages->pElems[x] = *(pElems[x]);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//    int            - [in] left
//    int            - [in] top
//    BOOL           - [in] can we skip redrawing?
//
// Output:
//    HWND
//
// Notes:
//    - DANGER! DANGER!  this function is protected so that anybody can call it
//      from their control.  however, people should be extremely careful of when
//      and why they do this.  preferably, this function would only need to be
//      called by an end-control writer in design mode to take care of some
//      hosting/painting issues.  otherwise, the framework should be left to
//      call it when it wants.
//
HWND COleControl::CreateInPlaceWindow
(
    int  x,
    int  y,
    BOOL fNoRedraw
)
{
    BOOL    fVisible;
    DWORD   dwWindowStyle, dwExWindowStyle;
    char    szWindowTitle[128];

    // if we've already got a window, do nothing.
    //
    if (m_hwnd)
        return m_hwnd;

    // get the user to register the class if it's not already
    // been done.  we have to critical section this since more than one thread
    // can be trying to create this control
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
        if (!RegisterClassData()) {
            LEAVECRITICALSECTION1(&g_CriticalSection);
            return NULL;
        } else 
            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // let the user set up things like the window title, the
    // style, and anything else they feel interested in fiddling
    // with.
    //
    dwWindowStyle = dwExWindowStyle = 0;
    szWindowTitle[0] = '\0';
    if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
        return NULL;

    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

    // create window visible if parent hidden (common case)
    // otherwise, create hidden, then shown.  this is a little subtle, but
    // it makes sense eventually.
    //
    if (!m_hwndParent)
        m_hwndParent = GetParkingWindow();

    fVisible = IsWindowVisible(m_hwndParent);

    // This one kinda sucks -- if a control is subclassed, and we're in
    // a host that doesn't support Message Reflecting, we have to create
    // the user window in another window which will do all the reflecting.
    // VERY blech. [don't however, bother in design mode]
    //
    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) && (m_hwndParent != GetParkingWindow())) {
        // determine if the host supports message reflecting.
        //
        if (!m_fCheckedReflecting) {
            VARIANT_BOOL f;
            if (!GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &f) || !f)
                m_fHostReflects = FALSE;
            m_fCheckedReflecting = TRUE;
        }

        // if the host doesn't support reflecting, then we have to create
        // an extra window around the control window, and then parent it
        // off that.
        //
        if (!m_fHostReflects) {
            ASSERT(m_hwndReflect == NULL, "Where'd this come from?");
            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &m_Size);
            if (!m_hwndReflect)
                return NULL;
            SetWindowLong(m_hwndReflect, GWL_USERDATA, (long)this);
            dwWindowStyle |= WS_VISIBLE;
        }
    } else {
        if (!fVisible)
            dwWindowStyle |= WS_VISIBLE;
    }

    // we have to mutex the entire create window process since we need to use
    // the s_pLastControlCreated to pass in the object pointer.  nothing too
    // serious
    //
    ENTERCRITICALSECTION2(&g_CriticalSection);
    s_pLastControlCreated = this;
    m_fCreatingWindow = TRUE;

    // finally, go create the window, parenting it as appropriate.
    //
    m_hwnd = CreateWindowEx(dwExWindowStyle,
                            WNDCLASSNAMEOFCONTROL(m_ObjectType),
                            szWindowTitle,
                            dwWindowStyle,
                            (m_hwndReflect) ? 0 : x,
                            (m_hwndReflect) ? 0 : y,
                            m_Size.cx, m_Size.cy,
                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent,
                            NULL, g_hInstance, NULL);

    // clean up some variables, and leave the critical section
    //
    m_fCreatingWindow = FALSE;
    s_pLastControlCreated = NULL;
    LEAVECRITICALSECTION2(&g_CriticalSection);

    if (m_hwnd) {
        // let the derived-control do something if they so desire
        //
        if (!AfterCreateWindow()) {
            DestroyWindow(m_hwnd);
            return NULL;
        }

        // if we didn't create the window visible, show it now.
        //
        if (fVisible)
            SetWindowPos(m_hwnd, NULL, 0, 0, 0, 0,
                         SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | ((fNoRedraw) ? SWP_NOREDRAW : 0));
    }

    return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent    [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//    HWND            - [in] new parent window
//
// Notes:
//
void COleControl::SetInPlaceParent
(
    HWND hwndParent
)
{
#ifdef DEBUG
    HWND hwndOld;
    DWORD dw;
#endif

    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

    if (m_hwndParent == hwndParent)
        return;

    m_hwndParent = hwndParent;
    if (m_hwnd)
    {

#ifdef DEBUG
        hwndOld = 
#endif
            SetParent(GetOuterWindow(), hwndParent);


    #ifdef DEBUG

        if (hwndOld == NULL)
        {
            dw = GetLastError();            
            ASSERT(dw == 0, "SetParent failed");
        }

    #endif

    }
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.   controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//    - see win32sdk docs.
//
// Notes:
//
LRESULT CALLBACK COleControl::ControlWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl = ControlFromHwnd(hwnd);
    HRESULT hr;
    LRESULT lResult = 0;
    DWORD   dwCookie;
    BYTE    fSimpleFrame = FALSE;

    // if the value isn't a positive value, then it's in some special
    // state [creation or destruction]  this is safe because under win32,
    // the upper 2GB of an address space aren't available.
    //
    if ((LONG)pCtl == 0) {
        pCtl = s_pLastControlCreated;
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)pCtl);
        pCtl->m_hwnd = hwnd;
    } else if ((ULONG)pCtl == 0xffffffff) {
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    // this is unfortunate.  if the control gets destroyed while processing a
    // message [ie, 'End' in an event, etc ....], we need to be able to
    // contine through to the end of this routine, past the post-processing.
    // to do this, we need to force a ref count on the control to keep it
    // around.  blech
    //
    pCtl->ExternalAddRef();

    // message preprocessing
    //
    if (pCtl->m_pSimpleFrameSite) {
        hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
        if (hr == S_FALSE) goto Done;
    }

    // for certain messages, do not call the user window proc. instead,
    // we have something else we'd like to do.
    //
    switch (msg) {
      case WM_PAINT:
        {
        // call the user's OnDraw routine.
        //
        PAINTSTRUCT ps;
        RECT        rc;
        HDC         hdc;

        // if we're given an HDC, then use it
        //
        if (!wParam)
        {
            hdc = BeginPaint(hwnd, &ps);
        }
        else
            hdc = (HDC)wParam;

        GetClientRect(hwnd, &rc);
        pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

        if (!wParam)
        {
            EndPaint(hwnd, &ps);
        }
        }
        break;

      case WM_DESTROY:        
        pCtl->BeforeDestroyWindow();        		

        // fall through so that controls will send this to the parent window class.

      default:
        // call the derived-control's window proc
        //
        lResult = pCtl->WindowProc(msg, wParam, lParam);

        break;

    }

    // message postprocessing
    //
    switch (msg) {

      case WM_NCDESTROY:
        
        // after this point, the window doesn't exist any more
        //
        SetWindowLong(hwnd, GWL_USERDATA, 0xffffffff);

        // We've been destroyed so reset our parent to NULL, so that it gets regenerated when we're recreated
        //
        pCtl->m_hwndParent = NULL;		
        pCtl->m_hwnd = NULL;
        break;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(msg == WM_SETFOCUS);
        break;

      case WM_SIZE:
        // a change in size is a change in view
        //
        if (!pCtl->m_fCreatingWindow)
            pCtl->ViewChanged();
        break;
    }

    // lastly, simple frame postmessage processing
    //
    if (pCtl->m_pSimpleFrameSite)
        pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);

  Done:
    pCtl->ExternalRelease();
    return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//    BOOL              - [in] true means take, false release
//
// Output:
//    BOOL
//
// Notes:
//    - CONSIDER: this is pretty messy, and it's still not entirely clear
//      what the ole control/focus story is.
//
BOOL COleControl::SetFocus
(
    BOOL fGrab
)
{
    HRESULT hr;
    HWND    hwnd;

    // first thing to do is check out UI Activation state, and then set
    // focus [either with windows api, or via the host for windowless
    // controls]
    //
    if (m_pInPlaceSiteWndless) {
        if (!m_fUIActive && fGrab)
            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

        hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
        return (hr == S_OK) ? TRUE : FALSE;
    } else {

        // we've got a window.
        //
        if (m_fInPlaceActive) {
            hwnd = (fGrab) ? m_hwnd : m_hwndParent;
            if (!m_fUIActive && fGrab)
                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
            else
                return (::SetFocus(hwnd) == hwnd);
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// ReflectOcmMessage
//=--------------------------------------------------------------------------=
// Reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Returns: TRUE if an OCM_ message was reflect
//          FALSE if no OCM_ message was reflected
//
// The return value from SendMessage is stored is returned in pLResult
//
// Notes:
//
BOOL COleControl::ReflectOcmMessage
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    LRESULT *pLResult
)
{
    COleControl *pCtl;    

    ASSERT(pLResult, "RESULT pointer is NULL");    
    *pLResult = 0;

    switch(msg)
    {
        case WM_COMMAND:
        case WM_NOTIFY:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_PARENTNOTIFY:
            pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA);
            if (pCtl)            
            {
                *pLResult = SendMessage(pCtl->m_hwnd, OCM__BASE + msg, wParam, lParam);
                return TRUE;
            }
            break;
    }

    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Notes:
//
LRESULT CALLBACK COleControl::ReflectWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lResult;
    COleControl *pCtl;
    
    switch (msg) {

        case WM_SETFOCUS:
            pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA);
            if (pCtl)
	        {
                return pCtl->SetFocus(TRUE);
	        }
            break;

	case WM_SIZE:
		pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA);
		if (pCtl != NULL)
			::MoveWindow(pCtl->m_hwnd, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
		// continue with default processing
		break;
    }

    // If the message is reflected then return the result of the OCM_ message
    //    
    if (ReflectOcmMessage(hwnd, msg, wParam, lParam, &lResult))
        return lResult;

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL COleControl::GetAmbientProperty
(
    DISPID  dispid,
    VARTYPE vt,
    void   *pData
)
{
    DISPPARAMS dispparams;
    VARIANT v, v2;
    HRESULT hr;

    v.vt = VT_EMPTY;
    v.lVal = 0;
    v2.vt = VT_EMPTY;
    v2.lVal = 0;

    // get a pointer to the source of ambient properties.
    //
    if (!m_pDispAmbient) {
        if (m_pClientSite)
            m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

        if (!m_pDispAmbient)
            return FALSE;
    }

    // now go and get the property into a variant.
    //
    memset(&dispparams, 0, sizeof(DISPPARAMS));
    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                                &v, NULL, NULL);
    if (FAILED(hr)) return FALSE;

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = VariantChangeType(&v2, &v, 0, vt);
    if (FAILED(hr)) {
        VariantClear(&v);
        return FALSE;
    }

    // copy the data to where the user wants it
    //
    CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
    VariantClear(&v);
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont    [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//    IFont **         - [out] where to put the font.
//
// Output:
//    BOOL             - FALSE means couldn't get it.
//
// Notes:
//
BOOL COleControl::GetAmbientFont
(
    IFont **ppFont
)
{
    IDispatch *pFontDisp;

    // we don't have to do much here except get the ambient property and QI
    // it for the user.
    //
    *ppFont = NULL;
    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
        return FALSE;

    pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
    pFontDisp->Release();
    return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//    BOOL            - true is design mode, false is run mode
//
// Notes:
//
BOOL COleControl::DesignMode
(
    void
)
{
    VARIANT_BOOL f;

    // if we don't already know our run mode, go and get it.  we'll assume
    // it's true unless told otherwise
    //
    if (!m_fModeFlagValid) {
        f = TRUE;
        if (!GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f))
            return FALSE;
        m_fModeFlagValid = TRUE;
        m_fRunMode = f;
    }

    return !m_fRunMode;
}

//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// something the user can pay attention to
//
// Output:
//    BOOL             - false means fatal error, can't continue
// Notes:
//
BOOL COleControl::AfterCreateWindow
(
    void
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we create a window.  the user should register their
// window class here, and set up any other things, such as the title of
// the window, and/or sytle bits, etc ...
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error, can't continue
//
// Notes:
//
BOOL COleControl::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=
void COleControl::InvalidateControl
(
    LPCRECT lpRect
)
{
    if (m_fInPlaceActive)
        OcxInvalidateRect(lpRect, TRUE);
    else
        ViewChanged();

    // CONSIDER: one might want to call pOleAdviseHolder->OnDataChanged() here
    // if there was support for IDataObject
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize    [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//    SIZEL *        - [in] new size
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::SetControlSize
(
    SIZEL *pSize
)
{
    HRESULT hr;
    SIZEL slHiMetric;

    PixelToHiMetric(pSize, &slHiMetric);
    hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
    return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow    [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//      OPERATION!
//
HRESULT COleControl::RecreateControlWindow
(
    void
)
{
    HRESULT hr;
    HWND    hwndPrev;
    BYTE    fUIActive = m_fUIActive;

    // we need to correctly preserve the control's position within the
    // z-order here.
    //
    if (m_hwnd)
        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

    // if we're in place active, then we have to deactivate, and reactivate
    // ourselves with the new window ...
    //
    if (m_fInPlaceActive) {

        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
        hr = InPlaceActivate((fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
        RETURN_ON_FAILURE(hr);

    } else if (m_hwnd) {
        DestroyWindow(m_hwnd);
        if (m_hwndReflect) {
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }

        CreateInPlaceWindow(0, 0, FALSE);
    }

    // restore z-order position
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    return m_hwnd ? S_OK : E_FAIL;
}

// from Globals.C. don't need to mutex it here since we only read it.
//
extern HINSTANCE g_hInstResources;

//=--------------------------------------------------------------------------=
// COleControl::GetResourceHandle    [callable]
//=--------------------------------------------------------------------------=
// gets the HINSTANCE of the DLL where the control should get resources
// from.  implemented in such a way to support satellite DLLs.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE COleControl::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // crit sect this for apartment threading support.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fHaveLocale)
        // if we can't get the ambient locale id, then we'll just continue
        // with the globally set up value.
        //
        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &g_lcidLocale))
            goto Done;

    g_fHaveLocale = TRUE;

  Done:
    LEAVECRITICALSECTION1(&g_CriticalSection);
    return ::GetResourceHandle();
}

//=--------------------------------------------------------------------------=
// COleControl::GetControl    [IControlPrv]
//=--------------------------------------------------------------------------=
// Returns a pointer to the COleControl class
//
HRESULT COleControl::GetControl(COleControl **ppOleControl)
{
	CHECK_POINTER(ppOleControl);
	*ppOleControl = this;
	(*ppOleControl)->AddRef();
	return S_OK;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlocx96.cpp ===
//=--------------------------------------------------------------------------=
// CtlOcx96.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//
#include "pch.h"

#include "CtrlObj.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//    DWORD *        - [out] activation policy
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
    DWORD *pdwPolicy
)
{
    CHECK_POINTER(pdwPolicy);

    // just get the policy in the global structure describing this control.
    //
    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg
)
{
    // OVERRIDE: end control writers should just override this if they want
    // to have a control that is never in-place active.
    //
    return S_OK;
}
    
//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//    BOOL               - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg,
    BOOL    fSetAlways
)
{
    // OVERRIDE:  just get the user to override this if they want to never
    // be activated
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate    [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//    QACONTAINER *        - [in]  info about the container
//    QACONTROL *          - [out] info about the control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
    QACONTAINER *pContainer,
    QACONTROL *pControl
)
{
    HRESULT hr;

    // we need these guys.
    //
    if (!pContainer) return E_UNEXPECTED;
    if (!pControl) return E_UNEXPECTED;

    // start grabbing things from the QACONTAINER structure and apply them
    // as relevant
    //
    // We do the size comparison against the original (VC 4.2) 
    // size of the structures in OCIDL.H.  These _OLD structure definitions
    // are cached away by us in ctrlobj.h.  If we were to compile against
    // arbitrary VC header files containing new, larger structures then 
    // we'd begin to inadvertently fail.  We'd be comparing the original 
    // structure size passed in by a container against an inflated (sizeof) size.
    //
    if (pContainer->cbSize < sizeof(QACONTAINER_OLD)) return E_UNEXPECTED;
    if (pControl->cbSize < sizeof(QACONTROL_OLD)) return E_UNEXPECTED;

    // save out the client site, of course.
    //
    if (pContainer->pClientSite) {
        hr = SetClientSite(pContainer->pClientSite);
        RETURN_ON_FAILURE(hr);
    }

    // if the lcid is not LANG_NEUTRAL, score!
    //
    if (pContainer->lcid) {
        ENTERCRITICALSECTION1(&g_CriticalSection);  // Should have crit sect
        g_lcidLocale = pContainer->lcid;
        g_fHaveLocale = TRUE;
        LEAVECRITICALSECTION1(&g_CriticalSection);
    }

    // pay attention to some ambients
    //
    if (pContainer->dwAmbientFlags & QACONTAINER_MESSAGEREFLECT) {
        m_fHostReflects = TRUE;
        m_fCheckedReflecting = TRUE;
    }

    // hook up some notifications.  first property notifications.
    //
    if (pContainer->pPropertyNotifySink) {
        pContainer->pPropertyNotifySink->AddRef();
        hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
        if (FAILED(hr)) {
            pContainer->pPropertyNotifySink->Release();
            return hr;
        }
    }

    // then the event sink.
    //
    if (pContainer->pUnkEventSink) {
        hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
        if (FAILED(hr)) {
            pContainer->pUnkEventSink->Release();
            return hr;
        }
    }

    // finally, the advise sink.
    //
    if (pContainer->pAdviseSink) {
        // don't need to pass the cookie back since there can only be one
        // person advising at a time.
        //
        hr = SetAdvise(DVASPECT_CONTENT, 0, pContainer->pAdviseSink);
        RETURN_ON_FAILURE(hr);
    }

    // set up a few things in the QACONTROL structure.  we're opaque by default
    //
    pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

    // that's pretty much all we're interested in.  we will, however, pass on the
    // rest of the things to the end control writer and see if they want to do
    // anything with them. they shouldn't touch any of the above except for the
    // ambients.
    //
    return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//    LPSIZEL            - [in] the size of the content extent
//
// Output:
//    HRESULT            - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
    LPSIZEL pSize
)
{
    return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//    LPSIZEL        - [out] returns current size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
    LPSIZEL pSize
)
{
    return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//    QACONTAINER *            - [in]  contains additional information
//    DWORD *                  - [out] put ViewStatus flags here.
//
// Output:
//    HRESULT
//
// Notes:
//    - control writers should only look at/consume:
//        a. dwAmbientFlags
//        b. colorFore/colorBack
//        c. pFont
//        d. pUndoMgr
//        e. dwAppearance
//        f. hpal
//
//    - all the others are set up the for the user by the framework.
//    - control writers should set up the pdwViewStatus with flags as per
//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//      care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
    QACONTAINER *pContainer,
    DWORD       *pdwViewStatus
)
{
    // by default, nuthin much to do!
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlview.cpp ===
//=--------------------------------------------------------------------------=
// CtlView.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the IViewObjectEx interface, which is a moderately
// non-trivial bunch of code.
//
#include "pch.h"

#include "CtrlObj.H"

// for ASSERT and FAIL
//
SZTHISFILE



// local functions we're going to find useful
//
HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw    [IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context. 
//
// Parameters:
//    DWORD                - [in] draw aspect
//    LONG                 - [in] part of object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in] specifies the target device
//    HDC                  - [in] information context for target device
//    HDC                  - [in] target device context
//    LPCRECTL             - [in] rectangle in which the object is drawn
//    LPCRECTL             - [in] window extent and origin for metafiles
//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing
//    DWORD                - [in] parameter to pass to callback.
//
// Output:
//    HRESULT
//
// Notes:
//    - we support the following OCX 96 extensions
//        a. flicker free drawing [multi-pass drawing]
//        b. pvAspect != NULL for optimized DC handling
//        c. prcBounds == NULL for windowless inplace active objects
//
STDMETHODIMP COleControl::Draw
(
    DWORD            dwDrawAspect,
    LONG             lIndex,
    void            *pvAspect,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    HDC              hdcDraw,
    LPCRECTL         prcBounds,
    LPCRECTL         prcWBounds,
    BOOL (__stdcall *pfnContinue)(DWORD dwContinue),
    DWORD            dwContinue
)
{
    HRESULT hr;
    RECTL rc;
    POINT pVp, pW;
    BOOL  fOptimize = FALSE;
    int iMode;
    BYTE fMetafile = FALSE;
    BYTE fDeleteDC = FALSE;
    SIZE sWindowExt, sViewportExt;

    // support the aspects required for multi-pass drawing
    //
    switch (dwDrawAspect) {
        case DVASPECT_CONTENT:
        case DVASPECT_OPAQUE:
        case DVASPECT_TRANSPARENT:
            break;
        default:
            return DV_E_DVASPECT;
    }

    // first, have to do a little bit to support printing.
    //
    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

        // We are dealing with a metafile.
        //
        fMetafile = TRUE;

        // If attributes DC is NULL, create one, based on ptd.
        //
        if (!hicTargetDevice) {

            // Does _CreateOleDC have to return an hDC
            // or can it be flagged to return an hIC 
            // for this particular case?
            //
            hicTargetDevice = _CreateOleDC(ptd);
            fDeleteDC = TRUE;
        }
    }

    // check to see if we have any flags passed in the pvAspect parameter.
    //
    if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
        fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

    // if they didn't give us a rectangle, just copy over ours
    //
    if (!prcBounds) {

        memcpy(&rc, &m_rcLocation, sizeof(rc));

    } else {

        // first -- convert the DC back to MM_TEXT mapping mode so that the
        // window proc and OnDraw can share the same painting code.  save
        // some information on it, so we can restore it later [without using
        // a SaveDC/RestoreDC]
        //
        rc = *prcBounds;

        // Don't do anything to hdcDraw if it's a metafile.
        // The control's Draw method must make the appropriate
        // accomodations for drawing to a metafile
        //
        if (!fMetafile) {
            LPtoDP(hdcDraw, (POINT *)&rc, 2);
            SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
            SetWindowOrgEx(hdcDraw, 0, 0, &pW);
            GetWindowExtEx(hdcDraw, &sWindowExt);
            GetViewportExtEx(hdcDraw, &sViewportExt);
            iMode = SetMapMode(hdcDraw, MM_TEXT);
        }
    }

    // prcWBounds is NULL and not used if we are not dealing with a metafile.
    // For metafiles, we pass on rc as *prcBounds, we should also include
    // prcWBounds
    //
    hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

    // clean up the DC when we're done with it, if appropriate.
    //
    if (prcBounds && !fMetafile) {
        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
        SetWindowExtEx(hdcDraw, sWindowExt.cx, sWindowExt.cy, NULL);
        SetViewportExtEx(hdcDraw, sViewportExt.cx, sViewportExt.cy, NULL);
        SetMapMode(hdcDraw, iMode);
    }

    // if we created a dc, blow it away now
    //
    if (fDeleteDC) DeleteDC(hicTargetDevice);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//    HDC                - [in]  dc to work with
//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::DoSuperClassPaint
(
    HDC      hdc,
    LPCRECTL prcBounds
)
{
    HWND hwnd;
    RECT rcClient;
    int  iMapMode;
    POINT ptWOrg, ptVOrg;
    SIZE  sWOrg, sVOrg;

    // make sure we have a window.
    //
    hwnd = CreateInPlaceWindow(0,0, FALSE);
    if (!hwnd)
        return E_FAIL;

    GetClientRect(hwnd, &rcClient);

    // set up the DC for painting.  this code largely taken from the MFC CDK
    // DoSuperClassPaint() fn.  doesn't always get things like command
    // buttons quite right ...
    //
    // NOTE: there is a windows 95 problem in which the font instance manager
    // will leak a bunch of bytes in the global GDI pool whenever you 
    // change your extents and have an active font.  this code gets around
    // this for on-screen cases, but not for printing [which shouldn't be
    // too serious, because you're not often changing your control size and
    // printing rapidly in succession]
    //
    if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
        && (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
        SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
    }

    SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
    SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

#if STRICT
    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#else
    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#endif // STRICT

    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//    DWORD                - [in]  how the object is to be represented
//    LONG                 - [in]  part of the object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in]  specifies the target device
//    HDC                  - [in]  information context for the target device
//    LOGPALETTE **        - [out] where to put palette
//
// Output:
//    S_OK                 - Control has a palette, and returned it through the out param.
//    S_FALSE              - Control does not currently have a palette.
//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control.
//
// Notes:
//
STDMETHODIMP COleControl::GetColorSet
(
    DWORD            dwDrawAspect,
    LONG             lindex,
    void            *IgnoreMe,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    LOGPALETTE     **ppColorSet
)
{
    if (dwDrawAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *ppColorSet = NULL;
    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze    [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//    DWORD            - [in] aspect
//    LONG             - [in] part of object to draw
//    void *           - NULL
//    DWORD *          - [out] for Unfreeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Freeze
(
    DWORD   dwDrawAspect,
    LONG    lIndex,
    void   *IgnoreMe,
    DWORD  *pdwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze    [IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//    DWORD        - [in] cookie from freeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Unfreeze
(
    DWORD dwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//    DWORD            - [in] aspect
//    DWORD            - [in] info about the sink
//    IAdviseSink *    - [in] the sink
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SetAdvise
(
    DWORD        dwAspects,
    DWORD        dwAdviseFlags,
    IAdviseSink *pAdviseSink
)
{
    // if it's not a content aspect, we don't support it.
    //
    if (!(dwAspects & DVASPECT_CONTENT)) {
        return DV_E_DVASPECT;
    }

    // set up some flags  [we gotta stash for GetAdvise ...]
    //
    m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
    m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

    RELEASE_OBJECT(m_pViewAdviseSink);
    m_pViewAdviseSink = pAdviseSink;
    ADDREF_OBJECT(m_pViewAdviseSink);

    // prime them if they want it [we need to store this so they can get flags later]
    //
    if (m_fViewAdvisePrimeFirst)
        ViewChanged();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//    DWORD *            - [out]  aspects
//    DWORD *            - [out]  advise flags
//    IAdviseSink **     - [out]  the sink
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP COleControl::GetAdvise
(
    DWORD        *pdwAspects,
    DWORD        *pdwAdviseFlags,
    IAdviseSink **ppAdviseSink
)
{
    // if they want it, give it to them
    //
    if (pdwAspects)
        *pdwAspects = DVASPECT_CONTENT;

    if (pdwAdviseFlags) {
        *pdwAdviseFlags = 0;
        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
    }

    if (ppAdviseSink) {
        *ppAdviseSink = m_pViewAdviseSink;
        ADDREF_OBJECT(*ppAdviseSink);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//    DWORD            - [in] draw aspect
//    LONG             - [in] part of object to draw
//    DVTARGETDEVICE * - [in] information about target device
//    LPSIZEL          - [out] where to put the size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD           dwDrawAspect,
    LONG            lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL         psizel
)
{
    // we already have an implementation of this [from IOleObject]
    //
    return GetExtent(dwDrawAspect, psizel);
}


//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette    [overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.  ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//    HDC            - [in]  HIC for the target device
//    LOGPALETTE **  - [out] where to put the palette
//
// Output:
//    BOOL           - TRUE means we processed it, false means nope.
//
// Notes:
//
BOOL COleControl::OnGetPalette
(
    HDC          hicTargetDevice,
    LOGPALETTE **ppColorSet
)
{
    return FALSE;
}


//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//    DWORD             - [in]  aspect
//    LPRECTL           - [out] region rectangle
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetRect
(
    DWORD    dvAspect,
    LPRECTL  prcRect
)
{
    RECTL rc;
    BOOL  f;

    // call the user routine and let them return the size
    //
    f = OnGetRect(dvAspect, &rc);
    if (!f) return DV_E_DVASPECT;

    // transform these dudes.
    //
    PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
    PixelToHiMetric((LPSIZEL)((LPBYTE)&rc + sizeof(SIZEL)), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));
    
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//    DWORD *            - [out] the status
//
/// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetViewStatus
(
    DWORD *pdwStatus
)
{
    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
    // transparency vs opacity.
    // OVERRIDE:  controls that wish to support multi-pass drawing should
    // override this routine and return, in addition to the flags indication
    // opacity, flags indicating what sort of drawing aspects they support.
    //
    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//    DWORD                - [in]  aspect
//    LPCRECT              - [in]  Bounds rectangle
//    POINT                - [in]  hit location client coordinates
//    LONG                 - [in]  what the container considers close
//    DWORD *              - [out] info about the hit
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitPoint
(
    DWORD    dvAspect,
    LPCRECT  prcBounds,
    POINT    ptLocation,
    LONG     lCloseHint,
    DWORD   *pdwHitResult
)
{
    // OVERRIDE: override me if you want to provide additional [non-opaque]
    // functionality
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates wheter any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LPCRECT          - [in]  bounds
//    LPCRECT          - [in]  location
//    LONG             - [in]  what host considers close
//    DWORD *          - [out] hit result
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitRect
(
    DWORD     dvAspect,
    LPCRECT   prcBounds,
    LPCRECT   prcLocation,
    LONG      lCloseHint,
    DWORD    *pdwHitResult
)
{
    RECT rc;

    // OVERRIDE: override this for additional behaviour
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LONG             - [in]  index
//    DVTARGETDEVICE * - [in]  target device information
//    HDC              - [in]  HIC
//    DVEXTENTINFO *   - [in]  sizing data
//    LPSIZEL          - [out] sizing data retunred by control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetNaturalExtent
(
    DWORD           dvAspect,
    LONG            lIndex,
    DVTARGETDEVICE *ptd,
    HDC             hicTargetDevice,
    DVEXTENTINFO   *pExtentInfo,
    LPSIZEL         pSizel
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect    [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//    DWORD              - [in]  aspect they want the rect for
//    RECTL *            - [out] the rectangle that matches this aspect
//
// Output:
//    BOOL               - false means we don't like the aspect
//
// Notes:
//
BOOL COleControl::OnGetRect
(
    DWORD   dvAspect,
    RECTL  *pRect
)
{
    // by default, we only support content drawing.
    //
    if (dvAspect != DVASPECT_CONTENT)
        return FALSE;

    // just give them our bounding rectangle
    //
    *((LPRECT)pRect) = m_rcLocation;
    return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//    DVTARGETDEVICE *              - [in] duh.
//
// Output:
//    HDC
//
// Notes:
//
HDC _CreateOleDC
(
    DVTARGETDEVICE *ptd
)
{
    LPDEVMODEW   pDevModeW;
    DEVMODEA     DevModeA, *pDevModeA;
    LPOLESTR     lpwszDriverName;
    LPOLESTR     lpwszDeviceName;
    LPOLESTR     lpwszPortName;
    HDC          hdc;

    // return screen DC for NULL target device
    //
    if (!ptd)
        return CreateDC("DISPLAY", NULL, NULL, NULL);

    if (ptd->tdExtDevmodeOffset == 0)
        pDevModeW = NULL;
    else
        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName);

    // wow, this sucks.
    //
    if (pDevModeW) {
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (pDevModeW->dmDriverExtra) {
            pDevModeA = (DEVMODEA *)CtlHeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
            if (!pDevModeA) return NULL;
            memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
        } else
            pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
    } else
        pDevModeA = NULL;

    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
    if (pDevModeA != &DevModeA) CtlHeapFree(g_hHeap, 0, pDevModeA);
    return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlpsst.cpp ===
//=--------------------------------------------------------------------------=
// ControlPersistence.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of persistence interfaces for COleControl.
//
#include "pch.h"
#include "CtrlObj.H"

#include "CtlHelp.H"

// for ASSERT and FAIL
//
SZTHISFILE


// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"Contents";	


//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF                  // Marker at end of property list
#define MAXAUTOBUF 3800                 // Best if < 1 page.

typedef struct tagSTREAMHDR {

    DWORD  dwSignature;     // Signature.
    size_t cbWritten;       // Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//    IPropertyBag *      - [in] pbag from which to read props.
//    IErrorLog *         - [in] error log to write to
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    HRESULT hr;

    // load in our standard state first.  nothing serious here ... currently,
    // we've just got two properties, for cx and cy.
    //
    hr = LoadStandardState(pPropertyBag, pErrorLog);
    RETURN_ON_FAILURE(hr);

    // now call the user text load function, and get them to load in whatever
    // they're interested in.
    //
    hr = LoadTextState(pPropertyBag, pErrorLog);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//    IPropertyBag *        - [in] property to write to
//    BOOL                  - [in] do we clear the dirty bit?
//    BOOL                  - [in] do we write out default values anyhoo?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IPropertyBag *pPropertyBag,
    BOOL          fClearDirty,
    BOOL          fWriteDefault
)
{
    HRESULT hr;

    // save out standard state information
    //
    hr = SaveStandardState(pPropertyBag);
    RETURN_ON_FAILURE(hr);

    // now call the user function and get them to save out
    // all of their properties.
    //
    hr = SaveTextState(pPropertyBag, fWriteDefault);
    RETURN_ON_FAILURE(hr);

    // now clear the dirty flag and send out notification that we're
    // done.
    //
    if (fClearDirty)
        m_fDirty = FALSE;

    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//    CLSID *         - [out] where to put the clsid
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
    CLSID *pclsid
)
{
    CHECK_POINTER(pclsid);

    // copy the thing over
    //
    *pclsid = CLSIDOFOBJECT(m_ObjectType);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//    HRESULT        - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
    void
)
{
    return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    void
)
{
    BOOL f;

    // call the overridable function to do this work
    //
    f = InitializeNewState();

    // make sure we mark ourselves as dirty
    //
    m_fDirty = TRUE;
    return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ULARGE_INTEGER *    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
    ULARGE_INTEGER *pulMaxSize
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//    IStream *    - [in] stream from which to load
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IStream *pStream
)
{
    HRESULT hr;

    // first thing to do is read in standard properties the user don't
    // persist themselves.
    //
    hr = LoadStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // load in the user properties.  this method is one they -have- to implement
    // themselves.
    //
    hr = LoadBinaryState(pStream);
    
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//    IStream *        - [in]
//    BOOL             - [in] clear dirty bit?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStream *pStream,
    BOOL     fClearDirty
)
{
    HRESULT hr;

    // use our helper routine that we share with the IStorage persistence
    // code.
    //
    hr = m_SaveToStream(pStream);
    RETURN_ON_FAILURE(hr);

    // clear out dirty flag [if appropriate] and notify that we're done
    // with save.
    //
    if (fClearDirty)
        m_fDirty = FALSE;
    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//    IStorage *    - [in] we don't use this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    IStorage *pStorage
)
{
    // we already have an implementation of this [for IPersistStreamInit]
    //
    return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//    IStorage *    - [in] DUH.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
    IStream *pStream;
    HRESULT  hr;

    // we're going to use IPersistStream::Load from the CONTENTS stream.
    //
    hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // IPersistStreamInit::Load
    //
    hr = Load(pStream);
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//    IStorage *        - [in] 10 points if you figure it out
//    BOOL              - [in] is the storage the same as the load storage?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStorage *pStorage,
    BOOL      fSameAsLoad
)
{
    IStream *pStream;
    HRESULT  hr;

    // we're just going to save out to the CONTENTES stream.
    //
    hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // use our helper routine.
    //
    hr = m_SaveToStream(pStream);
    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted    [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//    IStorage *    - ignored
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
    IStorage *pStorageNew
)
{
    // if our save succeeded, then we can do our post save work.
    //
    if (m_fSaveSucceeded) {
        m_fDirty = FALSE;
        if (m_pOleAdviseHolder)
            m_pOleAdviseHolder->SendOnSave();
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//    S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
    void
)
{
    // we don't ever hold on to  a storage pointer, so this is remarkably
    // uninteresting to us.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//    IStream *        - figure it out
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::m_SaveToStream
(
    IStream *pStream
)
{
    HRESULT hr;

    // save out standard state information that the user has no control
    // over
    //
    hr = SaveStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // save out user-specific satte information.  they MUST implement this
    // function
    //
    hr = SaveBinaryState(pStream);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//    IPropertyBag *    - [in]
//    IErrorLog *       - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    VARIANT v;
    HRESULT hr;
    SIZEL   slHiMetric = { 100, 50 };

    // currently, our only standard properties are related to size.
    // if we can't find them, then we'll just use some defaults.
    //
    v.vt = VT_I4;
    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentX", &v, pErrorLog);
    if (FAILED(hr)) goto DefaultSize;
    
    slHiMetric.cx = v.lVal;

    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentY", &v, pErrorLog);
    if (FAILED(hr)) goto DefaultSize;
    slHiMetric.cy = v.lVal;

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;

  DefaultSize:
    m_Size.cx = 100;
    m_Size.cy = 50;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//    IStream *         - [in] 
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IStream *pStream
)
{
    STREAMHDR stmhdr;
    HRESULT hr;
    SIZEL   slHiMetric;

    // look for our header structure, so we can verify stream validity.
    //
    hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
        return E_UNEXPECTED;

    // currently, the only standard state we're writing out is
    // a SIZEL structure describing the control's size.
    //
    if (stmhdr.cbWritten != sizeof(m_Size))
        return E_UNEXPECTED;

    // we like the stream.  let's go load in our two properties.
    //
    hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
    RETURN_ON_FAILURE(hr);

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//    IPropertyBag *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IPropertyBag *pPropertyBag
)
{
    HRESULT hr;
    VARIANT v;
    SIZEL   slHiMetric;

    // currently, the only standard proprerties we persist are Size related
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    v.vt = VT_I4;
    v.lVal = slHiMetric.cx;

    hr = pPropertyBag->Write(L"_ExtentX", &v);
    RETURN_ON_FAILURE(hr);

    v.lVal = slHiMetric.cy;

    hr = pPropertyBag->Write(L"_ExtentY", &v);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//    IStream *            - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IStream *pStream
)
{
    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
    HRESULT hr;
    SIZEL   slHiMetric;


    // first thing to do is write out our stream hdr structure.
    //
    hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    // the only properties we're currently persisting here are the size
    // properties for this control.  make sure we do that in HiMetric
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState    [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//    BOOL        - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
    void
)
{
    // we find this largely uninteresting
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ctlwrap.cpp ===
//=--------------------------------------------------------------------------=
// CtlWrap.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.
//
#include "pch.h"

#include "CtrlObj.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//    none
//
// Output:
//    TRUE if we have focus, else false
//
// Notes:
//
BOOL COleControl::OcxGetFocus
(
    void
)
{
    // if we're windowless, the site provides this functionality
    //
    if (m_pInPlaceSiteWndless) {
        return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
    } else {

        // we've got a window.  just let the APIs do our work
        //
        if (m_fInPlaceActive)
            return (GetFocus() == m_hwnd);
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect    [wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//    LPRECT                - [out]  duh.
//
// Output:
//    BOOL                  - false means unexpected.
//
// Notes:
//
BOOL COleControl::OcxGetWindowRect
(
    LPRECT prc
)
{
    // if we're windowless, then we have this information already!
    //
    if (Windowless()) {
        *prc = m_rcLocation;
        return TRUE;
    } else
        return GetWindowRect(m_hwnd, prc);

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc    [wrapper]
//=--------------------------------------------------------------------------=
// default window processing
//
// Parameters:
//    UINT           - [in] duh.
//    WPARAM         - [in] duh.
//    LPARAM         - [in] DUH.
//
// Output:
//    LRESULT
//
// Notes:
//
LRESULT COleControl::OcxDefWindowProc
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT l;

    // if we're windowless, this is a site provided pointer
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &l);
    else
        // we've got a window -- just pass it along
        //
        l = DefWindowProc(m_hwnd, msg, wParam, lParam);

    return l;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC    [wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//    none
//
// Output:
//    HDC            - null means we couldn't get one
//
// Notes:
//    - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//      parameters, since the windows GetDC doesn't expose these either. users
//      wanting that sort of fine tuned control can call said routine
//      explicitly
//
HDC COleControl::OcxGetDC
(
    void
)
{
    HDC hdc = NULL;

    // if we're windowless, the site provides this functionality.
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
    else
        hdc = GetDC(m_hwnd);

    return hdc;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC    [wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//    HDC             - [in] release me
//
// Output:
//    none
//
// Notes:
//
void COleControl::OcxReleaseDC
(
    HDC hdc
)
{
    // if we're windowless, the site does this for us
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->ReleaseDC(hdc);
    else
        ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//    BOOL            - [in] true means take, false release
//
// Output:
//    BOOL            - true means it's yours, false nuh-uh
//
// Notes:
//
BOOL COleControl::OcxSetCapture
(
    BOOL fGrab
)
{
    HRESULT hr;

    // the host does this for us if we're windowless [i'm getting really bored
    // of typing that]
    //
    if (m_pInPlaceSiteWndless) {
        hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
        return (hr == S_OK);
    } else {
        // people shouldn't call this when they're not in-place active, but
        // just in case...
        //
        if (m_fInPlaceActive) {
            if (fGrab)
                SetCapture(m_hwnd);
            else
                ReleaseCapture();
            return TRUE;
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//    none
//
// Output:
//    BOOL         - true it's yours, false it's not
//
// Notes:
//
BOOL COleControl::OcxGetCapture
(
    void
)
{
    // host does this for windowless dudes
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->GetCapture() == S_OK;
    else {
        // people shouldn't call this when they're not in-place active, but
        // just in case.
        //
        if (m_fInPlaceActive)
            return GetCapture() == m_hwnd;
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect    [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//    LPCRECT            - [in] rectangle to invalidate
//    BOOL               - [in] do we erase background first?
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxInvalidateRect
(
    LPCRECT prcInvalidate,
    BOOL    fErase
)
{
    // if we're windowless, then we need to get the site to do all this for
    // us
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
    else {
        // otherwise do something different depending on whether or not we're
        // in place active or not
        //
        if (m_fInPlaceActive && m_hwnd)
            return InvalidateRect(m_hwnd, prcInvalidate, fErase);
        else
            ViewChanged();
    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect    [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//    LPCRECT             - [in] region to scroll
//    LPCRECT             - [in] region to clip
//    int                 - [in] dx to scroll
//    int                 - [in] dy to scroll
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxScrollRect
(
    LPCRECT  prcBounds,
    LPCRECT  prcClip,
    int      dx,
    int      dy
)
{
    // if we're windowless, the site provides this functionality, otherwise
    // APIs do the job
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
    else {
        if (m_fInPlaceActive) 
            ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
        else
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\dbgcrit.cpp ===
////
// DbgCrit.cpp
// ~~~~~~~~~~~
//
// This file holds the critical section class for tracking down whether the
// critical section has correctly left within the routine.

#include "pch.h"

#if DEBUG

SZTHISFILE

//////
//  CCritSec::CCritSec
//
//  The constructor calls EnterCriticalSection and sets up the variables
//
CCritSec::CCritSec
(
  CRITICAL_SECTION *CritSec
)
{
  EnterCriticalSection(CritSec);

  m_fLeft     = FALSE;
  m_pCriticalSection = CritSec;
} //CCritSec


//////
//  CCritSec::~CCritSec
//
//  The destructor checks the flag that tells us whether or not the
//  critical section was left properly or not.
//
CCritSec::~CCritSec
(
)
{
  if(m_fLeft == FALSE)
    FAIL("CriticalSection was not left properly.");
} //~CCritSec


//////
//  CCritSec::Left
//
//  A method that sets the flag to TRUE and also calls LeaveCriticalSection
//
void CCritSec::Left
(
  void
)
{
  LeaveCriticalSection(m_pCriticalSection);
  m_fLeft = TRUE;
} //Left

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\fguids.cpp ===
//=--------------------------------------------------------------------------=
// FGuids.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of Visual Studio Html help CLSID/interface guids
//
    #include "pch.h"
    #include <initguid.h>

    DEFINE_GUID(IID_IVsHelpInit,        0x854d7ac3, 0xbc3d, 0x11d0, 0xb4, 0x21, 0x00, 0xa0, 0xc9, 0x0f, 0x9d, 0xc4);        
    DEFINE_GUID(CLSID_VsHelpServices,   0x854d7ac5, 0xbc3d, 0x11d0, 0xb4, 0x21, 0x00, 0xa0, 0xc9, 0x0f, 0x9d, 0xc4);
    DEFINE_GUID(IID_IVsHelpSystem,      0x854d7ac0, 0xbc3d, 0x11d0, 0xb4, 0x21, 0x00, 0xa0, 0xc9, 0x0f, 0x9d, 0xc4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//
#include "pch.h"

#ifdef DEBUG
#include <stdlib.h>

//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"
#define CTL_INI_SIZE 14

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    LPTSTR lpszText;
    
    char  szMsg[512];

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    MSG  msg;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);
    if(PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE))
    {
      id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);
      PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
    }

    return id;
}


//---------------------------------------------------------------------------
// Implementation for class CtlSwitch
//---------------------------------------------------------------------------

CtlSwitch* CtlSwitch::g_pctlswFirst = NULL;

//=---------------------------------------------------------------------------=
//  CtlSwitch::InitSwitch - Initialize members and add new object to 
//			    linked-list
//=---------------------------------------------------------------------------=
void CtlSwitch::InitSwitch
(
 char * pszName
)
{
  // set fields
  m_pszName = pszName;
  m_fSet = FALSE;

  // link into global list of switches
  this->m_pctlswNext = g_pctlswFirst;
  g_pctlswFirst = this;
  
}


//=---------------------------------------------------------------------------=
//  SetCtlSwitches:
//    Initialize linked-list control switches to those values set in the 
//    corresponding .ini files
//=---------------------------------------------------------------------------=
VOID SetCtlSwitches 
(
    LPSTR    lpCtlPath
)
{    
    TCHAR lpWindowsDir[128];	  //  Path to Windows directory
    UINT uMaxWinPathSize = 128;	  //  Max size for Win path
    UINT uPathSize;		  //  Actual Win path size

    LPCTSTR lpAllSwitch = "allctls";	    //	Name of section which applies to all ctls
    char lpszCtlName[128];		    //	Name of ctl (minus extension) to act as section name in INI	  
    LPCTSTR lpFileName = "\\CtlSwtch.ini";  //	Name of INI file
    char lpStatus[4];			    //	Status of switch (on/off)
    LPCTSTR lpDefaultStatus = "set";	    //	Default status
    LPCTSTR lpTurnOff = "off";
    LPCTSTR lpTurnOn = "on";
    DWORD nSizeStatus = 4;		    //	Size of status switch
    DWORD fSet;				    //	If switch is set in INI

    //  Create path to CtlSwtch.ini in the Windows directory
    uPathSize = GetWindowsDirectory(lpWindowsDir, uMaxWinPathSize) + CTL_INI_SIZE;
    lstrcat(lpWindowsDir, lpFileName);

    //	Create section name for control (control name minus extension)
    lstrcpyn(lpszCtlName, lpCtlPath, strlen(lpCtlPath) - 3);
    int curChar = strlen(lpszCtlName);
    int charCount = 0;
    while (lpszCtlName[curChar] != '\\')
      {
      curChar--;
      charCount++;
      }
    curChar++;
    lstrcpyn(lpszCtlName, &lpCtlPath[curChar], charCount);

    //  Use CTLSWTCH.INI to set switches.  If not defined in INI file, create switch
    for (CtlSwitch* pctlsw = CtlSwitch::g_pctlswFirst; pctlsw; pctlsw = pctlsw->m_pctlswNext)
      {
      //  Specific control switches override the "allctls" switch
      fSet = GetPrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, lpDefaultStatus, (LPTSTR)lpStatus, nSizeStatus, (LPCTSTR)lpWindowsDir);

      // If switch is not set for control, use "allctls" switch
      if ((fSet == 0) || (strcmp(lpStatus, "set") == 0))
	{
        fSet = GetPrivateProfileString(lpAllSwitch, (LPCTSTR)pctlsw->m_pszName, lpDefaultStatus, (LPTSTR)lpStatus, nSizeStatus, (LPCTSTR)lpWindowsDir);

        // If INI file or switch do not exist, create one...
        if ((fSet == 0) || (strcmp(lpStatus, "set") == 0))
	  {
	  // If switch was initialized TRUE, turn it on
	  if (pctlsw->m_fSet != 0)
	    WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOn, (LPCTSTR)lpWindowsDir); 
	  //  Else turn it off
	  else
	    {
	    WritePrivateProfileString(lpAllSwitch, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOff, (LPCTSTR)lpWindowsDir); 
	    WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOff, (LPCTSTR)lpWindowsDir); 
	    pctlsw->m_fSet = FALSE;
	    }
	  }
	else if ((strcmp(lpStatus, "on") == 0))
	  {
	  WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpStatus, (LPCTSTR)lpWindowsDir); 
	  pctlsw->m_fSet = TRUE;
	  }
	else
	  {
	  WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOff, (LPCTSTR)lpWindowsDir); 
	  pctlsw->m_fSet = FALSE;
	  }
	}
      else if ((strcmp(lpStatus, "on") == 0))
	pctlsw->m_fSet = TRUE;
      else 
	pctlsw->m_fSet = FALSE;

      }
      
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\globals.cpp ===
//=--------------------------------------------------------------------------=
// Globals.cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains global variables and strings and the like that just don't fit
// anywhere else.
//
#include "pch.h"

//=--------------------------------------------------------------------------=
// support for licensing
//
BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
BOOL g_fServerHasTypeLibrary = TRUE;

#ifdef MDAC_BUILD

    // Satellite .DLL name includes 2 or 3 letter language abbreviation
    //
    VARIANT_BOOL g_fSatelliteLangExtension =  TRUE;

#endif

//=--------------------------------------------------------------------------=
// our instance handles
//
HINSTANCE    g_hInstance;
HINSTANCE    g_hInstResources;
VARIANT_BOOL g_fHaveLocale;

//=--------------------------------------------------------------------------=
// OleAut Library Handle
//
#ifdef MDAC_BUILD
HINSTANCE g_hOleAutHandle;
#else
HANDLE 	 g_hOleAutHandle;
#endif

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
CRITICAL_SECTION    g_CriticalSection;

//=--------------------------------------------------------------------------=
// critical section for our heap memory leak detection.
//
CRITICAL_SECTION    g_csHeap;
BOOL g_fInitCrit = FALSE;
BOOL g_flagConstructorAlloc = FALSE;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
BOOL    g_fSysWin95;                    // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;                    // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\makefile.inc ===
THUNDER55=..\..\vb98
TOOLS=TOOLS
C32=C32
MAKEVERS=$(THUNDER55)\$(TOOLS)\BIN\makevers /MajorVer 6 /MinorVer 0

JulianDate:
    $(THUNDER55)\$(TOOLS)\BIN\jdate -newline -terse > $(O)\dwinvers.txt

$(O)\dwinvers.h: JulianDate
    $(MAKEVERS) > $(O)\dwinvers.h < $(O)\dwinvers.txt
    $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(O)\dwinvers.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\macros.cpp ===
//=--------------------------------------------------------------------------=
// Macros.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
// Handy macros like the ones we use in the VB code base.
//=--------------------------------------------------------------------------=
#include "pch.h"

#ifdef DEBUG
#include <winuser.h>

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
//  Debug control switches
//=--------------------------------------------------------------------------=
DEFINE_SWITCH(fTraceCtlAllocs);	//  Trace all Heap allocations and frees
				//  fOutputFile should also be on with this switch
DEFINE_SWITCH(fOutputFile);	//  Logs all debug info in file: 
				//    %CurrentDir%\ctldebug.log
DEFINE_SWITCH(fNoLeakAsserts);	//  No Heap memory leak asserts are displayed 
				//    when turned on.



//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//                            !DEBUGGING HEAP MEMORY LEAKS!
// To debug a leak you need to figure out where and when the allocation was made.
// The top of the assert dialog will give you the OCX/DLL causing the leak.
// Goto Project/Build...Settings.
// On the Debug tab, select "additional DLLs"
// Locate and select the OCX/DLL causing the leak.
// Put a breakpoint on the noted line below. 
// Goto Edit...Breakpoints.
// Select the new breakpoint.
// Press 'Condition'
// In the 'Enter number of times to skip before breaking' put the value of nAlloc-1.
// (if the leak was nAlloc=267 then you want to skip the breapoint 266 times, enter 266)
//
// WARNING: Each control (OCX/DLL) will have its own instance of the framewrk, and thus
//	    its own instance of the memory leak implementaion.  Adding a breakpoint 
//	    anywhere in the framewrk will actually add multiple breakpoints - one for 
//	    each control.
//          Go back to Edit...Breakpoints.
//	    Deselect or remove the breakpoints for the OCX's/DLL's not causing leaks
//
// Run your scenario.
// When you hit this breakpoint verify that pvAddress and nByteCount are correct and then
// look down the callstack to see where the allocation was made.
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
void PutBreakPointHere(void * pvAddress, ULONG nByteCount, ULONG  nAlloc, char * szFile, ULONG uLine)
{
  pvAddress=pvAddress;  nAlloc=nAlloc;  nByteCount=nByteCount;
  szFile=szFile;
  uLine=uLine;
  HINSTANCE hInstance = g_hInstance;  //  hInstance of the OCX/DLL calling this breakpoint
  int PutBreakPointOnThisLine = 1;                              // <--- breakpoint here.
} //  PutBreakPointHere



//=--------------------------------------------------------------------------=
//
//  Debug Heap Memory Leak implementations
//

class CAddressNode
{
public:
  void * m_pv;		    //	Address of memory block allocated
  ULONG  m_cb;		    //	Size of allocation in BYTES
  ULONG  m_cAlloc;	    //	Allocation pass count.  
  LPSZ   m_szFile;	    //	Source file where the allocation was made
  ULONG  m_uLine;	    //	Source line number where the allocation was made
  CAddressNode * m_pnNext;  //	Nodes are stored in a linked list

  void * operator new(size_t cb);
  void operator delete(void * pv);

  //  We maintain a freelist to speed up allocation of AddressNodes.
  static CAddressNode * m_pnFreeList;
};


CAddressNode *	m_rInstTable[NUM_INST_TABLE_ENTRIES];  // Hashing table of all instances of 
						       // mem alloc

CAddressNode *	m_pnEnumNode;	      //  Next node for enumerator to return
UINT		m_uEnumIndex;	      //  Current index into m_rInstTable for enumerator
static ULONG	m_cGlobalPassCount;   //  Pass count of allocation.  Common to all heaps    

ULONG m_cCurNumAllocs;		  // Current number of allocations
ULONG m_cNumAllocs;		  // Total number of allocations ever done.
ULONG m_cCurNumBytesAllocated;	  // Current number of bytes allocated.
ULONG m_cNumBytesAllocated;	  // Total bytes allocated.
ULONG m_HWAllocs;		  // High water allocations.
ULONG m_HWBytes;		  // High water bytes.
static ULONG m_OverallCurAlloc;   // These are overall statistics to since we
static ULONG m_OverallCurBytes;   // wouldn't mind the overall high water.
static ULONG m_OverallHWAlloc;
static ULONG m_OverallHWBytes;


//  Forward declarations
VOID AddInst(VOID * pv, DWORD dwBytes, LPSZ szFile, UINT uLine);
VOID DebugInst(ULONG cb);
VOID AnalyzeInst(LPVOID pv);
VOID DumpInst(CAddressNode * pn, LPTSTR lpTypeofAlloc);
LPSTR DumpInstTable(LPSTR lpLeak);
VOID DeleteInst(LPVOID pv);
VOID VerifyHeaderTrailer(CAddressNode * pn);
VOID CheckForLeaks(VOID);
VOID HeapCheck(VOID);
VOID OutputToFile(LPSTR szOutput);
CAddressNode * FindInst(LPVOID pv);
CAddressNode * EnumReset();
CAddressNode * EnumNext();


//  Initialize a header and trailer for all memory to be allocated.
//  Use 8 bytes so it is also compatible with RISC machines.
char * g_szHeader  = "HEADHEAD";
char * g_szTrailer = "END!END!";

#define HEADERSIZE 8	    // # of bytes of block header
			    // 0 ==> no block header signature
#define TRAILERSIZE 8	    // # of bytes of block trailer
			    // 0 ==> no block trailer signature



//=--------------------------------------------------------------------------=
//  CtlHeapAllocImpl:
//	Debug wrapper for HeapAlloc to track memory leaks:
//=--------------------------------------------------------------------------=
LPVOID CtlHeapAllocImpl(
			HANDLE g_hHeap, 
			DWORD dwFlags, 
			DWORD dwBytesRequested, 
			LPSTR lpszFile, 
			UINT line
		       )
{
  LPVOID lpvRet;
  DWORD dwBytes;
  LPTSTR lpTypeofAlloc = "HeapAlloc   ";
  

  //  If someone tries to allocate memory before PROCCESS_ATTATCH (such as in a 
  //  global constructor), do not track it because neither our heap nor our 
  //  hInstance have been initialized yet.
  //
  if (!g_fInitCrit)
    {
    g_flagConstructorAlloc = TRUE;
    return HeapAlloc(g_hHeap, dwFlags, dwBytesRequested);
    }


  //  Increase size to make space for header and trailer signatures
  dwBytes = dwBytesRequested + HEADERSIZE + TRAILERSIZE;

  //  Allocate memory
  lpvRet = HeapAlloc(g_hHeap, dwFlags, dwBytes);
  if (lpvRet)
    {
    //	Initialize memory (non-zero)
    if (!(dwFlags & HEAP_ZERO_MEMORY))
      memset(lpvRet, 0xAF, dwBytes);

    //	Add instance to hash table
    AddInst(lpvRet, dwBytesRequested, lpszFile, line);

    //	Trace allocations if switch is on
    if (FSWITCH(fTraceCtlAllocs))
      {
      CAddressNode *pn = FindInst(lpvRet);
      DumpInst(pn, lpTypeofAlloc);
      }

    //	Advance pointer past header signature.
    lpvRet = (LPVOID) ((char *)lpvRet + HEADERSIZE);
    }
  return lpvRet;
} //  CtlHeapAllocImpl



//=--------------------------------------------------------------------------=
// CtlHeapReAllocImpl:
//   
//=--------------------------------------------------------------------------=
LPVOID CtlHeapReAllocImpl(
			  HANDLE g_hHeap, 
			  DWORD dwFlags, 
			  LPVOID lpvMem, 
			  DWORD dwBytesRequested, 
			  LPSTR lpszFile, 
			  UINT line
			 )
{
  LPVOID lpvRet;
  CAddressNode * pn;
  int byte;
  DWORD cbOffset, dwBytes;
  LPTSTR lpTypeofAlloc = "HeapReAlloc ";

  //  Move pointer to beginning of header
  lpvMem = (LPVOID)((char *)lpvMem - HEADERSIZE);

  //  Find instance in hash table
  pn = FindInst(lpvMem);
  if (!pn)
    {
    FAIL("CtlHeapReAllocImpl - could not find lpvMem in the instance table.  See debug \
          output for more info.");
    AnalyzeInst(lpvMem);
    return 0;
    }

  //  Increase size to make space for header and trailer signatures
  dwBytes = dwBytesRequested + HEADERSIZE + TRAILERSIZE;
  lpvRet = HeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes);
  if (lpvRet)
    {
    //	If the reallocation grew, we must intialize new memory
    if (dwBytesRequested > pn->m_cb)
      {
      if (dwFlags & HEAP_ZERO_MEMORY)
        byte = 0x0;
      else
        byte = 0xAF;

      //  Get the byte offset of trailer in the old allocation
      cbOffset = pn->m_cb + HEADERSIZE;
      memset((char *)lpvRet + cbOffset, byte, dwBytes - cbOffset);
      }
    //	Update hash table
    EnterCriticalSection(&g_csHeap);
    DeleteInst(lpvMem);
    AddInst(lpvRet, dwBytesRequested, lpszFile, line);
    LeaveCriticalSection(&g_csHeap); 

    //	Trace Allocations if switch is on
    if (FSWITCH(fTraceCtlAllocs))
      {
      CAddressNode *pn = FindInst(lpvRet);
      DumpInst(pn, lpTypeofAlloc);
      }

    //	Advance pointer past header signature.
    lpvRet = (LPVOID)((char *)lpvRet + HEADERSIZE);
    }
  return lpvRet;
} //  CtlHeapReAllocImpl

			       

//=--------------------------------------------------------------------------=
//  CtlHeapFreeImpl:
//	Debug wrapper for HeapFree
//=--------------------------------------------------------------------------=
BOOL CtlHeapFreeImpl(
		     HANDLE g_hHeap, 
		     DWORD dwFlags,
		     LPVOID lpvMem
		    )
{
  BOOL fRet = FALSE;
  CAddressNode * pn;
  LPTSTR lpTypeofAlloc = "HeapFree    ";


  //  If someone tries to de-allocate memory after PROCCESS_DETATCH (such as in a 
  //  global destructor), Re-initialize critical section and free memory.
  //
  if (!g_fInitCrit)
    InitializeCriticalSection(&g_csHeap);
	

  //  Move pointer to beginning of header
  lpvMem = (LPVOID) ((char *)lpvMem - HEADERSIZE);

  //  Find the instance in the hash table
  pn = FindInst(lpvMem);
  if (pn)
    {
    //	Verify the memory has not been overwritten 
    VerifyHeaderTrailer(pn);

    //	Trace allocations if switch is on
    if (FSWITCH(fTraceCtlAllocs))
      {
      CAddressNode *pn = FindInst(lpvMem);
      DumpInst(pn, lpTypeofAlloc);
      }

    //	Free memory  -- NOTE: WinNT will set free memory to 0xEEFEEEFE which is ""
    fRet = HeapFree(g_hHeap, 0, lpvMem);
    if (!fRet)
      FAIL("CtlHeapFreeImpl - lpvMem was found to be allocated in the heap passed in \
	    but HeapFree() failed.  Maybe the pointer was already freed.");
    }

  //  Remove instance from hash table
  if (fRet)
    DeleteInst(lpvMem);  

  //  Make sure this memory wasn't allocated in a global constructor
  else if (!g_flagConstructorAlloc)
    {
    FAIL("CtlHeapFreeImpl - could not find lpvMem in the instance table.  See debug \
          output for more info.");
    AnalyzeInst(lpvMem);
    }
  else
    fRet = TRUE;
  
  //  If called after PROCESS_DETATCH delete critical section and Check for leaks again
  //  NOTE:  Only the LAST Assert will have the exact leak information.  All previous
  //	     Asserts will not take into account a HeapFree which occurs after PROCESS_DETACH.
  //	     This only occurs in controls using global static destructors.
  if (!g_fInitCrit)
    {
    CheckForLeaks();
    DeleteCriticalSection(&g_csHeap);
    }

  return fRet;
} //  CtlHeapFreeImpl



//=--------------------------------------------------------------------------=
//  CheckForLeaks:
//    We are calling PROCESS_DETATCH so check if hash table is empty.  If not
//    dump info on memory that has been leaked.
//=--------------------------------------------------------------------------=
VOID CheckForLeaks(VOID)
{
  CAddressNode * pn = EnumReset();
  BOOL IsEmpty = (pn == NULL);	  //  FALSE if there are leaks

  //  First check for memory trashing of any leaked memory
  HeapCheck();
  
  if (!IsEmpty)
    {

    //	First find out which OCX/DLL is leaking
    TCHAR lpCtlName[128];
    DWORD nSize = 128;
    DWORD fValidPath;
    fValidPath = GetModuleFileName(g_hInstance, (LPTSTR)lpCtlName, nSize);

    LPSTR lpLeaks;
    // Allocate some memory to hold the data but use GlobalAlloc since we
    // don't want to use the vb memory stuff since it will muck things up.
    lpLeaks = (LPSTR)GlobalLock(GlobalAlloc(GMEM_MOVEABLE,128));

    lstrcpy(lpLeaks, lpCtlName);
    lstrcat(lpLeaks, " has leaked memory.\nUse PutBreakPointHere() in macros.cpp to debug.\r\n");

    //  Collect all leak info
    lpLeaks = DumpInstTable(lpLeaks);
    
    //  Dump output to file if "fOutputFile" switch is on
    if (FSWITCH(fOutputFile))
      OutputToFile(lpLeaks);

    //  Dump output to an assert as long as "fNoLeakAsserts" is off
    else if (!FSWITCH(fNoLeakAsserts))
      {
      //  Truncate output so it fits into DisplayAssert (512 Max)
      if (lstrlen(lpLeaks) > 500)
	{
	lstrcpyn(lpLeaks, lpLeaks, 500);
	lstrcat(lpLeaks, "\nMore...");
	}
      DisplayAssert(lpLeaks, "FAIL", NULL, 0);
      }

    //	Release memory used to store leak info
    GlobalUnlock((HGLOBAL)GlobalHandle(lpLeaks)), 
	      (BOOL)GlobalFree((HGLOBAL)GlobalHandle(lpLeaks));

    }
  return;
} //  CheckForLeaks



//=--------------------------------------------------------------------------=
//  AddInst:
//    A heap allocation occured so here we add the allocation information to 
//    the instance table.  To debug memory leaks where you need to use pass 
//    counts, set a passcount breakpoint in this function using the passcount 
//    value given in the debug output.
//=--------------------------------------------------------------------------=
VOID AddInst(
	     VOID * pv, 
	     DWORD dwBytes, 
	     LPSZ szFile, 
	     UINT uLine
	    )
{
  UINT uHash;
  CAddressNode * pn = new CAddressNode();
  ASSERT(pn,"");
  
  EnterCriticalSection(&g_csHeap);

  m_cGlobalPassCount++;

  pn->m_pv = pv;                        //  Memory address of allocation
  pn->m_cb = dwBytes;                   //  Bytes requested to be allocated
  pn->m_cAlloc = m_cGlobalPassCount;    //  This is the pass count value in debug output.
  pn->m_szFile = szFile;                //  Source file the allocation call was made
  pn->m_uLine = uLine;                  //  Line number in source file.

  PutBreakPointHere(pv, dwBytes, m_cGlobalPassCount, szFile, uLine);

  //  Add instance to proper position in table
  uHash = HashInst(pv);
  pn->m_pnNext = m_rInstTable[uHash];
  m_rInstTable[uHash] = pn;

  //  Copy header and trailer signatures.
  memcpy((char *)pv, g_szHeader, HEADERSIZE);
  memcpy((char *)pv + HEADERSIZE + dwBytes, g_szTrailer, TRAILERSIZE);

  LeaveCriticalSection(&g_csHeap);

  //  Track extra memory debug info
  DebugInst( dwBytes );
} //  AddInst



//=--------------------------------------------------------------------------=
//  DebugInst:
//    Updates the memory debug information
//=--------------------------------------------------------------------------=
VOID DebugInst(
	       ULONG cb
	      )
{
  EnterCriticalSection(&g_csHeap);

  ++m_cCurNumAllocs;
  ++m_cNumAllocs;
  ++m_OverallCurAlloc;
  m_cCurNumBytesAllocated+=cb;
  m_cNumBytesAllocated+=cb;
  m_OverallCurBytes+=cb;

  m_HWAllocs = (m_HWAllocs < m_cCurNumAllocs) ? m_cCurNumAllocs : m_HWAllocs;
  m_HWBytes = (m_HWBytes < m_cCurNumBytesAllocated) ? m_cCurNumBytesAllocated : m_HWBytes;
  m_OverallHWAlloc = (m_OverallHWAlloc < m_OverallCurAlloc) 
						    ? m_OverallCurAlloc : m_OverallHWAlloc;
  m_OverallHWBytes = (m_OverallHWBytes < m_OverallCurBytes) 
						    ? m_OverallCurBytes : m_OverallHWBytes;

  LeaveCriticalSection(&g_csHeap);

} //  DebugInst



//=--------------------------------------------------------------------------=
//  FindInst:
//    Give a pointer to an allocation, return a pointer to the debug 
//    allocation information.
//=--------------------------------------------------------------------------=
CAddressNode * FindInst(
			LPVOID pv
		       )
{
  CAddressNode * pn;

  EnterCriticalSection(&g_csHeap);

  pn = m_rInstTable[HashInst(pv)];
  while (pn && pn->m_pv != pv)
    pn = pn->m_pnNext;

  LeaveCriticalSection(&g_csHeap);
  return pn;

} //  FindInst



//=--------------------------------------------------------------------------=
//  AnalyzeInst:
//    Given a pointer try determine if it is a valid Read and Write pointer
//    and if it was allocated.
//=--------------------------------------------------------------------------=
VOID AnalyzeInst(
		 LPVOID pv
		)
{
  LPTSTR lpTypeofAlloc = "Bad lpvMem ";
  CAddressNode * pn = NULL;

  //  Either we have a bad pointer or the pointer does not point to any
  //  known heap allocations.   Here we check if it points to readable or 
  //  writable memory.
  BOOL fBadPointer = (IsBadReadPtr(pv, 4) || IsBadWritePtr(pv, 4));
    
  // Report what we know about the memory address
  if (fBadPointer)
    DebugPrintf("AnalyzeInst found that pointer pv=0x%lX is not writable\n\r" \
		"or readable.  The allocation is either outside the addressable range\n\r" \
		"for this operating system or the allocation was already freed.\n\r",pv);
  else
    DebugPrintf("AnalyzeInst found that pointer pv=0x%lX is readable and writable,\n\r"  \
		"so the allocation was made without being added to instance table\n\r" \
		"(prior to PROCESS_ATTATCH), or the memory was already freed.\n\r",pv);
    
} //  AnanlyzeInst



//=--------------------------------------------------------------------------=
//  DumpInst:
//    Dump instance information out to an assert window.
//=--------------------------------------------------------------------------=
VOID DumpInst(
	      CAddressNode * pn,
	      LPTSTR lpTypeofAlloc
	     )
{  
  char szOutput[255];

  //  Format output
  wsprintf(szOutput, "%s: %s(%u) Address=0x%lx  nAlloc=%ld  Bytes=%ld\r\n", lpTypeofAlloc,
	   pn->m_szFile, pn->m_uLine, (ULONG)pn->m_pv, (ULONG)pn->m_cAlloc, (ULONG)pn->m_cb);
  
  //  Dump output to file if switch is turned on
  if (FSWITCH(fOutputFile))
    OutputToFile(szOutput);
  else if (FSWITCH(fNoLeakAsserts))
    DebugPrintf(szOutput);
      
  //  Else display output in assert
  else
    DisplayAssert(szOutput, "FAIL", _szThisFile, __LINE__);;

} //  DumpInst



//=--------------------------------------------------------------------------=
//  DumpInstTable:
//    Memory leak has been detected so dump the entire instance table.
//=--------------------------------------------------------------------------=
LPSTR DumpInstTable(
		    LPSTR lpLeak
		   )
{
  CAddressNode * pn = EnumReset();
  DWORD sizeoflpLeak;
  LPSTR lpTemp;

  EnterCriticalSection(&g_csHeap);

  DebugPrintf(lpLeak);

  while (pn)
    {
    //	Format the leak info
    char szOut[250] = {NULL};
    wsprintf(szOut, "\t%s(%u) Address=0x%lx  nAlloc=%ld  Bytes=%ld\r\n", pn->m_szFile,
           pn->m_uLine, (ULONG)pn->m_pv, (ULONG)pn->m_cAlloc, (ULONG)pn->m_cb);

    DebugPrintf(szOut);
    
    //  Convert lpLeak to a handle and get its current allocation size
    sizeoflpLeak = GlobalSize(GlobalHandle(lpLeak));

    //	Reallocate memory to make space for more leak info
    lpTemp = (LPSTR) (GlobalUnlock((HGLOBAL)GlobalHandle(lpLeak)), 
	      GlobalLock(GlobalReAlloc((HGLOBAL)GlobalHandle(lpLeak), 
	      sizeoflpLeak + lstrlen(szOut) + 1, GMEM_MOVEABLE)));

    //	Add new leak info to lpLeak
    if(lpTemp)
      {
      lpLeak = lpTemp;
      lstrcat(lpLeak, szOut);
      }

    //	Get the next leak
    pn = EnumNext();
    }
  LeaveCriticalSection(&g_csHeap);
  return lpLeak;

} //  DumpInstTable



//=--------------------------------------------------------------------------=
//  DeleteInst:
//    A heap allocation got free or was reallocated so remove the
//    information from the instance table and check for memory trashing.
//=--------------------------------------------------------------------------=
VOID DeleteInst(
		LPVOID pv
	       )
{
  CAddressNode ** ppn, * pnDead;
  ppn = &m_rInstTable[HashInst(pv)];

  EnterCriticalSection(&g_csHeap);
  
  //  Find allocation instance 
  while (*ppn != NULL)
    {
    if ((*ppn)->m_pv == pv)
      {
      pnDead = *ppn;
      *ppn = (*ppn)->m_pnNext;

      //  Correct memory debug info
      --m_cCurNumAllocs;
      m_cCurNumBytesAllocated -= pnDead->m_cb;
      --m_OverallCurAlloc;
      m_OverallCurBytes -= pnDead->m_cb;

      //  Remove instance
      delete pnDead;
		  LeaveCriticalSection(&g_csHeap);
      return;
      }	//  if

    ppn = &((*ppn)->m_pnNext);
    } //  while

    FAIL("DeleteInst - memory instance not found");
} //  DeleteInst



//=--------------------------------------------------------------------------=
//  VerifyHeaderTrailer:
//    Inspect allocation for header and trailer signature overwrites
//=--------------------------------------------------------------------------=
VOID VerifyHeaderTrailer(
			 CAddressNode * pn
			)
{
  LPTSTR lpTypeofAlloc = "Memory trashed ";

  //Verify the header
  if (memcmp((char *)pn->m_pv, g_szHeader, HEADERSIZE) != 0)
    {
    FAIL("Heap block header has been trashed.");
    DebugPrintf("Heap block header trashed.");
    DebugPrintf("\r\n");
    DumpInst(pn, lpTypeofAlloc);
    }

  //Verify the trailer
  if (memcmp((char *)pn->m_pv + pn->m_cb + HEADERSIZE, g_szTrailer, TRAILERSIZE) != 0)
    {
    FAIL("Heap block trailer has been trashed.");
    DebugPrintf("Heap block trailer trashed.");
    DebugPrintf("\r\n");
    DumpInst(pn, lpTypeofAlloc);
    }
  return;

} //  VerifyHeaderTrailer




//=--------------------------------------------------------------------------=
//  HeapCheck:
//    Inspect all of the allocations for header and trailer signature 
//    overwrites.
//=--------------------------------------------------------------------------=
VOID HeapCheck(VOID)
{
  ASSERT(HeapValidate(g_hHeap, 0, NULL) != 0, "OS Says heap is corrupt");

  CAddressNode * pn = EnumReset();
  while (pn)
    {
    VerifyHeaderTrailer(pn);
    pn = EnumNext();
    }
  return;
} //  HeapCheck



//=-------------------------------------------------------------------------=
//  For use with CAddresssNode
//=-------------------------------------------------------------------------=
#define MEM_cAddressNodes 128		  //  Nodes are block allocated
#define UNUSED(var)	  ((var) = (var)) //  Used to avoid warnings

//  The free list is common
CAddressNode * CAddressNode::m_pnFreeList = NULL;

//=--------------------------------------------------------------------------=
//  CAddressNode::operator new:
//    Returns a pointer to an allocated address node. If there are none on 
//    the free list then we allocate a block of address nodes, chain them 
//    together and add them to the free list.   These nodes are never 
//    actually freed so it is ok to allocate them in blocks.
//=--------------------------------------------------------------------------=
void * CAddressNode::operator new(
				  size_t cb
				 )
{
  CAddressNode * pn;
  UNUSED(cb);

  EnterCriticalSection(&g_csHeap); // needed for static m_pnFreeList

  if (m_pnFreeList == NULL)
    {
    UINT cbSize = sizeof(CAddressNode) * MEM_cAddressNodes;  //allocate a block
    pn = (CAddressNode *) HeapAlloc(g_hHeap, 0, cbSize);
    //chain all except the first node together.  the first node
    //is the one returned
    for (int i = 1; i < MEM_cAddressNodes - 1; ++i)
      pn[i].m_pnNext = &pn[i+1];
    pn[MEM_cAddressNodes - 1].m_pnNext = NULL;
    m_pnFreeList = &pn[1];
    }
  else
    {
    pn = m_pnFreeList;
    m_pnFreeList = pn->m_pnNext;
    }

  LeaveCriticalSection(&g_csHeap);
  return pn;
} //  CAddressNode::operator new



//=--------------------------------------------------------------------------=
//  CAddressNode::operator delete
//    Return the address node to the free list.  We never actually free
//    the node since nodes are allocated in blocks.
//=--------------------------------------------------------------------------=
void CAddressNode::operator delete(
				   void * pv
				  )
{
  EnterCriticalSection(&g_csHeap); // needed for static m_pnFreeList

  CAddressNode * pn = (CAddressNode *) pv;
  pn->m_pnNext = m_pnFreeList;
  m_pnFreeList = pn;

  LeaveCriticalSection(&g_csHeap);
} //  CAddressNode::operator delete



//=--------------------------------------------------------------------------=
//  EnumReset:
//    Reset the enumerator and return the first node.  NULL if empty.
//=--------------------------------------------------------------------------=
CAddressNode * EnumReset()
{
  m_pnEnumNode = NULL;
  for (m_uEnumIndex = 0; m_uEnumIndex < NUM_INST_TABLE_ENTRIES; ++m_uEnumIndex)
    {
    m_pnEnumNode = m_rInstTable[m_uEnumIndex];
    if (m_pnEnumNode != NULL)
      return m_pnEnumNode;
    }
  return NULL;  //Instance table is empty
} //  EnumReset



//=--------------------------------------------------------------------------=
//  EnumNext:
//    Return the next node in the enumeration.  m_pnEnumNode points to the last
//    node returned.  It is NULL if no more left.
//=--------------------------------------------------------------------------=
CAddressNode * EnumNext()
{
  ASSERT(m_uEnumIndex <= NUM_INST_TABLE_ENTRIES, "");

  if (m_pnEnumNode == NULL)
    return NULL;    //end of enumeration

  m_pnEnumNode = m_pnEnumNode->m_pnNext;
  if (m_pnEnumNode == NULL)
    {
    //at end of this linked list so search for next list
    m_uEnumIndex++;
    while (m_uEnumIndex < NUM_INST_TABLE_ENTRIES && m_rInstTable[m_uEnumIndex] == NULL)
      m_uEnumIndex++;
    if (m_uEnumIndex < NUM_INST_TABLE_ENTRIES)
      m_pnEnumNode = m_rInstTable[m_uEnumIndex];
    }
  return m_pnEnumNode;
} //  EnumNext



//=---------------------------------------------------------------------------=
//  OutputToFile:
//    Dumps output to file "ctldebug.log"
//=---------------------------------------------------------------------------=
VOID OutputToFile
(
    LPSTR szOutput
)
{
    DWORD nPathSize;
    DWORD nDirPathSize = 128;
    TCHAR lpFilePath[128];
    LPCTSTR lpFileName = "\\CtlDebug.log";
    HANDLE hFile;
    BOOL fWritten, fClosed = FALSE;
    DWORD nBytesWritten;

    //	Create path to output file
    nPathSize = GetCurrentDirectory(nDirPathSize, (LPTSTR)lpFilePath);
    if (nPathSize == 0)
      FAIL("Unable to get current directory...");
    lstrcat(lpFilePath, lpFileName);

    //	Open and write to file
    hFile = CreateFile((LPCTSTR)lpFilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
			                                FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD SetPtr = SetFilePointer(hFile, NULL, NULL, FILE_END);
    fWritten = WriteFile(hFile, (LPCVOID)szOutput, (DWORD)strlen(szOutput), 
			                                        &nBytesWritten, NULL); 
    if (!fWritten)
      FAIL("Unable to write output to file...");

    //	Close file handle
    fClosed = CloseHandle(hFile);
    if (!fClosed)
      FAIL("Unable to close output file...");

} //  OutputToFile


//
//  End of Debug Memory Leak implemntation
//
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// This routine outputs through DebugPrintf some information if the 
// given hr fails to succeed.  This is used by RRETURN to output where
// a function that returns a failing error code.
//=--------------------------------------------------------------------------=
HRESULT HrDebugTraceReturn
(
  HRESULT hr,
  char *pszFile,
  int iLine
)
{
  // We only output information if the hr fails.
  if (FAILED(hr))
    {
    char szMessageError[128];
    szMessageError[0] = '\0';
    BOOL fMessage;

#if RBY_MAC
    fMessage = FALSE; // FormatMessage not available on the mac
#else
    // Get the message from the system
    // CONSIDER, t-tshort 10/95: Getting some messages from us instead 
    //                           of the system?
    fMessage = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK
			      | FORMAT_MESSAGE_FROM_SYSTEM,
			     NULL, hr,
			     MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),
			     szMessageError, sizeof(szMessageError), NULL);
#endif

    // Erps didn't get a message.
    if(!fMessage)
      lstrcpy(szMessageError,"Unknown Hresult");

    // Output the information that we want.
    DebugPrintf("FAILED RETURN: %s(%d) : 0x%08lx, %s\n", 
                pszFile, iLine, hr, szMessageError);
    }

  return hr;
}

//---------------------------------------------------------------------
// The following is a common output formatting buffer shared by several
// of the following debug routines.
//---------------------------------------------------------------------
char s_rgchOutput[2048]; // pretty big...


//=--------------------------------------------------------------------------=
// Emit debugging information
//=--------------------------------------------------------------------------=
void _DebugOutput(char* pszOutput)
{
  OutputDebugString(pszOutput);
}


//=--------------------------------------------------------------------------=
// Emit a formatted debugging string to the location specified in
// the debug options dialog.
//=--------------------------------------------------------------------------=
void _DebugPrintf(char* pszFmt, ...) 
{
  va_list  args;

  va_start(args, pszFmt);
  wvsprintf(s_rgchOutput, pszFmt, args);
  va_end(args);

  // sqwak if we overrun the formatting buffer!
  ASSERT(strlen(s_rgchOutput) < sizeof(s_rgchOutput), "");

  _DebugOutput(s_rgchOutput);
}

//=--------------------------------------------------------------------------=
// Conditional form of DebugPrintf
//=--------------------------------------------------------------------------=
void _DebugPrintIf(BOOL fPrint, char* pszFmt, ...)
{
  va_list  args;

  if (!fPrint)
    return;

  va_start(args, pszFmt);
  wvsprintf(s_rgchOutput, pszFmt, args);
  va_end(args);

  // sqwak if we overrun the formatting buffer!
  ASSERT(strlen(s_rgchOutput) < sizeof(s_rgchOutput), "");

  _DebugOutput(s_rgchOutput);
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\pch.h ===
//
// Definition of precompiled header
//
#include "IPserver.h"
#include "Globals.h"
#include "util.h"
#include "macros.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\ipserver.cpp ===
//=--------------------------------------------------------------------------=
// InProcServer.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "pch.h"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "ClassF.H"
#include "CtrlObj.H"
#include "Unknown.H"
#include "ComCat.H"

#ifdef DEBUG 
#include "debug.h"
#include <winbase.h>
#endif // DEBUG

// for ASSERT and FAIL
//
SZTHISFILE

#ifdef VS_HELP
    #include "vshelp.h"
    extern IVsHelpSystem *g_pIVsHelpSystem;
#endif

//=--------------------------------------------------------------------------=
// Private module level data
//

//=--------------------------------------------------------------------------=
// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.
//
// Make this a constant.
extern const char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow";
BYTE g_fRegisteredReflect = FALSE;
BOOL g_fDBCSEnabled = FALSE;

extern HINSTANCE g_hInstResources;
extern HINSTANCE g_hinstVersion;

#ifdef MDAC_BUILD
extern HINSTANCE g_hOleAutHandle;
#else
extern HANDLE 	 g_hOleAutHandle;
#endif

extern const int    g_ctCATIDImplemented;
extern const CATID* g_rgCATIDImplemented[];

// ref count for LockServer
//
LONG  g_cLocks;


// private routines for this file.
//
int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);
void      CleanupGlobalObjects(void);

//=--------------------------------------------------------------------------=
// DllMain
//=--------------------------------------------------------------------------=
// yon standard LibMain.
//
// Parameters and Output:
//    - see SDK Docs on DllMain
//
// Notes:
//
BOOL WINAPI DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    void  *pvReserved
)
{
//    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
        DWORD dwVer = GetVersion();
        DWORD dwWinVer;

        //  swap the two lowest bytes of dwVer so that the major and minor version
        //  numbers are in a usable order.
        //  for dwWinVer: high byte = major version, low byte = minor version
        //     OS               Sys_WinVersion  (as of 5/2/95)
        //     =-------------=  =-------------=
        //     Win95            0x035F   (3.95)
        //     WinNT ProgMan    0x0333   (3.51)
        //     WinNT Win95 UI   0x0400   (4.00)
        //
        dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
        g_fSysWinNT = FALSE;
        g_fSysWin95 = FALSE;
        g_fSysWin95Shell = FALSE;

        if (dwVer < 0x80000000) {
            g_fSysWinNT = TRUE;
            g_fSysWin95Shell = (dwWinVer >= 0x0334);
        } else  {
            g_fSysWin95 = TRUE;
            g_fSysWin95Shell = TRUE;
        }
        
		// initialize a critical seciton for our apartment threading support
        //
        InitializeCriticalSection(&g_CriticalSection);

        // create an initial heap for everybody to use.
        // currently, we're going to let the system make things thread-safe,
        // which will make them a little slower, but hopefully not enough
        // to notice
        //
        if (!g_hHeap)
            g_hHeap = GetProcessHeap();
        if (!g_hHeap) {
            FAIL("Couldn't get Process Heap.  Not good!");
            return FALSE;
        }

        g_hInstance = (HINSTANCE)hInstance;

        // this causes DllMain to NOT get called for DLL_THREAD_ATTACH and DETACH.
        // if you are interested in these notifications, please remove this line.
        //
        DisableThreadLibraryCalls(g_hInstance);

        g_fDBCSEnabled = GetSystemMetrics(SM_DBCSENABLED);

        // Initialize OleAut
		//
        g_hOleAutHandle = LoadLibrary("oleaut32.dll");
 
        // give the user a chance to initialize whatever
        //
        InitializeLibrary();


#ifdef DEBUG

	TCHAR lpCtlName[255];
	DWORD nSize = 255;
	DWORD fValidPath;

	// set all ctl debug switches
	//
	fValidPath = GetModuleFileName(g_hInstance, (LPTSTR)lpCtlName, nSize);
	if (fValidPath != 0)
	  SetCtlSwitches((LPSTR)lpCtlName);

        // initialize a critical seciton for our heap memory leak detection
        //
	InitializeCriticalSection(&g_csHeap);
	g_fInitCrit = TRUE; 
	
#endif // DEBUG
  
        return TRUE;
        }

      // do  a little cleaning up!
      //
      case DLL_PROCESS_DETACH:

  #ifdef VS_HELP
        ASSERT(g_pIVsHelpSystem == NULL, "IVsHelpSystem didn't get released");
  #endif
        
        // clean up some stuff
        //
        DeleteCriticalSection(&g_CriticalSection);
        CleanupGlobalObjects();

        // give the user a chance to do some cleaning up
        //
        UninitializeLibrary();

        // Deinitialize OleAut, But not in Win95.
		// Calling FreeLibrary under Win95 for OleAut
		// will sometimes cause a crash (It seems that 
		// there can be a rpoblem in which OleAut is called
		// from OleUnitnitialize and causes a problem with FreeLibrary.
		//
        if (g_hOleAutHandle && !g_fSysWin95)
        {
            FreeLibrary((HINSTANCE)g_hOleAutHandle);
            g_hOleAutHandle = NULL;
        }

		// Make sure we free up our cached resource handle for localized resources
		//
		if (g_hInstResources && g_hInstResources != g_hInstance)
			FreeLibrary(g_hInstResources);

		// Free up VERSION.DLL
		//
		if (g_hinstVersion)
		{
			FreeLibrary(g_hinstVersion);
			g_hinstVersion = NULL;
		}
			
#ifdef DEBUG

		// check for memory leaks
		//
		CheckForLeaks();

		// free critical section used for leak checking
		//
		DeleteCriticalSection(&g_csHeap);
		g_fInitCrit = FALSE;
        
#endif //  DEBUG

        return TRUE;
    }

    return TRUE;
}


//=--------------------------------------------------------------------------=
// CleanupGlobalObjects
//=--------------------------------------------------------------------------=
// duh
//
// Notes:
//
void CleanupGlobalObjects(void)
{
    int i = 0;

    while (!ISEMPTYOBJECT(i)) {
        if (g_ObjectInfo[i].usType == OI_CONTROL) {
            if (CTLWNDCLASSREGISTERED(i))
                UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance);
        }
        i++;
    }

    // clean up our parking window.
    //
    if (g_hwndParking) {
        DestroyWindow(g_hwndParking);
        g_hwndParking = NULL;
        UnregisterClass("CtlFrameWork_Parking", g_hInstance);
    }

    // clean up after reflection, if appropriate.
    //
    if (g_fRegisteredReflect) {
        UnregisterClass(g_szReflectClassName, g_hInstance);
        g_fRegisteredReflect = FALSE;
    }
}

//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllRegisterServer
(
    void
)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user registration function.
    //
    return (RegisterData())? S_OK : E_FAIL;
}



//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllUnregisterServer
(
    void
)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function
    //
    return (UnregisterData()) ? S_OK : E_FAIL;
}


//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.
//
// Notes:
//
STDAPI DllCanUnloadNow
(
    void
)
{

#ifdef VS_HELP

      if (g_pIVsHelpSystem)
      {
          g_pIVsHelpSystem->Release();
          g_pIVsHelpSystem = NULL;
      }

#endif

    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this
    //
#ifdef MDAC_BUILD
    return (g_cLocks || !CanUnloadLibraryNow()) ? S_FALSE : S_OK;
#else
    return (g_cLocks) ? S_FALSE : S_OK;
#endif
}


//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED
//
// Notes:
//
STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

    // arg checking
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.
    //
    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
#ifdef MDAC_BUILD
        // NOTE: LibraryGetClassObject() hook for ATL/VS98 support, added by markash
	return LibraryGetClassObject(rclsid, riid, ppvObjOut);
#else         
        return CLASS_E_CLASSNOTAVAILABLE;
#endif

    // create the blank object.
    //
    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported
//
// Notes:
//
int IndexOfOleObject
(
    REFCLSID rclsid
)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//
HRESULT RegisterAllObjects
(
    void
)
{
    ITypeLib *pTypeLib = NULL;
    HRESULT hr;
    DWORD   dwPathLen;
    char    szTmp[MAX_PATH];
    char    szHelpPath[MAX_PATH];
    int     x = 0;
    BOOL    fHelpFile = FALSE;
    long    lMajor = -1, lMinor = -1;
    UINT    cbWinHelpPath = 0;
    OLECHAR *pwszHelpPath;
    BSTR bstrTypeLibName = NULL;
	WORD wFlags = 0;

#if DEBUG
	BOOL fCtlFlagFound = FALSE;
	BOOL fCtlTypeLib = FALSE;
	int iCatID;
	BOOL fCatIDFound = FALSE;
#endif

    // Load and register our type library.
    //
    if (g_fServerHasTypeLibrary) {
        TLIBATTR *ptlattr;
        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
        bstrTypeLibName = BSTRFROMANSI(szTmp);
        hr = LoadTypeLib(bstrTypeLibName, &pTypeLib);
        if (FAILED(hr)) goto CleanUp;
		
        pTypeLib->GetLibAttr(&ptlattr);
        lMajor = ptlattr->wMajorVerNum;
        lMinor = ptlattr->wMinorVerNum;

#if DEBUG
		fCtlTypeLib = ptlattr->wLibFlags & LIBFLAG_FCONTROL;
#endif		
        pTypeLib->ReleaseTLibAttr(ptlattr);

    }


    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }
	
        // Check to see if there is a help file for the object
        // If so, look for it in the Windows\Help directory.  If a help file is 
        // found for any object in the Windows\Help directory, then we'll register it with 
        // the typelib.  Once we find the first help file we stop looking.
        //
        if (!fHelpFile) {
            if (cbWinHelpPath == 0)  {
                cbWinHelpPath = GetHelpFilePath(szHelpPath, MAX_PATH);
                lstrcat(szHelpPath, "\\");
                cbWinHelpPath++;
            }
		
            ASSERT(cbWinHelpPath > 0, "Help path is zero length");
            ASSERT(cbWinHelpPath + ((HELPFILEOFOBJECT(x)) ? lstrlen(HELPFILEOFOBJECT(x)) : 0) < MAX_PATH, "Help file path exceeds maxiumu path");
		
            // Make sure we have a non-NULL pointer before calling lstrlen
            // and check that the helpfile exists and isn't a directory
            //		
            if (HELPFILEOFOBJECT(x) && lstrlen(HELPFILEOFOBJECT(x)) > 0) {
                lstrcpyn(szHelpPath + cbWinHelpPath, HELPFILEOFOBJECT(x), lstrlen(HELPFILEOFOBJECT(x)) + 1);
                fHelpFile = ((GetFileAttributes(szHelpPath) & FILE_ATTRIBUTE_DIRECTORY) == 0);
            }

            // Once we've determined the help file exists, terminate after the filename
            // since all we care to register is the path.  Not the path and filename.  We also
            // don't want the terminating '\', so subtract 1 from cbWinHelpPath.
            //
            if (fHelpFile)
                szHelpPath[cbWinHelpPath - 1] = '\0';
            else
                szHelpPath[cbWinHelpPath] = '\0';
        }

        // depending on the object type, register different pieces of information
        //
        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing
          //
          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:

	#if DEBUG
			// For debug builds, verify that the cached object data matches the typeinfo attributes for that object
			//
			hr =  GetTypeFlagsForGuid(pTypeLib, CLSIDOFOBJECT(x), &wFlags);
			if (SUCCEEDED(hr))
			{
				if (NULL != CREATEFNOFOBJECT(x))
				{
					ASSERT(wFlags & TYPEFLAG_FCANCREATE, "Create flag not found on creatable object");
				}
				else
				{
					ASSERT(!(wFlags & TYPEFLAG_FCANCREATE), "Create flag found on non-creatable object");
				}
			}
	#endif

            RegisterUnknownObject(NAMEOFOBJECT(x), LABELOFOBJECT(x), CLSIDOFOBJECT(x), ISAPARTMENTMODELTHREADED(x));
            break;

          case OI_AUTOMATION:
	
	#if DEBUG
			// For debug builds, verify that the cached object data matches the typeinfo attributes for that object
			//
			hr =  GetTypeFlagsForGuid(pTypeLib, CLSIDOFOBJECT(x), &wFlags);
			if (SUCCEEDED(hr))
			{
				if (NULL != CREATEFNOFOBJECT(x))
				{
					ASSERT(wFlags & TYPEFLAG_FCANCREATE, "Create flag not found on creatable object");
				}
				else
				{
					ASSERT(!(wFlags & TYPEFLAG_FCANCREATE), "Create flag found on non-creatable object");
				}
			}
	#endif
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), LABELOFOBJECT(x), VERSIONOFOBJECT(x),
                                     lMajor, lMinor, *g_pLibid, CLSIDOFOBJECT(x), ISAPARTMENTMODELTHREADED(x));
            break;

          case OI_CONTROL:
			
			{	
				BOOL fControl = TRUE;

				//  Go to the TypeInfo for the object and see if it has the control bit set
				//  We should only add the Control and ToolboxBitmap32 registry key for objects 
				//  that have the Control bit set in their typelib.
				//
				//  Note: If the TypeLib can't be found or there is an error attempting to
				//		  retrieve the control flag, we default to setting the Control bit.
				//        Since we're attempting to register the object as a control our
				//        default assumption will be that it is a control.
				//
				hr =  GetTypeFlagsForGuid(pTypeLib, CLSIDOFOBJECT(x), &wFlags);
				if (SUCCEEDED(hr))
				{
					fControl = wFlags & TYPEFLAG_FCONTROL;
			
			#if DEBUG
					fCtlFlagFound |= fControl;

					// For debug builds, verify that the cached object data matches the typeinfo attributes for that object
					//
					if (NULL != CREATEFNOFOBJECT(x))
					{
						ASSERT(wFlags & TYPEFLAG_FCANCREATE, "Create flag not found on creatable object");
					}
					else
					{
						ASSERT(!(wFlags & TYPEFLAG_FCANCREATE), "Create flag found on non-creatable object");
					}
			#endif

				}

				RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), LABELOFOBJECT(x), 
									  VERSIONOFOBJECT(x), VERSIONMINOROFOBJECT(x),
									  lMajor, lMinor,
									  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x),
									  BITMAPIDOFCONTROL(x), ISAPARTMENTMODELTHREADED(x),
									  fControl);
			}
            break;

        }
        x++;
    }

	// Make sure the if a TypeLib control attribute was found, a coclass control attribute is also found;
	// or neither is found.  You can't have one without the other.
	// 
	ASSERT((fCtlTypeLib && fCtlFlagFound) || 
		   (!fCtlTypeLib && !fCtlFlagFound), "TypeLib and coclass control attributes not set consistently");


    if (g_fServerHasTypeLibrary)
    {
		ASSERT(pTypeLib, "TypeLib pointer is NULL");
		ASSERT(SysStringLen(bstrTypeLibName) > 0, "TypeLib name is invalid");

        if (fHelpFile)
		pwszHelpPath = OLESTRFROMANSI(szHelpPath);

	// Note: we have to pass in an empty string instead of NULL if fHelpFile==FALSE, because
	//   otherwise OLEAUT leaves the old value of the HELPDIR key there (stephwe 9/97)
        hr = RegisterTypeLib(pTypeLib, bstrTypeLibName, fHelpFile ? pwszHelpPath : L"");

        if (fHelpFile)
		CoTaskMemFree(pwszHelpPath);

        pTypeLib->Release();
        if (FAILED(hr)) goto CleanUp;
    }

#if DEBUG		

	// Make sure there is consistency between the Control flags set in the typelib
	// versus the CATID_Control attribute.
	//
	for (iCatID=0; iCatID < g_ctCATIDImplemented; iCatID++)
	{
		if (IsEqualGUID((REFGUID) *g_rgCATIDImplemented[iCatID], (REFGUID) CATID_Control))
		{
			fCatIDFound = TRUE;					   
			break;
		}
	}
	
	ASSERT((fCatIDFound && fCtlFlagFound) || 
		   (!fCatIDFound && !fCtlFlagFound), "Typelib control attribute not in sync with CATID_Control setting");

#endif

    hr = S_OK;

CleanUp:
    SysFreeString(bstrTypeLibName);

    return hr;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//	WARNING! You must link with the new version of OLEAUT shipping with
//	         Visual Basic version 5.0 in order for this function to 
//	         work correctly.
//
HRESULT UnregisterAllObjects
(
    void
)
{
    HRESULT hr;
    int x = 0;
    
    char szTmp[MAX_PATH];
    TLIBATTR *ptlibattr = NULL;
    ITypeLib *pTypeLib = NULL;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            UnregisterUnknownObject(CLSIDOFOBJECT(x), NULL);
            break;

          case OI_CONTROL:
            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                    CLSIDOFOBJECT(x));
	    break;
    
          case OI_AUTOMATION:
            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                       CLSIDOFOBJECT(x));
            break;

        }
        x++;
    }

    // if we've got one, unregister our type library 
    if (g_pLibid)
    {
	GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
	MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);

	hr = LoadTypeLibEx(pwsz, REGKIND_NONE, &pTypeLib);
	if (FAILED(hr)) goto CleanUp;

	hr = pTypeLib->GetLibAttr(&ptlibattr);		
	if (FAILED(hr)) goto CleanUp;
	
	// Call OLEAUT to have it unregister our type library.  It will handle
	// the case where there is a 16-bit version of the control's typelib
	// registered and will only blow away the 32-bit related keys in this case.
	//
	UnRegisterTypeLib(*g_pLibid, ptlibattr->wMajorVerNum, ptlibattr->wMinorVerNum, ptlibattr->lcid, ptlibattr->syskind);

    }


CleanUp:
    if (ptlibattr)
	pTypeLib->ReleaseTLibAttr(ptlibattr);
    
    RELEASE_OBJECT(pTypeLib);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\proppage.cpp ===
//=--------------------------------------------------------------------------=
// PropertyPages.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of CPropertyPage object.
//
#include "pch.h"
#include "PropPage.H"

#if defined(VS_HELP) || defined(HTML_HELP)

    #ifdef MS_BUILD
        #include "HtmlHelp.h"
    #else
        #include "HtmlHelp.hxx"
    #endif

    #ifdef VS_HELP
        #include "VSHelp.h"        // Visual Studio html help support
    #endif

#endif

// for ASSERT and FAIL
//
SZTHISFILE



// this variable is used to pass the pointer to the object to the hwnd.
//
static CPropertyPage *s_pLastPageCreated;

//=--------------------------------------------------------------------------=
// CPropertyPage::CPropertyPage
//=--------------------------------------------------------------------------=
// constructor.
//
// Parameters:
//    IUnknown *          - [in] controlling unknown
//    int                 - [in] object type.
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CPropertyPage::CPropertyPage
(
    IUnknown         *pUnkOuter,
    int               iObjectType
)
: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType)
{
    // initialize various dudes.
    //
    m_pPropertyPageSite = NULL;
    m_hwnd = NULL;
    m_cObjects = 0;

    m_fDirty = FALSE;
    m_fActivated = FALSE;
    m_fDeactivating = FALSE;
    m_ppUnkObjects = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CPropertyPage::~CPropertyPage
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CPropertyPage::~CPropertyPage()
{
    // clean up our window.
    //
    if (m_hwnd) {
        SetWindowLong(m_hwnd, GWL_USERDATA, 0xffffffff);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    // release all the objects we're holding on to.
    //
    ReleaseAllObjects();

    // release the site
    //
    RELEASE_OBJECT(m_pPropertyPageSite);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support IPP and IPP2.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CPropertyPage::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) {
        pUnk = (IUnknown *)this;
    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) {
        pUnk = (IUnknown *)this;
    } else {
        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetPageSite    [IPropertyPage]
//=--------------------------------------------------------------------------=
// the initialization function for a property page through which the page
// receives an IPropertyPageSite pointer.
//
// Parameters:
//    IPropertyPageSite *        - [in] new site.
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP CPropertyPage::SetPageSite
(
    IPropertyPageSite *pPropertyPageSite
)
{
    RELEASE_OBJECT(m_pPropertyPageSite);
    m_pPropertyPageSite = pPropertyPageSite;
    ADDREF_OBJECT(pPropertyPageSite);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Activate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to create it's display window as a child of hwndparent
// and to position it according to prc.
//
// Parameters:
//    HWND                - [in]  parent window
//    LPCRECT             - [in]  where to position ourselves
//    BOOL                - [in]  whether we're modal or not.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Activate
(
    HWND    hwndParent,
    LPCRECT prcBounds,
    BOOL    fModal
)
{
    HRESULT hr;

    // first make sure the dialog window is loaded and created.
    //
    hr = EnsureLoaded();
    RETURN_ON_FAILURE(hr);

    // fire off a PPM_NEWOBJECTS now
    //    
	hr = NewObjects();		// Note: m_fDirty is cleared after this call
    RETURN_ON_FAILURE(hr);

    // set our parent window if we haven't done so yet.
    //
    if (!m_fActivated) {
        SetParent(m_hwnd, hwndParent);
        m_fActivated = TRUE;
    }

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);
    ShowWindow(m_hwnd, SW_SHOW);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Deactivate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to destroy the window created in activate
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Deactivate
(
    void
)
{
    HRESULT hr = S_OK;

    m_fDeactivating = TRUE;

    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);
    RETURN_ON_FAILURE(hr);

    // blow away your window.
    //
    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
	    m_hwnd = NULL;
    }

    m_fActivated = FALSE;
    m_fDeactivating = FALSE;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::GetPageInfo    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to fill a PROPPAGEINFO structure
//
// Parameters:
//    PROPPAGEINFO *    - [out] where to put info.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::GetPageInfo
(
    PROPPAGEINFO *pPropPageInfo
)
{
    RECT rect;

    CHECK_POINTER(pPropPageInfo);

    EnsureLoaded();

    // clear it out first.
    //
    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));

    pPropPageInfo->pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType));
    pPropPageInfo->dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType);

    if (!(pPropPageInfo->pszTitle && pPropPageInfo->pszDocString && pPropPageInfo->pszHelpFile))
        goto CleanUp;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (m_hwnd) {
        GetWindowRect(m_hwnd, &rect);

        pPropPageInfo->size.cx = rect.right - rect.left;
        pPropPageInfo->size.cy = rect.bottom - rect.top;
    }

    return S_OK;

  CleanUp:
    if (pPropPageInfo->pszDocString) {
      CoTaskMemFree(pPropPageInfo->pszDocString);
      pPropPageInfo->pszDocString = NULL;
    }
    if (pPropPageInfo->pszHelpFile) {
      CoTaskMemFree(pPropPageInfo->pszHelpFile);
      pPropPageInfo->pszHelpFile = NULL;
    }
    if (pPropPageInfo->pszTitle) {
      CoTaskMemFree(pPropPageInfo->pszTitle);
      pPropPageInfo->pszTitle = NULL;
    }

    return E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetObjects    [IPropertyPage]
//=--------------------------------------------------------------------------=
// provides the page with the objects being affected by the changes.
//
// Parameters:
//    ULONG            - [in] count of objects.
//    IUnknown **      - [in] objects.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::SetObjects
(
    ULONG      cObjects,
    IUnknown **ppUnkObjects
)
{
    HRESULT hr;
    ULONG   x;

    //Vegas 33683 - joejo
    // make sure the old control is updated
    // if page is dirty!
    if (m_fDirty)
        hr = Apply();

    // make sure we've been loaded, and free out any other objects that might
    // have been hanging around
    //
    ReleaseAllObjects();

    if (!cObjects)
        return S_OK;

    // now go and set up the new ones.
    //
    m_ppUnkObjects = (IUnknown **)CtlHeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(m_ppUnkObjects);

    // loop through and copy over all the objects.
    //
    for (x = 0; x < cObjects; x++) {
        m_ppUnkObjects[x] = ppUnkObjects[x];
        ADDREF_OBJECT(m_ppUnkObjects[x]);
    }

    // go and tell the page that there are new objects [but only if it's been
    // activated]
    //
    hr = S_OK;
    m_cObjects = cObjects;
    if (m_fActivated)
        hr = NewObjects();    // Note: m_fDirty is cleared after this call
    
    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Show    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to show or hide its window
//
// Parameters:
//    UINT             - [in] whether to show or hide
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Show
(
    UINT nCmdShow
)
{
    if (m_hwnd)
        ShowWindow(m_hwnd, nCmdShow);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Move    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to relocate and resize itself to a position other than what
// was specified through Activate
//
// Parameters:
//    LPCRECT        - [in] new position and size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Move
(
    LPCRECT prcBounds
)
{
    // do what they sez
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, NULL, prcBounds->left, prcBounds->top,
                     prcBounds->right - prcBounds->left,
                     prcBounds->bottom - prcBounds->top,
                     SWP_NOZORDER);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::IsPageDirty    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page whether it has changed its state
//
// Output
//    S_OK            - yep
//    S_FALSE         - nope
//
// Notes:
//
STDMETHODIMP CPropertyPage::IsPageDirty
(
    void
)
{
    return m_fDirty ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Apply    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to send its changes to all the objects passed through
// SetObjects()
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Apply
(
    void
)
{
    HRESULT hr = S_OK;

    if (m_hwnd) {
        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&hr);
        RETURN_ON_FAILURE(hr);

        if (m_fDirty) {
            m_fDirty = FALSE;

            if (m_pPropertyPageSite && !m_fDeactivating)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    } else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Help    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page that the help button was clicked.
//
// Parameters:
//    LPCOLESTR        - [in] help directory
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Help
(
    LPCOLESTR pszHelpDir        // Note: With VS_HELP set this parameter is ignored
)
{
    char *pszExt;
    char buf[MAX_PATH];
    BOOL f = FALSE;

#ifdef VS_HELP
    BOOL bHelpStarted;
    HRESULT hr;
#endif

    ASSERT(m_hwnd, "CPropertyPage::Help called with no hwnd!");

    pszExt = FileExtension(HELPFILEOFPROPPAGE(m_ObjectType));
    if (pszExt)
    {

    #ifdef VS_HELP
    #else
    #endif

    #if defined(VS_HELP) || defined(HTML_HELP)
    
        if (lstrcmpi(pszExt, "CHM") == 0)
        {

        #ifdef VS_HELP

            lstrcpy(buf, HELPFILEOFPROPPAGE(m_ObjectType));

            // First try to show help through VisualStudio
            //
            hr = VisualStudioShowHelpTopic(buf, HELPCONTEXTOFPROPPAGE(m_ObjectType), &bHelpStarted);
            f = SUCCEEDED(hr);

            // Check to see if Visual Studio help could be successfully started.  If not,
            // assume it doesn't exist
            //
            if (!bHelpStarted)
        
        #endif

            {        
                MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
                lstrcpy(buf, psz);
                lstrcat(buf, "\\");
                lstrcat(buf, HELPFILEOFPROPPAGE(m_ObjectType));

                // Show the help topic manually by calling HtmlHelp directly
                //
                f = (BOOL) HtmlHelp(m_hwnd, buf, HH_HELP_CONTEXT, 
                            HELPCONTEXTOFPROPPAGE(m_ObjectType));            
            }

        #ifdef VS_HELP

            else
            {
                ASSERT(SUCCEEDED(hr), "Failed to show help topic from Visual Studio");
            }

        #endif

        }

        else if (lstrcmpi(pszExt, "HLP") == 0)
    
    #endif

        {
            // WinHelp

            // get the helpfile name
            //
            MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
            lstrcpy(buf, psz);
            lstrcat(buf, "\\");
            lstrcat(buf, HELPFILEOFPROPPAGE(m_ObjectType));

            lstrcat(buf, ">LangRef");				// Use LangRef window style
            f = WinHelp(m_hwnd, buf, HELP_CONTEXT,
                        HELPCONTEXTOFPROPPAGE(m_ObjectType));
        }        

    #if defined(VS_HELP) || defined(HTML_HELP)

        else
        {
            FAIL("Unrecognized help file type");
        }

    #endif

    }


    return f ? S_OK : E_FAIL;
}

static BOOL IsLastTabItem(HWND hdlg, HWND hctl, UINT nCmd)
{
    if ((SendMessage(hdlg, WM_GETDLGCODE, 0, 0L) &
     (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
    {
        // Get top level child for controls with children, like combo.
        //	        
        HWND hwnd;
        for (/**/; hctl != hdlg; hctl = GetParent(hctl))
            hwnd = hctl;

        // Walk the zorder list until we reached the end
        // or until we get to a valid tab item
        //
        do
        {
	        if ((hwnd = GetWindow(hwnd, nCmd)) == NULL)
		        return TRUE;
        }
        while ((GetWindowLong(hwnd, GWL_STYLE) & (WS_DISABLED|WS_TABSTOP|WS_VISIBLE)) != (WS_TABSTOP|WS_VISIBLE));
	}
    return FALSE;
}


//=--------------------------------------------------------------------------=
// CPropertyPage::TranslateAccelerator    [IPropertyPage]
//=--------------------------------------------------------------------------=
// informs the page of keyboard events, allowing it to implement it's own
// keyboard interface.
//
// Parameters:
//    LPMSG            - [in] message that triggered this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::TranslateAccelerator
(
    LPMSG pmsg
)
{
    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?");
    CHECK_POINTER(pmsg);

    BOOL fHandled = FALSE;
    HWND hctl;

    // Special consideration for the Return and Escape keys.
    //
    if ((pmsg->message == WM_KEYDOWN) &&
        ((pmsg->wParam == VK_RETURN) || (pmsg->wParam == VK_ESCAPE))) {

        // Always let the frame handle the Escape key, but if we have the
        // Return key, then we need to ask the focus control if it wants it.
        // Usually, controls that want the Return key will return DLGC_WANTALLKEYS
        // when they process WM_GETDLGCODE.  This is the case when an
        // Edit or RichEdit control has the ES_MULTILINE style
        //
        if (VK_RETURN == pmsg->wParam && m_hwnd != pmsg->hwnd
         && (SendMessage(pmsg->hwnd, WM_GETDLGCODE, 0, 0L) & DLGC_WANTALLKEYS)) {

            // Pass the Return key on as a WM_CHAR, because
            // this is what TranslateMessage will do for a
            // WM_KEYDOWN
            //
            // If a control does not process this message, then
            // it should return non-zero, in which case we can
            // pass it on to the Frame
            //
            fHandled = !SendMessage(pmsg->hwnd, WM_CHAR, pmsg->wParam, pmsg->lParam);
        }

        // If the message was not handled, then let the 
        // Frame handle this message, but we need to change
        // the window handle to that of the propage.
        // This needs to be done because edit controls
        // with ES_WANTRETURN will return DLGC_WANTALLKEYS,
        // which will cause the Frame not to handle the Escape key
        // 
        return fHandled ? S_OK : (pmsg->hwnd = m_hwnd, S_FALSE);
    }

    if (pmsg->message == WM_KEYDOWN && pmsg->wParam == VK_TAB && GetKeyState(VK_CONTROL) >= 0) {
        // If we already have the focus.  Let's determine whether we should
        // pass focus up to the frame.
        //
        if (IsChild(m_hwnd, pmsg->hwnd)) {
            // Fix for default button border
            //
            DWORD dwDefID = SendMessage(m_hwnd, DM_GETDEFID, 0, 0);
            if (HIWORD(dwDefID) == DC_HASDEFID) {
                hctl = GetDlgItem(m_hwnd, LOWORD(dwDefID));
                if (NULL != hctl && IsWindowEnabled(hctl))
                    SendMessage(m_hwnd, WM_NEXTDLGCTL, (WPARAM)hctl, 1L);
            }
            // If the focus control is the last the the tab order
            // then we will pass the message to the frame
            //
            if (IsLastTabItem(m_hwnd, pmsg->hwnd, GetKeyState(VK_SHIFT) < 0 ?
             GW_HWNDPREV : GW_HWNDNEXT)) {
	            // Pass focus to the frame by letting the page site handle
                // this message.
                if (NULL != m_pPropertyPageSite)
                    fHandled = m_pPropertyPageSite->TranslateAccelerator(pmsg) == S_OK;
            }

        } else {

            // We don't already have the focus.  The frame is passing the
            // focus to us.
            //
            hctl = GetNextDlgTabItem(m_hwnd, NULL, GetKeyState(VK_SHIFT) < 0);
            if (NULL != hctl)
                fHandled = (BOOL)SendMessage(m_hwnd, WM_NEXTDLGCTL, (WPARAM)hctl, 1L);
        }            
    }

    // just pass this message on to the dialog proc and see if they want it.
    //
    // just pass this message on to the dialog proc and see if they want it.
    //
    if (FALSE == fHandled) {
        // In order for accelerators to work properly, we need to
        // temporarily replace the message window handle to that
        // of the first child in the property page in response
        // to a WM_SYSKEYDOWN.  This will allow the user to use an
        // accelerator key to go from a tab to a control on the 
        // active page.
        //
        hctl = pmsg->hwnd;
        if (WM_SYSKEYDOWN == pmsg->message && !IsChild(m_hwnd, pmsg->hwnd))
            pmsg->hwnd = GetWindow(m_hwnd, GW_CHILD);

        fHandled = IsDialogMessage(m_hwnd, pmsg);
        pmsg->hwnd = hctl;
    }

    return fHandled ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EditProperty    [IPropertyPage2]
//=--------------------------------------------------------------------------=
// instructs the page to set the focus to the property matching the dispid.
//
// Parameters:
//    DISPID            - [in] dispid of property to set focus to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::EditProperty
(
    DISPID dispid
)
{
    HRESULT hr = E_NOTIMPL;

    // send the message on to the control, and see what they want to do with it.
    //
    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EnsureLoaded
//=--------------------------------------------------------------------------=
// makes sure the dialog is actually loaded
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CPropertyPage::EnsureLoaded
(
    void
)
{
    HRESULT hr = S_OK;
    HRSRC hrsrc;
    HGLOBAL hDlg;
    LPCDLGTEMPLATE pDlg;
    HWND hwndDlg;

    // duh
    //
    if (m_hwnd)
        return S_OK;

    // create the dialog window
    //
    hrsrc = FindResource(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), RT_DIALOG);
    ASSERT(hrsrc, "Failed to find dialog template");
    if (!hrsrc) 
	return HRESULT_FROM_WIN32(GetLastError());
        
    hDlg = LoadResource(GetResourceHandle(), hrsrc);
    ASSERT(hDlg, "Failed to load dialog resource");
    if (!hDlg)
	return HRESULT_FROM_WIN32(GetLastError()); 

    pDlg = (LPCDLGTEMPLATE) LockResource(hDlg);
    ASSERT(pDlg, "Failed to lock dialog resource");
    if (!pDlg)
	return HRESULT_FROM_WIN32(GetLastError()); 
    
    // set up the global variable so that when we're in the dialog proc, we can
    // stuff this in the hwnd
    //
    // crit sect this whole creation process for apartment threading support.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    s_pLastPageCreated = this;

    // Why not call CreateDialog instead?  The answer is that the property page
    // dialog resource may contain Windows custom controls where the window proc for the
    // Windows control resides in your control DLL (e.g., .OCX file), not the 
    // satellite DLL.  If CreateDialog calls CreateWindow to create your Windows custom control 
    // with a different instance than where the window class for the control is 
    // registered, it will fail.
    //
    hwndDlg = CreateDialogIndirect(g_hInstance, pDlg, GetParkingWindow(),
                          CPropertyPage::PropPageDlgProc);

    ASSERT(hwndDlg, "Couldn't load Dialog Resource!!!");
    ASSERT(hwndDlg == m_hwnd, "Returned hwnd doesn't match cached hwnd");

    // clean up variables and leave the critical section
    //
    s_pLastPageCreated = NULL;
    LEAVECRITICALSECTION1(&g_CriticalSection);

    if (!m_hwnd)     
        return HRESULT_FROM_WIN32(GetLastError());    

#if 0
    // go and notify the window that it should pick up any objects that are
    // available
    //
    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);
#endif  // 0

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::ReleaseAllObjects
//=--------------------------------------------------------------------------=
// releases all the objects that we're working with
//
// Notes:
//
void CPropertyPage::ReleaseAllObjects
(
    void
)
{
    HRESULT hr;
    UINT x;

    // some people will want to stash pointers in the PPM_INITOBJECTS case, so
    // we want to tell them to release them now.
    //
    if (m_fActivated && m_hwnd)
        SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);

    if (!m_cObjects) return;
    // loop through and blow them all away.
    //
    for (x = 0; x < m_cObjects; x++)
        QUICK_RELEASE(m_ppUnkObjects[x]);

    CtlHeapFree(g_hHeap, 0, m_ppUnkObjects);
    m_ppUnkObjects = NULL;
    m_cObjects = 0;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::PropPageDlgProc
//=--------------------------------------------------------------------------=
// static global helper dialog proc that gets called before we pass the message
// on to anybody ..
//
// Parameters:
//    - see win32sdk docs on DialogProc
//
// Notes:
//
INT_PTR CALLBACK CPropertyPage::PropPageDlgProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CPropertyPage *pPropertyPage;

    // get the window long, and see if it's been set to the object this hwnd
    // is operating against.  if not, go and set it now.
    //
    pPropertyPage = (CPropertyPage *)GetWindowLong(hwnd, GWL_USERDATA);
    if ((ULONG)pPropertyPage == 0xffffffff)
        return FALSE;
    if (!pPropertyPage) {
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)s_pLastPageCreated);
        pPropertyPage = s_pLastPageCreated;
        pPropertyPage->m_hwnd = hwnd;
    }

    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!");

    // just call the user dialog proc and see if they want to do anything.
    //
    return pPropertyPage->DialogProc(hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// CPropertyPage::FirstControl
//=--------------------------------------------------------------------------=
// returns the first controlish object that we are showing ourselves for.
// returns a cookie that must be passed in for Next ...
//
// Parameters:
//    DWORD *    - [out] cookie to be used for Next
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::FirstControl
(
    DWORD *pdwCookie
)
{
    // just use the implementation of NEXT.
    //
    *pdwCookie = 0;
    return NextControl(pdwCookie);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NextControl
//=--------------------------------------------------------------------------=
// returns the next control in the chain of people to work with given a cookie
//
// Parameters:
//    DWORD *            - [in/out] cookie to get next from, and new cookie.
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::NextControl
(
    DWORD *pdwCookie
)
{
    UINT      i;

    // go looking through all the objects that we've got, and find the
    // first non-null one.
    //
    for (i = *pdwCookie; i < m_cObjects; i++) {
        if (!m_ppUnkObjects[i]) continue;

        *pdwCookie = i + 1;                // + 1 so we start at next item next time
        return m_ppUnkObjects[i];
    }

    // couldn't find it .
    //
    *pdwCookie = 0xffffffff;
    return NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NewObjects    [helper]
//=--------------------------------------------------------------------------=
// Sends PPM_NEWOBJECTS message to the property page dialog, so that
// it can initialize its dialog fields.
//
// Notes:
//
HRESULT CPropertyPage::NewObjects()
{
	HRESULT hr = S_OK;
	SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM) &hr);

	// Clear the dirty bit and make sure the Apply button gets disabled.
	//
	if (m_fDirty)
	{
		m_fDirty = FALSE;
        
        ASSERT(m_fDeactivating == FALSE, "We're being deactivated?");
		if (m_pPropertyPageSite)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);        
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::MakeDirty    [helper, callable]
//=--------------------------------------------------------------------------=
// marks a page as dirty.
//
// Notes:
//
void CPropertyPage::MakeDirty
(
    void
)
{
    m_fDirty = TRUE;
    
    // Need to make sure we have a page site and we're not being deactivated
    // IE 4.0 will crash if we attempt to call OnStatusChange while we're being
    // deactivated
    //
    if (m_pPropertyPageSite && !m_fDeactivating)
        m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
}


// from Globals.C
//
extern HINSTANCE g_hInstResources;


//=--------------------------------------------------------------------------=
// CPropertyPage::GetResourceHandle    [helper, callable]
//=--------------------------------------------------------------------------=
// returns current resource handle, based on pagesites ambient LCID.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CPropertyPage::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // enter a critical section for g_lcidLocale and g_fHavelocale
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fHaveLocale) {
        if (m_pPropertyPageSite) {
            m_pPropertyPageSite->GetLocaleID(&g_lcidLocale);
            g_fHaveLocale = TRUE;
        }
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StandardEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//
#include "pch.h"
#include "StdEnum.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//            none
//
// Notes: This default constructor only exists so that derived classes can be created
//        Internal debug checks have been added to confirm that internal
//        state is correctly set before use (calls to Next, Skip, etc)
//        
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum()
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(IID_IUnknown),
  m_cElements(0),
  m_cbElementSize(0),
  m_iCurrent(0),
  m_rgElements(NULL),
  m_pfnCopyElement(NULL)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
        if (m_rgElements) CtlHeapFree(g_hHeap, 0, m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    	
    if (DO_GUIDS_MATCH(riid, m_iid) || DO_GUIDS_MATCH(riid, IID_IUnknown)) 
    {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
	ASSERT(m_pfnCopyElement, "NULL m_pfnCopyElement is invalid CStandardEnum state!");

    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
	ASSERT(m_pfnCopyElement, "NULL m_pfnCopyElement is invalid CStandardEnum state!");

    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
	ASSERT(m_pfnCopyElement, "NULL m_pfnCopyElement is invalid CStandardEnum state!");

    CStandardEnum *pNewEnum;

    *ppEnumClone = NULL;

    pNewEnum = New CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;
    pNewEnum->m_iCurrent = m_iCurrent;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\strcoll.cpp ===
//=--------------------------------------------------------------------------=
// StringsColl.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for our simple strings collections.
//
#include "pch.h"

#include "SimpleEnumVar.H"
#include "StringsColl.H"


// for asserts
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// CStringsCollection::CStringsCollection
//=--------------------------------------------------------------------------=
// constructor. sets up the safearray pointer.
//
// Parameters:
//    SAFEARRAY        - [in] the collection we're working with.
//
// Notes:
//
CStringCollection::CStringCollection
(
    SAFEARRAY *psa
)
: m_psa(psa)
{
    ASSERT(m_psa, "Bogus Safearray pointer!");
}

//=--------------------------------------------------------------------------=
// CStringCollection::~CStringCollection
//=--------------------------------------------------------------------------=
//
// Notes:
//
CStringCollection::~CStringCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Count
//=--------------------------------------------------------------------------=
// returns the count of the things in the collection
//
// Parameters:
//    long *         - [out] the count
//
// Output:
//    HRESULT        - S_OK, one of the SAFEARRAY Scodes.
//
// Notes:
//    - we're assuming the safearray's lower bound is zero!
//
STDMETHODIMP CStringCollection::get_Count
(
    long *plCount
)
{
    HRESULT hr;

    ASSERT(m_psa, "Who created a collection without a SAFEARRAY?");

    CHECK_POINTER(plCount);

    // get the bounds.
    //
    hr = SafeArrayGetUBound(m_psa, 1, plCount);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // add one since we're zero-offset
    //
    (*plCount)++;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Item
//=--------------------------------------------------------------------------=
// returns a string given an INDEX
//
// Parameters:
//    long          - [in]  the index to get it from
//    BSTR *        - [out] the item
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get_Item
(
    long  lIndex,
    BSTR *pbstrItem
)
{
    HRESULT hr;

    CHECK_POINTER(pbstrItem);

    // get the element from the safearray
    //
    hr = SafeArrayGetElement(m_psa, &lIndex, pbstrItem);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // otherwise, we've got it, so we can return
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get__NewEnum
//=--------------------------------------------------------------------------=
// returns a new IEnumVARIANT object with the collection in it.
//
// Parameters:
//    IUnknown     **    - [out] new enumvariant object.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get__NewEnum
(
    IUnknown **ppUnkNewEnum
)
{
    HRESULT hr;
    long    l;

    CHECK_POINTER(ppUnkNewEnum);

    // get the count of things in the SAFEARRAY
    //
    hr = get_Count(&l);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // create the object.
    //
    *ppUnkNewEnum = (IUnknown *) new CSimpleEnumVariant(m_psa, l);
    if (!*ppUnkNewEnum)
        CLEARERRORINFORET(E_OUTOFMEMORY);

    // refcount is already 1, so we can leave.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// CStringDynaCollection::CStringDynaCollection
//=--------------------------------------------------------------------------=
// constructor for this object.  doesn't do very much.
//
// Parameters:
//    same as for CStringCollection
//
// Notes:
//
CStringDynaCollection::CStringDynaCollection
(
    SAFEARRAY *psa
)
: CStringCollection(psa)
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::~CStringDynaCollection
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CStringDynaCollection::~CStringDynaCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::put_Item
//=--------------------------------------------------------------------------=
// sets the value of an item in the array.
//
// Parameters:
//    long         - [in] index at which to put it
//    BSTR         - [in] new value.
//
// Output:
//    HRESULT      - S_OK, safearray Scode.
//
// Notes:
//    - NULLs are converted to ""
//
STDMETHODIMP CStringDynaCollection::put_Item
(
    long lIndex,
    BSTR bstr
)
{
    HRESULT hr;
    long l;
    BSTR bstr2 = NULL;

    // get the count and verify our index
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);
    if (lIndex < 0 || lIndex >= l)
        CLEARERRORINFORET(E_INVALIDARG);
    
    // put out the string, convert NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &lIndex, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Add
//=--------------------------------------------------------------------------=
// adds a new string to the end of the collection.
//
// Parameters:
//    BSTR         - [in] the new string to add
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Add
(
    BSTR bstr
)
{
    SAFEARRAYBOUND sab;
    BSTR    bstr2 = NULL;
    HRESULT hr;
    long    l;

    // get the current size of the array.
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);

    // add one new elemnt
    //
    sab.cElements = l + 1;
    sab.lLbound = 0;

    // redim the array.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // put the out string, converting NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &l, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Remove
//=--------------------------------------------------------------------------=
// removes an element from the collection, and shuffles all the rest down to
// fill up the space.
//
// Parameters:
//    long         - [in] index of dude to remove.
//
// Output:
//    HRESULT      - S_OK, safearray Scodes.
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Remove
(
    long lIndex
)
{
    SAFEARRAYBOUND sab;
    HRESULT hr;
    BSTR    bstr;
    long    lCount;
    long    x, y;

    // first get the count of things in our array.
    //
    hr = get_Count(&lCount);
    RETURN_ON_FAILURE(hr);

    // check the index
    //
    if (lIndex < 0 || lIndex >= lCount)
        CLEARERRORINFORET(E_INVALIDARG);

    // let's go through, shuffling everything down one.
    //
    for (x = lIndex, y = x + 1; x < lCount - 1; x++, y++) {
        // get the next element.
        //
        hr = SafeArrayGetElement(m_psa, &y, &bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);

        // set it at the current location
        //
        hr = SafeArrayPutElement(m_psa, &x, bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);
    }

    // we're at the last element.  let's go and kill it.
    //
    sab.cElements = lCount - 1;
    sab.lLbound = 0;

    // CONSIDER: 9.95 -- there is a bug in oleaut32.dll which causes the
    //         below to fail if cElements = 0.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // we're done.  go bye-bye.
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\adbind.h ===
//=--------------------------------------------------------------------------=
//
// adbind.h	Microsoft Active Data Binding interfaces
//
//              Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
//=--------------------------------------------------------------------------=
#ifndef _ADBIND_H_
#define _ADBIND_H_

#include "oledb.h"

DEFINE_GUID(IID_IDataFormat, 0xaf08b280, 0x90f2, 0x11d0,0x94, 0x84, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

//=--------------------------------------------------------------------------=
// IDataFormat interface
//=--------------------------------------------------------------------------=
#undef  INTERFACE
#define INTERFACE IID_IDataFormat

// The following are used with IDataFormat::GetBinding
#define DATAFORMAT_FGETDATA	0x0   // Return a SetData binding
#define DATAFORMAT_FSETDATA	0x1   // Return a GetData binding

DECLARE_INTERFACE_(IDataFormat, IUnknown)
{
  STDMETHOD(GetBinding)(VARTYPE vtPropHint, DWORD rgfDataFormat, IUnknown* prowset, DBCOLUMNINFO* pcolinfo, DBBINDING* pbinding, ULONG* pcbSize, DWORD* pdwCookie) PURE;
  STDMETHOD(GetData)(DWORD dwCookie, void* pvFrom, VARIANT* pvarTo, DBSTATUS* pdbstatus, IDispatch* pdispObject) PURE;
  STDMETHOD(SetData)(DWORD dwCookie, VARIANT* pvarFrom, void* pvTo, IDispatch* pdispObject) PURE;
  STDMETHOD(ReleaseData)(DWORD dwCookie, void* pv) PURE;
  STDMETHOD(ReleaseBinding)(DWORD dwCookie) PURE;
  STDMETHOD(GetRawData)(DWORD dwCookie, void *pvFrom, VARIANT *pvarTo, DBSTATUS *pdbstatus) PURE;
  STDMETHOD(SetRawData)(DWORD dwCookie, VARIANT *pvarFrom, void *pvTo) PURE;
  STDMETHOD(Clone)(IDataFormat **ppDataFormat) PURE;
  STDMETHOD(Convert)(DWORD dwCookie, const VARIANT *pvarFrom, VARIANT *pvarTo) PURE;
  STDMETHOD(SetLcid)(LCID lcid) PURE;
  STDMETHOD(Default)(BOOL *fDefault) PURE;
  STDMETHOD(GetLcid)(LCID *lcid) PURE;
};

#endif // _ADBIND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\unknown.cpp ===
//=--------------------------------------------------------------------------=
// Unknown.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for various things in the unknown object that supports
// aggregation.
//
#include "pch.h"
#include "Unknown.H"
#include <stddef.h>

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    CHECK_POINTER(ppvObjOut);

    // if they're asking for IUnknown, then we have to pass them ourselves.
    // otherwise defer to the inheriting object's InternalQueryInterface
    //
    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        m_cRef++;
        *ppvObjOut = (IUnknown *)this;
        return S_OK;
    } else
        return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

    // dead code    
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::Release
(
    void
)
{
    // are we just about to go away?
    //
    if (1 == m_cRef) {

        // if we are, then we want to let the user know about it, so they can
        // free things up before their vtables go away.  the extra ref here
        // makes sure that if they addref/release something, they don't cause
        // the current code to get tripped again
        //
        m_cRef++;
        m_pMainUnknown()->BeforeDestroyObject();
        ASSERT(m_cRef == 2, "ctl has Ref Count problem!!");

        m_cRef  = 0; // so people can be sure of this in the destructor
        delete m_pMainUnknown();
        return 0;
    }

    return --m_cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CUnknownObject::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::BeforeDestroyObject
//=--------------------------------------------------------------------------=
// called just as we are about to trash an object
//
// Notes:
//
void CUnknownObject::BeforeDestroyObject
(
    void
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\vshelp.cpp ===
//=--------------------------------------------------------------------------=
// HtmlHlp.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "pch.h"
#include "VsHelp.h"

SZTHISFILE

#ifdef VS_HELP

IVsHelpSystem *g_pIVsHelpSystem = NULL;

//=--------------------------------------------------------------------------=
// QueryStartupVisualStudioHelp [HtmlHelp helper]
//=--------------------------------------------------------------------------=
// Starts up Visual Studio help system 
//
HRESULT QueryStartupVisualStudioHelp(IVsHelpSystem **ppIVsHelpSystem)
{    
 
    CHECK_POINTER(ppIVsHelpSystem);
    
    HRESULT hr = S_OK;    
    IVsHelpInit *pIVSHelpInit = NULL;

    ENTERCRITICALSECTION1(&g_CriticalSection);

    // Check to see if we're already started.  If so, no need to continue
    //
    if (g_pIVsHelpSystem)
    {
        goto CleanUp;
    }    

    // Create an instance of the VsHelpServices package, if not already created
    //
    hr = ::CoCreateInstance(CLSID_VsHelpServices,
                            NULL, 
                            CLSCTX_INPROC_SERVER,
                            IID_IVsHelpSystem,
                            (void**) &g_pIVsHelpSystem) ; 

    if (FAILED(hr))
    {
        goto CleanUp;
    }

    ASSERT(g_pIVsHelpSystem, "g_pIVsHelpSystem is NULL even though hr was successful");
    if (!g_pIVsHelpSystem)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    //--- Initialize the help system.

    // Get the init interface pointer.
    //
    hr = g_pIVsHelpSystem->QueryInterface(IID_IVsHelpInit, (void**)&pIVSHelpInit);
    ASSERT(SUCCEEDED(hr), "QI to IVSHelpInit failed -- continuing anyway");
  
    if (SUCCEEDED(hr))
    {
        hr = pIVSHelpInit->LoadUIResources(g_lcidLocale);
        ASSERT(SUCCEEDED(hr), "LoadUIResources() failed (this will happen if you haven't run MSDN setup) -- continuing anyway");
    }

    hr = S_OK;

CleanUp:

    LEAVECRITICALSECTION1(&g_CriticalSection);

    QUICK_RELEASE(pIVSHelpInit);

    if (SUCCEEDED(hr))
    {
        g_pIVsHelpSystem->AddRef();
        *ppIVsHelpSystem = g_pIVsHelpSystem;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// VisualStudioShowHelpTopic [HtmlHelp helper]
//=--------------------------------------------------------------------------=
// Displays the help topic in Visual Studio's help window
//
HRESULT VisualStudioShowHelpTopic(const char *pszHelpFile, DWORD dwContextId, BOOL *pbHelpStarted)
{
    HRESULT hr;
    IVsHelpSystem* pIVsHelpSystem = NULL;
    BSTR bstrHelpFile;

    // Hand back help started to signify that we were able to start the help 
    // system.  This is useful since the controls have no clue as to what 
    // environment they are running under Visual Studio might not be around 
    // in which case the control will call HtmlHelp directly.
    //
    if (pbHelpStarted)
        *pbHelpStarted = FALSE;

    hr = QueryStartupVisualStudioHelp(&pIVsHelpSystem);
    if (FAILED(hr))    
        return hr;

    ASSERT(pIVsHelpSystem, "QI succeeded but return value is NULL");

    hr = pIVsHelpSystem->ActivateHelpSystem(0);
    ASSERT(SUCCEEDED(hr), "Failed to activate the help system");
    if (FAILED(hr))
        goto CleanUp;
    
    // With the help system successfully activated, signify to the caller 
    // that the Visual Studio help mechanism should work
    //
    if (pbHelpStarted)
        *pbHelpStarted = TRUE;
    
    bstrHelpFile = BSTRFROMANSI(pszHelpFile);
    ASSERT(bstrHelpFile, "Out of memory allocating BSTR");

    hr = pIVsHelpSystem->DisplayTopicFromIdentifier(bstrHelpFile, dwContextId, VHS_Localize);
    SysFreeString(bstrHelpFile);

    ASSERT(SUCCEEDED(hr), "Failed to display help topic");
    if (FAILED(hr))
        goto CleanUp;

CleanUp:
    QUICK_RELEASE(pIVsHelpSystem);

    return hr;   
}

#endif // VS_HELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\framewrk\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "pch.h"

#include <comcat.h>

// for ASSERT and FAIL
//
SZTHISFILE

BOOL g_bDllVerChecked = FALSE;

// VERSION.DLL functions
//
HINSTANCE g_hinstVersion = NULL;
PVERQUERYVALUE g_pVerQueryValue = NULL;
PGETFILEVERSIONINFO g_pGetFileVersionInfo = NULL;
PGETFILEVERSIONINFOSIZE g_pGetFileVersionInfoSize = NULL;

// temporary until we get an updated ComCat.H
//
EXTERN_C const CATID CATID_SimpleFrameControl = {0xD40C2700,0xFFA1,0x11cf,{0x82,0x34,0x00,0xaa,0x00,0xC1,0xAB,0x85}};

// These are externals for registering the control CATID's
extern const CATID *g_rgCATIDImplemented[];
extern const CATID *g_rgCATIDRequired[];
extern const int g_ctCATIDImplemented;
extern const int g_ctCATIDRequired;

#define CATID_ARRAY_SIZE 10

//=---------------------------------------------------------------------------=
// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(short),          // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

#ifndef MDAC_BUILD

    //=---------------------------------------------------------------------------=
    // overloaded new
    //=---------------------------------------------------------------------------=
    //
    // Please use New instead of new by inheriting from the class CtlNewDelete 
    // in Macros.H
    //
    inline void * _cdecl operator new
    (
        size_t    size
    )
    {
      if (!g_hHeap)
		    {
		    g_hHeap = GetProcessHeap();
		    return g_hHeap ? CtlHeapAlloc(g_hHeap, 0, size) : NULL;
		    }

      return CtlHeapAlloc(g_hHeap, 0, size);
    }

    //=---------------------------------------------------------------------------=
    // overloaded delete
    //=---------------------------------------------------------------------------=
    // retail case just uses win32 Local* heap mgmt functions
    //
    // Parameters:
    //    void *        - [in] free me!
    //
    // Notes:
    //
    void _cdecl operator delete ( void *ptr)
    {
        if (ptr)
          CtlHeapFree(g_hHeap, 0, ptr);
    }

#endif

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1, 
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], 
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCSTR   pszObjectName,
    LPCSTR   pszLabelName,
    REFCLSID riidObject,
    BOOL     fAptThreadSafe
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //

    // If someone has added Implemented Categories for our control, then
    // don't blow away the entire CLSID section as we will blow away
    // these keys.  Ideally we should clean up all other keys, but 
    // implemented categories, but this would be expensive.
    //
    if (!ExistImplementedCategories(riidObject))
	// clean out any garbage
	//
	UnregisterUnknownObject(riidObject, NULL);

    if (!StringFromGuidA(riidObject, szGuidStr)) 
	goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!pszLabelName)
	wsprintf(szScratch, "%s Object", pszObjectName);	        
    else 
        lstrcpy(szScratch, pszLabelName);

    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);

    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    if (fAptThreadSafe)
    {
	l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
	CLEANUP_ON_ERROR(l);
    }
    else
    {
        // Blow away any existing key that would say we're Apartment model threaded
        //
	RegDeleteValue(hkSub, "ThreadingModel");    
    }

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Object Version Number
//    long         - [in] typelib major ver
//    long         - [in] typelib minor ver
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//
BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    LPCSTR   pszLabelName,
    long     lVersion,
    long     lTLMajor,
    long     lTLMinor,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    BOOL     fAptThreadSafe
)
{
    ICatRegister *pCatRegister;
    HRESULT hr;
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // This is a warning assert.  If you've tripped this, then your current component 
    // is within VERSION_DELTA versions of exceeding MAX_VERSION.  Consider bumping up MAX_VERSION 
    // or change the delta to a smaller number.  Reasonable settings for these
    // depend on how often you do a major version change of your component.
    //
    ASSERT(MAX_VERSION > VERSION_DELTA, "The MAX_VERSION setting is not in line with what we expect it to be.");
    ASSERT(lVersion <= MAX_VERSION - VERSION_DELTA, "Version number of component is approaching or exceeds limit of checked range.  Consider increasing MAX_VERSION value.");

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, pszLabelName, riidObject, fAptThreadSafe)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    lstrcpy(szScratch, pszLibName);
    lstrcat(szScratch, ".");
    lstrcat(szScratch, pszObjectName);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!pszLabelName)
	wsprintf(szScratch, "%s Object", pszObjectName);
    else
        lstrcpy(szScratch, pszLabelName);

    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    ASSERT(pszObjectName, "Object name is NULL");
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!pszLabelName)
	wsprintf(szScratch, "%s Object", pszObjectName);
    else
	lstrcpy(szScratch, pszLabelName);

    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = "<TLMajor>.<TLMinor>"
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%ld.%ld", lTLMajor, lTLMinor);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);

    // now, finally, register ourselves with component categories
    //
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ICatRegister,
                          (void **)&pCatRegister);
    if (SUCCEEDED(hr)) {
        pCatRegister->RegisterClassImplCategories(riidObject, 1,
                                                  (GUID *)&CATID_Programmable);
        pCatRegister->Release();
    }

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Object Major Version Number
//    long         - [in] Object Minor Vesrion Number
//    long         - [in] TypeLib Major Version Number
//    long         - [in] Typelib minor version number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//	  BOOL	       - [in] Apartment thread safe flag
//	  BOOL		   - [in] Control bit:Flag to tell whether to add the Control key or not.
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    LPCSTR   pszLabelName,
    long     lMajorVersion,
    long     lMinorVersion,
    long     lTLMajor,
    long     lTLMinor,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId,
    BOOL     fAptThreadSafe,
	BOOL	 fControl
)
{
    ICatRegister *pCatRegister;
    HRESULT hr;
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    CATID   rgCatid[CATID_ARRAY_SIZE];
    LONG    l;

    // first register all the automation information for this sucker.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, pszLabelName, lMajorVersion, lTLMajor, lTLMinor, riidLibrary, riidObject, fAptThreadSafe)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
	if (fControl)
	{
		l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
		CLEANUP_ON_ERROR(l);
		RegCloseKey(hkSub);
		hkSub = NULL;
	}

    // now set up the MiscStatus Bits...
    //       
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    hkSub = NULL; 

	// Don't need Toolbox bitmap for designers and other non-controls
	//
	if (fControl)
	{
		// now set up the toolbox bitmap
		//
		GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
		wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
		lstrcat(szTmp, szGuidStr);

		l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
		CLEANUP_ON_ERROR(l);

		l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
		CLEANUP_ON_ERROR(l);
	}

    // now, finally, register ourselves with component categories
    //
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ICatRegister,
                          (void **)&pCatRegister);
    if (SUCCEEDED(hr)) {
      int iCounter;

      ASSERT(g_ctCATIDImplemented <= CATID_ARRAY_SIZE  &&  
             g_ctCATIDRequired <= CATID_ARRAY_SIZE,
             "Array for CATID's is too small.  Need to adjust.");

      // Register all the implemented CATID's of the control.
      if(g_ctCATIDImplemented > 0)
      {
        for(iCounter = 0;  iCounter < g_ctCATIDImplemented  && 
                           iCounter < CATID_ARRAY_SIZE;  iCounter++)
          memcpy(&(rgCatid[iCounter]), g_rgCATIDImplemented[iCounter], sizeof(CATID));

        pCatRegister->RegisterClassImplCategories(riidObject, 
                                                  g_ctCATIDImplemented, 
                                                  (GUID *)rgCatid);
      } //if

      // Register all the Required CATID's of the control.
      if(g_ctCATIDRequired > 0)
      {
        for(iCounter = 0;  iCounter < g_ctCATIDRequired  &&
                           iCounter < CATID_ARRAY_SIZE;  iCounter++)
          memcpy(&(rgCatid[iCounter]), g_rgCATIDRequired[iCounter], sizeof(CATID));

        pCatRegister->RegisterClassReqCategories(riidObject, 
                                                 g_ctCATIDRequired,
                                                 (GUID *)rgCatid);
      } //if

        pCatRegister->Release();
    }

  CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//    BOOL	   - [out] Returns TRUE if all keys were deleted for the 
//			   given CLSID.  Returns FALSE if only the
//			   InprocServer32 key or no keys were deleted.
//			   The caller can pass NULL if they don't care
//			   about what set of keys were removed.
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//	WARNING! This routine assumes that all framework built components
//		 and their predessors are in-process server 32-bit DLLs.
//               If other server types exist for control's CLSID
//		 the CLSID entry will be blown away for these server types.
//
//		 If the framework and the control are built as 16-bit components
//	         and you unregister the control, the information will be left
//	         in the registry.  You're on your own to make this work for 16-bit.
//
//		 This routine *only* preserves the CLSID section if
//		 a 16-bit InprocServer key is found.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject,
    BOOL *pfAllRemoved
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // Start on the assumption that we are going to blow away the entire section
    // for the given CLSID.  If this turns out to be a false assumption we'll
    // reset this to FALSE.
    //
    if (pfAllRemoved)
        *pfAllRemoved = TRUE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // See if a 16-bit in-proc server is register for this object
    // If so, then we don't want to disturb any of the keys except
    // the 32-bit in-proc server key
    //
    if (ExistInprocServer(hk, szScratch))
    {
	// Move one more level down to the InprocServer32 key and only delete it
	// We need to preserve the other keys for the InprocServer.
	//
	lstrcat(szScratch, "\\InprocServer32");
	if (pfAllRemoved)
		*pfAllRemoved = FALSE;
    }

    f = DeleteKeyAndSubKeys(hk, szScratch);

    RegCloseKey(hk);

    return f;				   
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f, fAllRemoved, fFailure;    
    long l, lVersionFound;    
    DWORD dwDummy;
    BOOL bSuccess;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject, &fAllRemoved);
    if (!f) return FALSE;

    if (fAllRemoved)
    {
          
	// delete everybody of the form
	//   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
        //
	// Note: It's important we unregister the version dependent progid first
        //       otherwise, if another version of the component was unregistered
        //       it will have blown away the version independent progid, we'd
        //       fail and never blow away the version dependent progid
	wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
	f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);	
        if (!f) return FALSE;
        

        // Before we blow away the version independent ProgId, make sure there are 
        // no version dependent ProgIds out there
        //
        if (!QueryOtherVersionProgIds(pszLibName, pszObjectName, lVersion, &lVersionFound, &fFailure))
        {
            ASSERT(!fFailure, "QueryOtherVersionProgIds failed");

            // If a failure occurred such that we don't know if there was another version,
            // error on the side of leaving the version dependent ProgId in the registry.
            //
            if (!fFailure)
            {
	        // delete everybody of the form:
	        //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
	        //
                wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);        
	        f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
	        if (!f) return FALSE;
            }
        }
        else
        {
            // This is here to fix a bug in the previous version of the framework
            // In the previous version we'd blindly blow away the progid for the
            // component without looking for other versions.  To help
            // resolve this, we'll restore the progid if we found other 
            // version dependent progids.
            //       
            ASSERT(lVersionFound > 0, "Version number found is 0");
            bSuccess = CopyVersionDependentProgIdToIndependentProgId(pszLibName, pszObjectName, lVersionFound);
            ASSERT(bSuccess, "Failed to copy version dependent ProgId to version independent ProgId");
            
            // The previous version of the framework didn't write out the CurVer sub-key so
            // we need to take care of that here.
            //
            wsprintf(szScratch, "%s.%s\\CurVer", pszLibName, pszObjectName);                                    
            l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, KEY_ALL_ACCESS, &hk);
            if (ERROR_SUCCESS != l)
            {
                l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                                                        KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
                
                ASSERT(ERROR_SUCCESS == l, "Failed to create reg key");
                if (ERROR_SUCCESS == l)
                {
                    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersionFound);
                    
                    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);                    
                    ASSERT(ERROR_SUCCESS == l, "Failed to set key value");

                    l = RegCloseKey(hk);
                    ASSERT(ERROR_SUCCESS == l, "Failed to close key");
                }
                    
            }
            else
            {
                l = RegCloseKey(hk);
            }
                                           
        }       

    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
	return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}


//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// deletes a key and all of its subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPCSTR              - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPCSTR  pszSubKey
)
{
    HKEY  hk;
    char  szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        // We're deleting keys, so always enumerate the 0th
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// QueryOtherVersionProgIds [RegisterTypeLib helper]
//=--------------------------------------------------------------------------=
// Searches for other version dependent ProgIds for a component
//
// Parameters:
//    pszLibName          - [in] lib name portion of ProgId <libname.coclass>
//    pszObjectName       - [in] coclass portion of ProgId  <libname.coclass>
//    lVersion            - [in] Major version number of our component
//    plFoundVersion      - [out] The largest version number found not equal to our own.  
//                                The version number will be less than or equal to MAX_VERSION
//    pfFailure           - [out] Flag indicating that a failure occurred preventing
//                                us from knowing if there are any other ProgIds
// Output:
//    BOOL                - TRUE:  One or more other version dependent progids exist
//                          FALSE: No other version dependent progids exist
//
// Notes:
//    - If a version dependent ProgId exceeds MAX_VERSION we won't find it.
//    - ASSUMPTION: Major versions are checked for starting at MAX_VERSION and working
//                  down to 1.  An assert will occur if your component
//                  approaches MAX_VERSION allowing you to bump up MAX_VERSION.
//                  The assumption is that major version changes on components 
//                  built with the framework are rare.  It should take many
//                  dev cycles and many years to approach this limit.
//                  Once you get near the limit the assert fires and you
//                  can modify the value to anticipate future versions.
//                  This will allow components built today to successfully
//                  find ProgIds for other components built in the future.                  
//                  However, at some point a component built today won't
//                  be able to find other controls that exceed today's 
//                  MAX_VERSION value.  If this is a concern, re-write
//                  this routine to use RegEnumKey and look for any
//                  version dependent ProgId independent of it's version number.
//                  We chose not to implement it this way, since there may be
//                  several hundred calls to RegEnumKey to find the ProgId
//                  you're looking for.  It's cheaper to make at most MAX_VERSION
//                  calls.
//
BOOL QueryOtherVersionProgIds
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    long     *plFoundVersion,
    BOOL     *pfFailure
    
)
{
    BOOL fFound;
    char szTmp[MAX_PATH];
    long lVer;
    long l;
    HKEY hk, hkVersion;    

    CHECK_POINTER(pszLibName);
    CHECK_POINTER(pszObjectName);

    // This is a warning assert.  If you've tripped this, then your current component 
    // is within VERSION_DELTA versions of exceeding MAX_VERSION.  Consider bumping up MAX_VERSION 
    // or change the delta to a smaller number.  Reasonable settings for these
    // depend on how often you do a major version change of your component.
    //
    ASSERT(MAX_VERSION > VERSION_DELTA, "The MAX_VERSION setting is not in line with what we expect it to be.");
    ASSERT(lVersion <= MAX_VERSION - VERSION_DELTA, "Version number of component is approaching or exceeds limit of checked range.  Consider increasing MAX_VERSION value.");

    // Initialize out params
    //
    if (plFoundVersion)
        *plFoundVersion = 0;

    if (pfFailure)
        *pfFailure = TRUE;

    fFound = FALSE;
    
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "", 0, KEY_ALL_ACCESS, &hk);
    ASSERT(l == ERROR_SUCCESS, "Failed to open HKEY_CLASSES_ROOT");
    if (l != ERROR_SUCCESS) return FALSE;   // Note: If this fails we don't know whether a version dependent ProgId exists or not.

    // We need to walk backwards down from MAX_VERSION so that we end up with the largest version number
    // not equaling our own
    // PERF: It's cheaper to look for a realistic set of versions than it is to enumerate all registry keys
    //       looking for a partial match on the ProgId to figure out what versions are available.
    //
    for (lVer = MAX_VERSION; lVer > 0; lVer--)
    {
        // We know about our version number, skip it.
        //
        if (lVersion == lVer)
            continue;

        // Create version dependent ProgId
        //
        wsprintf(szTmp, "%s.%s.%ld", pszLibName, pszObjectName, lVer);

        l = RegOpenKeyEx(hk, szTmp, 0, KEY_ALL_ACCESS, &hkVersion);

        if (ERROR_SUCCESS == l)        
        {
            // We found another version dependent ProgId other than our own - bail out
            // 
            fFound = TRUE;

            if (plFoundVersion)
                *plFoundVersion = lVer;

            l = RegCloseKey(hkVersion);
            ASSERT(l == ERROR_SUCCESS, "Failed to close version dependent key");
            goto CleanUp;        
        }
    }    

CleanUp:

    // If we made it this far, then we know for certain whether there were other
    // version dependent progids or not.  Reflect back to the caller there
    // was no general failure that led to us not know whether there were
    // any version dependent ProgIds
    //
    if (pfFailure)
        *pfFailure = FALSE;
    
    l = RegCloseKey(hk);
    ASSERT(l == ERROR_SUCCESS, "Failed closing HKEY_CLASSES_ROOT key");

    return fFound;
}

//=--------------------------------------------------------------------------=
// CopyVersionDependentProgIdToIndependentProgId [RegisterTypeLib helper]
//=--------------------------------------------------------------------------=
// Copies the contents of the version dependent ProgId to a version 
// independent ProgId
//
// Parameters:
//    pszLibName          - [in] lib name portion of ProgId <libname.coclass>
//    pszObjectName       - [in] coclass portion of ProgId  <libname.coclass>
//    lVersion            - [in] Major version number of our component
//
// Output:
//    BOOL                - TRUE:  ProgId was copied successfully
//                          FALSE: ProgId was not copied successfully
//
// Notes:
//
BOOL CopyVersionDependentProgIdToIndependentProgId
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion    
)
{    
    CHECK_POINTER(pszLibName);
    CHECK_POINTER(pszObjectName);
    
    HKEY hkVerDependent, hkVerIndependent;    
    char szTmp[MAX_PATH];
    long l, lTmp;
    BOOL bSuccess;
    DWORD dwDummy;
    
    // Get a handle to the version dependent ProgId
    //
    wsprintf(szTmp, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);  

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hkVerDependent);
    ASSERT(ERROR_SUCCESS == l, "Failed to open the version dependent ProgId");
    if (ERROR_SUCCESS != l)
        return FALSE;

    // Blow away the version independent ProgId
    //
    wsprintf(szTmp, "%s.%s", pszLibName, pszObjectName);
    DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szTmp);

    // Create the initial key for the version independent ProgId
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, "", REG_OPTION_NON_VOLATILE,
                                                    KEY_READ | KEY_WRITE, NULL, &hkVerIndependent, &dwDummy);
    if (ERROR_SUCCESS != l)
        goto CleanUp;

    // Copy the contents of the version dependent ProgId to the version independent ProgId
    //
    bSuccess = CopyRegistrySection(hkVerDependent, hkVerIndependent);
    l = (bSuccess) ? ERROR_SUCCESS : !ERROR_SUCCESS;

CleanUp:    
    lTmp = RegCloseKey(hkVerDependent);
    ASSERT(ERROR_SUCCESS == lTmp, "Failed to close registry key");

    lTmp = RegCloseKey(hkVerIndependent);
    ASSERT(ERROR_SUCCESS == lTmp, "Failed to close registry key");
    
    return (ERROR_SUCCESS == l) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// CopyRegistrySection
//=--------------------------------------------------------------------------=
// Recursively copies a section of the registry to another section of the
// registry
//
// Parameters:
//      hkSource        - [in]  The source key to copy from
//      hkDest          - [in]  The dest key to copy to
//
// Output:
//    BOOL                - TRUE:  Registry section was copied successfully
//                          FALSE: Registry section was not copied successfully
//
// Notes:
//      - In order for this to work, only the top-level destination key should exist.
//        We assume that there are no sub-keys under the destination key.
//
BOOL CopyRegistrySection(HKEY hkSource, HKEY hkDest)
{
    char szTmp[MAX_PATH];
    long l, lTmp;
    DWORD dwKey, dwDummy, cbData;
    HKEY hkSrcSub, hkDestSub;
    BOOL bSuccess;
    FILETIME ft;
    DWORD dwType;

    // Copy the value of the source key to the destination key
    //
    cbData = sizeof(szTmp);
    l = RegQueryValueEx(hkSource, NULL,  NULL, &dwType, (BYTE *) szTmp, &cbData);

    if (ERROR_SUCCESS != l)
        return FALSE;

    l = RegSetValueEx(hkDest, NULL, NULL, dwType, (const BYTE *) szTmp, cbData);
    if (ERROR_SUCCESS != l)
        return FALSE;

    dwKey = 0;

    // Enumerate through all of the sub-keys underneath the source key
    //
    while (ERROR_SUCCESS == RegEnumKeyEx(hkSource, dwKey, szTmp, &cbData, NULL, NULL, NULL, &ft))
    {
        ASSERT(cbData > 0, "RegEnumKeyEx returned 0 length string");
        
        // Open the registry source sub-key
        //
        l = RegOpenKeyEx(hkSource, szTmp, 0, KEY_ALL_ACCESS, &hkSrcSub);
        
        ASSERT(ERROR_SUCCESS == l, "Failed to open reg key");
        if (ERROR_SUCCESS != l)
            break;

        // Create the registry dest sub-key
        //
        l = RegCreateKeyEx(hkDest, szTmp, 0, "", REG_OPTION_NON_VOLATILE,
                                                    KEY_READ | KEY_WRITE, NULL, &hkDestSub, &dwDummy);
        
        ASSERT(ERROR_SUCCESS == l, "Failed to create reg key");
        if (ERROR_SUCCESS != l)
        {
            lTmp = RegCloseKey(hkSrcSub);
            ASSERT(ERROR_SUCCESS == lTmp, "Failed to close reg key");
            break;
        }

        // Recursively call ourselves copying all sub-entries from the source key to the dest key
        //
        bSuccess = CopyRegistrySection(hkSrcSub, hkDestSub);
        ASSERT(bSuccess, "Recursive call to CopyRegistrySection failed");

        // Cleanup
        //
        lTmp = RegCloseKey(hkSrcSub);
        ASSERT(ERROR_SUCCESS == l, "Failed to close reg key");

        lTmp = RegCloseKey(hkDestSub);
        ASSERT(ERROR_SUCCESS == l, "Failed to close reg key");

        dwKey++;
    }

    return (ERROR_SUCCESS == l ? TRUE : FALSE);
}

//=--------------------------------------------------------------------------=
// GetHelpFilePath [RegisterTypeLib helper]
//=--------------------------------------------------------------------------=
// Returns the path to the Windows\Help directory
//
// Parameters:
//	char * - [in/out] Pointer to buffer that will contain
//		           the HELP path we will return to the caller
//	UINT   - [in] Number of bytes in the buffer
//
// Output:
//	UINT	- Returns the number of bytes actually copied to the buffer
// 
UINT GetHelpFilePath(char *pszPath, UINT cbPath)
{
	UINT cb;
	char szHelp[] = "\\HELP";
	
	ASSERT(pszPath, "Path pointer is NULL");

	// No need to continue if specified buffer size is zero or less
	//
	if (cbPath == 0)
		return 0;

	cb = GetWindowsDirectory(pszPath, cbPath);
	ASSERT(cb > 0, "Windows path is zero length");
	
	// Concatenate "\HELP" onto the Windows directory
	//
	cb += lstrlen(szHelp);
	if (cb < cbPath)
		lstrcat(pszPath, szHelp);
	else
		FAIL("Unable to add HELP path to Windows, buffer too small");

	return cb;		
}

//=--------------------------------------------------------------------------=
// ExistInprocServer [RegisterUnknownObject Helper]
//=--------------------------------------------------------------------------=
// Checks for the Implemented Categories key under a given key
//
// Parameters:
//	riid - [in] CLSID of object to be examined
//
// Output:
//	BOOL	- Returns TRUE if Implemented Categories exists
//		  Returns FALSE if Implemented Categories doesn't exist
//
BOOL ExistImplementedCategories(REFCLSID riid)
{	
	char szGuidStr[MAX_PATH];
	char szScratch[MAX_PATH];
	long l;
	DWORD dwDummy;
	HKEY hkCLSID, hkImplementedCategories;

	if (!StringFromGuidA(riid, szGuidStr)) 
		return FALSE;
	wsprintf(szScratch, "CLSID\\%s", szGuidStr);

	l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ, NULL, &hkCLSID, &dwDummy);
	if (l != ERROR_SUCCESS) return FALSE;	
	
	l = RegOpenKeyEx(hkCLSID, "Implemented Categories", 0, KEY_ALL_ACCESS, &hkImplementedCategories);
	RegCloseKey(hkCLSID);

	if (l != ERROR_SUCCESS) return FALSE;	
	RegCloseKey(hkImplementedCategories);

	// If we made it this far, then the 'Implemented Categories' key must have been found
	//	
	return TRUE;
}

//=--------------------------------------------------------------------------=
// ExistInprocServer [UnregisterUnknownObject Helper]
//=--------------------------------------------------------------------------=
// Checks for other servers such as (16-bit) InProcServer under the
// CLSID section for a given CLSID guid.
//
// Parameters:
//	HKEY	- [in]	HKEY top-level key where to look for the given
//			CLSID
//	char *  - [in]  CLSID of server that we want to see if there
//			is an (16-bit) InProcServer registered.
//
// Output:
//	BOOL	- Returns TRUE if a 16-bit in-proc server is registered
//		  Returns FALSE if no 16-bit in-proc server is registered
//
BOOL ExistInprocServer(HKEY hkCLSID, char *pszCLSID)
{	
	HKEY hkInProcServer;
	LONG l;
	char szInprocServer[MAX_PATH];

	wsprintf(szInprocServer, "%s\\InprocServer", pszCLSID);
	
	// Attempt to open the 16-bit 'InProcServer' key
	//
	l = RegOpenKeyEx(hkCLSID, szInprocServer, 0, KEY_ALL_ACCESS, &hkInProcServer);
	if (l != ERROR_SUCCESS) return FALSE;	
	RegCloseKey(hkInProcServer);

	// If we made it this far, then the 'InProcServer' key must have been found
	//	
	return TRUE;
}

//=--------------------------------------------------------------------------=
// FileExtension
//=--------------------------------------------------------------------------=
// Given a filename returns the file extension without the preceeded period.
//
char *FileExtension(const char *pszFilename)
{
    char *pPeriod;

    ASSERT(pszFilename, "Passed in filename is NULL");

    // Start at the end of the string and work backwards looking for a period
    //
    pPeriod = (char *) pszFilename + lstrlen(pszFilename) - 1;
    while (pPeriod >= pszFilename)
    {
        if (*pPeriod == '.')
            return ++pPeriod;

        pPeriod--;
    }

    // No extension name was found
    //
    return NULL;
}

//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:
//
static void GetScreenMetrics
(
    void
)
{
    HDC hDCScreen;

    // we have to critical section this in case two threads are converting
    // things at the same time
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (s_fGotScreenMetrics)
        goto Done;

    // we want the metrics for the screen
    //
    hDCScreen = GetDC(NULL);

    ASSERT(hDCScreen, "couldn't get a DC for the screen.");
    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY);

    ReleaseDC(NULL, hDCScreen);
    s_fGotScreenMetrics = TRUE;

    // we're done with our critical seciton.  clean it up
    //
  Done:
    LEAVECRITICALSECTION1(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units
    //
    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric
//
// Notes:
//
void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display
    //
    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    lstrcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    lstrcpy(pszLast, pszName);
}

// from Globals.C
//
extern HINSTANCE    g_hInstResources;

//=--------------------------------------------------------------------------=
// GetResourceHandle
//=--------------------------------------------------------------------------=
// returns the resource handle.  we use the host's ambient Locale ID to
// determine, from a table in the DLL, which satellite DLL to load for
// localized resources.  If a satellite .DLL is not supported or not found
// the instance handle of the object is returned.
//
// Input:
//		lcid = 0 - [in, optional] Locale id that caller wants resource handle for
//				                  This overrides the default lcid.  If no lcid
//								  is provided or its 0, then the default lcid is used.
//
// Output:
//    HINSTANCE
//
// Notes:
//  The localized .DLL must be at the same location as the client object or control.
//  If the .DLL is not in the same location it will not be found and the resource
//  handle of the client object or control will be returned.
//
//  If a localized .DLL containing the full language abbreviation is not found,
//  the language abbreviation is truncated to two characters and the satellite
//  DLL with that name is attempted.  For example, the name MyCtlJPN.DLL and
//  MyCtlJP.DLL are both valid.
//
// If an lcid is passed in then we will attempt to find a satellite DLL matching 
// the desired lcid.  If the lcid is not 0, doesn't match the default lcid and a 
// library is found and loaded for it, we don't cache the library's instance handle.  
// Its up to the caller to call FreeLibrary on the returned handle.  The caller should
// compare the returned handle against g_hInstResources and g_hInstance.  If its not 
// equal to either of these handles then call FreeLibrary on it.  If it is equal to 
// either of these handles then the call must *not* call FreeLibrary on it.
//
HINSTANCE _stdcall GetResourceHandle
(
    LCID lcid /* = 0 */
)
{
    int i;
    char szExtension[5], szModuleName[MAX_PATH];
    char szDllName[MAX_PATH], szFinalName[MAX_PATH];
    char szBaseName[MAX_PATH];
    HINSTANCE hInstResources;
    int iCompare;

#if DEBUG
    int iReCompare;
    char szEnvironValue[MAX_PATH];
    char szMessage[5 * MAX_PATH];		// The message includes 4 file references plus message text
    DWORD dwLength;
    DWORD dwSuccess = 0;
#endif

    // crit sect this so that we don't screw anything up.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    
    // If we fall out, we need to make sure we're returning the cached resource handle
    //
    hInstResources = g_hInstResources;

    // don't do anything if we don't have to
    // If the resource handle has already been cached and the passed in lcid matches the 
    // cached lcid or its the default, we just use the saved instance.
    //
    if ((hInstResources && (lcid == 0 || lcid == g_lcidLocale)) || !g_fSatelliteLocalization)
        goto CleanUp;
    
    if (lcid == 0)
	// Passed in LCID is zero so we want the instance for the default lcid.
	lcid = g_lcidLocale;

    // we're going to call GetLocaleInfo to get the abbreviated name for the
    // LCID we've got.
    //
    i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
    if (!i) goto CleanUp;

    // we've got the language extension.  go and load the DLL name from the
    // resources and then tack on the extension.
    // please note that all inproc sers -must- have the string resource 1001
    // defined to the base name of the server if they wish to support satellite
    // localization.
    //
    i = LoadString(g_hInstance, 1001, szBaseName, sizeof(szBaseName));
    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!");
    if (!i) goto CleanUp;

#ifdef MDAC_BUILD    
    if (g_fSatelliteLangExtension)
#endif
    {
        // got the basename and the extention. go and combine them, and then add
        // on the .DLL for them.
        //
        wsprintf(szDllName, "%s%s.DLL", szBaseName, szExtension);

        // try to load in the DLL
        //
    #if DEBUG
        dwLength = 
    #endif
            GetModuleFileName(g_hInstance, szModuleName, MAX_PATH);

	ASSERT(dwLength > 0, "GetModuleFileName failed");

        _MakePath(szModuleName, szDllName, szFinalName);

        hInstResources = LoadLibrary(szFinalName);

    #if DEBUG

	// This will help diagnose problems where a machine may contain two satellite .DLLs
	// one using the long extension name and the other the short extension name.
	// We'll at least get a warning under DEBUG that we've got two plausible satellite
	// DLLs hanging around, but we're only going to use one of them:  the one with the long name.
	//
	if (hInstResources && lstrlen(szExtension) > 2)
	{
	    HINSTANCE hinstTemp;
	    char szExtTemp[MAX_PATH];

	    // Truncate the language extension to the first two characters
	    lstrcpy(szExtTemp, szExtension);	// Don't want to whack the extension as this will cause
					        // the next if statement to always fail if we truncate it here.
					        // Make a copy and use it.

	    szExtTemp[2] = '\0';
	    wsprintf(szDllName, "%s%s.DLL", szBaseName, szExtTemp);		
	    _MakePath(szModuleName, szDllName, szFinalName);

	    // Try loading the localized .DLL using the truncated lang abbreviation
	    hinstTemp = LoadLibrary(szFinalName);
	    ASSERT(hinstTemp == NULL, "Satellite DLLs with both long and short language abbreviations found.  Using long abbreviation.");
	}

    #endif	 // DEBUG

        if (!hInstResources && lstrlen(szExtension) > 2)
        {
	    // Truncate the language extension to the first two characters
	    szExtension[2] = '\0';	
	    wsprintf(szDllName, "%s%s.DLL", szBaseName, szExtension);		
	       _MakePath(szModuleName, szDllName, szFinalName);

	    // Try loading the localized .DLL using the truncated lang abbreviation
	    hInstResources = LoadLibrary(szFinalName);
        }

        // if we couldn't find it with the entire LCID, try it with just the primary
        // langid
        //
        if (!hInstResources) 
        {
            LPSTR psz;
            LCID lcid;
            lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT);
            i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
            if (!i) goto CleanUp;

            // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly
            // hacky, but it should be fine.  there are no DBCS lang identifiers.
            // finally, retry the load
            //
            psz = szFinalName + lstrlen(szFinalName);
            memcpy((LPBYTE)psz - 7, szExtension, 3);
            hInstResources = LoadLibrary(szFinalName);
        }

        //try under the <base path>\LCID\<sxBaseName.dll>
        if (!hInstResources)
        {

          wsprintf(szDllName, "%u\\%s.dll", lcid, szBaseName);		
          _MakePath(szModuleName, szDllName, szFinalName);
          hInstResources = LoadLibrary(szFinalName);         
        }
    }

#ifdef MDAC_BUILD

    else
    {        
        char *psz;

        GetModuleFileName(g_hInstance, szModuleName, MAX_PATH);
        psz = strrchr(szModuleName, '\\');
        *psz = NULL;

        // szModuleName should now contain the path for the DLL
        // now concatenate the resource location
        strcat(szModuleName, "\\resources\\");
        wsprintf(szDllName, "%s%d", szModuleName, lcid);
        strcat(szDllName, "\\");
        strcat(szDllName, szBaseName);
        strcat(szDllName, ".DLL");

        // try to load in the DLL
        //
        hInstResources = LoadLibrary(szDllName);    
    }

#endif

  CleanUp:

    // if we couldn't load the DLL for some reason, then just return the
    // current resource handle, which is good enough.
    //
    if (!hInstResources) 
	hInstResources = g_hInstance;

    if (!g_hInstResources && (lcid == 0 || lcid == g_lcidLocale))
	// We only cache the instance handle for the default LCID.
	// For all other passed in lcid values we will LoadLibrary on the satellite DLL each time.
	// Its recommended that the calling app cache the returned instance handle for the given
	// lcid passed in.
	//
	g_hInstResources = hInstResources;

    ASSERT(hInstResources, "Resource handle is NULL");

    // =-------------------------------------------------------------------
    // Satellite .DLL version check
    // =-------------------------------------------------------------------
    // The satellite .DLL version must exactly match the version of the
    // 
    if ((!g_bDllVerChecked) || 
	    (lcid != g_lcidLocale && lcid != 0))
    {	
	    // If we're using a satellite .DLL 
	    // (hInstResources != g_hInstance), do a version check.
	    // 
	    // If the passed in lcid is different than what we've cached and we're
	    // using a satellite .DLL, do the version check.
	    //

	    // Make sure we have a satellite .DLL
	    //
	    if (hInstResources != g_hInstance) 								
	    {
	    #if DEBUG
		    dwLength = 
	    #endif
			    GetModuleFileName(hInstResources, szFinalName, MAX_PATH);

		    ASSERT(dwLength > 0, "GetModuleFileName failed");

		    iCompare = CompareDllVersion(szFinalName, TRUE);
		    
	    #if DEBUG

		    if (VERSION_LESS_THAN == iCompare)
		    {
			    wsprintf(szMessage, "Major version compare: VERSION resource info in %s is less than VERSION info in %s. Non-localized resources will be used.  In order to see localized resources, you need to obtain a version of %s that matches %s.", szFinalName, szModuleName, szFinalName, szModuleName);
			    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
		    }
		    else if (VERSION_GREATER_THAN == iCompare)
		    {
			    wsprintf(szMessage, "Major version compare: VERSION resource info in %s is greater than VERSION info in %s. Non-localized resources will be used.  In order to see localized resources, you need to obtain a version of %s that matches %s.", szFinalName, szModuleName, szFinalName, szModuleName);
			    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
		    }
		    else if (VERSION_EQUAL == iCompare)
		    {

			    // Vegas #29024: Only enable full version assert if environment variable is set.
			    //
			    dwSuccess = GetEnvironmentVariable("INTL_VERSION_COMPARE", szEnvironValue,  MAX_PATH);

			    if (dwSuccess > 0)
			    {
				    // Re-do the comparison using a full-version compare
				    //
				    // Note: Don't use iCompare here otherwise DEBUG builds will default to non-localized resources
				    //		 when major version comparison succeeds, but full version compare fails.  				
				    //
				    iReCompare = CompareDllVersion(szFinalName, FALSE);

				    if (VERSION_LESS_THAN == iReCompare)
				    {
					    wsprintf(szMessage, "Warning: Full version compare: VERSION resource info in %s is less than VERSION info in %s. Localized resources will continue to be used, but may not be in sync.", szFinalName, szModuleName);
					    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
				    }
				    else if (VERSION_GREATER_THAN == iReCompare)
				    {
					    wsprintf(szMessage, "Warning: Full version compare: VERSION resource info in %s is greater than VERSION info in %s. Localized resources will continue to be used, but may not be in sync.", szFinalName, szModuleName);
					    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
				    }
			    }

		    }

	    #endif

		    // If CompareDllVersion ever returns NOT_EQUAL it means it didn't get far enough
		    // to figure out if the version was less than or greater than.  It must have failed.
		    //
		    // Note: In this case, we go ahead and use the satellite .DLL anyway.  It may be that
		    //	     the satellite .DLL doesn't contain VERSION info.
		    //
		    ASSERT(VERSION_NOT_EQUAL != iCompare, "Failure attempting to compare satellite .DLL version");
		    if (VERSION_LESS_THAN == iCompare || VERSION_GREATER_THAN == iCompare)
		    {
			    // If the check fails, return the instance of ourself, not the
			    // satellite .DLL.  Resources will be displayed in English.
			    //
			    hInstResources = g_hInstance;

			    if (lcid == 0 || lcid == g_lcidLocale)
			    {
				    g_hInstResources = g_hInstance;				
			    }
		    }

	    }

	    if (lcid == 0 || lcid == g_lcidLocale)
		    g_bDllVerChecked = TRUE;
    }

    LEAVECRITICALSECTION1(&g_CriticalSection);

    return hInstResources;
}

//=--------------------------------------------------------------------------=
// CompareDllVersion
//=--------------------------------------------------------------------------=
// Given a pointer to an external filename, compare the version info in the
// file with the version info in our own binary (.DLL or .OCX).
//
// Parameters:
//
// Returns: S_OK if type flags are successfully found, otherwise an error code
//
VERSIONRESULT _stdcall CompareDllVersion(const char * pszFilename, BOOL bCompareMajorVerOnly)
{	
	// Default to not equal.  The only time we're not equal is if something failed.
	//
	VERSIONRESULT vrResult = VERSION_NOT_EQUAL;
	
	BOOL bResult;	
	VS_FIXEDFILEINFO ffiMe, ffiDll;
	char szModuleName[MAX_PATH];
	WORD wMajorVerMe;
	WORD wMajorVerDll;

	DWORD dwLength;

	// Get VERSION info for our own .DLL/.OCX (aka Me)
	//
	ASSERT(g_hInstance, "hInstance is NULL");
	dwLength = GetModuleFileName(g_hInstance, szModuleName, MAX_PATH);
	ASSERT(dwLength > 0, "GetModuleFilename failed");

	if (0 == dwLength)
		goto CleanUp;

	// Make sure we're not comparing the same file
	//
	ASSERT(0 != lstrcmpi(szModuleName, pszFilename), "The same file is being compared");

	bResult = GetVerInfo(szModuleName, &ffiMe);
	ASSERT(bResult, "GetVerInfo failed");	
	if (!bResult)
		goto CleanUp;

	ASSERT(0xFEEF04BD == ffiMe.dwSignature, "Bad VS_FIXEDFILEINFO signature for Me");

	// Get version info for the passed in .DLL name
	//
	bResult = GetVerInfo(pszFilename, &ffiDll);
	ASSERT(bResult, "GetVerInfo failed");	
	if (!bResult)
		goto CleanUp;

	ASSERT(0xFEEF04BD == ffiDll.dwSignature, "Bad VS_FIXEDFILEINFO signature for Me");
	
	if (bCompareMajorVerOnly)
	{
		// Major version compare
		//
		wMajorVerMe = HIWORD(ffiMe.dwFileVersionMS);
		wMajorVerDll = HIWORD(ffiDll.dwFileVersionMS);

		if (wMajorVerMe == wMajorVerDll)
			return VERSION_EQUAL;
		else if (wMajorVerMe > wMajorVerDll)
			return VERSION_LESS_THAN;
		else
			return VERSION_GREATER_THAN;

	}
	else	
	{	
		// Full version compare
		//
		// Compare the version with our build version set by constants in DWINVERS.H
		//
		if (ffiMe.dwFileVersionMS == ffiDll.dwFileVersionMS &&
			ffiMe.dwFileVersionLS == ffiDll.dwFileVersionLS)
		{
			vrResult = VERSION_EQUAL;
		}
		else if (ffiMe.dwFileVersionMS == ffiDll.dwFileVersionMS)
		{
			if (ffiMe.dwFileVersionLS > ffiDll.dwFileVersionLS)
					vrResult = VERSION_LESS_THAN;
			else
					vrResult = VERSION_GREATER_THAN;
		}
		else if (ffiMe.dwFileVersionMS < ffiDll.dwFileVersionMS)
		{
			vrResult = VERSION_LESS_THAN;
		}
		else
		{
			vrResult = VERSION_GREATER_THAN;
		}

	}

CleanUp:
	return vrResult;

}

//=--------------------------------------------------------------------------=
// GetVerInfo
//=--------------------------------------------------------------------------=
// Returns the VERSION resource fixed file info struct for a given file.
//
// Parameters:
//		pszFilename	- [in]		Filename to return version info for
//		pffi		- [out]		Version info
//
BOOL _stdcall GetVerInfo(const char * pszFilename, VS_FIXEDFILEINFO *pffi)
{	
	DWORD dwHandle = 0;
	DWORD dwVersionSize = 0;
	UINT uiLength = 0;
	VS_FIXEDFILEINFO * pffiTemp;

#if DEBUG
	DWORD dwGetLastError;
#endif

	BYTE *pVersionInfo = NULL;
	BOOL bResult = FALSE;

	memset(pffi, 0, sizeof(VS_FIXEDFILEINFO));
	
	dwVersionSize = CallGetFileVersionInfoSize((char *) pszFilename, &dwHandle);

#if DEBUG
	dwGetLastError = GetLastError();
#endif

	ASSERT(dwVersionSize > 0, "GetFileVersionInfoSize failed");

	if (0 == dwVersionSize)
		goto CleanUp;

	pVersionInfo = (BYTE *) HeapAlloc(g_hHeap, 0, dwVersionSize);
	ASSERT(pVersionInfo, "pVersionInfo is NULL");
	if (NULL == pVersionInfo)
		goto CleanUp;

	bResult = CallGetFileVersionInfo((char *) pszFilename, dwHandle, dwVersionSize, pVersionInfo);
	ASSERT(bResult, "GetFileVersionInfo failed");
	if (!bResult)
		goto CleanUp;

	bResult = CallVerQueryValue(pVersionInfo, "\\", (void **) &pffiTemp, &uiLength);
	ASSERT(bResult, "VerQueryValue failed");
	
	if (!bResult)
		goto CleanUp;

	ASSERT(sizeof(VS_FIXEDFILEINFO) == uiLength, "Returned length is invalid");
	memcpy(pffi, pffiTemp, uiLength);

CleanUp:

	if (pVersionInfo)
		HeapFree(g_hHeap, 0, pVersionInfo);

	return bResult;
}

//=--------------------------------------------------------------------------=
// CallGetFileVersionInfoSize [VERSION.DLL API wrapper]
//=--------------------------------------------------------------------------=
// This does a dynamic call to the GetFileVersionInfoSize API function.  If
// VERSION.DLL isn't loaded, then this function loads it.
//
BOOL CallGetFileVersionInfoSize
(
	LPTSTR lptstrFilename, 
	LPDWORD lpdwHandle
)
{
	EnterCriticalSection(&g_CriticalSection);

	// One-time setup of VERSION.DLL and function pointer
	//
	if (!g_pGetFileVersionInfoSize)
	{
		if (!g_hinstVersion)
		{
			g_hinstVersion = LoadLibrary(DLL_VERSION);
			ASSERT(g_hinstVersion, "Failed to load VERSION.DLL");
			if (!g_hinstVersion)
				return FALSE;
		}
			
		g_pGetFileVersionInfoSize = (PGETFILEVERSIONINFOSIZE) GetProcAddress(g_hinstVersion, FUNC_GETFILEVERSIONINFOSIZE);
		ASSERT(g_pGetFileVersionInfoSize, "Failed to get proc address for GetFileVersionInfoSize");
		if (!g_pGetFileVersionInfoSize)
			return FALSE;
	}
		
	LeaveCriticalSection(&g_CriticalSection);

	// Call GetFileVersionInfoSize
	//
	return g_pGetFileVersionInfoSize(lptstrFilename, lpdwHandle);	
}


//=--------------------------------------------------------------------------=
// CallGetFileVersionInfo [VERSION.DLL API wrapper]
//=--------------------------------------------------------------------------=
// This does a dynamic call to the GetFileVersionInfo API function.  If
// VERSION.DLL isn't loaded, then this function loads it.
//
BOOL CallGetFileVersionInfo
(
	LPTSTR lpststrFilename, 
	DWORD dwHandle, 
	DWORD dwLen, 
	LPVOID lpData	
)
{
	EnterCriticalSection(&g_CriticalSection);

	// One-time setup of VERSION.DLL and function pointer
	//
	if (!g_pGetFileVersionInfo)
	{
		if (!g_hinstVersion)
		{
			g_hinstVersion = LoadLibrary(DLL_VERSION);
			ASSERT(g_hinstVersion, "Failed to load VERSION.DLL");
			if (!g_hinstVersion)
				return FALSE;
		}
			
		g_pGetFileVersionInfo = (PGETFILEVERSIONINFO) GetProcAddress(g_hinstVersion, FUNC_GETFILEVERSIONINFO);
		ASSERT(g_pGetFileVersionInfo, "Failed to get proc address for GetFileVersionInfo");
		if (!g_pGetFileVersionInfo)
			return FALSE;
	}
		
	LeaveCriticalSection(&g_CriticalSection);

	// Call GetFileVersionInfo
	//
	return g_pGetFileVersionInfo(lpststrFilename, dwHandle, dwLen, lpData);	
}


//=--------------------------------------------------------------------------=
// CallVerQueryValue [VERSION.DLL API wrapper]
//=--------------------------------------------------------------------------=
// This does a dynamic call to the VerQueryValue API function.  If
// VERSION.DLL isn't loaded, then this function loads it.
//
BOOL CallVerQueryValue
(
	const LPVOID pBlock,
	LPTSTR lpSubBlock,
	LPVOID *lplpBuffer,
	PUINT puLen
)
{
	EnterCriticalSection(&g_CriticalSection);

	// One-time setup of VERSION.DLL and function pointer
	//
	if (!g_pVerQueryValue)
	{
		if (!g_hinstVersion)
		{
			g_hinstVersion = LoadLibrary(DLL_VERSION);
			ASSERT(g_hinstVersion, "Failed to load VERSION.DLL");
			if (!g_hinstVersion)
				return FALSE;
		}
			
		g_pVerQueryValue = (PVERQUERYVALUE) GetProcAddress(g_hinstVersion, FUNC_VERQUERYVALUE);
		ASSERT(g_pVerQueryValue, "Failed to get proc address for VerQueryValue");
		if (!g_pVerQueryValue)
			return FALSE;
	}
		
	LeaveCriticalSection(&g_CriticalSection);

	// Call VerQueryValue
	//
	return g_pVerQueryValue(pBlock, lpSubBlock, lplpBuffer, puLen);
}

//=--------------------------------------------------------------------------=
// GetTypeInfoFlagsForGuid
//=--------------------------------------------------------------------------=
// Given a pointer to a TypeLib and a TypeInfo guid, returns the TYPEFLAGS
// associated with the TypeInfo
//
// Parameters:
//		pTypeLib -		[in]  Pointer of TypeLib to find typeinfo type flags
//		guidTypeInfo - 	[in]  Guid of TypeInfo we're looking for
//		pwFlags -       [out] TYPEFLAGS associated with the typeinfo
//
// Returns: S_OK if type flags are successfully found, otherwise an error code
//
HRESULT GetTypeFlagsForGuid(ITypeLib *pTypeLib, REFGUID guidTypeInfo, WORD *pwFlags)
{
	ITypeInfo *pTypeInfo;
	TYPEATTR *pTypeAttr;
	HRESULT hr;

	if (!pTypeLib || !pwFlags)
		return E_POINTER;

	*pwFlags = 0;

	// Search for the given guid in the TypeLib
	//
	hr = pTypeLib->GetTypeInfoOfGuid(guidTypeInfo, &pTypeInfo);		

	if (SUCCEEDED(hr))
	{
		// Get the type attributes for the found TypeInfo
		//
		hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
		ASSERT(SUCCEEDED(hr), "Failed to get ctl TypeInfo TypeAttr");

		if (SUCCEEDED(hr))
		{
			// Return TYPEFLAGS
			//
			*pwFlags = pTypeAttr->wTypeFlags;
			pTypeInfo->ReleaseTypeAttr(pTypeAttr);
		}

		pTypeInfo->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\asp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Wed Mar 12 14:39:56 1997
 */
/* Compiler settings for asp.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __asp_h__
#define __asp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_ASPTypeLibrary;

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IStringList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStringList : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT i,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in] */ VARIANT i,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IStringList_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in] */ VARIANT i,
    /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IRequestDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IRequestDictionary_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT Var,
    /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRequest : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IRequest_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT __stdcall IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Request;

class Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IReadCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReadCookie : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_HasKeys( 
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IReadCookie_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT Var,
    /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IWriteCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWriteCookie : public IDispatch
    {
    public:
        virtual /* [propput][id] */ HRESULT __stdcall put_Item( 
            /* [in] */ VARIANT key,
            /* [in] */ BSTR rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Expires( 
            /* [in] */ DATE rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Domain( 
            /* [in] */ BSTR rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Path( 
            /* [in] */ BSTR rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Secure( 
            /* [in] */ boolean rhs) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_HasKeys( 
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT key,
            /* [in] */ BSTR rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ boolean rhs);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IWriteCookie_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IWriteCookie_put_Item(This,key,rhs)	\
    (This)->lpVtbl -> put_Item(This,key,rhs)

#define IWriteCookie_put_Expires(This,rhs)	\
    (This)->lpVtbl -> put_Expires(This,rhs)

#define IWriteCookie_put_Domain(This,rhs)	\
    (This)->lpVtbl -> put_Domain(This,rhs)

#define IWriteCookie_put_Path(This,rhs)	\
    (This)->lpVtbl -> put_Path(This,rhs)

#define IWriteCookie_put_Secure(This,rhs)	\
    (This)->lpVtbl -> put_Secure(This,rhs)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput][id] */ HRESULT __stdcall IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT key,
    /* [in] */ BSTR rhs);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE rhs);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR rhs);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR rhs);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ boolean rhs);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Buffer( 
            /* [retval][out] */ boolean __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Buffer( 
            /* [in] */ boolean fIsBuffering) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_ContentType( 
            /* [in] */ BSTR pbstrContentTypeRet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Expires( 
            /* [in] */ VARIANT varExpiresMinutesRet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_ExpiresAbsolute( 
            /* [in] */ VARIANT varExpiresRet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Status( 
            /* [in] */ BSTR pbstrStatusRet) = 0;
        
        virtual /* [hidden][id] */ HRESULT __stdcall Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall BinaryWrite( 
            /* [in] */ SAFEARRAY __RPC_FAR * rgbBuffer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall End( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Flush( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden][id] */ HRESULT __stdcall WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *fIsBuffering);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ boolean fIsBuffering);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR pbstrContentTypeRet);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varExpiresMinutesRet);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varExpiresRet);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR pbstrStatusRet);
        
        /* [hidden][id] */ HRESULT ( __stdcall __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * rgbBuffer);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden][id] */ HRESULT ( __stdcall __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IResponse_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> put_ContentType(This,pbstrContentTypeRet)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,varExpiresMinutesRet)	\
    (This)->lpVtbl -> put_Expires(This,varExpiresMinutesRet)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,varExpiresRet)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,varExpiresRet)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> put_Status(This,pbstrStatusRet)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,rgbBuffer)	\
    (This)->lpVtbl -> BinaryWrite(This,rgbBuffer)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ boolean fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR pbstrContentTypeRet);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varExpiresMinutesRet);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varExpiresRet);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR pbstrStatusRet);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT __stdcall IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * rgbBuffer);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT __stdcall IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Response;

class Response;
#endif

#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_ISessionObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT __stdcall get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT __stdcall put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [propputref][id] */ HRESULT __stdcall putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Timeout( 
            /* [in] */ long plvar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Abandon( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [propputref][id] */ HRESULT ( __stdcall __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long plvar);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define ISessionObject_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,pvar)

#define ISessionObject_putref_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,pvar)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,plvar)	\
    (This)->lpVtbl -> put_Timeout(This,plvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT __stdcall ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT __stdcall ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT __stdcall ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long plvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Session;

class Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IApplicationObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT __stdcall put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [propputref][id] */ HRESULT __stdcall putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Lock( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall UnLock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [propputref][id] */ HRESULT ( __stdcall __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IApplicationObject_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,pvar)

#define IApplicationObject_putref_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,pvar)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT __stdcall IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT __stdcall IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Application;

class Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_ScriptTimeout( 
            /* [in] */ long plTimeoutSeconds) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long plTimeoutSeconds);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IServer_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long plTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Server;

class Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IScriptingContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IScriptingContext_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ScriptingContext;

class ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\btree.h ===
#ifndef BTREE_H
#define BTREE_H

//------------------
//  BTreePage
//  	A BTree page
//------------------

struct PageHeader
{
    long Order;    // maximum # of page  links in page
    long MaxKeys;  // maximum # of keys  in page
    long MinKeys;  // minimum # of keys  in page
    long NoOfKeys; // actual  # of keys  in page
    long KeySize;  // maximum # of bytes in a key
};

template <class K, class D>
struct BTreeNode
{
    K  m_Key;
    const D * m_pData;
    ULONG m_ulHash;
    BTreeNode<K, D> * m_pNext;

    BTreeNode();
    BTreeNode(const K& Key, const D* data);
    ~BTreeNode();

    void operator = (const BTreeNode& node);
};

template <class K, class D>
BTreeNode<K,D>::BTreeNode() :
m_pData(NULL),
m_pNext(NULL),
m_ulHash(0)
{
}

template <class K, class D>
BTreeNode<K,D>::BTreeNode(const K& Key, const D* pdata) :
m_pData(pdata),
m_pNext(NULL)
{
    m_Key = Key;
    m_ulHash = Hash(Key);
}

template <class K, class D>
BTreeNode<K,D>::~BTreeNode()
{
    m_pNext = NULL;
}

template <class K, class D>
void BTreeNode<K,D>::operator=(const BTreeNode& node)
{
    m_Key = node.m_Key;
    m_pData = node.m_pData;
    m_ulHash = node.m_ulHash;
    m_pNext = node.m_pNext;
}

template <class K, class D>
struct BTreePage
{
    PageHeader m_hdr;    // header information
    BTreeNode<K,D> * m_pNodes;
    BTreePage<K,D>** m_ppLinks;

    BTreePage<K,D>*  m_pParent;
    BTreePage(long ord);
    BTreePage(const BTreePage & p);
    ~BTreePage();
    void operator = (const BTreePage & page);
    void DeleteAllNodes();
    void CopyNodes(BTreeNode<K,D>* pDestNodes, BTreeNode<K,D>* pSrcNodes, long cnt);
};

template <class K, class D> 
BTreePage<K,D>::BTreePage(long ord)
{

    m_hdr.Order     = ord;
    m_hdr.MaxKeys   = ord - 1;
    m_hdr.MinKeys   = ord / 2;
    m_hdr.NoOfKeys  = 0;
    m_hdr.KeySize   = sizeof(K);

    if (m_hdr.Order == 0)
    {
        m_pNodes = NULL;
        m_ppLinks = NULL;
        return;
    }

    // allocate key array
    m_pNodes = new BTreeNode<K,D> [m_hdr.MaxKeys];

    ASSERT(m_pNodes, "Couldn't allocate nodes array!");

    memset(m_pNodes,0,m_hdr.MaxKeys * sizeof(BTreeNode<K,D>));

    m_ppLinks = new BTreePage<K,D>*[m_hdr.MaxKeys + 1];

    ASSERT(m_ppLinks, "Couldn't allocate limks array!");

    memset(m_ppLinks,0,((m_hdr.MaxKeys + 1)* sizeof(BTreePage<K,D>*)));

    m_pParent = NULL;
}
	
template <class K, class D>
BTreePage<K, D>::BTreePage(const BTreePage<K,D> & pg)
{
    m_hdr = pg.m_hdr;

    // allocate key array
    m_pNodes = new BTreeNode<K,D>[m_hdr.MaxKeys];

    ASSERT(m_pNodes, "Couldn't allocate nodes array!");

    CopyNodes(m_pNodes, pg.m_pNodes, m_hdr.Order);

    for (int i = 0; i < m_hdr.MaxKeys + 1; i++)
        m_ppLinks[i] = pg.m_ppLinks[i];

    m_pParent = pg.m_pParent;
}
	
template <class K, class D>
BTreePage<K, D>::~BTreePage()
{
    // delete old buffers
    DeleteAllNodes();
    
    delete [] m_ppLinks;
}
	
template <class K, class D>
void BTreePage<K,D>::operator = (const BTreePage<K,D> & pg)
{

    // allocate key array
    if (m_pNodes!= NULL)
        DeleteAllNodes();

    m_pNodes = new BTreeNode<K,D> [pg.m_hdr.MaxKeys];

    ASSERT(m_pNodes, "Couldn't allocate nodes array!");

    if (m_ppLinks)
        delete [] m_ppLinks;

    m_ppLinks = new BTreePage<K,D>*[pg.m_hdr.MaxKeys + 1];

    ASSERT(m_ppLinks, "Couldn't allocate links array!");

    m_hdr = pg.m_hdr;

    CopyNodes(m_pNodes, pg.m_pNodes, m_hdr.Order);


    for (int i = 0; i < m_hdr.MaxKeys + 1; i++)
        m_ppLinks[i] = pg.m_ppLinks[i];

    m_pParent = pg.m_pParent;
}

template <class K, class D>
void BTreePage<K,D>::DeleteAllNodes()
{
    for (int i = 0; i < m_hdr.NoOfKeys; i++)
    {
        BTreeNode<K,D>* pIndex = m_pNodes[i].m_pNext;

        while(pIndex)
        {
            BTreeNode<K,D>* pDel = pIndex;
            pIndex = pIndex->m_pNext;
            delete pDel;
        }

    }

    delete [] m_pNodes;
    m_pNodes = NULL;
}

template <class K, class D>
void BTreePage<K,D>::CopyNodes(BTreeNode<K,D>* pDestNodes, BTreeNode<K,D>* pSrcNodes, long cnt)
{
    for (int i = 0; i < cnt; i++)
    {
        pDestNodes[i] = pSrcNodes[i];
        BTreeNode<K,D>* pSrcIndex = pSrcNodes[i].m_pNext;
        BTreeNode<K,D>* pDestIndex = pDestNodes;

        while(pSrcIndex)
        {
            pDestIndex->m_pNext = new BTreeNode<K,D>(*pSrcIndex);
            pSrcIndex = pSrcIndex->m_pNext;
            pDestIndex = pDestIndex->m_pNext;
        }
    }
}

//-----------------------------------------------
//  BTree
//      A DataFile that uses a BTree for indexing
//      NOTE: No copy semantics will exist for a btree
//-----------------------------------------------

template <class K, class D>
	class BTree
{
public:
    BTree(long ord); // new
    BTree(long ord, int (*compare)(const K& key1, const K& key2));

    ~BTree();

    void Insert(const K & key, const D* data);
    const D* Get(const K & key);
    void Delete(const K & key);
    void InOrder(void (* func)(const K & key, const D* pdata, int depth, int index));
    void Clear();

private:
    // data members
    BTreePage<K,D>*    m_pRoot;   // root page (always in memory)

    void (* TravFunc)(const K & key, const D* pdata, int depth, int index);
    int (*CompFunc) (const K& key1, const K& key2);

    // search for a node
    BOOL Search(BTreePage<K,D>* ppg, const ULONG& thash, const K& searchkey, BTreePage<K,D>** ppkeypage, long & pos);

    // insert node into leaf
    void InsertKey(const K & inskey, const D* pdata);

    // promote a key into a parent node
    void PromoteInternal(BTreePage<K, D>* ppg, BTreeNode<K,D> & node, BTreePage<K, D>* pgrtrpage);

    // promote a key by creating a new root
    void PromoteRoot(BTreeNode<K,D> & node, BTreePage<K, D>* plesspage, BTreePage<K, D>* pgrtrpage);

    // adjust tree if leaf has shrunk in size
    void AdjustTree(BTreePage<K, D>* pleafpg);

    // redistribute keys among siblings and parent
    void Redistribute(long keypos, BTreePage<K, D>* plesspage, BTreePage<K, D>* pparpage, BTreePage<K, D>* pgrtrpage);

    // concatenate sibling pages
    void Concatenate(long keypos, BTreePage<K, D>* plesspage, BTreePage<K, D>* pparpage, BTreePage<K, D>* pgrtrpage);

    // recursive traversal function used by InOrder
    void RecurseTraverse(const BTreePage<K, D>* ppg, int depth);

    // recursively delete a page and all it's sub pages;
    void DeletePage(BTreePage<K,D>* ppg);
};
	
template <class K, class D>
BTree<K,D>::BTree(long ord)
{
    CompFunc  = NULL;
    m_pRoot = new BTreePage<K,D>(ord);
}
	
template <class K, class D>
BTree<K,D>::BTree(long ord, int (*comp)(const K& key1, const K& key2))
{
    CompFunc  = comp;
    m_pRoot = new BTreePage<K,D>(ord);
}
	
template <class K, class D>
BTree<K,D>::~BTree()
{
    DeletePage(m_pRoot);
}
	
template <class K, class D>
void BTree<K,D>::Insert(const K & key, const D* pdb)
{
    // store the key in a page
    InsertKey(key,pdb);
}
    
template <class K, class D>
const D* BTree<K,D>::Get(const K & key)
{

    BTreePage<K,D>* pgetpage = NULL;
    long  getpos;

    if (Search(m_pRoot, Hash(key), key, &pgetpage, getpos))
    {
        BOOL found = FALSE;

        BTreeNode<K,D>* pnode = &pgetpage->m_pNodes[getpos];

	if (CompFunc)
	{
          while(pnode && !found)
          {
              if (CompFunc(key, pnode->m_Key) == 0)
              {
                  found = TRUE;
                  return pnode->m_pData;
              }

              pnode = pnode->m_pNext;
	  }
	}
	else
	{
          while(pnode && !found)
          {
              if (key == pnode->m_Key)
              {
                  found = TRUE;
                  return pnode->m_pData;
              }

              pnode = pnode->m_pNext;
	  }
        }

    }
    else
    {
        return NULL;
    }

    return NULL;
}

template <class K, class D>
void BTree<K,D>::Delete(const K & delkey)
{

    BTreePage<K,D>* pdelpage = NULL;
    long delpos;

    if (!Search(m_pRoot, Hash(delkey), delkey, &pdelpage, delpos))
    {
        return;
    }

    if (!pdelpage->m_ppLinks[0]) // is this a leaf page?
    {
        //Delete all linked nodes.
        BOOL bFound = FALSE;
        BOOL bDelNode = FALSE;
        BTreeNode<K,D>* pDelNode = (pdelpage->m_pNodes + delpos);
        BTreeNode<K,D>* pIndex = pDelNode;

        while(pDelNode && !bFound)
        {
            if ((CompFunc  && (CompFunc(delkey, pDelNode->m_Key) == 0)) ||
		(!CompFunc && (delkey == pDelNode->m_Key)))
            {
                //If the node we need to delete is the head node in the list AND it's the only node
                //then we need to skip to the routine below to delete it from the tree.
                // + delpos
                if (pDelNode == (pdelpage->m_pNodes + delpos))
                {
                    if (!pDelNode->m_pNext)
                    {
                        bDelNode = TRUE;
                    }
                    else
                    {
                        pDelNode = pDelNode->m_pNext;
                        *pIndex = *pDelNode;
                        delete pDelNode;
                        pDelNode = NULL;
                    }
                }
                else
                {
                    pIndex->m_pNext = pDelNode->m_pNext;
                    delete pDelNode;
                    pDelNode = NULL;
                }

                bFound = TRUE;
            }
            else
            {
                pIndex = pDelNode;
                pDelNode = pDelNode->m_pNext;
            }

        }

        if (bDelNode)
        {
            --pdelpage->m_hdr.NoOfKeys;

            // remove key from leaf
	    for (long n = delpos; n < pdelpage->m_hdr.NoOfKeys; ++n)
            {
                pdelpage->m_pNodes[n] = pdelpage->m_pNodes[n + 1];
            }

            memset((void*)&pdelpage->m_pNodes[pdelpage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));


            // adjust tree
	    if (pdelpage->m_hdr.NoOfKeys < pdelpage->m_hdr.MinKeys)
                AdjustTree(pdelpage);
        }
    }
    else // delpage is internal
    {
        // replace deleted key with immediate successor
        BTreePage<K,D>* psucpage = NULL;

        // find successor
        psucpage = pdelpage->m_ppLinks[delpos + 1];

        while (psucpage->m_ppLinks[0])
            psucpage = psucpage->m_ppLinks[0];

        
        //Delete all linked nodes.
        BOOL bFound = FALSE;
        BOOL bDelNode = FALSE;
        BTreeNode<K,D>* pDelNode = (pdelpage->m_pNodes + delpos);
        BTreeNode<K,D>* pIndex = pDelNode;

        while(pDelNode && !bFound)
        {
            if ((CompFunc  && (CompFunc(delkey, pDelNode->m_Key) == 0)) ||
		(!CompFunc && (delkey == pDelNode->m_Key)))
            {
                //If the node we need to delete is the head node in the list AND it's the only node
                //then we need to skip to the routine below to delete it from the tree.
                if (pDelNode == (pdelpage->m_pNodes + delpos))
                {
                    if (!pDelNode->m_pNext)
                    {
                        bDelNode = TRUE;
                    }
                    else
                    {
                        pDelNode = pDelNode->m_pNext;
                        pdelpage->m_pNodes[delpos].operator=(*pDelNode);
                        delete pDelNode;
                    }
                }
                else
                {
                    pIndex->m_pNext = pDelNode->m_pNext;
                    delete pDelNode;
                    pDelNode = NULL;
                }

                bFound = TRUE;
            }
            else
            {
                pIndex = pDelNode;
                pDelNode = pDelNode->m_pNext;
            }
        }

        if (bDelNode)
        {
            // first key is the "swappee"
            pdelpage->m_pNodes[delpos] = psucpage->m_pNodes[0];

            // deleted swapped key from sucpage
            --psucpage->m_hdr.NoOfKeys;

            for (long n = 0; n < psucpage->m_hdr.NoOfKeys; ++n)
    	    {
                psucpage->m_pNodes[n] = psucpage->m_pNodes[n + 1];
                psucpage->m_ppLinks[n + 1] = psucpage->m_ppLinks[n + 2];
            }

            memset((void*)&psucpage->m_pNodes[psucpage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));

            psucpage->m_ppLinks[psucpage->m_hdr.NoOfKeys + 1] = NULL;


	        // adjust tree for leaf node
            if (psucpage->m_hdr.NoOfKeys < psucpage->m_hdr.MinKeys)
                AdjustTree(psucpage);
        }
    }
}
    
template <class K, class D>
void BTree<K,D>::InOrder(void (* func)(const K & key, const D* pdata, int depth, int index))
{
    // save the address of the function to call
    TravFunc = func;

    // recurse the tree
    RecurseTraverse(m_pRoot, 0);

}

template <class K, class D>
void BTree<K,D>::Clear()
{
    DeletePage(m_pRoot);
}
    
template <class K, class D>
BOOL BTree<K,D>::Search(BTreePage<K,D>* ppg, const ULONG& thash, const K& searchkey, BTreePage<K,D>** ppkeypage, long & pos)
{
    BOOL result;
    pos = 0;

    for (;;)
    {
        if (pos == ppg->m_hdr.NoOfKeys)
            goto getpage;

        if (ppg->m_pNodes[pos].m_ulHash == thash)
        {
            *ppkeypage = (BTreePage<K,D>*)ppg;
            result = TRUE;
            break;
        }
        else
        {
            if (ppg->m_pNodes[pos].m_ulHash < thash)
               ++pos;
            else
            {
                // I know this is a label -- so shoot me!
getpage:

                // if we're in a leaf page, key wasn't found
                if (!ppg->m_ppLinks[pos])
                {
                    *ppkeypage = (BTreePage<K,D>*)ppg;
                    result  = FALSE;
                }
                else
                {
      	            result = Search(ppg->m_ppLinks[pos],thash, searchkey,ppkeypage,pos);
                }

                break;
            }
        }
    }

    return result;
}

template <class K, class D>
void BTree<K,D>::InsertKey(const K & inskey, const D* pdata)
{
    BTreePage<K,D>* pinspage = NULL;
    long inspos;
    BTreeNode<K,D> newnode(inskey, pdata);

    BOOL bFound = Search(m_pRoot,Hash(inskey), inskey,&pinspage,inspos);

    if (bFound)
    {
        BOOL found = FALSE;

        BTreeNode<K,D>* pnode = &(pinspage->m_pNodes[inspos]);
        BTreeNode<K,D>* pparent = NULL;

	if (CompFunc != NULL)
	{
	    while(pnode && !found)
	    {
                if (CompFunc(inskey, pnode->m_Key) == 0)
		{
		    found = TRUE;
		}
        
		pparent = pnode;
		pnode = pnode->m_pNext;
	    }
	}
	else
	{
	    while(pnode && !found)
	    {
                if (inskey == pnode->m_Key)
		{
		    found = TRUE;
		}
        
		pparent = pnode;
		pnode = pnode->m_pNext;
	    }
        }

        if (found)
        {
            return;
        }
    
        pparent->m_pNext = new BTreeNode<K,D>(inskey, pdata);

    }
    else
    {
        if (pinspage->m_hdr.NoOfKeys == pinspage->m_hdr.MaxKeys)
        {
            // temporary arrays
            BTreeNode<K,D>* ptempkeys = new BTreeNode<K,D>[pinspage->m_hdr.MaxKeys + 1];

            // copy entries from inspage to temporaries
            long nt = 0; // index into temporaries
            long ni = 0; // index into inspage

            ptempkeys[inspos] = newnode;

            while (ni < pinspage->m_hdr.MaxKeys)
            {
                if (ni == inspos)
                ++nt;

                ptempkeys[nt] = pinspage->m_pNodes[ni];

                ++ni;
                ++nt;
            }

            // generate a new leaf node
            BTreePage<K,D>* psibpage = new BTreePage<K,D>(pinspage->m_hdr.Order);
            psibpage->m_pParent = pinspage->m_pParent;

            // clear # of keys in pages
            pinspage->m_hdr.NoOfKeys = 0;
            psibpage->m_hdr.NoOfKeys = 0;

            // copy appropriate keys from temp to pages
            for (ni = 0; ni < pinspage->m_hdr.MinKeys; ++ni)
            {
                pinspage->m_pNodes[ni] = ptempkeys[ni];

                ++pinspage->m_hdr.NoOfKeys;
            }

            for (ni = pinspage->m_hdr.MinKeys + 1; ni <= pinspage->m_hdr.MaxKeys; ++ni)
            {
                psibpage->m_pNodes[ni - 1 - pinspage->m_hdr.MinKeys] = ptempkeys[ni];
                ++(psibpage->m_hdr.NoOfKeys);
            }

            // Fill any remaining entries in inspage with null.
            // Note that sibpage is initialized to null values
            // by the constructor.

            for (ni = pinspage->m_hdr.MinKeys; ni < pinspage->m_hdr.MaxKeys; ++ni)
            {
                memset((void*)&pinspage->m_pNodes[ni],0,sizeof(BTreeNode<K,D>));
            }

            // promote key and pointer
            if (!pinspage->m_pParent)
            {
                // we need to create a new root
                PromoteRoot(ptempkeys[pinspage->m_hdr.MinKeys], pinspage, psibpage);
            }
            else
            {
                BTreePage<K,D>* pparpage;

                pparpage = pinspage->m_pParent;

                // promote into parent
                PromoteInternal(pparpage, ptempkeys[pinspage->m_hdr.MinKeys], psibpage);
            }

            delete [] ptempkeys;
        }
        else // simply insert new key and data ptr
        {
            for (long n = pinspage->m_hdr.NoOfKeys; n > inspos; --n)
            {
                pinspage->m_pNodes[n] = pinspage->m_pNodes[n - 1];
            }

            pinspage->m_pNodes[inspos] = newnode;

            ++pinspage->m_hdr.NoOfKeys;
        }
    }

}

template <class K, class D>
void BTree<K,D>::PromoteInternal(BTreePage<K,D>* pinspage, BTreeNode<K,D> & node, BTreePage<K,D>* pgrtrpage)
{
    if (pinspage->m_hdr.NoOfKeys == pinspage->m_hdr.MaxKeys)
    {
        // temporary arrays
        BTreeNode<K,D> * ptempkeys = new BTreeNode<K,D>[pinspage->m_hdr.MaxKeys + 1];
        BTreePage<K,D>** ptemplnks = new BTreePage<K,D>*[pinspage->m_hdr.Order   + 1];

        // copy entries from inspage to temporaries
        long nt = 0; // index into temporaries
        long ni = 0; // index into inspage

        ptemplnks[0] = pinspage->m_ppLinks[0];

        long inspos = 0;

        // find insertion position
        while ((inspos < pinspage->m_hdr.MaxKeys) 
        &&  (pinspage->m_pNodes[inspos].m_ulHash < node.m_ulHash))
        ++inspos;

        // store new info
        ptempkeys[inspos]     = node;
        ptemplnks[inspos + 1] = pgrtrpage;

        // copy existing keys
        while (ni < pinspage->m_hdr.MaxKeys)
        {
            if (ni == inspos)
                ++nt;

            ptempkeys[nt]     = pinspage->m_pNodes[ni];
            ptemplnks[nt + 1] = pinspage->m_ppLinks[ni + 1];

            ++ni;
            ++nt;
        }

        // generate a new leaf node
        BTreePage<K,D>* psibpage = new BTreePage<K,D>(pinspage->m_hdr.Order);

        psibpage->m_pParent = pinspage->m_pParent;

        // clear # of keys in pages
        pinspage->m_hdr.NoOfKeys = 0;
        psibpage->m_hdr.NoOfKeys = 0;

        pinspage->m_ppLinks[0] = ptemplnks[0];

        // copy appropriate keys from temp to pages
        for (ni = 0; ni < pinspage->m_hdr.MinKeys; ++ni)
        {
            pinspage->m_pNodes[ni]     = ptempkeys[ni];
            pinspage->m_ppLinks[ni + 1] = ptemplnks[ni + 1];

            ++pinspage->m_hdr.NoOfKeys;
        }

        psibpage->m_ppLinks[0] = ptemplnks[pinspage->m_hdr.MinKeys + 1];

        for (ni = pinspage->m_hdr.MinKeys + 1; ni <= pinspage->m_hdr.MaxKeys; ++ni)
        {
            psibpage->m_pNodes[ni - 1 - pinspage->m_hdr.MinKeys] = ptempkeys[ni];
            psibpage->m_ppLinks[ni - pinspage->m_hdr.MinKeys]     = ptemplnks[ni + 1];

            ++psibpage->m_hdr.NoOfKeys;
        }

        // Fill any remaining entries in inspage with null.
        // Note that sibpage is initialized to null values
        // by the constructor.

        for (ni = pinspage->m_hdr.MinKeys; ni < pinspage->m_hdr.MaxKeys; ++ni)
        {
            memset((void*)&pinspage->m_pNodes[ni],0, sizeof(BTreeNode<K,D>));
            pinspage->m_ppLinks[ni + 1] = NULL;
        }

        // update child parent links
        BTreePage<K,D>* pchild;

        for (ni = 0; ni <= psibpage->m_hdr.NoOfKeys; ++ni)
        {
            pchild = psibpage->m_ppLinks[ni];

            pchild->m_pParent= psibpage;

        }

        // promote key and pointer
        if (!pinspage->m_pParent)
        {
            // we need to create a new root
            PromoteRoot(ptempkeys[pinspage->m_hdr.MinKeys], pinspage, psibpage);
        }
        else
        {
            BTreePage<K, D>* pparpage;

            pparpage = pinspage->m_pParent;

            // promote into parent
            PromoteInternal(pparpage, ptempkeys[pinspage->m_hdr.MinKeys], psibpage);
        }

        delete [] ptempkeys;
        delete [] ptemplnks;
    }
    else // simply insert new key and data ptr
    {
        long inspos = 0;

        // find insertion position
        while ((inspos < pinspage->m_hdr.NoOfKeys) 
        && (pinspage->m_pNodes[inspos].m_ulHash < node.m_ulHash))
        ++inspos;

        // shift any keys right
        for (long n = pinspage->m_hdr.NoOfKeys; n > inspos; --n)
        {
            pinspage->m_pNodes[n]     = pinspage->m_pNodes[n - 1];
            pinspage->m_ppLinks[n + 1] = pinspage->m_ppLinks[n];
        }

        // store new info
        pinspage->m_pNodes[inspos]     = node;
        pinspage->m_ppLinks[inspos + 1] = pgrtrpage;

        ++pinspage->m_hdr.NoOfKeys;

    }
}

template <class K, class D>
void BTree<K,D>::PromoteRoot(BTreeNode<K,D> & node, BTreePage<K,D> * plesspage, BTreePage<K,D> * pgrtrpage)
{
    // create new root page
    BTreePage<K,D>* pnewroot = new BTreePage<K,D>(m_pRoot->m_hdr.Order);

    // insert key into new root
    pnewroot->m_pNodes[0] = node;

    pnewroot->m_ppLinks[0] = plesspage;
    pnewroot->m_ppLinks[1] = pgrtrpage;

    pnewroot->m_hdr.NoOfKeys = 1;

    m_pRoot = pnewroot;

    plesspage->m_pParent = m_pRoot;
    pgrtrpage->m_pParent = m_pRoot;

}

template <class K, class D>
void BTree<K,D>::AdjustTree(BTreePage<K,D>* ppg)
{
    if (!ppg->m_pParent)
        return;

    BTreePage<K,D>* pparpage = ppg->m_pParent;
    BTreePage<K,D>* psibless = NULL;
    BTreePage<K,D>* psibgrtr = NULL;

    // find pointer to pg in parent
    for (long n = 0; pparpage->m_ppLinks[n] != ppg; ++n)
    ;

    // read sibling pages
    if (n < pparpage->m_hdr.NoOfKeys)
        psibgrtr = pparpage->m_ppLinks[n + 1];

    if (n > 0)
        psibless = pparpage->m_ppLinks[n - 1];

    if (!psibgrtr && !psibless)
        return;

    // decide to redistribute or concatenate
    if (!psibgrtr || (psibgrtr && psibless && (psibless->m_hdr.NoOfKeys > psibgrtr->m_hdr.NoOfKeys)))
    {
        --n;

        if (psibless->m_hdr.NoOfKeys > psibless->m_hdr.MinKeys)
            Redistribute(n,psibless,pparpage,ppg);
        else
            Concatenate(n,psibless,pparpage,ppg);
    }
    else if (psibgrtr)
    {
        if (psibgrtr->m_hdr.NoOfKeys > psibgrtr->m_hdr.MinKeys)
            Redistribute(n,ppg,pparpage,psibgrtr);
        else
            Concatenate(n,ppg,pparpage,psibgrtr);
    }

}
    
template <class K, class D>
void BTree<K,D>::Redistribute(long keypos, BTreePage<K,D>* plesspage, BTreePage<K,D>* pparpage, BTreePage<K,D>* pgrtrpage)
{
    // note: this function is ONLY called for leaf nodes!
    long n;

    if (!plesspage->m_ppLinks[0]) // working with leaves
    {
        if (plesspage->m_hdr.NoOfKeys > pgrtrpage->m_hdr.NoOfKeys)
        {
            // slide a key from lesser to greater
            // move keys in greater to the left by one
            for (n = pgrtrpage->m_hdr.NoOfKeys; n > 0; --n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n - 1];
            }

            // store parent separator key in greater page
            pgrtrpage->m_pNodes[0] = pparpage->m_pNodes[keypos];

            // increment greater page's key count
            ++pgrtrpage->m_hdr.NoOfKeys;

            // decrement lessor page's key count
            --plesspage->m_hdr.NoOfKeys;

            // move last key in less page to parent as separator
            pparpage->m_pNodes[keypos] = plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys];

            // clear last key in less page
            memset((void*)&plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));
        }
        else
        {
            // slide a key from greater to lessor
            // add parent key to lessor page
            plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys] = pparpage->m_pNodes[keypos];

            // increment lessor page's key count
            ++plesspage->m_hdr.NoOfKeys;

            // insert in parent the lowest key in greater page
            pparpage->m_pNodes[keypos] = pgrtrpage->m_pNodes[0];

            // decrement # of keys in greater page
            --pgrtrpage->m_hdr.NoOfKeys;

            // move keys in greater page to left
            for (n = 0; n < pgrtrpage->m_hdr.NoOfKeys; ++n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n + 1];
            }

            // make last key blank
            memset((void*)&pgrtrpage->m_pNodes[n], 0, sizeof(BTreeNode<K,D>));
        }
    }
    else
    {
        if (plesspage->m_hdr.NoOfKeys > pgrtrpage->m_hdr.NoOfKeys)
        {
            // slide a key from lesser to greater
            // move keys in greater to the left by one
            for (n = pgrtrpage->m_hdr.NoOfKeys; n > 0; --n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n - 1];
                pgrtrpage->m_ppLinks[n + 1] = pgrtrpage->m_ppLinks[n];
            }

            pgrtrpage->m_ppLinks[1] = pgrtrpage->m_ppLinks[0];

            // store parent separator key in greater page
            pgrtrpage->m_pNodes[0] = pparpage->m_pNodes[keypos];
            pgrtrpage->m_ppLinks[0] = plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys];

            // update child link
            BTreePage<K,D>* pchild;

            pchild = pgrtrpage->m_ppLinks[0];

            pchild->m_pParent= pgrtrpage;

            // increment greater page's key count
            ++pgrtrpage->m_hdr.NoOfKeys;

            // decrement lessor page's key count
            --plesspage->m_hdr.NoOfKeys;

            // move last key in less page to parent as separator
            pparpage->m_pNodes[keypos] = plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys];

            // clear last key in less page
            memset((void*)&plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));
            plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys + 1] = NULL;
        }
        else
        {
            // slide a key from greater to lessor
            // add parent key to lessor page
            plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys] = pparpage->m_pNodes[keypos];
            plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys + 1] = pgrtrpage->m_ppLinks[0];

            // update child link
            BTreePage<K,D>* pchild;

            pchild = pgrtrpage->m_ppLinks[0];

            pchild->m_pParent = plesspage;

            // increment lessor page's key count
            ++plesspage->m_hdr.NoOfKeys;

            // insert in parent the lowest key in greater page
            pparpage->m_pNodes[keypos] = pgrtrpage->m_pNodes[0];

            // decrement # of keys in greater page
            --pgrtrpage->m_hdr.NoOfKeys;

            // move keys in greater page to left
            for (n = 0; n < pgrtrpage->m_hdr.NoOfKeys; ++n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n + 1];
                pgrtrpage->m_ppLinks[n] = pgrtrpage->m_ppLinks[n + 1];
            }

            pgrtrpage->m_ppLinks[n] = pgrtrpage->m_ppLinks[n + 1];

            // make last key blank
            memset((void*)&pgrtrpage->m_pNodes[n], 0, sizeof(BTreeNode<K,D>));
            pgrtrpage->m_ppLinks[n + 1] = NULL;
        }
    }

    if (!pparpage->m_pParent)
        m_pRoot = pparpage;
}
	
template <class K, class D>
void BTree<K,D>::Concatenate(long keypos, BTreePage<K,D>* plesspage, BTreePage<K,D>* pparpage, BTreePage<K,D>* pgrtrpage)
{
    long n, ng;

    // move separator key from parent into lesspage
    plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys] = pparpage->m_pNodes[keypos];
    plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys + 1] = pgrtrpage->m_ppLinks[0];

    ++plesspage->m_hdr.NoOfKeys;

    // delete separator from parent
    --pparpage->m_hdr.NoOfKeys;

    for (n = keypos; n < pparpage->m_hdr.NoOfKeys; ++n)
    {
        pparpage->m_pNodes[n] = pparpage->m_pNodes[n + 1];
        pparpage->m_ppLinks[n + 1] = pparpage->m_ppLinks[n + 2];
    }

    // clear unused key in parent
    memset((void*)&pparpage->m_pNodes[n], 0, sizeof(BTreeNode<K,D>));
    pparpage->m_ppLinks[n + 1] = NULL;

    // copy keys from grtrpage to lesspage
    ng = 0;
    n  = plesspage->m_hdr.NoOfKeys;

    while (ng < pgrtrpage->m_hdr.NoOfKeys)
    {
        ++plesspage->m_hdr.NoOfKeys;

        plesspage->m_pNodes[n] = pgrtrpage->m_pNodes[ng];
        memset((void*)&pgrtrpage->m_pNodes[ng], 0, sizeof(BTreeNode<K,D>));
        plesspage->m_ppLinks[n + 1] = pgrtrpage->m_ppLinks[ng + 1];
        pgrtrpage->m_ppLinks[ng + 1] = NULL;

        ++ng;
        ++n; 
    }

    delete pgrtrpage;

    // is this a leaf page?
    if (plesspage->m_ppLinks[0])
    {
        // adjust child pointers to point to less page
        BTreePage<K,D>* pchild;

        for (n = 0; n <= plesspage->m_hdr.NoOfKeys; ++n)
        {
            pchild = plesspage->m_ppLinks[n];

            pchild->m_pParent = plesspage;
        }
    }

    // write less page and parent
    if (pparpage->m_hdr.NoOfKeys == 0)
    {
        AdjustTree(pparpage);

        plesspage->m_pParent = pparpage->m_pParent;

        if (!plesspage->m_pParent)
            m_pRoot = plesspage;
        else
        {
            for (int n = 0; n <= pparpage->m_pParent->m_hdr.NoOfKeys; n++)
            {
                if (pparpage == pparpage->m_pParent->m_ppLinks[n])
                {
                    pparpage->m_pParent->m_ppLinks[n] = plesspage;
                    break;
                }
            }
            
        }

        delete pparpage;

    }
    else
    {
        // reset root page, if necessary
        if (!pparpage->m_pParent)
            m_pRoot = pparpage;

        // if parent is too small, adjust tree!
        if (pparpage->m_hdr.NoOfKeys < pparpage->m_hdr.MinKeys)
            AdjustTree(pparpage);
    }
}   

template <class K, class D>
void BTree<K,D>::RecurseTraverse(const BTreePage<K,D>* ppg, int depth)
{
    long n;
    BTreePage<K,D>* p = NULL;
    
    depth++;
    // sequence through keys in page, recursively processing links
    for (n = 0; n < ppg->m_hdr.NoOfKeys; ++n)
    {
        // follow each link before processing page
        if (ppg->m_ppLinks[n])
        {
            p = ppg->m_ppLinks[n];
            RecurseTraverse(p, depth);
            
        }

        int index = 0;

        BTreeNode<K,D>* p = &ppg->m_pNodes[n];

        while(p)
        {
            TravFunc(p->m_Key, p->m_pData, depth, index);
            index++;
            p = p->m_pNext;
        }

    }

    // handle greatest subtree link
    if ((ppg->m_ppLinks != NULL) && ppg->m_ppLinks[n])
    {
        p = ppg->m_ppLinks[n];
        RecurseTraverse(p, depth);
    }

}

template <class K, class D>
void BTree<K,D>::DeletePage(BTreePage<K,D>* ppg)
{
    long n;
    BTreePage<K,D>* p = NULL;

    if (!ppg)

        return;

    // sequence through keys in page, recursively processing links
    for (n = 0; n < ppg->m_hdr.NoOfKeys; ++n)
    {
        // follow each link before processing page
        if (ppg->m_ppLinks[n])
        {
            p = ppg->m_ppLinks[n];
            DeletePage(p);
            ppg->m_ppLinks[n] = NULL;
        }

    }

    // handle greatest subtree link
    if ((ppg->m_ppLinks != NULL) && ppg->m_ppLinks[n])
    {
        p = ppg->m_ppLinks[n];
        DeletePage(p);
        ppg->m_ppLinks[n] = NULL;
    }

    delete ppg;

}
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\cdf.h ===
#ifndef _DEFINED_CDF_H_
#define _DEFINED_CDF_H_

#define MAX_NODE_NAME      32
#define MAX_NODE_CLASS     64

// pack definition structures on a DWORD boundary to match VB Type definition aligment

#pragma pack(4)

typedef enum tagCONV_NODE_TYPE
{
   NODE_TYPE_PAGE,
   NODE_TYPE_CONVERSATION
} CONV_NODE_TYPE;

typedef struct tagCONV_HEADER
{
   DWORD dwVersion;
   DWORD cNodes;
   DWORD dwFirstNodeID;
   DWORD dwReserved1;
   DWORD dwReserved2;
} CONV_HEADER;

typedef struct tagCONV_NODE
{
   DWORD				   dwNodeID; // Not saved in file. NodeID = offset into file. Set on return from API
   char  				szName[MAX_NODE_NAME];
   char    				szClass[MAX_NODE_CLASS];   // TODO: Can we limit names and classes as such?
   DWORD				   dwReserved1;
   DWORD				   dwReserved2;
   DWORD				   dwReserved3;
   DWORD				   dwLinkCount;
// DWORD    			dwLink1;
// DWORD			      dwLink2;
// ...
// DWORD    			dwLinkN;
// etc.
} CONV_NODE;

//
// CDF File Format
//
// Header
//
//	Name Len
//	Name
//	Class Len
//	Class
//	Link Count
//	Link1
//	Link2
//	...
//	LinkN

#pragma pack()

// resource type name used for CDFs

#define CDF_RESOURCE_TYPE "__ICDF__"

// current version of CDF

#define CDF_VERSION 0

// File layout:
//
// header
// constructor node (no links)
// destructor node (no links)
// termination node (no links)
// OnError node
// first link of OnError node
// second link of OnError node
// ...
// nth link of OnError node
// first conversation node
// first link of first node
// second link of first node
// ...
// nth link of first node
// second conversation node
// first link of second node
// etc.
//
// File is always read and written sequentially

///////////////////////////////////////////////////////////////////
//////////////////////////// CDF API //////////////////////////////
///////////////////////////////////////////////////////////////////

// Functions for reading a CDF

extern "C" HRESULT WINAPI CDF_Open(LPTSTR pszFileName, HANDLE *phCDF);
extern "C" HRESULT WINAPI CDF_OpenFromResource(HANDLE hModule, LPCSTR pszResourceName, HANDLE *phCDF);

extern "C" HRESULT WINAPI CDF_GetVersion(HANDLE hCDF, DWORD *pdwVersion);
extern "C" HRESULT WINAPI CDF_GetNodeCount(HANDLE hCDF, DWORD *pdwNodeCount);

extern "C" HRESULT WINAPI CDF_GetFirstNode(HANDLE hCDF, CONV_NODE *pConvNode);
extern "C" HRESULT WINAPI CDF_GetNode(HANDLE hCDF, DWORD dwNodeID, CONV_NODE *pConvNode);
extern "C" HRESULT WINAPI CDF_GetLink(HANDLE hCDF, DWORD dwNodeID, DWORD dwIndex, CONV_NODE *pDestConvNode);

// Functions for writing a CDF

extern "C" HRESULT WINAPI CDF_Create(LPCTSTR pszFileName, HANDLE *phCDF);
extern "C" HRESULT WINAPI CDF_AddNode(HANDLE hCDF, LPSTR pszName, LPSTR pszClass);
extern "C" HRESULT WINAPI CDF_AddLink(HANDLE hCDF, LPSTR pszDestNode);

// Always close the CDF when finished reading or writing

extern "C" HRESULT WINAPI CDF_Close(HANDLE hCDF);

#endif	// _DEFINED_CDF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\autoobj.h ===
//=--------------------------------------------------------------------------=
// AutomationObject.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown and dispatch
// implementations for them.
//
#ifndef _AUTOMATIONOBJECT_H_

#include "Unknown.H"            // for aggregating unknown
#include <olectl.h>             // for connection point stuff

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// Misc constants
//=--------------------------------------------------------------------------=

// maximum number of arguments that can be sent to FireEvent()
//
#define MAX_ARGS    32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these
//
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1


//=--------------------------------------------------------------------------=
// Structures
//=--------------------------------------------------------------------------=

// describes an event
//
typedef struct tagEVENTINFO {

    DISPID    dispid;                    // dispid of the event
    int       cParameters;               // number of arguments to the event
    VARTYPE  *rgTypes;                   // type of each argument

} EVENTINFO;


// This is a helper structure that you can use to help verify that the
// Data1_ #define's match up with the interfaces they represent.
// In your code declare an array as follows:
//
//		#ifdef DEBUG
//
//			GUIDDATA1_COMPARE g_gdMyControl [] = {
//						{ Data1_MyControlInterface, &IID_IMyControlInterface.Data1 },
//						{ Data1_MySubObject, &IID_IMySubObject.Data1 },
//						{0, 0},												// Mark the end of the array
//						}; 
//		#endif
//
// In your InternalQueryInterface function, make a call to the framework
// helper function  DebugVerifyData1Guids as follows:
//
//		#ifdef DEBUG
//			DebugVerifyData1Guids(g_gdMyControl);
//		#endif
//
#ifdef DEBUG
	 
 struct GUIDDATA1_COMPARE
 {
	DWORD dwData1a;
	DWORD *pdwData1b;
 };

 void DebugVerifyData1Guids(GUIDDATA1_COMPARE *pGuidData1_Compare);

#endif

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable
    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
    long         lVersionMinor;                  // minor version number
    const IID   *riid;                           // object's type
    const IID   *riidEvents;                     // if it has events
    LPCSTR       pszHelpFile;                    // the helpfile for this automation object.
    ITypeInfo   *pTypeInfo;                      // typeinfo for this object
    UINT         cTypeInfo;                      // number of refs to the type info

} AUTOMATIONOBJECTINFO;

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.
//
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define VERSIONMINOROFOBJECT(index)    ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersionMinor
#define INTERFACEOFOBJECT(index)       (*(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid))
#define EVENTIIDOFOBJECT(index)        (*(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riidEvents))
#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile

#define ISVALIDEVENTIID(index)	       (((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riidEvents != NULL)

#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECTWEVENTS(name, clsid, objname, fn, ver, riid, piide, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECT2(name, clsid, objname, lblname, fn, ver, vermin, riid, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECTWEVENTS2(name, clsid, objname, lblname, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECT3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECTWEVENTS3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, NULL, TRUE, fn, NULL }, ver, 0, riid, NULL,  pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECTWEVENTS(name, clsid, objname, fn, ver, riid, piide, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, NULL, TRUE, fn, NULL }, ver, 0, riid, piide, pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECT2(name, clsid, objname, lblname, fn, ver, vermin, riid, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, NULL }, ver, vermin, riid, NULL,  pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECTWEVENTS2(name, clsid, objname, lblname, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, NULL }, ver, vermin, riid, piide, pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECT3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, precreatefn }, ver, vermin, riid, NULL,  pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECTWEVENTS3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, precreatefn }, ver, vermin, riid, piide, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
        return CAutomationObject::GetTypeInfoCount(pctinfo); \
    } \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
    } \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
    } \
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
    } \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
    } \


//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo
//
//
class CAutomationObject : public CUnknownObject  {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT *);
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    //  ISupportErrorInfo methods
    //
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

    CAutomationObject(IUnknown *, int , void *);
    virtual ~CAutomationObject();

    // callable functions -- things that most people will find useful.
    //
    virtual HINSTANCE GetResourceHandle(void);
    virtual HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);
    virtual HRESULT Exception(HRESULT hr, LPWSTR wszException, DWORD dwHelpContextID);

  protected:
    // member variables that derived objects might need to get at information in the
    // global object table
    //
    int   m_ObjectType;

#ifdef MDAC_BUILD
    const CLSID	*m_pTypeLibId;
#endif

  private:
    // member variables we don't share.
    //
    BYTE  m_fLoadedTypeInfo;
};


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents
//=--------------------------------------------------------------------------=
// a slightly modified version of CAutomationObject that supports event
// firing
//
class CAutomationObjectWEvents : public CAutomationObject,
                                 public IConnectionPointContainer {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // we have to declare this since IConnectionPointContainer inherits
    // from IUnknown
    //
    DECLARE_STANDARD_UNKNOWN();

    // IConnectionPointContainer methods
    //
    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    // how everybody will fire an event
    //
    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);

    // whether it's necessary to fire the event
    BOOL FFireEvent() { return m_cpEvents.m_rgSinks != NULL; }

    CAutomationObjectWEvents(IUnknown *, int , void *);
    virtual ~CAutomationObjectWEvents();

  protected:
    // nested class that will handle all of the connection point stuff
    //
    class CConnectionPoint : public IConnectionPoint {
      public:
        IUnknown **m_rgSinks;

        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
        STDMETHOD_(ULONG,AddRef)(THIS) ;
        STDMETHOD_(ULONG,Release)(THIS) ;

        // IConnectionPoint methods
        //
        STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
        void    DoOnChanged(DISPID dispid);
        BOOL    DoOnRequestEdit(DISPID dispid);
        HRESULT AddSink(void *, DWORD *);

        CAutomationObjectWEvents *m_pObject();
        CConnectionPoint(BYTE b){
            m_bType = b;
            m_rgSinks = NULL;
            m_cSinks = 0;
        }
        ~CConnectionPoint();

      private:
        BYTE   m_bType;
        short  m_cSinks;

    } m_cpEvents, m_cpPropNotify;

    // so they can get at some of our protected things, like AddRef, QI, etc.
    //
    friend CConnectionPoint;
};


#define _AUTOMATIONOBJECT_H_
#endif // _AUTOMATIONOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\csf.h ===
#ifndef _GLOBAL_WEBCLASS_CONSTANTS_
#define _GLOBAL_WEBCLASS_CONSTANTS_

#define WEBITEM_URL_PARAM_NAME                   "WCI"
#define WEBITEM_URL_PARAM_NAME_LEN               sizeof(WEBITEM_URL_PARAM_NAME)

#define WEBITEM_URL_PARAM_NAME_WIDE              L"WCI"
#define WEBITEM_URL_PARAM_NAME_WIDE_LEN          sizeof(WEBITEM_URL_PARAM_NAME_WIDE)

#define WEBITEM_INTERNAL_URL_PARAM_NAME          "WCIID"
#define WEBITEM_INTERNAL_URL_PARAM_NAME_LEN      sizeof(WEBITEM_INTERNAL_URL_PARAM_NAME)

#define WEBITEM_INTERNAL_URL_PARAM_NAME_WIDE     L"WCIID"
#define WEBITEM_INTERNAL_URL_PARAM_NAME_WIDE_LEN sizeof(WEBITEM_INTERNAL_URL_PARAM_NAME_WIDE)

#define EVENT_URL_PARAM_NAME                     "WCE"
#define EVENT_URL_PARAM_NAME_LEN                 sizeof(EVENT_URL_PARAM_NAME)

#define EVENT_URL_PARAM_NAME_WIDE                L"WCE"
#define EVENT_URL_PARAM_NAME_WIDE_LEN            sizeof(EVENT_URL_PARAM_NAME_WIDE)

#define EVENT_INTERNAL_URL_PARAM_NAME            "WCEID"
#define EVENT_INTERNAL_URL_PARAM_NAME_LEN        sizeof(EVENT_INTERNAL_URL_PARAM_NAME)

#define EVENT_INTERNAL_URL_PARAM_NAME_WIDE       L"WCEID"
#define EVENT_INTERNAL_URL_PARAM_NAME_WIDE_LEN   sizeof(EVENT_INTERNAL_URL_PARAM_NAME_WIDE)


#define PAGECLASS_URL_PARAM_NAME_WIDE	L"CPC"
#define PAGECLASS_URL_PARAM_NAME		"CPC"

#define CONVCLASS_URL_PARAM_NAME_WIDE	L"CCC"
#define CONVCLASS_URL_PARAM_NAME		"CCC"

#define INTERNAL_PAGENAME_URL_PARAM_NAME_WIDE	L"WCIID"
#define INTERNAL_PAGENAME_URL_PARAM_NAME		"WCIID"

#define EXTERNAL_PAGENAME_URL_PARAM_NAME_WIDE	L"WCI"
#define EXTERNAL_PAGENAME_URL_PARAM_NAME		"WCI"

#define CONVNAME_URL_PARAM_NAME_WIDE	L"CCN"
#define CONVNAME_URL_PARAM_NAME			"CCN"

#define SEQNO_URL_PARAM_NAME			"CSN"
#define SEQNO_URL_PARAM_NAME_WIDE		L"CSN"

#define NOTRANS_URL_PARAM_NAME			"WCNOTRANS"
#define NOTRANS_URL_PARAM_NAME_WIDE		L"WCNOTRANS"

#define STACKID_URL_PARAM_NAME_WIDE		L"SID"

#define NODEID_URL_PARAM_NAME_WIDE		L"ICNODEID"

#define MAX_EVENT_LEN	256

#define	EMBEDDED_GET_SENTINEL_WIDE			L"ICGET"

#define	HYPERLINK_SENTINEL_WIDE				L"WCE"
#define	INTERNAL_HYPERLINK_SENTINEL_WIDE	L"WCEID"
#define	EXTERNAL_HYPERLINK_SENTINEL_WIDE	L"WCE"

#define	SUBMIT_SENTINEL_WIDE				L"ICSUBMIT_"

#define  CUSTOM_EVENT_SENTINEL_WIDE    L"ICEVENT"

#define	MAX_ERROR_DESCRIPTION				256

#define MAX_CLASS_SIZE						64
#define MAX_NAME_SIZE						64

#define REGDB_CONVERSATIONS_PATH			TEXT("SOFTWARE\\Microsoft\\Visual Basic\\6.0\\WebClass")
#define REGDB_TRACE_MASK_VALUE			    TEXT("TraceMask")
#define REGDB_DEF_TEMPLATES_DIR_VALUE       "DefaultTemplateDirectory"
#define REGDB_DEF_TEMPLATES_DIR_VALUE_WIDE  L"DefaultTemplateDirectory"

#define MAX_SEQNO_LEN                       16

#define URL_MUNGING_TOKEN                   "^@^"
#define URL_MUNGING_TOKEN_WIDE              L"^@^"

#define URL_MAX_LEN  256							// Max chars in URL

// DEFINE_GUID(CATID_WebClass, );

// {74E7D75E-3826-11d1-9C70-00C04FB987DF}
const GUID CATID_WebClass =
{ 0xcbc5d810, 0x1856, 0x11d1, { 0xb8, 0x1, 0x0, 0xa0, 0xd1, 0x0, 0x37, 0xe4  } };

#define WC_DEBUG_START_PARAM	"WCDEBUG"
#define WC_DEBUG_START_PARAM_WIDE	L"WCDEBUG"

#define ASP_EXT		    ".ASP"
#define ASP_EXT_LEN		sizeof(ASP_EXT)

#define ASP_EXT_WIDE        L".ASP"
#define ASP_EXT_WIDE_LEN    sizeof(ASP_EXT_WIDE_LEN)

// Note first char must reamin a uniuqe char
//
#define URL_DATA_PARAM_NAME	        "WCU"
#define URL_DATA_PARAM_NAME_WIDE	L"WCU"
#define URL_DATA_PARAM_NAME_LEN 	sizeof("WCU") - 1

#define MAX_WEBITEMS                512
#define HIAVG_WEBITEMS              64

#endif // _GLOBAL_WEBCLASS_CONSTANTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\ctrlobj.h ===
//=--------------------------------------------------------------------------=
// ControlObject.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the COleControl object
//
#ifndef _CONTROLOBJECT_H_

// we need the automation object and ctlole.h
//
#include "AutoObj.H"
#include "Macros.H"

// For VC++ 4.2 include files and above, all OCX96.H declarations are in OCIDL.H
// For VB 5.0 build tools, we must include OCX96.H to get this declares.
//
#ifndef __ocidl_h__
#include "ocx96.h"
#endif

// These are the original QA structures.  We preserve the declarations here
// because if the structure size changes (i.e., gets larger) in OCIDL.H
// then controls will begin to fail QuickActivate when hosted on older 
// containers.
//
typedef struct  tagQACONTAINER_OLD
    {
    ULONG cbSize;
    IOleClientSite __RPC_FAR *pClientSite;
    IAdviseSinkEx __RPC_FAR *pAdviseSink;
    IPropertyNotifySink __RPC_FAR *pPropertyNotifySink;
    IUnknown __RPC_FAR *pUnkEventSink;
    DWORD dwAmbientFlags;
    OLE_COLOR colorFore;
    OLE_COLOR colorBack;
    IFont __RPC_FAR *pFont;
    IOleUndoManager __RPC_FAR *pUndoMgr;
    DWORD dwAppearance;
    LONG lcid;
    HPALETTE hpal;
    struct IBindHost __RPC_FAR *pBindHost;
    }	QACONTAINER_OLD;

typedef struct  tagQACONTROL_OLD
    {
    ULONG cbSize;
    DWORD dwMiscStatus;
    DWORD dwViewStatus;
    DWORD dwEventCookie;
    DWORD dwPropNotifyCookie;
    DWORD dwPointerActivationPolicy;
    }	QACONTROL_OLD;


// forward declaration
//
class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.
//
COleControl *ControlFromUnknown(IUnknown *);


//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// superclass window support.  you can pass this in to DoSuperClassPaint
//
#define DRAW_SENDERASEBACKGROUND        1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number.  Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.
//
#define CTLIVERB_PROPERTIES     1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.
//
typedef struct tagVERBINFO {

    LONG    lVerb;                // verb id
    ULONG   idVerbName;           // resource ID of verb name
    DWORD   fuFlags;              // verb flags
    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.  the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information
    DWORD           dwOleMiscFlags;                // control flags
    DWORD           dwActivationPolicy;            // IPointerInactive support
    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque?
    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can?
    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap
    LPCSTR          szWndClass;                    // name of window control class
    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet?
    WORD            cPropPages;                    // number of property pages
    const GUID    **rgPropPageGuids;               // array of the property page GUIDs
    WORD            cCustomVerbs;                  // number of custom verbs
    const VERBINFO *rgCustomVerbs;                 // description of custom verbs
    WNDPROC         pfnSubClass;                   // for subclassed controls.    
} CONTROLOBJECTINFO;


#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_CONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_CONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, NULL, TRUE, fn, NULL}, ver, 0, riid, piide, pszh, NULL, 0}, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, NULL, TRUE, fn, NULL}, ver, 0, riid, piide, pszh, NULL, 0}, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_CONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, NULL}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_WINDOWLESSCONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, NULL}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_CONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, precreatefn}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_WINDOWLESSCONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, precreatefn}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass

//=--------------------------------------------------------------------------=
// IControlPrv
//=--------------------------------------------------------------------------=
// Interface which allows you to access the COleControl class pointer to
// a control
//
interface IControlPrv : IUnknown
{
	STDMETHOD(GetControl)(COleControl **ppCOleControl) PURE;
};

//=--------------------------------------------------------------------------=
// COleControl
//=--------------------------------------------------------------------------=
// the mother of all C++ objects
//
class COleControl : public CAutomationObjectWEvents, 
                    public IOleObject, public IOleControl,
                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject,
                    public IViewObjectEx, public IPersistPropertyBag,
                    public IPersistStreamInit, public IPersistStorage,
                    public ISpecifyPropertyPages, public IProvideClassInfo,
                    public IPointerInactive, public IQuickActivate,
					public IControlPrv
{
  public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.  just delegate to controlling
    // unknown
    //
    DECLARE_STANDARD_UNKNOWN();

    //=--------------------------------------------------------------------------=
    // IPersist methods.  used by IPersistStream and IPersistStorage
    //
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

    // IPersistStreamInit methods
    //
    STDMETHOD(IsDirty)(THIS);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
    STDMETHOD(InitNew)();

    // IPersistStorage
    //
    STDMETHOD(InitNew)(IStorage  *pStg);
    STDMETHOD(Load)(IStorage  *pStg);
    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

    // IPersistPropertyBag
    //
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    // IOleControl methods
    //
    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
    STDMETHOD(OnMnemonic)(LPMSG pMsg);
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
    STDMETHOD(FreezeEvents)(BOOL bFreeze);

    // IOleObject methods
    //
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                                     HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID  *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject
    //
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceObject/IOleInPlaceObjectWindowless
    //
    STDMETHOD(InPlaceDeactivate)(void);
    STDMETHOD(UIDeactivate)(void);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    STDMETHOD(ReactivateAndUndo)(void);
    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                            IOleInPlaceUIWindow  *pUIWindow,
                            BOOL fFrameWindow);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IViewObject2/IViewObjectEx
    //
    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw,
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                    BOOL ( __stdcall  *pfnContinue )(DWORD dwContinue),
                    DWORD dwContinue);
    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                           DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                           LOGPALETTE  * *ppColorSet);
    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                      void  *pvAspect,DWORD  *pdwFreeze);
    STDMETHOD(Unfreeze)(DWORD dwFreeze);
    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
    STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

    // ISpecifyPropertyPages
    //
    STDMETHOD(GetPages)(CAUUID * pPages);

    // IProvideClassInfo methods
    //
    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

    // IPointerInactive methods
    //
    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

    // IQuickActivate methods
    //
    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
    STDMETHOD(SetContentExtent)(LPSIZEL);
    STDMETHOD(GetContentExtent)(LPSIZEL);

	// IControlPrv methods
	STDMETHOD(GetControl)(COleControl **pOleControl);

    // constructor and destructor
    //
    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface);
    virtual ~COleControl();

    //=--------------------------------------------------------------------------=
    // callable by anybody
    //
    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ParkingWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    // You can use this in any parent window to support message reflection 
    //
    static BOOL ReflectOcmMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *pLResult);

    static COleControl * ControlFromHwnd(HWND hwnd) {
        return (COleControl *) GetWindowLong(hwnd, GWL_USERDATA);
    }

    HINSTANCE    GetResourceHandle(void);

    //=--------------------------------------------------------------------------=
    // ole controls that want to support both windowed and windowless operations
    // should use these wrappers instead of the appropriate win32 api routine.
    // controls that don't care and just want to be windowed all the time can
    // just go ahead and use the api routines.
    //
    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API
    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd
    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect
    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc
    HDC     OcxGetDC(void);                             // GetDC(m_hwnd);
    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc);
    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL);
    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd
    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f);
    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...);

	// little routine for people to tell if they are windowless or not
    //
    inline BOOL  Windowless(void) {
        return !m_fInPlaceActive || m_pInPlaceSiteWndless;
    }

    // some people don't care if they're windowed or not -- they just need
    // a site pointer.  this makes it a little easier.
    //
    inline IOleInPlaceSite    *GetInPlaceSite(void) {
        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
	}

  protected:

    //=--------------------------------------------------------------------------=
    // member variables that derived controls can get at.
    //
    // derived controls Should NOT modify the following.
    //
    IOleClientSite     *m_pClientSite;             // client site
    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site
    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation
    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client
    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site
    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer
    SIZEL               m_Size;                    // the size of this control    
    RECT                m_rcLocation;              // where we at
    HWND                m_hwnd;                    // our window
    HWND                m_hwndParent;              // our parent window

    // You may need this if you override ::Save
    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object

    // Windowless OLE controls support
    //
    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

    // flags indicating internal state.  do not modify.
    //
    unsigned m_fDirty:1;                           // does the control need to be resaved?
    unsigned m_fInPlaceActive:1;                   // are we in place active or not?
    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not?
    unsigned m_fUIActive:1;                        // are we UI active or not.
    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not
    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly?

    //=--------------------------------------------------------------------------=
    // methods that derived controls can override, but may need to be called
    // from their versions.
    //
    virtual void      ViewChanged(void);
    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual void      BeforeDestroyObject(void);

    //=--------------------------------------------------------------------------=
    // member functions that provide for derived controls, or that we use, but
    // derived controls might still find useful.
    //
    HRESULT      DoSuperClassPaint(HDC, LPCRECTL);
    HRESULT      RecreateControlWindow(void);
    BOOL         DesignMode(void);
    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *);
    BOOL         GetAmbientFont(IFont **ppFontOut);
    void         ModalDialog(BOOL fShow);
    void         InvalidateControl(LPCRECT prc);    
    BOOL         SetControlSize(SIZEL *pSizel);

    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
    HRESULT      InPlaceActivate(LONG lVerb);
    void         SetInPlaceVisible(BOOL);
    void         SetInPlaceParent(HWND);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.DoOnChanged(dispid);
    }
    inline BOOL  RequestPropertyEdit(DISPID dispid) {
        return m_cpPropNotify.DoOnRequestEdit(dispid);
    }

    // subclassed windows controls support ...
    //
    inline HWND  GetOuterWindow(void) {
        return (m_hwndReflect) ? m_hwndReflect : m_hwnd;
    }

  private:
    //=--------------------------------------------------------------------------=
    // the following are methods that ALL control writers must override and implement
    //
    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
    virtual BOOL    RegisterClassData(void) PURE;

    //=--------------------------------------------------------------------------=
    // OVERRIDABLES -- methods controls can implement for customized functionality
    //
    virtual void    AmbientPropertyChanged(DISPID dispid);
    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR);
    virtual void    BeforeDestroyWindow(void);
    virtual HRESULT DoCustomVerb(LONG lVerb);
    virtual BOOL    OnSetExtent(SIZEL *pSizeL);
    virtual BOOL    OnSpecialKey(LPMSG);
    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **);
    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
    virtual BOOL    InitializeNewState();
    virtual BOOL    AfterCreateWindow(void);
    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect);
    virtual HRESULT OnSetClientSite(void);

    //=--------------------------------------------------------------------------=
    // methods that various people internally will share.  not needed, however, by
    // any inherting classes.
    //
    HRESULT         m_SaveToStream(IStream *pStream);
    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    HRESULT         LoadStandardState(IStream *pStream);
    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag);
    HRESULT         SaveStandardState(IStream *pStream);

    //=--------------------------------------------------------------------------=
    // member variables we don't want anybody to get their hands on, including
    // inheriting classes
    //
    HWND              m_hwndReflect;               // for subclassed windows
    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2
    unsigned          m_fHostReflects:1;           // does the host reflect messages?
    unsigned          m_fCheckedReflecting:1;      // have we checked above yet?

    // internal flags.  various other flags are visible to the end control class.
    //
    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible
    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise
    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise
    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping
    unsigned m_fRunMode:1;                         // are we in run mode or not?
    unsigned m_fChangingExtents:1;		   // Prevent recursive SetExtent calls

};

#define _CONTROLOBJECT_H_
#endif // _CONTROLOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\datapath.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Wed May 22 16:53:08 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __datapath_h__
#define __datapath_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif 	/* __IBindHost_FWD_DEFINED__ */


#ifndef __IObjectWithSite_FWD_DEFINED__
#define __IObjectWithSite_FWD_DEFINED__
typedef interface IObjectWithSite IObjectWithSite;
#endif 	/* __IObjectWithSite_FWD_DEFINED__ */


#ifndef __IDataPathBrowser_FWD_DEFINED__
#define __IDataPathBrowser_FWD_DEFINED__
typedef interface IDataPathBrowser IDataPathBrowser;
#endif 	/* __IDataPathBrowser_FWD_DEFINED__ */


#ifndef __IProvideClassInfo3_FWD_DEFINED__
#define __IProvideClassInfo3_FWD_DEFINED__
typedef interface IProvideClassInfo3 IProvideClassInfo3;
#endif 	/* __IProvideClassInfo3_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "olectl.h"
#include "urlmon.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: datapath.h

#pragma comment(lib,"uuid3.lib")
//
//--------------------------------------------------------------------------
			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

#include "idispids.h"
typedef BSTR OLE_DATAPATH;
#define SID_SDataPathBrowser IID_IDataPathBrowser
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost

////////////////////////////////////////////////////////////////////////////
//  State values for the DISPID_READYSTATE property
			/* size is 4 */

enum __MIDL___MIDL__intf_0000_0001
    {	READYSTATE_UNINITIALIZED	= 1,
	READYSTATE_LOADING	= 0,
	READYSTATE_LOADED	= 2,
	READYSTATE_INTERACTIVE	= 3,
	READYSTATE_COMPLETE	= 4
    };

////////////////////////////////////////////////////////////////////////////
//  DataPath GUIDs (link to uuid3.lib)
EXTERN_C const GUID OLE_DATAPATH_BMP;
EXTERN_C const GUID OLE_DATAPATH_DIB;
EXTERN_C const GUID OLE_DATAPATH_WMF;
EXTERN_C const GUID OLE_DATAPATH_ENHMF;
EXTERN_C const GUID OLE_DATAPATH_GIF;
EXTERN_C const GUID OLE_DATAPATH_JPEG;
EXTERN_C const GUID OLE_DATAPATH_TIFF;
EXTERN_C const GUID OLE_DATAPATH_XBM;
EXTERN_C const GUID OLE_DATAPATH_PCX;
EXTERN_C const GUID OLE_DATAPATH_PICT;
EXTERN_C const GUID OLE_DATAPATH_CGM;
EXTERN_C const GUID OLE_DATAPATH_EPS;
EXTERN_C const GUID OLE_DATAPATH_COMMONIMAGE;
EXTERN_C const GUID OLE_DATAPATH_ALLIMAGE;
EXTERN_C const GUID OLE_DATAPATH_AVI;
EXTERN_C const GUID OLE_DATAPATH_MPEG;
EXTERN_C const GUID OLE_DATAPATH_QUICKTIME;
EXTERN_C const GUID OLE_DATAPATH_BASICAUDIO;
EXTERN_C const GUID OLE_DATAPATH_MIDI;
EXTERN_C const GUID OLE_DATAPATH_WAV;
EXTERN_C const GUID OLE_DATAPATH_RIFF;
EXTERN_C const GUID OLE_DATAPATH_SOUND;
EXTERN_C const GUID OLE_DATAPATH_VIDEO;
EXTERN_C const GUID OLE_DATAPATH_ALLMM;
EXTERN_C const GUID OLE_DATAPATH_ANSITEXT;
EXTERN_C const GUID OLE_DATAPATH_UNICODE;
EXTERN_C const GUID OLE_DATAPATH_RTF;
EXTERN_C const GUID OLE_DATAPATH_HTML;
EXTERN_C const GUID OLE_DATAPATH_POSTSCRIPT;
EXTERN_C const GUID OLE_DATAPATH_ALLTEXT;
EXTERN_C const GUID OLE_DATAPATH_DIF;
EXTERN_C const GUID OLE_DATAPATH_SYLK;
EXTERN_C const GUID OLE_DATAPATH_BIFF;
EXTERN_C const GUID OLE_DATAPATH_PALETTE;
EXTERN_C const GUID OLE_DATAPATH_PENDATA;
////////////////////////////////////////////////////////////////////////////

EXTERN_C const GUID FLAGID_Internet;
EXTERN_C const GUID GUID_PathProperty;
EXTERN_C const GUID GUID_HasPathProperties;

////////////////////////////////////////////////////////////////////////////
//  ARRAYID GUIDs (link to uuid3.lib)
EXTERN_C const GUID ARRAYID_PathProperties;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindHost
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IBindHost __RPC_FAR *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBindHost : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateMoniker( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT __stdcall MonikerBindToStorage( 
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
        virtual HRESULT __stdcall MonikerBindToObject( 
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindHostVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IBindHost __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IBindHost __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *CreateMoniker )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( __stdcall __RPC_FAR *MonikerBindToStorage )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        HRESULT ( __stdcall __RPC_FAR *MonikerBindToObject )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)	\
    (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved)

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)	\
    (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)	\
    (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IBindHost_CreateMoniker_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBindHost_CreateMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IBindHost_MonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindHost_MonikerBindToObject_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IBindHost_MonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindHost_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0100
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOBJECTWITHSITE_DEFINED
#define _LPOBJECTWITHSITE_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0100_v0_0_s_ifspec;

#ifndef __IObjectWithSite_INTERFACE_DEFINED__
#define __IObjectWithSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectWithSite
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][object][uuid] */ 


			/* size is 4 */
typedef /* [unique] */ IObjectWithSite __RPC_FAR *LPOBJECTWITHSITE;


EXTERN_C const IID IID_IObjectWithSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IObjectWithSite : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetSite( 
            /* [in] */ IUnknown __RPC_FAR *pUnkSite) = 0;
        
        virtual HRESULT __stdcall GetSite( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithSiteVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IObjectWithSite __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IObjectWithSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetSite )( 
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkSite);
        
        HRESULT ( __stdcall __RPC_FAR *GetSite )( 
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite);
        
    } IObjectWithSiteVtbl;

    interface IObjectWithSite
    {
        CONST_VTBL struct IObjectWithSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectWithSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectWithSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectWithSite_SetSite(This,pUnkSite)	\
    (This)->lpVtbl -> SetSite(This,pUnkSite)

#define IObjectWithSite_GetSite(This,riid,ppvSite)	\
    (This)->lpVtbl -> GetSite(This,riid,ppvSite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IObjectWithSite_SetSite_Proxy( 
    IObjectWithSite __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkSite);


void __RPC_STUB IObjectWithSite_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IObjectWithSite_GetSite_Proxy( 
    IObjectWithSite __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite);


void __RPC_STUB IObjectWithSite_GetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectWithSite_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0101
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPDATAPATHBROWSER_DEFINED
#define _LPDATAPATHBROWSER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0101_v0_0_s_ifspec;

#ifndef __IDataPathBrowser_INTERFACE_DEFINED__
#define __IDataPathBrowser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataPathBrowser
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_IDataPathBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDataPathBrowser : public IUnknown
    {
    public:
        virtual HRESULT __stdcall BrowseType( 
            /* [in] */ REFGUID rguidPathType,
            /* [in] */ LPOLESTR pszDefaultPath,
            /* [in] */ ULONG cchPath,
            /* [size_is][out] */ LPOLESTR pszPath,
            /* [in] */ HWND hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataPathBrowserVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDataPathBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDataPathBrowser __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDataPathBrowser __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *BrowseType )( 
            IDataPathBrowser __RPC_FAR * This,
            /* [in] */ REFGUID rguidPathType,
            /* [in] */ LPOLESTR pszDefaultPath,
            /* [in] */ ULONG cchPath,
            /* [size_is][out] */ LPOLESTR pszPath,
            /* [in] */ HWND hWnd);
        
    } IDataPathBrowserVtbl;

    interface IDataPathBrowser
    {
        CONST_VTBL struct IDataPathBrowserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataPathBrowser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataPathBrowser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataPathBrowser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataPathBrowser_BrowseType(This,rguidPathType,pszDefaultPath,cchPath,pszPath,hWnd)	\
    (This)->lpVtbl -> BrowseType(This,rguidPathType,pszDefaultPath,cchPath,pszPath,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDataPathBrowser_BrowseType_Proxy( 
    IDataPathBrowser __RPC_FAR * This,
    /* [in] */ REFGUID rguidPathType,
    /* [in] */ LPOLESTR pszDefaultPath,
    /* [in] */ ULONG cchPath,
    /* [size_is][out] */ LPOLESTR pszPath,
    /* [in] */ HWND hWnd);


void __RPC_STUB IDataPathBrowser_BrowseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataPathBrowser_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0102
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPPROVIDECLASSINFO3_DEFINED
#define _LPPROVIDECLASSINFO3_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0102_v0_0_s_ifspec;

#ifndef __IProvideClassInfo3_INTERFACE_DEFINED__
#define __IProvideClassInfo3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo3
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IProvideClassInfo3 __RPC_FAR *LPPROVIDECLASSINFO3;

			/* size is 4 */

enum __MIDL_IProvideClassInfo3_0001
    {	INTERNETFLAG_USESDATAPATHS	= 0x1
    };

EXTERN_C const IID IID_IProvideClassInfo3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo3 : public IProvideClassInfo2
    {
    public:
        virtual HRESULT __stdcall GetGUIDDwordArrays( 
            /* [in] */ REFGUID rguidArray,
            /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
            /* [out][in] */ CADWORD __RPC_FAR *pcadw) = 0;
        
        virtual HRESULT __stdcall GetClassInfoLocale( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT __stdcall GetFlags( 
            /* [in] */ REFGUID guidGroup,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfo3Vtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideClassInfo3 __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideClassInfo3 __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUIDDwordArrays )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID rguidArray,
            /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
            /* [out][in] */ CADWORD __RPC_FAR *pcadw);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfoLocale )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
            /* [in] */ LCID lcid);
        
        HRESULT ( __stdcall __RPC_FAR *GetFlags )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidGroup,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
    } IProvideClassInfo3Vtbl;

    interface IProvideClassInfo3
    {
        CONST_VTBL struct IProvideClassInfo3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo3_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideClassInfo3_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideClassInfo3_GetGUIDDwordArrays(This,rguidArray,pcaUUID,pcadw)	\
    (This)->lpVtbl -> GetGUIDDwordArrays(This,rguidArray,pcaUUID,pcadw)

#define IProvideClassInfo3_GetClassInfoLocale(This,ppITypeInfo,lcid)	\
    (This)->lpVtbl -> GetClassInfoLocale(This,ppITypeInfo,lcid)

#define IProvideClassInfo3_GetFlags(This,guidGroup,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,guidGroup,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideClassInfo3_GetGUIDDwordArrays_Proxy( 
    IProvideClassInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID rguidArray,
    /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
    /* [out][in] */ CADWORD __RPC_FAR *pcadw);


void __RPC_STUB IProvideClassInfo3_GetGUIDDwordArrays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideClassInfo3_GetClassInfoLocale_Proxy( 
    IProvideClassInfo3 __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
    /* [in] */ LCID lcid);


void __RPC_STUB IProvideClassInfo3_GetClassInfoLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideClassInfo3_GetFlags_Proxy( 
    IProvideClassInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID guidGroup,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IProvideClassInfo3_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo3_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0103
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0103_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0103_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\depfile.inc ===
; Dependency file for setup wizards.

// This include file is included at the beginning of every .dep template
// file (.tpl).  Remember that the customers will see anything that is
// not commented out using C++ or C-style comments.
//
// Include version information from dwinvers.h
#include "dwinvers.h"
//
// Define a version string
#define MAKEVERSION(aa,bb,cc,dd) aa.bb.cc.dd
//
// Default version string
#define VERSION MAKEVERSION(vusMajorVer,vusMinorVer,vusVersNumf2,vusVersNuml2)



// declare language ID's
//
//
// Note: for most of these, we use the primary language ID,
//  : and NOT the full language ID (the exceptions being
//  : CHT/CHS).
//
#define ID_ENGLISH 0009
#define ID_GERMAN 0007
#define ID_FRENCH 000C
#define ID_ITALIAN 0010
#define ID_SPANISH 000A
#define ID_JAPANESE 0011
#define ID_KOREAN 0012
#define ID_CHT 0404
#define ID_CHS 0804



// locale abbreviations
//
//
// The following are the standard localized DLL names:
//
// English:               EN
// German:                DE
// French:                FR
// Italian:               IT
// Spanish:               ES
// Japanese:              JP
// Korean:                KO
// Chinese Traditional:   CHT
// Chinese Simplified:    CHS


// ***************************************************************************
// Standard Internet keys
// ***************************************************************************
#define INTERNET_VB5(a) \
	CABFileName=a ## .cab					      {NEWL} \
	CABDefaultURL=http:{DOUBLESLASH}activex.microsoft.com/controls/vb5  {NEWL} \
	CABINFFile=a ## .inf

#define INTERNET(a) \
	CABFileName=a ## .cab					      {NEWL} \
	CABDefaultURL=http:{DOUBLESLASH}activex.microsoft.com/controls/vb6  {NEWL} \
	CABINFFile=a ## .inf


// ***************************************************************************
// Defines a single language DLL section.  Use this only
// if your component has only a single satellite DLL.
// ***************************************************************************
#define SATELLITE_1(basename, baselocname, langabbrev, langid, langfullname) \
; ** langfullname (langabbrev) ***				      {NEWL} \
; (langid = langfullname)					      {NEWL} \
;								      {NEWL} \
[basename <langid>]						      {NEWL} \
Uses1=baselocname ## langabbrev ## .dll				      {NEWL} \
Uses2=								      {NEWL} \
								      {NEWL} \
[baselocname ## langabbrev ## .dll <langid>]			      {NEWL} \
Uses1=								      {NEWL} \
INTERNET(baselocname ## langabbrev)				      {NEWL}


// ***************************************************************************
// Defines all language satellite DLL sections.  Use this only
// if your component has only a single satellite DLL.
// ***************************************************************************
#define SATELLITE_DLLS(component, baselocname) \
SATELLITE_1(component, baselocname, DE, ID_GERMAN, German)	      {NEWL} \
SATELLITE_1(component, baselocname, FR, ID_FRENCH, French)	      {NEWL} \
SATELLITE_1(component, baselocname, IT, ID_ITALIAN, Italian)	      {NEWL} \
SATELLITE_1(component, baselocname, ES, ID_SPANISH, Spanish)	      {NEWL} \
SATELLITE_1(component, baselocname, JP, ID_JAPANESE, Japanese)	      {NEWL} \
SATELLITE_1(component, baselocname, KO, ID_KOREAN, Korean)	      {NEWL} \
SATELLITE_1(component, baselocname, CHT, ID_CHT, Chinese Traditional) {NEWL} \
SATELLITE_1(component, baselocname, CHS, ID_CHS, Chinese Simplified)  {NEWL}


// ***************************************************************************
// Standard section for ComCat.dll
// ***************************************************************************
#define STD_COMCAT_SECTION \
/* BUG #5-28738,stephwe,11/96: Include ComCat.dll as a dependence     {NEWL} \
   of all our shipped ctls */					      {NEWL} \
								      {NEWL} \
/* Note that we are *not* including this file in any of the cab files {NEWL} \
   because IE3.0 can't download it if in use, which it will be */     {NEWL} \
								      {NEWL} \
/* NOTE: This section is repeated in vb6dep.ini.  Please keep them in {NEWL} \
   sync. */							      {NEWL} \
								      {NEWL} \
[ComCat.dll]							      {NEWL} \
Dest=$(WinSysPathSysFile)					      {NEWL} \
Register=$(DLLSelfRegister)					      {NEWL} \
Uses1=								      {NEWL}


// ***************************************************************************
// The entire contents of a standard dependency file for a component
// without any dependencies other than a localized DLL using the standard
// language abbreviations, self-registerable, and going into windows\system
// ***************************************************************************

#define STD_DEP_FILE_ONLY_SATELLITE_DEPENDENCE(component, basename, baselocname) \
; Dependencies for component					      {NEWL} \
								      {NEWL} \
								      {NEWL} \
; Default Dependencies ---------------------------------------------- {NEWL} \
								      {NEWL} \
								      {NEWL} \
[component]							      {NEWL} \
Dest=$(WinSysPath)						      {NEWL} \
Register=$(DLLSelfRegister)					      {NEWL} \
Version=VERSION							      {NEWL} \
Uses1=ComCat.dll/*BUG #5-28738,stephwe,11/96 */			      {NEWL} \
Uses2=								      {NEWL} \
INTERNET(basename)						      {NEWL} \
								      {NEWL} \
STD_COMCAT_SECTION	  					      {NEWL} \
								      {NEWL} \
; Localized Dependencies -------------------------------------------- {NEWL} \
								      {NEWL} \
								      {NEWL} \
SATELLITE_DLLS(component, baselocname)



// ***************************************************************************


// VERSION INFORMATION!
// This is the version for the .dep file *itself*.  It goes at the top of every .dep file
[Version]
Version=VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE               (-525)
#define DISPID_READYSTATECHANGE         (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY (-728)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);
VOID SetCtlSwitches (LPSTR lpFileName);


// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#if !defined(SZTHISFILE)
#define SZTHISFILE	static char _szThisFile[] = __FILE__;
#endif //!defined(SZTHISFILE)


// our versions of the ASSERT and FAIL macros.
//
#if !defined(ASSERT)
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }
#endif //!defined(ASSERT)

#if !defined(FAIL)
#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }
#endif //!defined(FAIL)



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadReadPtr((void *)(val), sizeof(void *))) { FAIL("Pointer is NULL"); }

//////
// CCritSec
// ~~~~~~~~
//   This is a class to help track down whether a critical section has been left
//   using a LeaveCriticalSection or not.
//
class CCritSec
{
public:
    CCritSec(CRITICAL_SECTION *CritSec);
    ~CCritSec();

    // methods
    void Left(void);

private:
    // variables
    BOOL  m_fLeft;
    CRITICAL_SECTION *m_pCriticalSection;
}; // CCritSec

#define ENTERCRITICALSECTION1(CriticalSection) CCritSec DebugCriticalSection1(CriticalSection)
#define LEAVECRITICALSECTION1(CriticalSection) DebugCriticalSection1.Left()
#define ENTERCRITICALSECTION2(CriticalSection) CCritSec DebugCriticalSection2(CriticalSection)
#define LEAVECRITICALSECTION2(CriticalSection) DebugCriticalSection2.Left()
#define ENTERCRITICALSECTION3(CriticalSection) CCritSec DebugCriticalSection3(CriticalSection)
#define LEAVECRITICALSECTION3(CriticalSection) DebugCriticalSection3.Left()

#else  // DEBUG

#if !defined(SZTHISFILE)
#define SZTHISFILE
#endif //!defined(SZTHISFILE)

#if !defined(ASSERT)
#define ASSERT(fTest, err)
#endif //!defined(ASSERT)

#if !defined(FAIL)
#define FAIL(err)
#endif //!defined(FAIL)

#define CHECK_POINTER(val)

#define ENTERCRITICALSECTION1(CriticalSection) EnterCriticalSection(CriticalSection)
#define LEAVECRITICALSECTION1(CriticalSection) LeaveCriticalSection(CriticalSection)
#define ENTERCRITICALSECTION2(CriticalSection) EnterCriticalSection(CriticalSection)
#define LEAVECRITICALSECTION2(CriticalSection) LeaveCriticalSection(CriticalSection)
#define ENTERCRITICALSECTION3(CriticalSection) EnterCriticalSection(CriticalSection)
#define LEAVECRITICALSECTION3(CriticalSection) LeaveCriticalSection(CriticalSection)

// Force compile errors when OutputDebugString used in Retail builds
#ifndef USE_OUTPUTDEBUGSTRING_IN_RETAIL
#undef OutputDebugString
#define OutputDebugString(s)
#endif

#endif	// DEBUG

#define _DEBUG_H_
#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\ipserver.h ===
//=--------------------------------------------------------------------------=
// InProcServer.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _INPROCSERVER_H_

#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>

#ifdef VC4_BUILD
    typedef BOOL bool;
    #define false FALSE
    #define true  TRUE
#endif

// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=
//
void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);


//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *__pUnk = (ptr); (ptr) = NULL; __pUnk->Release(); }
#define QUICK_RELEASE(ptr)     if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface
//
#define Data1_IActiveDesigner              0x51AAE3E0
#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95                  0x9a4bbfb5
#define Data1_IControl                     0xa7fddba0
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataFrame                   0x97F254E0
#define Data1_IDataFrameExpert             0x73687490
#define Data1_IDataObject                  0x0000010e
#define Data1_IDispatch                    0x00020400
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoActions          0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IFormExpert                  0x5aac7f70
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMsoCommandTarget            0xb722bccb
#define Data1_IMsoDocument                 0xb722bcc5
#define Data1_IOleInPlaceComponent         0x5efc7970
#define Data1_IMsoView                     0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleCompoundUndoAction       0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoAction               0x894ad3b0
#define Data1_IOleUndoActionManager        0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideDynamicClassInfo     0x468cfb80
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10
#define Data1_IObjectSafety                0xcb5bdc81

#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))   \
      {                                     \
        itf *pITF = pObj;                   \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#define SAFE_CAST(varDest, varSrc, type) \
    { type var = varSrc; varDest = (type)varSrc; }



#define _INPROCSERVER_H_
#endif // _INPROCSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

// the library that we are
//
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// support for licensing
//
extern BOOL   g_fMachineHasLicense;
extern BOOL   g_fCheckedForLicense;

extern const BOOL g_fUseRuntimeLicInCompositeCtl;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
extern BOOL   g_fServerHasTypeLibrary;

//=--------------------------------------------------------------------------=
// our instance handle, and various pieces of information interesting to
// localization
//
extern HINSTANCE    g_hInstance;

extern const VARIANT_BOOL g_fSatelliteLocalization;

#ifdef MDAC_BUILD
    extern VARIANT_BOOL g_fSatelliteLangExtension;
#endif

extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// critical section for our heap memory leak detection
//
extern CRITICAL_SECTION g_csHeap;
extern BOOL g_fInitCrit;
extern BOOL g_flagConstructorAlloc;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
extern HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
extern BOOL g_fSysWin95;                    // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;                    // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
extern BOOL g_fDBCSEnabled;					// system is DBCS enabled

//Vegas 21279 - joejo
//=--------------------------------------------------------------------------=
// OleAut Library Handle
//
#ifdef MDAC_BUILD
extern HINSTANCE g_hOleAutHandle;
#else
extern HANDLE 	 g_hOleAutHandle;
#endif
//Vegas 21279 - joejo

//=-------------------------------------------------------------------------------
//  Control Debug Switch implementation
//=-------------------------------------------------------------------------------
//---------------------------------------------------------------------------
// The following macros allow you declare global BOOL variables that are only
// included in the debug build (they map to FALSE in the retail build).  
// These boolean switches are automatically persisted (in %WINDIR%\ctlswtch.ini) 
// and a console app (ctlswtch.exe) is used to turn on/off the switches.
// All switches must be initialized.  This can be done in the InitializeLibrary()
// routine of each control.  All switches are initialized to FALSE using the
// INIT_SWITCH macro, and to TRUE using the INIT_SWITCH_TRUE macro.
//
//                     
// To declare a switch (global scope), define and intialize the switch e.g.
//
//
//  DEFINE_SWITCH(fContainer);
//
// AND,
//
//  INIT_SWITCH(fContainer);
//
//
// To test whether a switch is currently set (TRUE), use FSWITCH, e.g.
//
//  if (FSWITCH(fContainer))
//    *ppv = (IOleContainer*)this;
//
//
// To reference a switch declared in another file, use EXTERN_SWITCH, e.g.
//
//  EXTERN_SWITCH(fContainer);
//
// AND
//
//  INIT_SWITCH(fContainer);
//---------------------------------------------------------------------------
#if DEBUG

// private implementation; use SWITCH macros below to declare and use
class CtlSwitch {
public:
  void InitSwitch(char * pszName);

  BOOL m_fSet;			    // TRUE if switch is enabled
  char * m_pszName;		    // name of the switch
  CtlSwitch* m_pctlswNext;          // next switch in global list
  static CtlSwitch* g_pctlswFirst;  // head of global list
};

#define DEFINE_SWITCH(NAME)	    CtlSwitch g_Switch_ ## NAME;
#define INIT_SWITCH(NAME)	    g_Switch_ ## NAME . InitSwitch(#NAME);
#define EXTERN_SWITCH(NAME)	    extern CtlSwitch g_Switch_ ## NAME;
#define INIT_SWITCH_TRUE(NAME)      g_Switch_ ## NAME . InitSwitch(#NAME);  g_Switch_ ## NAME . m_fSet = TRUE;
#define FSWITCH(NAME)		    (g_Switch_ ## NAME . m_fSet)


#else //DEBUG

#define DEFINE_SWITCH(NAME) 
#define INIT_SWITCH(NAME)
#define EXTERN_SWITCH(NAME) 
#define INIT_SWITCH_TRUE(NAME)
#define FSWITCH(NAME)		    FALSE

#endif //DEBUG


#define _GLOBALS_H_
#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\ksalpha.h ===
#include "kxalpha.h"

//
// Process State Enumerated Type Values
//

#define ProcessInMemory 0x0
#define ProcessOutOfMemory 0x1
#define ProcessInTransition 0x2

//
// Thread State Enumerated Type Values
//

#define Initialized 0x0
#define Ready 0x1
#define Running 0x2
#define Standby 0x3
#define Terminated 0x4
#define Waiting 0x5

//
// Wait Reason Enumerated Type Values
//

#define WrEventPair 0xe

//
// Apc State Structure Offset Definitions
//

#define AsApcListHead 0x0
#define AsProcess 0x10
#define AsKernelApcInProgress 0x14
#define AsKernelApcPending 0x15
#define AsUserApcPending 0x16

//
// Critical Section Structure Offset Definitions
//

#define CsLockCount 0x4
#define CsRecursionCount 0x8
#define CsOwningThread 0xc

//
// Dispatcher Context Structure Offset Definitions
//

#define DcControlPc 0x0
#define DcFunctionEntry 0x4
#define DcEstablisherFrame 0x8
#define DcContextRecord 0xc

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0xc
#define ErNumberParameters 0x10
#define ErExceptionInformation 0x14
#define ExceptionRecordLength 0x50

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x4
#define FmContention 0x8
#define FmEvent 0xc
#define FmOldIrql 0x1c

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x4

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x4

//
// Processor Control Registers Structure Offset Definitions
//

#define PCR_MINOR_VERSION 0x1
#define PCR_MAJOR_VERSION 0x1
#define PcMinorVersion 0x0
#define PcMajorVersion 0x4
#define PcPalBaseAddress 0x8
#define PcPalMajorVersion 0x10
#define PcPalMinorVersion 0x14
#define PcPalSequenceVersion 0x18
#define PcPalMajorSpecification 0x1c
#define PcPalMinorSpecification 0x20
#define PcFirmwareRestartAddress 0x28
#define PcRestartBlock 0x30
#define PcPalReserved 0x38
#define PcPanicStack 0xc38
#define PcProcessorType 0xc3c
#define PcProcessorRevision 0xc40
#define PcPhysicalAddressBits 0xc44
#define PcMaximumAddressSpaceNumber 0xc48
#define PcPageSize 0xc4c
#define PcFirstLevelDcacheSize 0xc50
#define PcFirstLevelDcacheFillSize 0xc54
#define PcFirstLevelIcacheSize 0xc58
#define PcFirstLevelIcacheFillSize 0xc5c
#define PcFirmwareRevisionId 0xc60
#define PcSystemType 0xc64
#define PcSystemVariant 0xc6c
#define PcSystemRevision 0xc70
#define PcSystemSerialNumber 0xc74
#define PcCycleClockPeriod 0xc84
#define PcSecondLevelCacheSize 0xc88
#define PcSecondLevelCacheFillSize 0xc8c
#define PcThirdLevelCacheSize 0xc90
#define PcThirdLevelCacheFillSize 0xc94
#define PcFourthLevelCacheSize 0xc98
#define PcFourthLevelCacheFillSize 0xc9c
#define PcPrcb 0xca0
#define PcNumber 0xca4
#define PcSetMember 0xca8
#define PcHalReserved 0xcb0
#define PcIrqlTable 0xeb0
#define PcIrqlMask 0xed0
#define PcInterruptRoutine 0x10e0
#define PcReservedVectors 0x14e0
#define PcMachineCheckError 0x14f0
#define PcDpcStack 0x14f4
#define PcNotMember 0x14e4
#define PcCurrentPid 0x14fc
#define PcSystemServiceDispatchStart 0x1504
#define PcSystemServiceDispatchEnd 0x1508
#define PcIdleThread 0x150c
#define ProcessorControlRegisterLength 0x1510
#define SharedUserData 0xff000000
#define UsTickCountLow 0x0
#define UsTickCountMultiplier 0x4
#define UsInterruptTime 0x8
#define UsSystemTime 0x10

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x2
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x4
#define PbNextThread 0x8
#define PbIdleThread 0xc
#define PbNumber 0x10
#define PbBuildType 0x12
#define PbSetMember 0x14
#define PbRestartBlock 0x18
#define PbInterruptCount 0x1c
#define PbDpcTime 0x20
#define PbInterruptTime 0x24
#define PbKernelTime 0x28
#define PbUserTime 0x2c
#define PbQuantumEndDpc 0x30
#define PbIpiFrozen 0x5c
#define PbIpiCounts 0x310
#define PbProcessorState 0x60
#define PbAlignmentFixupCount 0x334
#define PbContextSwitches 0x338
#define PbDcacheFlushCount 0x33c
#define PbExceptionDispatchcount 0x340
#define PbFirstLevelTbFills 0x344
#define PbFloatingEmulationCount 0x348
#define PbIcacheFlushCount 0x34c
#define PbSecondLevelTbFills 0x350
#define PbSystemCalls 0x354
#define PbCurrentPacket 0x380
#define PbTargetSet 0x38c
#define PbWorkerRoutine 0x390
#define PbRequestSummary 0x3c0
#define PbSignalDone 0x3c4
#define PbDpcListHead 0x468
#define PbDpcLock 0x470
#define PbDpcCount 0x474
#define PbLastDpcCount 0x290
#define PbQuantumEnd 0x478
#define PbStartCount 0x460
#define PbSoftwareInterrupts 0x298
#define PbInterruptActive 0x29c
#define PbDpcRoutineActive 0x47c
#define PbDpcQueueDepth 0x480
#define PbDpcRequestRate 0x45c
#define PbDpcBypassCount 0x294
#define PbApcBypassCount 0x2a0
#define PbDispatchInterruptCount 0x2a4
#define PbDpcInterruptRequested 0x400
#define PbMaximumDpcQueueDepth 0x450
#define PbMinimumDpcRate 0x454
#define PbAdjustDpcThreshold 0x458
#define ProcessorBlockLength 0x490

//
// Immediate Interprocessor Command Definitions
//

#define IPI_APC 0x1
#define IPI_DPC 0x2
#define IPI_FREEZE 0x4
#define IPI_PACKET_READY 0x8

//
// Interprocessor Interrupt Count Structure Offset Definitions
//

#define IcFreeze 0x0
#define IcPacket 0x4
#define IcDPC 0x8
#define IcAPC 0xc
#define IcFlushSingleTb 0x10
#define IcFlushEntireTb 0x18
#define IcChangeColor 0x20
#define IcSweepDcache 0x24
#define IcSweepIcache 0x28
#define IcSweepIcacheRange 0x2c
#define IcFlushIoBuffers 0x30

//
// Thread Environment Block Structure Offset Definitions
//

#define TeStackBase 0x4
#define TeStackLimit 0x8
#define TeEnvironmentPointer 0x1c
#define TeClientId 0x20
#define TeActiveRpcHandle 0x28
#define TeThreadLocalStoragePointer 0x2c
#define TePeb 0x30
#define TeSoftFpcr 0xc8
#define TeCsrQlpcStack 0x44
#define TeGdiClientPID 0x6f4
#define TeGdiClientTID 0x6f8
#define TeGdiThreadLocalInfo 0x6fc
#define TeglDispatchTable 0x714
#define TeglSectionInfo 0xbe0
#define TeglSection 0xbe4
#define TeglTable 0xbe8
#define TeglCurrentRC 0xbec
#define TeglContext 0xbf0
#define PebKernelCallbackTable 0x2c

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// APC object Structure Offset Definitions
//

#define ApType 0x0
#define ApSize 0x2
#define ApThread 0x8
#define ApApcListEntry 0xc
#define ApKernelRoutine 0x14
#define ApRundownRoutine 0x18
#define ApNormalRoutine 0x1c
#define ApNormalContext 0x20
#define ApSystemArgument1 0x24
#define ApSystemArgument2 0x28
#define ApApcStateIndex 0x2c
#define ApApcMode 0x2d
#define ApInserted 0x2e

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpDpcListEntry 0x4
#define DpDeferredRoutine 0xc
#define DpDeferredContext 0x10
#define DpSystemArgument1 0x14
#define DpSystemArgument2 0x18
#define DpLock 0x1c

//
// Device object Structure Offset Definitions
//

#define DvType 0x0
#define DvSize 0x2
#define DvDeviceListHead 0x4
#define DvSpinLock 0xc
#define DvBusy 0x10

//
// Device queue entry Structure Offset Definitions
//

#define DeDeviceListEntry 0x0
#define DeSortKey 0x8
#define DeInserted 0xc

//
// Event Structure Offset Definitions
//

#define EvType 0x0
#define EvSize 0x2
#define EvSignalState 0x4
#define EvWaitListHead 0x8

//
// Event Pair Structure Offset Definitions
//

#define EpType 0x0
#define EpSize 0x2
#define EpEventLow 0x4
#define EpEventHigh 0x14

//
// Interrupt Object Structure Offset Definitions
//

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x4
#define InServiceRoutine 0xc
#define InServiceContext 0x10
#define InSpinLock 0x14
#define InActualLock 0x18
#define InDispatchAddress 0x1c
#define InVector 0x20
#define InIrql 0x24
#define InSynchronizeIrql 0x25
#define InMode 0x2c
#define InNumber 0x28
#define InFloatingSave 0x26
#define InConnected 0x27
#define InDispatchCode 0x34
#define InLevelSensitive 0x0
#define InLatched 0x1

//
// Process Object Structure Offset Definitions
//

#define PrProfileListHead 0x10
#define PrReadyListHead 0x2c
#define PrSwapListEntry 0x34
#define PrThreadListHead 0x3c
#define PrKernelTime 0x24
#define PrUserTime 0x28
#define PrDirectoryTableBase 0x18
#define PrActiveProcessors 0x20
#define PrAffinity 0x48
#define PrStackCount 0x4c
#define PrAutoAlignment 0x50
#define PrBasePriority 0x4e
#define PrState 0x51
#define PrThreadQuantum 0x4f
#define ProcessObjectLength 0x60

//
// Queue Object Structure Offset Definitions
//

#define QuEntryListHead 0x10
#define QuThreadListHead 0x10
#define QuCurrentCount 0x18
#define QuMaximumCount 0x1c

//
// Profile Object Structure Offset Definitions
//

#define PfType 0x0
#define PfSize 0x2
#define PfProfileListEntry 0x4
#define PfProcess 0xc
#define PfRangeBase 0x10
#define PfRangeLimit 0x14
#define PfBucketShift 0x18
#define PfBuffer 0x1c
#define PfStarted 0x2a
#define PfSource 0x28
#define PfAffinity 0x24

//
// Thread Object Structure Offset Definitions
//

#define EeKernelEventPair 0x0
#define EtEventPair 0x224
#define EtPerformanceCountLow 0x204
#define EtPerformanceCountHigh 0x23c
#define EtEthreadLength 0x240
#define ThMutantListHead 0x10
#define ThInitialStack 0x18
#define ThStackLimit 0x1c
#define ThKernelStack 0x20
#define ThTeb 0x24
#define ThDebugActive 0x28
#define ThState 0x29
#define ThAlerted 0x2a
#define ThApcState 0x30
#define ThContextSwitches 0x48
#define ThWaitStatus 0x4c
#define ThWaitIrql 0x50
#define ThWaitMode 0x51
#define ThWaitNext 0x52
#define ThWaitReason 0x53
#define ThWaitBlockList 0x54
#define ThWaitListEntry 0x58
#define ThWaitTime 0x60
#define ThBasePriority 0x64
#define ThDecrementCount 0x65
#define ThPriorityDecrement 0x66
#define ThQuantum 0x67
#define ThWaitBlock 0x68
#define ThQueue 0xe0
#define ThTimer 0xe8
#define ThQueueListEntry 0x110
#define ThAffinity 0x118
#define ThPreempted 0x11c
#define ThProcessReadyQueue 0x11d
#define ThKernelStackResident 0x11e
#define ThNextProcessor 0x11f
#define ThCallbackStack 0x120
#define ThWin32Thread 0x124
#define ThTrapFrame 0x128
#define ThApcStatePointer 0x12c
#define ThKernelApcDisable 0x134
#define ThLargeStack 0x135
#define ThPriority 0x2f
#define ThPreviousMode 0x137
#define ThKernelTime 0x138
#define ThUserTime 0x13c
#define ThSavedApcState 0x140
#define ThAlertable 0x158
#define ThApcStateIndex 0x159
#define ThApcQueueable 0x15a
#define ThAutoAlignment 0x15b
#define ThStackBase 0x15c
#define ThSuspendApc 0x160
#define ThSuspendSemaphore 0x190
#define ThThreadListEntry 0x1a4
#define ThFreezeCount 0x1ac
#define ThSuspendCount 0x1ad
#define ThreadObjectLength 0x1b0
#define EVENT_WAIT_BLOCK_OFFSET 0xb0

//
// Timer object Structure Offset Definitions
//

#define TiDueTime 0x10
#define TiTimerListEntry 0x18
#define TiDpc 0x20
#define TiInserted 0x24
#define TIMER_TABLE_SIZE 0x80

//
// Wait Block Structure Offset Definitions
//

#define WbWaitListEntry 0x0
#define WbThread 0x8
#define WbObject 0xc
#define WbNextWaitBlock 0x10
#define WbWaitKey 0x14
#define WbWaitType 0x16

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x20007
#define CONTEXT_CONTROL 0x20001
#define CONTEXT_FLOATING_POINT 0x20002
#define CONTEXT_INTEGER 0x20004

#define CxFltF0 0x0
#define CxFltF1 0x8
#define CxFltF2 0x10
#define CxFltF3 0x18
#define CxFltF4 0x20
#define CxFltF5 0x28
#define CxFltF6 0x30
#define CxFltF7 0x38
#define CxFltF8 0x40
#define CxFltF9 0x48
#define CxFltF10 0x50
#define CxFltF11 0x58
#define CxFltF12 0x60
#define CxFltF13 0x68
#define CxFltF14 0x70
#define CxFltF15 0x78
#define CxFltF16 0x80
#define CxFltF17 0x88
#define CxFltF18 0x90
#define CxFltF19 0x98
#define CxFltF20 0xa0
#define CxFltF21 0xa8
#define CxFltF22 0xb0
#define CxFltF23 0xb8
#define CxFltF24 0xc0
#define CxFltF25 0xc8
#define CxFltF26 0xd0
#define CxFltF27 0xd8
#define CxFltF28 0xe0
#define CxFltF29 0xe8
#define CxFltF30 0xf0
#define CxFltF31 0xf8
#define CxIntV0 0x100
#define CxIntT0 0x108
#define CxIntT1 0x110
#define CxIntT2 0x118
#define CxIntT3 0x120
#define CxIntT4 0x128
#define CxIntT5 0x130
#define CxIntT6 0x138
#define CxIntT7 0x140
#define CxIntS0 0x148
#define CxIntS1 0x150
#define CxIntS2 0x158
#define CxIntS3 0x160
#define CxIntS4 0x168
#define CxIntS5 0x170
#define CxIntFp 0x178
#define CxIntA0 0x180
#define CxIntA1 0x188
#define CxIntA2 0x190
#define CxIntA3 0x198
#define CxIntA4 0x1a0
#define CxIntA5 0x1a8
#define CxIntT8 0x1b0
#define CxIntT9 0x1b8
#define CxIntT10 0x1c0
#define CxIntT11 0x1c8
#define CxIntRa 0x1d0
#define CxIntT12 0x1d8
#define CxIntAt 0x1e0
#define CxIntGp 0x1e8
#define CxIntSp 0x1f0
#define CxIntZero 0x1f8
#define CxFpcr 0x200
#define CxSoftFpcr 0x208
#define CxFir 0x210
#define CxPsr 0x218
#define CxContextFlags 0x21c
#define ContextFrameLength 0x230

//
// Exception Frame Offset Definitions and Length
//

#define ExFltF2 0x8
#define ExFltF3 0x10
#define ExFltF4 0x18
#define ExFltF5 0x20
#define ExFltF6 0x28
#define ExFltF7 0x30
#define ExFltF8 0x38
#define ExFltF9 0x40
#define ExIntS0 0x48
#define ExIntS1 0x50
#define ExIntS2 0x58
#define ExIntS3 0x60
#define ExIntS4 0x68
#define ExIntS5 0x70
#define ExIntFp 0x78
#define ExPsr 0x88
#define ExSwapReturn 0x80
#define ExIntRa 0x0
#define ExceptionFrameLength 0xa0

//
// Jump Offset Definitions and Length
//

#define JbFp 0x0
#define JbPc 0x4
#define JbSeb 0x8
#define JbType 0xc
#define JbFltF2 0x10
#define JbFltF3 0x18
#define JbFltF4 0x20
#define JbFltF5 0x28
#define JbFltF6 0x30
#define JbFltF7 0x38
#define JbFltF8 0x40
#define JbFltF9 0x48
#define JbIntS0 0x50
#define JbIntS1 0x58
#define JbIntS2 0x60
#define JbIntS3 0x68
#define JbIntS4 0x70
#define JbIntS5 0x78
#define JbIntS6 0x80
#define JbIntSp 0x88
#define JbFir 0x90

//
// Trap Frame Offset Definitions and Length
//

#define TrFltF0 0x128
#define TrFltF1 0x138
#define TrFltF10 0x140
#define TrFltF11 0x148
#define TrFltF12 0x150
#define TrFltF13 0x158
#define TrFltF14 0x160
#define TrFltF15 0x168
#define TrFltF16 0x170
#define TrFltF17 0x178
#define TrFltF18 0x180
#define TrFltF19 0x188
#define TrFltF20 0x190
#define TrFltF21 0x198
#define TrFltF22 0x1a0
#define TrFltF23 0x1a8
#define TrFltF24 0x1b0
#define TrFltF25 0x1b8
#define TrFltF26 0x1c0
#define TrFltF27 0x1c8
#define TrFltF28 0x1d0
#define TrFltF29 0x1d8
#define TrFltF30 0x1e0
#define TrIntV0 0xa0
#define TrIntT0 0xa8
#define TrIntT1 0xb0
#define TrIntT2 0xb8
#define TrIntT3 0xc0
#define TrIntT4 0xc8
#define TrIntT5 0xd0
#define TrIntT6 0xd8
#define TrIntT7 0xe0
#define TrIntFp 0x18
#define TrIntA0 0x20
#define TrIntA1 0x28
#define TrIntA2 0x30
#define TrIntA3 0x38
#define TrIntA4 0x118
#define TrIntA5 0x120
#define TrIntT8 0xe8
#define TrIntT9 0xf0
#define TrIntT10 0xf8
#define TrIntT11 0x100
#define TrIntT12 0x108
#define TrIntAt 0x110
#define TrIntGp 0x48
#define TrIntSp 0x0
#define TrFpcr 0x130
#define TrPsr 0x10
#define TrPreviousKsp 0x14
#define TrFir 0x8
#define TrExceptionRecord 0x50
#define TrOldIrql 0x1e8
#define TrPreviousMode 0x1ec
#define TrIntRa 0x40
#define TrTrapFrame 0x1f0
#define TrapFrameLength 0x200

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x8
#define LpbKernelStack 0x18
#define LpbPrcb 0x1c
#define LpbProcess 0x20
#define LpbThread 0x24
#define LpbRegistryLength 0x28
#define LpbRegistryBase 0x2c
#define LpbDpcStack 0x60
#define LpbFirstLevelDcacheSize 0x64
#define LpbFirstLevelDcacheFillSize 0x68
#define LpbFirstLevelIcacheSize 0x6c
#define LpbFirstLevelIcacheFillSize 0x70
#define LpbGpBase 0x74
#define LpbPanicStack 0x78
#define LpbPcrPage 0x7c
#define LpbPdrPage 0x80
#define LpbSecondLevelDcacheSize 0x84
#define LpbSecondLevelDcacheFillSize 0x88
#define LpbSecondLevelIcacheSize 0x8c
#define LpbSecondLevelIcacheFillSize 0x90
#define LpbPhysicalAddressBits 0x94
#define LpbMaximumAddressSpaceNumber 0x98
#define LpbSystemSerialNumber 0x9c
#define LpbSystemType 0xac
#define LpbSystemVariant 0xb4
#define LpbSystemRevision 0xb8
#define LpbProcessorType 0xbc
#define LpbProcessorRevision 0xc0
#define LpbCycleClockPeriod 0xc4
#define LpbPageSize 0xc8
#define LpbRestartBlock 0xcc
#define LpbFirmwareRestartAddress 0xd0
#define LpbFirmwareRevisionId 0xd8
#define LpbPalBaseAddress 0xdc

//
// Client/Server data structure definitions.
//

#define CidUniqueProcess 0x0
#define CidUniqueThread 0x4
#define CsrlClientThread 0x0
#define CsrlMessageStack 0xc

//
//  System Service Descriptor Table structure definitions.
//

#define NUMBER_SERVICE_TABLES 0x2
#define SERVICE_NUMBER_MASK 0xfff
#define SERVICE_TABLE_SHIFT 0x8
#define SERVICE_TABLE_MASK 0x10
#define SdBase 0x0
#define SdCount 0x4
#define SdLimit 0x8
#define SdNumber 0xc

//
// Restart Block Structure Definitions
//

#define RbSignature 0x0
#define RbLength 0x4
#define RbVersion 0x8
#define RbRevision 0xa
#define RbNextRestartBlock 0xc
#define RbRestartAddress 0x10
#define RbBootMasterId 0x14
#define RbProcessorId 0x18
#define RbBootStatus 0x1c
#define RbCheckSum 0x20
#define RbSaveAreaLength 0x24
#define RbSaveArea 0x28
#define RbHaltReason 0x28
#define RbLogoutFrame 0x2c
#define RbPalBase 0x30
#define RbIntV0 0x38
#define RbIntT0 0x40
#define RbIntT1 0x48
#define RbIntT2 0x50
#define RbIntT3 0x58
#define RbIntT4 0x60
#define RbIntT5 0x68
#define RbIntT6 0x70
#define RbIntT7 0x78
#define RbIntS0 0x80
#define RbIntS1 0x88
#define RbIntS2 0x90
#define RbIntS3 0x98
#define RbIntS4 0xa0
#define RbIntS5 0xa8
#define RbIntFp 0xb0
#define RbIntA0 0xb8
#define RbIntA1 0xc0
#define RbIntA2 0xc8
#define RbIntA3 0xd0
#define RbIntA4 0xd8
#define RbIntA5 0xe0
#define RbIntT8 0xe8
#define RbIntT9 0xf0
#define RbIntT10 0xf8
#define RbIntT11 0x100
#define RbIntRa 0x108
#define RbIntT12 0x110
#define RbIntAT 0x118
#define RbIntGp 0x120
#define RbIntSp 0x128
#define RbIntZero 0x130
#define RbFpcr 0x138
#define RbFltF0 0x140
#define RbFltF1 0x148
#define RbFltF2 0x150
#define RbFltF3 0x158
#define RbFltF4 0x160
#define RbFltF5 0x168
#define RbFltF6 0x170
#define RbFltF7 0x178
#define RbFltF8 0x180
#define RbFltF9 0x188
#define RbFltF10 0x190
#define RbFltF11 0x198
#define RbFltF12 0x1a0
#define RbFltF13 0x1a8
#define RbFltF14 0x1b0
#define RbFltF15 0x1b8
#define RbFltF16 0x1c0
#define RbFltF17 0x1c8
#define RbFltF18 0x1d0
#define RbFltF19 0x1d8
#define RbFltF20 0x1e0
#define RbFltF21 0x1e8
#define RbFltF22 0x1f0
#define RbFltF23 0x1f8
#define RbFltF24 0x200
#define RbFltF25 0x208
#define RbFltF26 0x210
#define RbFltF27 0x218
#define RbFltF28 0x220
#define RbFltF29 0x228
#define RbFltF30 0x230
#define RbFltF31 0x238
#define RbAsn 0x240
#define RbGeneralEntry 0x244
#define RbIksp 0x248
#define RbInterruptEntry 0x24c
#define RbKgp 0x250
#define RbMces 0x254
#define RbMemMgmtEntry 0x258
#define RbPanicEntry 0x25c
#define RbPcr 0x260
#define RbPdr 0x264
#define RbPsr 0x268
#define RbReiRestartAddress 0x26c
#define RbSirr 0x270
#define RbSyscallEntry 0x274
#define RbTeb 0x278
#define RbThread 0x27c
#define RbPerProcessorState 0x280

//
// Address Space Layout Definitions
//

#define KSEG0_BASE 0x80000000
#define KSEG2_BASE 0xc0000000
#define SYSTEM_BASE 0xc0800000
#define PDE_BASE 0xc0180000
#define PTE_BASE 0xc0000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x18
#define PTI_SHIFT 0xd

//
// Interrupt Priority Request Level Definitions
//

#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0x6
#define POWER_LEVEL 0x7
#define HIGH_LEVEL 0x7

//
// Bug Check Code Definitions
//

#define DATA_BUS_ERROR 0x2e
#define INSTRUCTION_BUS_ERROR 0x2f
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define NO_USER_MODE_CONTEXT 0xe
#define PANIC_STACK_SWITCH 0x2b
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x0
#define KERNEL_BREAKPOINT 0x1
#define BREAKIN_BREAKPOINT 0x19
#define DEBUG_PRINT_BREAKPOINT 0x14
#define DEBUG_PROMPT_BREAKPOINT 0x15
#define DEBUG_STOP_BREAKPOINT 0x16
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 0x17
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 0x18

//
// Trap Code Definitions
//

#define GENTRAP_INTEGER_OVERFLOW 0xffffffff
#define GENTRAP_INTEGER_DIVIDE_BY_ZERO 0xfffffffe
#define GENTRAP_FLOATING_OVERFLOW 0xfffffffd
#define GENTRAP_FLOATING_DIVIDE_BY_ZERO 0xfffffffc
#define GENTRAP_FLOATING_UNDERFLOW 0xfffffffb
#define GENTRAP_FLOATING_INVALID_OPERAND 0xfffffffa
#define GENTRAP_FLOATING_INEXACT_RESULT 0xfffffff9

//
// Status Code Definitions
//

#define STATUS_SUCCESS 0x0
#define STATUS_ALPHA_MACHINE_CHECK 0xdfff002e
#define STATUS_ACCESS_VIOLATION 0xc0000005
#define STATUS_GUARD_PAGE_VIOLATION 0x80000001
#define STATUS_STACK_OVERFLOW 0xc00000fd
#define STATUS_IN_PAGE_ERROR 0xc0000006
#define STATUS_DATATYPE_MISALIGNMENT 0x80000002
#define STATUS_INVALID_OWNER 0xc000005a
#define STATUS_INVALID_SYSTEM_SERVICE 0xc000001c
#define STATUS_ILLEGAL_INSTRUCTION 0xc000001d
#define STATUS_KERNEL_APC 0x100
#define STATUS_BREAKPOINT 0x80000003
#define STATUS_SINGLE_STEP 0x80000004
#define STATUS_INTEGER_OVERFLOW 0xc0000095
#define STATUS_INVALID_LOCK_SEQUENCE 0xc000001e
#define STATUS_INSTRUCTION_MISALIGNMENT 0xc00000aa
#define STATUS_FLOAT_STACK_CHECK 0xc0000092
#define STATUS_NO_EVENT_PAIR 0xc000014e
#define STATUS_INTEGER_DIVIDE_BY_ZERO 0xc0000094
#define STATUS_INVALID_PARAMETER_1 0xc00000ef
#define STATUS_UNWIND 0xc0000027
#define STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED 0xc000014a
#define STATUS_ALPHA_ARITHMETIC_EXCEPTION 0xc0000092
#define STATUS_ALPHA_GENTRAP 0xc00000aa
#define STATUS_ALPHA_BAD_VIRTUAL_ADDRESS 0xc0000005
#define STATUS_NO_CALLBACK_ACTIVE 0xc0000258
#define STATUS_BAD_COMPRESSION_BUFFER 0xc0000242

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define FALSE 0x0
#define TRUE 0x1
#define BASE_PRIORITY_THRESHOLD 0x8
#define EVENT_PAIR_INCREMENT 0x1
#define LOW_REALTIME_PRIORITY 0x10
#define MM_USER_PROBE_ADDRESS 0x7fff0000
#define KERNEL_STACK_SIZE 0x4000
#define KERNEL_LARGE_STACK_COMMIT 0x4000
#define SET_LOW_WAIT_HIGH 0xfffffffe
#define SET_HIGH_WAIT_LOW 0xffffffff
#define THREAD_QUANTUM 0x2
#define PROCESSOR_ALPHA_21064 0x5248
#define PROCESSOR_ALPHA_21164 0x52ac
#define PROCESSOR_ALPHA_21066 0x524a
#define PROCESSOR_ALPHA_21068 0x524c
#define PTE_VALID_MASK 0x1
#define PTE_VALID 0x0
#define PTE_OWNER_MASK 0x2
#define PTE_OWNER 0x1
#define PTE_DIRTY_MASK 0x4
#define PTE_DIRTY 0x2
#define PTE_GLOBAL_MASK 0x10
#define PTE_GLOBAL 0x4
#define PTE_WRITE_MASK 0x80
#define PTE_WRITE 0x7
#define PTE_COPYONWRITE_MASK 0x100
#define PTE_COPYONWRITE 0x8
#define PTE_PFN_MASK 0xfffffe00
#define PTE_PFN 0x9
#define PSR_MODE_MASK 0x1
#define PSR_USER_MODE 0x1
#define PSR_MODE 0x0
#define PSR_IE_MASK 0x2
#define PSR_IE 0x1
#define PSR_IRQL_MASK 0x1c
#define PSR_IRQL 0x2
#define IE_SFW_MASK 0x3
#define IE_SFW 0x0
#define IE_HDW_MASK 0xfc
#define IE_HDW 0x2
#define MCHK_CORRECTABLE_MASK 0x1
#define MCHK_CORRECTABLE 0x0
#define MCHK_RETRYABLE_MASK 0x2
#define MCHK_RETRYABLE 0x1
#define MCES_MCK_MASK 0x1
#define MCES_MCK 0x0
#define MCES_SCE_MASK 0x2
#define MCES_SCE 0x1
#define MCES_PCE_MASK 0x4
#define MCES_PCE 0x2
#define MCES_DPC_MASK 0x8
#define MCES_DPC 0x3
#define MCES_DSC_MASK 0x10
#define MCES_DSC 0x4
#define MCES_DMCK_MASK 0x20
#define MCES_DMCK 0x5
#define EXCSUM_SWC_MASK 0x1
#define EXCSUM_SWC 0x0
#define EXCSUM_INV_MASK 0x2
#define EXCSUM_INV 0x1
#define EXCSUM_DZE_MASK 0x4
#define EXCSUM_DZE 0x2
#define EXCSUM_OVF_MASK 0x8
#define EXCSUM_OVF 0x3
#define EXCSUM_UNF_MASK 0x10
#define EXCSUM_UNF 0x4
#define EXCSUM_INE_MASK 0x20
#define EXCSUM_INE 0x5
#define EXCSUM_IOV_MASK 0x40
#define EXCSUM_IOV 0x6

//
// Call PAL mnemonics
//

// begin callpal

#define bpt 0x80
#define callsys 0x83
#define imb 0x86
#define gentrap 0xaa
#define rdteb 0xab
#define kbpt 0xac
#define callkd 0xad
#define halt 0x0
#define restart 0x1
#define draina 0x2
#define reboot 0x3
#define initpal 0x4
#define wrentry 0x5
#define swpirql 0x6
#define rdirql 0x7
#define di 0x8
#define ei 0x9
#define swppal 0xa
#define ssir 0xc
#define csir 0xd
#define rfe 0xe
#define retsys 0xf
#define swpctx 0x10
#define swpprocess 0x11
#define rdmces 0x12
#define wrmces 0x13
#define tbia 0x14
#define tbis 0x15
#define tbisasn 0x17
#define dtbis 0x16
#define rdksp 0x18
#define swpksp 0x19
#define rdpsr 0x1a
#define rdpcr 0x1c
#define rdthread 0x1e
#define tbim 0x20
#define tbimasn 0x21
#define rdcounters 0x30
#define rdstate 0x31
#define wrperfmon 0x32
#define initpcr 0x38

// end callpal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\localsrv.h ===
//=--------------------------------------------------------------------------=
// LocalServer.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...
//
#ifndef _LOCALSERVER_H_

void      InitializeLibrary(void);
void      UninitializeLibrary(void);

#ifdef MDAC_BUILD
    BOOL	  CanUnloadLibraryNow(void);
    HRESULT	  LibraryGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObjOut);
#endif

BOOL      RegisterData(void);
BOOL      UnregisterData(void);
BOOL      CheckForLicense();
BOOL      CheckLicenseKey(LPWSTR wszCheckme);
BSTR      GetLicenseKey(void);

// global variables that various people use to get information about the control.
//
extern const char g_szLibName [];
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS         0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)      (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,      (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,      (void *)&(name##Control) }
#define PROPERTYPAGE(name)     { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT            { OI_BOGUS, NULL }

#define _LOCALSERVER_H_
#endif // _LOCALSERVER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\kxalpha.h ===
/*++

  Copyright (c) 1992, 1993 Digital Equipment Corporation


  Module:
           kxalpha.h

  Abstract:
           Contains alpha architecture constants and assembly macros.

  Author:
          Joe Notarangelo  31-March-1992   (based on Dave Cutler's kxmips.h)


  Revision History

  16-July-1992       John DeRosa

  Removed fwcalpal.h hook.


  8-July-1992        John DeRosa

  Added fwcalpal.h hooks, defined HALT call_pal.


--*/

//
// Define Sfw Interrupt Levels and masks
//

#define APC_INTERRUPT 0x1
#define DISPATCH_INTERRUPT 0x2

//
// Define standard integer registers.
//
// N.B. `at' is `AT' so it doesn't conflict with the `.set at' pseudo-op.
//

#define v0 $0                   // return value register
#define t0 $1                   // caller saved (temporary) registers
#define t1 $2                   //
#define t2 $3                   //
#define t3 $4                   //
#define t4 $5                   //
#define t5 $6                   //
#define t6 $7                   //
#define t7 $8                   //
#define s0 $9                   // callee saved (nonvolatile) registers
#define s1 $10                  //
#define s2 $11                  //
#define s3 $12                  //
#define s4 $13                  //
#define s5 $14                  //
#define fp $15                  // frame pointer register, or s6
#define a0 $16                  // argument registers
#define a1 $17                  //
#define a2 $18                  //
#define a3 $19                  //
#define a4 $20                  //
#define a5 $21                  //
#define t8 $22                  // caller saved (temporary) registers
#define t9 $23                  //
#define t10 $24                 //
#define t11 $25                 //
#define ra $26                  // return address register
#define t12 $27                 // caller saved (temporary) registers
#define AT $28                  // assembler temporary register
#define gp $29                  // global pointer register
#define sp $30                  // stack pointer register
#define zero $31                // zero register

#ifndef PALCODE

//
// Define standard floating point registers.
//

#define f0 $f0                  // return value register
#define f1 $f1                  // return value register
#define f2 $f2                  // callee saved (nonvolatile) registers
#define f3 $f3                  //
#define f4 $f4                  //
#define f5 $f5                  //
#define f6 $f6                  //
#define f7 $f7                  //
#define f8 $f8                  //
#define f9 $f9                  //
#define f10 $f10                // caller saved (temporary) registers
#define f11 $f11                //
#define f12 $f12                //
#define f13 $f13                //
#define f14 $f14                //
#define f15 $f15                //
#define f16 $f16                // argument registers
#define f17 $f17                //
#define f18 $f18                //
#define f19 $f19                //
#define f20 $f20                //
#define f21 $f21                //
#define f22 $f22                // caller saved (temporary) registers
#define f23 $f23                //
#define f24 $f24                //
#define f25 $f25                //
#define f26 $f26                //
#define f27 $f27                //
#define f28 $f28                //
#define f29 $f29                //
#define f30 $f30                //
#define f31 $f31                // floating zero register
#define fzero $f31              // floating zero register (alias)

#endif //!PALCODE


//
// Define procedure entry macros
//

#define ALTERNATE_ENTRY(Name)           \
        .globl  Name;                   \
Name:;

#define LEAF_ENTRY(Name)                \
        .text;                          \
        .align  4;                      \
        .globl  Name;                   \
        .ent    Name, 0;                \
Name:;                                  \
        .frame  sp, 0, ra;              \
        .prologue 0;

#define NESTED_ENTRY(Name, fsize, retrg) \
        .text;                          \
        .align  4;                      \
        .globl  Name;                   \
        .ent    Name, 0;                \
Name:;                                  \
        .frame  sp, fsize, retrg;

//
// Define global definition macros.
//

#define END_REGION(Name)                \
        .globl  Name;                   \
Name:;

#define START_REGION(Name)              \
        .globl  Name;                   \
Name:;

//
// Define exception handling macros.
//

#define EXCEPTION_HANDLER(Handler)      \
        .edata 1, Handler;


#define PROLOGUE_END  .prologue 1;

//
// Define save and restore floating state macros.
//

#define SAVE_NONVOLATILE_FLOAT_STATE    \
        bsr     ra, KiSaveNonVolatileFloatState

//
// Define interfaces to pcr and palcode
//
//    The interfaces defined in the following macros will be PALcode
//    calls for some implemenations, but may be in-line code in others
//    (eg. uniprocessor vs multiprocessor).  At the current time all of
//    the interfaces are PALcode calls.
//

//
// Define interfaces for cache coherency
//

//++
//
// IMB
//
// Macro Description:
//
//     Issue the architecture-defined Instruction Memory Barrier.  This
//     instruction will make the processor instruction stream coherent with
//     the system memory.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define IMB          call_pal imb

//
// Define PALcode Environment Transition Interfaces
//

//++
//
// REBOOT
//
// Macro Description:
//
//     Reboot the processor to return to firmware.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define REBOOT         call_pal reboot

//++
//
// RESTART
//
// Macro Description:
//
//     Restart the processor with the processor state found in a
//     restart block.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to an ARC restart block with an Alpha AXP
//          saved state area.
//
// Return Value:
//
//     If successful the call does not return.  Otherwise, any return
//     is considered a failure.
//
// Registers Used:
//
//     None.
//
//--

#define RESTART      call_pal restart

//++
//
// SWPPAL
//
// Macro Description:
//
//     Swap the execution environment to a new PALcode image.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the physical address of the base of the new PALcode
//          image.
//
//     a1 - a5 - Supply arguments to the new PALcode environment.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define SWPPAL       call_pal swppal

//
// Define IRQL and interrupt interfaces
//

//++
//
// DISABLE_INTERRUPTS
//
// Macro Description:
//
//     Disable all interrupts for the current processor and return the
//     previous PSR.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DISABLE_INTERRUPTS        call_pal di

//++
//
// ENABLE_INTERRUPTS
//
// Macro Description:
//
//     Enable interrupts according to the current PSR for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define ENABLE_INTERRUPTS         call_pal ei

//++
//
// SWAP_IRQL
//
// Macro Description:
//
//     Swap the IRQL level for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the new IRQL level.
//
// Return Value:
//
//     v0 = previous IRQL level.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define SWAP_IRQL    call_pal swpirql

//++
//
// GET_CURRENT_IRQL
//
// Macro Description:
//
//     Return the current processor Interrupt Request Level (IRQL).
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = current IRQL.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_CURRENT_IRQL  call_pal rdirql


//
// Define interfaces for software interrupts
//

//++
//
// DEASSERT_SOFTWARE_INTERRUPT
//
// Macro Description:
//
//     Deassert the software interrupts indicated in a0 for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the mask for the software interrupt to be de-asserted.
//          a0<1> - Deassert DISPATCH software interrupt.
//          a0<0> - Deassert APC software interrupt.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define DEASSERT_SOFTWARE_INTERRUPT    call_pal csir

//++
//
// REQUEST_SOFTWARE_INTERRUPT
//
// Macro Description:
//
//     Request software interrupts on the current processor according to
//     the mask supplied in a0.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the mask of software interrupts to be requested.
//          a0<1> - Request DISPATCH software interrupt.
//          a0<0> - Request APC software interrupt.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define REQUEST_SOFTWARE_INTERRUPT     call_pal ssir

//
// Define interfaces to Processor Status Register
//

//++
//
// GET_CURRENT_PROCESSOR_STATUS_REGISTER
//
// Macro Description:
//
//     Return the current Processor Status Register (PSR) for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = current PSR.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_CURRENT_PROCESSOR_STATUS_REGISTER   call_pal rdpsr


//
// Define current thread interface
//

//++
//
// GET_THREAD_ENVIRONMENT_BLOCK
//
// Macro Description:
//
//     Return the base address of the current Thread Environment Block (TEB),
//     for the currently executing thread on the current processor.
//
// Mode;
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = TEB base address.
//
// Registers Used:
//
//     None.
//
//--

#define GET_THREAD_ENVIRONMENT_BLOCK  call_pal rdteb

//++
//
// GET_CURRENT_THREAD
//
// Macro Description:
//
//     Return the thread object address for the currently executing thread
//     on the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PCR base address.
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// If uni-processor, retrieve current thread address from the global
// variable KiCurrentThread.
//

#define GET_CURRENT_THREAD              \
        lda     v0, KiCurrentThread;    \
        ldl     v0, 0(v0)

#else

//
// If multi-processor, retrive per-processor current thread via a call pal.
//

#define GET_CURRENT_THREAD    call_pal rdthread

#endif //NT_UP

//
// Define per-processor data area routine interfaces
//

//++
//
// GET_PROCESSOR_CONTROL_REGION_BASE
//
// Macro Description:
//
//     Return the base address of the Process Control Region (PCR)
//     for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PCR base address.
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// Uni-processor, address of PCR is in global variable.
//

#define GET_PROCESSOR_CONTROL_REGION_BASE \
        lda     v0, KiPcrBaseAddress;     \
        ldl     v0, 0(v0)

#else

//
// Multi-processor, get per-processor value via call pal.
//

#define GET_PROCESSOR_CONTROL_REGION_BASE    call_pal rdpcr

#endif //NT_UP

//++
//
// GET_PROCESSOR_CONTROL_BLOCK_BASE
//
// Macro Description:
//
//     Return the Processor Control Block base address.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PRCB base address.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_PROCESSOR_CONTROL_BLOCK_BASE   \
        GET_PROCESSOR_CONTROL_REGION_BASE; \
        ldl     v0, PcPrcb(v0)


//
// Define kernel stack interfaces
//

//++
//
// GET_INITIAL_KERNEL_STACK
//
// Macro Description:
//
//     Return the initial kernel stack address for the current thread.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = initial kernel stack address.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_INITIAL_KERNEL_STACK  call_pal rdksp

//++
//
// SET_INITIAL_KERNEL_STACK
//
// Macro Description:
//
//     Set the initial kernel stack address for the current thread.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the new initial kernel stack address.
//
// Return Value:
//
//     v0 - Previous initial kernel stack address.
//
// Registers Used:
//
//     AT.
//
//--

#define SET_INITIAL_KERNEL_STACK  call_pal swpksp

//
// Define initialization routine interfaces
//

//++
//
// INITIALIZE_PAL
//
// Macro Description:
//
//     Supply values to initialize the PALcode.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies initial PageDirectoryBase (32-bit superpage address).
//     a1 - Supplies PRCB Base Address (32-bit superpage address).
//     a2 - Supplies address of initial kernel thread object.
//     a3 - Supplies address of TEB for initial kernel thread object.
//     gp - Supplies kernel image global pointer.
//     sp - Supplies initial thread kernel stack pointer.
//
// Return Value:
//
//     v0 = PAL base address in 32-bit super-page format (KSEG0).
//
// Registers Used:
//
//     AT, a3.
//
//--

#define INITIALIZE_PAL  call_pal initpal

//++
//
// WRITE_KERNEL_ENTRY_POINT
//
// Macro Description:
//
//     Register the kernel entry point to receive control for a
//     class of exceptions.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the address of the kernel entry point.
//     a1 - Supplies the class of exception dispatched to this entry point.
//          0 = bug check conditions
//          1 = memory management faults
//          2 = interrupts
//          3 = system service calls
//          4 = general exception traps
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a2-a3.
//
//--

#define WRITE_KERNEL_ENTRY_POINT  call_pal wrentry

//
// Define entry point values for the wrentry callpal function
//

#define entryBugCheck   0
#define entryMM         1
#define entryInterrupt  2
#define entrySyscall    3
#define entryGeneral    4

//++
//
// CACHE_PCR_VALUES
//
// Macro Description:
//
//     Notify the PALcode that the PCR has been initialized by the
//     kernel and the HAL and that the PALcode may now read values
//     from the PCR and cache them inside the processor.
//
//     N.B. - the PCR pointer must have already been established in
//          initpal
//
//     N.B. - This interface is a processor-specific implementation
//          and cannot be assumed to be present on all processors.
//          Currently implemented for the following processors:
//
//              DECchip 21064
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a0 - a3.
//
//--

#define CACHE_PCR_VALUES  call_pal initpcr

//
// Define transition interfaces
//

//++
//
// RETURN_FROM_TRAP_OR_INTERRUPT
//
// Macro Description:
//
//     Return to execution thread after processing a trap or
//     interrupt.  Traps can be general exceptions (breakpoint,
//     arithmetic traps, etc.) or memory management faults.
//     This macro is also used to startup a thread of execution
//     for the first time.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the previous processor status register.
//     a1 - Supplies new software interrupt requests.
//          a1<1> - Request a DISPATCH Interrupt.
//          a1<0> - Request an APC Interrupt.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define RETURN_FROM_TRAP_OR_INTERRUPT      call_pal rfe

//++
//
// RETURN_FROM_SYSTEM_CALL
//
// Macro Description:
//
//     Return from a system service call.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the previous processor status register.
//     a1 - Supplies new software interrupt requests.
//          a1<1> - Request a DISPATCH Interrupt.
//          a1<0> - Request an APC Interrupt.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     All volatile registers.
//
//--

#define RETURN_FROM_SYSTEM_CALL   call_pal retsys

//++
//
// SYSCALL
//
// Macro Description:
//
//     Call a system service.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     v0 - Supplies the system service number.
//     [other arguments as per calling standard]
//
// Return Value:
//
//     Will not return directly, returns via retsys, no return value.
//
// Registers Used:
//
//     All volatile registers.
//
//--

#define SYSCALL  call_pal callsys

//
// Define breakpoint interfaces
//

//++
//
// BREAK
//
// Macro Description:
//
//     Issue a user breakpoint which may be handled by a user-mode
//     debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     None.
//
//--

#define BREAK    call_pal bpt

//++
//
// BREAK_DEBUG_STOP
//
// Macro Description:
//
//     Issue a stop breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_STOP \
    ldil    v0, DEBUG_STOP_BREAKPOINT; \
    call_pal callkd

//++
//++
//
// BREAK_BREAKIN
//
// Macro Description:
//
//     Issue a breakin breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_BREAKIN \
    ldil    v0, BREAKIN_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_LOAD_SYMBOLS
//
// Macro Description:
//
//     Issue a load symbols breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_LOAD_SYMBOLS \
    ldil    v0, DEBUG_LOAD_SYMBOLS_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_UNLOAD_SYMBOLS
//
// Macro Description:
//
//     Issue a unload symbols breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_UNLOAD_SYMBOLS \
    ldil    v0, DEBUG_UNLOAD_SYMBOLS_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_PRINT
//
// Macro Description:
//
//     Cause a debug print breakpoint which will be interpreted by
//     the kernel debugger and will print a string to the kernel debugger
//     port.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 - Supplies the address of ASCII string to print.
//     a1 - Supplies the length of the string to print.
//
// Return Value:
//
//     Does not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--


#define BREAK_DEBUG_PRINT \
    ldil    v0, DEBUG_PRINT_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_PROMPT
//
// Macro Description:
//
//     Cause a debug print breakpoint which will be interpreted by
//     the kernel debugger and will receive a string from the kernel debugger
//     port after prompting for input.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 - Supplies the address of ASCII string to print.
//     a1 - Supplies the length of the string to print.
//     a2 - Supplies the address of the buffer to receive the input string.
//     a3 - Supplies the maximum length of the input string.
//
// Return Value:
//
//     Does not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--


#define BREAK_DEBUG_PROMPT \
    ldil    v0, DEBUG_PROMPT_BREAKPOINT; \
    call_pal callkd

//
// Define tb manipulation interfaces
//

//++
//
// TB_INVALIDATE_ALL
//
// Macro Description:
//
//     Invalidate all cached virtual address translations for the current
//     processor that are not fixed.
//     Some translations may be fixed in hardware and/or software and
//     these are not invalidated (eg. super-pages).
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a0 - a3.
//
//--


#define TB_INVALIDATE_ALL   call_pal tbia

//++
//
// TB_INVALIDATE_SINGLE
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE   call_pal tbis

//++
//
// TB_INVALIDATE_MULTIPLE
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of Virtual Addresses of the
//          translations to invalidate.
//     a1 - Supplies the count of Virtual Addresses in the list
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a2.
//
//--

#define TB_INVALIDATE_MULTIPLE   call_pal tbim

//++
//
// TB_INVALIDATE_SINGLE_ASN
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address for the specified address space number.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
//     a1 - Supplies the Address Space Number of the translation to be
//          invalidated.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE_ASN   call_pal tbisasn

//++
//
// TB_INVALIDATE_MULTIPLE_ASN
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses for the specified address space number.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of Virtual Addresses of the
//          translations to invalidate.
//
//     a1 - Supplies the count of Virtual Addresses in the list
//
//     a2 - Supplies the Address Space Number of the translation to be
//          invalidated.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a3.
//
//--

#define TB_INVALIDATE_MULTIPLE_ASN   call_pal tbimasn

//++
//
// DATA_TB_INVALIDATE_SINGLE
//
// Macro Description:
//
//     Invalidate data stream translations for a single virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define DATA_TB_INVALIDATE_SINGLE  call_pal dtbis

//
// Define context switch interfaces
//

//++
//
// SWAP_THREAD_CONTEXT
//
// Macro Description:
//
//
//     Change to a new thread context.  This will mean a new kernel stack,
//     new current thread address and a new thread environment block.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of new initial kernel stack.
//     a1 - Supplies the address of new thread object.
//     a2 - Supplies the address of new thread environment block.
//     a3 - Supplies the PFN of the new page directory if the process
//          is to be swapped, -1 otherwise.
//     a4 - Supplies the ASN of the new processor if the process is to
//          be swapped, undefined otherwise.
//     a5 - Supplies the ASN wrap indicator if the process is to be swapped,
//          undefined otherwise.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT.
//
//--

#define SWAP_THREAD_CONTEXT   call_pal  swpctx

//++
//
// SWAP_PROCESS_CONTEXT
//
// Macro Description:
//
//     Change from one process address space to another.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Pfn of Page Directory for new address space.
//     a1 - Supplies the Address Space Number for new address space.
//     a2 - Supplies the ASN wrap indicator (0 = no wrap, non-zero = wrap).
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a3.
//
//--

#define SWAP_PROCESS_CONTEXT  call_pal  swpprocess

//
// Define access to DPC Active flag
//

//++
//
// GET_DPC_ACTIVE_FLAG
//
// Macro Description:
//
//     Return the DPC Active Flag for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = DPC Active Flag
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// The DPC Active flag can be safely acquired from the PCR (there is only one).
//

#define GET_DPC_ACTIVE_FLAG \
        GET_PROCESSOR_CONTROL_REGION_BASE; \
        ldl     v0, PcDpcRoutineActive(v0)

#else

//
// Ensure that the DPC flag fetch is atomic.
//

#define GET_DPC_ACTIVE_FLAG \
        DISABLE_INTERRUPTS;                 \
        GET_PROCESSOR_CONTROL_REGION_BASE;  \
        ldl     v0, PcDpcRoutineActive(v0); \
        ENABLE_INTERRUPTS;

#endif //NT_UP

//++
//
// SET_DPC_ACTIVE_FLAG
//
// Macro Description:
//
//     Set the DPC Active Flag for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 = Supplies the DPC Active Flag Value to set.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT.
//
//--

#define SET_DPC_ACTIVE_FLAG                     \
        .set    noat;                           \
        GET_PROCESSOR_CONTROL_REGION_BASE;      \
        stl     a0, PcDpcRoutineActive(v0);     \
        .set    at


//
// Define interfaces for generate trap
//

//++
//
// GENERATE_TRAP
//
// Macro Description:
//
//     Generate a trap.  Code has discovered an exception condition
//     and wants to raise a trap to indicate the condition.  Anticipated
//     for use by compilers for divide by zero, etc..
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 = Supplies the trap number which identifies the exception.
//
// Return Value:
//
//     Does not return, generates a trap to kernel mode, no return value.
//
// Registers Used:
//
//     None.
//
//--

#define GENERATE_TRAP call_pal gentrap

//
// Define performance and debug interfaces.
//

//++
//
// GET_INTERNAL_COUNTERS
//
// Macro Description:
//
//     Read the internal processor event counters.  The counter formats
//     and the events counted are processor implementation-dependent.
//
//     N.B. - the counters will only be implemented for checked builds.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the superpage 32 address of the buffer to receive
//          the counter data.  The address must be quadword aligned.
//
//     a1 - Supplies the length of the buffer allocated for the counters.
//
// Return Value:
//
//     v0 - 0 is returned if the interface is not implemented.
//          If v0 <= a1 then v0 is the length of the data returned.
//          If v0 > a1 then v0 is the length of the processor implementation
//          counter record.
//
// Registers Used:
//
//     AT, a2 - a3.
//
//--

#define GET_INTERNAL_COUNTERS  call_pal rdcounters

//++
//
// GET_INTERNAL_PROCESSOR_STATE
//
// Macro Description:
//
//     Read the internal processor state.  The data values returned and
//     their format are processor implementation-dependent.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the superpage 32 address of the buffer to receive
//          the processor state data.  The address must be quadword aligned.
//
//     a1 - Supplies the length of the buffer allocated for the state.
//
// Return Value:
//
//     v0 - If v0 <= a1 then v0 is the length of the data returned.
//          If v0 > a1 then v0 is the length of the processor implementation
//          state record.
//
// Registers Used:
//
//     AT, a2 - a3.
//
//--

#define GET_INTERNAL_PROCESSOR_STATE  call_pal rdstate

//++
//
// WRITE_PERFORMANCE_COUNTERS
//
// Macro Description:
//
//     Write the state of the internal processor performance counters.
//     The number of performance counters, the events they count, and their
//     usage is processor implementation-depedent.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the number of the performance counter.
//
//     a1 - Supplies a flag that indicates if the performance counter is
//          to be enabled or disabled (0 = disabled, non-zero = enabled).
//
//     a2 - a5 - Supply processor implementation-dependent parameters.
//
// Return Value:
//
//     v0 - 0 is returned if the operation is unsuccessful or the performance
//          counter does not exist.  Otherwise, a non-zero value is returned.
//
// Registers Used:
//
//     AT, a2 - a5.
//
//--

#define WRITE_PERFORMANCE_COUNTERS  call_pal wrperfmon


//
// Define interfaces for controlling the state of machine checks.
//

//++
//
// DRAIN_ABORTS
//
// Macro Description:
//
//     Stall processor execution until all previous instructions have
//     executed to the point that any exceptions they may raise have been
//     signalled.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DRAIN_ABORTS  call_pal draina


//++
//
// GET_MACHINE_CHECK_ERROR_SUMMARY
//
// Macro Description:
//
//     Read the processor machine check error summary register.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 - The value of the MCES register.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_MACHINE_CHECK_ERROR_SUMMARY  call_pal rdmces


//++
//
// WRITE_MACHINE_CHECK_ERROR_SUMMARY
//
// Macro Description:
//
//     Write new values to the machine check error summary register.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the values to write to the MCES register.
//
// Return Value:
//
//     v0 - Previous value of the MCES register.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define WRITE_MACHINE_CHECK_ERROR_SUMMARY  call_pal wrmces


//++
//
// LoadByte(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Loades the byte at the base address defined by the
//     offset + register expression Base into the register Value
//
// Arguments:
//
//     Value - Supplies the string name of the destination register
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the source of the byte.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT
//
//--

#define LoadByte( Value, Base )        \
        .set    noat;                  \
        lda     AT, Base;              \
        ldq_u   Value, Base;           \
        extbl   Value, AT, Value;      \
        .set    at;


//++
//
// StoreByte(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the low byte of the register Value at the base address
//     defined by the offset + register expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreByte( Value, Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskbl   t12, AT, t12;           \
        insbl   Value, AT, AT;          \
        bis     t12, AT, t12;           \
        lda     AT, Base;               \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, 0(AT);             \
        .set    at;


//++
//
// ZeroByte(
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Zeroes the byte at the address defined by the offset + register
//     expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define ZeroByte( Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskbl   t12, AT, t12;           \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, (AT);              \
        .set    at;

//++
//
// StoreByteAligned(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the low byte of the register Value at the base address
//     defined by the offset + register expression Base.  This macro
//     is functionally equivalent to StoreByte, but it assumes that
//     Base is dword aligned and optimizes the generated code
//     based on the alignment of Offset.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreByteAligned( Value, Offset, Base )         \
    .set    noat;                                       \
    ldl     AT, Offset(Base);                           \
    mskbl   AT, 0, t12;                                 \
    bis     t12, Value, AT;                             \
    stl     AT, Offset(Base);                           \
    .set    at;


//++
//
// ClearByteAligned(
//     Offset,
//     Base
//     )
//
// Macro Description:
//
//     Clears the byte at the location defined by the offset + register
//     expression Base.  It assumes that Base is dword aligned and optimizes
//     the generated code based on the alignment of Offset.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Offset - Supplies the offset of the destination of the store.
//
//     Base - Supplies the base address of the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define ZeroByteAligned( Offset, Base )          \
    .set    noat;                                       \
    ldl     AT, Offset(Base);                           \
    mskbl   AT, 0, t12;                                 \
    stl     t12, Offset(Base);                          \
    .set    at;



//++
//
// StoreWord(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the word of the register Value at the word aligned base address
//     defined by the offset + register expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
//     N.B. - The destination must be word-aligned.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreWord( Value, Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskwl   t12, AT, t12;           \
        inswl   Value, AT, AT;          \
        bis     t12, AT, t12;           \
        lda     AT, Base;               \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, 0(AT);             \
        .set    at;

//
// Define subtitle macro
//

#define SBTTL(x)

//
// Define mnemonic for writing callpal in assembly language that will
// fit in the opcode field.
//

#define callpal call_pal

//
// Define exception data section and align.
//
// Nearly all source files that include this header file need the following
// few pseudo-ops and so, by default, they are placed once here rather than
// repeated in every source file.  If these pseudo-ops are not needed, then
// define HEADER_FILE prior to including this file.
//
// Also the PALCODE environment uses this include file but cannot use
// these definitions.
//

#if  !defined(HEADER_FILE) && !defined(PALCODE)

        .edata 0
        .align 2
        .text

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\macros.h ===
//=--------------------------------------------------------------------------=
// Macros.h
//=--------------------------------------------------------------------------=
// Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
// Handy macros like the ones we use in the VB code base.
//=--------------------------------------------------------------------------=
#ifndef _MACROS_H_

#include <globals.h>

//---------------------------------------------------------------------------
//  Debugging Heap Memory Leaks:
//		Macros and definitions		
//---------------------------------------------------------------------------
#ifdef DEBUG
typedef char * LPSZ;
#define NUM_INST_TABLE_ENTRIES 1024
#define Deb_FILELINEPROTO   , LPSTR lpszFile, UINT line
#define Deb_FILELINECALL    , __FILE__, __LINE__
#define Deb_FILELINEPASS    , lpszFile, line
#else  // DEBUG
#define Deb_FILELINEPROTO
#define Deb_FILELINECALL
#define Deb_FILELINEPASS
#endif  // DEBUG


// Function prototypes for the actual implementations of the debug heap wrapper functions.
#ifdef DEBUG
LPVOID CtlHeapAllocImpl(HANDLE g_hHeap, DWORD dwFlags, DWORD dwBytes Deb_FILELINEPROTO);
LPVOID CtlHeapReAllocImpl(HANDLE g_hHeap, DWORD dwFlags, LPVOID lpvMem, DWORD dwBytes Deb_FILELINEPROTO);
BOOL   CtlHeapFreeImpl(HANDLE g_hHeap, DWORD dwFlags, LPVOID lpvMem);
extern VOID CheckForLeaks(VOID);
inline UINT HashInst(VOID * pv) { return ((UINT) ((ULONG)pv >> 4)) % NUM_INST_TABLE_ENTRIES; } //  Hashing function
#endif // DEBUG


#define OleAlloc(dwBytes)									CoTaskMemAlloc(dwBytes)
#define OleReAlloc(lpvMem, dwBytes)			  CoTaskMemReAlloc(lpvMem, dwBytes)
#define OleFree(lpvMem)										CoTaskMemFree(lpvMem)
#define New																new (g_hHeap Deb_FILELINECALL)

//--------------------------------------------------------------------------------------------------
//	Macros for our memory leak detection

#ifdef DEBUG
// Use these functions to allocate memory from the global heap.
#define CtlHeapAlloc(g_hHeap, dwFlags, dwBytes)						CtlHeapAllocImpl(g_hHeap, dwFlags, dwBytes Deb_FILELINECALL)
#define CtlHeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes)	CtlHeapReAllocImpl(g_hHeap, dwFlags, lpvMem, dwBytes Deb_FILELINECALL)
#define CtlHeapFree(g_hHeap, dwFlags, lpvMem)							CtlHeapFreeImpl(g_hHeap, dwFlags, lpvMem)
#define CtlAlloc(dwBytes)																	CtlHeapAllocImpl(g_hHeap, 0, dwBytes Deb_FILELINECALL)
#define CtlAllocZero(dwBytes)															CtlHeapAllocImpl(g_hHeap, HEAP_ZERO_MEMORY, dwBytes Deb_FILELINECALL)
#define CtlReAlloc(lpvMem, dwBytes)																	CtlHeapReAllocImpl(g_hHeap, 0, lpvMem, dwBytes Deb_FILELINECALL)
#define CtlReAllocZero(lpvMem, dwBytes)																	CtlHeapReAllocImpl(g_hHeap, HEAP_ZERO_MEMORY, lpvMem, dwBytes Deb_FILELINECALL)
#define CtlFree(lpvMem)																		CtlHeapFreeImpl(g_hHeap, 0, lpvMem)
#define NewCtlHeapAlloc(g_hHeap, dwFlags, dwBytes)				CtlHeapAllocImpl(g_hHeap, dwFlags, dwBytes Deb_FILELINEPASS)

#else
// In retail on Win32 we map directly to the Win32 Heap API
#define CtlHeapAlloc(g_hHeap, dwFlags, dwBytes)						HeapAlloc(g_hHeap, dwFlags, dwBytes)
#define CtlHeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes) HeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes)
#define CtlHeapFree(g_hHeap, dwFlags, lpvMem)							HeapFree(g_hHeap, dwFlags, lpvMem)
#define CtlAlloc(dwBytes)																	HeapAlloc(g_hHeap, 0, dwBytes)
#define CtlAllocZero(dwBytes)															HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwBytes)
#define CtlReAlloc(lpvMem, dwBytes)																	HeapReAlloc(g_hHeap, 0, lpvMem, dwBytes)
#define CtlReAllocZero(lpvMem, dwBytes)																	HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, lpvMem, dwBytes)
#define CtlFree(lpvMem)																		HeapFree(g_hHeap, 0, lpvMem)
#define NewCtlHeapAlloc(g_hHeap, dwFlags, dwBytes)				HeapAlloc(g_hHeap, dwFlags, dwBytes)
#endif // DEBUG

//	Macros for header files
//  SZTHISFILE cannot be defined in header files.  These macros avoid its re-definition
#ifdef DEBUG
#define CtlHeapAlloc_Header_Util(g_hHeap, dwFlags, dwBytes)	CtlHeapAllocImpl(g_hHeap, dwFlags, dwBytes, __FILE__, __LINE__);
#else
#define CtlHeapAlloc_Header_Util(g_hHeap, dwFlags, dwBytes)	HeapAlloc (g_hHeap, dwFlags, dwBytes);
#endif // DEBUG


//=---------------------------------------------------------------------------=
// class CtlNewDelete
//
// This class MUST be inherited by any class in the CTLS Tree that wants
// to use "new" or "delete" to allocate/free.
//
// This class has no data members or virtual functions, so it does not
// change the size of any instances of classes which inherit from it.
//=---------------------------------------------------------------------------=
class CtlNewDelete
{
public:
inline void * _cdecl operator new (size_t size, HANDLE g_hHeap Deb_FILELINEPROTO);
inline void _cdecl operator delete (LPVOID pv, HANDLE g_hHeap Deb_FILELINEPROTO);
inline void _cdecl operator delete (LPVOID pv);
};


//=---------------------------------------------------------------------------=
// CtlNewDelete::operator new
//=---------------------------------------------------------------------------=
// Parameters:
//    size_t         - [in] what size do we alloc
//		g_hHeap				 - [in] our global heap
//		lpszFile			 - [in] what file are we allocating from
//		line					 - [in] what line # do we allocate from
//
// Output:
//    VOID *         - new memory.
//
// Notes:
//
// We don't need to worry about ENTERCRITICALSECTION1 here.
// New is either called by the c run-time or after
// g_hHeap has been initialized in DllMain PROCESS_ATTACH.
// In either case this call is synchronized.
// If we try putting ENTERCRITICALSECTION1 here, we will
// blow up if the c run-time is attempting to initialize
// our static objects such as objects w/ global constructors.
inline void * _cdecl CtlNewDelete::operator new (size_t size, HANDLE g_hHeap Deb_FILELINEPROTO)
{
    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
        return g_hHeap ? NewCtlHeapAlloc(g_hHeap, 0, size) : NULL;
    }

    return NewCtlHeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// CtlNewDelete::operator delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
inline void _cdecl CtlNewDelete::operator delete ( void *ptr, HANDLE g_hHeap Deb_FILELINEPROTO)
{
    if (ptr)
      CtlHeapFree(g_hHeap, 0, ptr);
}
inline void _cdecl CtlNewDelete::operator delete ( void *ptr)
{
    if (ptr)
      CtlHeapFree(g_hHeap, 0, ptr);
}

//---------------------------------------------------------------------------
// Convert C's BOOL to Basic's BOOL
//---------------------------------------------------------------------------
#define BASICBOOLOF(f)    ((f) ? -1 : 0 )
#define FMAKEBOOL(f)      (!!(f))

//---------------------------------------------------------------------------
// Code macros
//---------------------------------------------------------------------------
#define SWAP(type, a, b)  { type _z_=(a);  (a)=(b);  (b)=_z_; }

#if 0
#define loop  while(1)    // "loop" keyword for infinite loops
#endif // 0

// "scope" keyword for { } that are used just to introduce a new name scope.
// It's disconcerting to see { } without some keyword in front of the {...
#define scope


#define ADDREF(PUNK) \
  {if (PUNK) (PUNK)->AddRef();}

#ifndef RELEASE
#define RELEASE(PUNK) \
  {if (PUNK) {LPUNKNOWN punkXXX = (PUNK); (PUNK) = NULL; punkXXX->Release();}}
#endif //RELEASE

// In some multiple inheritance cases you need to dis-ambiguate which IUnknown implementation to use
#define RELEASETYPE(PUNK,TYPE) \
  {if (PUNK) {LPUNKNOWN punkXXX = (TYPE *)(PUNK); (PUNK) = NULL; punkXXX->Release();}}

#define FREESTRING(bstrVal) \
  {if((bstrVal) != NULL) {SysFreeString((bstrVal)); (bstrVal) = NULL; }}

//---------------------------------------------------------------------
// Debug macros
//---------------------------------------------------------------------
#if DEBUG
void _DebugPrintf(char* pszFormat, ...);
void _DebugPrintIf(BOOL fPrint, char* pszFormat, ...);

#define DebugPrintf _DebugPrintf
#define DebugPrintIf _DebugPrintIf

#else // DEBUG || DEBUG_OUTPUT_ON

inline void _DebugNop(...) {}

#define DebugPrintf     1 ? (void)0 : _DebugNop
#define DebugPrintIf    1 ? (void)0 : _DebugNop
#define DebugMessageBox 1 ? (void)0 : _DebugNop

#endif // DEBUG

//---------------------------------------------------------------------
// Error handling macros
//---------------------------------------------------------------------

#ifdef DEBUG
extern HRESULT HrDebugTraceReturn(HRESULT hr, char *szFile, int iLine);
#define RRETURN(hr) return HrDebugTraceReturn(hr, _szThisFile, __LINE__)
#else
#define RRETURN(hr) return (hr)
#endif  //DEBUG


// FAILEDHR : Same as FAILED(hr), but prints a debug message if the test failed.
#if DEBUG
#define FAILEDHR(HR) _FAILEDHR(HR, _szThisFile, __LINE__)
inline BOOL _FAILEDHR(HRESULT hr, char* pszFile, int iLine)
  {
  if (FAILED(hr))
    HrDebugTraceReturn(hr, pszFile, iLine);
  return FAILED(hr);
  }
#else
#define FAILEDHR(HR) FAILED(HR)
#endif

// SUCCEEDEDHR : Same as SUCCEEDED(hr), but prints a debug message if the test failed.
#define SUCCEEDEDHR(HR) (!FAILEDHR(HR))

// Print a debug message if FAILED(hr).
#if DEBUG
#define CHECKHR(HR) _CHECKHR(HR, _szThisFile, __LINE__)
inline void _CHECKHR(HRESULT hr, char* pszFile, int iLine)
  {
  if (FAILED(hr))
    HrDebugTraceReturn(hr, pszFile, iLine);
  }
#else
#define CHECKHR(HR) HR
#endif

#define IfErrGoto(EXPR, LABEL) \
    { err = (EXPR); if (err) goto LABEL; }

#define IfErrRet(EXPR) \
    { err = (EXPR); if (err) return err; };

#define IfErrGo(EXPR) IfErrGoto(EXPR, Error)


#define IfFailGoto(EXPR, LABEL) \
    { hr = (EXPR); if(FAILEDHR(hr)) goto LABEL; }

#ifndef IfFailRet
#define IfFailRet(EXPR) \
    { hr = (EXPR); if(FAILED(hr)) RRETURN(hr); }
#endif // IfFailRet

#define IfFailGo(EXPR) IfFailGoto(EXPR, Error)


#define IfFalseGoto(EXPR, HR, LABEL) \
    { if(!(EXPR)) { hr = (HR); goto LABEL; } }


#define IfFalseRet(EXPR, HR) \
    { if(!(EXPR)) RRETURN(HR); }

#define IfFalseGo(EXPR, HR) IfFalseGoto(EXPR, HR, Error)


#if DEBUG
#define CHECKRESULT(x) ASSERT((x)==NOERROR,"");
#else  // DEBUG
#define CHECKRESULT(x) (x)
#endif  // DEBUG


//---------------------------------------------------------------------------
// STATICF is for static functions.  In retail we disable this in order to
// do better function reordering via the linker.
//---------------------------------------------------------------------------
#if !defined(STATICF)
#ifdef DEBUG
#define STATICF static
#else  // DEBUG
#define STATICF
#endif  // DEBUG
#endif


#define _MACROS_H_
#endif // _MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\makeauto.inc ===
#=------------------------------------------------------------------------=
# MakeAuto.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds an automation server.  Assumes existence of $(SERVERNAME) and $(OBJS)
#

#
# targets
#
!if "$(FRAMEWRKDIR)" == ""
FRAMEWRKDIR=..\..
!endif

VERSIONHDR=$(FRAMEWRKDIR)\dwinvers.h

!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(SERVERNAME).DLL
!endif

!if "$(INTLBLD)"!=""
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif
!endif

# Special for msrdo20 build - allows output of ODL.H (or some other alternate)
!if "$(ALTERNATEODLHFILE)"==""
_ALTERNATEODLHFILE=-h $(SERVERNAME)Interfaces.H
!else
_ALTERNATEODLHFILE=$(ALTERNATEODLHFILE)
!endif

# Tools
#
!include "Tools.Inc"
SRCDIR=..
FXDIR=$(FRAMEWRKDIR)\FrameWrk
INTLPATH=.\.

# Relative path to the INTL, satellite DLL build, directory
#

!if "$(TOOLS)"==""
TOOLS=TOOLS
!endif

!if "$(C32)"==""
C32=C32
!endif

IDHEADER=..\..\tools\idheader.bat

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
#
!if "$(NONFRAMEWRKMAKE)"==""
LIBS=$(FXDIR)\Debug\CtlFwD32.Lib $(DEVBIN)\htmlhelp\v6\debug\lib\htmlhelp.lib
!endif
CFLAGS=-Zil -DDEBUG -Od -FI$(FRAMEWRKDIR)\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee
!endif
LFLAGS=-debugtype:cv -debug:notmapped,full -pdb:none

RCFLAGS=-dDEBUG
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\debug\CtlFwD32.Lib  ..\..\vblic\debug\vblic.lib

!else if "$(ASICECAP)"!=""
#
# ICECap
#
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
!if "$(NONFRAMEWRKMAKE)"==""
LIBS=$(FXDIR)\IceCap\CtlFwI32.Lib ICap.Lib msvcrt.lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif
#
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -FI$(FRAMEWRKDIR)\include\vc41warn.h
LFLAGS=-debug:mapped
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\icecap\CtlFwI32.Lib ..\..\vblic\icecap\vblic.lib


!else
#
# Release
#
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
!if "$(NONFRAMEWRKMAKE)"==""
LIBS=$(FXDIR)\Release\CtlFwR32.Lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif
#
CFLAGS=-Zil -Owxsb1 -FI$(FRAMEWRKDIR)\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee -QAl
!endif
LFLAGS=
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\release\CtlFwR32.Lib ..\..\vblic\release\vblic.lib

LFLAGS=$(LFLAGS) -debugtype:fixup,cv -debug:notmapped,full
!endif

#
# The CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file when the object is compiled.  Set CTLS_BROWSE to something
# if you wish a browse file generated.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# default flags
#
INCPATH=-I. -I$(SRCDIR) -I$(FRAMEWRKDIR)\Include $(_INCPATH) -I$(VB55CTLS)
RCFLAGS=-r -dRC_INVOKED $(RCFLAGS) $(_RCFLAGS) $(INCPATH)
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib uuid.lib advapi32.lib oldnames.lib uuid2.lib oleaut32.nt4 comdlg32.lib gdi32.lib
!ifdef RISC_BLD
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -def:$(SRCDIR)\$(SERVERNAME).def
!if "$(_NOODLFILE)"==""
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS)
!endif
!else
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:i386 -def:$(SRCDIR)\$(SERVERNAME).def
!if "$(_NOODLFILE)"==""
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS)
!endif
!endif

_SERVERDEP=$(_SERVERDEP)

!if "$(PCHFILE)"!=""
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif

all: \
!if "$(INTLBLD)"!=""
	$(INTLPATH)\$(_LOCALEBASENAME)xxx.Dll
!elseif "$(DEPFILEBLD)"!=""
	$(_SERVERBASENAME).DEP
!else
	$(MORETARGETS) $(_SERVERFILENAME) $(POSTTARGETS)
!endif

!if "$(_NOODLFILE)"==""
$(_SERVERFILENAME): $(VERSIONHDR) $(SERVERNAME).TLB $(OBJS) \
                   $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(LIBS) $(LFLAGS)
!else
$(_SERVERFILENAME): $(VERSIONHDR) $(OBJS) \
                   $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(LIBS) $(LFLAGS)

!endif

!if "$(CTLS_BROWSE)"!=""
	$(BSCMAKE) /o $(SERVERNAME).bsc *.sbr
!endif

# Precompiled header build rules
#
!if "$(PCHFILE)"!=""
pch.cpp:
    echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif

# Standard build rules.
# If a .CPP, .C or .ODL file can't
# be found in the other dependencies then it defaults to one of the following build rules
#
{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.odl.tlb:
	$(MKTYPLIB) $(_MKTYPLIBFLAGS) -nologo -cpp_opt "/C /E /D__MKTYPLIB__ -nologo $(_MTLPREPROCFLAGS)" $(_ALTERNATEODLHFILE) -o Errors.LOG $<

{$(SRCDIR)}.idl.tlb:
	$(MIDL) /newtlb /h -o Errors.LOG $<

# TODO: you should come up with some mechanism to generate this file
#       on your own.
#
#-----------------------------------------------------------------------
# Build dwinvers.h
#-----------------------------------------------------------------------
$(FRAMEWRKDIR)\dwinvers.h : $(FRAMEWRKDIR)\dwinvers.txt
  echo Building dwinvers.h
  $(MAKEVERS) > $(FRAMEWRKDIR)\dwinvers.h < $(FRAMEWRKDIR)\dwinvers.txt
  $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(FRAMEWRKDIR)\dwinvers.h
  copy $(FRAMEWRKDIR)\dwinvers.h $(FRAMEWRKDIR)\framewrk

!if "$(_NOODLFILE)"==""
$(SERVERNAME).TLB : $(SRCDIR)\$(SERVERNAME).ODL $(TLBTARGETS)
    echo Generating $(SERVERNAME).TLB and $(_ALTERNATEODLHFILE)
    $(MKTYPLIB) $(_MKTYPLIBFLAGS) $(INCPATH) -nologo -cpp_opt "/C /E /D__MKTYPLIB__ -nologo $(_MTLPREPROCFLAGS)" $(_ALTERNATEODLHFILE) -o Errors.LOG -tlb $(SERVERNAME).TLB $(SRCDIR)\$(SERVERNAME).ODL


$(SERVERNAME).Rbj : $(SERVERNAME).TLB $(SRCDIR)\$(SERVERNAME).RC
    echo Compiling $(SERVERNAME).RC
    $(RC) $(RCFLAGS) -fo $(SERVERNAME).Res $(SRCDIR)\$(SERVERNAME).Rc
!endif

!if "$(SERVERNAME)"=="RDOCURS"
$(SERVERNAME).Rbj : $(SRCDIR)\$(SERVERNAME).RC
    echo Compiling $(SERVERNAME).RC
    $(RC) $(RCFLAGS) -fo $(SERVERNAME).Res $(SRCDIR)\$(SERVERNAME).Rc
!endif

!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(SERVERNAME).Rbj $(SERVERNAME).Res
!else
    cvtres -machine:ix86 -nologo -out:$(SERVERNAME).Rbj $(SERVERNAME).Res
!endif

# Localized DLL build
#

Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp

!if "$(_NOODLFILE)"==""

!if "$(PCHFILE)"==""
Dep: $(MORETARGETS) $(SERVERNAME).TLB
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCLPREOPT) $(INCPATH) -d $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!else
Dep: $(MORETARGETS) $(SERVERNAME).TLB pch.pch
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!endif

!else

!if "$(PCHFILE)"==""
Dep: $(MORETARGETS)
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCLPREOPT) $(INCPATH) -d $(SRCDIR)\*.c*  > dep.mak
!else
Dep: $(MORETARGETS) pch.pch
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c*  > dep.mak
!endif

!endif
#=----------------------------=
# Include Dependency Makefile
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\makecbc.inc ===
#=------------------------------------------------------------------------=
# MakeCBC.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds a custom base class.  Assumes existence of $(DESIGNERNAME), and $(OBJS)
#

.SUFFIXES: .s


#
# targets
#
VERSIONHDR=dwinvers.h


#
# support for naming your DLL something other than DESIGNERNAME
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(DESIGNERNAME).DLL
!endif
!if "$(RUNMODEDLL)"=="YES"
!if "$(_RUNMODESERVERNAME)"==""
_RUNMODESERVERNAME=$(RUNMODE).DLL
!endif
!endif

# Tools
#
!include "Tools.Inc"
SRCDIR=..
FXDIR=..\..\FrameWrk
INTLPATH=.\.

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
LIBS=$(FXDIR)\Debug\CtlFwD32.Lib $(DEVBIN)\htmlhelp\v6\debug\lib\htmlhelp.lib
CFLAGS=-Zil -DDEBUG -Od -FI..\..\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS = $(CFLAGS) /QAieee
!endif
_MTLPREPROCFLAGS = $(_MTLPREPROCFLAGS) /DDEBUG
LINKFLAGS=-debugtype:cv -debug:notmapped,full
RCFLAGS=-dDEBUG
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\debug\CtlFwD32.Lib  ..\..\vblic\debug\vblic.lib

!else if "$(ASICECAP)"!=""
#
# ICECap
#
LIBS=$(FXDIR)\IceCap\CtlFwI32.Lib ICap.Lib msvcrt.lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -FI..\..\include\vc41warn.h
LINKFLAGS=-debug:mapped
_MTLPREPROCFLAGS = $(_MTLPREPROCFLAGS) /DICECAP
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\icecap\CtlFwI32.Lib ..\..\vblic\icecap\vblic.lib

!else
#
# Release
#
LIBS=$(FXDIR)\Release\CtlFwR32.Lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
#
CFLAGS=-Zil -Owxsb1 -FI..\..\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS = $(CFLAGS) /QAl /QAieee
!endif
LINKFLAGS=-debugtype:fixup,cv -debug:notmapped,full
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\release\CtlFwR32.Lib ..\..\vblic\release\vblic.lib

!endif

# 
# The CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file when the object is compiled.  Set CTLS_BROWSE to something
# if you wish a browse file generated.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# default flags
#
INCPATH=-I. -I$(SRCDIR) -I..\..\Include $(_INCPATH)
MLFLAGS=-c -coff $(INCPATH) -nologo
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif
RCFLAGS=-r $(RCFLAGS) $(_RCFLAGS) $(INCPATH)

!ifdef RISC_BLD
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib uuid.lib advapi32.lib oldnames.lib uuid2.lib oleaut32.nt4 comdlg32.lib gdi32.lib 
LFLAGS=$(LINKFLAGS) $(_LFLAGS) -nologo -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE)
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib uuid.lib advapi32.lib oldnames.lib uuid2.lib oleaut32.nt4 comdlg32.lib gdi32.lib
LFLAGS=$(LINKFLAGS) $(_LFLAGS) -nologo -DLL -subsystem:windows,4.00 -nodefaultlib -machine:i386
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!endif

!if "$(ASDEBUG)"!=""
DSGNLFLAGS=-out:$(_SERVERFILENAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_d -def:$(SRCDIR)\$(DESIGNERNAME).def
!else
DSGNLFLAGS=-out:$(_SERVERFILENAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_r -def:$(SRCDIR)\$(DESIGNERNAME).def
!endif
DSGNLIBS=$(LIBS) $(_DSGNLIBS)

!if "$(ASDEBUG)"!=""
RUNLFLAGS=-out:$(_RUNMODESERVERNAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_rt_d -def:$(SRCDIR)\$(RUNMODE).DEF
!else
RUNLFLAGS=-out:$(_RUNMODESERVERNAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_rt_r -def:$(SRCDIR)\$(RUNMODE).DEF
!endif
RUNLIBS=$(LIBS) $(_RUNLIBS)


!IF "$(ALLTARGETS)"==""
ALLTARGETS= \
!if "$(INTLBLD)"==""
!if "$(RUNMODEDLL)"=="YES"
     $(_RUNMODESERVERNAME) \
!endif
     $(_SERVERFILENAME) \
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
	  Lego
!endif
!else
    $(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL
!endif
!endif

!if "$(TLBTARGETS)"==""
TLBTARGETS=$(SRCDIR)\$(DESIGNERNAME).TLB
!endif

!if "$(TLBRUNTARGETS)"==""
TLBRUNTARGETS=$(SRCDIR)\$(RUNMODE).ODL
!endif

!if "$(PCHFILE)"!=""
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif


#=--------------------------------------------------------------------------=
# build the designer, and, if appropriate, the run-mode DLL
#
all: $(ALLTARGETS)

$(_SERVERFILENAME): $(VERSIONHDR) $(DESIGNERNAME).TLB $(OBJS) \
                    $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(DSGNLIBS) $(DSGNLFLAGS)
!if "$(CTLS_BROWSE)"!=""
    $(BSCMAKE) /o $(_SERVERFILENAME).bsc *.sbr
!endif

!if "$(RUNMODEDLL)"=="YES"
$(_RUNMODESERVERNAME): $(VERSIONHDR) \
!if "$(RUNMODETLB)"=="YES"
		$(RUNMODE).TLB \
!endif
		$(RUNOBJS)
    $(LINK) $(RUNOBJS) $(RUNLFLAGS) $(RUNLIBS)
!endif

!if "$(PCHFILE)"!=""
# pre-compiled header targets. 
pch.cpp:
  echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
  $(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif

{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.asm.Obj:
    $(ML) $(MLFLAGS) $<

# TODO: you should come up with some mechanism to generate this file
#       on your own.
#
$(VERSIONHDR) : ..\..\FrameWrk\dwinvers.h
    echo Generating Version Information Header File (dwinvers.h)
    copy ..\..\FrameWrk\dwinvers.h >nul

$(DESIGNERNAME).TLB : $(TLBTARGETS)
    echo Generating $(DESIGNERNAME).TLB and $(DESIGNERNAME)Interfaces.H
    $(CC) $(INCPATH) -nologo /C /E /D__MKTYPLIB__ $(_MTLPREPROCFLAGS) /Tc $(SRCDIR)\$(DESIGNERNAME).ODL > preproc.odl
    $(MKTYPLIB) $(_MKTYPLIBFLAGS) -nologo -nocpp -h $(DESIGNERNAME)Interfaces.H -o Errors.LOG -tlb $(DESIGNERNAME).TLB preproc.odl

$(RUNMODE).TLB : $(TLBRUNTARGETS)
    echo Generating $(RUNMODE).TLB and $(RUNMODE)Interfaces.H
    $(CC) $(INCPATH) -nologo /C /E /D__MKTYPLIB__ $(_MTLPREPROCFLAGS) /Tc $(SRCDIR)\$(RUNMODE).ODL > preproc.odl
    $(MKTYPLIB) $(_MKTYPLIBFLAGS) -nologo -nocpp -h $(RUNMODE)Interfaces.H -o Errors.LOG -tlb $(RUNMODE).TLB preproc.odl

$(DESIGNERNAME).Rbj : $(DESIGNERNAME).TLB $(SRCDIR)\$(DESIGNERNAME).RC
    echo Compiling $(DESIGNERNAME).RC
    $(RC) $(RCFLAGS) -fo $(DESIGNERNAME).Res $(SRCDIR)\$(DESIGNERNAME).Rc
!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(DESIGNERNAME).Rbj $(DESIGNERNAME).Res
!else
    cvtres -machine:ix86 -nologo -out:$(DESIGNERNAME).Rbj $(DESIGNERNAME).Res
!endif

$(RUNMODE).Rbj : \
!if "$(RUNMODETLB)"=="YES"
		$(RUNMODE).TLB \
!endif
		$(SRCDIR)\$(RUNMODE).RC
    echo Compiling $(RUNMODE).RC
    $(RC) $(RCFLAGS) -fo $(RUNMODE).Res $(SRCDIR)\$(RUNMODE).Rc
!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(RUNMODE).Rbj $(RUNMODE).Res
!else
    cvtres -machine:ix86 -nologo -out:$(RUNMODE).Rbj $(RUNMODE).Res
!endif


!if "$(_SERVERBASENAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif

!if "$(RUNMODEDLL)"=="YES"
!if "$(_RUNMODEBASENAME)"==""
!message _RUNMODEBASENAME not set
!endif

!if "$(_RUNMODEEXTENSION)"==""
!message _RUNMODEEXTENSION not set
!endif
!endif

!if "$(INTLBLD)"!=""
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif
!endif

Lego:
!if "$(CTLS_LEGO)"=="YES"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!if "$(_RUNMODEBASENAME)" != ""
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_RUNMODEBASENAME) FILE_EXTENSION=$(_RUNMODEEXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif
!endif

Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp

Dep: GenerateDeps \
!if "$(RUNMODETLB)"=="YES"
     $(RUNMODE).TLB \
!endif     
!if "$(PCHFILE)"!=""
    pch.pch \
!endif
     $(DESIGNERNAME).TLB


GenerateDeps: $(INTLPATH)\HelpStrs.RC $(DESIGNERNAME).TLB dwinvers.h
    echo Generating Dependancies for $(DESIGNERNAME)
!if "$(PCHFILE)"==""
    $(INCLUDES) $(INCPATH) -d $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!else
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!endif


#=----------------------------=
# Include Dependency Makefile 
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\makectl.inc ===
#=------------------------------------------------------------------------=
# MakeCtl.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds a control.  Assumes existence of $(CONTROLNAME), and $(OBJS)
#

.SUFFIXES: .s

#
# Determine the build type.
# You can use this constant to make relative path references to
# other binaries that you need to link to.  For example, 
# ..\..\MyLib\$(BUILDTYPE)\MyLib.Lib
#
!if "$(ASDEBUG)" != ""
BUILDTYPE=DEBUG
BUILDLIB=LIBDBG
!elseif "$(ASICECAP)" != ""
BUILDTYPE=ICECAP
BUILDLIB=LIBICE
!else
BUILDTYPE=RELEASE
BUILDLIB=LIBREL
!endif

#
# targets
#
VERSIONHDR=dwinvers.h

#
# support for naming your OCX something other than CONTROLNAME
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(CONTROLNAME).Ocx
!endif

!if "$(_DEFBASENAME)"==""
_DEFBASENAME=$(CONTROLNAME)
!endif

# Tools
#
!include "Tools.Inc"
SRCDIR=..
FXDIR=..\..\FrameWrk

!if "$(VC4_BUILD)" != ""
_CFLAGS=$(_CFLAGS) -DVC4_BUILD=1
!endif

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
LIBS=$(FXDIR)\Debug\CtlFwD32.Lib 
!if "$(VC4_BUILD)" == ""
LIBS=$(LIBS) $(DEVBIN)\htmlhelp\v6\debug\lib\htmlhelp.lib
!endif
CFLAGS=-Zil -DDEBUG -Od -FI..\..\include\vc41warn.h
!   if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee
!   endif
!if "$(PDBYES)"==""
LFLAGS=-debugtype:cv -debug:notmapped,full -pdb:none
!else
LFLAGS=-debugtype:cv -debug:notmapped,full
!endif
RCFLAGS=-dDEBUG
MLFLAGS=-Zi
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif

!else if "$(ASICECAP)"!=""
#
# ICECap
#
LIBS=$(FXDIR)\IceCap\CtlFwI32.Lib ICap.Lib msvcrt.lib 
!if "$(VC4_BUILD)" == ""
LIBS=$(LIBS) $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif
#
CFLAGS=-Gh -Zil -Oxsb1 -DICECAP -FI..\..\include\vc41warn.h
LFLAGS=-debug:mapped
MLFLAGS=-Zi
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\icecap\CtlFwI32.Lib ..\..\vblic\icecap\vblic.lib
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif
!else
#
# Release
#          
LIBS=$(FXDIR)\Release\CtlFwR32.Lib
!if "$(VC4_BUILD)" == ""
LIBS=$(LIBS) $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif

!if "$(SPENABLED)"==""
#
CFLAGS=-Zil -Oxsb1 -GF -FI..\..\include\vc41warn.h
!   if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
!   endif
!else
#
CFLAGS=-Zil -Oxsb1 -FI..\..\include\vc41warn.h
!   if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
!   endif
!endif

#LNK4078: multiple ".text" sections found with different attributes (40000040)
LFLAGS=/optidata /merge:.rdata=.text /ignore:4078 -OPT:REF -OPT:ICF,4 
MLFLAGS=-Zi 
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\release\CtlFwR32.Lib ..\..\vblic\release\vblic.lib
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
MLFLAGS=$(MLFLAGS) -Gy
!endif

LFLAGS=$(LFLAGS) -debugtype:fixup,cv -debug:notmapped,full
!endif

#
# This is to turn on or off the browse info file
# If CTLS_BROWSE environment variable is set then turn on the
# browse file stuff.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# default flags
#
INCPATH=-I. -I$(SRCDIR) -I..\..\include $(_INCPATH) -I$(DEVBINC)\htmlhelp\v6\idl\include

!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(INCPATH) -nologo $(MLFLAGS)
!elseif "$(PROCESSOR_ARCHITECTURE)"=="MIPS"
MLFLAGS=-c $(INCPATH) -nologo $(MLFLAGS)
!elseif "$(PROCESSOR_ARCHITECTURE)"=="PPC"
MLFLAGS=$(INCPATH) -nologo $(MLFLAGS)
!else
MLFLAGS=-c -coff $(INCPATH) -nologo $(MLFLAGS)
!endif

RCFLAGS=-r -dRC_INVOKED $(RCFLAGS) $(_RCFLAGS) $(INCPATH)

!if "$(ASDEBUG)" != ""
MKTYPLIBFLAGS=$(MKTYPLIBFLAGS) -DDEBUG
MTLPREPROCFLAGS=$(MTLPREPROCFLAGS) -DDEBUG
!elseif "$(ASICECAP)" != ""
MKTYPLIBFLAGS=$(MKTYPLIBFLAGS) -DICECAP
MTLPREPROCFLAGS=$(MTLPREPROCFLAGS) -DICECAP
!endif

!ifdef RISC_BLD
LIBS=$(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib advapi32.lib oldnames.lib oleaut32.nt4 comdlg32.lib gdi32.lib 
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -def:$(SRCDIR)\$(_DEFBASENAME).def
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi -DRISC_BLD $(CFLAGS) $(_CFLAGS) -Tp
MKTYPLIBFLAGS=$(_MKTYPLIBFLAGS) $(MKTYPLIBFLAGS) /DRISC_BLD
MTLPREPROCFLAGS=$(_MTLPREPROCFLAGS) $(MTLPREPROCFLAGS) /DRISC_BLD
!else
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib advapi32.lib oldnames.lib oleaut32.nt4 comdlg32.lib gdi32.lib
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:i386 -def:$(SRCDIR)\$(_DEFBASENAME).def
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
MKTYPLIBFLAGS=$(_MKTYPLIBFLAGS) $(MKTYPLIBFLAGS)
MTLPREPROCFLAGS=$(_MTLPREPROCFLAGS) $(MTLPREPROCFLAGS)
!endif

# Clients can choose to link with their own versions of UUID.LIB
#
!if "$(_NOUUID)" == ""
LIBS=$(LIBS) uuid.lib uuid2.lib
!endif

!if "$(PCHFILE)"!=""
!if "$(PCHBASEFILE)" != ""
OBJS=$(OBJS) $(PCHBASEFILE).obj
PCHFLAGS=-Yu$(PCHFILE)
!else
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif
!endif

# set up our default targets
#
!if "$(ALLTARGETS)"==""
ALLTARGETS=$(_SERVERFILENAME)
!endif

!if "$(TLBTARGETS)"==""
TLBTARGETS=$(SRCDIR)\$(CONTROLNAME).ODL
!endif

#=------------------------------------------------------------------------=
# the good stuff -- the real targets
#
all: $(MORETARGETS) $(ALLTARGETS)

$(_SERVERFILENAME): $(VERSIONHDR) $(CONTROLNAME).TLB $(OBJS) \
		    $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(LIBS) $(LFLAGS)
!if "$(CTLS_BROWSE)"!=""
	$(BSCMAKE) /o $(CONTROLNAME).bsc /S (windows.h eb.h vb.h ole2.h) *.sbr
!endif

# Precompiled header build rules
#
!if "$(PCHFILE)"!=""
!if "$(PCHBASEFILE)" != ""
# pre-compiled header targets. 
$(PCHBASEFILE).cpp:
    echo #include "$(PCHFILE)" > $(PCHBASEFILE).cpp

$(PCHBASEFILE).pch $(PCHBASEFILE).obj: $(SRCDIR)\$(PCHFILE) $(PCHBASEFILE).cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) $(PCHBASEFILE).cpp

!else
# pre-compiled header targets. 
pch.cpp:
    echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif
!endif

# Standard build rules.
# If a .CPP, .C or .ODL file can't
# be found in the other dependencies then it defaults to one of the following build rules
#
{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.s.Obj:
!ifdef RISC_BLD
!  if "$(PROCESSOR_ARCHITECTURE)"=="PPC"
    $(CC) /P /Tc $<
    $(ML) $*.i
     del $*.i
!  else
    $(ML) $(MLFLAGS) $< /Fo$@
!  endif
!else
{$(SRCDIR)}.asm.Obj:
    $(ML) $(MLFLAGS) $<
!endif

# TODO: you should come up with some mechanism to generate this file
#       on your own.
#
$(VERSIONHDR) : ..\..\FrameWrk\dwinvers.h
    echo Generating Version Information Header File (dwinvers.h)
    copy ..\..\FrameWrk\dwinvers.h >nul

$(CONTROLNAME).TLB : $(TLBTARGETS)
    echo Generating $(CONTROLNAME).TLB and $(CONTROLNAME)Interfaces.H
    $(CC) /E /D__MKTYPLIB__ -nologo $(MTLPREPROCFLAGS) $(INCPATH) /Tc $(SRCDIR)\$(CONTROLNAME).ODL > preproc.odl
    $(MKTYPLIB) $(MKTYPLIBFLAGS) -nocpp -nologo  -h $(CONTROLNAME)Interfaces.H -o Errors.LOG -tlb $(CONTROLNAME).TLB preproc.odl
				  
$(CONTROLNAME).Rbj : $(CONTROLNAME).TLB $(SRCDIR)\$(CONTROLNAME).RC
    echo Compiling $(CONTROLNAME).RC
    $(RC) $(RCFLAGS) -fo $(CONTROLNAME).Res $(SRCDIR)\$(CONTROLNAME).Rc
!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(CONTROLNAME).Rbj $(CONTROLNAME).Res
!else
    cvtres -machine:ix86 -nologo -out:$(CONTROLNAME).Rbj $(CONTROLNAME).Res
!endif

Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp

!if "$(PCHFILE)"==""
Dep: $(MORETARGETS) $(CONTROLNAME).TLB
    echo Generating Dependencies for $(CONTROLNAME)
    $(INCLUDES) $(INCPATH) -d $(SRCDIR)\*.c* $(SRCDIR)\*.rc $(SRCDIR)\*.odl > dep.mak
!else
!if "$(PCHBASEFILE)" != ""
Dep: $(MORETARGETS) $(CONTROLNAME).TLB $(PCHBASEFILE).pch
    echo Generating Dependencies for $(CONTROLNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=$(PCHBASEFILE).pch $(SRCDIR)\*.c* $(SRCDIR)\*.rc $(SRCDIR)\*.odl > dep.mak

!else
Dep: $(MORETARGETS) $(CONTROLNAME).TLB pch.pch
    echo Generating Dependencies for $(CONTROLNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* $(SRCDIR)\*.rc $(SRCDIR)\*.odl > dep.mak
!endif
!endif

#=----------------------------=
# Include Dependency Makefile 
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\makelib.inc ===
#=------------------------------------------------------------------------=
# MakeLib.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds a library.  Assumes existence of $(TARGET) and $(OBJS)
# (TARGET is the base name of the library, i.e. datad)
#

#
# targets
#
!if "$(FRAMEWRKDIR)" == ""
!   if "$(MDAC_BUILD)" != ""
FRAMEWRKDIR=..\..\..
!   else
FRAMEWRKDIR=..\..
!   endif
!endif

# Tools
#
!include "Tools.Inc"
!if "$(MDAC_BUILD)" != ""
SRCDIR=\foxde\framewrk
!else
SRCDIR=..
!endif
TARGETLIB=$(TARGET).lib

!if "$(VC4_BUILD)" != ""
_CFLAGS=$(_CFLAGS) -DVC4_BUILD=1
!endif

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
!if "$(MDAC_BUILD)" != ""
CFLAGS=-Zil -DDEBUG -D_DEBUG -DSTRICT -Od -DMDAC_BUILD -FI$(FRAMEWRKDIR)\include\vc41warn.h
!else
CFLAGS=-Zil -DDEBUG -Od -FI$(FRAMEWRKDIR)\include\vc41warn.h
!endif
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee
!endif
RCFLAGS=-dDEBUG

!else if "$(ASICECAP)"!=""
#
# ICECap
#
!if "$(MDAC_BUILD)" != ""
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -DNDEBUG -DSTRICT -DMDAC_BUILD -FI$(FRAMEWRKDIR)\include\vc41warn.h
!else
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -FI$(FRAMEWRKDIR)\include\vc41warn.h
!endif

!else
#
# Release
#
!if "$(MDAC_BUILD)" != ""
CFLAGS=-Zil -Owxsb1 -DNDEBUG -DSTRICT -DMDAC_BUILD -FI$(FRAMEWRKDIR)\include\vc41warn.h
!else
CFLAGS=-Zil -Owxsb1 -FI$(FRAMEWRKDIR)\include\vc41warn.h
!endif

!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
!endif 

!endif

# 
# The CTLSBROWSE or CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file when the object is compiled.  Set CTLSBROWSE or CTLS_BROWSE to something
# if you wish a browse file generated.
!if "$(CTLSBROWSE)" != ""
CTLS_BROWSE=1
!endif

!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# If we have precompiled headers, add the pch file to
# the list of objects and to the compiler flags
#
!if "$(PCHFILE)"!=""
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif

#
# default flags
#   CONSIDER: Will every library always want CV info?
#
INCPATH=-I. -I$(SRCDIR) -I$(FRAMEWRKDIR)\Include $(_INCPATH)
!ifdef RISC_BLD
LIBFLAGS=$(LIBFLAGS) $(_LIBFLAGS) -debugtype:cv -nologo -out:$(TARGETLIB) -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE)
CFLAGS=-nologo -c $(INCPATH) -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
LIBFLAGS=$(LIBFLAGS) $(_LIBFLAGS) -debugtype:cv -nologo -out:$(TARGETLIB) -subsystem:windows,4.00 -nodefaultlib -machine:ix86
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!endif

!if "$(PCHFILE)" == ""
all: $(MORETARGETS) $(TARGETLIB)
!else
all: pch.pch $(MORETARGETS) $(TARGETLIB)
!endif

$(TARGETLIB): $(OBJS) $(SRCDIR)\Makefile
    $(LIBRARIAN) $(OBJS) $(LIBFLAGS)
!if "$(DATABROWSE)"!=""
    $(BSCMAKE) /o $(TARGET).bsc /S (windows.h ole2.h) *.sbr
!endif

# Precompiled header build rules
#
!if "$(PCHFILE)"!=""
# pre-compiled header targets. 
pch.cpp:
    echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif


# Standard build rules.  
# If a .CPP, .C or .ODL file can't
# be found in the other dependencies then it defaults to one of the following build rules
#
{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<


Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp


!if "$(PCHFILE)"==""
Dep: $(MORETARGETS)
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d $(SRCDIR)\*.c* > dep.mak
!else
Dep: pch.pch $(MORETARGETS) 
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* > dep.mak
!endif

#=----------------------------=
# Include Dependency Makefile 
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\ocx96.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Wed Mar 27 07:31:34 1996
 */
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ocx96_h__
#define __ocx96_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

typedef interface IAdviseSinkEx IAdviseSinkEx;


typedef interface IOleInPlaceObjectWindowless IOleInPlaceObjectWindowless;


typedef interface IOleInPlaceSiteEx IOleInPlaceSiteEx;


typedef interface IOleInPlaceSiteWindowless IOleInPlaceSiteWindowless;


typedef interface IViewObjectEx IViewObjectEx;


typedef interface IOleUndoUnit IOleUndoUnit;


typedef interface IOleParentUndoUnit IOleParentUndoUnit;


typedef interface IEnumOleUndoUnits IEnumOleUndoUnits;


typedef interface IOleUndoManager IOleUndoManager;


typedef interface IQuickActivate IQuickActivate;


typedef interface IPointerInactive IPointerInactive;


/* header files for imported files */

#ifndef _MAC 
#include "oaidl.h"
#endif
#include "olectl.h"

#ifndef _MAC 
#include "datapath.h"
#else
#define IBindHost IUnknown
#endif


/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#define OLEMISC_IGNOREACTIVATEWHENVISIBLE 0x00080000
#define OLEMISC_SUPPORTSMULTILEVELUNDO    0x00200000




/****************************************
 * Generated header for interface: IAdviseSinkEx
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IAdviseSinkEx *LPADVISESINKEX;


EXTERN_C const IID IID_IAdviseSinkEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAdviseSinkEx : public IAdviseSink
    {
    public:
        virtual void __stdcall OnViewStatusChange( 
            /* [in] */ DWORD dwViewStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAdviseSinkExVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IAdviseSinkEx * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IAdviseSinkEx * This);
        
        ULONG ( __stdcall *Release )( 
            IAdviseSinkEx * This);
        
        /* [local] */ void ( __stdcall *OnDataChange )( 
            IAdviseSinkEx * This,
            /* [unique][in] */ FORMATETC *pFormatetc,
            /* [unique][in] */ STGMEDIUM *pStgmed);
        
        /* [local] */ void ( __stdcall *OnViewChange )( 
            IAdviseSinkEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex);
        
        /* [local] */ void ( __stdcall *OnRename )( 
            IAdviseSinkEx * This,
            /* [in] */ IMoniker *pmk);
        
        /* [local] */ void ( __stdcall *OnSave )( 
            IAdviseSinkEx * This);
        
        /* [local] */ void ( __stdcall *OnClose )( 
            IAdviseSinkEx * This);
        
        void ( __stdcall *OnViewStatusChange )( 
            IAdviseSinkEx * This,
            /* [in] */ DWORD dwViewStatus);
        
    } IAdviseSinkExVtbl;

    interface IAdviseSinkEx
    {
        CONST_VTBL struct IAdviseSinkExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdviseSinkEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdviseSinkEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdviseSinkEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdviseSinkEx_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> OnDataChange(This,pFormatetc,pStgmed)

#define IAdviseSinkEx_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> OnViewChange(This,dwAspect,lindex)

#define IAdviseSinkEx_OnRename(This,pmk)	\
    (This)->lpVtbl -> OnRename(This,pmk)

#define IAdviseSinkEx_OnSave(This)	\
    (This)->lpVtbl -> OnSave(This)

#define IAdviseSinkEx_OnClose(This)	\
    (This)->lpVtbl -> OnClose(This)


#define IAdviseSinkEx_OnViewStatusChange(This,dwViewStatus)	\
    (This)->lpVtbl -> OnViewStatusChange(This,dwViewStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void __stdcall IAdviseSinkEx_OnViewStatusChange_Proxy( 
    IAdviseSinkEx * This,
    /* [in] */ DWORD dwViewStatus);






/****************************************
 * Generated header for interface: __MIDL__intf_0087
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IAdviseSinkEx * LPADVISESINKEX;




/****************************************
 * Generated header for interface: IOleInPlaceObjectWindowless
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IOleInPlaceObjectWindowless *LPOLEINPLACEOBJECTWINDOWLESS;


EXTERN_C const IID IID_IOleInPlaceObjectWindowless;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceObjectWindowless : public IOleInPlaceObject
    {
    public:
        virtual HRESULT __stdcall OnWindowMessage( 
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lparam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT __stdcall GetDropTarget( 
            /* [out] */ IDropTarget **ppDropTarget) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceObjectWindowlessVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleInPlaceObjectWindowless * This);
        
        ULONG ( __stdcall *Release )( 
            IOleInPlaceObjectWindowless * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *GetWindow )( 
            IOleInPlaceObjectWindowless * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( __stdcall *ContextSensitiveHelp )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall *InPlaceDeactivate )( 
            IOleInPlaceObjectWindowless * This);
        
        HRESULT ( __stdcall *UIDeactivate )( 
            IOleInPlaceObjectWindowless * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *SetObjectRects )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ LPCRECT lprcPosRect,
            /* [in] */ LPCRECT lprcClipRect);
        
        HRESULT ( __stdcall *ReactivateAndUndo )( 
            IOleInPlaceObjectWindowless * This);
        
        HRESULT ( __stdcall *OnWindowMessage )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lparam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( __stdcall *GetDropTarget )( 
            IOleInPlaceObjectWindowless * This,
            /* [out] */ IDropTarget **ppDropTarget);
        
    } IOleInPlaceObjectWindowlessVtbl;

    interface IOleInPlaceObjectWindowless
    {
        CONST_VTBL struct IOleInPlaceObjectWindowlessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceObjectWindowless_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceObjectWindowless_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceObjectWindowless_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceObjectWindowless_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceObjectWindowless_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceObjectWindowless_InPlaceDeactivate(This)	\
    (This)->lpVtbl -> InPlaceDeactivate(This)

#define IOleInPlaceObjectWindowless_UIDeactivate(This)	\
    (This)->lpVtbl -> UIDeactivate(This)

#define IOleInPlaceObjectWindowless_SetObjectRects(This,lprcPosRect,lprcClipRect)	\
    (This)->lpVtbl -> SetObjectRects(This,lprcPosRect,lprcClipRect)

#define IOleInPlaceObjectWindowless_ReactivateAndUndo(This)	\
    (This)->lpVtbl -> ReactivateAndUndo(This)


#define IOleInPlaceObjectWindowless_OnWindowMessage(This,msg,wParam,lparam,plResult)	\
    (This)->lpVtbl -> OnWindowMessage(This,msg,wParam,lparam,plResult)

#define IOleInPlaceObjectWindowless_GetDropTarget(This,ppDropTarget)	\
    (This)->lpVtbl -> GetDropTarget(This,ppDropTarget)

#endif /* COBJMACROS */


#endif 	/* C style interface */










/****************************************
 * Generated header for interface: __MIDL__intf_0088
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleInPlaceObjectWindowless * LPOLEINPLACEOBJECTWINDOWLESS;




/****************************************
 * Generated header for interface: IOleInPlaceSiteEx
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 2 */
typedef 
enum _ACTIVATEFLAGS
    {	ACTIVATE_WINDOWLESS	= 1
    }	ACTIVATEFLAGS;


EXTERN_C const IID IID_IOleInPlaceSiteEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceSiteEx : public IOleInPlaceSite
    {
    public:
        virtual HRESULT __stdcall OnInPlaceActivateEx( 
            /* [out] */ BOOL *pfNoRedraw,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT __stdcall OnInPlaceDeactivateEx( 
            /* [in] */ BOOL fNoRedraw) = 0;
        
        virtual HRESULT __stdcall RequestUIActivate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceSiteExVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleInPlaceSiteEx * This);
        
        ULONG ( __stdcall *Release )( 
            IOleInPlaceSiteEx * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *GetWindow )( 
            IOleInPlaceSiteEx * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( __stdcall *ContextSensitiveHelp )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall *CanInPlaceActivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *OnInPlaceActivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *OnUIActivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *GetWindowContext )( 
            IOleInPlaceSiteEx * This,
            /* [out] */ IOleInPlaceFrame **ppFrame,
            /* [out] */ IOleInPlaceUIWindow **ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( __stdcall *Scroll )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( __stdcall *OnUIDeactivate )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( __stdcall *OnInPlaceDeactivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *DiscardUndoState )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *DeactivateAndUndo )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *OnPosRectChange )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ LPCRECT lprcPosRect);
        
        HRESULT ( __stdcall *OnInPlaceActivateEx )( 
            IOleInPlaceSiteEx * This,
            /* [out] */ BOOL *pfNoRedraw,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( __stdcall *OnInPlaceDeactivateEx )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ BOOL fNoRedraw);
        
        HRESULT ( __stdcall *RequestUIActivate )( 
            IOleInPlaceSiteEx * This);
        
    } IOleInPlaceSiteExVtbl;

    interface IOleInPlaceSiteEx
    {
        CONST_VTBL struct IOleInPlaceSiteExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceSiteEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceSiteEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceSiteEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceSiteEx_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceSiteEx_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceSiteEx_CanInPlaceActivate(This)	\
    (This)->lpVtbl -> CanInPlaceActivate(This)

#define IOleInPlaceSiteEx_OnInPlaceActivate(This)	\
    (This)->lpVtbl -> OnInPlaceActivate(This)

#define IOleInPlaceSiteEx_OnUIActivate(This)	\
    (This)->lpVtbl -> OnUIActivate(This)

#define IOleInPlaceSiteEx_GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)	\
    (This)->lpVtbl -> GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)

#define IOleInPlaceSiteEx_Scroll(This,scrollExtant)	\
    (This)->lpVtbl -> Scroll(This,scrollExtant)

#define IOleInPlaceSiteEx_OnUIDeactivate(This,fUndoable)	\
    (This)->lpVtbl -> OnUIDeactivate(This,fUndoable)

#define IOleInPlaceSiteEx_OnInPlaceDeactivate(This)	\
    (This)->lpVtbl -> OnInPlaceDeactivate(This)

#define IOleInPlaceSiteEx_DiscardUndoState(This)	\
    (This)->lpVtbl -> DiscardUndoState(This)

#define IOleInPlaceSiteEx_DeactivateAndUndo(This)	\
    (This)->lpVtbl -> DeactivateAndUndo(This)

#define IOleInPlaceSiteEx_OnPosRectChange(This,lprcPosRect)	\
    (This)->lpVtbl -> OnPosRectChange(This,lprcPosRect)


#define IOleInPlaceSiteEx_OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)	\
    (This)->lpVtbl -> OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)

#define IOleInPlaceSiteEx_OnInPlaceDeactivateEx(This,fNoRedraw)	\
    (This)->lpVtbl -> OnInPlaceDeactivateEx(This,fNoRedraw)

#define IOleInPlaceSiteEx_RequestUIActivate(This)	\
    (This)->lpVtbl -> RequestUIActivate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */












/****************************************
 * Generated header for interface: __MIDL__intf_0089
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleInPlaceSiteEx * LPOLEINPLACESITEEX;




/****************************************
 * Generated header for interface: IOleInPlaceSiteWindowless
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IOleInPlaceSiteWindowless *LPOLEINPLACESITEWINDOWLESS;

#define OLEDC_NODRAW 1
#define OLEDC_PAINTBKGND 2
#define OLEDC_OFFSCREEN 4

EXTERN_C const IID IID_IOleInPlaceSiteWindowless;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceSiteWindowless : public IOleInPlaceSiteEx
    {
    public:
        virtual HRESULT __stdcall CanWindowlessActivate( void) = 0;
        
        virtual HRESULT __stdcall GetCapture( void) = 0;
        
        virtual HRESULT __stdcall SetCapture( 
            /* [in] */ BOOL fCapture) = 0;
        
        virtual HRESULT __stdcall GetFocus( void) = 0;
        
        virtual HRESULT __stdcall SetFocus( 
            /* [in] */ BOOL fFocus) = 0;
        
        virtual HRESULT __stdcall GetDC( 
            /* [in] */ LPCRECT prc,
            /* [in] */ DWORD grfFlags,
            /* [out] */ HDC *phDC) = 0;
        
        virtual HRESULT __stdcall ReleaseDC( 
            /* [in] */ HDC hDC) = 0;
        
        virtual HRESULT __stdcall InvalidateRect( 
            /* [in] */ LPCRECT prc,
            /* [in] */ BOOL fErase) = 0;
        
        virtual HRESULT __stdcall InvalidateRgn( 
            /* [in] */ HRGN hrgn,
            /* [in] */ BOOL fErase) = 0;
        
        virtual HRESULT __stdcall ScrollRect( 
            /* [in] */ int dx,
            /* [in] */ int dy,
            /* [in] */ LPCRECT prcScroll,
            /* [in] */ LPCRECT prcClip) = 0;
        
        virtual HRESULT __stdcall AdjustRect( 
            /* [out][in] */ LPRECT prc) = 0;
        
        virtual HRESULT __stdcall OnDefWindowMessage( 
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceSiteWindowlessVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleInPlaceSiteWindowless * This);
        
        ULONG ( __stdcall *Release )( 
            IOleInPlaceSiteWindowless * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *GetWindow )( 
            IOleInPlaceSiteWindowless * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( __stdcall *ContextSensitiveHelp )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall *CanInPlaceActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *OnInPlaceActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *OnUIActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *GetWindowContext )( 
            IOleInPlaceSiteWindowless * This,
            /* [out] */ IOleInPlaceFrame **ppFrame,
            /* [out] */ IOleInPlaceUIWindow **ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( __stdcall *Scroll )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( __stdcall *OnUIDeactivate )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( __stdcall *OnInPlaceDeactivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *DiscardUndoState )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *DeactivateAndUndo )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *OnPosRectChange )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ LPCRECT lprcPosRect);
        
        HRESULT ( __stdcall *OnInPlaceActivateEx )( 
            IOleInPlaceSiteWindowless * This,
            /* [out] */ BOOL *pfNoRedraw,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( __stdcall *OnInPlaceDeactivateEx )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fNoRedraw);
        
        HRESULT ( __stdcall *RequestUIActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *CanWindowlessActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *GetCapture )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *SetCapture )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fCapture);
        
        HRESULT ( __stdcall *GetFocus )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *SetFocus )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fFocus);
        
        HRESULT ( __stdcall *GetDC )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ LPCRECT prc,
            /* [in] */ DWORD grfFlags,
            /* [out] */ HDC *phDC);
        
        HRESULT ( __stdcall *ReleaseDC )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ HDC hDC);
        
        HRESULT ( __stdcall *InvalidateRect )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ LPCRECT prc,
            /* [in] */ BOOL fErase);
        
        HRESULT ( __stdcall *InvalidateRgn )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ HRGN hrgn,
            /* [in] */ BOOL fErase);
        
        HRESULT ( __stdcall *ScrollRect )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ int dx,
            /* [in] */ int dy,
            /* [in] */ LPCRECT prcScroll,
            /* [in] */ LPCRECT prcClip);
        
        HRESULT ( __stdcall *AdjustRect )( 
            IOleInPlaceSiteWindowless * This,
            /* [out][in] */ LPRECT prc);
        
        HRESULT ( __stdcall *OnDefWindowMessage )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
    } IOleInPlaceSiteWindowlessVtbl;

    interface IOleInPlaceSiteWindowless
    {
        CONST_VTBL struct IOleInPlaceSiteWindowlessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceSiteWindowless_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceSiteWindowless_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceSiteWindowless_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceSiteWindowless_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceSiteWindowless_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceSiteWindowless_CanInPlaceActivate(This)	\
    (This)->lpVtbl -> CanInPlaceActivate(This)

#define IOleInPlaceSiteWindowless_OnInPlaceActivate(This)	\
    (This)->lpVtbl -> OnInPlaceActivate(This)

#define IOleInPlaceSiteWindowless_OnUIActivate(This)	\
    (This)->lpVtbl -> OnUIActivate(This)

#define IOleInPlaceSiteWindowless_GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)	\
    (This)->lpVtbl -> GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)

#define IOleInPlaceSiteWindowless_Scroll(This,scrollExtant)	\
    (This)->lpVtbl -> Scroll(This,scrollExtant)

#define IOleInPlaceSiteWindowless_OnUIDeactivate(This,fUndoable)	\
    (This)->lpVtbl -> OnUIDeactivate(This,fUndoable)

#define IOleInPlaceSiteWindowless_OnInPlaceDeactivate(This)	\
    (This)->lpVtbl -> OnInPlaceDeactivate(This)

#define IOleInPlaceSiteWindowless_DiscardUndoState(This)	\
    (This)->lpVtbl -> DiscardUndoState(This)

#define IOleInPlaceSiteWindowless_DeactivateAndUndo(This)	\
    (This)->lpVtbl -> DeactivateAndUndo(This)

#define IOleInPlaceSiteWindowless_OnPosRectChange(This,lprcPosRect)	\
    (This)->lpVtbl -> OnPosRectChange(This,lprcPosRect)


#define IOleInPlaceSiteWindowless_OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)	\
    (This)->lpVtbl -> OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)

#define IOleInPlaceSiteWindowless_OnInPlaceDeactivateEx(This,fNoRedraw)	\
    (This)->lpVtbl -> OnInPlaceDeactivateEx(This,fNoRedraw)

#define IOleInPlaceSiteWindowless_RequestUIActivate(This)	\
    (This)->lpVtbl -> RequestUIActivate(This)


#define IOleInPlaceSiteWindowless_CanWindowlessActivate(This)	\
    (This)->lpVtbl -> CanWindowlessActivate(This)

#define IOleInPlaceSiteWindowless_GetCapture(This)	\
    (This)->lpVtbl -> GetCapture(This)

#define IOleInPlaceSiteWindowless_SetCapture(This,fCapture)	\
    (This)->lpVtbl -> SetCapture(This,fCapture)

#define IOleInPlaceSiteWindowless_GetFocus(This)	\
    (This)->lpVtbl -> GetFocus(This)

#define IOleInPlaceSiteWindowless_SetFocus(This,fFocus)	\
    (This)->lpVtbl -> SetFocus(This,fFocus)

#define IOleInPlaceSiteWindowless_GetDC(This,prc,grfFlags,phDC)	\
    (This)->lpVtbl -> GetDC(This,prc,grfFlags,phDC)

#define IOleInPlaceSiteWindowless_ReleaseDC(This,hDC)	\
    (This)->lpVtbl -> ReleaseDC(This,hDC)

#define IOleInPlaceSiteWindowless_InvalidateRect(This,prc,fErase)	\
    (This)->lpVtbl -> InvalidateRect(This,prc,fErase)

#define IOleInPlaceSiteWindowless_InvalidateRgn(This,hrgn,fErase)	\
    (This)->lpVtbl -> InvalidateRgn(This,hrgn,fErase)

#define IOleInPlaceSiteWindowless_ScrollRect(This,dx,dy,prcScroll,prcClip)	\
    (This)->lpVtbl -> ScrollRect(This,dx,dy,prcScroll,prcClip)

#define IOleInPlaceSiteWindowless_AdjustRect(This,prc)	\
    (This)->lpVtbl -> AdjustRect(This,prc)

#define IOleInPlaceSiteWindowless_OnDefWindowMessage(This,msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowMessage(This,msg,wParam,lParam,plResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */






























/****************************************
 * Generated header for interface: __MIDL__intf_0090
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleInPlaceSiteWindowless * LPOLEINPLACESITEWINDOWLESS;




/****************************************
 * Generated header for interface: IViewObjectEx
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IViewObjectEx *LPVIEWOBJECTEX;

			/* size is 2 */
typedef 
enum _VIEWSTATUS
    {	VIEWSTATUS_OPAQUE	= 1,
	VIEWSTATUS_SOLIDBKGND	= 2,
	VIEWSTATUS_DVASPECTOPAQUE	= 4,
	VIEWSTATUS_DVASPECTTRANSPARENT	= 8
    }	VIEWSTATUS;

			/* size is 2 */
typedef 
enum _HITRESULT
    {	HITRESULT_OUTSIDE	= 0,
	HITRESULT_TRANSPARENT	= 1,
	HITRESULT_CLOSE	= 2,
	HITRESULT_HIT	= 3
    }	HITRESULT;

			/* size is 2 */
typedef 
enum _DVASPECT2
    {	DVASPECT_OPAQUE	= 16,
	DVASPECT_TRANSPARENT	= 32
    }	DVASPECT2;

			/* size is 16 */
typedef struct  tagExtentInfo
    {
    UINT cb;
    DWORD dwExtentMode;
    SIZEL sizelProposed;
    }	DVEXTENTINFO;

			/* size is 2 */
typedef 
enum tagExtentMode
    {	DVEXTENT_CONTENT	= 0,
	DVEXTENT_INTEGRAL	= DVEXTENT_CONTENT + 1
    }	DVEXTENTMODE;

			/* size is 2 */
typedef 
enum tagAspectInfoFlag
    {	DVASPECTINFOFLAG_CANOPTIMIZE	= 1
    }	DVASPECTINFOFLAG;

			/* size is 8 */
typedef struct  tagAspectInfo
    {
    UINT cb;
    DWORD dwFlags;
    }	DVASPECTINFO;


EXTERN_C const IID IID_IViewObjectEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IViewObjectEx : public IViewObject2
    {
    public:
        virtual HRESULT __stdcall GetRect( 
            /* [in] */ DWORD dwAspect,
            /* [out] */ LPRECTL pRect) = 0;
        
        virtual HRESULT __stdcall GetViewStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT __stdcall QueryHitPoint( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ POINT ptlLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult) = 0;
        
        virtual HRESULT __stdcall QueryHitRect( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ LPCRECT prcLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult) = 0;
        
        virtual HRESULT __stdcall GetNaturalExtent( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [in] */ DVEXTENTINFO *pExtentInfo,
            /* [out] */ LPSIZEL psizel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewObjectExVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IViewObjectEx * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IViewObjectEx * This);
        
        ULONG ( __stdcall *Release )( 
            IViewObjectEx * This);
        
        HRESULT ( __stdcall *Draw )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall __stdcall *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue);
        
        HRESULT ( __stdcall *GetColorSet )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE **ppColorSet);
        
        HRESULT ( __stdcall *Freeze )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [out] */ DWORD *pdwFreeze);
        
        HRESULT ( __stdcall *Unfreeze )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( __stdcall *SetAdvise )( 
            IViewObjectEx * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink *pAdvSink);
        
        HRESULT ( __stdcall *GetAdvise )( 
            IViewObjectEx * This,
            /* [out] */ DWORD *pAspects,
            /* [out] */ DWORD *pAdvf,
            /* [out] */ IAdviseSink **ppAdvSink);
        
        HRESULT ( __stdcall *GetExtent )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [out] */ LPSIZEL lpsizel);
        
        HRESULT ( __stdcall *GetRect )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [out] */ LPRECTL pRect);
        
        HRESULT ( __stdcall *GetViewStatus )( 
            IViewObjectEx * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( __stdcall *QueryHitPoint )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ POINT ptlLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult);
        
        HRESULT ( __stdcall *QueryHitRect )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ LPCRECT prcLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult);
        
        HRESULT ( __stdcall *GetNaturalExtent )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [in] */ DVEXTENTINFO *pExtentInfo,
            /* [out] */ LPSIZEL psizel);
        
    } IViewObjectExVtbl;

    interface IViewObjectEx
    {
        CONST_VTBL struct IViewObjectExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewObjectEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewObjectEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewObjectEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewObjectEx_Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)	\
    (This)->lpVtbl -> Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)

#define IViewObjectEx_GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)	\
    (This)->lpVtbl -> GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)

#define IViewObjectEx_Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)	\
    (This)->lpVtbl -> Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)

#define IViewObjectEx_Unfreeze(This,dwFreeze)	\
    (This)->lpVtbl -> Unfreeze(This,dwFreeze)

#define IViewObjectEx_SetAdvise(This,aspects,advf,pAdvSink)	\
    (This)->lpVtbl -> SetAdvise(This,aspects,advf,pAdvSink)

#define IViewObjectEx_GetAdvise(This,pAspects,pAdvf,ppAdvSink)	\
    (This)->lpVtbl -> GetAdvise(This,pAspects,pAdvf,ppAdvSink)


#define IViewObjectEx_GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)	\
    (This)->lpVtbl -> GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)


#define IViewObjectEx_GetRect(This,dwAspect,pRect)	\
    (This)->lpVtbl -> GetRect(This,dwAspect,pRect)

#define IViewObjectEx_GetViewStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetViewStatus(This,pdwStatus)

#define IViewObjectEx_QueryHitPoint(This,dwAspect,pRectBounds,ptlLoc,lCloseHint,pHitResult)	\
    (This)->lpVtbl -> QueryHitPoint(This,dwAspect,pRectBounds,ptlLoc,lCloseHint,pHitResult)

#define IViewObjectEx_QueryHitRect(This,dwAspect,pRectBounds,prcLoc,lCloseHint,pHitResult)	\
    (This)->lpVtbl -> QueryHitRect(This,dwAspect,pRectBounds,prcLoc,lCloseHint,pHitResult)

#define IViewObjectEx_GetNaturalExtent(This,dwAspect,lindex,ptd,hicTargetDev,pExtentInfo,psizel)	\
    (This)->lpVtbl -> GetNaturalExtent(This,dwAspect,lindex,ptd,hicTargetDev,pExtentInfo,psizel)

#endif /* COBJMACROS */


#endif 	/* C style interface */
















/****************************************
 * Generated header for interface: __MIDL__intf_0091
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IViewObjectEx * LPVIEWOBJECTEX;
			/* size is 0 */

#define UAS_NORMAL         0
#define UAS_BLOCKED        1
#define UAS_NOPARENTENABLE 2
#define UAS_MASK           0x03




/****************************************
 * Generated header for interface: IOleUndoUnit
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IOleUndoUnit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleUndoUnit : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Do( 
            /* [in] */ IOleUndoManager *pUndoManager) = 0;
        
        virtual HRESULT __stdcall GetDescription( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT __stdcall GetUnitType( 
            /* [out] */ CLSID *pclsid,
            /* [out] */ LONG *plID) = 0;
        
        virtual HRESULT __stdcall OnNextAdd( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleUndoUnitVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleUndoUnit * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleUndoUnit * This);
        
        ULONG ( __stdcall *Release )( 
            IOleUndoUnit * This);
        
        HRESULT ( __stdcall *Do )( 
            IOleUndoUnit * This,
            /* [in] */ IOleUndoManager *pUndoManager);
        
        HRESULT ( __stdcall *GetDescription )( 
            IOleUndoUnit * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *GetUnitType )( 
            IOleUndoUnit * This,
            /* [out] */ CLSID *pclsid,
            /* [out] */ LONG *plID);
        
        HRESULT ( __stdcall *OnNextAdd )( 
            IOleUndoUnit * This);
        
    } IOleUndoUnitVtbl;

    interface IOleUndoUnit
    {
        CONST_VTBL struct IOleUndoUnitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleUndoUnit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleUndoUnit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleUndoUnit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleUndoUnit_Do(This,pUndoManager)	\
    (This)->lpVtbl -> Do(This,pUndoManager)

#define IOleUndoUnit_GetDescription(This,pbstr)	\
    (This)->lpVtbl -> GetDescription(This,pbstr)

#define IOleUndoUnit_GetUnitType(This,pclsid,plID)	\
    (This)->lpVtbl -> GetUnitType(This,pclsid,plID)

#define IOleUndoUnit_OnNextAdd(This)	\
    (This)->lpVtbl -> OnNextAdd(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */














/****************************************
 * Generated header for interface: __MIDL__intf_0092
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleUndoUnit * LPOLEUNDOUNIT;




/****************************************
 * Generated header for interface: IOleParentUndoUnit
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IOleParentUndoUnit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleParentUndoUnit : public IOleUndoUnit
    {
    public:
        virtual HRESULT __stdcall Open( 
            /* [in] */ IOleParentUndoUnit *pPUU) = 0;
        
        virtual HRESULT __stdcall Close( 
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit) = 0;
        
        virtual HRESULT __stdcall Add( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall FindUnit( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall GetParentState( 
            /* [out] */ DWORD *pdwState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleParentUndoUnitVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleParentUndoUnit * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleParentUndoUnit * This);
        
        ULONG ( __stdcall *Release )( 
            IOleParentUndoUnit * This);
        
        HRESULT ( __stdcall *Do )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleUndoManager *pUndoManager);
        
        HRESULT ( __stdcall *GetDescription )( 
            IOleParentUndoUnit * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *GetUnitType )( 
            IOleParentUndoUnit * This,
            /* [out] */ CLSID *pclsid,
            /* [out] */ LONG *plID);
        
        HRESULT ( __stdcall *OnNextAdd )( 
            IOleParentUndoUnit * This);
        
        HRESULT ( __stdcall *Open )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleParentUndoUnit *pPUU);
        
        HRESULT ( __stdcall *Close )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit);
        
        HRESULT ( __stdcall *Add )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *FindUnit )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *GetParentState )( 
            IOleParentUndoUnit * This,
            /* [out] */ DWORD *pdwState);
        
    } IOleParentUndoUnitVtbl;

    interface IOleParentUndoUnit
    {
        CONST_VTBL struct IOleParentUndoUnitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleParentUndoUnit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleParentUndoUnit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleParentUndoUnit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleParentUndoUnit_Do(This,pUndoManager)	\
    (This)->lpVtbl -> Do(This,pUndoManager)

#define IOleParentUndoUnit_GetDescription(This,pbstr)	\
    (This)->lpVtbl -> GetDescription(This,pbstr)

#define IOleParentUndoUnit_GetUnitType(This,pclsid,plID)	\
    (This)->lpVtbl -> GetUnitType(This,pclsid,plID)

#define IOleParentUndoUnit_OnNextAdd(This)	\
    (This)->lpVtbl -> OnNextAdd(This)


#define IOleParentUndoUnit_Open(This,pPUU)	\
    (This)->lpVtbl -> Open(This,pPUU)

#define IOleParentUndoUnit_Close(This,pPUU,fCommit)	\
    (This)->lpVtbl -> Close(This,pPUU,fCommit)

#define IOleParentUndoUnit_Add(This,pUU)	\
    (This)->lpVtbl -> Add(This,pUU)

#define IOleParentUndoUnit_FindUnit(This,pUU)	\
    (This)->lpVtbl -> FindUnit(This,pUU)

#define IOleParentUndoUnit_GetParentState(This,pdwState)	\
    (This)->lpVtbl -> GetParentState(This,pdwState)

#endif /* COBJMACROS */


#endif 	/* C style interface */
















/****************************************
 * Generated header for interface: __MIDL__intf_0093
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleParentUndoUnit * LPOLEPARENTUNDOUNIT;




/****************************************
 * Generated header for interface: IEnumOleUndoUnits
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IEnumOleUndoUnits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumOleUndoUnits : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out][length_is][size_is][out] */ IOleUndoUnit **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumOleUndoUnits **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOleUndoUnitsVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IEnumOleUndoUnits * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IEnumOleUndoUnits * This);
        
        ULONG ( __stdcall *Release )( 
            IEnumOleUndoUnits * This);
        
        HRESULT ( __stdcall *Next )( 
            IEnumOleUndoUnits * This,
            /* [in] */ ULONG celt,
            /* [out][length_is][size_is][out] */ IOleUndoUnit **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( __stdcall *Skip )( 
            IEnumOleUndoUnits * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall *Reset )( 
            IEnumOleUndoUnits * This);
        
        HRESULT ( __stdcall *Clone )( 
            IEnumOleUndoUnits * This,
            /* [out] */ IEnumOleUndoUnits **ppenum);
        
    } IEnumOleUndoUnitsVtbl;

    interface IEnumOleUndoUnits
    {
        CONST_VTBL struct IEnumOleUndoUnitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOleUndoUnits_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumOleUndoUnits_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumOleUndoUnits_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumOleUndoUnits_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumOleUndoUnits_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumOleUndoUnits_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumOleUndoUnits_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */














/****************************************
 * Generated header for interface: __MIDL__intf_0094
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IEnumOleUndoUnits * LPENUMOLEUNDOUNITS;
#define SID_SOleUndoManager IID_IOleUndoManager




/****************************************
 * Generated header for interface: IOleUndoManager
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IOleUndoManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleUndoManager : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Open( 
            /* [in] */ IOleParentUndoUnit *pPUU) = 0;
        
        virtual HRESULT __stdcall Close( 
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit) = 0;
        
        virtual HRESULT __stdcall Add( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall GetOpenParentState( 
            /* [out] */ DWORD *pdwState) = 0;
        
        virtual HRESULT __stdcall DiscardFrom( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall UndoTo( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall RedoTo( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall EnumUndoable( 
            /* [out] */ IEnumOleUndoUnits **ppEnum) = 0;
        
        virtual HRESULT __stdcall EnumRedoable( 
            /* [out] */ IEnumOleUndoUnits **ppEnum) = 0;
        
        virtual HRESULT __stdcall GetLastUndoDescription( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT __stdcall GetLastRedoDescription( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT __stdcall Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleUndoManagerVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleUndoManager * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleUndoManager * This);
        
        ULONG ( __stdcall *Release )( 
            IOleUndoManager * This);
        
        HRESULT ( __stdcall *Open )( 
            IOleUndoManager * This,
            /* [in] */ IOleParentUndoUnit *pPUU);
        
        HRESULT ( __stdcall *Close )( 
            IOleUndoManager * This,
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit);
        
        HRESULT ( __stdcall *Add )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *GetOpenParentState )( 
            IOleUndoManager * This,
            /* [out] */ DWORD *pdwState);
        
        HRESULT ( __stdcall *DiscardFrom )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *UndoTo )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *RedoTo )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *EnumUndoable )( 
            IOleUndoManager * This,
            /* [out] */ IEnumOleUndoUnits **ppEnum);
        
        HRESULT ( __stdcall *EnumRedoable )( 
            IOleUndoManager * This,
            /* [out] */ IEnumOleUndoUnits **ppEnum);
        
        HRESULT ( __stdcall *GetLastUndoDescription )( 
            IOleUndoManager * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *GetLastRedoDescription )( 
            IOleUndoManager * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *Enable )( 
            IOleUndoManager * This,
            /* [in] */ BOOL fEnable);
        
    } IOleUndoManagerVtbl;

    interface IOleUndoManager
    {
        CONST_VTBL struct IOleUndoManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleUndoManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleUndoManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleUndoManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleUndoManager_Open(This,pPUU)	\
    (This)->lpVtbl -> Open(This,pPUU)

#define IOleUndoManager_Close(This,pPUU,fCommit)	\
    (This)->lpVtbl -> Close(This,pPUU,fCommit)

#define IOleUndoManager_Add(This,pUU)	\
    (This)->lpVtbl -> Add(This,pUU)

#define IOleUndoManager_GetOpenParentState(This,pdwState)	\
    (This)->lpVtbl -> GetOpenParentState(This,pdwState)

#define IOleUndoManager_DiscardFrom(This,pUU)	\
    (This)->lpVtbl -> DiscardFrom(This,pUU)

#define IOleUndoManager_UndoTo(This,pUU)	\
    (This)->lpVtbl -> UndoTo(This,pUU)

#define IOleUndoManager_RedoTo(This,pUU)	\
    (This)->lpVtbl -> RedoTo(This,pUU)

#define IOleUndoManager_EnumUndoable(This,ppEnum)	\
    (This)->lpVtbl -> EnumUndoable(This,ppEnum)

#define IOleUndoManager_EnumRedoable(This,ppEnum)	\
    (This)->lpVtbl -> EnumRedoable(This,ppEnum)

#define IOleUndoManager_GetLastUndoDescription(This,pbstr)	\
    (This)->lpVtbl -> GetLastUndoDescription(This,pbstr)

#define IOleUndoManager_GetLastRedoDescription(This,pbstr)	\
    (This)->lpVtbl -> GetLastRedoDescription(This,pbstr)

#define IOleUndoManager_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */






























/****************************************
 * Generated header for interface: __MIDL__intf_0095
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleUndoManager * LPOLEUNDOMANAGER;
#define QACONTAINER_SHOWHATCHING      0x0001
#define QACONTAINER_SHOWGRABHANDLES   0x0002
#define QACONTAINER_USERMODE          0x0004
#define QACONTAINER_DISPLAYASDEFAULT  0x0008
#define QACONTAINER_UIDEAD            0x0010
#define QACONTAINER_AUTOCLIP          0x0020
#define QACONTAINER_MESSAGEREFLECT    0x0040
#define QACONTAINER_SUPPORTSMNEMONICS 0x0080
			/* size is 56 */
typedef struct  _QACONTAINER
    {
    ULONG cbSize;
    IOleClientSite *pClientSite;
    IAdviseSinkEx *pAdviseSink;
    IPropertyNotifySink *pPropertyNotifySink;
    IUnknown *pUnkEventSink;
    DWORD dwAmbientFlags;
    OLE_COLOR colorFore;
    OLE_COLOR colorBack;
    IFont *pFont;
    IOleUndoManager *pUndoMgr;
    DWORD dwAppearance;
    LONG lcid;
    HPALETTE hpal;
    IBindHost *pBindHost;
    }	QACONTAINER;

			/* size is 24 */
typedef struct  _QACONTROL
    {
    ULONG cbSize;
    DWORD dwMiscStatus;
    DWORD dwViewStatus;
    DWORD dwEventCookie;
    DWORD dwPropNotifyCookie;
    DWORD dwPointerActivationPolicy;
    }	QACONTROL;





/****************************************
 * Generated header for interface: IQuickActivate
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 



EXTERN_C const IID IID_IQuickActivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IQuickActivate : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QuickActivate( 
            /* [in] */ QACONTAINER *pqacontainer,
            /* [out] */ QACONTROL *pqacontrol) = 0;
        
        virtual HRESULT __stdcall SetContentExtent( 
            LPSIZEL lpsizel) = 0;
        
        virtual HRESULT __stdcall GetContentExtent( 
            LPSIZEL lpsizel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQuickActivateVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IQuickActivate * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IQuickActivate * This);
        
        ULONG ( __stdcall *Release )( 
            IQuickActivate * This);
        
        HRESULT ( __stdcall *QuickActivate )( 
            IQuickActivate * This,
            /* [in] */ QACONTAINER *pqacontainer,
            /* [out] */ QACONTROL *pqacontrol);
        
        HRESULT ( __stdcall *SetContentExtent )( 
            IQuickActivate * This,
            LPSIZEL lpsizel);
        
        HRESULT ( __stdcall *GetContentExtent )( 
            IQuickActivate * This,
            LPSIZEL lpsizel);
        
    } IQuickActivateVtbl;

    interface IQuickActivate
    {
        CONST_VTBL struct IQuickActivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuickActivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQuickActivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQuickActivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQuickActivate_QuickActivate(This,pqacontainer,pqacontrol)	\
    (This)->lpVtbl -> QuickActivate(This,pqacontainer,pqacontrol)

#define IQuickActivate_SetContentExtent(This,lpsizel)	\
    (This)->lpVtbl -> SetContentExtent(This,lpsizel)

#define IQuickActivate_GetContentExtent(This,lpsizel)	\
    (This)->lpVtbl -> GetContentExtent(This,lpsizel)

#endif /* COBJMACROS */


#endif 	/* C style interface */












/****************************************
 * Generated header for interface: __MIDL__intf_0096
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IQuickActivate * LPQUICKACTIVATE;
			/* size is 2 */
typedef 
enum _POINTERINACTIVE
    {	POINTERINACTIVE_ACTIVATEONENTRY	= 1,
	POINTERINACTIVE_DEACTIVATEONLEAVE	= 2,
	POINTERINACTIVE_ACTIVATEONDRAG	= 4
    }	POINTERINACTIVE;





/****************************************
 * Generated header for interface: IPointerInactive
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 



EXTERN_C const IID IID_IPointerInactive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPointerInactive : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetActivationPolicy( 
            /* [out] */ DWORD *pdwPolicy) = 0;
        
        virtual HRESULT __stdcall OnInactiveMouseMove( 
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD grfKeyState) = 0;
        
        virtual HRESULT __stdcall OnInactiveSetCursor( 
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD dwMouseMsg,
            /* [in] */ BOOL fSetAlways) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPointerInactiveVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IPointerInactive * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IPointerInactive * This);
        
        ULONG ( __stdcall *Release )( 
            IPointerInactive * This);
        
        HRESULT ( __stdcall *GetActivationPolicy )( 
            IPointerInactive * This,
            /* [out] */ DWORD *pdwPolicy);
        
        HRESULT ( __stdcall *OnInactiveMouseMove )( 
            IPointerInactive * This,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD grfKeyState);
        
        HRESULT ( __stdcall *OnInactiveSetCursor )( 
            IPointerInactive * This,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD dwMouseMsg,
            /* [in] */ BOOL fSetAlways);
        
    } IPointerInactiveVtbl;

    interface IPointerInactive
    {
        CONST_VTBL struct IPointerInactiveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPointerInactive_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPointerInactive_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPointerInactive_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPointerInactive_GetActivationPolicy(This,pdwPolicy)	\
    (This)->lpVtbl -> GetActivationPolicy(This,pdwPolicy)

#define IPointerInactive_OnInactiveMouseMove(This,pRectBounds,x,y,grfKeyState)	\
    (This)->lpVtbl -> OnInactiveMouseMove(This,pRectBounds,x,y,grfKeyState)

#define IPointerInactive_OnInactiveSetCursor(This,pRectBounds,x,y,dwMouseMsg,fSetAlways)	\
    (This)->lpVtbl -> OnInactiveSetCursor(This,pRectBounds,x,y,dwMouseMsg,fSetAlways)

#endif /* COBJMACROS */


#endif 	/* C style interface */












/****************************************
 * Generated header for interface: __MIDL__intf_0097
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IPointerInactive * LPPOINTERINACTIVE;



/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
// trevors: To build with vc5, we should not include olectlid.h anymore.  We
// should include olectl.h.  We check to see if we are compiling with vc5 or
// not and include the correct header file. 
#if _MSC_VER == 1100
#include <olectl.h>
#else
#include <olectlid.h>
#endif // _MSC_VER
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface ICursor FAR* LPCURSOR;

typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;
typedef interface ICursor FAR* FAR* LPLPCURSOR;


//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //
    STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
    STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //
    STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\objsafe.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Fri May 24 09:44:29 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objsafe_h__
#define __objsafe_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IObjectSafety_FWD_DEFINED__
#define __IObjectSafety_FWD_DEFINED__
typedef interface IObjectSafety IObjectSafety;
#endif 	/* __IObjectSafety_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri May 24 09:44:29 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  (C) Copyright 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: ObjSafe.h
//
//--------------------------------------------------------------------------
#ifndef _LPSAFEOBJECT_DEFINED
#define _LPSAFEOBJECT_DEFINED

// Option bit definitions for IObjectSafety:
#define	INTERFACESAFE_FOR_UNTRUSTED_CALLER	0x00000001	// Caller of interface may be untrusted
#define	INTERFACESAFE_FOR_UNTRUSTED_DATA	0x00000002	// Data passed into interface may be untrusted

// {CB5BDC81-93C1-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IObjectSafety, 0xcb5bdc81, 0x93c1, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
//EXTERN_C GUID CATID_SafeForScripting;
//EXTERN_C GUID CATID_SafeForInitializing;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IObjectSafety_INTERFACE_DEFINED__
#define __IObjectSafety_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectSafety
 * at Fri May 24 09:44:29 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IObjectSafety;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IObjectSafety : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) = 0;
        
        virtual HRESULT __stdcall SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectSafetyVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IObjectSafety __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IObjectSafety __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IObjectSafety __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetInterfaceSafetyOptions )( 
            IObjectSafety __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);
        
        HRESULT ( __stdcall __RPC_FAR *SetInterfaceSafetyOptions )( 
            IObjectSafety __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions);
        
    } IObjectSafetyVtbl;

    interface IObjectSafety
    {
        CONST_VTBL struct IObjectSafetyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectSafety_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectSafety_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectSafety_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectSafety_GetInterfaceSafetyOptions(This,riid,pdwSupportedOptions,pdwEnabledOptions)	\
    (This)->lpVtbl -> GetInterfaceSafetyOptions(This,riid,pdwSupportedOptions,pdwEnabledOptions)

#define IObjectSafety_SetInterfaceSafetyOptions(This,riid,dwOptionSetMask,dwEnabledOptions)	\
    (This)->lpVtbl -> SetInterfaceSafetyOptions(This,riid,dwOptionSetMask,dwEnabledOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IObjectSafety_GetInterfaceSafetyOptions_Proxy( 
    IObjectSafety __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
    /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);


void __RPC_STUB IObjectSafety_GetInterfaceSafetyOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IObjectSafety_SetInterfaceSafetyOptions_Proxy( 
    IObjectSafety __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ DWORD dwOptionSetMask,
    /* [in] */ DWORD dwEnabledOptions);


void __RPC_STUB IObjectSafety_SetInterfaceSafetyOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectSafety_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Fri May 24 09:44:29 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


			/* size is 4 */
typedef /* [unique] */ IObjectSafety __RPC_FAR *LPOBJECTSAFETY;

#endif


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\proppage.h ===
//=--------------------------------------------------------------------------=
// PropertyPages.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPERTYPAGES_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#define DEFINE_PROPERTYPAGEOBJECT2(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci, fthreadsafe) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, NULL, TRUE, pfn }, wr, wt, wd, pszhf, dwhci } \

#define DEFINE_PROPERTYPAGEOBJECT2(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci, fthreadsafe) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, NULL, fthreadsafe, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject,
											public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

    HINSTANCE GetResourceHandle(void);            // returns current resource handle.

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    int      m_ObjectType;                        // what type of object we are

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    unsigned m_fDeactivating:1;                   // Set when the page is deactivating.  This helps prevent
                                                  // unnecessary calls to IPropertyPageSite::OnStatusChange

    UINT     m_cObjects;                          // how many objects we're holding on to

    void     ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  EnsureLoaded(void);                // forces the load of the page.
    HRESULT  NewObjects(void);			// Notifies page to initialize its fields with prop vals

    // default dialog proc for a page.
    //
    static BOOL CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual BOOL DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPERTYPAGES_H_
#endif // _PROPERTYPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\rtol.h ===
//=--------------------------------------------------------------------------=
// RToL.H
//=--------------------------------------------------------------------------=
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// This is here to support compilation with VC5.  VC5 header files lost
// a couple of things for Right To Left so they are right here.

//#if _MSC_VER == 1100

#ifndef _RTOL_H_
#define _RTOL_H_

#define DISPID_RIGHTTOLEFT           (-611)
#define DISPID_AMBIENT_RIGHTTOLEFT   (-732)

#endif // _RTOL_H_ 

//#endif // _MSC_VER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\strcoll.h ===
//=--------------------------------------------------------------------------=
// StringsColl.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRINGSCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRINGSCOLL_H_
#endif // _STRINGSCOLL_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\stdenum.h ===
//=--------------------------------------------------------------------------=
// StandardEnum.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STANDARDENUM_H_

#include "Unknown.H"
#include "Macros.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, 
										 public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

	CStandardEnum();
    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

protected:
    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STANDARDENUM_H_
#endif // _STANDARDENUM_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\tools.inc ===
#=------------------------------------------------------------------------=
# Tools.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# sets up the various tools required to build a control.
#


CC=cl
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
ML=asaxp
!elseif "$(PROCESSOR_ARCHITECTURE)"=="MIPS"
ML=cl
!elseif "$(PROCESSOR_ARCHITECTURE)"=="PPC"
ML=pas
!else
ML=ml
!endif
RC=rc
LINK=link
LIBRARIAN=lib
MKTYPLIB=mktyplib
INCLUDES=includes
MKDEP=mkdep
MAKEVERS=$(THUNDER55)\$(TOOLS)\BIN\makevers /MajorVer 6 /MinorVer 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vb5auto.inc ===
#=------------------------------------------------------------------------=
# vb5ctls.inc
#=------------------------------------------------------------------------=
# builds a control for the vb5 product.  adds a few pieces of functionality
# to the generic makectl.inc


#=------------------------------------------------------------------------=
# NOTE:
#
# variable definitions before the !include line, and new targets, etc,
# afterwards.
#
#=------------------------------------------------------------------------=

#=------------------------------------------------------------------------=
# variable definitions
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(SERVERNAME).Dll
!endif

# Relative path to the INTL, satellite DLL build, directory
#
INTLPATH=.\.
VBLICPATH=..\..\VBLIC

IDHEADER=..\..\tools\idheader.bat
DEPFILE=..\..\tools\depfile.bat

!if "$(DEPFILEBLD)"!=""
ALLTARGETS=$(_SERVERBASENAME).DEP
!else
MORETARGETS=\
!	if "$(_NOID)" == ""
		Helpstrs.H \
!	endif
	$(MORETARGETS)
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
POSTTARGETS=Lego
!else
POSTTARGETS=
!endif
!endif

TLBTARGETS=\
!if "$(_NOID)" == ""
	HelpStrs.H \
!endif
!if "$(_NOODLFILE)"==""
	..\$(SERVERNAME).ODL
!endif

# licensing support
#
!if "$(ASDEBUG)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\debug\vblic.lib 
!elseif "$(ASICECAP)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\icecap\vblic.lib 
!else
_LIBS=$(_LIBS) $(VBLICPATH)\release\vblic.lib 
!endif

#=------------------------------------------------------------------------=
# extra compiler flags, etc.
#
!if "$(ASDEBUG)"!=""
#
# debug
#
_LFLAGS=$(_LFLAGS) -map:$(SERVERNAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAieee
!endif

!else if "$(ASICECAP)"!=""
#
# icecap
#
_LFLAGS=$(_LFLAGS) -map:$(SERVERNAME).map

!else
#
# release
#
_LFLAGS=$(_LFLAGS) -debugtype:fixup,cv -debug:notmapped,full -debugtype:coff -map:$(SERVERNAME).map

!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAl /QAieee
!endif
!endif

!if "$(_NOBASE)"==""
!if "$(ASDEBUG)"!=""
_LFLAGS=$(_LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_d
!else
_LFLAGS=$(_LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_r
!endif
!endif

#=------------------------------------------------------------------------=
# put all variable definitions before this, and new targets afterwards
#
!include "..\..\Include\MakeAuto.Inc"


#=------------------------------------------------------------------------=
# new targets
#

VBDep:\
!if "$(_NOID)" == ""
	HelpStrs.H \
!endif
	dep

# helpstr/id support
#
!if "$(_NOID)" == ""
HelpStrs.H : ..\$(SERVERNAME).ID
    echo Generating HelpIDs.H, HelpStrs.H and HelpStrs.RC
    $(IDHEADER) ..\$(SERVERNAME).id helpids.h helpstrs.h helpstrs.rc > nul
!endif

!if "$(SERVERNAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif

# Localized DLL build
#
!if "$(_NOID)" == ""
$(INTLPATH)\HelpStrs.RC : ..\$(SERVERNAME).ID
		echo Generating HelpStrs.RC
		$(IDHEADER) ..\$(SERVERNAME).id $(INTLPATH)\helpids.h $(INTLPATH)\helpstrs.h $(INTLPATH)\helpstrs.rc > nul
!endif

$(INTLPATH)\intl.res : $(INTLPATH)\intl.rc
	echo Compiling satellite DLL resources ...
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
!if "$(NONFRAMEWRKMAKE)"==""
	rc -dINTLBUILD $(INCPATH) -I$(FRAMEWRKDIR)\framewrk\. $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc
!else
	rc -dINTLBUILD $(INCPATH) $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc
!endif

$(INTLPATH)\intl.rbj : $(INTLPATH)\intl.res
!ifdef RISC_BLD
	cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!else
	cvtres -machine:ix86 -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!endif

!if "$(INTLBLD)"!=""
#
# Check for the .ID file.  Not all objects require an .ID file.
#
!	if exist(..\$(SERVERNAME).ID)
$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : $(FRAMEWRKDIR)\dwinvers.h \
!if "$(_NOID)"==""
			$(INTLPATH)\helpstrs.rc \
!endif  
 $(INTLPATH)\intl.rbj
	echo Linking satellite DLL ...
	link -nologo -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_intl -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj
!	else
$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : $(INTLPATH)\intl.rbj
	echo Linking satellite DLL ...
	link -nologo -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_intl -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj
!	endif

!endif

Lego:
!if "$(CTLS_LEGO)"=="YES"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif

# Dependency File Build
#
$(_SERVERBASENAME).DEP : $(_SERVERBASENAME).TPL $(VB55CTLS)\dwinvers.txt $(VB55CTLS)\dwinvers.h
	echo Generating Setup Wizard dependency file
	$(DEPFILE) $(_SERVERBASENAME).tpl $(_SERVERBASENAME).dep
	del $(_SERVERBASENAME).dep.suc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vb5cbc.inc ===
#=------------------------------------------------------------------------=
# VB55CTLS.inc
#=------------------------------------------------------------------------=
# builds a control for the vb5 product.  adds a few pieces of functionality
# to the generic MakeCBC.inc


#=------------------------------------------------------------------------=
# NOTE:
#
# variable definitions before the !include line, and new targets, etc,
# afterwards.
#
#=------------------------------------------------------------------------=


#=------------------------------------------------------------------------=
# variable definitions
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(DESIGNERNAME).Dll
!endif

!ifndef _BASEKEYNAME
_BASEKEYNAME=$(_LOCALEBASENAME)
!endif

# Relative path to the INTL, satellite DLL build, directory
#
INTLPATH=.\.
VBLICPATH=..\..\VBLIC

!if "$(TOOLS)"==""
TOOLS=TOOLS
!endif

!if "$(C32)"==""
C32=C32
!endif

IDHEADER=..\..\tools\idheader.bat
DEPFILE=..\..\tools\depfile.bat

!if "$(INTLBLD)"!=""
ALLTARGETS=$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL \
!elseif "$(DEPFILEBLD)"!=""
!if "$(RUNMODEDLL)"=="YES"
DEPFILEBASENAME=$(_RUNMODEBASENAME)
!else
DEPFILEBASENAME=$(_SERVERBASENAME)
!endif
ALLTARGETS=$(DEPFILEBASENAME).DEP
!else
ALLTARGETS=$(SPECIALTARGETS) $(VB55CTLS)\dwinvers.h Helpstrs.H  \
!if "$(RUNMODEDLL)"=="YES"
    $(_RUNMODESERVERNAME) \
!endif
    $(_SERVERFILENAME)  \
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
	   Lego
!endif
!endif

TLBTARGETS=HelpStrs.H ..\$(DESIGNERNAME).ODL
TLBRUNTARGETS=HelpStrs.H ..\$(RUNMODE).ODL

# licensing support
#
!if "$(ASDEBUG)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\debug\vblic.lib 
!elseif "$(ASICECAP)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\icecap\vblic.lib 
!else
_LIBS=$(_LIBS) $(VBLICPATH)\release\vblic.lib 
!endif

#=------------------------------------------------------------------------=
# extra compiler flags, etc.
#
!if "$(ASDEBUG)"!=""
#
# debug
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAieee
!endif

!else if "$(ASICECAP)"!=""
#
# icecap
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map

!else
#
# release
#
_LFLAGS=$(_LFLAGS) -debugtype:fixup,cv -debug:notmapped,full -debugtype:coff -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAl /QAieee
!endif
!endif

#=------------------------------------------------------------------------=
# put all variable definitions before this, and new targets afterwards
#
!include "..\..\Include\MakeCBC.Inc"


#=------------------------------------------------------------------------=
# new targets
#
VBDep: HelpStrs.H dep

#-----------------------------------------------------------------------
# Build dwinvers.h
#-----------------------------------------------------------------------
$(VB55CTLS)\dwinvers.h : $(VB55CTLS)\dwinvers.txt
  echo Building dwinvers.h
  $(MAKEVERS) > $(VB55CTLS)\dwinvers.h < $(VB55CTLS)\dwinvers.txt
  $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(VB55CTLS)\dwinvers.h
  copy $(VB55CTLS)\dwinvers.h $(VB55CTLS)\framewrk

# helpstr/id support
#
HelpStrs.H : ..\$(DESIGNERNAME).ID
    echo Generating HelpIDs.H, HelpStrs.H and HelpStrs.RC
    $(IDHEADER) ..\$(DESIGNERNAME).id helpids.h helpstrs.h helpstrs.rc > nul

!if "$(_SERVERBASENAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif

# Localized DLL build
#
$(INTLPATH)\HelpStrs.RC : ..\$(DESIGNERNAME).ID
		echo Generating HelpStrs.RC
		$(IDHEADER) ..\$(DESIGNERNAME).id $(INTLPATH)\helpids.h $(INTLPATH)\helpstrs.h $(INTLPATH)\helpstrs.rc > nul

$(INTLPATH)\intl.res : $(INTLPATH)\intl.rc
	echo Compiling satellite DLL resources ...
	rc -dINTLBUILD -i..\. -i\. -i..\..\framewrk\. -i..\..\include\. $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc

$(INTLPATH)\intl.rbj : $(INTLPATH)\intl.res
!ifdef RISC_BLD 
	cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!else
	cvtres -machine:ix86 -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!endif

$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : $(INTLPATH)\helpstrs.rc $(INTLPATH)\intl.rbj 
	echo Linking satellite DLL ...
	link -nologo -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(_BASEKEYNAME)_intl -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj

Lego:
!if "$(CTLS_LEGO)"=="YES"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif

# Dependency File Build
#
$(DEPFILEBASENAME).DEP : $(DEPFILEBASENAME).TPL $(VB55CTLS)\dwinvers.txt $(VB55CTLS)\dwinvers.h
	echo Generating Setup Wizard dependency file
	$(DEPFILE) $(DEPFILEBASENAME).tpl $(DEPFILEBASENAME).dep
	del $(DEPFILEBASENAME).dep.suc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\unknown.h ===
//=--------------------------------------------------------------------------=
// Unknown.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// a class definition for an IUnknown super-class that will support
// aggregation.
//
#ifndef _UNKNOWN_H_

#include "Macros.H"

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...
//
typedef struct {

    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable!
    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable!
    LPCSTR	 pszLabelName;		    // Registry display name      ONLY USE IF YOU'RE CoCreatable!
					    // for your object
    BOOL	 fApptThreadSafe;
    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable!
    HRESULT      (*pfnPreCreate)(void);     // pointer to pre-create fn.

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define LABELOFOBJECT(index)	  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszLabelName)


#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)
#define ISAPARTMENTMODELTHREADED(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fApptThreadSafe)

#define PRECREATEFNOFOBJECT(index) (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnPreCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#define DEFINE_UNKNOWNOBJECT2(name, clsid, objname, lblname, fn, fthreadsafe) \
extern UNKNOWNOBJECTINFO name##Object \

#define DEFINE_UNKNOWNOBJECT3(name, clsid, objname, lblname, precreatefn, fn, fthreadsafe) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, NULL, TRUE, fn, NULL } \

#define DEFINE_UNKNOWNOBJECT2(name, clsid, objname, lblname, fn, fthreadsafe) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, lblname, fthreadsafe, fn, NULL } \

#define DEFINE_UNKNOWNOBJECT3(name, clsid, objname, lblname, precreatefn, fn, fthreadsafe) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, lblname, fthreadsafe, fn, precreatefn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
        return ExternalQueryInterface(riid, ppvObjOut); \
    } \
    STDMETHOD_(ULONG, AddRef)(void) { \
        return ExternalAddRef(); \
    } \
    STDMETHOD_(ULONG, Release)(void) { \
        return ExternalRelease(); \
    } \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp
//
extern LONG g_cLocks;



//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.
//
class CUnknownObject : public CtlNewDelete {

  public:
    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
        : m_pvInterface(pvInterface),
          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
        {  InterlockedIncrement(&g_cLocks); }

    virtual ~CUnknownObject() { InterlockedDecrement(&g_cLocks); }

    // these are all protected so that classes that inherit from this can
    // at get at them.
    //
  protected:
    // IUnknown methods.  these just delegate to the controlling
    // unknown.
    //
    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
        return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
    }
    virtual ULONG ExternalAddRef(void) {
        return m_pUnkOuter->AddRef();
    }
    virtual ULONG ExternalRelease(void) {
        return m_pUnkOuter->Release();
    }

    // people should use this during creation to return their private
    // unknown
    //
    inline IUnknown *PrivateUnknown (void) {
        return &m_UnkPrivate;
    }

    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual void    BeforeDestroyObject(void);

    IUnknown *m_pUnkOuter;            // outer controlling Unknown
    void     *m_pvInterface;          // the real interface we're working with.

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object, and for those cases where
    // this object isn't aggregated.
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(1) {}

      private:
        CUnknownObject *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    // so they can reference themselves in CUnknownObject from pMainUnknown()
    //
    friend class CPrivateUnknownObject;

    // by overriding this, people inheriting from this unknown can implement
    // additional interfaces.  declared as private here so they have to use their
    // own version.
    //
};




#define _UNKNOWN_H_
#endif // _UNKNOWN_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "Globals.H"
#include "Macros.h"

//=--------------------------------------------------------------------------=
// Structs, Enums, Etc.
//=--------------------------------------------------------------------------=
typedef enum 
{
	VERSION_LESS_THAN=-1,
	VERSION_EQUAL=0,
	VERSION_GREATER_THAN=1,
	VERSION_NOT_EQUAL=2
} VERSIONRESULT;

//=--------------------------------------------------------------------------=
// Misc Helper Stuff
//=--------------------------------------------------------------------------=
//

HWND      GetParkingWindow(void);

HINSTANCE _stdcall GetResourceHandle(LCID lcid = 0);	// Optional LCID param
											            // If not used or zero, we use
											            // g_lcidLocale.

//=--------------------------------------------------------------------------=
// VERSION.DLL function pointers
//=--------------------------------------------------------------------------=
//
#define DLL_VERSION "VERSION.DLL"

#define FUNC_VERQUERYVALUE "VerQueryValueA"
#define FUNC_GETFILEVERSIONINFO "GetFileVersionInfoA"
#define FUNC_GETFILEVERSIONINFOSIZE "GetFileVersionInfoSizeA"

typedef DWORD (_stdcall * PGETFILEVERSIONINFOSIZE)(LPTSTR lptstrFilename, LPDWORD lpdwHandle);
typedef BOOL (_stdcall * PGETFILEVERSIONINFO)(LPTSTR lpststrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL (_stdcall * PVERQUERYVALUE)(const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);

BOOL CallGetFileVersionInfoSize(LPTSTR lptstrFilename, LPDWORD lpdwHandle);
BOOL CallGetFileVersionInfo(LPTSTR lpststrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
BOOL CallVerQueryValue(const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);

BOOL _stdcall InitVersionFuncs();
VERSIONRESULT _stdcall  CompareDllVersion(const char * pszFilename, BOOL bCompareMajorVerOnly);
BOOL _stdcall GetVerInfo(const char * pszFilename, VS_FIXEDFILEINFO *pffi);

// an array of common OLE automation data types and their sizes [in bytes]
//
extern const BYTE g_rgcbDataTypeSize [];


//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//

// CAUTION: Be careful setting MAX_VERSION too high.  Changing this value
//          has serious performance implications.  This means that for
//          every control registered we may call RegOpenKeyEx MAX_VERSION-1 times
//          to find out if there is a version dependent ProgId.  Since major
//          version upgrades of components should be a infrequent occurance
//          this should be a reasonable limit for most components.
// PERF:    I ran ICECAP for the value below and this lead to RegOpenKeyEx to
//          count for 2.2% of unregistration time.  I tried 255 and RegOpenKeyEx
//          jumps to 44% of unregistration time.  This value has no impact on registration time.
//
#define MAX_VERSION     32      // The max number of version dependent ProgIds to look for
#define VERSION_DELTA   10      // Subtract this value from MAX_VERSION to obtain the threshold
                                // at which we'll throw an assert warning you that the version
                                // of your component is nearing or exceeding the versions 
                                // (MAX_VERSION) we support
#define GUID_STR_LEN    40

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : CtlHeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
        if (m_pBuf)
            *((unsigned short *)m_pBuf) = 0;
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) CtlHeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};


//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

// * 2 for DBCS handling in below length computation
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR) // Embedded NULLs not supported

inline BSTR DuplicateBSTR(BSTR bstr) { 
    return SysAllocStringLen(bstr, SysStringLen(bstr)); }

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);


//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegSetMultipleValues(HKEY hkey, ...);
BOOL RegisterUnknownObject(LPCSTR pszObjectName, LPCSTR pszLabelName, REFCLSID riidObject, BOOL fAptThreadSafe);
BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, LPCSTR pszLabelName, long lObjVer, long lMajorVersion, long lMinorVersion, REFCLSID riidLibrary, REFCLSID riidObject, BOOL fAptThreadSafe);
BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, LPCSTR pszLabelName, long lObjMajVer, long lObjMinVer, long lMajorVersion, long lMinorVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId, BOOL fAptThreadSafe, BOOL fControl);
BOOL UnregisterUnknownObject(REFCLSID riidObject, BOOL *pfAllRemoved);
BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
#define UnregisterControlObject UnregisterAutomationObject

BOOL UnregisterTypeLibrary(REFCLSID riidLibrary);

// Register/UnregisterUnknownObject helpers to help prevent us from blowing away specific keys
//
BOOL ExistInprocServer(HKEY hkCLSID, char *pszCLSID);
BOOL ExistImplementedCategories(REFCLSID riid);

// Finds out if there are other version dependent ProgIds for our component around
//
BOOL QueryOtherVersionProgIds(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, long *plFoundVersion, BOOL *pfFailure);

// Copies the contents of a version dependent ProgId to a version independent ProgId
//
BOOL CopyVersionDependentProgIdToIndependentProgId(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion);

// Copies a source key (including all sub-keys) to a destination key
//
BOOL CopyRegistrySection(HKEY hkSource, HKEY hkDest);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPCSTR pszSubKey);

// Path of Windows\Help directory.
//
UINT GetHelpFilePath(char *pszPath, UINT cbPath);

// Helper function for registration
//
void _MakePath(LPSTR pszFull, const char * pszName, LPSTR pszOut);

// TypeLib helper functions
//
HRESULT GetTypeFlagsForGuid(ITypeLib *pTypeLib, REFGUID guidTypeInfo, WORD *pwFlags);

//=--------------------------------------------------------------------------=
// string helpers.
//
char * FileExtension(const char *pszFilename);

//=--------------------------------------------------------------------------=
// conversion helpers.
//
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);


//=--------------------------------------------------------------------------=
// This is a version macro so that versioning can be done in text and binary
// streams.
//
#define VERSION(x,y) MAKELONG(y,x)

#define _UTIL_H_
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vb5ctls.inc ===
#=------------------------------------------------------------------------=
# VB55CTLS.inc
#=------------------------------------------------------------------------=
# builds a control for the vb5 product.  adds a few pieces of functionality
# to the generic makectl.inc


#=------------------------------------------------------------------------=
# NOTE:
#
# variable definitions before the !include line, and new targets, etc,
# afterwards.
#
#=------------------------------------------------------------------------=


#=------------------------------------------------------------------------=
# variable definitions
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(CONTROLNAME).Ocx
!endif

# Relative path to the INTL, satellite DLL build, directory
#
INTLPATH=.\.
VBLICPATH=..\..\VBLIC

!if "$(TOOLS)"==""
TOOLS=TOOLS
!endif

!if "$(C32)"==""
C32=C32
!endif

IDHEADER=..\..\tools\idheader.bat
DEPFILE=..\..\tools\depfile.bat

#
# base address file
BASEFILE=$(DEVBINC)\vstudio\v6\dllbase.txt

!if "$(INTLBLD)"!=""
ALLTARGETS=dwinvers.h $(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL \
!elseif "$(DEPFILEBLD)"!=""
ALLTARGETS=$(_SERVERBASENAME).DEP
!else
ALLTARGETS=$(VB55CTLS)\dwinvers.h \
!if "$(_NOID)" == ""
	Helpstrs.H \
!endif
	$(_SERVERFILENAME)  \
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
	   Lego
!endif
!endif

TLBTARGETS= \
!if "$(_NOID)" == ""
	HelpStrs.H \
!endif
	..\$(CONTROLNAME).ODL

# licensing support
#
!if "$(ASDEBUG)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\debug\vblic.lib 
!elseif "$(ASICECAP)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\icecap\vblic.lib 
!else
_LIBS=$(_LIBS) $(VBLICPATH)\release\vblic.lib 
!endif

#=------------------------------------------------------------------------=
# extra compiler flags, etc.
#
!if "$(ASDEBUG)"!=""
#
# debug
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAieee
!endif

!else if "$(ASICECAP)"!=""
#
# icecap
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map

!else
#
# release
#
_LFLAGS=$(_LFLAGS) -debugtype:fixup,cv -debug:notmapped,full -debugtype:coff -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAl /QAieee
!endif
!endif

!if "$(_NOBASE)"==""
!if "$(_BASEADDRNAME)"==""
#default base address name is the name of the control
!if "$(ASDEBUG)"!=""
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(CONTROLNAME)_d
!else
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(CONTROLNAME)_r
!endif
!else
#using custom base address name
!if "$(ASDEBUG)"!=""
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(_BASEADDRNAME)_d
!else
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(_BASEADDRNAME)_r
!endif
!endif
!endif

#
# The CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file.  Set CTLS_BROWSE to something and one will be generated.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#=------------------------------------------------------------------------=
# put all variable definitions before this, and new targets afterwards
#
!include "..\..\Include\MakeCtl.Inc"


#=------------------------------------------------------------------------=
# new targets
#
VBDep: HelpStrs.H dep

#-----------------------------------------------------------------------
# Build dwinvers.h
#-----------------------------------------------------------------------
$(VB55CTLS)\dwinvers.h : $(VB55CTLS)\dwinvers.txt
  echo Building dwinvers.h
  $(MAKEVERS) > $(VB55CTLS)\dwinvers.h < $(VB55CTLS)\dwinvers.txt
  $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(VB55CTLS)\dwinvers.h
  copy $(VB55CTLS)\dwinvers.h $(VB55CTLS)\framewrk

# helpstr/id support
#
!if "$(_NOID)" == ""
HelpStrs.H : ..\$(CONTROLNAME).ID
    echo Generating HelpIDs.H, HelpStrs.H and HelpStrs.RC
    $(IDHEADER) ..\$(CONTROLNAME).id helpids.h helpstrs.h helpstrs.rc > nul
!endif

!if "$(_SERVERBASENAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif


!if "$(INTLBLD)"!=""
# Localized DLL build
#
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif

!if "$(_NOBASE)" == ""
!if "$(_INTLBASEADDRNAME)"==""
#default base address name to the name of the control
_LFLAGS_INTL=-base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(CONTROLNAME)_intl
!else
#using custom base address name
_LFLAGS_INTL=-base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(_INTLBASEADDRNAME)_intl
!endif
!endif

!if "$(_NOID)" == ""
$(INTLPATH)\HelpStrs.RC : ..\$(CONTROLNAME).ID
		echo Generating HelpStrs.RC
		$(IDHEADER) ..\$(CONTROLNAME).id $(INTLPATH)\helpids.h $(INTLPATH)\helpstrs.h $(INTLPATH)\helpstrs.rc > nul
!endif

$(INTLPATH)\intl.res : $(INTLPATH)\intl.rc
	echo Compiling satellite DLL resources ...
	rc -dINTLBUILD $(INCPATH) $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc

$(INTLPATH)\intl.rbj : $(INTLPATH)\intl.res
!ifdef RISC_BLD 
	cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!else
	cvtres -machine:ix86 -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!endif


$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : \
!if	"$(_NOID)" == ""
	$(INTLPATH)\helpstrs.rc \
!endif
	$(INTLPATH)\intl.rbj 
	echo Linking satellite DLL ...
	link -nologo $(_LFLAGS_INTL) -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj

!endif	//INTLBLD

Lego:
!if "$(CTLS_LEGO)"=="YES" && "$(_SERVERBASENAME)"!="Crystl32"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif

# Dependency File Build
#
$(_SERVERBASENAME).DEP : $(_SERVERBASENAME).TPL $(VB55CTLS)\dwinvers.txt $(VB55CTLS)\dwinvers.h
	echo Generating Setup Wizard dependency file
	$(DEPFILE) $(_SERVERBASENAME).tpl $(_SERVERBASENAME).dep
	del $(_SERVERBASENAME).dep.suc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vbochost.h ===
//---------------------------------------------------------------------------
// VBOCHOST.H
//---------------------------------------------------------------------------
// Copyright (c) 1991-1995, Microsoft Corp.  All Rights Reserved.
//---------------------------------------------------------------------------
// Include file for the OLE Custom Controls Visual Basic
// programming interface.
//---------------------------------------------------------------------------

#if !defined (_VBOCHOST_H_)
#define _VBOCHOST_H_
        
DEFINE_GUID(IID_IVBGetControl, 0x40A050A0L, 0x3C31, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);
DEFINE_GUID(IID_IGetOleObject, 0x8A701DA0L, 0x4FEB, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);

//---------------------------------------------------------------------------
// IVBGetControl
//---------------------------------------------------------------------------

// Constants for dwWhich parameter:
#define GC_WCH_SIBLING	    0x00000001L
#define GC_WCH_CONTAINER    0x00000002L   // no FONLYNEXT/PREV
#define GC_WCH_CONTAINED    0x00000003L   // no FONLYNEXT/PREV
#define GC_WCH_ALL	    0x00000004L
#define GC_WCH_FREVERSEDIR  0x08000000L   // OR'd with others
#define GC_WCH_FONLYNEXT    0x10000000L   // OR'd with others
#define GC_WCH_FONLYPREV    0x20000000L   // OR'd with others
#define GC_WCH_FSELECTED    0x40000000L   // OR'd with others

DECLARE_INTERFACE_(IVBGetControl, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IVBGetControl methods ****
    STDMETHOD(EnumControls)(THIS_ DWORD dwOleContF, DWORD dwWhich, 
                            LPENUMUNKNOWN FAR *ppenumUnk) PURE;
    };

//---------------------------------------------------------------------------
// IGetOleObject
//---------------------------------------------------------------------------
DECLARE_INTERFACE_(IGetOleObject, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IGetOleObject methods ****
    STDMETHOD(GetOleObject)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    };

#endif  // !defined (_VBOCHOST_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vbdsc.h ===
/*****************************************************************************\
*                                                                             *
* vbdsc.h       DSC interfaces for OLE                                        *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _VBDSC_H_ )
#define _VBDSC_H_

// JeffG: Copied this section from olebind.h to get rid of compiler warnings
#if !defined( INITGUID )
// trevors: To build with vc5, we should not include olectlid.h anymore.  We
// should include olectl.h.  We check to see if we are compiling with vc5 or
// not and include the correct header file. 
#if _MSC_VER == 1100
#include <olectl.h>
#else
#include <olectlid.h>
#endif // _MSC_VER
#endif

DEFINE_GUID(IID_IVBDSC, 
        0x1ab42240, 0x8c70, 0x11ce, 0x94, 0x21, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

typedef interface IVBDSC FAR *LPVBDSC;


typedef enum _tagDSCERROR
  {
  DSCERR_BADDATAFIELD = 0
  }
DSCERROR;


//////////////////////////////////////////////////////////////////////////////
//
//  IVBDSC interface
//
//////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IVBDSC

DECLARE_INTERFACE_(IVBDSC, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IVBDSC methods
    //
    STDMETHOD(CancelUnload)(THIS_ BOOL FAR *pfCancel) PURE;
    STDMETHOD(Error)(THIS_ DWORD dwErr, BOOL FAR *pfShowError) PURE;
    STDMETHOD(CreateCursor)(THIS_ ICursor FAR * FAR *ppCursor) PURE;
};

#endif // !defined( _VBDSC_H_ )

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vc5warn.h ===
//=--------------------------------------------------------------------------=
// VC5Warn.h
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several VC5 warnings that trip framewrk definitions
//

// warning C4291: no matching operator delete found; memory will not be
// freed if initialization throws an exception. This happens on Alpha builds
// because class CtlNewDelete in macros.h does not define a matching delete
// operator.

#if defined(ALPHA)
#pragma warning(disable:4291)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\wbclsser.h ===
//=--------------------------------------------------------------------------=
// wbclsser.h
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// API for WebClass Designer Serialization
//
// adolfoc 7/29/97
//			Renamed WCS_NODE_TYPE_URL to WCS_NODE_TYPE_PAGE,
//			added WCS_NODE_TYPE_URL with value 3,
//			changed URL tag to Page
// 
#ifndef _WBCLSSER_H_

#include "csfdebug.h"
#include "convman_tlb.h"

// Designer State Flags
#define RUNSTATE_COMPILED          0x00000000
#define RUNSTATE_F5                0x00000001

#define DISPID_OBJECT_PROPERTY_START 	0x00000500

// Serialization Versions
// 0.0      Beta1
// 0.1      PreBeta2   -   WebItems must be sorted on load
// 0.2      PreBeta2   -   Added Optimize member var to WebItems
// 0.3      PreBeta2   -   WebEvents are now sorted on load too
// 0.4      PreBeta2   - 
// 0.5      PreBeta2   -   Tagattributes added anonymous tag number
// 0.6		<skipped>
// 0.7      PreRC1	   -   Added URLInName to design time state
// 0.8      PreRC1	   -   Fixed bug in WebItem and event sorting algorithm. Now we need
//						   to fixup old projects with bug whose WebItems and events are not
//						   serialized in alphabetical order.

// structure of WebClass on disk
const DWORD dwExpectedVerMajor = 0;
const DWORD dwExpectedVerMinor = 8; 

class CRunWebItemState;
class CRunEventState;

class CStateBase
{
public:
	CStateBase() {}
	~CStateBase() {}

public:
	//////////////////////////////////////////////////////////////////////
	//
	// inline ReadStrings(IStream *pStream, ULONG acbStrings[],
	//                    BSTR *apbstrStrings[], int cStrings)
	//                    
	//
	//
	//////////////////////////////////////////////////////////////////////

	inline ReadStrings(IStream *pStream, ULONG acbStrings[],
					   BSTR *apbstrStrings[], int cStrings)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
        char *pszReadBuf = NULL;
        ULONG cbLongest = 0;
        int i = 0;

        while (i < cStrings)
        {
            if (acbStrings[i] > cbLongest)
            {
                cbLongest = acbStrings[i];
            }
            i++;
        }
        if (0 != cbLongest)
        {
            pszReadBuf = new char[cbLongest + sizeof(WCHAR)];
            CSF_CHECK(NULL != pszReadBuf, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);
        }
        i = 0;
		while (i < cStrings)
		{
            if (0 == acbStrings[i])
            {
                *(apbstrStrings[i]) = NULL;
            }
            else
            {
                hr = pStream->Read(pszReadBuf, acbStrings[i], &cbRead);
                CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
                CSF_CHECK(cbRead == acbStrings[i], STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
                *((WCHAR *)&pszReadBuf[acbStrings[i]]) = L'\0';

                *(apbstrStrings[i]) = ::SysAllocString((WCHAR *)pszReadBuf);
                CSF_CHECK(*(apbstrStrings[i]) != NULL, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);
            }
			i++;
		}

	CLEANUP:
        if (NULL != pszReadBuf)
        {
            delete [] pszReadBuf;
        }
		return hr;
	}

	//////////////////////////////////////////////////////////////////////
	//
	// inline WriteStrings(IStream *pStream, ULONG acbStrings[],
	//                     BSTR *apbstrStrings[], int cStrings)
	//
	//
	//////////////////////////////////////////////////////////////////////


	inline WriteStrings(IStream *pStream, ULONG acbStrings[],
						BSTR abstrStrings[], int cStrings)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		int i = 0;

		while (i < cStrings)
		{
            if (NULL != abstrStrings[i])
            {
                hr = pStream->Write(abstrStrings[i], acbStrings[i], &cbWritten);
                CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
                CSF_CHECK(cbWritten == acbStrings[i], STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);
            }
			i++;
		}

	CLEANUP:
		return hr;
	}

};

class CRunWebClassState : public CStateBase
{
public:
	CRunWebClassState()
	{
		m_dwVerMajor = dwExpectedVerMajor;
		m_dwVerMinor = dwExpectedVerMinor;
		m_bstrName = NULL;		// Kill
		m_bstrProgID = NULL;	// Runtime only
		m_StateManagementType = wcNoState;
		m_bstrASPName = NULL;	
		m_bstrAppendedParams = NULL;	
		m_bstrStartupItem = NULL;	
		m_DIID_WebClass = GUID_NULL;
		m_DIID_WebClassEvents = GUID_NULL;
		m_dwTICookie = 0;	
		m_dwFlags = 0;
		m_rgWebItemsState = 0;
		m_dwWebItemCount = 0;
	}

	~CRunWebClassState()
	{
		if(m_bstrName != NULL)
			::SysFreeString(m_bstrName);

		if(m_bstrProgID != NULL)
			::SysFreeString(m_bstrProgID);

		if(m_bstrASPName != NULL)
			::SysFreeString(m_bstrASPName);

        if(m_bstrAppendedParams != NULL)
            ::SysFreeString(m_bstrAppendedParams);

        if(m_bstrStartupItem != NULL)
            ::SysFreeString(m_bstrStartupItem);
	}

public:
	DWORD				m_dwVerMajor;            // major version number
	DWORD				m_dwVerMinor;            // minor version number
	BSTR				m_bstrName;             // WebClass name
	BSTR				m_bstrProgID;           // WebClass progid
	StateManagement		m_StateManagementType;  // state management type
	BSTR				m_bstrASPName;          // name of ASP file
	IID					m_DIID_WebClass;        // IID of WebClass' main IDispatch
	IID					m_DIID_WebClassEvents;  // IID of WebClass' events IDispatch
	DWORD				m_dwTICookie;           // typeinfo cookie
    BSTR                m_bstrAppendedParams;   // URL state
    BSTR                m_bstrStartupItem;      // f5 statup Item
	DWORD				m_dwFlags;
	CRunWebItemState*	m_rgWebItemsState;
	DWORD				m_dwWebItemCount;		// runtime node types

public:
	HRESULT Load(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
		ULONG acbStrings[5];
		BSTR *apbstrStrings[5];

		// read structure from stream

		hr = pStm->Read(this, sizeof(CRunWebClassState), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunWebClassState) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// TODO: need error codes for version incompatibility, handle backlevel formats etc.

//		CSF_CHECK(dwExpectedVerMajor == m_dwVerMajor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);
//		CSF_CHECK(dwExpectedVerMinor == m_dwVerMinor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);

		// read string lengths from stream

		hr = pStm->Read(acbStrings, sizeof(acbStrings), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of string pointer addresses

		apbstrStrings[0] = &(m_bstrName);
		apbstrStrings[1] = &(m_bstrProgID);
		apbstrStrings[2] = &(m_bstrASPName);
		apbstrStrings[3] = &(m_bstrAppendedParams);
		apbstrStrings[4] = &(m_bstrStartupItem);

		// read strings from stream

		hr = ReadStrings(pStm, acbStrings, apbstrStrings,
					   (sizeof(acbStrings) / sizeof(acbStrings[0])) );

	CLEANUP:
		return hr;
	}

	HRESULT Save(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		ULONG acbStrings[5];
        ::ZeroMemory(acbStrings, sizeof(acbStrings));
		BSTR abstrStrings[5];

		// write WebClass structure to stream

		hr = pStm->Write(this, sizeof(CRunWebClassState), &cbWritten);
		CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(cbWritten == sizeof(CRunWebClassState), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// get lengths of strings and write them to stream

        if (NULL != m_bstrName)
        {
            acbStrings[0] = ::SysStringByteLen(m_bstrName);
        }
        if (NULL != m_bstrProgID)
        {
            acbStrings[1] = ::SysStringByteLen(m_bstrProgID);
        }
        if (NULL != m_bstrASPName)
        {
            acbStrings[2] = ::SysStringByteLen(m_bstrASPName);
        }
        if (NULL != m_bstrAppendedParams)
        {
            acbStrings[3] = ::SysStringByteLen(m_bstrAppendedParams);
        }
        if (NULL != m_bstrStartupItem)
        {
            acbStrings[4] = ::SysStringByteLen(m_bstrStartupItem);
        }

		hr = pStm->Write(acbStrings, sizeof(acbStrings), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(cbWritten == sizeof(acbStrings), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of pointers to strings to be written to stream

		abstrStrings[0] = m_bstrName;
		abstrStrings[1] = m_bstrProgID;
		abstrStrings[2] = m_bstrASPName;
		abstrStrings[3] = m_bstrAppendedParams;
		abstrStrings[4] = m_bstrStartupItem;

		// write strings to stream

		hr = WriteStrings(pStm, acbStrings, abstrStrings,
						(sizeof(acbStrings) / sizeof(acbStrings[0])) );

	CLEANUP:
		return hr;
	}
};

typedef struct tagWCS_NODEHEADER
{
	BYTE bType;                   // node type: nested WebClass, URL, events
} WCS_NODEHEADER;

// WCS_DTNODE_TYPE_URL_BOUND_TAG is a special case because WCS_DTNODE.dispid
// contains the dispid of the referenced URL and WCS_DTNODE.bstrName contains
// the name of the referenced URL.

// structure of node on disk at runtime

class CRunWebItemState : protected CStateBase
{
public:
	CRunWebItemState()
	{
		m_dwVerMajor = dwExpectedVerMajor;
		m_dwVerMinor = dwExpectedVerMinor;
		m_dispid = -1;
		m_bstrName = NULL;
		m_bstrTemplate = NULL;
		m_bstrToken = NULL;
		m_IID_Events = GUID_NULL;
		m_fParseReplacements = FALSE;
		m_bstrAppendedParams = NULL;
    	m_fUsesRelativePath = FALSE;
		m_dwTokenInfo = 0;
		m_dwReserved2 = 0;
		m_dwReserved3 = 0;
		m_rgEvents = 0;
		m_dwEventCount = 0;
	}

	~CRunWebItemState()
	{
		if(m_bstrName != NULL)
			::SysFreeString(m_bstrName);

		if(m_bstrTemplate != NULL)
			::SysFreeString(m_bstrTemplate);

		if(m_bstrToken != NULL)
			::SysFreeString(m_bstrToken);

		if(m_bstrAppendedParams != NULL)
			::SysFreeString(m_bstrAppendedParams);
	}

public:
	HRESULT Load(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
		ULONG acbStrings[4];
		BSTR *apbstrStrings[4];
		int cStrings = 4;

		// read structure from stream

		hr = pStm->Read(this, sizeof(CRunWebItemState), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunWebItemState) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

	//	m_pvData = NULL; // don't take junk pointer value from stream

		// set up array of string pointer addresses according to node type

		apbstrStrings[0] = &m_bstrName;
		apbstrStrings[1] = &m_bstrTemplate;
		apbstrStrings[2] = &m_bstrToken;
		apbstrStrings[3] = &m_bstrAppendedParams;

		// read string lengths from stream

		hr = pStm->Read(acbStrings, sizeof(acbStrings), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// read strings from stream

		hr = ReadStrings(pStm, acbStrings, apbstrStrings, cStrings);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

	HRESULT Save
	(
		LPSTREAM pStm
	)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		ULONG acbStrings[4];
        ::ZeroMemory(acbStrings, sizeof(acbStrings));
		BSTR abstrStrings[4];
		int cStrings = 4;

		// write node structure to stream

		hr = pStm->Write(this, sizeof(CRunWebItemState), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunWebItemState) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of strings to be written to stream and
		// determine how many there will be

		abstrStrings[0] = m_bstrName;
        if (NULL != m_bstrName)
        {
            acbStrings[0] = ::SysStringByteLen(m_bstrName);
        }

		abstrStrings[1] = m_bstrTemplate;
        if (NULL != m_bstrTemplate)
        {
            acbStrings[1] = ::SysStringByteLen(m_bstrTemplate);
        }
		abstrStrings[2] = m_bstrToken;
        if (NULL != m_bstrToken)
        {
            acbStrings[2] = ::SysStringByteLen(m_bstrToken);
        }
		abstrStrings[3] = m_bstrAppendedParams;
        if (NULL != m_bstrAppendedParams)
        {
            acbStrings[3] = ::SysStringByteLen(m_bstrAppendedParams);
        }

		// write string lengths to stream

		hr = pStm->Write(acbStrings, sizeof(acbStrings), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// write strings to stream

		hr = WriteStrings(pStm, acbStrings, abstrStrings, cStrings);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

public:
    DWORD m_dwVerMajor;
	DWORD m_dwVerMinor;
	// common properties
	DISPID m_dispid;                // dispid of node
	BSTR m_bstrName;                // name of node

	// url properties
	BSTR m_bstrTemplate;            // url's HTML template name
	BSTR m_bstrToken;               // url's token for replacement events
	IID m_IID_Events;               // IID of url's dynamic events interface
	BOOL m_fParseReplacements;      // TRUE=parse replacement recursively
	BSTR m_bstrAppendedParams;		// Appended params
    BOOL m_fUsesRelativePath;        // Specifies whether the runtime should load
                                    // templates relative to the ASP's actual path

	DWORD m_dwTokenInfo;
	DWORD m_dwReserved2;
	DWORD m_dwReserved3;
	CRunEventState* m_rgEvents;
	DWORD m_dwEventCount;
};

// design time node types

#define WCS_NODE_TYPE_RESOURCE            (BYTE)10
//#define WCS_DTNODE_TYPE_UNBOUND_TAG     (BYTE)12
//#define WCS_DTNODE_TYPE_NESTED_WEBCLASS (BYTE)15  

//#define WCS_DTNODE_TYPE_CUSTOM_EVENT    (BYTE)11
//#define WCS_DTNODE_TYPE_URL_BOUND_TAG   (BYTE)13
//#define WCS_DTNODE_TYPE_EVENT_BOUND_TAG (BYTE)14

class CRunEventState : public CStateBase
{
public:
	enum EventTypes
	{
		typeCustomEvent,
		typeURLBoundTag,
		typeEventBoundTag,
		typeUnboundTag,
	};

	CRunEventState()
	{
		m_dwVerMajor = 0;
		m_dwVerMinor = 0;
		m_type = wcCustom;
		m_dispid = -1;
		m_bstrName = NULL;
		m_bstrOriginalHref = NULL;
	}

	~CRunEventState()
	{
		if(m_bstrName != NULL)
			::SysFreeString(m_bstrName);

		if(m_bstrOriginalHref != NULL)
			::SysFreeString(m_bstrOriginalHref);
	}

public:
	inline BOOL IsDTEvent()
	{
		return ( (m_type == EventTypes::typeCustomEvent)  ||
			   (m_type == EventTypes::typeUnboundTag)   ||
			   (m_type == EventTypes::typeURLBoundTag) ||
			   (m_type == EventTypes::typeEventBoundTag)
			 );
	}
	
	HRESULT Load(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
		ULONG acbStrings[2];
		BSTR *apbstrStrings[2];
		int cStrings = 2;

		// TODO: Mopve this into state funcs..
		hr = pStm->Read(this, sizeof(CRunEventState), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);

		// read design time string lengths from stream

		hr = pStm->Read(acbStrings, sizeof(acbStrings), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// now check if there are any strings to read
		// if yes then set up array of string pointer addresses

		apbstrStrings[0] = &m_bstrName;
		apbstrStrings[1] = &m_bstrOriginalHref;

		hr = ReadStrings(pStm, acbStrings, apbstrStrings, 2);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

	HRESULT Save(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		ULONG acbStrings[2];
        ::ZeroMemory(acbStrings, sizeof(acbStrings));
		BSTR abstrStrings[2];
		int cStrings = 2;

		// set version numbers in node

		hr = pStm->Write(this, sizeof(CRunEventState), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunEventState) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of strings to be written to stream and
		// determine how many there will be

        if (NULL != m_bstrName)
        {
            acbStrings[0] = ::SysStringByteLen(m_bstrName);
        }
        if (NULL != m_bstrOriginalHref)
        {
            acbStrings[1] = ::SysStringByteLen(m_bstrOriginalHref);
        }

		abstrStrings[0] = m_bstrName;
		abstrStrings[1] = m_bstrOriginalHref;

		// write string lengths to stream

		hr = pStm->Write(acbStrings, sizeof(acbStrings), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// write strings to stream

		hr = WriteStrings(pStm, acbStrings, abstrStrings, cStrings);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

	inline DISPID GetDISPIDDirect() { return m_dispid; }
	inline BSTR GetNameDirect() {return m_bstrName; }

public:
	DWORD m_dwVerMajor;
	DWORD m_dwVerMinor;
	WebClassEventTypes  m_type;               // node type: nested WebClass, URL, events
	DISPID		m_dispid;             // dispid of node
	BSTR		m_bstrName;           // name of node
	BSTR		m_bstrOriginalHref;
};


class CRunWebClassStateHeader
{
public:
	CRunWebClassStateHeader()
	{
		m_pWebClassState = NULL;
		m_cbWebClassState = 0;
		m_dwWebItemCount = 0;
	}

	~CRunWebClassStateHeader(){}

public:
	CRunWebClassState*	m_pWebClassState;
	DWORD				m_cbWebClassState;
	DWORD				m_dwWebItemCount;
};

//////////////////////////////////////////////////////////////////////
//
// File Format:
//
// WCS_WEBCLASS structure
// length of WCS_WEBCLASS.bstrName
// length of WCS_WEBCLASS.bstrCatastropheURL
// length of WCS_WEBCLASS.bstrVirtualDirectory
// WCS_WEBCLASS.bstrName
// WCS_WEBCLASS.bstrCatastropheURL
// WCS_WEBCLASS.bstrVirtualDirectory
//
// WCS_WEBCLASS.cNodes instances of
// +-------------------------------
// | WCS_NODE structure
// | length of WCS_NODE.bstrName
// | lengths of other node specific strings
// | WCS_NODE.bstrName
// | other node specific strings
// +-------------------------------
//
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//
// inline void WCS_FreeWebClass(WCS_WEBCLASS *pClass)
//
// Frees all embedded BSTRs and invokes delete on structure
// 
//////////////////////////////////////////////////////////////////////
/*
inline void WCS_FreeWebClass(WCS_WEBCLASS *pClass)
{
  if (pClass->bstrName != NULL)
  {
    ::SysFreeString(pClass->bstrName);
  }
  if (pClass->bstrProgID != NULL)
  {
    ::SysFreeString(pClass->bstrProgID);
  }
  if (pClass->bstrCatastropheURL != NULL)
  {
    ::SysFreeString(pClass->bstrCatastropheURL);
  }
  if (pClass->bstrVirtualDirectory != NULL)
  {
    ::SysFreeString(pClass->bstrVirtualDirectory);
  }
  if (pClass->bstrFirstURL != NULL)
  {
    ::SysFreeString(pClass->bstrFirstURL);
  }
  if (pClass->bstrASPName != NULL)
  {
    ::SysFreeString(pClass->bstrASPName);
  }
  delete pClass;
}
*/
//////////////////////////////////////////////////////////////////////
//
// inline void WCS_FreeNode(WCS_NODE *pNode)
//
// Frees all embedded BSTRs and invokes delete on structure
//
//////////////////////////////////////////////////////////////////////
/*
inline void WCS_FreeNode(WCS_NODE *pNode)
{
  if (pNode->bstrName != NULL)
  {
    ::SysFreeString(pNode->bstrName);
  }
  if (WCS_NODE_TYPE_NESTED_WEBCLASS == pNode->bType)
  {
    if (pNode->bstrProgID != NULL)
    {
      ::SysFreeString(pNode->bstrProgID);
    }
  }
  else if ( (WCS_NODE_TYPE_PAGE == pNode->bType) ||
            (WCS_DTNODE_TYPE_PAGE == pNode->bType) )
  {
    if (pNode->bstrTemplate != NULL)
    {
      ::SysFreeString(pNode->Page.bstrTemplate);
    }
    if (pNode->Page.bstrToken != NULL)
    {
      ::SysFreeString(pNode->Page.bstrToken);
    }
    if (pNode->Page.bstrAppendedParams != NULL)
    {
      ::SysFreeString(pNode->Page.bstrAppendedParams);
    }
  }
  delete pNode;
}

//////////////////////////////////////////////////////////////////////
//
// inline void WCS_FreeDTNode(WCS_NODE *pNode)
//
// Frees all embedded BSTRs and invokes delete on structure
//
//////////////////////////////////////////////////////////////////////

inline void WCS_FreeDTNode(WCS_DTNODE *pNode)
{
  if ( (WCS_DTNODE_TYPE_URL_BOUND_TAG == pNode->bType) ||
       (WCS_DTNODE_TYPE_EVENT_BOUND_TAG == pNode->bType) )
  {
    if (NULL != pNode->DTEvent.bstrOriginalHref)
    {
      ::SysFreeString(pNode->DTEvent.bstrOriginalHref);
    }
  }
  else if (WCS_DTNODE_TYPE_PAGE == pNode->bType)
  {
    if (NULL != pNode->DTPage.bstrHTMLTemplateSrcName)
    {
      ::SysFreeString(pNode->DTPage.bstrHTMLTemplateSrcName);
    }
  }
  WCS_FreeNode(pNode);
}



//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_ReadWebClass(IStream *pStream,
//                                 WCS_WEBCLASS **ppClass)
//
//
//////////////////////////////////////////////////////////////////////


inline HRESULT WCS_ReadWebClass(IStream *pStream, WCS_WEBCLASS **ppClass)
{
  HRESULT hr = S_OK;
  ULONG cbRead = 0;
  ULONG acbStrings[6];
  BSTR *apbstrStrings[6];

  // allocate structure
  
  *ppClass = new WCS_WEBCLASS;
  CSF_CHECK(*ppClass != NULL, E_OUTOFMEMORY, CSF_TRACE_INTERNAL_ERRORS);

  // read structure from stream

  hr = pStream->Read(*ppClass, sizeof(**ppClass), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(**ppClass) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  (*ppClass)->pvData = NULL; // don't take junk pointer value from stream

  // TODO: need error codes for version incompatibility, handle backlevel formats etc.

  CSF_CHECK(WCS_WEBCLASS_VER_MAJOR == (*ppClass)->wVerMajor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(WCS_WEBCLASS_VER_MAJOR == (*ppClass)->wVerMinor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);

  // read string lengths from stream

  hr = pStream->Read(acbStrings, sizeof(acbStrings), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of string pointer addresses

  apbstrStrings[0] = &((*ppClass)->bstrName);
  apbstrStrings[1] = &((*ppClass)->bstrProgID);
  apbstrStrings[2] = &((*ppClass)->bstrCatastropheURL);
  apbstrStrings[3] = &((*ppClass)->bstrVirtualDirectory);
  apbstrStrings[4] = &((*ppClass)->bstrFirstURL);
  apbstrStrings[5] = &((*ppClass)->bstrASPName);

  // read strings from stream

  hr = ReadStrings(pStream, acbStrings, apbstrStrings,
                   (sizeof(acbStrings) / sizeof(acbStrings[0])) );
  
CLEANUP:
  if (FAILED(hr) && (*ppClass != NULL))
  {
    WCS_FreeWebClass(*ppClass);
    *ppClass = NULL;
  }
  return hr;
}


//=--------------------------------------------------------------------------=
//
// inline HRESULT WCS_ReadNodeFromStream(IStream *pStream, WCS_NODE *pNode)
//
// Reads a WCS_NODE structure from a stream. Caller passes in node.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCS_ReadNodeFromStream(IStream *pStream, WCS_NODE *pNode)
{
  HRESULT hr = S_OK;
  ULONG cbRead = 0;
  ULONG acbStrings[4];
  BSTR *apbstrStrings[4];
  int cStrings = 0;

  // read structure from stream

  hr = pStream->Read(pNode, sizeof(*pNode), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(*pNode) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // TODO: need error codes for version incompatibility, handle backlevel formats etc.

  CSF_CHECK(WCS_NODE_VER_MAJOR == pNode->wVerMajor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(WCS_NODE_VER_MINOR == pNode->wVerMinor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of string pointer addresses according to node type

  apbstrStrings[0] = &(pNode->bstrName);

  if ( (WCS_NODE_TYPE_NESTED_WEBCLASS == pNode->bType) ||
       (WCS_DTNODE_TYPE_NESTED_WEBCLASS == pNode->bType) )
  {
    apbstrStrings[1] = &(pNode->bstrProgID);
    cStrings = 2;
  }
  else if ( (WCS_NODE_TYPE_PAGE == pNode->bType) ||
            (WCS_DTNODE_TYPE_PAGE == pNode->bType) )
  {
    apbstrStrings[1] = &(pNode->bstrTemplate);
    apbstrStrings[2] = &(pNode->bstrToken);
    apbstrStrings[3] = &(pNode->bstrAppendedParams);
    cStrings = 4;
  }
  else if ( (WCS_NODE_TYPE_EVENT == bType) ||
            IsDTEvent(bType) )
  {
    cStrings = 1;
  }
  else
  {
    CSF_CHECK(FALSE, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
  }

  // read string lengths from stream

  hr = pStream->Read(acbStrings, sizeof(acbStrings), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // read strings from stream

  hr = ReadStrings(pStream, acbStrings, apbstrStrings, cStrings);

CLEANUP:
  return hr;
}

//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_ReadNode(IStream *pStream, WCS_NODE **ppNode)
//
// Allocates a WCS_NODE structure and reads its contents from the
// stream.
//
//////////////////////////////////////////////////////////////////////

inline HRESULT WCS_ReadNode(IStream *pStream, WCS_NODE **ppNode)
{
  HRESULT hr = S_OK;

  // allocate structure

  *ppNode = new WCS_NODE;
  CSF_CHECK(*ppNode != NULL, E_OUTOFMEMORY, CSF_TRACE_INTERNAL_ERRORS);

  // read node in from stream

  hr = WCS_ReadNodeFromStream(pStream, *ppNode);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

CLEANUP:
  if (FAILED(hr) && (*ppNode != NULL))
  {
    WCS_FreeNode(*ppNode);
    *ppNode = NULL;
  }
  return hr;
}



//=--------------------------------------------------------------------------=
//
// inline HRESULT WCS_ReadDTNode(IStream *pStream, WCS_DTNODE **ppNode)
//
// Allocates a WCS_DTNODE and reads its contents from the stream.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCS_ReadDTNode(IStream *pStream, WCS_DTNODE **ppNode)
{
  HRESULT hr = S_OK;
  ULONG cbRead = 0;
  ULONG acbStrings[1];
  BSTR *apbstrStrings[1];
  int cStrings = 0;

  // allocate structure

  *ppNode = new WCS_DTNODE;
  CSF_CHECK(*ppNode != NULL, E_OUTOFMEMORY, CSF_TRACE_INTERNAL_ERRORS);

  // read base class WCS_NODE first

  hr = WCS_ReadNodeFromStream(pStream, *ppNode);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

  // read design time fields

  if (WCS_DTNODE_TYPE_PAGE == (*ppNode)->bType)
  {
    hr = pStream->Read(&(*ppNode)->DTPage, sizeof((*ppNode)->DTPage), &cbRead);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof((*ppNode)->DTPage) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
  }
  else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != (*ppNode)->bType)
  {
    hr = pStream->Read(&(*ppNode)->DTEvent, sizeof((*ppNode)->DTEvent), &cbRead);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof((*ppNode)->DTEvent) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
  }

  // read design time string lengths from stream

  hr = pStream->Read(acbStrings, sizeof(acbStrings), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // now check if there are any strings to read
  // if yes then set up array of string pointer addresses

  if (0 == acbStrings[0])
  {
    // There are no strings to read so store NULL pointers
    if (WCS_DTNODE_TYPE_PAGE == (*ppNode)->bType)
    {
      (*ppNode)->DTPage.bstrHTMLTemplateSrcName = NULL;
    }
    else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != (*ppNode)->bType)
    {
      (*ppNode)->DTEvent.bstrOriginalHref = NULL;
    }
    goto CLEANUP;
  }
  else // There are strings so read them from the stream
  {
    if (WCS_DTNODE_TYPE_PAGE == (*ppNode)->bType)
    {
      apbstrStrings[0] = &((*ppNode)->DTPage.bstrHTMLTemplateSrcName);
    }
    else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != (*ppNode)->bType)
    {
      apbstrStrings[0] = &((*ppNode)->DTEvent.bstrOriginalHref);
    }
    cStrings++;
  }

  // read strings from stream

  if (cStrings > 0)
  {
    hr = ReadStrings(pStream, acbStrings, apbstrStrings, cStrings);
  }

CLEANUP:
  if (FAILED(hr) && (*ppNode != NULL))
  {
    WCS_FreeDTNode(*ppNode);
    *ppNode = NULL;
  }
  return hr;
}

//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_WriteWebClass(IStream *pStream, WCS_WEBCLASS *pClass)
//
//
//////////////////////////////////////////////////////////////////////

inline HRESULT WCS_WriteWebClass(IStream *pStream, WCS_WEBCLASS *pClass)
{
  HRESULT hr = S_OK;
  ULONG cbWritten = 0;
  ULONG acbStrings[6];
  BSTR abstrStrings[6];

  // set version numbers

  pClass->wVerMajor = WCS_WEBCLASS_VER_MAJOR;
  pClass->wVerMinor = WCS_WEBCLASS_VER_MAJOR;

  // write WebClass structure to stream

  hr = pStream->Write(pClass, sizeof(*pClass), &cbWritten);
  CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(cbWritten == sizeof(*pClass), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // get lengths of strings and write them to stream

  acbStrings[0] = SysStringByteLen(pClass->bstrName);
  acbStrings[1] = SysStringByteLen(pClass->bstrProgID);
  acbStrings[2] = SysStringByteLen(pClass->bstrCatastropheURL);
  acbStrings[3] = SysStringByteLen(pClass->bstrVirtualDirectory);
  acbStrings[4] = SysStringByteLen(pClass->bstrFirstURL);
  acbStrings[5] = SysStringByteLen(pClass->bstrASPName);

  hr = pStream->Write(acbStrings, sizeof(acbStrings), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(cbWritten == sizeof(acbStrings), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of pointers to strings to be written to stream
  
  abstrStrings[0] = pClass->bstrName;
  abstrStrings[1] = pClass->bstrProgID;
  abstrStrings[2] = pClass->bstrCatastropheURL;
  abstrStrings[3] = pClass->bstrVirtualDirectory;
  abstrStrings[4] = pClass->bstrFirstURL;
  abstrStrings[5] = pClass->bstrASPName;

  // write strings to stream

  hr = WriteStrings(pStream, acbStrings, abstrStrings,
                    (sizeof(acbStrings) / sizeof(acbStrings[0])) );

CLEANUP:
  return hr;
}


//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_WriteNode(IStream *pStream, WCS_NODE *pNode)
//
//
//////////////////////////////////////////////////////////////////////

inline HRESULT WCS_WriteNode(IStream *pStream, WCS_NODE *pNode)
{
  HRESULT hr = S_OK;
  ULONG cbWritten = 0;
  ULONG acbStrings[4];
  BSTR abstrStrings[4];
  int cStrings = 0;

  // set version numbers in node

  pNode->wVerMajor = WCS_NODE_VER_MAJOR;
  pNode->wVerMinor = WCS_NODE_VER_MINOR;

  // write node structure to stream

  hr = pStream->Write(pNode, sizeof(*pNode), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(*pNode) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of strings to be written to stream and
  // determine how many there will be

  abstrStrings[0] = pNode->bstrName;
  acbStrings[0] = ::SysStringByteLen(pNode->bstrName);

  if ( (WCS_NODE_TYPE_NESTED_WEBCLASS == pNode->bType) ||
       (WCS_DTNODE_TYPE_NESTED_WEBCLASS == pNode->bType) )
  {
    abstrStrings[1] = pNode->Nested.bstrProgID;
    acbStrings[1] = ::SysStringByteLen(pNode->Nested.bstrProgID);
    cStrings = 2;
  }
  else if ( (WCS_NODE_TYPE_PAGE == pNode->bType) ||
            (WCS_DTNODE_TYPE_PAGE == pNode->bType) )
  {
    abstrStrings[1] = pNode->Page.bstrTemplate;
    acbStrings[1] = ::SysStringByteLen(pNode->Page.bstrTemplate);
    abstrStrings[2] = pNode->Page.bstrToken;
    acbStrings[2] = ::SysStringByteLen(pNode->Page.bstrToken);
    abstrStrings[3] = pNode->Page.bstrAppendedParams;
    acbStrings[3] = ::SysStringByteLen(pNode->Page.bstrAppendedParams);
    cStrings = 4;
  }
  else if ( (WCS_NODE_TYPE_EVENT == pNode->bType) ||
            WCS_IsDTEvent(pNode->bType) )
  {
    cStrings = 1;
  }
  else
  {
    CSF_CHECK(FALSE, E_INVALIDARG, CSF_TRACE_INTERNAL_ERRORS);
  }

  // write string lengths to stream

  hr = pStream->Write(acbStrings, sizeof(acbStrings), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // write strings to stream

  hr = WriteStrings(pStream, acbStrings, abstrStrings, cStrings);

CLEANUP:
  return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCS_WriteDTNode(IStream *pStream, WCS_DTNODE *pNode)
//
// Write design time node. Write the base class runtime node and then
// then extra stuff in the design time node.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCS_WriteDTNode(IStream *pStream, WCS_DTNODE *pNode)
{
  HRESULT hr = S_OK;
  ULONG cbWritten = 0;
  ULONG acbStrings[1] = { 0 };
  BSTR abstrStrings[1];
  int cStrings = 0;

  // write run time node first

  hr = WCS_WriteNode(pStream, pNode);
  CSF_CHECK(hr == S_OK, hr, CSF_TRACE_INTERNAL_ERRORS);

  // write design time fields

  if (WCS_DTNODE_TYPE_PAGE == pNode->bType)
  {
    hr = pStream->Write(&pNode->DTPage, sizeof(pNode->DTPage), &cbWritten);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof(pNode->DTPage) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

    if (NULL != pNode->DTPage.bstrHTMLTemplateSrcName)
    {
      abstrStrings[0] = pNode->DTPage.bstrHTMLTemplateSrcName;
      acbStrings[0] = ::SysStringByteLen(pNode->DTPage.bstrHTMLTemplateSrcName);
      cStrings++;
    }
  }
  else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != pNode->bType)
  {
    hr = pStream->Write(&pNode->DTEvent, sizeof(pNode->DTEvent), &cbWritten);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof(pNode->DTEvent) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

    if (NULL != pNode->DTEvent.bstrOriginalHref)
    {
      abstrStrings[0] = pNode->DTEvent.bstrOriginalHref;
      acbStrings[0] = ::SysStringByteLen(pNode->DTEvent.bstrOriginalHref);
      cStrings++;
    }
  }

  hr = pStream->Write(acbStrings, sizeof(acbStrings), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  if (cStrings > 0)
  {
    hr = WriteStrings(pStream, acbStrings, abstrStrings, cStrings);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);
  }

CLEANUP:
  return hr;
}
*/


#define _WBCLSSER_H_
#endif // _WBCLSSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\wcutil.h ===
//=--------------------------------------------------------------------------=
// WCUtil.H
//=--------------------------------------------------------------------------=
// Copyright (c) 1987-1998, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Utitlity Routines for the WebClass Designer
//

#ifndef _WCUTIL_H_

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_ANSIFromWideStr(WCHAR * pwszWideStr, char **ppszAnsi)
//
// Converts null terminated WCHAR string to null terminated ANSI string. 
// Allocates ANSI string using new operator. If successful, caller must free
// ANSI string with delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_ANSIFromWideStr"));

    HRESULT hr = S_OK;
    *ppszAnsi = NULL;
    int cchWideStr = (int)::wcslen(pwszWideStr);
    int cchConverted = 0;

    // get required buffer length

    int cchAnsi = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                        0,                    // performance and mapping flags 
                                        pwszWideStr,          // address of wide-character string 
                                        cchWideStr,           // number of characters in string 
                                        NULL,                 // address of buffer for new string 
                                        0,                    // size of buffer 
                                        NULL,                 // address of default for unmappable characters 
                                        NULL                  // address of flag set when default char. used 
                                       );
    CSF_CHECK(0 != cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the ANSI string

    *ppszAnsi = new char [cchAnsi + 1];
    CSF_CHECK(NULL != *ppszAnsi, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pwszWideStr,          // address of wide-character string 
                                         cchWideStr,           // number of characters in string 
                                         *ppszAnsi,            // address of buffer for new string 
                                         cchAnsi,              // size of buffer 
                                         NULL,                 // address of default for unmappable characters 
                                         NULL                  // address of flag set when default char. used 
                                        );
    CSF_CHECK(cchConverted == cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null byte

    *( (*ppszAnsi) + cchAnsi ) = '\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            delete [] *ppszAnsi;
            *ppszAnsi = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_ANSIFromWideStr hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_ANSIFromWideStr(WCHAR * pwszWideStr, char **ppszAnsi)
//
// Converts null terminated WCHAR string to null terminated ANSI string. 
// Allocates ANSI string using new operator. If successful, caller must free
// ANSI string with delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_ANSIFromWideStrLen(WCHAR *pwszWideStr, int cchWideStr, char **ppszAnsi)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_ANSIFromWideStr"));

    HRESULT hr = S_OK;
    *ppszAnsi = NULL;
    int cchConverted = 0;

    // get required buffer length

    int cchAnsi = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                        0,                    // performance and mapping flags 
                                        pwszWideStr,          // address of wide-character string 
                                        cchWideStr,           // number of characters in string 
                                        NULL,                 // address of buffer for new string 
                                        0,                    // size of buffer 
                                        NULL,                 // address of default for unmappable characters 
                                        NULL                  // address of flag set when default char. used 
                                       );
    CSF_CHECK(0 != cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the ANSI string

    *ppszAnsi = new char [cchAnsi + 1];
    CSF_CHECK(NULL != *ppszAnsi, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pwszWideStr,          // address of wide-character string 
                                         cchWideStr,           // number of characters in string 
                                         *ppszAnsi,            // address of buffer for new string 
                                         cchAnsi,              // size of buffer 
                                         NULL,                 // address of default for unmappable characters 
                                         NULL                  // address of flag set when default char. used 
                                        );
    CSF_CHECK(cchConverted == cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null byte

    *( (*ppszAnsi) + cchAnsi ) = '\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            delete [] *ppszAnsi;
            *ppszAnsi = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_ANSIFromWideStr hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr))
//
// Converts null terminated ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the new operator. If successful, caller
// must free WCHAR string using the delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_WideStrFromANSI"));

    HRESULT hr = S_OK;
    *ppwszWideStr = NULL;
    int cchANSI = ::strlen(pszAnsi);
    int cchConverted = 0;

    // get required buffer length

    int cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           cchANSI,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
    CSF_CHECK(0 != cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the WCHAR *

    *ppwszWideStr = new WCHAR[cchWideStr + 1];
    CSF_CHECK(NULL != *ppwszWideStr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pszAnsi,              // address of multibyte string 
                                         cchANSI,              // number of characters in string 
                                         *ppwszWideStr,               // address of buffer for new string 
                                         cchWideStr               // size of buffer 
                                        );
    CSF_CHECK(cchConverted == cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null character

    *( (*ppwszWideStr) + cchWideStr ) = L'\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            delete [] *ppwszWideStr;
            *ppwszWideStr = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_WideStrFromANSI hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_WideStrFromANSIExtra(char *pszAnsi, WCHAR **ppwszWideStr))
//
// Converts null terminated ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the new operator. If successful, caller
// must free WCHAR string using the delete operator. 
//
// User can also specify the number of extra bytes to add the returned buffer. The
// actual size of the buffer is returned as well.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_WideStrFromANSIExtra
(
	HANDLE hHeap,
	char *pszAnsi, 
	int cchANSI,
	WCHAR **ppwszWideStr, 
	DWORD cbExtra,
	DWORD* pcbBufferSize,
	DWORD* pcchConverted
)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_WideStrFromANSI"));

    HRESULT hr = S_OK;
    *ppwszWideStr = NULL;
    int cchConverted = 0;
	DWORD cbBufferSize = 0;

    // get required buffer length

    int cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           cchANSI,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
    CSF_CHECK(0 != cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

	cbBufferSize = (cchWideStr + 1 + cbExtra) * sizeof(WCHAR);

    // allocate a buffer for the WCHAR *

    *ppwszWideStr = (LPWSTR) HeapAlloc(hHeap, NULL, cbBufferSize);
    CSF_CHECK(NULL != *ppwszWideStr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pszAnsi,              // address of multibyte string 
                                         cchANSI,              // number of characters in string 
                                         *ppwszWideStr,               // address of buffer for new string 
                                         cchWideStr               // size of buffer 
                                        );
    CSF_CHECK(cchConverted == cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null character

    *( (*ppwszWideStr) + cchWideStr ) = L'\0';
	
	*pcbBufferSize = cbBufferSize;
	*pcchConverted = cchConverted;

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            delete [] *ppwszWideStr;
            *ppwszWideStr = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_WideStrFromANSI hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_WideStrFromANSILen(char *pszAnsi, int nLen, WCHAR **ppwszWideStr))
//
// Converts length specifed ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the new operator. If successful, caller
// must free WCHAR string using the delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_WideStrFromANSILen(char *pszAnsi, int nLen, WCHAR **ppwszWideStr)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_WideStrFromANSI"));

    HRESULT hr = S_OK;
    *ppwszWideStr = NULL;
    int cchConverted = 0;

	if(nLen == 0)
	{
		*ppwszWideStr = NULL;
		return S_OK;
	}

    // get required buffer length

    int cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           nLen,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
    CSF_CHECK(0 != cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the WCHAR *

    *ppwszWideStr = new WCHAR[cchWideStr + 1];
    CSF_CHECK(NULL != *ppwszWideStr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pszAnsi,              // address of multibyte string 
                                         nLen,              // number of characters in string 
                                         *ppwszWideStr,               // address of buffer for new string 
                                         cchWideStr               // size of buffer 
                                        );
    CSF_CHECK(cchConverted == cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null character

    *( (*ppwszWideStr) + cchWideStr ) = L'\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            delete [] *ppwszWideStr;
            *ppwszWideStr = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_WideStrFromANSI hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_ANSIFromBSTR(BSTR bstr, char **ppszAnsi)
//
// Converts BSTR to null terminated ANSI string. Allocates ANSI string using
// new operator. If successful, caller must free ANSI string with delete
// operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_ANSIFromBSTR(BSTR bstr, char **ppszAnsi)
{
  CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_ANSIFromBSTR"));

  HRESULT hr = S_OK;
  *ppszAnsi = NULL;
  int cchBstr = (int)::SysStringLen(bstr);
  int cchConverted = 0;

  // get required buffer length

  int cchAnsi = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                      0,                    // performance and mapping flags 
                                      bstr,                 // address of wide-character string 
                                      cchBstr,              // number of characters in string 
                                      NULL,                 // address of buffer for new string 
                                      0,                    // size of buffer 
                                      NULL,                 // address of default for unmappable characters 
                                      NULL                  // address of flag set when default char. used 
                                     );
  CSF_CHECK(0 != cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

  // allocate a buffer for the ANSI string

  *ppszAnsi = new char [cchAnsi + 1];
  CSF_CHECK(NULL != *ppszAnsi, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

  // now convert the string and copy it to the buffer
  
  cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                       0,                    // performance and mapping flags 
                                       bstr,                 // address of wide-character string 
                                       cchBstr,              // number of characters in string 
                                       *ppszAnsi,            // address of buffer for new string 
                                       cchAnsi,              // size of buffer 
                                       NULL,                 // address of default for unmappable characters 
                                       NULL                  // address of flag set when default char. used 
                                      );
  CSF_CHECK(cchConverted == cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

  // add terminating null byte

  *( (*ppszAnsi) + cchAnsi ) = '\0';

CLEANUP:
  if (FAILED(hr))
  {
    if (NULL != *ppszAnsi)
    {
      delete [] *ppszAnsi;
      *ppszAnsi = NULL;
    }
  }

  CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_ANSIFromBSTR hr = %08.8X"), hr);

  return hr;
}



//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_BSTRFromANSI(char *pszAnsi, BSTR *pbstr))
//
// Converts null terminated ANSI string to a null terminated BSTR. Allocates
// BSTR. If successful, caller must free BSTR using ::SysFreeString().
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_BSTRFromANSI(char *pszAnsi, BSTR *pbstr)
{
  CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_BSTRFromANSI"));

  HRESULT hr = S_OK;
  WCHAR   *pwszWideStr = NULL;

  // convert to a wide string first

  hr = WCU_WideStrFromANSI(pszAnsi, &pwszWideStr);
  CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);

  // allocate a BSTR and copy it

  *pbstr = ::SysAllocStringLen(pwszWideStr, ::wcslen(pwszWideStr));
  CSF_CHECK(NULL != *pbstr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

CLEANUP:
  if (NULL != pwszWideStr)
  {
      delete [] pwszWideStr;
  }
  if (FAILED(hr))
  {
    if (NULL != *pbstr)
    {
      ::SysFreeString(*pbstr);
      *pbstr = NULL;
    }
  }

  CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_BSTRFromANSI hr = %08.8X"), hr);

  return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_BSTRFromANSILen(char *pszAnsi, int nLen, BSTR *pbstr))
//
// Converts len specified ANSI string to a null terminated BSTR. Allocates
// BSTR. If successful, caller must free BSTR using ::SysFreeString().
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_BSTRFromANSILen(char *pszAnsi, int nLen, BSTR *pbstr)
{
  CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_BSTRFromANSI"));

  HRESULT hr = S_OK;
  WCHAR   *pwszWideStr = NULL;

  if(nLen == 0)
  {
	*pbstr = SysAllocString(L"\0");
	CSF_CHECK(*pbstr != NULL, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

	return S_OK;
  }

  // convert to a wide string first

  hr = WCU_WideStrFromANSILen(pszAnsi, nLen, &pwszWideStr);
  CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);

  // allocate a BSTR and copy it

  *pbstr = ::SysAllocStringLen(pwszWideStr, nLen);
  CSF_CHECK(NULL != *pbstr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

CLEANUP:
  if (NULL != pwszWideStr)
  {
      delete [] pwszWideStr;
  }
  if (FAILED(hr))
  {
    if (NULL != *pbstr)
    {
      ::SysFreeString(*pbstr);
      *pbstr = NULL;
    }
  }

  CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_BSTRFromANSI hr = %08.8X"), hr);

  return hr;
}

inline HRESULT GetIISVersion
(
	DWORD* pdwMajor, 
	DWORD* pdwMinor
)
{
	HRESULT hr = S_OK;
	TCHAR *pszRegIISParamsKey = { TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters") };
	TCHAR *pszRegASPParamsKey = { TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASP") };
	HKEY hKey = NULL;
	long lRet = 0;
	DWORD dwType = 0;
	DWORD cbSize = sizeof(DWORD);

	lRet = ::RegOpenKey(HKEY_LOCAL_MACHINE,
  					    pszRegIISParamsKey,
					    &hKey);
	CSF_CHECK(lRet == ERROR_SUCCESS, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);
		
	// Now, we can get the size of the value...
	lRet = ::RegQueryValueEx(hKey, "MajorVersion", NULL, &dwType, (BYTE*) pdwMajor, &cbSize);
	CSF_CHECK(lRet == ERROR_SUCCESS, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

	// Now, we can get the size of the value...
	lRet = ::RegQueryValueEx(hKey, "MinorVersion", NULL, &dwType, (BYTE*) pdwMinor, &cbSize);
	CSF_CHECK(lRet == ERROR_SUCCESS, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // Uggghh! IIS 3.0 never update the registry verison, so we need to check for 
    // ASP if 1 or 2 was specified...
    if(*pdwMajor < 3)
    {
		::RegCloseKey(hKey);

	    lRet = ::RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
  					            pszRegASPParamsKey,
                                0,
                                KEY_QUERY_VALUE,
					            &hKey);
	    
        if(lRet == ERROR_SUCCESS)
        {
            // We found the ASP key so this must be version 3.0...
            *pdwMajor = 3;
            *pdwMinor = 0;
        }
        
    }

CLEANUP:
	if(hKey != NULL)
		::RegCloseKey(hKey);

	return hr;
}

// TODO: Do we want this this way?
// Maybe just substract 2? No We ain't dynamic casue
// of the tlb anyhow.
inline DWORD IISVersionToASPVersion(DWORD dwIIS)
{
    DWORD dwASP = 0;
    
    if(dwIIS == 3)
    {
        dwASP = 1;
    }
    else if(dwIIS == 4)
    {
        dwASP = 2;
    }

    return dwASP;
}

// Listed from most to least
static WCHAR g_wszMostUniqueCharset[] = {L"~`\\_/{}|[]^!@#$%*():;"};

//----------------------------------------------------------------------------------------
// PickMostUniqueChar
//----------------------------------------------------------------------------------------
// Selects the most unique char in the specified string. We use this to pick the most unique
// char in the user supplied tag prefix. This optimizes searching for those tags
//----------------------------------------------------------------------------------------

inline HRESULT PickMostUniqueChar
(
    LPWSTR pwszPrefix,		// [in] String to find unique char in
    WORD* pwIndex			// [out] Index of the most unique char
)
{
	LPWSTR pwszRet = NULL;

	ASSERT(wcslen(pwszPrefix) < 0xFFFF);

	// See if the string contains any of our unique chars
	//
	pwszRet = wcspbrk(pwszPrefix, g_wszMostUniqueCharset);

	if(pwszRet != NULL)
	{
	    *pwIndex = (WORD)(pwszRet - pwszPrefix);
	}
	else
	{
		// If not, just use first char in the string
		//
	    *pwIndex = 0;
	}

    return S_OK;
}

/***
*wchar_t *wcsistr(string1, string2) - search for string2 in string1
*       (wide strings)
*
*Purpose:
*       finds the first occurrence of string2 in string1 (wide strings)
*
*Entry:
*       wchar_t *string1 - string to search in
*       wchar_t *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/



//=--------------------------------------------------------------------------=
//
// wchar_t *WCU_wcsistr(string1, string2)
//
// Purpose:
//       Finds the first occurrence of string2 in string1 (wide strings.
//       Not case sensitive.
//       This is a direct copy of C runtime source code from VC5. The only
//       addition is the use of the Win32 API CharUpperBuffW() to do a locale
//       sensitive conversion of characters to upper case before comparing
//       them.
//
// Entry:
//       wchar_t *string1 - string to search in
//       wchar_t *string2 - string to search for
//
// Exit:
//       returns a pointer to the first occurrence of string2 in
//       string1, or NULL if string2 does not occur in string1
//
//=--------------------------------------------------------------------------=

inline wchar_t * __cdecl WCU_wcsistr
(
    const wchar_t * wcs1,
    const wchar_t * wcs2
)
{
    wchar_t *cp = (wchar_t *) wcs1;
    wchar_t *s1, *s2;
    wchar_t c1, c2;
    

    while (*cp)
    {
        s1 = cp;
        s2 = (wchar_t *) wcs2;

        // while there are characters left in both strings

        while ( *s1 && *s2 )
        {
            // if the characters are not equal

            if (*s1 - *s2)
            {
                // convert them to uppercase

                c1 = *s1;
                c2 = *s2;
                if ( (CharUpperBuffW(&c1, (DWORD)1) != (DWORD)1) ||
                     (CharUpperBuffW(&c2, (DWORD)1) != (DWORD)1) )
                {
                    break;
                }

                // if the upper case characters are not equal then the string
                // is not there

                if (c1 - c2)
                    break;
            }
            s1++, s2++;
        }

        if (!*s2)
            return(cp);

        cp++;
    }

    return(NULL);
}



#define _WCUTIL_H_
#endif // _WCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mmcproxy\stub_dlldata.c ===
#include <dlldata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\vshelp.h ===
//=--------------------------------------------------------------------------=
// HtmlHlp.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Contains HtmlHelp helper functions
//
#ifndef _HTMLHELP_H_
#define _HTMLHELP_H_

#ifdef VS_HELP

    #include "HelpInit.H"
    #include "HelpSys.H"
    #include "HelpSvcs.h"
    
    //=--------------------------------------------------------------------------=
    // HtmlHelp helpers
    //
    HRESULT VisualStudioShowHelpTopic(const char *pszHelpFile, DWORD dwContextId, BOOL *pbHelpStarted);
    HRESULT QueryStartupVisualStudioHelp(IVsHelpSystem **ppIVsHelpSystem);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mmcproxy\proxy.c ===
//=--------------------------------------------------------------------------=
// proxy.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// MMC Interfcace Proxy and Stub Functions
//
//=--------------------------------------------------------------------------=
// This file contains proxy and stub functions for MMC methods that are not
// remotable using a MIDL generated proxy and stub. Non-remotable methods have
// parameters that are ambiguous i.e. can be casted to different data types.
// For example, IComponentData::Notify() is passed an event and two additional
// LPARAM arguments that are interpreted according to the event. Sometimes an
// LPARAM contains a simple value such as a long or two BOOLs and sometimes it
// contains an IDataObject *. MIDL doesn't know the difference between
// MMCN_SELECT and MMCN_PRINT so we need to write some code to help out.
// 
// The version of MMC.IDL in the designer directory has added a [local]
// attribute to all non-remotable methods. In addition, an extra method has
// been added to the same interface that is a remotable version of the method.
// The remotable version has more parameters and represents the union of all
// possible interpretations of the ambiguous parameter. For example,
// IExtendControlbar::ControlbarNotify() is defined as:
// 
//    [helpstring("User actions"), local]
//    HRESULT ControlbarNotify([in] MMC_NOTIFY_TYPE event,
//                             [in] LPARAM arg, [in] LPARAM param);
// 
// This method can receive MMCN_SELECT, MMCN_BTN_CLICK, and MMCN_MENU_BTNCLICK.
// The union of all possible parameter types is used in the following method
// added to that interface:
// 
// 
//    HRESULT RemControlbarNotify([in] MMC_NOTIFY_TYPE event,
//                                [in] LPARAM lparam, 
//                                [in] IDataObject *piDataObject,
//                                [in] MENUBUTTONDATA *MenuButtonData);
// 
// Note, that normal, in-proc, non-remoted versions of IExtendControlbar do not
// have this extra method in their vtable because no one is going to call it.
// It is only used in the MILD generated proxy object.
// 
// In order to tell MIDL which method remotes ControlbarNotify() an attribute
// control file (ACF) is used. The entry in the ACF for IExtendControlbar is:
// 
// interface IExtendControlbar 
// {
//     [call_as (ControlbarNotify)]
//             RemControlbarNotify();
// 
// }
// 
// This says that RemControlbarNotify should be called when remoting
// ControlbarNotify(). MIDL generates the proxy/stub code as usual but it only
// generates the prototypes for ControlbarNotify proxy and stub. We have to
// write these routines. 
// 
// When a remote client has an IExtendControlbarNotify pointer it actually
// points into the proxy vtable. MIDL sets the ControlbarNotify entry pointing to
// our IExtendControlbar_ControlbarNotify_Proxy() function below. That function
// interprets the parameters and then calls the MIDL generated
// IExtendControlbar_RemControlbarNotify_Proxy() that packs up the parameters
// and sends them off to the server. If a parameters is not applicable, (e.g.
// MMCN_SELECT does not receive a pointer to a MENUBUTTONDATA stuct), then a
// pointer to an empty struct or zeroes are sent.
// 
// When the packet reaches the server side the MIDL generated
// IExtendControlbar_RemControlbarNotify_Stub() unpacks them and then calls our
// IExtendControlbar_ControlbarNotify_Stub() passing it the parameters and the
// IExtendControlbar pointer into the server. This function interprets the
// parameters and then calls ControlbarNotify in the server.
// 
//=--------------------------------------------------------------------------=

#include "mmc.h"

extern HRESULT GetClipboardFormat
(
    WCHAR      *pwszFormatName,
    CLIPFORMAT *pcfFormat
);

extern HRESULT CreateMultiSelDataObject
(
    IDataObject          **ppiDataObjects,
    long                   cDataObjects,
    IDataObject          **ppiMultiSelDataObject
);


static HRESULT MenuButtonClickProxy
( 
    IExtendControlbar __RPC_FAR *This,
    IDataObject                 *piDataObject,
    MENUBUTTONDATA              *pMenuButtonData
);

static HRESULT IsMultiSelect(IDataObject *piDataObject, BOOL *pfMultiSelect)
{
    HRESULT    hr = S_OK;
    DWORD     *pdwMultiSelect = NULL;
    BOOL       fGotData = FALSE;
    FORMATETC  FmtEtc;
    STGMEDIUM  StgMed;

    ZeroMemory(&FmtEtc, sizeof(FmtEtc));
    ZeroMemory(&StgMed, sizeof(StgMed));

    *pfMultiSelect = FALSE;

    if (NULL == piDataObject)
    {
        goto Cleanup;
    }

    if (IS_SPECIAL_DATAOBJECT(piDataObject))
    {
        goto Cleanup;
    }

    hr = GetClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT, &FmtEtc.cfFormat);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->lpVtbl->GetData(piDataObject, &FmtEtc, &StgMed);
    if (SUCCEEDED(hr))
    {
        fGotData = TRUE;
    }
    else
    {
        hr = S_OK;
    }

    // Ignore any failures and assume that it is not multi-select. Snap-ins
    // should return DV_E_FORMATETC or DV_E_CLIPFORMAT but in practice that
    // is not the case. For example, the IIS snap-in returns E_NOTIMPL.
    // It would be impossible to cover the range of reasonable return codes so
    // we treat any error as format not supported.

    if (fGotData)
    {
        pdwMultiSelect = (DWORD *)GlobalLock(StgMed.hGlobal);

        if ((DWORD)1 == *pdwMultiSelect)
        {
            *pfMultiSelect = TRUE;
        }
    }

Cleanup:
    if (NULL != pdwMultiSelect)
    {
        (void)GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ReleaseStgMedium(&StgMed);
    }
    return hr;
}




static HRESULT InterpretMultiSelect
(
    IDataObject     *piDataObject,
    long            *pcDataObjects,
    IDataObject   ***pppiDataObjects
)
{
    HRESULT          hr = S_OK;
    SMMCDataObjects *pMMCDataObjects = NULL;
    BOOL             fGotData = FALSE;
    size_t           cbObjectTypes = 0;
    long             i = 0;
    FORMATETC        FmtEtc;
    STGMEDIUM        StgMed;

    ZeroMemory(&FmtEtc, sizeof(FmtEtc));
    ZeroMemory(&StgMed, sizeof(StgMed));

    *pcDataObjects = 0;
    *pppiDataObjects = NULL;

    // Get the SMMCDataObjects structure from MMC

    hr = GetClipboardFormat(CCF_MULTI_SELECT_SNAPINS, &FmtEtc.cfFormat);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->lpVtbl->GetData(piDataObject, &FmtEtc, &StgMed);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    fGotData = TRUE;

    pMMCDataObjects = (SMMCDataObjects *)GlobalLock(StgMed.hGlobal);
    if (NULL == pMMCDataObjects)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // Allocate an array of IDataObject and copy the IDataObjects to it

    *pcDataObjects = pMMCDataObjects->count;
    *pppiDataObjects = (IDataObject **)GlobalAlloc(GPTR,
                               pMMCDataObjects->count * sizeof(IDataObject *));

    if (NULL == *pppiDataObjects)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for (i = 0; i < *pcDataObjects; i++)
    {
        (*pppiDataObjects)[i] = pMMCDataObjects->lpDataObject[i];
    }

Cleanup:
    if (NULL != pMMCDataObjects)
    {
        (void)GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ReleaseStgMedium(&StgMed);
    }

    return hr;
}


void CheckForSpecialDataObjects
(
    IDataObject **ppiDataObject,
    BOOL         *pfSpecialDataObject,
    long         *plSpecialDataObject
)
{
    long lSpecialDataObject = (long)(*ppiDataObject);

    if (IS_SPECIAL_DATAOBJECT(lSpecialDataObject))
    {
        *plSpecialDataObject = lSpecialDataObject;
        *ppiDataObject = NULL;
        *pfSpecialDataObject = TRUE;
    }
    else
    {
        *pfSpecialDataObject = FALSE;
    }
}

static HRESULT SetRemote(IUnknown *This)
{
    HRESULT     hr = S_OK;
    IMMCRemote *piMMCRemote = NULL;
    DWORD       cbFileName = 0;
    char        szModuleFileName[MAX_PATH] = "";

    // Call IMMCRemote methods: ObjectIsRemote and SetMMCExePath so that the
    // snap-in will know it is remote and so that it will have MMC.EXE's full
    // path in order to build taskpad display strings.

    hr = This->lpVtbl->QueryInterface(This, &IID_IMMCRemote,
                                      (void **)&piMMCRemote);
    if (FAILED(hr))
    {
        // If the object doesn't support IMMCRemote that is not an error.
        // The designer runtime will get this QI on both its main object and
        // its IComponent object but only the main object needs to support the
        // interface.
        hr = S_OK;
        goto Cleanup;
    }

    hr = piMMCRemote->lpVtbl->ObjectIsRemote(piMMCRemote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    cbFileName = GetModuleFileName(NULL, // get executable that loaded us (MMC)
                                   szModuleFileName,
                                   sizeof(szModuleFileName));

    if (0 == cbFileName)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    hr = piMMCRemote->lpVtbl->SetMMCExePath(piMMCRemote, szModuleFileName);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = piMMCRemote->lpVtbl->SetMMCCommandLine(piMMCRemote, GetCommandLine());
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    if (NULL != piMMCRemote)
    {
        piMMCRemote->lpVtbl->Release(piMMCRemote);
    }

    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Proxy
( 
    IExtendControlbar __RPC_FAR *This,
    LPCONTROLBAR                 pControlbar
)
{
    HRESULT hr = S_OK;

    // Make sure the snap-in knows we are remoted. We do this here because
    // this is the first opportunity for the proxy to inform a toolbar
    // extension that it is remote.

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = IExtendControlbar_RemSetControlbar_Proxy(This, pControlbar);

Cleanup:
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Stub
( 
    IExtendControlbar __RPC_FAR  *This,
    LPCONTROLBAR                  pControlbar
)
{
    return This->lpVtbl->SetControlbar(This, pControlbar);
}


HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Proxy
( 
    IExtendControlbar __RPC_FAR *This,
    MMC_NOTIFY_TYPE              event,
    LPARAM                       arg,
    LPARAM                       param
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject  *piDataObject = NULL; // Not AddRef()ed
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // If this is not a menu button click then we can use the generated remoting
    // code with the arg and param unions

    if (MMCN_MENU_BTNCLICK == event)
    {
        hr = MenuButtonClickProxy(This,
                                  (IDataObject *)arg,
                                  (MENUBUTTONDATA *)param);
        goto Cleanup;
    }
    // Get any IDataObject associated with the event

    switch (event)
    {
        case MMCN_SELECT:
            piDataObject = (IDataObject *)param;
            break;

        case MMCN_BTN_CLICK:
            piDataObject = (IDataObject *)arg;
            break;

        default:
            piDataObject = NULL;
            break;
    }

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects,
                                  &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendControlbar_RemControlbarNotify_Proxy(This,
                                                     cDataObjects,
                                                     ppiDataObjects,
                                                     fSpecialDataObject,
                                                     lSpecialDataObject,
                                                     event, arg, param);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Stub
( 
    IExtendControlbar __RPC_FAR  *This,
    long                          cDataObjects,
    IDataObject                 **ppiDataObjects,
    BOOL                          fSpecialDataObject,
    long                          lSpecialDataObject,
    MMC_NOTIFY_TYPE               event,
    LPARAM                        arg,
    LPARAM                        param
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Put the IDataObject into the corresponding parameter for the event

    switch (event)
    {
        case MMCN_SELECT:
            param = (LPARAM)piDataObject;
            break;

        case MMCN_BTN_CLICK:
            arg = (LPARAM)piDataObject;
            break;

        default:
            break;
    }

    // Call into the snap-in with all parameters appearing as they would
    // when in-proc.

    hr = This->lpVtbl->ControlbarNotify(This, event, arg, param);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


static HRESULT MenuButtonClickProxy
( 
    IExtendControlbar __RPC_FAR *This,
    IDataObject                 *piDataObject,
    MENUBUTTONDATA              *pMenuButtonData
)
{
    HRESULT                   hr = S_OK;
    POPUP_MENUDEF            *pPopupMenuDef = NULL;
    HMENU                     hMenu = NULL;
    UINT                      uiSelectedItemID = 0;
    IExtendControlbarRemote  *piECRemote = NULL;
    long                      i = 0;
    BOOL                      fIsMultiSelect = FALSE;
    long                      cDataObjects = 1L;
    IDataObject             **ppiDataObjects = NULL;


    // The generated remoting cannot easily handle what we need to do so we get
    // IExtendControlbarRemote on the snap-in. This interface has methods that
    // allow us to ask the snap-in for its popup menu items, display the menu
    // here on the MMC side, and then tell the snap-in which item was selected.

    hr = This->lpVtbl->QueryInterface(This, &IID_IExtendControlbarRemote,
                                      (void **)&piECRemote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Tell the snap-in about the menu button click and get back its list of
    // popup menu items.

    hr = piECRemote->lpVtbl->MenuButtonClick(piECRemote,
                                             piDataObject,
                                             pMenuButtonData->idCommand,
                                             &pPopupMenuDef);     

    if ( FAILED(hr) || (NULL == pPopupMenuDef) )
    {
        goto Cleanup;
    }

    // Create an empty Win32 menu

    hMenu = CreatePopupMenu();
    if (NULL == hMenu)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // Iterate through each of the items and add them to the menu

    for (i = 0; i < pPopupMenuDef->cMenuItems; i++)
    {
        if (!AppendMenu(hMenu,
                        pPopupMenuDef->MenuItems[i].uiFlags,
                        pPopupMenuDef->MenuItems[i].uiItemID,
                        pPopupMenuDef->MenuItems[i].pszItemText))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
    }

    // If the owner HWND is NULL then this is an extension and it does not have
    // access to IConsole2 on MMC to get the main frame HWND. In this case just
    // use the active window on this thread.

    if (NULL == pPopupMenuDef->hwndMenuOwner)
    {
        pPopupMenuDef->hwndMenuOwner = GetActiveWindow();
    }

    // Display the popup menu and wait for a selection.

    uiSelectedItemID = (UINT)TrackPopupMenu(
       hMenu,                        // menu to display
       TPM_LEFTALIGN |               // align left side of menu with x
       TPM_TOPALIGN  |               // align top of menu with y
       TPM_NONOTIFY  |               // don't send any messages during selection
       TPM_RETURNCMD |               // make the ret val the selected item
       TPM_LEFTBUTTON,               // allow selection with left button only
       pMenuButtonData->x,           // left side coordinate
       pMenuButtonData->y,           // top coordinate
       0,                            // reserved,
       pPopupMenuDef->hwndMenuOwner, // owner window, this comes from snap-in
                                     // as it can call IConsole2->GetMainWindow
       NULL);                        // not used

    // A zero return could indicate either an error or that the user hit
    // Escape or clicked off of the menu to cancel the operation. GetLastError()
    // determines whether there was an error. Either way we're done but set the
    // hr first.

    if (0 == uiSelectedItemID)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // If i is non-zero then it contains the ID of the selected item.
    // Tell the snap-in what was selected and pass it the extra IUnknown it
    // included in its menu definition (this is snap-in defined and it allows
    // the snap-in to include some more identifying information to handle the
    // event).

    if (0 != uiSelectedItemID)
    {
        hr = piECRemote->lpVtbl->PopupMenuClick(
                                              piECRemote,
                                              piDataObject,
                                              uiSelectedItemID,
                                              pPopupMenuDef->punkSnapInDefined);
    }

Cleanup:

    if (NULL != piECRemote)
    {
        piECRemote->lpVtbl->Release(piECRemote);
    }
    if (NULL != hMenu)
    {
        (void)DestroyMenu(hMenu);
    }

    if (NULL != pPopupMenuDef)
    {
        for (i = 0; i < pPopupMenuDef->cMenuItems; i++)
        {
            if (NULL != pPopupMenuDef->MenuItems[i].pszItemText)
            {
                CoTaskMemFree(pPopupMenuDef->MenuItems[i].pszItemText);
            }
        }
        if (NULL != pPopupMenuDef->punkSnapInDefined)
        {
            pPopupMenuDef->punkSnapInDefined->lpVtbl->Release(pPopupMenuDef->punkSnapInDefined);
        }
        CoTaskMemFree(pPopupMenuDef);
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_MenuButtonClick_Proxy
( 
    IExtendControlbarRemote __RPC_FAR  *This,
    IDataObject __RPC_FAR              *piDataObject,
    int                                 idCommand,
    POPUP_MENUDEF __RPC_FAR *__RPC_FAR *ppPopupMenuDef
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendControlbarRemote_RemMenuButtonClick_Proxy(This,
                                                          cDataObjects,
                                                          ppiDataObjects,
                                                          fSpecialDataObject,
                                                          lSpecialDataObject,
                                                          idCommand,
                                                          ppPopupMenuDef);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_MenuButtonClick_Stub
( 
    IExtendControlbarRemote __RPC_FAR  *This,
    long                                cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR    ppiDataObjects[  ],
    BOOL                                fSpecialDataObject,
    long                                lSpecialDataObject,
    int                                 idCommand,
    POPUP_MENUDEF __RPC_FAR *__RPC_FAR *ppPopupMenuDef
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->MenuButtonClick(This, piDataObject,
                                       idCommand, ppPopupMenuDef);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_PopupMenuClick_Proxy
(
    IExtendControlbarRemote __RPC_FAR *This,
    IDataObject __RPC_FAR             *piDataObject,
    UINT                               uIDItem,
    IUnknown __RPC_FAR                *punkParam
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendControlbarRemote_RemPopupMenuClick_Proxy(This,
                                                         cDataObjects,
                                                         ppiDataObjects,
                                                         fSpecialDataObject,
                                                         lSpecialDataObject,
                                                         uIDItem,
                                                         punkParam);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_PopupMenuClick_Stub
(
    IExtendControlbarRemote __RPC_FAR *This,
    long                               cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR   ppiDataObjects[  ],
    BOOL                               fSpecialDataObject,
    long                               lSpecialDataObject,
    UINT                               uIDItem,
    IUnknown __RPC_FAR                *punkParam
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->PopupMenuClick(This, piDataObject, uIDItem, punkParam);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Proxy
( 
    IComponentData  *This,
    LPUNKNOWN        pUnknown
)
{
    HRESULT hr = S_OK;

    // Tell the object it is remote and give the path to mmc.exe

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Now pass on the Initiaize call normally. Using this order allows a snap-in
    // to know it is remote prior to its IComponentData::Initialize in case it
    // needs that information up front.

    hr = IComponentData_RemInitialize_Proxy(This, pUnknown);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Stub
( 
    IComponentData *This,
    LPUNKNOWN       pUnknown
)
{
    return This->lpVtbl->Initialize(This, pUnknown);
}



HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Proxy
( 
    IComponentData *This,
    LPCOMPONENT    *ppComponent
)
{
    HRESULT hr = S_OK;

    // Tell the object it is remote and give the path to mmc.exe

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Now pass on the CreateComponent call normally. Using this order allows a
    // snap-in to know it is remote prior to its
    // IComponentData::CreateComponent in case it needs that information up
    // front.

    // We do this in IComponentData::Initialize and
    // IComponentData::CreateComponent. Most cases will use Initialize but in
    // MMC 1.1 a taskpad extension does not receive IComponentData::Initialize.
    // MMC only calls IComponentData::CreateComponent. As a taskpad extension
    // may need to resolve a res:// URL to use the mmc.exe path we need to do
    // it here as well.

    hr = IComponentData_RemCreateComponent_Proxy(This, ppComponent);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Stub
( 
    IComponentData *This,
    LPCOMPONENT    *ppComponent
)
{
    return This->lpVtbl->CreateComponent(This, ppComponent);
}






HRESULT STDMETHODCALLTYPE IComponentData_Notify_Proxy
( 
    IComponentData __RPC_FAR *This,
    LPDATAOBJECT              piDataObject,
    MMC_NOTIFY_TYPE           event,
    LPARAM                    arg,
    LPARAM                    param
)
{
    BOOL fSpecialDataObject = FALSE;
    long lSpecialDataObject = 0;

    ICDNotifyParam ParamUnion;
    ZeroMemory(&ParamUnion, sizeof(ParamUnion));

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    ParamUnion.value = param;
    return IComponentData_RemNotify_Proxy(This, piDataObject,
                                          fSpecialDataObject,
                                          lSpecialDataObject,
                                          event, arg, &ParamUnion);
}


HRESULT STDMETHODCALLTYPE IComponentData_Notify_Stub
( 
    IComponentData __RPC_FAR *This,
    LPDATAOBJECT              piDataObject,
    BOOL                      fSpecialDataObject,
    long                      lSpecialDataObject,
    MMC_NOTIFY_TYPE           event,
    LPARAM                    arg,
    ICDNotifyParam           *pParamUnion
)
{
    if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    return This->lpVtbl->Notify(This, piDataObject,
                                event, arg, pParamUnion->value);
}


HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Proxy
( 
    IComponentData __RPC_FAR *This,
    IDataObject              *piDataObjectA,
    IDataObject              *piDataObjectB
)
{
    HRESULT       hr = S_OK;

    BOOL          fIsMultiSelectA = FALSE;
    long          cDataObjectsA = 1L;
    IDataObject **ppiDataObjectsA = NULL;
    BOOL          fSpecialDataObjectA = FALSE;
    long          lSpecialDataObjectA = 0;

    BOOL          fIsMultiSelectB = FALSE;
    long          cDataObjectsB = 1L;
    IDataObject **ppiDataObjectsB = NULL;
    BOOL          fSpecialDataObjectB = FALSE;
    long          lSpecialDataObjectB = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObjectA, &fSpecialDataObjectA, &lSpecialDataObjectA);

    CheckForSpecialDataObjects(&piDataObjectB, &fSpecialDataObjectB, &lSpecialDataObjectB);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObjectA)
    {
        hr = IsMultiSelect(piDataObjectA, &fIsMultiSelectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (!fSpecialDataObjectB)
    {
        hr = IsMultiSelect(piDataObjectB, &fIsMultiSelectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelectA)
    {
        hr = InterpretMultiSelect(piDataObjectA, &cDataObjectsA, &ppiDataObjectsA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsA = &piDataObjectA;
    }

    if (fIsMultiSelectB)
    {
        hr = InterpretMultiSelect(piDataObjectB, &cDataObjectsB, &ppiDataObjectsB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsB = &piDataObjectB;
    }

    hr = IComponentData_RemCompareObjects_Proxy(This,
                                                cDataObjectsA,
                                                ppiDataObjectsA,
                                                fSpecialDataObjectA,
                                                lSpecialDataObjectA,

                                                cDataObjectsB,
                                                ppiDataObjectsB,
                                                fSpecialDataObjectB,
                                                lSpecialDataObjectB);
Cleanup:
    if ( fIsMultiSelectA && (NULL != ppiDataObjectsA) )
    {
        (void)GlobalFree(ppiDataObjectsA);
    }
    if ( fIsMultiSelectB && (NULL != ppiDataObjectsB) )
    {
        (void)GlobalFree(ppiDataObjectsB);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Stub
( 
    IComponentData __RPC_FAR         *This,

    long                              cDataObjectsA,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsA[  ],
    BOOL                              fSpecialDataObjectA,
    long                              lSpecialDataObjectA,

    long                              cDataObjectsB,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsB[  ],
    BOOL                              fSpecialDataObjectB,
    long                              lSpecialDataObjectB
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObjectA = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectA = NULL;
    IDataObject *piDataObjectB = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectB = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjectsA > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsA, cDataObjectsA,
                                      &piMultiSelDataObjectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectA = piMultiSelDataObjectA;
    }
    else if (fSpecialDataObjectA)
    {
        piDataObjectA = (IDataObject *)lSpecialDataObjectA;
    }
    else
    {
        piDataObjectA = ppiDataObjectsA[0];
    }

    if (cDataObjectsB > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsB, cDataObjectsB,
                                      &piMultiSelDataObjectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectB = piMultiSelDataObjectB;
    }
    else if (fSpecialDataObjectB)
    {
        piDataObjectB = (IDataObject *)lSpecialDataObjectB;
    }
    else
    {
        piDataObjectB = ppiDataObjectsB[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CompareObjects(This, piDataObjectA, piDataObjectB);

Cleanup:
    if (NULL != piMultiSelDataObjectA)
    {
        piMultiSelDataObjectA->lpVtbl->Release(piMultiSelDataObjectA);
    }
    if (NULL != piMultiSelDataObjectB)
    {
        piMultiSelDataObjectB->lpVtbl->Release(piMultiSelDataObjectB);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_Notify_Proxy
( 
    IComponent __RPC_FAR *This,
    LPDATAOBJECT          piDataObject,
    MMC_NOTIFY_TYPE       event,
    LPARAM                arg,
    LPARAM                param
)
{
    ICNotifyArg      ArgUnion;
    ICNotifyParam    ParamUnion;
    ICOutParam      *pOutParam = NULL;
    HRESULT          hr = S_OK;
    BOOL             fIsMultiSelect = FALSE;
    long             cDataObjects = 1L;
    IDataObject    **ppiDataObjects = NULL;
    BOOL             fSpecialDataObject = FALSE;
    long             lSpecialDataObject = 0;

    ZeroMemory(&ArgUnion, sizeof(ArgUnion));
    ZeroMemory(&ParamUnion, sizeof(ParamUnion));

    // Switch any potential multiselect data objects with arg/param so that
    // piDataObject always contains the potential multiselect.

    switch (event)
    {
        case MMCN_QUERY_PASTE:
            ArgUnion.pidoQueryPasteTarget = piDataObject;
            piDataObject = (IDataObject *)arg;
            ParamUnion.value = param;
            break;

        case MMCN_PASTE:
            ArgUnion.pidoPasteTarget = piDataObject;
            piDataObject = (IDataObject *)arg;
            // Pass through param as an LPARAM rather than the IDataObject **
            // it really is. This is just to let the stub know whether it is
            // a copy or a move. If it is a move the CUTORMOVE IDataObject will
            // be in the ICOutParam returned from the stub.
            ParamUnion.value = param;
            break;

        case MMCN_RESTORE_VIEW:
            ArgUnion.value = arg;
            // Don't pass param because it is a BOOL * that will not be
            // marshaled. The BOOL will be received in the ICOutParam returned
            // from the stub.
            break;
            
        default:
            ArgUnion.value = arg;
            ParamUnion.value = param;
    }

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IComponent_RemNotify_Proxy(This,
                                    cDataObjects, ppiDataObjects,
                                    fSpecialDataObject, lSpecialDataObject,
                                    event, &ArgUnion, &ParamUnion, &pOutParam);
Cleanup:
    if (NULL != pOutParam)
    {
        if (MMCN_PASTE == event)
        {
            *((IDataObject **)param) = pOutParam->pidoCutOrMove;
        }
        else if (MMCN_RESTORE_VIEW == event)
        {
            *((BOOL *)param) = pOutParam->fRestoreHandled;
        }
        CoTaskMemFree(pOutParam);
    }

    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_Notify_Stub
( 
    IComponent __RPC_FAR  *This,
    long                   cDataObjects,
    IDataObject          **ppiDataObjects,
    BOOL                   fSpecialDataObject,
    long                   lSpecialDataObject,
    MMC_NOTIFY_TYPE        event,
    ICNotifyArg           *pArgUnion,
    ICNotifyParam         *pParamUnion,
    ICOutParam           **ppOutParam
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;
    LPARAM       Arg = 0;
    LPARAM       Param = 0;

    *ppOutParam = (ICOutParam *)CoTaskMemAlloc(sizeof(ICOutParam));
    if (NULL == *ppOutParam)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ZeroMemory(*ppOutParam, sizeof(ICOutParam));

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // If the event required swaping Arg and IDataObject then swap it back
    // before calling into the object. For MMCN_QUERY_PASTE and
    // MMCN_RESTORE_VIEW we need to make Param contain the out pointer.
    
    switch (event)
    {
        case MMCN_PASTE:
            Arg = (LPARAM)piDataObject;
            piDataObject = pArgUnion->pidoPasteTarget;
            if (0 == pParamUnion->value)
            {
                // This is a copy, pass zero in Param so snap-in will know that
                Param = 0;
            }
            else
            {
                // This is a move. Pass the address of the IDataObject in
                // the ICOutParam that we will return to the proxy.
                Param = (LPARAM)&((*ppOutParam)->pidoCutOrMove);
            }
            break;

        case MMCN_QUERY_PASTE:
            Arg = (LPARAM)piDataObject;
            piDataObject = pArgUnion->pidoQueryPasteTarget;
            Param = pParamUnion->value;
            break;

        case MMCN_RESTORE_VIEW:
            Arg = pArgUnion->value;
            Param = (LPARAM)&((*ppOutParam)->fRestoreHandled);
            break;

        default:
            Arg = pArgUnion->value;
            Param = pParamUnion->value;
            break;
    }

    hr = This->lpVtbl->Notify(This, piDataObject, event, Arg, Param);

Cleanup:
    if (FAILED(hr))
    {
        if (NULL != *ppOutParam)
        {
            CoTaskMemFree(*ppOutParam);
            *ppOutParam = NULL;
        }
    }
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Proxy
( 
    IComponent __RPC_FAR *This,
    IDataObject          *piDataObjectA,
    IDataObject          *piDataObjectB
)
{
    HRESULT       hr = S_OK;

    BOOL          fIsMultiSelectA = FALSE;
    long          cDataObjectsA = 1L;
    IDataObject **ppiDataObjectsA = NULL;
    BOOL          fSpecialDataObjectA = FALSE;
    long          lSpecialDataObjectA = 0;

    BOOL          fIsMultiSelectB = FALSE;
    long          cDataObjectsB = 1L;
    IDataObject **ppiDataObjectsB = NULL;
    BOOL          fSpecialDataObjectB = FALSE;
    long          lSpecialDataObjectB = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObjectA, &fSpecialDataObjectA, &lSpecialDataObjectA);

    CheckForSpecialDataObjects(&piDataObjectB, &fSpecialDataObjectB, &lSpecialDataObjectB);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObjectA)
    {
        hr = IsMultiSelect(piDataObjectA, &fIsMultiSelectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (!fSpecialDataObjectB)
    {
        hr = IsMultiSelect(piDataObjectB, &fIsMultiSelectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelectA)
    {
        hr = InterpretMultiSelect(piDataObjectA, &cDataObjectsA, &ppiDataObjectsA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsA = &piDataObjectA;
    }

    if (fIsMultiSelectB)
    {
        hr = InterpretMultiSelect(piDataObjectB, &cDataObjectsB, &ppiDataObjectsB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsB = &piDataObjectB;
    }

    hr = IComponent_RemCompareObjects_Proxy(This,
                                            cDataObjectsA,
                                            ppiDataObjectsA,
                                            fSpecialDataObjectA,
                                            lSpecialDataObjectA,

                                            cDataObjectsB,
                                            ppiDataObjectsB,
                                            fSpecialDataObjectB,
                                            lSpecialDataObjectB);
Cleanup:
    if ( fIsMultiSelectA && (NULL != ppiDataObjectsA) )
    {
        (void)GlobalFree(ppiDataObjectsA);
    }
    if ( fIsMultiSelectB && (NULL != ppiDataObjectsB) )
    {
        (void)GlobalFree(ppiDataObjectsB);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Stub
( 
    IComponent __RPC_FAR             *This,

    long                              cDataObjectsA,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsA[  ],
    BOOL                              fSpecialDataObjectA,
    long                              lSpecialDataObjectA,

    long                              cDataObjectsB,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsB[  ],
    BOOL                              fSpecialDataObjectB,
    long                              lSpecialDataObjectB
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObjectA = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectA = NULL;
    IDataObject *piDataObjectB = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectB = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjectsA > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsA, cDataObjectsA,
                                      &piMultiSelDataObjectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectA = piMultiSelDataObjectA;
    }
    else if (fSpecialDataObjectA)
    {
        piDataObjectA = (IDataObject *)lSpecialDataObjectA;
    }
    else
    {
        piDataObjectA = ppiDataObjectsA[0];
    }

    if (cDataObjectsB > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsB, cDataObjectsB,
                                      &piMultiSelDataObjectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectB = piMultiSelDataObjectB;
    }
    else if (fSpecialDataObjectB)
    {
        piDataObjectB = (IDataObject *)lSpecialDataObjectB;
    }
    else
    {
        piDataObjectB = ppiDataObjectsB[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CompareObjects(This, piDataObjectA, piDataObjectB);

Cleanup:
    if (NULL != piMultiSelDataObjectA)
    {
        piMultiSelDataObjectA->lpVtbl->Release(piMultiSelDataObjectA);
    }
    if (NULL != piMultiSelDataObjectB)
    {
        piMultiSelDataObjectB->lpVtbl->Release(piMultiSelDataObjectB);
    }
    return hr;
}

//=--------------------------------------------------------------------------=
//
//                      SCOPEDATAITEM Marshaling
//
//
//=--------------------------------------------------------------------------=
// Caveat: When returning a string in SCOPEDATAITEM MMC does not use a
// callee allocate/caller free strategy. When in-proc, the owner of the memory
// must insure that it stays alive for as long as the caller is expected to
// use it (e.g. scope item display name must remain valid for the life of the
// scope item). When out-of-proc, that returned string will be allocated by
// the proxy using CoTaskMemAlloc() and it will never be freed so there will
// be some leaks.
//=--------------------------------------------------------------------------=

static void SCOPEDATAITEM_TO_WIRE
(
    SCOPEDATAITEM      *psdi,
    WIRE_SCOPEDATAITEM *pwsdi
)
{
    pwsdi->mask = psdi->mask;
    pwsdi->nImage = psdi->nImage;
    pwsdi->nOpenImage = psdi->nOpenImage;
    pwsdi->nState = psdi->nState;
    pwsdi->cChildren = psdi->cChildren;
    pwsdi->lParam = psdi->lParam;
    pwsdi->relativeID = psdi->relativeID;
    pwsdi->ID = psdi->ID;

    if ( SDI_STR != (psdi->mask & SDI_STR) )
    {
        pwsdi->pwszDisplayName = NULL;
        pwsdi->fUsingCallbackForString = FALSE;
    }
    else if (MMC_CALLBACK == psdi->displayname)
    {
        pwsdi->pwszDisplayName = NULL;
        pwsdi->fUsingCallbackForString = TRUE;
    }
    else if (NULL == psdi->displayname)
    {
        pwsdi->pwszDisplayName = NULL;
        pwsdi->fUsingCallbackForString = FALSE;
    }
    else
    {
        // A string is being passed. Need to CoTaskMemAlloc() it so that
        // the MIDL generated stub can free it after transmission

        int cbString = (lstrlenW(psdi->displayname) + 1) * sizeof(psdi->displayname[0]);

        pwsdi->pwszDisplayName = (LPOLESTR)CoTaskMemAlloc(cbString);
        if (NULL == pwsdi->pwszDisplayName)
        {
            RpcRaiseException( E_OUTOFMEMORY );
        }
        else
        {
            memcpy(pwsdi->pwszDisplayName, psdi->displayname, cbString);
        }
        pwsdi->fUsingCallbackForString = FALSE;
    }
}


static void WIRE_TO_SCOPEDATAITEM
(
    WIRE_SCOPEDATAITEM *pwsdi,
    SCOPEDATAITEM      *psdi
)
{
    psdi->mask = pwsdi->mask;
    psdi->nImage = pwsdi->nImage;
    psdi->nOpenImage = pwsdi->nOpenImage;
    psdi->nState = pwsdi->nState;
    psdi->cChildren = pwsdi->cChildren;
    psdi->lParam = pwsdi->lParam;
    psdi->relativeID = pwsdi->relativeID;
    psdi->ID = pwsdi->ID;

    if ( SDI_STR != (psdi->mask & SDI_STR) )
    {
        psdi->displayname = NULL;
    }
    else if (pwsdi->fUsingCallbackForString)
    {
        psdi->displayname = MMC_CALLBACK;
    }
    else
    {
        psdi->displayname = pwsdi->pwszDisplayName;
    }
}


HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Proxy
( 
    IComponentData __RPC_FAR *This,
    SCOPEDATAITEM __RPC_FAR  *pScopeDataItem
)
{
    WIRE_SCOPEDATAITEM wsdi;
    HRESULT            hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from MMC to the snap-in. (MMC might not have initialized
    // the pointer).

    pScopeDataItem->displayname = NULL;

    SCOPEDATAITEM_TO_WIRE(pScopeDataItem, &wsdi);

    hr =  IComponentData_RemGetDisplayInfo_Proxy(This, &wsdi);
    WIRE_TO_SCOPEDATAITEM(&wsdi, pScopeDataItem);

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Stub
( 
    IComponentData __RPC_FAR     *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi
)
{
    SCOPEDATAITEM sdi;
    HRESULT       hr;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    hr = This->lpVtbl->GetDisplayInfo(This, &sdi);
    SCOPEDATAITEM_TO_WIRE(&sdi, pwsdi);

    return hr;
}



HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Proxy
( 
    IConsoleNameSpace __RPC_FAR *This,
    LPSCOPEDATAITEM              pItem
)
{
    WIRE_SCOPEDATAITEM  wsdi;
    HRESULT             hr;
    HSCOPEITEM          ItemID;

    SCOPEDATAITEM_TO_WIRE(pItem, &wsdi);
    hr = IConsoleNameSpace_RemInsertItem_Proxy(This, &wsdi, &ItemID);

    // The only returned field is the item ID so copy it from the wire
    // structure to the client structure

    pItem->ID = ItemID;

    return hr;
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Stub
( 
    IConsoleNameSpace __RPC_FAR  *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi,
    HSCOPEITEM __RPC_FAR         *pItemID
)
{
    SCOPEDATAITEM sdi;
    HRESULT       hr;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    hr = This->lpVtbl->InsertItem(This, &sdi);

    // The only returned field is the itemID.

    *pItemID = sdi.ID;
    return hr;
}

HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Proxy
( 
    IConsoleNameSpace __RPC_FAR *This,
    LPSCOPEDATAITEM              pItem
)
{
    WIRE_SCOPEDATAITEM wsdi;

    SCOPEDATAITEM_TO_WIRE(pItem, &wsdi);
    return IConsoleNameSpace_RemSetItem_Proxy(This, &wsdi);
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Stub
( 
    IConsoleNameSpace __RPC_FAR  *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi
)
{
    SCOPEDATAITEM sdi;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    return This->lpVtbl->SetItem(This, &sdi);
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Proxy
( 
    IConsoleNameSpace __RPC_FAR *This,
    LPSCOPEDATAITEM              pItem
)
{
    WIRE_SCOPEDATAITEM wsdi;
    HRESULT            hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from the snap-in to MMC. (It might not have be
    // initialized).

    pItem->displayname = NULL;

    SCOPEDATAITEM_TO_WIRE(pItem, &wsdi);
    hr = IConsoleNameSpace_RemGetItem_Proxy(This, &wsdi);
    WIRE_TO_SCOPEDATAITEM(&wsdi, pItem);
    return hr;
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Stub
( 
    IConsoleNameSpace __RPC_FAR  *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi
)
{
    SCOPEDATAITEM sdi;
    HRESULT       hr;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    hr = This->lpVtbl->GetItem(This, &sdi);
    SCOPEDATAITEM_TO_WIRE(&sdi, pwsdi);

    return hr;
}






//=--------------------------------------------------------------------------=
//
//                      RESULTDATAITEM Marshaling
//
//
//=--------------------------------------------------------------------------=
// Caveat: When returning a string in RESULTDATAITEM MMC does not use a
// callee allocate/caller free strategy. When in-proc, the owner of the memory
// must insure that it stays alive for as long as the caller is expected to
// use it (e.g. list item column data must remain valid for the life of the
// list item). When out-of-proc, that returned string will be allocated by
// the proxy using SysAllocString() and it will never be freed so there will
// be some leaks.
//=--------------------------------------------------------------------------=

static void RESULTDATAITEM_TO_WIRE
(
    RESULTDATAITEM      *prdi,
    WIRE_RESULTDATAITEM *pwrdi
)
{
    pwrdi->mask = prdi->mask;
    pwrdi->bScopeItem = prdi->bScopeItem;
    pwrdi->itemID = prdi->itemID;
    pwrdi->nIndex = prdi->nIndex;
    pwrdi->nCol = prdi->nCol;
    pwrdi->nImage = prdi->nImage;
    pwrdi->nState = prdi->nState;
    pwrdi->lParam = prdi->lParam;
    pwrdi->iIndent = prdi->iIndent;

    if ( RDI_STR != (prdi->mask & RDI_STR) )
    {
        pwrdi->str = NULL;
        pwrdi->fUsingCallbackForString = FALSE;
    }
    else if (MMC_CALLBACK == prdi->str)
    {
        pwrdi->str = NULL;
        pwrdi->fUsingCallbackForString = TRUE;
    }
    else if (NULL == prdi->str)
    {
        pwrdi->str = NULL;
        pwrdi->fUsingCallbackForString = FALSE;
    }
    else
    {
        // A string is being passed. Need to CoTaskMemAlloc() it so that
        // the MIDL generated stub can free it after transmission

        int cbString = (lstrlenW(prdi->str) + 1) * sizeof(prdi->str[0]);

        pwrdi->str = (LPOLESTR)CoTaskMemAlloc(cbString);
        if (NULL == pwrdi->str)
        {
            RpcRaiseException( E_OUTOFMEMORY );
        }
        else
        {
            memcpy(pwrdi->str, prdi->str, cbString);
        }
        pwrdi->fUsingCallbackForString = FALSE;
    }
}



static void WIRE_TO_RESULTDATAITEM
(
    WIRE_RESULTDATAITEM *pwrdi,
    RESULTDATAITEM      *prdi
)
{
    prdi->mask = pwrdi->mask;
    prdi->bScopeItem = pwrdi->bScopeItem;
    prdi->itemID = pwrdi->itemID;
    prdi->nIndex = pwrdi->nIndex;
    prdi->nCol = pwrdi->nCol;
    prdi->nImage = pwrdi->nImage;
    prdi->nState = pwrdi->nState;
    prdi->lParam = pwrdi->lParam;
    prdi->iIndent = pwrdi->iIndent;

    if ( RDI_STR != (prdi->mask & RDI_STR) )
    {
        prdi->str = NULL;
    }
    else if (pwrdi->fUsingCallbackForString)
    {
        prdi->str = MMC_CALLBACK;
    }
    else
    {
        prdi->str = pwrdi->str;
    }
}

 
HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Proxy
( 
    IComponent __RPC_FAR     *This,
    RESULTDATAITEM __RPC_FAR *pResultDataItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from MMC to the snap-in. (MMC might not have initialized
    // the pointer).

    pResultDataItem->str = NULL;

    RESULTDATAITEM_TO_WIRE(pResultDataItem, &wrdi);

    hr =  IComponent_RemGetDisplayInfo_Proxy(This, &wrdi);
    WIRE_TO_RESULTDATAITEM(&wrdi, pResultDataItem);

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Stub
( 
    IComponent __RPC_FAR          *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->GetDisplayInfo(This, &rdi);
    RESULTDATAITEM_TO_WIRE(&rdi, pwrdi);

    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;
    HRESULTITEM         ItemID;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    hr = IResultData_RemInsertItem_Proxy(This, &wrdi, &ItemID);

    // The only returned field is the itemID so copy it from the wire
    // structure to the client structure

    pItem->itemID = ItemID;

    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi,
    HRESULTITEM __RPC_FAR         *pItemID
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->InsertItem(This, &rdi);

    // The only returned field is the itemID.

    *pItemID = rdi.itemID;
    return hr;
}

HRESULT STDMETHODCALLTYPE IResultData_SetItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    return IResultData_RemSetItem_Proxy(This, &wrdi);
}


HRESULT STDMETHODCALLTYPE IResultData_SetItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    return This->lpVtbl->SetItem(This, &rdi);
}

HRESULT STDMETHODCALLTYPE IResultData_GetItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from the snap-in to MMC. (It might not have be
    // initialized).

    pItem->str = NULL;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    hr = IResultData_RemGetItem_Proxy(This, &wrdi);
    WIRE_TO_RESULTDATAITEM(&wrdi, pItem);
    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_GetItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->GetItem(This, &rdi);
    RESULTDATAITEM_TO_WIRE(&rdi, pwrdi);

    return hr;
}

HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from the snap-in to MMC. (It might not have be
    // initialized).

    pItem->str = NULL;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    hr = IResultData_RemGetNextItem_Proxy(This, &wrdi);
    WIRE_TO_RESULTDATAITEM(&wrdi, pItem);
    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->GetNextItem(This, &rdi);
    RESULTDATAITEM_TO_WIRE(&rdi, pwrdi);
    return hr;
}


//=--------------------------------------------------------------------------=
//
//                              HICON Marshaling
//
//=--------------------------------------------------------------------------=
// In wtypes.idl HICON is defined with the wire_marshal attribute with its
// 'on-the-wire' type as a pointer to a RemotableHandle. RemotableHandle is
// defined in wtypes.idl as
// 
// typedef union _RemotableHandle switch( long fContext ) u
// {
//     case WDT_INPROC_CALL:   long   hInproc;
//     case WDT_REMOTE_CALL:   long   hRemote;
// } RemotableHandle;
// 
// A wire_marshal type must supply routines to size, marhsal, unmarshal, and
// free marshaling data. Those routines are in ole32.dll but someone forgot to
// export them. (ole32 also has routines to marshal bitmaps, hwnds, etc. that
// are all exported). The code has been plagiarized here from ole32. The source
// is in \\savik\cairo\src\ole32\oleprx32\proxy\transmit.cxx with some macros in
// transmit.h in that same directory.
//
//=--------------------------------------------------------------------------=


//
// The following defines and macros are from transmit.h. Note that
// USER_CALL_CTXT_MASK is from rpcndr.h and WDT_REMOTE_CALL is from wtypes.idl.
//

#define ALIGN( pStuff, cAlign ) \
        pStuff = (unsigned char *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
                                    Length = (((Length) + (cAlign)) & ~ (cAlign))

#define PULONG_LV_CAST   *(unsigned long __RPC_FAR * __RPC_FAR *)&


#define DIFFERENT_MACHINE_CALL( Flags)  \
                          (USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE)

#define WDT_HANDLE_MARKER      WDT_INPROC_CALL




//=--------------------------------------------------------------------------=
// HICON_UserSize
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR *pFlags       [in] data format & context (see below)
//  unsigned long            StartingSize [in] current buffer size
//  HICON __RPC_FAR         *hIcon        [in] HICON to be marshaled
//    
//
// Flags Layout
// ============
//
//----------------------------------------------------------------------
// Bits     Flag                            Value
//----------------------------------------------------------------------
// 31-24    Floating-point representation   0 = IEEE
//                                          1 = VAX
//                                          2 = Cray
//                                          3 = IBM 
//----------------------------------------------------------------------
// 23-20    Integer and floating-point byte
//          order                           0 = Big-endian
//                                          1 = Little-endian 
//----------------------------------------------------------------------
// 19-16    Character representation        0 = ASCII
//                                          1 = EBCDIC 
//----------------------------------------------------------------------
// 15-0     Marshaling context flag         0 = MSHCTX_LOCAL
//                                          1 = MSHCTX_NOSHAREDMEM
//                                          2 = MSHCTX_DIFFERENTMSCHINE
//                                          3 = MSHCTX_INPROC 
//----------------------------------------------------------------------
//
// Output:
//      New buffer size after adding amount needed for HICON marshaled data
//
// Notes:
//
// Called from MIDL generated proxy to determine buffer size needed for 
// marhaled data.
//

unsigned long __RPC_USER HICON_UserSize
(
    unsigned long __RPC_FAR *pFlags,
    unsigned long            StartingSize,
    HICON __RPC_FAR         *hIcon
)
{
    if (NULL == hIcon)
    {
        return StartingSize;
    }

    // If marshaling context is to a different machine then we don't support
    // that.

    if ( DIFFERENT_MACHINE_CALL(*pFlags) )
    {
        RpcRaiseException( RPC_S_INVALID_TAG );
    }

    // Make sure that our data will fall at a long boundary

    LENGTH_ALIGN( StartingSize, 3 );

    //Add the length
    
    return StartingSize + 8;
}


//=--------------------------------------------------------------------------=
// HICON_UserMarhsal
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR  *pFlags  [in] data format & context (see above)
//  unsigned char  __RPC_FAR *pBuffer [in] current buffer size
//  HICON __RPC_FAR          *hIcon   [in] HICON to be marshaled
//    
//
// Output:
//      Pointer to buffer location following HICON's marshaling data
//
// Notes:
//
// Called from MIDL generated proxy to marshal an HICON
//

unsigned char __RPC_FAR * __RPC_USER HICON_UserMarshal
(
    unsigned long __RPC_FAR  *pFlags,
    unsigned char  __RPC_FAR *pBuffer,
    HICON __RPC_FAR          *hIcon
)
{
    if (NULL == hIcon)
    {
        return pBuffer;
    }

    if ( DIFFERENT_MACHINE_CALL(*pFlags) )
    {
        RpcRaiseException( RPC_S_INVALID_TAG );
    }

    // Make sure that our data will fall at a long boundary

    ALIGN( pBuffer, 3 );

    *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
    *( PULONG_LV_CAST pBuffer)++ = *((long *)hIcon);

    return pBuffer;
}

//=--------------------------------------------------------------------------=
// HICON_UserUnmarhsal
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR  *pFlags  [in] data format & context (see above)
//  unsigned char  __RPC_FAR *pBuffer [in] current buffer size
//  HICON __RPC_FAR          *hIcon   [in] HICON to be marshaled
//    
//
// Output:
//      Pointer to buffer location following HICON's marshaling data
//
// Notes:
//
// Called from MIDL generated stub to unmarshal an HICON
//

unsigned char __RPC_FAR *__RPC_USER HICON_UserUnmarshal
(
    unsigned long __RPC_FAR  *pFlags,
    unsigned char  __RPC_FAR *pBuffer,
    HICON __RPC_FAR          *hIcon
)
{
    unsigned long HandleMarker;

    ALIGN( pBuffer, 3 );

    HandleMarker = *( PULONG_LV_CAST pBuffer)++;

    if ( HandleMarker == WDT_HANDLE_MARKER )
        *((long *)hIcon) = *( PULONG_LV_CAST pBuffer)++;
    else
        RpcRaiseException( RPC_S_INVALID_TAG );

    return pBuffer;
}



//=--------------------------------------------------------------------------=
// HICON_UserUnmarhsal
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR  *pFlags  [in] data format & context (see above)
//  HICON __RPC_FAR          *hIcon   [in] HICON that was unmarshaled
//    
//
// Output:
//      None
//
// Notes:
//
// Called from MIDL generated stub to free any associated marshaling data
// allocated during unmarshaling for embedded pointers. Not used for HICON.
//

void __RPC_USER HICON_UserFree
(
    unsigned long __RPC_FAR *pFlags,
    HICON __RPC_FAR         *hIcon
)
{
}



//=--------------------------------------------------------------------------=
//
//                          IImageList Marshaling
//
//
//=--------------------------------------------------------------------------=
// These methods needed call_as because the HICON and HBITMAP parameters are
// specified as long pointers in the original IDL.
//=--------------------------------------------------------------------------=

HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Proxy
( 
    IImageList __RPC_FAR *This,
    LONG_PTR __RPC_FAR   *pIcon,
    long                  nLoc
)
{
    return IImageList_RemImageListSetIcon_Proxy(This, (HICON)pIcon, nLoc);
}


HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Stub
( 
    IImageList __RPC_FAR *This,
    HICON                 hIcon,
    long                  nLoc
)
{
    return This->lpVtbl->ImageListSetIcon(This, (LONG_PTR __RPC_FAR*)hIcon, nLoc);
}

HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Proxy
( 
    IImageList __RPC_FAR *This,
    LONG_PTR __RPC_FAR   *pBMapSm,
    LONG_PTR __RPC_FAR   *pBMapLg,
    long                  nStartLoc,
    COLORREF              cMask
)
{
    return IImageList_RemImageListSetStrip_Proxy(This,
                                                 (HBITMAP)pBMapSm,
                                                 (HBITMAP)pBMapLg,
                                                 nStartLoc,
                                                 cMask);
}


HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Stub
( 
    IImageList __RPC_FAR *This,
    HBITMAP               hbmSmall,
    HBITMAP               hbmLarge,
    long                  nStartLoc,
    COLORREF              cMask
)
{
    return This->lpVtbl->ImageListSetStrip(This,
                                           (LONG_PTR __RPC_FAR*)hbmSmall,
                                           (LONG_PTR __RPC_FAR*)hbmLarge,
                                           nStartLoc,
                                           cMask);
}

HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Proxy
( 
    IExtendPropertySheet __RPC_FAR *This,
    LPPROPERTYSHEETCALLBACK         lpProvider,
    LONG_PTR                        handle,
    LPDATAOBJECT                    lpIDataObject
)
{
    HRESULT                      hr = S_OK;
    WIRE_PROPERTYPAGES          *pPages = NULL;
    WIRE_PROPERTYPAGE           *pPage = NULL;
    ULONG                        i = 0;
    ULONG                        j = 0;
    IExtendPropertySheetRemote  *piExtendPropertySheetRemote = NULL;
    IRemotePropertySheetManager *piRemotePropertySheetManager = NULL;

    // Make sure the snap-in knows we are remoted. We do this here because
    // this is the first opportunity for the proxy to inform a property page
    // extension that it is remote and pass it data such as the MMC.exe path
    // and the MMC command line.

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Call the IExtendPropertySheetRemote method which will return a filled in
    // WIRE_PROPERTYPAGES from the remoted snap-in.

    hr = This->lpVtbl->QueryInterface(This, &IID_IExtendPropertySheetRemote,
                                      (void **)&piExtendPropertySheetRemote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = piExtendPropertySheetRemote->lpVtbl->CreatePropertyPageDefs(
                            piExtendPropertySheetRemote, lpIDataObject, &pPages);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If there are pages (snap-in might not have added any) then
    // CoCreateInstance the remote property sheet manager using the clsid
    // returned in WIRE_PROPERTYPAGES. This object will be created in-proc here
    // on the MMC side.

    if (0 == pPages->cPages)
    {
        goto Cleanup;
    }

    hr = CoCreateInstance(&pPages->clsidRemotePropertySheetManager,
                          NULL, // no aggregation,
                          CLSCTX_INPROC_SERVER,
                          &IID_IRemotePropertySheetManager,
                          (void **)&piRemotePropertySheetManager);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Pass the remote property sheet manager the WIRE_PROPERTYPAGES and let it
    // actually create the property pages and add them to the sheet here on the
    // MMC side.

    hr = piRemotePropertySheetManager->lpVtbl->CreateRemotePages(
                                                    piRemotePropertySheetManager,
                                                    lpProvider,
                                                    handle,
                                                    lpIDataObject,
                                                    pPages);
Cleanup:
    if (NULL != piRemotePropertySheetManager)
    {
        piRemotePropertySheetManager->lpVtbl->Release(piRemotePropertySheetManager);
    }

    if (NULL != piExtendPropertySheetRemote)
    {
        piExtendPropertySheetRemote->lpVtbl->Release(piExtendPropertySheetRemote);
    }

    // Free the WIRE_PROPERTYPAGES and all of its contents.

    if (NULL != pPages)
    {
        // Release the object and free the title for each individual page
        
        for (i = 0, pPage = &pPages->aPages[0]; i < pPages->cPages; i++, pPage++)
        {
            if (NULL != pPage->apunkObjects)
            {
                for (j = 0; j < pPage->cObjects; j++)
                {
                    if (NULL != pPage->apunkObjects[j])
                    {
                        pPage->apunkObjects[j]->lpVtbl->Release(pPage->apunkObjects[j]);
                    }
                }
                CoTaskMemFree(pPage->apunkObjects);
            }
            if (NULL != pPage->pwszTitle)
            {
                CoTaskMemFree(pPage->pwszTitle);
            }
        }

        // Free the ProgID prefix

        if (NULL != pPages->pwszProgIDStart)
        {
            CoTaskMemFree(pPages->pwszProgIDStart);
        }

        // Free all of the snap-in's property page info

        if (NULL != pPages->pPageInfos)
        {
            for (i = 0; i < pPages->pPageInfos->cPages; i++)
            {
                if (NULL != pPages->pPageInfos->aPageInfo[i].pwszTitle)
                {
                    CoTaskMemFree(pPages->pPageInfos->aPageInfo[i].pwszTitle);
                }
                if (NULL != pPages->pPageInfos->aPageInfo[i].pwszProgID)
                {
                    CoTaskMemFree(pPages->pPageInfos->aPageInfo[i].pwszProgID);
                }
            }
            CoTaskMemFree(pPages->pPageInfos);
        }

        // Free all of the objects associated with the sheet

        if (NULL != pPages->apunkObjects)
        {
            for (i = 0; i < pPages->cObjects; i++)
            {
                if (NULL != pPages->apunkObjects[i])
                {
                    pPages->apunkObjects[i]->lpVtbl->Release(pPages->apunkObjects[i]);
                }
            }
            CoTaskMemFree(pPages->apunkObjects);
        }


        // Release the extra object and the WIRE_PROPERTYPAGES struct itself

        if (NULL != pPages->punkExtra)
        {
            pPages->punkExtra->lpVtbl->Release(pPages->punkExtra);
        }
        CoTaskMemFree(pPages);
    }

    return hr;
}


//=--------------------------------------------------------------------------=
// IExtendPropertySheet_CreatePropertyPages_Stub
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IExtendPropertySheet __RPC_FAR *This [in] this pointer
//
// Output:
//
// Notes:
//
// This stub is never called because
// IExtendPropertySheet_CreatePropertyPages_Proxy() (see above) reroutes the
// call to IExtendPropertySheetRemote::CreatePropertyPageDefs().
//

HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Stub
( 
    IExtendPropertySheet __RPC_FAR *This
)
{
    return S_OK;
}



HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Proxy
( 
    IExtendPropertySheet __RPC_FAR *This,
    IDataObject                    *piDataObject
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendPropertySheet_RemQueryPagesFor_Proxy(This,
                                                     cDataObjects,
                                                     ppiDataObjects,
                                                     fSpecialDataObject,
                                                     lSpecialDataObject);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Stub
( 
    IExtendPropertySheet __RPC_FAR   *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->QueryPagesFor(This, piDataObject);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendPropertySheet2_GetWatermarks_Proxy
( 
    IExtendPropertySheet2 __RPC_FAR *This,
    IDataObject                     *piDataObject,
    HBITMAP                         *lphWatermark,
    HBITMAP                         *lphHeader,
    HPALETTE                        *lphPalette,
    BOOL                            *bStretch
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendPropertySheet2_RemGetWatermarks_Proxy(This,
                                                      cDataObjects,
                                                      ppiDataObjects,
                                                      fSpecialDataObject,
                                                      lSpecialDataObject,
                                                      lphWatermark,
                                                      lphHeader,
                                                      lphPalette,
                                                      bStretch);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheet2_GetWatermarks_Stub
( 
    IExtendPropertySheet2 __RPC_FAR   *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    HBITMAP                          *lphWatermark,
    HBITMAP                          *lphHeader,
    HPALETTE                         *lphPalette,
    BOOL                             *bStretch
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->GetWatermarks(This,
                                     piDataObject,
                                     lphWatermark,
                                     lphHeader,
                                     lphPalette,
                                     bStretch);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheetRemote_CreatePropertyPageDefs_Proxy
( 
    IExtendPropertySheetRemote __RPC_FAR  *This,
    IDataObject                           *piDataObject,
    WIRE_PROPERTYPAGES                   **ppPages
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendPropertySheetRemote_RemCreatePropertyPageDefs_Proxy(
                                                             This,
                                                             cDataObjects,
                                                             ppiDataObjects,
                                                             fSpecialDataObject,
                                                             lSpecialDataObject,
                                                             ppPages);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheetRemote_CreatePropertyPageDefs_Stub
( 
    IExtendPropertySheetRemote __RPC_FAR  *This,
    long                                   cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR       ppiDataObjects[  ],
    BOOL                                   fSpecialDataObject,
    long                                   lSpecialDataObject,
    WIRE_PROPERTYPAGES                   **ppPages
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CreatePropertyPageDefs(This, piDataObject, ppPages);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}



HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Proxy
( 
    IPropertySheetProvider __RPC_FAR *This,
    LPCWSTR                           title,
    boolean                           type,
    MMC_COOKIE                        cookie,
    IDataObject                      *piDataObject,
    DWORD                             dwOptions
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IPropertySheetProvider_RemCreatePropertySheet_Proxy(This,
                                                             title,
                                                             type,
                                                             cookie,
                                                             cDataObjects,
                                                             ppiDataObjects,
                                                             fSpecialDataObject,
                                                             lSpecialDataObject,
                                                             dwOptions);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Stub
( 
    IPropertySheetProvider __RPC_FAR *This,
    LPCWSTR                           title,
    boolean                           type,
    MMC_COOKIE                        cookie,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    DWORD                             dwOptions
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CreatePropertySheet(This, title, type, cookie, piDataObject, dwOptions);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}



HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Proxy
( 
    IPropertySheetProvider __RPC_FAR *This,
    MMC_COOKIE                        cookie,
    IComponent                       *piComponent,
    IDataObject                      *piDataObject
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IPropertySheetProvider_RemFindPropertySheet_Proxy(This,
                                                           cookie,
                                                           piComponent,
                                                           cDataObjects,
                                                           ppiDataObjects,
                                                           fSpecialDataObject,
                                                           lSpecialDataObject);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Stub
( 
    IPropertySheetProvider __RPC_FAR *This,
    MMC_COOKIE                        cookie,
    IComponent                       *piComponent,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->FindPropertySheet(This, cookie, piComponent, piDataObject);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}







HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Proxy
( 
    IExtendContextMenu __RPC_FAR *This,
    LPDATAOBJECT                  piDataObject,
    LPCONTEXTMENUCALLBACK         piCallback,
    long __RPC_FAR               *pInsertionAllowed
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Make sure the snap-in knows we are remoted. We do this here because
    // this is the first opportunity for the proxy to inform a context menu
    // extension that it is remote.

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendContextMenu_RemAddMenuItems_Proxy(This,
                                                  cDataObjects,
                                                  ppiDataObjects,
                                                  fSpecialDataObject,
                                                  lSpecialDataObject,
                                                  piCallback,
                                                  pInsertionAllowed);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Stub
( 
    IExtendContextMenu __RPC_FAR     *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    LPCONTEXTMENUCALLBACK             piCallback,
    long __RPC_FAR                   *pInsertionAllowed
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->AddMenuItems(This, piDataObject,
                                    piCallback, pInsertionAllowed);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Proxy
( 
    IExtendContextMenu __RPC_FAR *This,
    long                          lCommandID,
    LPDATAOBJECT                  piDataObject
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendContextMenu_RemCommand_Proxy(This,
                                             cDataObjects,
                                             ppiDataObjects,
                                             fSpecialDataObject,
                                             lSpecialDataObject,
                                             lCommandID);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Stub
( 
    IExtendContextMenu __RPC_FAR     *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    long                              lCommandID
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->Command(This, lCommandID, piDataObject);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}



HRESULT STDMETHODCALLTYPE IColumnData_GetColumnConfigData_Proxy
( 
    IColumnData __RPC_FAR                    *This,
    SColumnSetID __RPC_FAR                   *pColID,
    MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData
)
{
    HRESULT              hr = S_OK;
    size_t               cbColData = 0;
    MMC_COLUMN_SET_DATA *pColSetData = NULL;

    // Call the proxy and get the returned data from MMC

    hr = IColumnData_RemGetColumnConfigData_Proxy(This, pColID, ppColSetData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSetData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSetData)->pColData)
    {
        goto Cleanup;
    }

    // At this point the MIDL-generated proxy has returned an MMC_COLUMN_SET_DATA
    // in which the embedded pointer pColData points to a separate block of
    // memory which must be freed independently. The snap-in thinks that
    // pColData points into the same block of memory so it will only call
    // CoTaskMemFree for the MMC_COLUMN_SET_DATA. We need to allocate a new single
    // block in the format the snap-in is expecting and free the memory returned
    // from the proxy.

    cbColData = sizeof(MMC_COLUMN_DATA) * (*ppColSetData)->nNumCols;

    pColSetData = (MMC_COLUMN_SET_DATA *)CoTaskMemAlloc(
                                        sizeof(MMC_COLUMN_SET_DATA) + cbColData);
    
    if (NULL == pColSetData)
    {
        CoTaskMemFree((*ppColSetData)->pColData);
        CoTaskMemFree(*ppColSetData);
        *ppColSetData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the column set data

        memcpy(pColSetData, (*ppColSetData), sizeof(MMC_COLUMN_SET_DATA));

        // Set the embedded pointer to point immediately following the
        // MMC_COLUMN_SET_DATA
        
        pColSetData->pColData = (MMC_COLUMN_DATA *)(pColSetData + 1);

        // Copy the column data

        memcpy(pColSetData->pColData, (*ppColSetData)->pColData, cbColData);

        // Free the data returned from the proxy
        
        CoTaskMemFree((*ppColSetData)->pColData);
        CoTaskMemFree(*ppColSetData);

        // Return the new single block pointer to the snap-in
        
        *ppColSetData = pColSetData;
    }

Cleanup:
    return hr;
}


HRESULT STDMETHODCALLTYPE IColumnData_GetColumnConfigData_Stub
( 
    IColumnData __RPC_FAR                    *This,
    SColumnSetID __RPC_FAR                   *pColID,
    MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData
)
{
    HRESULT          hr = S_OK;
    size_t           cbColData = 0;
    MMC_COLUMN_DATA *pColData = NULL;

    // Call into MMC and get the returned data

    hr = This->lpVtbl->GetColumnConfigData(This, pColID, ppColSetData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSetData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSetData)->pColData)
    {
        goto Cleanup;
    }

    // At this point MMC has returned a pointer to an MMC_COLUMN_SET_DATA
    // that contains an embedded pointer into the same block of memory (pColData).
    // MMC expects that the caller will make a single call to CoTaskMemFree().
    // The MIDL-generated stub thinks the embedded pointer needs to be freed
    // separately so we need to reconstruct the output to use two separate
    // blocks.

    // Allocate a new MMC_COLUMN_DATA array

    cbColData = sizeof(MMC_COLUMN_DATA) * (*ppColSetData)->nNumCols;

    pColData = (MMC_COLUMN_DATA *)CoTaskMemAlloc(cbColData);
    if (NULL == pColData)
    {
        CoTaskMemFree(*ppColSetData);
        *ppColSetData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the column data
        memcpy(pColData, (*ppColSetData)->pColData, cbColData);

        // Overwrite the existing embedded pointer. There will be no memory leak
        // because that pointer pointed into the same block as the
        // MMC_COLUMN_SET_DATA and the stub will free the MMC_COLUMN_SET_DATA pointer.
        // Now both pointers can be freed independently as the stub expects.

        (*ppColSetData)->pColData = pColData;
    }

Cleanup:
    return hr;
}



HRESULT STDMETHODCALLTYPE IColumnData_GetColumnSortData_Proxy
( 
    IColumnData __RPC_FAR                  *This,
    SColumnSetID __RPC_FAR                 *pColID,
    MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData
)
{
    HRESULT            hr = S_OK;
    size_t             cbSortData = 0;
    MMC_SORT_SET_DATA *pColSortData = NULL;

    // Call the proxy and get the returned data from MMC

    hr = IColumnData_RemGetColumnSortData_Proxy(This, pColID, ppColSortData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSortData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSortData)->pSortData)
    {
        goto Cleanup;
    }

    // At this point the MIDL-generated proxy has returned an MMC_SORT_SET_DATA
    // in which the embedded pointer pSortData points to a separate block of
    // memory which must be freed independently. The snap-in thinks that
    // pSortData points into the same block of memory so it will only call
    // CoTaskMemFree for the MMC_SORT_SET_DATA. We need to allocate a new single
    // block in the format the snap-in is expecting and free the memory returned
    // from the proxy.

    cbSortData = sizeof(MMC_SORT_DATA) * (*ppColSortData)->nNumItems;

    pColSortData = (MMC_SORT_SET_DATA *)CoTaskMemAlloc(
                                         sizeof(MMC_SORT_SET_DATA) + cbSortData);

    if (NULL == pColSortData)
    {
        CoTaskMemFree((*ppColSortData)->pSortData);
        CoTaskMemFree(*ppColSortData);
        *ppColSortData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the sort set data

        memcpy(pColSortData, (*ppColSortData), sizeof(MMC_SORT_SET_DATA));

        // Set the embedded pointer to point immediately following the
        // MMC_SORT_SET_DATA

        pColSortData->pSortData = (MMC_SORT_DATA *)(pColSortData + 1);

        // Copy the sort data

        memcpy(pColSortData->pSortData, (*ppColSortData)->pSortData, cbSortData);

        // Free the data returned from the proxy

        CoTaskMemFree((*ppColSortData)->pSortData);
        CoTaskMemFree(*ppColSortData);

        // Return the new single block pointer to the snap-in

        *ppColSortData = pColSortData;
    }

Cleanup:
    return hr;
}


HRESULT STDMETHODCALLTYPE IColumnData_GetColumnSortData_Stub
( 
    IColumnData __RPC_FAR                  *This,
    SColumnSetID __RPC_FAR                 *pColID,
    MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData
)
{
    HRESULT        hr = S_OK;
    size_t         cbSortData = 0;
    MMC_SORT_DATA *pSortData = NULL;

    // Call into MMC and get the returned data

    hr = This->lpVtbl->GetColumnSortData(This, pColID, ppColSortData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSortData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSortData)->pSortData)
    {
        goto Cleanup;
    }

    // At this point MMC has returned a pointer to an MMC_SORT_SET_DATA
    // that contains an embedded pointer into the same block of memory (pSortData).
    // MMC expects that the caller will make a single call to CoTaskMemFree().
    // The MIDL-generated stub thinks the embedded pointer needs to be freed
    // separately so we need to reconstruct the output to use two separate
    // blocks.

    // Allocate a new MMC_SORT_DATA array

    cbSortData = sizeof(MMC_SORT_DATA) * (*ppColSortData)->nNumItems;

    pSortData = (MMC_SORT_DATA *)CoTaskMemAlloc(cbSortData);
    if (NULL == pSortData)
    {
        CoTaskMemFree(*ppColSortData);
        *ppColSortData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the column data
        memcpy(pSortData, (*ppColSortData)->pSortData, cbSortData);

        // Overwrite the existing embedded pointer. There will be no memory leak
        // because that pointer pointed into the same block as the
        // MMC_SORT_SET_DATA and the stub will free the MMC_SORT_SET_DATA pointer.
        // Now both pointers can be freed independently as the stub expects.

        (*ppColSortData)->pSortData = pSortData;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\include\wininet.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    wininet.h

Abstract:

    Contains manifests, macros, types and prototypes for Microsoft Windows
    Internet Extensions

--*/

#if !defined(_WININET_)
#define _WININET_

/*
 * Set up Structure Packing to be 4 bytes
 * for all wininet structures
 */

#pragma pack(push, wininet, 4)

#if defined(__cplusplus)
extern "C" {
#endif

#if !defined(_WINX32_)
#define INTERNETAPI DECLSPEC_IMPORT
#else
#define INTERNETAPI
#endif

//
// internet types
//

typedef LPVOID HINTERNET;
typedef HINTERNET * LPHINTERNET;

typedef WORD INTERNET_PORT;
typedef INTERNET_PORT * LPINTERNET_PORT;

//
// Internet APIs
//

//
// manifests
//

#define INTERNET_INVALID_PORT_NUMBER    0           // use the protocol-specific default

#define INTERNET_DEFAULT_FTP_PORT       21          // default for FTP servers
#define INTERNET_DEFAULT_GOPHER_PORT    70          //    "     "  gopher "
#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.

#define MAX_CACHE_ENTRY_INFO_SIZE       4096

//
// maximum field lengths (arbitrary)
//

#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_MAX_USER_NAME_LENGTH   128
#define INTERNET_MAX_PASSWORD_LENGTH    128
#define INTERNET_MAX_PORT_NUMBER_LENGTH 5           // INTERNET_PORT is unsigned short
#define INTERNET_MAX_PORT_NUMBER_VALUE  65535       // maximum unsigned short value
#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_PROTOCOL_NAME      "gopher"    // longest protocol name
#define INTERNET_MAX_URL_LENGTH         ((sizeof(INTERNET_MAX_PROTOCOL_NAME) - 1) \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

//
// values returned by InternetQueryOption() with INTERNET_OPTION_KEEP_CONNECTION:
//

#define INTERNET_KEEP_ALIVE_UNKNOWN     ((DWORD)-1)
#define INTERNET_KEEP_ALIVE_ENABLED     1
#define INTERNET_KEEP_ALIVE_DISABLED    0

//
// flags returned by InternetQueryOption() with INTERNET_OPTION_REQUEST_FLAGS
//

#define INTERNET_REQFLAG_FROM_CACHE     0x00000001
#define INTERNET_REQFLAG_ASYNC          0x00000002

//
// flags common to open functions (not InternetOpen()):
//

#define INTERNET_FLAG_RELOAD            0x80000000  // retrieve the original item

//
// flags for InternetOpenUrl():
//

#define INTERNET_FLAG_RAW_DATA          0x40000000  // receive the item as raw data
#define INTERNET_FLAG_EXISTING_CONNECT  0x20000000  // do not create new connection object

//
// flags for InternetOpen():
//

#define INTERNET_FLAG_ASYNC             0x10000000  // this request is asynchronous (where supported)

//
// protocol-specific flags:
//

#define INTERNET_FLAG_PASSIVE           0x08000000  // used for FTP connections

//
// additional cache flags
//

#define INTERNET_FLAG_NO_CACHE_WRITE    0x04000000  // don't write this item to the cache
#define INTERNET_FLAG_DONT_CACHE        INTERNET_FLAG_NO_CACHE_WRITE

#define INTERNET_FLAG_MAKE_PERSISTENT   0x02000000  // make this item persistent in cache

#define INTERNET_FLAG_OFFLINE           0x01000000  // use offline semantics

//
// additional flags
//

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)

#define INTERNET_FLAG_KEEP_CONNECTION   0x00400000  // use keep-alive semantics

#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000  // don't handle redirections automatically

#define INTERNET_FLAG_READ_PREFETCH     0x00100000  // do background read prefetch

#define INTERNET_FLAG_NO_COOKIES        0x00080000  // no automatic cookie handling

#define INTERNET_FLAG_NO_AUTH           0x00040000  // no automatic authentication handling

//
// Security Ignore Flags, Allow HttpOpenRequest to overide
//  Secure Channel (SSL/PCT) failures of the following types.
//

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   0x00008000 // ex: https:// to http://

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://

#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.

#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.

//more caching flags
#define INTERNET_FLAG_MUST_CACHE_REQUEST        0x00000010 // fails if unable to cache request
#define INTERNET_FLAG_RESYNCHRONIZE             0x00000800 // asking wininet to update an item if it is newer
#define INTERNET_FLAG_HYPERLINK                 0x00000400 // asking wininet to
                                                           //do hyperlinking semantic which works right for scripts
#define INTERNET_FLAG_NO_UI                     0x00000200

//
// flags for FTP
//

#define INTERNET_FLAG_TRANSFER_ASCII    FTP_TRANSFER_TYPE_ASCII
#define INTERNET_FLAG_TRANSFER_BINARY   FTP_TRANSFER_TYPE_BINARY

//
// flags field masks
//

#define SECURITY_INTERNET_MASK  (INTERNET_FLAG_IGNORE_CERT_CN_INVALID    |  \
                                 INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   )

#define SECURITY_SET_MASK       SECURITY_INTERNET_MASK

#define INTERNET_FLAGS_MASK     (INTERNET_FLAG_RELOAD               \
                                | INTERNET_FLAG_RAW_DATA            \
                                | INTERNET_FLAG_EXISTING_CONNECT    \
                                | INTERNET_FLAG_ASYNC               \
                                | INTERNET_FLAG_PASSIVE             \
                                | INTERNET_FLAG_NO_CACHE_WRITE      \
                                | INTERNET_FLAG_MAKE_PERSISTENT     \
                                | INTERNET_FLAG_OFFLINE             \
                                | INTERNET_FLAG_SECURE              \
                                | INTERNET_FLAG_KEEP_CONNECTION     \
                                | INTERNET_FLAG_NO_AUTO_REDIRECT    \
                                | INTERNET_FLAG_READ_PREFETCH       \
                                | INTERNET_FLAG_NO_COOKIES          \
                                | INTERNET_FLAG_NO_AUTH             \
                                | SECURITY_INTERNET_MASK            \
                                | INTERNET_FLAG_TRANSFER_ASCII      \
                                | INTERNET_FLAG_TRANSFER_BINARY     \
                                | INTERNET_FLAG_RESYNCHRONIZE       \
                                | INTERNET_FLAG_MUST_CACHE_REQUEST  \
                                | INTERNET_FLAG_HYPERLINK           \
                                | INTERNET_FLAG_NO_UI               \
                                )

#define INTERNET_OPTIONS_MASK   (~INTERNET_FLAGS_MASK)

//
// INTERNET_NO_CALLBACK - if this value is presented as the dwContext parameter
// then no call-backs will be made for that API
//

#define INTERNET_NO_CALLBACK            0

//
// structures/types
//

//
// INTERNET_SCHEME - enumerated URL scheme type
//

typedef enum {
    INTERNET_SCHEME_PARTIAL = -2,
    INTERNET_SCHEME_UNKNOWN = -1,
    INTERNET_SCHEME_DEFAULT = 0,
    INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_GOPHER,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_FILE,
    INTERNET_SCHEME_NEWS,
    INTERNET_SCHEME_MAILTO,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_FIRST = INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_LAST = INTERNET_SCHEME_SOCKS
} INTERNET_SCHEME, * LPINTERNET_SCHEME;

//
// INTERNET_ASYNC_RESULT - this structure is returned to the application via
// the callback with INTERNET_STATUS_REQUEST_COMPLETE. It is not sufficient to
// just return the result of the async operation. If the API failed then the
// app cannot call GetLastError() because the thread context will be incorrect.
// Both the value returned by the async API and any resultant error code are
// made available. The app need not check dwError if dwResult indicates that
// the API succeeded (in this case dwError will be ERROR_SUCCESS)
//

typedef struct {

    //
    // dwResult - the HINTERNET, DWORD or BOOL return code from an async API
    //

    DWORD dwResult;

    //
    // dwError - the error code if the API failed
    //

    DWORD dwError;
} INTERNET_ASYNC_RESULT, * LPINTERNET_ASYNC_RESULT;

//
// INTERNET_PREFETCH_STATUS -
//

typedef struct {

    //
    // dwStatus - status of download. See INTERNET_PREFETCH_ flags
    //

    DWORD dwStatus;

    //
    // dwSize - size of file downloaded so far
    //

    DWORD dwSize;
} INTERNET_PREFETCH_STATUS, * LPINTERNET_PREFETCH_STATUS;

//
// INTERNET_PREFETCH_STATUS - dwStatus values
//

#define INTERNET_PREFETCH_PROGRESS  0
#define INTERNET_PREFETCH_COMPLETE  1
#define INTERNET_PREFETCH_ABORTED   2

//
// INTERNET_PROXY_INFO - structure supplied with INTERNET_OPTION_PROXY to get/
// set proxy information on a InternetOpen() handle
//

typedef struct {

    //
    // dwAccessType - INTERNET_OPEN_TYPE_DIRECT, INTERNET_OPEN_TYPE_PROXY, or
    // INTERNET_OPEN_TYPE_PRECONFIG (set only)
    //

    DWORD dwAccessType;

    //
    // lpszProxy - proxy server list
    //

    LPCTSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCTSTR lpszProxyBypass;
} INTERNET_PROXY_INFO, * LPINTERNET_PROXY_INFO;

//
// INTERNET_VERSION_INFO - version information returned via
// InternetQueryOption(..., INTERNET_OPTION_VERSION, ...)
//

typedef struct {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
} INTERNET_VERSION_INFO, * LPINTERNET_VERSION_INFO;

//
// URL_COMPONENTS - the constituent parts of an URL. Used in InternetCrackUrl()
// and InternetCreateUrl()
//
// For InternetCrackUrl(), if a pointer field and its corresponding length field
// are both 0 then that component is not returned; If the pointer field is NULL
// but the length field is not zero, then both the pointer and length fields are
// returned; if both pointer and corresponding length fields are non-zero then
// the pointer field points to a buffer where the component is copied. The
// component may be un-escaped, depending on dwFlags
//
// For InternetCreateUrl(), the pointer fields should be NULL if the component
// is not required. If the corresponding length field is zero then the pointer
// field is the address of a zero-terminated string. If the length field is not
// zero then it is the string length of the corresponding pointer field
//

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPSTR   lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPSTR   lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPSTR   lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPSTR   lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPSTR   lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPSTR   lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSA, * LPURL_COMPONENTSA;
typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;
#ifdef UNICODE
typedef URL_COMPONENTSW URL_COMPONENTS;
typedef LPURL_COMPONENTSW LPURL_COMPONENTS;
#else
typedef URL_COMPONENTSA URL_COMPONENTS;
typedef LPURL_COMPONENTSA LPURL_COMPONENTS;
#endif // UNICODE

//
// INTERNET_CERTIFICATE_INFO lpBuffer - contains the certificate returned from
// the server
//

typedef struct {

    //
    // ftExpiry - date the certificate expires.
    //

    FILETIME ftExpiry;

    //
    // ftStart - date the certificate becomes valid.
    //

    FILETIME ftStart;

    //
    // lpszSubjectInfo - the name of organization, site, and server
    //   the cert. was issued for.
    //

    LPTSTR lpszSubjectInfo;

    //
    // lpszIssuerInfo - the name of organization, site, and server
    //   the cert was issues by.
    //

    LPTSTR lpszIssuerInfo;

    //
    // lpszProtocolName - the name of the protocol used to provide the secure
    //   connection.
    //

    LPTSTR lpszProtocolName;

    //
    // lpszSignatureAlgName - the name of the algorithm used for signing
    //  the certificate.
    //

    LPTSTR lpszSignatureAlgName;

    //
    // lpszEncryptionAlgName - the name of the algorithm used for
    //  doing encryption over the secure channel (SSL/PCT) connection.
    //

    LPTSTR lpszEncryptionAlgName;

    //
    // dwKeySize - size of the key.
    //

    DWORD dwKeySize;

} INTERNET_CERTIFICATE_INFO, * LPINTERNET_CERTIFICATE_INFO;

//
// prototypes
//

INTERNETAPI
BOOL
WINAPI
InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    );

//
// constants for InternetTimeFromSystemTime
//

#define INTERNET_RFC1123_FORMAT     0
#define INTERNET_RFC1123_BUFSIZE   30

INTERNETAPI
BOOL
WINAPI
InternetTimeToSystemTime(
    IN  LPCSTR lpszTime,         // NULL terminated string
    OUT SYSTEMTIME *pst,         // output in GMT time
    IN  DWORD dwReserved
    );

INTERNETAPI
BOOL
WINAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwReserved
);

INTERNETAPI
BOOL
WINAPI
InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );
INTERNETAPI
BOOL
WINAPI
InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    );
#ifdef UNICODE
#define InternetCrackUrl  InternetCrackUrlW
#else
#define InternetCrackUrl  InternetCrackUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );
INTERNETAPI
BOOL
WINAPI
InternetCreateUrlW(
    IN LPURL_COMPONENTSW lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPWSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );
#ifdef UNICODE
#define InternetCreateUrl  InternetCreateUrlW
#else
#define InternetCreateUrl  InternetCreateUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlW
#else
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
INTERNETAPI
BOOL
WINAPI
InternetCombineUrlW(
    IN LPCWSTR lpszBaseUrl,
    IN LPCWSTR lpszRelativeUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCombineUrl  InternetCombineUrlW
#else
#define InternetCombineUrl  InternetCombineUrlA
#endif // !UNICODE

//
// flags for InternetCrackUrl() and InternetCreateUrl()
//

#define ICU_ESCAPE      0x80000000  // (un)escape URL characters
#define ICU_USERNAME    0x40000000  // use internal username & password

//
// flags for InternetCanonicalizeUrl() and InternetCombineUrl()
//

#define ICU_NO_ENCODE   0x20000000  // Don't convert unsafe characters to escape sequence
#define ICU_DECODE      0x10000000  // Convert %XX escape sequences to characters
#define ICU_NO_META     0x08000000  // Don't convert .. etc. meta path sequences
#define ICU_ENCODE_SPACES_ONLY 0x04000000  // Encode spaces only
#define ICU_BROWSER_MODE 0x02000000 // Special encode/decode rules for browser

INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetOpen  InternetOpenW
#else
#define InternetOpen  InternetOpenA
#endif // !UNICODE

//
// access types for InternetOpen()
//

#define INTERNET_OPEN_TYPE_PRECONFIG    0   // use registry configuration
#define INTERNET_OPEN_TYPE_DIRECT       1   // direct to net
#define INTERNET_OPEN_TYPE_PROXY        3   // via named proxy

#define PRE_CONFIG_INTERNET_ACCESS  INTERNET_OPEN_TYPE_PRECONFIG
#define LOCAL_INTERNET_ACCESS       INTERNET_OPEN_TYPE_DIRECT
#define GATEWAY_INTERNET_ACCESS     2   // Internet via gateway
#define CERN_PROXY_INTERNET_ACCESS  INTERNET_OPEN_TYPE_PROXY

INTERNETAPI
BOOL
WINAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    );

INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetConnect  InternetConnectW
#else
#define InternetConnect  InternetConnectA
#endif // !UNICODE

//
// service types for InternetConnect()
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3

INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetOpenUrl  InternetOpenUrlW
#else
#define InternetOpenUrl  InternetOpenUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

INTERNETAPI
DWORD
WINAPI
InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG  lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD dwContext
    );

INTERNETAPI
BOOL
WINAPI
InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

INTERNETAPI
BOOL
WINAPI
InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

INTERNETAPI
BOOL
WINAPI
InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
INTERNETAPI
BOOL
WINAPI
InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
#ifdef UNICODE
#define InternetFindNextFile  InternetFindNextFileW
#else
#define InternetFindNextFile  InternetFindNextFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetQueryOption  InternetQueryOptionW
#else
#define InternetQueryOption  InternetQueryOptionA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
#ifdef UNICODE
#define InternetSetOption  InternetSetOptionW
#else
#define InternetSetOption  InternetSetOptionA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetSetOptionExA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    );
INTERNETAPI
BOOL
WINAPI
InternetSetOptionExW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetSetOptionEx  InternetSetOptionExW
#else
#define InternetSetOptionEx  InternetSetOptionExA
#endif // !UNICODE

//
// flags for InternetSetOptionEx()
//

#define ISO_GLOBAL      0x00000001  // modify option globally
#define ISO_REGISTRY    0x00000002  // write option to registry (where applicable)

#define ISO_VALID_FLAGS (ISO_GLOBAL | ISO_REGISTRY)

//
// options manifests for Internet{Query|Set}Option
//

#define INTERNET_OPTION_CALLBACK                1
#define INTERNET_OPTION_CONNECT_TIMEOUT         2
#define INTERNET_OPTION_CONNECT_RETRIES         3
#define INTERNET_OPTION_CONNECT_BACKOFF         4
#define INTERNET_OPTION_SEND_TIMEOUT            5
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT    INTERNET_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT         6
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT INTERNET_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT       7
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT    8
#define INTERNET_OPTION_HANDLE_TYPE             9
#define INTERNET_OPTION_CONTEXT_VALUE           10
#define INTERNET_OPTION_LISTEN_TIMEOUT          11
#define INTERNET_OPTION_READ_BUFFER_SIZE        12
#define INTERNET_OPTION_WRITE_BUFFER_SIZE       13

#define INTERNET_OPTION_ASYNC_ID                15
#define INTERNET_OPTION_ASYNC_PRIORITY          16

#define INTERNET_OPTION_PARENT_HANDLE           21
#define INTERNET_OPTION_KEEP_CONNECTION         22
#define INTERNET_OPTION_REQUEST_FLAGS           23
#define INTERNET_OPTION_EXTENDED_ERROR          24

#define INTERNET_OPTION_OFFLINE_MODE            26
#define INTERNET_OPTION_CACHE_STREAM_HANDLE     27
#define INTERNET_OPTION_USERNAME                28
#define INTERNET_OPTION_PASSWORD                29
#define INTERNET_OPTION_ASYNC                   30
#define INTERNET_OPTION_SECURITY_FLAGS          31
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT    32
#define INTERNET_OPTION_DATAFILE_NAME           33
#define INTERNET_OPTION_URL                     34
#define INTERNET_OPTION_SECURITY_CERTIFICATE    35
#define INTERNET_OPTION_SECURITY_KEY_BITNESS    36
#define INTERNET_OPTION_REFRESH                 37
#define INTERNET_OPTION_PROXY                   38
#define INTERNET_OPTION_SETTINGS_CHANGED        39
#define INTERNET_OPTION_VERSION                 40
#define INTERNET_OPTION_USER_AGENT              41

#define INTERNET_FIRST_OPTION                   INTERNET_OPTION_CALLBACK
#define INTERNET_LAST_OPTION                    INTERNET_OPTION_USER_AGENT

//
// values for INTERNET_OPTION_PRIORITY
//

#define INTERNET_PRIORITY_FOREGROUND            1000

//
// handle types
//

#define INTERNET_HANDLE_TYPE_INTERNET           1
#define INTERNET_HANDLE_TYPE_CONNECT_FTP        2
#define INTERNET_HANDLE_TYPE_CONNECT_GOPHER     3
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       4
#define INTERNET_HANDLE_TYPE_FTP_FIND           5
#define INTERNET_HANDLE_TYPE_FTP_FIND_HTML      6
#define INTERNET_HANDLE_TYPE_FTP_FILE           7
#define INTERNET_HANDLE_TYPE_FTP_FILE_HTML      8
#define INTERNET_HANDLE_TYPE_GOPHER_FIND        9
#define INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML   10
#define INTERNET_HANDLE_TYPE_GOPHER_FILE        11
#define INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML   12
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       13

//
// values for INTERNET_OPTION_SECURITY_FLAGS
//

#define SECURITY_FLAG_SECURE                    0x00000001 // can query only
#define SECURITY_FLAG_SSL                       0x00000002
#define SECURITY_FLAG_SSL3                      0x00000004
#define SECURITY_FLAG_PCT                       0x00000008
#define SECURITY_FLAG_PCT4                      0x00000010
#define SECURITY_FLAG_IETFSSL4                  0x00000020

#define SECURITY_FLAG_40BIT                     0x10000000
#define SECURITY_FLAG_128BIT                    0x20000000
#define SECURITY_FLAG_56BIT                     0x40000000
#define SECURITY_FLAG_UNKNOWNBIT                0x80000000
#define SECURITY_FLAG_NORMALBITNESS             SECURITY_FLAG_40BIT

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID
#define SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS  INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS
#define SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP   INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP

INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoW
#else
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoA
#endif // !UNICODE

//
// callback function for InternetSetStatusCallback
//

typedef
VOID
(CALLBACK * INTERNET_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef INTERNET_STATUS_CALLBACK * LPINTERNET_STATUS_CALLBACK;

INTERNETAPI
INTERNET_STATUS_CALLBACK
WINAPI
InternetSetStatusCallback(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

//
// status manifests for Internet status callback
//

#define INTERNET_STATUS_RESOLVING_NAME          10
#define INTERNET_STATUS_NAME_RESOLVED           11
#define INTERNET_STATUS_CONNECTING_TO_SERVER    20
#define INTERNET_STATUS_CONNECTED_TO_SERVER     21
#define INTERNET_STATUS_SENDING_REQUEST         30
#define INTERNET_STATUS_REQUEST_SENT            31
#define INTERNET_STATUS_RECEIVING_RESPONSE      40
#define INTERNET_STATUS_RESPONSE_RECEIVED       41
#define INTERNET_STATUS_CTL_RESPONSE_RECEIVED   42
#define INTERNET_STATUS_PREFETCH                43
#define INTERNET_STATUS_CLOSING_CONNECTION      50
#define INTERNET_STATUS_CONNECTION_CLOSED       51
#define INTERNET_STATUS_HANDLE_CREATED          60
#define INTERNET_STATUS_HANDLE_CLOSING          70
#define INTERNET_STATUS_REQUEST_COMPLETE        100
#define INTERNET_STATUS_REDIRECT                110

//
// if the following value is returned by InternetSetStatusCallback, then
// probably an invalid (non-code) address was supplied for the callback
//

#define INTERNET_INVALID_STATUS_CALLBACK        ((INTERNET_STATUS_CALLBACK)(-1L))

//
// FTP
//

//
// manifests
//

#define FTP_TRANSFER_TYPE_UNKNOWN   0x00000000
#define FTP_TRANSFER_TYPE_ASCII     0x00000001
#define FTP_TRANSFER_TYPE_BINARY    0x00000002

#define FTP_TRANSFER_TYPE_MASK      (FTP_TRANSFER_TYPE_ASCII | FTP_TRANSFER_TYPE_BINARY)

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpFindFirstFile  FtpFindFirstFileW
#else
#define FtpFindFirstFile  FtpFindFirstFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpGetFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszRemoteFile,
    IN LPCSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpGetFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpGetFile  FtpGetFileW
#else
#define FtpGetFile  FtpGetFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpPutFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpPutFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocalFile,
    IN LPCWSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpPutFile  FtpPutFileW
#else
#define FtpPutFile  FtpPutFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpDeleteFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName
    );
INTERNETAPI
BOOL
WINAPI
FtpDeleteFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName
    );
#ifdef UNICODE
#define FtpDeleteFile  FtpDeleteFileW
#else
#define FtpDeleteFile  FtpDeleteFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpRenameFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    );
INTERNETAPI
BOOL
WINAPI
FtpRenameFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszExisting,
    IN LPCWSTR lpszNew
    );
#ifdef UNICODE
#define FtpRenameFile  FtpRenameFileW
#else
#define FtpRenameFile  FtpRenameFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpOpenFile  FtpOpenFileW
#else
#define FtpOpenFile  FtpOpenFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpCreateDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpCreateDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpCreateDirectory  FtpCreateDirectoryW
#else
#define FtpCreateDirectory  FtpCreateDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpRemoveDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpRemoveDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpRemoveDirectory  FtpRemoveDirectoryW
#else
#define FtpRemoveDirectory  FtpRemoveDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpSetCurrentDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpSetCurrentDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryW
#else
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpGetCurrentDirectoryA(
    IN HINTERNET hConnect,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpGetCurrentDirectoryW(
    IN HINTERNET hConnect,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
#ifdef UNICODE
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryW
#else
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpCommandA(
    IN HINTERNET hConnect,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpCommandW(
    IN HINTERNET hConnect,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCWSTR lpszCommand,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpCommand  FtpCommandW
#else
#define FtpCommand  FtpCommandA
#endif // !UNICODE

//
// Gopher
//

//
// manifests
//

//
// string field lengths (in characters, not bytes)
//

#define MAX_GOPHER_DISPLAY_TEXT     128
#define MAX_GOPHER_SELECTOR_TEXT    256
#define MAX_GOPHER_HOST_NAME        INTERNET_MAX_HOST_NAME_LENGTH
#define MAX_GOPHER_LOCATOR_LENGTH   (1                                  \
                                    + MAX_GOPHER_DISPLAY_TEXT           \
                                    + 1                                 \
                                    + MAX_GOPHER_SELECTOR_TEXT          \
                                    + 1                                 \
                                    + MAX_GOPHER_HOST_NAME              \
                                    + 1                                 \
                                    + INTERNET_MAX_PORT_NUMBER_LENGTH   \
                                    + 1                                 \
                                    + 1                                 \
                                    + 2                                 \
                                    )

//
// structures/types
//

//
// GOPHER_FIND_DATA - returns the results of a GopherFindFirstFile()/
// InternetFindNextFile() request
//

typedef struct {
    CHAR   DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];
    DWORD GopherType;   // GOPHER_TYPE_, if known
    DWORD SizeLow;
    DWORD SizeHigh;
    FILETIME LastModificationTime;
    CHAR   Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
} GOPHER_FIND_DATAA, * LPGOPHER_FIND_DATAA;
typedef struct {
    WCHAR  DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];
    DWORD GopherType;   // GOPHER_TYPE_, if known
    DWORD SizeLow;
    DWORD SizeHigh;
    FILETIME LastModificationTime;
    WCHAR  Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
} GOPHER_FIND_DATAW, * LPGOPHER_FIND_DATAW;
#ifdef UNICODE
typedef GOPHER_FIND_DATAW GOPHER_FIND_DATA;
typedef LPGOPHER_FIND_DATAW LPGOPHER_FIND_DATA;
#else
typedef GOPHER_FIND_DATAA GOPHER_FIND_DATA;
typedef LPGOPHER_FIND_DATAA LPGOPHER_FIND_DATA;
#endif // UNICODE

//
// manifests for GopherType
//

#define GOPHER_TYPE_TEXT_FILE       0x00000001
#define GOPHER_TYPE_DIRECTORY       0x00000002
#define GOPHER_TYPE_CSO             0x00000004
#define GOPHER_TYPE_ERROR           0x00000008
#define GOPHER_TYPE_MAC_BINHEX      0x00000010
#define GOPHER_TYPE_DOS_ARCHIVE     0x00000020
#define GOPHER_TYPE_UNIX_UUENCODED  0x00000040
#define GOPHER_TYPE_INDEX_SERVER    0x00000080
#define GOPHER_TYPE_TELNET          0x00000100
#define GOPHER_TYPE_BINARY          0x00000200
#define GOPHER_TYPE_REDUNDANT       0x00000400
#define GOPHER_TYPE_TN3270          0x00000800
#define GOPHER_TYPE_GIF             0x00001000
#define GOPHER_TYPE_IMAGE           0x00002000
#define GOPHER_TYPE_BITMAP          0x00004000
#define GOPHER_TYPE_MOVIE           0x00008000
#define GOPHER_TYPE_SOUND           0x00010000
#define GOPHER_TYPE_HTML            0x00020000
#define GOPHER_TYPE_PDF             0x00040000
#define GOPHER_TYPE_CALENDAR        0x00080000
#define GOPHER_TYPE_INLINE          0x00100000
#define GOPHER_TYPE_UNKNOWN         0x20000000
#define GOPHER_TYPE_ASK             0x40000000
#define GOPHER_TYPE_GOPHER_PLUS     0x80000000

//
// gopher type macros
//

#define IS_GOPHER_FILE(type)            (BOOL)(((type) & GOPHER_TYPE_FILE_MASK) ? TRUE : FALSE)
#define IS_GOPHER_DIRECTORY(type)       (BOOL)(((type) & GOPHER_TYPE_DIRECTORY) ? TRUE : FALSE)
#define IS_GOPHER_PHONE_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_CSO) ? TRUE : FALSE)
#define IS_GOPHER_ERROR(type)           (BOOL)(((type) & GOPHER_TYPE_ERROR) ? TRUE : FALSE)
#define IS_GOPHER_INDEX_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_INDEX_SERVER) ? TRUE : FALSE)
#define IS_GOPHER_TELNET_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TELNET) ? TRUE : FALSE)
#define IS_GOPHER_BACKUP_SERVER(type)   (BOOL)(((type) & GOPHER_TYPE_REDUNDANT) ? TRUE : FALSE)
#define IS_GOPHER_TN3270_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TN3270) ? TRUE : FALSE)
#define IS_GOPHER_ASK(type)             (BOOL)(((type) & GOPHER_TYPE_ASK) ? TRUE : FALSE)
#define IS_GOPHER_PLUS(type)            (BOOL)(((type) & GOPHER_TYPE_GOPHER_PLUS) ? TRUE : FALSE)

#define IS_GOPHER_TYPE_KNOWN(type)      (BOOL)(((type) & GOPHER_TYPE_UNKNOWN) ? FALSE : TRUE)

//
// GOPHER_TYPE_FILE_MASK - use this to determine if a locator identifies a
// (known) file type
//

#define GOPHER_TYPE_FILE_MASK       (GOPHER_TYPE_TEXT_FILE          \
                                    | GOPHER_TYPE_MAC_BINHEX        \
                                    | GOPHER_TYPE_DOS_ARCHIVE       \
                                    | GOPHER_TYPE_UNIX_UUENCODED    \
                                    | GOPHER_TYPE_BINARY            \
                                    | GOPHER_TYPE_GIF               \
                                    | GOPHER_TYPE_IMAGE             \
                                    | GOPHER_TYPE_BITMAP            \
                                    | GOPHER_TYPE_MOVIE             \
                                    | GOPHER_TYPE_SOUND             \
                                    | GOPHER_TYPE_HTML              \
                                    | GOPHER_TYPE_PDF               \
                                    | GOPHER_TYPE_CALENDAR          \
                                    | GOPHER_TYPE_INLINE            \
                                    )

//
// structured gopher attributes (as defined in gopher+ protocol document)
//

typedef struct {
    LPCTSTR Comment;
    LPCTSTR EmailAddress;
} GOPHER_ADMIN_ATTRIBUTE_TYPE, * LPGOPHER_ADMIN_ATTRIBUTE_TYPE;

typedef struct {
    FILETIME DateAndTime;
} GOPHER_MOD_DATE_ATTRIBUTE_TYPE, * LPGOPHER_MOD_DATE_ATTRIBUTE_TYPE;

typedef struct {
    DWORD Ttl;
} GOPHER_TTL_ATTRIBUTE_TYPE, * LPGOPHER_TTL_ATTRIBUTE_TYPE;

typedef struct {
    INT Score;
} GOPHER_SCORE_ATTRIBUTE_TYPE, * LPGOPHER_SCORE_ATTRIBUTE_TYPE;

typedef struct {
    INT LowerBound;
    INT UpperBound;
} GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE, * LPGOPHER_SCORE_RANGE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Site;
} GOPHER_SITE_ATTRIBUTE_TYPE, * LPGOPHER_SITE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Organization;
} GOPHER_ORGANIZATION_ATTRIBUTE_TYPE, * LPGOPHER_ORGANIZATION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Location;
} GOPHER_LOCATION_ATTRIBUTE_TYPE, * LPGOPHER_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT DegreesNorth;
    INT MinutesNorth;
    INT SecondsNorth;
    INT DegreesEast;
    INT MinutesEast;
    INT SecondsEast;
} GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE, * LPGOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT Zone;
} GOPHER_TIMEZONE_ATTRIBUTE_TYPE, * LPGOPHER_TIMEZONE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Provider;
} GOPHER_PROVIDER_ATTRIBUTE_TYPE, * LPGOPHER_PROVIDER_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Version;
} GOPHER_VERSION_ATTRIBUTE_TYPE, * LPGOPHER_VERSION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ShortAbstract;
    LPCTSTR AbstractFile;
} GOPHER_ABSTRACT_ATTRIBUTE_TYPE, * LPGOPHER_ABSTRACT_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ContentType;
    LPCTSTR Language;
    DWORD Size;
} GOPHER_VIEW_ATTRIBUTE_TYPE, * LPGOPHER_VIEW_ATTRIBUTE_TYPE;

typedef struct {
    BOOL TreeWalk;
} GOPHER_VERONICA_ATTRIBUTE_TYPE, * LPGOPHER_VERONICA_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR QuestionType;
    LPCTSTR QuestionText;
} GOPHER_ASK_ATTRIBUTE_TYPE, * LPGOPHER_ASK_ATTRIBUTE_TYPE;

//
// GOPHER_UNKNOWN_ATTRIBUTE_TYPE - this is returned if we retrieve an attribute
// that is not specified in the current gopher/gopher+ documentation. It is up
// to the application to parse the information
//

typedef struct {
    LPCTSTR Text;
} GOPHER_UNKNOWN_ATTRIBUTE_TYPE, * LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE;

//
// GOPHER_ATTRIBUTE_TYPE - returned in the user's buffer when an enumerated
// GopherGetAttribute call is made
//

typedef struct {
    DWORD CategoryId;   // e.g. GOPHER_CATEGORY_ID_ADMIN
    DWORD AttributeId;  // e.g. GOPHER_ATTRIBUTE_ID_ADMIN
    union {
        GOPHER_ADMIN_ATTRIBUTE_TYPE Admin;
        GOPHER_MOD_DATE_ATTRIBUTE_TYPE ModDate;
        GOPHER_TTL_ATTRIBUTE_TYPE Ttl;
        GOPHER_SCORE_ATTRIBUTE_TYPE Score;
        GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE ScoreRange;
        GOPHER_SITE_ATTRIBUTE_TYPE Site;
        GOPHER_ORGANIZATION_ATTRIBUTE_TYPE Organization;
        GOPHER_LOCATION_ATTRIBUTE_TYPE Location;
        GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE GeographicalLocation;
        GOPHER_TIMEZONE_ATTRIBUTE_TYPE TimeZone;
        GOPHER_PROVIDER_ATTRIBUTE_TYPE Provider;
        GOPHER_VERSION_ATTRIBUTE_TYPE Version;
        GOPHER_ABSTRACT_ATTRIBUTE_TYPE Abstract;
        GOPHER_VIEW_ATTRIBUTE_TYPE View;
        GOPHER_VERONICA_ATTRIBUTE_TYPE Veronica;
        GOPHER_ASK_ATTRIBUTE_TYPE Ask;
        GOPHER_UNKNOWN_ATTRIBUTE_TYPE Unknown;
    } AttributeType;
} GOPHER_ATTRIBUTE_TYPE, * LPGOPHER_ATTRIBUTE_TYPE;

#define MAX_GOPHER_CATEGORY_NAME    128     // arbitrary
#define MAX_GOPHER_ATTRIBUTE_NAME   128     //     "
#define MIN_GOPHER_ATTRIBUTE_LENGTH 256     //     "

//
// known gopher attribute categories. See below for ordinals
//

#define GOPHER_INFO_CATEGORY        TEXT("+INFO")
#define GOPHER_ADMIN_CATEGORY       TEXT("+ADMIN")
#define GOPHER_VIEWS_CATEGORY       TEXT("+VIEWS")
#define GOPHER_ABSTRACT_CATEGORY    TEXT("+ABSTRACT")
#define GOPHER_VERONICA_CATEGORY    TEXT("+VERONICA")

//
// known gopher attributes. These are the attribute names as defined in the
// gopher+ protocol document
//

#define GOPHER_ADMIN_ATTRIBUTE      TEXT("Admin")
#define GOPHER_MOD_DATE_ATTRIBUTE   TEXT("Mod-Date")
#define GOPHER_TTL_ATTRIBUTE        TEXT("TTL")
#define GOPHER_SCORE_ATTRIBUTE      TEXT("Score")
#define GOPHER_RANGE_ATTRIBUTE      TEXT("Score-range")
#define GOPHER_SITE_ATTRIBUTE       TEXT("Site")
#define GOPHER_ORG_ATTRIBUTE        TEXT("Org")
#define GOPHER_LOCATION_ATTRIBUTE   TEXT("Loc")
#define GOPHER_GEOG_ATTRIBUTE       TEXT("Geog")
#define GOPHER_TIMEZONE_ATTRIBUTE   TEXT("TZ")
#define GOPHER_PROVIDER_ATTRIBUTE   TEXT("Provider")
#define GOPHER_VERSION_ATTRIBUTE    TEXT("Version")
#define GOPHER_ABSTRACT_ATTRIBUTE   TEXT("Abstract")
#define GOPHER_VIEW_ATTRIBUTE       TEXT("View")
#define GOPHER_TREEWALK_ATTRIBUTE   TEXT("treewalk")

//
// identifiers for attribute strings
//

#define GOPHER_ATTRIBUTE_ID_BASE        0xabcccc00

#define GOPHER_CATEGORY_ID_ALL          (GOPHER_ATTRIBUTE_ID_BASE + 1)

#define GOPHER_CATEGORY_ID_INFO         (GOPHER_ATTRIBUTE_ID_BASE + 2)
#define GOPHER_CATEGORY_ID_ADMIN        (GOPHER_ATTRIBUTE_ID_BASE + 3)
#define GOPHER_CATEGORY_ID_VIEWS        (GOPHER_ATTRIBUTE_ID_BASE + 4)
#define GOPHER_CATEGORY_ID_ABSTRACT     (GOPHER_ATTRIBUTE_ID_BASE + 5)
#define GOPHER_CATEGORY_ID_VERONICA     (GOPHER_ATTRIBUTE_ID_BASE + 6)
#define GOPHER_CATEGORY_ID_ASK          (GOPHER_ATTRIBUTE_ID_BASE + 7)

#define GOPHER_CATEGORY_ID_UNKNOWN      (GOPHER_ATTRIBUTE_ID_BASE + 8)

#define GOPHER_ATTRIBUTE_ID_ALL         (GOPHER_ATTRIBUTE_ID_BASE + 9)

#define GOPHER_ATTRIBUTE_ID_ADMIN       (GOPHER_ATTRIBUTE_ID_BASE + 10)
#define GOPHER_ATTRIBUTE_ID_MOD_DATE    (GOPHER_ATTRIBUTE_ID_BASE + 11)
#define GOPHER_ATTRIBUTE_ID_TTL         (GOPHER_ATTRIBUTE_ID_BASE + 12)
#define GOPHER_ATTRIBUTE_ID_SCORE       (GOPHER_ATTRIBUTE_ID_BASE + 13)
#define GOPHER_ATTRIBUTE_ID_RANGE       (GOPHER_ATTRIBUTE_ID_BASE + 14)
#define GOPHER_ATTRIBUTE_ID_SITE        (GOPHER_ATTRIBUTE_ID_BASE + 15)
#define GOPHER_ATTRIBUTE_ID_ORG         (GOPHER_ATTRIBUTE_ID_BASE + 16)
#define GOPHER_ATTRIBUTE_ID_LOCATION    (GOPHER_ATTRIBUTE_ID_BASE + 17)
#define GOPHER_ATTRIBUTE_ID_GEOG        (GOPHER_ATTRIBUTE_ID_BASE + 18)
#define GOPHER_ATTRIBUTE_ID_TIMEZONE    (GOPHER_ATTRIBUTE_ID_BASE + 19)
#define GOPHER_ATTRIBUTE_ID_PROVIDER    (GOPHER_ATTRIBUTE_ID_BASE + 20)
#define GOPHER_ATTRIBUTE_ID_VERSION     (GOPHER_ATTRIBUTE_ID_BASE + 21)
#define GOPHER_ATTRIBUTE_ID_ABSTRACT    (GOPHER_ATTRIBUTE_ID_BASE + 22)
#define GOPHER_ATTRIBUTE_ID_VIEW        (GOPHER_ATTRIBUTE_ID_BASE + 23)
#define GOPHER_ATTRIBUTE_ID_TREEWALK    (GOPHER_ATTRIBUTE_ID_BASE + 24)

#define GOPHER_ATTRIBUTE_ID_UNKNOWN     (GOPHER_ATTRIBUTE_ID_BASE + 25)

//
// prototypes
//

INTERNETAPI
BOOL
WINAPI
GopherCreateLocatorA(
    IN LPCSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszDisplayString OPTIONAL,
    IN LPCSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
GopherCreateLocatorW(
    IN LPCWSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszDisplayString OPTIONAL,
    IN LPCWSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPWSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define GopherCreateLocator  GopherCreateLocatorW
#else
#define GopherCreateLocator  GopherCreateLocatorA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
GopherGetLocatorTypeA(
    IN LPCSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
INTERNETAPI
BOOL
WINAPI
GopherGetLocatorTypeW(
    IN LPCWSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
#ifdef UNICODE
#define GopherGetLocatorType  GopherGetLocatorTypeW
#else
#define GopherGetLocatorType  GopherGetLocatorTypeA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator OPTIONAL,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAA lpFindData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator OPTIONAL,
    IN LPCWSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAW lpFindData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherFindFirstFile  GopherFindFirstFileW
#else
#define GopherFindFirstFile  GopherFindFirstFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherOpenFile  GopherOpenFileW
#else
#define GopherOpenFile  GopherOpenFileA
#endif // !UNICODE

typedef
BOOL
(CALLBACK * GOPHER_ATTRIBUTE_ENUMERATOR)(
    LPGOPHER_ATTRIBUTE_TYPE lpAttributeInfo,
    DWORD dwError
    );

INTERNETAPI
BOOL
WINAPI
GopherGetAttributeA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
GopherGetAttributeW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherGetAttribute  GopherGetAttributeW
#else
#define GopherGetAttribute  GopherGetAttributeA
#endif // !UNICODE

//
// HTTP
//

//
// manifests
//

//
// the default major/minor HTTP version numbers
//

#define HTTP_MAJOR_VERSION      1
#define HTTP_MINOR_VERSION      0

#define HTTP_VERSION            TEXT("HTTP/1.0")

//
// HttpQueryInfo info levels. Generally, there is one info level
// for each potential RFC822/HTTP/MIME header that an HTTP server
// may send as part of a request response.
//
// The HTTP_QUERY_RAW_HEADERS info level is provided for clients
// that choose to perform their own header parsing.
//

#define HTTP_QUERY_MIME_VERSION                 0
#define HTTP_QUERY_CONTENT_TYPE                 1
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    2
#define HTTP_QUERY_CONTENT_ID                   3
#define HTTP_QUERY_CONTENT_DESCRIPTION          4
#define HTTP_QUERY_CONTENT_LENGTH               5
#define HTTP_QUERY_CONTENT_LANGUAGE             6
#define HTTP_QUERY_ALLOW                        7
#define HTTP_QUERY_PUBLIC                       8
#define HTTP_QUERY_DATE                         9
#define HTTP_QUERY_EXPIRES                      10
#define HTTP_QUERY_LAST_MODIFIED                11
#define HTTP_QUERY_MESSAGE_ID                   12
#define HTTP_QUERY_URI                          13
#define HTTP_QUERY_DERIVED_FROM                 14
#define HTTP_QUERY_COST                         15
#define HTTP_QUERY_LINK                         16
#define HTTP_QUERY_PRAGMA                       17
#define HTTP_QUERY_VERSION                      18  // special: part of status line
#define HTTP_QUERY_STATUS_CODE                  19  // special: part of status line
#define HTTP_QUERY_STATUS_TEXT                  20  // special: part of status line
#define HTTP_QUERY_RAW_HEADERS                  21  // special: all headers as ASCIIZ
#define HTTP_QUERY_RAW_HEADERS_CRLF             22  // special: all headers
#define HTTP_QUERY_CONNECTION                   23
#define HTTP_QUERY_ACCEPT                       24
#define HTTP_QUERY_ACCEPT_CHARSET               25
#define HTTP_QUERY_ACCEPT_ENCODING              26
#define HTTP_QUERY_ACCEPT_LANGUAGE              27
#define HTTP_QUERY_AUTHORIZATION                28
#define HTTP_QUERY_CONTENT_ENCODING             29
#define HTTP_QUERY_FORWARDED                    30
#define HTTP_QUERY_FROM                         31
#define HTTP_QUERY_IF_MODIFIED_SINCE            32
#define HTTP_QUERY_LOCATION                     33
#define HTTP_QUERY_ORIG_URI                     34
#define HTTP_QUERY_REFERER                      35
#define HTTP_QUERY_RETRY_AFTER                  36
#define HTTP_QUERY_SERVER                       37
#define HTTP_QUERY_TITLE                        38
#define HTTP_QUERY_USER_AGENT                   39
#define HTTP_QUERY_WWW_AUTHENTICATE             40
#define HTTP_QUERY_PROXY_AUTHENTICATE           41
#define HTTP_QUERY_ACCEPT_RANGES                42
#define HTTP_QUERY_SET_COOKIE                   43
#define HTTP_QUERY_COOKIE                       44
#define HTTP_QUERY_REQUEST_METHOD               45  // special: GET/POST etc.

#define HTTP_QUERY_MAX                          45

//
// HTTP_QUERY_CUSTOM - if this special value is supplied as the dwInfoLevel
// parameter of HttpQueryInfo() then the lpBuffer parameter contains the name
// of the header we are to query
//

#define HTTP_QUERY_CUSTOM                       65535

//
// HTTP_QUERY_FLAG_REQUEST_HEADERS - if this bit is set in the dwInfoLevel
// parameter of HttpQueryInfo() then the request headers will be queried for the
// request information
//

#define HTTP_QUERY_FLAG_REQUEST_HEADERS         0x80000000

//
// HTTP_QUERY_FLAG_SYSTEMTIME - if this bit is set in the dwInfoLevel parameter
// of HttpQueryInfo() AND the header being queried contains date information,
// e.g. the "Expires:" header then lpBuffer will contain a SYSTEMTIME structure
// containing the date and time information converted from the header string
//

#define HTTP_QUERY_FLAG_SYSTEMTIME              0x40000000

//
// HTTP_QUERY_FLAG_NUMBER - if this bit is set in the dwInfoLevel parameter of
// HttpQueryInfo(), then the value of the header will be converted to a number
// before being returned to the caller, if applicable
//

#define HTTP_QUERY_FLAG_NUMBER                  0x20000000

//
// HTTP_QUERY_FLAG_COALESCE - combine the values from several headers of the
// same name into the output buffer
//

#define HTTP_QUERY_FLAG_COALESCE                0x10000000

#define HTTP_QUERY_MODIFIER_FLAGS_MASK          (HTTP_QUERY_FLAG_REQUEST_HEADERS    \
                                                | HTTP_QUERY_FLAG_SYSTEMTIME        \
                                                | HTTP_QUERY_FLAG_NUMBER            \
                                                | HTTP_QUERY_FLAG_COALESCE          \
                                                )

#define HTTP_QUERY_HEADER_MASK                  (~HTTP_QUERY_MODIFIER_FLAGS_MASK)

//
// HTTP Response Status Codes:
//

#define HTTP_STATUS_OK              200     // request completed
#define HTTP_STATUS_CREATED         201     // object created, reason = new URI
#define HTTP_STATUS_ACCEPTED        202     // async completion (TBS)
#define HTTP_STATUS_PARTIAL         203     // partial completion
#define HTTP_STATUS_NO_CONTENT      204     // no info to return

#define HTTP_STATUS_AMBIGUOUS       300     // server couldn't decide what to return
#define HTTP_STATUS_MOVED           301     // object permanently moved
#define HTTP_STATUS_REDIRECT        302     // object temporarily moved
#define HTTP_STATUS_REDIRECT_METHOD 303     // redirection w/ new access method
#define HTTP_STATUS_NOT_MODIFIED    304     // if-modified-since was not modified

#define HTTP_STATUS_BAD_REQUEST     400     // invalid syntax
#define HTTP_STATUS_DENIED          401     // access denied
#define HTTP_STATUS_PAYMENT_REQ     402     // payment required
#define HTTP_STATUS_FORBIDDEN       403     // request forbidden
#define HTTP_STATUS_NOT_FOUND       404     // object not found
#define HTTP_STATUS_BAD_METHOD      405     // method is not allowed
#define HTTP_STATUS_NONE_ACCEPTABLE 406     // no response acceptable to client found
#define HTTP_STATUS_PROXY_AUTH_REQ  407     // proxy authentication required
#define HTTP_STATUS_REQUEST_TIMEOUT 408     // server timed out waiting for request
#define HTTP_STATUS_CONFLICT        409     // user should resubmit with more info
#define HTTP_STATUS_GONE            410     // the resource is no longer available
#define HTTP_STATUS_AUTH_REFUSED    411     // couldn't authorize client

#define HTTP_STATUS_SERVER_ERROR    500     // internal server error
#define HTTP_STATUS_NOT_SUPPORTED   501     // required not supported
#define HTTP_STATUS_BAD_GATEWAY     502     // error response received from gateway
#define HTTP_STATUS_SERVICE_UNAVAIL 503     // temporarily overloaded
#define HTTP_STATUS_GATEWAY_TIMEOUT 504     // timed out waiting for gateway

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define HttpOpenRequest  HttpOpenRequestW
#else
#define HttpOpenRequest  HttpOpenRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
#ifdef UNICODE
#define HttpAddRequestHeaders  HttpAddRequestHeadersW
#else
#define HttpAddRequestHeaders  HttpAddRequestHeadersA
#endif // !UNICODE

//
// values for dwModifiers parameter of HttpAddRequestHeaders()
//

#define HTTP_ADDREQ_INDEX_MASK      0x0000FFFF
#define HTTP_ADDREQ_FLAGS_MASK      0xFFFF0000

//
// HTTP_ADDREQ_FLAG_ADD_IF_NEW - the header will only be added if it doesn't
// already exist
//

#define HTTP_ADDREQ_FLAG_ADD_IF_NEW 0x10000000

//
// HTTP_ADDREQ_FLAG_ADD - if HTTP_ADDREQ_FLAG_REPLACE is set but the header is
// not found then if this flag is set, the header is added anyway, so long as
// there is a valid header-value
//

#define HTTP_ADDREQ_FLAG_ADD        0x20000000

//
// HTTP_ADDREQ_FLAG_COALESCE - coalesce headers with same name. e.g.
// "Accept: text/*" and "Accept: audio/*" with this flag results in a single
// header: "Accept: text/*, audio/*"
//

//
// HTTP_ADDREQ_FLAG_COALESCE - coalesce headers with same name. e.g.
// "Accept: text/*" and "Accept: audio/*" with this flag results in a single
// header: "Accept: text/*, audio/*"
//

#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       0x40000000

#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   0x01000000

#define HTTP_ADDREQ_FLAG_COALESCE                  HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA

//
// HTTP_ADDREQ_FLAG_REPLACE - replaces the specified header. Only one header can
// be supplied in the buffer. If the header to be replaced is not the first
// in a list of headers with the same name, then the relative index should be
// supplied in the low 8 bits of the dwModifiers parameter. If the header-value
// part is missing, then the header is removed
//

#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
INTERNETAPI
BOOL
WINAPI
HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#ifdef UNICODE
#define HttpSendRequest  HttpSendRequestW
#else
#define HttpSendRequest  HttpSendRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
INTERNETAPI
BOOL
WINAPI
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
#ifdef UNICODE
#define HttpQueryInfo  HttpQueryInfoW
#else
#define HttpQueryInfo  HttpQueryInfoA
#endif // !UNICODE

//
// Cookie APIs
//

INTERNETAPI
BOOL
WINAPI
InternetSetCookieA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszCookieName,
    IN LPCSTR lpszCookieData
    );
INTERNETAPI
BOOL
WINAPI
InternetSetCookieW(
    IN LPCSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    IN LPCWSTR lpszCookieData
    );
#ifdef UNICODE
#define InternetSetCookie  InternetSetCookieW
#else
#define InternetSetCookie  InternetSetCookieA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetGetCookieA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszCookieName,
    OUT LPSTR lpCookieData,
    IN OUT LPDWORD lpdwSize
    );
INTERNETAPI
BOOL
WINAPI
InternetGetCookieW(
    IN LPCSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    OUT LPWSTR lpCookieData,
    IN OUT LPDWORD lpdwSize
    );
#ifdef UNICODE
#define InternetGetCookie  InternetGetCookieW
#else
#define InternetGetCookie  InternetGetCookieA
#endif // !UNICODE

//
// offline browsing
//

INTERNETAPI
DWORD
WINAPI
InternetAttemptConnect(
    DWORD dwReserved
    );

//
// Internet UI
//

//
// InternetErrorDlg - Provides UI for certain Errors.
//

#define FLAGS_ERROR_UI_FILTER_FOR_ERRORS        0x01
#define FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS     0x02
#define FLAGS_ERROR_UI_FLAGS_GENERATE_DATA      0x04
#define FLAGS_ERROR_UI_FLAGS_NO_UI              0x08

INTERNETAPI
DWORD
WINAPI
InternetErrorDlg(
     IN HWND hWnd,
     IN OUT HINTERNET hRequest,
     IN DWORD dwError,
     IN DWORD dwFlags,
     IN OUT LPVOID * lppvData
     );

INTERNETAPI
DWORD
WINAPI
InternetConfirmZoneCrossing(
     IN HWND hWnd,
     IN LPSTR szUrlPrev,
     IN LPSTR szUrlNew,
     IN BOOL bPost
     );

//#if !defined(_WINERROR_)

//
// Internet API error returns
//

#define INTERNET_ERROR_BASE                     12000

#define ERROR_INTERNET_OUT_OF_HANDLES           (INTERNET_ERROR_BASE + 1)
#define ERROR_INTERNET_TIMEOUT                  (INTERNET_ERROR_BASE + 2)
#define ERROR_INTERNET_EXTENDED_ERROR           (INTERNET_ERROR_BASE + 3)
#define ERROR_INTERNET_INTERNAL_ERROR           (INTERNET_ERROR_BASE + 4)
#define ERROR_INTERNET_INVALID_URL              (INTERNET_ERROR_BASE + 5)
#define ERROR_INTERNET_UNRECOGNIZED_SCHEME      (INTERNET_ERROR_BASE + 6)
#define ERROR_INTERNET_NAME_NOT_RESOLVED        (INTERNET_ERROR_BASE + 7)
#define ERROR_INTERNET_PROTOCOL_NOT_FOUND       (INTERNET_ERROR_BASE + 8)
#define ERROR_INTERNET_INVALID_OPTION           (INTERNET_ERROR_BASE + 9)
#define ERROR_INTERNET_BAD_OPTION_LENGTH        (INTERNET_ERROR_BASE + 10)
#define ERROR_INTERNET_OPTION_NOT_SETTABLE      (INTERNET_ERROR_BASE + 11)
#define ERROR_INTERNET_SHUTDOWN                 (INTERNET_ERROR_BASE + 12)
#define ERROR_INTERNET_INCORRECT_USER_NAME      (INTERNET_ERROR_BASE + 13)
#define ERROR_INTERNET_INCORRECT_PASSWORD       (INTERNET_ERROR_BASE + 14)
#define ERROR_INTERNET_LOGIN_FAILURE            (INTERNET_ERROR_BASE + 15)
#define ERROR_INTERNET_INVALID_OPERATION        (INTERNET_ERROR_BASE + 16)
#define ERROR_INTERNET_OPERATION_CANCELLED      (INTERNET_ERROR_BASE + 17)
#define ERROR_INTERNET_INCORRECT_HANDLE_TYPE    (INTERNET_ERROR_BASE + 18)
#define ERROR_INTERNET_INCORRECT_HANDLE_STATE   (INTERNET_ERROR_BASE + 19)
#define ERROR_INTERNET_NOT_PROXY_REQUEST        (INTERNET_ERROR_BASE + 20)
#define ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND (INTERNET_ERROR_BASE + 21)
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER   (INTERNET_ERROR_BASE + 22)
#define ERROR_INTERNET_NO_DIRECT_ACCESS         (INTERNET_ERROR_BASE + 23)
#define ERROR_INTERNET_NO_CONTEXT               (INTERNET_ERROR_BASE + 24)
#define ERROR_INTERNET_NO_CALLBACK              (INTERNET_ERROR_BASE + 25)
#define ERROR_INTERNET_REQUEST_PENDING          (INTERNET_ERROR_BASE + 26)
#define ERROR_INTERNET_INCORRECT_FORMAT         (INTERNET_ERROR_BASE + 27)
#define ERROR_INTERNET_ITEM_NOT_FOUND           (INTERNET_ERROR_BASE + 28)
#define ERROR_INTERNET_CANNOT_CONNECT           (INTERNET_ERROR_BASE + 29)
#define ERROR_INTERNET_CONNECTION_ABORTED       (INTERNET_ERROR_BASE + 30)
#define ERROR_INTERNET_CONNECTION_RESET         (INTERNET_ERROR_BASE + 31)
#define ERROR_INTERNET_FORCE_RETRY              (INTERNET_ERROR_BASE + 32)
#define ERROR_INTERNET_INVALID_PROXY_REQUEST    (INTERNET_ERROR_BASE + 33)
#define ERROR_INTERNET_NEED_UI                  (INTERNET_ERROR_BASE + 34)

#define ERROR_INTERNET_HANDLE_EXISTS            (INTERNET_ERROR_BASE + 36)
#define ERROR_INTERNET_SEC_CERT_DATE_INVALID    (INTERNET_ERROR_BASE + 37)
#define ERROR_INTERNET_SEC_CERT_CN_INVALID      (INTERNET_ERROR_BASE + 38)
#define ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR   (INTERNET_ERROR_BASE + 39)
#define ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR   (INTERNET_ERROR_BASE + 40)
#define ERROR_INTERNET_MIXED_SECURITY           (INTERNET_ERROR_BASE + 41)
#define ERROR_INTERNET_CHG_POST_IS_NON_SECURE   (INTERNET_ERROR_BASE + 42)
#define ERROR_INTERNET_POST_IS_NON_SECURE       (INTERNET_ERROR_BASE + 43)
#define ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED  (INTERNET_ERROR_BASE + 44)
#define ERROR_INTERNET_INVALID_CA               (INTERNET_ERROR_BASE + 45)
#define ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP    (INTERNET_ERROR_BASE + 46)
#define ERROR_INTERNET_ASYNC_THREAD_FAILED      (INTERNET_ERROR_BASE + 47)
#define ERROR_INTERNET_REDIRECT_SCHEME_CHANGE   (INTERNET_ERROR_BASE + 48)

//
// FTP API errors
//

#define ERROR_FTP_TRANSFER_IN_PROGRESS          (INTERNET_ERROR_BASE + 110)
#define ERROR_FTP_DROPPED                       (INTERNET_ERROR_BASE + 111)

//
// gopher API errors
//

#define ERROR_GOPHER_PROTOCOL_ERROR             (INTERNET_ERROR_BASE + 130)
#define ERROR_GOPHER_NOT_FILE                   (INTERNET_ERROR_BASE + 131)
#define ERROR_GOPHER_DATA_ERROR                 (INTERNET_ERROR_BASE + 132)
#define ERROR_GOPHER_END_OF_DATA                (INTERNET_ERROR_BASE + 133)
#define ERROR_GOPHER_INVALID_LOCATOR            (INTERNET_ERROR_BASE + 134)
#define ERROR_GOPHER_INCORRECT_LOCATOR_TYPE     (INTERNET_ERROR_BASE + 135)
#define ERROR_GOPHER_NOT_GOPHER_PLUS            (INTERNET_ERROR_BASE + 136)
#define ERROR_GOPHER_ATTRIBUTE_NOT_FOUND        (INTERNET_ERROR_BASE + 137)
#define ERROR_GOPHER_UNKNOWN_LOCATOR            (INTERNET_ERROR_BASE + 138)

//
// HTTP API errors
//

#define ERROR_HTTP_HEADER_NOT_FOUND             (INTERNET_ERROR_BASE + 150)
#define ERROR_HTTP_DOWNLEVEL_SERVER             (INTERNET_ERROR_BASE + 151)
#define ERROR_HTTP_INVALID_SERVER_RESPONSE      (INTERNET_ERROR_BASE + 152)
#define ERROR_HTTP_INVALID_HEADER               (INTERNET_ERROR_BASE + 153)
#define ERROR_HTTP_INVALID_QUERY_REQUEST        (INTERNET_ERROR_BASE + 154)
#define ERROR_HTTP_HEADER_ALREADY_EXISTS        (INTERNET_ERROR_BASE + 155)
#define ERROR_HTTP_REDIRECT_FAILED              (INTERNET_ERROR_BASE + 156)
#define ERROR_HTTP_NOT_REDIRECTED               (INTERNET_ERROR_BASE + 160) // BUGBUG

#define ERROR_INTERNET_SECURITY_CHANNEL_ERROR   (INTERNET_ERROR_BASE + 157) // BUGBUG
#define ERROR_INTERNET_UNABLE_TO_CACHE_FILE     (INTERNET_ERROR_BASE + 158) // BUGBUG
#define ERROR_INTERNET_TCPIP_NOT_INSTALLED      (INTERNET_ERROR_BASE + 159) // BUGBUG

#define INTERNET_ERROR_LAST                     ERROR_INTERNET_TCPIP_NOT_INSTALLED

//#endif // !defined(_WINERROR_)

//
// URLCACHE APIs
//

#if !defined(_WINX32_) && !defined(_URLCACHEAPI_)
#define URLCACHEAPI DECLSPEC_IMPORT
#else
#define URLCACHEAPI
#endif

//
// datatype definitions.
//

//
// cache entry type flags.
//

#define NORMAL_CACHE_ENTRY      0x00000001
#define STABLE_CACHE_ENTRY      0x00000002
#define STICKY_CACHE_ENTRY      0x00000004

#define SPARSE_CACHE_ENTRY      0x00010000
#define OCX_CACHE_ENTRY         0x00020000

#define COOKIE_CACHE_ENTRY      0x00100000
#define URLHISTORY_CACHE_ENTRY  0x00200000

//
// INTERNET_CACHE_ENTRY_INFO -
//

typedef struct _INTERNET_CACHE_ENTRY_INFOA {
    DWORD dwStructSize;         // version of cache system. 
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
    LPSTR   lpszLocalFileName;  // embedded pointer to the local file name.
    DWORD CacheEntryType;       // cache type bit mask.
    DWORD dwUseCount;           // current users count of the cache entry.
    DWORD dwHitRate;            // num of times the cache entry was retrieved.
    DWORD dwSizeLow;            // low DWORD of the file size.
    DWORD dwSizeHigh;           // high DWORD of the file size.
    FILETIME LastModifiedTime;  // last modified time of the file in GMT format.
    FILETIME ExpireTime;        // expire time of the file in GMT format
    FILETIME LastAccessTime;    // last accessed time in GMT format
    FILETIME LastSyncTime;      // last time the URL was synchronized
                                // with the source
    LPBYTE lpHeaderInfo;        // embedded pointer to the header info.
    DWORD dwHeaderInfoSize;     // size of the above header.
    LPSTR   lpszFileExtension;  // File extension used to retrieve the urldata as a file.
    DWORD dwReserved;           // reserved for future use.
} INTERNET_CACHE_ENTRY_INFOA, * LPINTERNET_CACHE_ENTRY_INFOA;
typedef struct _INTERNET_CACHE_ENTRY_INFOW {
    DWORD dwStructSize;         // version of cache system. 
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
    LPWSTR  lpszLocalFileName;  // embedded pointer to the local file name.
    DWORD CacheEntryType;       // cache type bit mask.
    DWORD dwUseCount;           // current users count of the cache entry.
    DWORD dwHitRate;            // num of times the cache entry was retrieved.
    DWORD dwSizeLow;            // low DWORD of the file size.
    DWORD dwSizeHigh;           // high DWORD of the file size.
    FILETIME LastModifiedTime;  // last modified time of the file in GMT format.
    FILETIME ExpireTime;        // expire time of the file in GMT format
    FILETIME LastAccessTime;    // last accessed time in GMT format
    FILETIME LastSyncTime;      // last time the URL was synchronized
                                // with the source
    LPBYTE lpHeaderInfo;        // embedded pointer to the header info.
    DWORD dwHeaderInfoSize;     // size of the above header.
    LPWSTR  lpszFileExtension;  // File extension used to retrieve the urldata as a file.
    DWORD dwReserved;           // reserved for future use.
} INTERNET_CACHE_ENTRY_INFOW, * LPINTERNET_CACHE_ENTRY_INFOW;
#ifdef UNICODE
typedef INTERNET_CACHE_ENTRY_INFOW INTERNET_CACHE_ENTRY_INFO;
typedef LPINTERNET_CACHE_ENTRY_INFOW LPINTERNET_CACHE_ENTRY_INFO;
#else
typedef INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFO;
typedef LPINTERNET_CACHE_ENTRY_INFOA LPINTERNET_CACHE_ENTRY_INFO;
#endif // UNICODE

//
// Cache APIs
//

URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    );
URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryW(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CreateUrlCacheEntry  CreateUrlCacheEntryW
#else
#define CreateUrlCacheEntry  CreateUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN DWORD dwReserved
    );
URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryW(
    IN LPCSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CommitUrlCacheEntry  CommitUrlCacheEntryW
#else
#define CommitUrlCacheEntry  CommitUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );
URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileW(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define RetrieveUrlCacheEntryFile  RetrieveUrlCacheEntryFileW
#else
#define RetrieveUrlCacheEntryFile  RetrieveUrlCacheEntryFileA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryFile(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    );

URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    );
URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamW(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define RetrieveUrlCacheEntryStream  RetrieveUrlCacheEntryStreamW
#else
#define RetrieveUrlCacheEntryStream  RetrieveUrlCacheEntryStreamA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
ReadUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    );

URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD Reserved
    );

URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );
URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoW(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define GetUrlCacheEntryInfo  GetUrlCacheEntryInfoW
#else
#define GetUrlCacheEntryInfo  GetUrlCacheEntryInfoA
#endif // !UNICODE

#define CACHE_ENTRY_ATTRIBUTE_FC    0x00000004
#define CACHE_ENTRY_HITRATE_FC      0x00000010
#define CACHE_ENTRY_MODTIME_FC      0x00000040
#define CACHE_ENTRY_EXPTIME_FC      0x00000080
#define CACHE_ENTRY_ACCTIME_FC      0x00000100
#define CACHE_ENTRY_SYNCTIME_FC     0x00000200
#define CACHE_ENTRY_HEADERINFO_FC   0x00000400

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );
URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoW(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );
#ifdef UNICODE
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoW
#else
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoA
#endif // !UNICODE

URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    );
URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryW(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define FindFirstUrlCacheEntry  FindFirstUrlCacheEntryW
#else
#define FindFirstUrlCacheEntry  FindFirstUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryA(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    );
URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define FindNextUrlCacheEntry  FindNextUrlCacheEntryW
#else
#define FindNextUrlCacheEntry  FindNextUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
FindCloseUrlCache(
    IN HANDLE hEnumHandle
    );

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    );

#if defined(__cplusplus)
}
#endif

/*
 * Return packing to whatever it was before we
 * entered this file
 */
#pragma pack(pop, wininet)

#endif // !defined(_WININET_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mmcproxy\multisel.cpp ===
//=--------------------------------------------------------------------------=
// multisel.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMultiSelDataObject class implementation
//
// This class simulates a multi-select data object craeted by MMC. It is
// used by the stub when it receives a remote call with multiple data objects.
//=--------------------------------------------------------------------------=

#include "mmc.h"

static HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi);
extern "C" HRESULT GetClipboardFormat(WCHAR      *pwszFormatName,
                                      CLIPFORMAT *pcfFormat);


class CMultiSelDataObject : public IDataObject
{
    public:
        CMultiSelDataObject();
        ~CMultiSelDataObject();

        HRESULT SetDataObjects(IDataObject **ppiDataObjects, long cDataObjects);
        
    private:

    // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

    // IDataObject
        STDMETHOD(GetData)(FORMATETC *pFormatEtcIn, STGMEDIUM *pmedium);
        STDMETHOD(GetDataHere)(FORMATETC *pFormatEtc, STGMEDIUM *pmedium);
        STDMETHOD(QueryGetData)(FORMATETC *pFormatEtc);
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pFormatEtcIn,
                                         FORMATETC *pFormatEtcOut);
        STDMETHOD(SetData)(FORMATETC *pFormatEtc,
                           STGMEDIUM *pmedium,
                           BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD            dwDirection,
                                 IEnumFORMATETC **ppenumFormatEtc);
        STDMETHOD(DAdvise)(FORMATETC   *pFormatEtc,
                           DWORD        advf,
                           IAdviseSink *pAdvSink,
                           DWORD       *pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise);

        void InitMemberVariables();
        void ReleaseDataObjects();

        SMMCDataObjects *m_pDataObjects;
        CLIPFORMAT       m_cfMultiSelectSnapIns;
        CLIPFORMAT       m_cfMultiSelectDataObject;
        ULONG            m_cRefs;
};


CMultiSelDataObject::CMultiSelDataObject()
{
    InitMemberVariables();
    m_cRefs = 1L;
}

CMultiSelDataObject::~CMultiSelDataObject()
{
    ReleaseDataObjects();
    InitMemberVariables();
}


void CMultiSelDataObject::ReleaseDataObjects()
{
    DWORD i = 0;

    if (NULL != m_pDataObjects)
    {
        while (i < m_pDataObjects->count)
        {
            if (NULL != m_pDataObjects->lpDataObject[i])
            {
                m_pDataObjects->lpDataObject[i]->Release();
            }
            i++;
        }
        (void)::GlobalFree((HGLOBAL)m_pDataObjects);
        m_pDataObjects = NULL;
    }
}

void CMultiSelDataObject::InitMemberVariables()
{
    m_pDataObjects = NULL;
    m_cfMultiSelectSnapIns = 0;
    m_cfMultiSelectDataObject = 0;
    m_cRefs = 0;
}


HRESULT CMultiSelDataObject::SetDataObjects
(
    IDataObject **ppiDataObjects,
    long          cDataObjects
)
{
    HRESULT hr = S_OK;
    long    i = 0;

    ReleaseDataObjects();

    hr = ::GetClipboardFormat(CCF_MULTI_SELECT_SNAPINS,
                              &m_cfMultiSelectSnapIns);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = ::GetClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT,
                              &m_cfMultiSelectDataObject);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_pDataObjects = (SMMCDataObjects *)::GlobalAlloc(GPTR,
        sizeof(SMMCDataObjects) + ((cDataObjects - 1) * sizeof(IDataObject *)));

    if (NULL == m_pDataObjects)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    m_pDataObjects->count = cDataObjects;

    for (i = 0; i < cDataObjects; i++)
    {
        ppiDataObjects[i]->AddRef();
        m_pDataObjects->lpDataObject[i] = ppiDataObjects[i];
    }

Cleanup:
    return hr;
}


//=--------------------------------------------------------------------------=
//
//                          IUnknown Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMultiSelDataObject::QueryInterface(REFIID riid, void **ppvObjOut)
{
    HRESULT hr = S_OK;

    if (IID_IUnknown == riid)
    {
        AddRef();
        *ppvObjOut = (IUnknown *)this;
    }
    else if (IID_IDataObject == riid)
    {
        AddRef();
        *ppvObjOut = (IDataObject *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}


STDMETHODIMP_(ULONG) CMultiSelDataObject::AddRef(void)
{
    m_cRefs++;
    return m_cRefs;
}


STDMETHODIMP_(ULONG) CMultiSelDataObject::Release(void)
{
    ULONG cRefs = --m_cRefs;

    if (0 == cRefs)
    {
        delete this;
    }
    return cRefs;
}

//=--------------------------------------------------------------------------=
//
//                             IDataObject Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMultiSelDataObject::GetData
(
    FORMATETC *pFmtEtc,
    STGMEDIUM *pStgMed
)
{
    SMMCDataObjects *pMMCDataObjects = NULL;
    DWORD           *pdw = NULL;
    DWORD            i = 0;
    HRESULT          hr = S_OK;

    if (TYMED_HGLOBAL != pFmtEtc->tymed)
    {
        hr = DV_E_TYMED;
        goto Cleanup;
    }

    if (m_cfMultiSelectSnapIns == pFmtEtc->cfFormat)
    {
        if (NULL == m_pDataObjects)
        {
            hr = DV_E_FORMATETC;
            goto Cleanup;
        }
        pStgMed->hGlobal = ::GlobalAlloc(GPTR,
                         sizeof(SMMCDataObjects) +
                         ((m_pDataObjects->count - 1) * sizeof(IDataObject *)));

        if (NULL == pStgMed->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pStgMed->tymed = TYMED_HGLOBAL;
        pMMCDataObjects = (SMMCDataObjects *)pStgMed->hGlobal;
        pMMCDataObjects->count = m_pDataObjects->count;

        for (i = 0; i < pMMCDataObjects->count; i++)
        {
            // Note: According to the rules of COM the returned IDataObject
            // pointers should be AddRef()ed. That is not done here in order
            // to emulate the way MMC does it.
            pMMCDataObjects->lpDataObject[i] = m_pDataObjects->lpDataObject[i];
        }
    }
    else if (m_cfMultiSelectDataObject == pFmtEtc->cfFormat)
    {
        pStgMed->hGlobal = ::GlobalAlloc(GPTR, sizeof(DWORD));
        if (NULL == pStgMed->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pStgMed->tymed = TYMED_HGLOBAL;
        pdw = (DWORD *)pStgMed->hGlobal;
        *pdw = (DWORD)1;
    }
    else
    {
        hr = DV_E_FORMATETC;
        goto Cleanup;
    }
Cleanup:
    return hr;
}

STDMETHODIMP CMultiSelDataObject::GetDataHere
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::QueryGetData(FORMATETC *pFmtEtc)
{
    HRESULT hr = S_OK;
    if (TYMED_HGLOBAL != pFmtEtc->tymed)
    {
        hr = DV_E_TYMED;
    }
    else if ( (m_cfMultiSelectSnapIns != pFmtEtc->cfFormat) &&
              (m_cfMultiSelectDataObject != pFmtEtc->cfFormat) )
    {
        hr = DV_E_FORMATETC;
    }
    return hr;
}

STDMETHODIMP CMultiSelDataObject::GetCanonicalFormatEtc
(
    FORMATETC *pFormatEtcIn,
    FORMATETC *pFormatEtcOut
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::SetData
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium,
    BOOL       fRelease
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::EnumFormatEtc
(
    DWORD            dwDirection,
    IEnumFORMATETC **ppenumFormatEtc
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::DAdvise
(
    FORMATETC   *pFormatEtc,
    DWORD        advf,
    IAdviseSink *pAdvSink,
    DWORD       *pdwConnection
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}


extern "C" HRESULT CreateMultiSelDataObject
(
    IDataObject          **ppiDataObjects,
    long                   cDataObjects,
    IDataObject          **ppiMultiSelDataObject
)
{
    HRESULT              hr = S_OK;
    CMultiSelDataObject *pMultiSelDataObject = new CMultiSelDataObject;

    *ppiMultiSelDataObject = NULL;

    if (NULL == pMultiSelDataObject)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pMultiSelDataObject->SetDataObjects(ppiDataObjects, cDataObjects);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    *ppiMultiSelDataObject = pMultiSelDataObject;

Cleanup:
    if ( FAILED(hr) && (NULL != pMultiSelDataObject) )
    {
        delete pMultiSelDataObject;
    }
    return hr;
}


extern "C" HRESULT GetClipboardFormat
(
    WCHAR       *pwszFormatName,
    CLIPFORMAT  *pcfFormat
)
{
    HRESULT  hr = S_OK;
    BOOL     fAnsi = TRUE;
    char    *pszFormatName = NULL;

    OSVERSIONINFO VerInfo;
    ::ZeroMemory(&VerInfo, sizeof(VerInfo));

    // Determine whether we are on NT or Win9x so that we know whether to
    // register clipboard format strings as UNICODE or ANSI.

    VerInfo.dwOSVersionInfoSize = sizeof(VerInfo);
    if (!::GetVersionEx(&VerInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    if (VER_PLATFORM_WIN32_NT == VerInfo.dwPlatformId)
    {
        fAnsi = FALSE;
    }

    if (fAnsi)
    {
        hr = ::ANSIFromWideStr(pwszFormatName, &pszFormatName);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatA(pszFormatName));
    }
    else
    {
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatW(pwszFormatName));
    }

    if (0 == *pcfFormat)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

Cleanup:
    if (NULL != pszFormatName)
    {
        (void)::GlobalFree(pszFormatName);
    }
    return hr;
}

static HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
{
    HRESULT hr = S_OK;
    int     cchWideStr = (int)::wcslen(pwszWideStr);
    int     cchConverted = 0;

    *ppszAnsi = NULL;

    // get required buffer length

    int cchAnsi = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                        0,           // performance and mapping flags 
                                        pwszWideStr, // address of wide-character string 
                                        cchWideStr,  // number of characters in string 
                                        NULL,        // address of buffer for new string 
                                        0,           // size of buffer 
                                        NULL,        // address of default for unmappable characters 
                                        NULL         // address of flag set when default char. used 
                                       );
    if (cchAnsi == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<char *>(::GlobalAlloc(GPTR, cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // now convert the string and copy it to the buffer
    cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pwszWideStr,          // address of wide-character string 
                                         cchWideStr,           // number of characters in string 
                                         *ppszAnsi,             // address of buffer for new string 
                                         cchAnsi,              // size of buffer 
                                         NULL,                 // address of default for unmappable characters 
                                         NULL                  // address of flag set when default char. used 
                                        );
    if (cchConverted != cchAnsi)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    // add terminating null byte

    *((*ppszAnsi) + cchAnsi) = '\0';

Cleanup:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            (void)::GlobalFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mmcproxy\stub_mmc_i.c ===
#include <mmc_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mmcproxy\stub_mmc_p.c ===
#include <mmc_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\help\makefile.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file implements the target specified in sources in NTTARGETFILE0.
    It executes a VB tool that generates help ID header files and an RC
    file containing all the help strings used by the design time ODL

!ENDIF

GenHelpIDs:
    SET THUNDER55=..\..\..\vb98
    SET TOOLS=TOOLS
	..\..\tools\idheader.bat mssnapd.id $(O)\mssnapd_helpids.h $(O)\mssnapd_helpstrs.h $(O)\mssnapd_helpstrs.rc -NoIncludePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ambients.cpp ===
//=--------------------------------------------------------------------------=
// ambients.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Class implementation for CAmbients.
//

#include "pch.h"
#include "common.h"
#include "ambients.h"

// for ASSERT and FAIL
//
SZTHISFILE


CAmbients::CAmbients()
{
    m_pDispAmbient = NULL;
}

CAmbients::~CAmbients()
{
    Detach();
}

void CAmbients::Attach(IDispatch *pDispAmbients)
{
    Detach();
    if (pDispAmbients != NULL)
    {
        pDispAmbients->AddRef();
    }
    m_pDispAmbient = pDispAmbients;
}

void CAmbients::Detach()
{
    RELEASE(m_pDispAmbient);
}

IDispatch *CAmbients::GetDispatch()
{
    return m_pDispAmbient;
}

HRESULT CAmbients::GetProjectDirectory(BSTR *pbstrProjDir)
{
    HRESULT hr = S_OK;
    hr = GetAmbientProperty(DISPID_AMBIENT_PROJECTDIRECTORY,
                            VT_BSTR,
                            pbstrProjDir);
    IfFailGo(hr);

Error:
    if (FAILED(hr))
    {
        *pbstrProjDir = NULL;
    }
    return hr;
}

HRESULT CAmbients::GetDesignerName(BSTR *pbstrName)
{
    HRESULT hr = S_OK;
    hr = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME,
                            VT_BSTR,
                            pbstrName);
    IfFailGo(hr);

Error:
    if (FAILED(hr))
    {
        *pbstrName = NULL;
    }
    return hr;
}

HRESULT CAmbients::GetSaveMode(long *plSaveMode)
{
    HRESULT hr = S_OK;
    hr = GetAmbientProperty(DISPID_AMBIENT_SAVEMODE,
                            VT_I4,
                            plSaveMode);
    IfFailGo(hr);

Error:
    if (FAILED(hr))
    {
        *plSaveMode = DESIGNERSAVEMODE_NORMAL;
    }
    return hr;
}


HRESULT CAmbients::GetAmbientProperty
(
    DISPID   dispid,
    VARTYPE  vtRequested,
    void    *pvData
)
{
    DISPPARAMS dispparams;
    ::ZeroMemory(&dispparams, sizeof(dispparams));
    VARIANT varProperty;
    ::VariantInit(&varProperty);
    VARIANT varRequested;
    ::VariantInit(&varRequested);
    HRESULT hr = S_OK;

    IfFalseGo(NULL != m_pDispAmbient, E_UNEXPECTED);
    // Get the property

    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0,
                                 DISPATCH_PROPERTYGET, &dispparams,
                                 &varProperty, NULL, NULL);
    IfFailGo(hr);

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = ::VariantChangeType(&varRequested, &varProperty, 0, vtRequested);
    IfFailGo(hr);

    // copy the data to where the user wants it
    //

    switch (vtRequested)
    {
        case VT_UI1:
            *(BYTE *)pvData = varRequested.bVal;
            break;

        case VT_I2:
            *(short *)pvData = varRequested.iVal;
            break;

        case VT_I4:
            *(long *)pvData = varRequested.lVal;
            break;

        case VT_R4:
            *(FLOAT *)pvData = varRequested.fltVal;
            break;

        case VT_R8:
            *(DOUBLE *)pvData = varRequested.dblVal;
            break;

        case VT_DATE:
            ::memcpy((DATE *)pvData, &varRequested.date, sizeof(varRequested.date));
            break;

        case VT_CY:
            *(CY *)pvData = varRequested.cyVal;
            break;

        case VT_BSTR:
            *(BSTR *)pvData = varRequested.bstrVal;
            break;

        case VT_DISPATCH:
            *(LPDISPATCH *)pvData = varRequested.pdispVal;
            break;

        case VT_ERROR:
            *(SCODE *)pvData = varRequested.scode;
            break;

        case VT_BOOL:
            *(BOOL *)pvData = varRequested.boolVal;
            break;

        case VT_VARIANT:
            *(VARIANT *)pvData = varRequested;
            break;

        case VT_UNKNOWN:
            *(IUnknown **)pvData = varRequested.punkVal;
            break;

        default:
            hr = E_INVALIDARG;
            break;
    };

Error:
    if (FAILED(hr))
    {
        ::VariantClear(&varRequested);
    }
    ::VariantClear(&varProperty);
    return hr;
}

//---------------------------------------------------------------------------------------
// HRESULT CAmbients::GetProjectName
//---------------------------------------------------------------------------------------
//  Output
//      S_OK
//      E_OUTOFMEMORY
//
//  Notes
//      Returns the project name by parsing the ProgID
//      ambient
//
HRESULT CAmbients::GetProjectName
(
    BSTR *pbstrProjectName
)
{
    HRESULT hr = S_OK;
    BSTR bstrProgID = NULL;
    LPWSTR pwsz = NULL;
    BSTR bstrProjectName = NULL;
    BOOL fRet = FALSE;

    hr = GetAmbientProperty(DISPID_AMBIENT_PROGID, VT_BSTR, &bstrProgID);
    IfFailGo(hr);

    pwsz = ::wcschr(bstrProgID, L'.');   
    IfFalseGo(pwsz != NULL, E_UNEXPECTED);

    *pwsz = L'\0';

    bstrProjectName = ::SysAllocString(bstrProgID);
    IfFalseGo(NULL != bstrProjectName, E_OUTOFMEMORY);

    *pbstrProjectName = bstrProjectName;

Error:

    if (FAILED(hr))
    {
        *pbstrProjectName = NULL;
    }
    FREESTRING(bstrProgID);

    return hr;
}

HRESULT CAmbients::GetInteractive(BOOL *pfInteractive)
{
    HRESULT      hr = S_OK;
    BOOL fvarInteractive = VARIANT_FALSE;

    *pfInteractive = FALSE;

    // To ensure a good COleControl::m_pDispAmbient we need to fetch a
    // property as that is when the framework initializes it. There is no
    // particular reason for getting this property as opposed to some other.

    IfFailGo(GetAmbientProperty(DISPID_AMBIENT_INTERACTIVE,
                                VT_BOOL,
                                &fvarInteractive));

    if (VARIANT_TRUE == fvarInteractive)
    {
        *pfInteractive = TRUE;
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ambients.h ===
//=--------------------------------------------------------------------------=
// ambients.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Class definition for CAmbients.
//

#ifndef _AMBIENTS_H_
#define _AMBIENTS_H_

class CAmbients
{
public:
    CAmbients();
    virtual ~CAmbients();

    void Attach(IDispatch *pDispAmbients);
    BOOL Attached() { return (NULL != m_pDispAmbient); }
    void Detach();
    IDispatch *GetDispatch();
    HRESULT GetProjectDirectory(BSTR *pbstrProjDir);
    HRESULT GetDesignerName(BSTR *pbstrName);
    HRESULT GetSaveMode(long *plSaveMode);
    HRESULT GetAmbientProperty(DISPID  dispid, VARTYPE vt, void *pData);
    HRESULT GetProjectName(BSTR* pbstrProjectName);
    HRESULT GetInteractive(BOOL *pfInteractive);

protected:
    IDispatch *m_pDispAmbient;
};


#endif // _AMBIENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\autoexep.h ===
class CAutomationException
{
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\chklst.h ===
//=--------------------------------------------------------------------------------------
// chklst.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CCheckList definition.
//=-------------------------------------------------------------------------------------=

// CCheckList
// This is a listbox class to for owner-drawn listboxes which have multiple
// selection with check boxes instead of highlighting.
// Concept and code sections borrowed from ruby's VBCheckList class.

#ifndef _CHKLIST_H_
#define _CHKLIST_H_


#define kCheckBoxChanged    WM_USER + 1

class CCheckedListItem : public CtlNewDelete, public CError
{
public:
    CCheckedListItem(bool bSelected);
    virtual ~CCheckedListItem();

public:
    bool    m_bSelected;
};


class CCheckList: public CtlNewDelete, public CError
{
public:
    CCheckList(int nCtrlID);
    ~CCheckList();

    HRESULT Attach(HWND hwnd);
    HRESULT Detach();

    HWND Window()       { return m_hwnd;}

public:
    HRESULT AddString(const char *pszText, int *piIndex);
    HRESULT SetItemData(int iIndex, void *pvData);
    HRESULT GetItemData(int iIndex, void **ppvData);
    HRESULT GetItemCheck(int iIndex, VARIANT_BOOL *pbCheck);
    HRESULT SetItemCheck(int iIndex, VARIANT_BOOL bCheck);
    HRESULT GetNumberOfItems(int *piCount);

    HRESULT DrawItem(DRAWITEMSTRUCT *pDrawItemStruct, bool fChecked);

protected:
    static LRESULT CALLBACK ListBoxSubClass(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

protected:
    HRESULT DrawFocus(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc);
    HRESULT DrawCheckbox(HDC hdc, bool fChecked, bool fEnabled, RECT *prc);
    HRESULT DrawText(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc);
    HRESULT OnButtonDown(int ixPos, int iyPos);

protected:
    int     m_nCtrlID;
    HWND    m_hwnd;
    WNDPROC m_oldWinProc;
};

#endif  // _CHKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\common.h ===
//=--------------------------------------------------------------------------------------
// common.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Common header files for mssnapd that cannot be precompiled
//=-------------------------------------------------------------------------------------=

#include <ad98.h>
#include <ctrlobj.h>
#include <proppage.h>
#include <objext.h>
#include "..\..\mssnapr\mssnapr\error.h"
#include "..\..\mssnapr\mssnapr\errors.h"
#include "mssnapd.h"
#include "snaputil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\chklst.cpp ===
//=--------------------------------------------------------------------------------------
// chklst.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Multi-select list box with checkbox-like selection
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "chklst.h"

SZTHISFILE

// Checkbox bitmap selection (sections within the source bitmap):
const int kUnchecked         = 0;
const int kChecked           = 1;
const int kDisabledUnchecked = 2;
const int kDisabledChecked   = 3;

// Bitmap dimensions
const int LBOXCXCHECKBMP	 = 11;
const int LBOXCYCHECKBMP	 = 11;

const int kMaxBuffer         = 512;


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Class to store information about items in the checked list
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//=--------------------------------------------------------------------------------------
// CCheckedListItem::CCheckedListItem(bSelected)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckedListItem::CCheckedListItem(bool bSelected) : m_bSelected(bSelected)
{
}


//=--------------------------------------------------------------------------------------
// CCheckedListItem::~CCheckedListItem()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckedListItem::~CCheckedListItem()
{
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Checked list class
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//=--------------------------------------------------------------------------------------
// CCheckList::CCheckList(int nCtrlID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckList::CCheckList(int nCtrlID) : m_nCtrlID(nCtrlID), m_hwnd(0), m_oldWinProc(0)
{
}


//=--------------------------------------------------------------------------------------
// CCheckList::~CCheckList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckList::~CCheckList()
{
}


//=--------------------------------------------------------------------------------------
// CCheckList::Attach(HWND hwnd)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::Attach
(
    HWND hwnd
)
{
    HRESULT hr = S_OK;

    m_hwnd = hwnd;
    if (m_hwnd == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }

    m_oldWinProc = reinterpret_cast<WNDPROC>(::SetWindowLong(m_hwnd, GWL_WNDPROC, reinterpret_cast<LONG>(ListBoxSubClass)));
    ::SetWindowLong(m_hwnd, GWL_USERDATA, reinterpret_cast<LONG>(this));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::Detach()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::Detach()
{
    HRESULT hr = S_OK;

    ::SetWindowLong(m_hwnd, GWL_WNDPROC, reinterpret_cast<LONG>(m_oldWinProc));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::AddString(const char *pszText, int *piIndex)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::AddString
(
    const char *pszText,
    int        *piIndex
)
{
    HRESULT hr = S_OK;
    int     iReturnVal = 0;

    iReturnVal = ::SendMessage(m_hwnd, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(pszText));
    if (iReturnVal == LB_ERR)
    {
        hr = S_FALSE;
    }

    *piIndex = iReturnVal;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::SetItemData(int iIndex, void *pvData)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::SetItemData
(
    int   iIndex,
    void *pvData
)
{
    HRESULT hr = S_OK;
    int     iReturnVal = 0;

    iReturnVal = ::SendMessage(m_hwnd, LB_SETITEMDATA, static_cast<WPARAM>(iIndex), reinterpret_cast<LPARAM>(pvData));
    if (iReturnVal == LB_ERR)
    {
        hr = S_FALSE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::GetItemData(int iIndex, void **ppvData)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::GetItemData
(
    int    iIndex,
    void **ppvData
)
{
    HRESULT  hr = S_OK;
    void    *pvReturnVal = NULL;

    pvReturnVal = reinterpret_cast<void *>(::SendMessage(m_hwnd, LB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0));
    if (pvReturnVal == reinterpret_cast<void *>(LB_ERR))
    {
        hr = S_FALSE;
    }

    *ppvData = pvReturnVal;
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::GetItemCheck(int iIndex, VARIANT_BOOL &bCheck)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::GetItemCheck(int iIndex, VARIANT_BOOL *pbCheck)
{
    HRESULT     hr = S_OK;
    void                *pvReturnVal = NULL;
    CCheckedListItem    *pItem = NULL;

    pvReturnVal = reinterpret_cast<void *>(::SendMessage(m_hwnd, LB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0));
    if (pvReturnVal == reinterpret_cast<void *>(LB_ERR))
    {
        hr = S_FALSE;
    }

    pItem = reinterpret_cast<CCheckedListItem *>(pvReturnVal);
    *pbCheck = (true == pItem->m_bSelected) ? VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::SetItemCheck(int iIndex, VARIANT_BOOL bCheck)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::SetItemCheck(int iIndex, VARIANT_BOOL bCheck)
{
    HRESULT     hr = S_OK;
    void                *pvReturnVal = NULL;
    CCheckedListItem    *pItem = NULL;

    pvReturnVal = reinterpret_cast<void *>(::SendMessage(m_hwnd, LB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0));
    if (pvReturnVal == reinterpret_cast<void *>(LB_ERR))
    {
        hr = S_FALSE;
    }

    pItem = reinterpret_cast<CCheckedListItem *>(pvReturnVal);
    pItem->m_bSelected = (VARIANT_TRUE == bCheck) ? true : false;


    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::GetNumberOfItems(long *plCount)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::GetNumberOfItems(int *piCount)
{
    HRESULT     hr = S_OK;

    *piCount = ::SendMessage(m_hwnd, LB_GETCOUNT, 0, 0);
    if (LB_ERR == *piCount)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawCheckbox(HDC hdc, bool fChecked, bool fEnabled, RECT *prc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawCheckbox
(
    HDC   hdc,
    bool  fChecked,
    bool  fEnabled,
    RECT *prc
)
{
    HRESULT hr = S_OK;
    HBITMAP hbmpCheckmark = NULL;
    int     nBitmap = 0;
    int     cxSource = 0;
    int     cySource = 0;
    RECT    rc;
    HDC     hdcMem = NULL;
    HBITMAP hbmpOld = NULL;

    hbmpCheckmark = ::LoadBitmap(GetResourceHandle(), MAKEINTRESOURCE(IDB_BITMAP_CHECKBOX));
    if (hbmpCheckmark == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    if (fChecked == true)
    {
        if (fEnabled == false)
            nBitmap = kDisabledChecked;
        else
            nBitmap = kChecked;
    }
    else
    {
        if (fEnabled == false)
            nBitmap = kDisabledUnchecked;
        else
            nBitmap = kUnchecked;
    }

    cxSource = nBitmap * LBOXCXCHECKBMP;
    cySource = 0;
    rc = *prc;

    hdcMem = ::CreateCompatibleDC(hdc);
    if (hdcMem == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Center and left
    rc.top += (rc.bottom - rc.top - LBOXCYCHECKBMP) / 2;

    hbmpOld = SelectBitmap(hdcMem, hbmpCheckmark);
    ::BitBlt(hdc, rc.left, rc.top, LBOXCXCHECKBMP, LBOXCYCHECKBMP, hdcMem, cxSource, cySource, SRCCOPY);

    SelectBitmap(hdcMem, hbmpOld);
    ::DeleteDC(hdcMem);

    prc->left += LBOXCXCHECKBMP + 2;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawText(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawText
(
    DRAWITEMSTRUCT *pDrawItemStruct,
    RECT            rc
)
{
    HRESULT  hr = S_OK;
    int      iItemID = 0;
    int      iResult = 0;
    HBRUSH   hBrush = NULL;
    COLORREF crBkColor = 0;
    COLORREF crTextColor = 0;
    HPEN     hPenOld = NULL;
    HBRUSH   hBrushOld = NULL;
    char     pszBuffer[kMaxBuffer + 1];

    iItemID = static_cast<int>(pDrawItemStruct->itemID);

    if (iItemID != -1 && pDrawItemStruct->itemAction & (ODA_FOCUS | ODA_DRAWENTIRE))
    {
        // if this item has the focus, or has the caret, use highlight colors.
        // Otherwise, use normal window colors.
        if (pDrawItemStruct->itemState & ODS_FOCUS)
        {
            hBrush = ::CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
            crBkColor = ::GetSysColor(COLOR_HIGHLIGHT);
            crTextColor = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
        }
        else
        {
            hBrush = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
            crBkColor = ::GetSysColor(COLOR_WINDOW);
            crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
        }

        ::SetTextColor(pDrawItemStruct->hDC, crTextColor);

        // clear a rectangle for painting text and focus rectangles on
        if (::SetBkColor(pDrawItemStruct->hDC, crBkColor) == CLR_INVALID)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hPenOld = SelectPen(pDrawItemStruct->hDC, GetStockPen(NULL_PEN));
        if (hPenOld == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hBrushOld = SelectBrush(pDrawItemStruct->hDC, hBrush);
        if (hBrushOld == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        ::Rectangle(pDrawItemStruct->hDC, rc.left, rc.top, rc.right + 1, rc.bottom + 1);

        SelectPen(pDrawItemStruct->hDC, hPenOld);
        SelectBrush(pDrawItemStruct->hDC, hBrushOld);
    }

    pszBuffer[0] = '\0';
    ::SendMessage(m_hwnd,
                  LB_GETTEXT,
                  pDrawItemStruct->itemID,
                  reinterpret_cast<LPARAM>(&pszBuffer));

    if (::strlen(pszBuffer) > 0)
    {
        rc.left++;
        rc.right--;

        iResult = ::DrawText(pDrawItemStruct->hDC,
                             reinterpret_cast<const char *>(&pszBuffer),
                             -1,
                             &rc,
                             DT_VCENTER | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawFocus(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawFocus
(
    DRAWITEMSTRUCT *pDrawItemStruct,
    RECT            rc
)
{
    HRESULT hr = S_OK;

    if ((pDrawItemStruct->itemAction & (ODA_FOCUS | ODA_DRAWENTIRE)) && (pDrawItemStruct->itemState & ODS_FOCUS))
    {
        DrawFocusRect(pDrawItemStruct->hDC, &rc);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawItem
(
    DRAWITEMSTRUCT *pDrawItemStruct,
    bool            fChecked
)
{
    HRESULT hr = S_OK;
    RECT    rc;
    bool    fEnabled = true;

    ::SetRect(&rc,
              pDrawItemStruct->rcItem.left,
              pDrawItemStruct->rcItem.top,
              pDrawItemStruct->rcItem.right,
              pDrawItemStruct->rcItem.bottom);

    hr = DrawCheckbox(pDrawItemStruct->hDC, fChecked, fEnabled, &rc);
    IfFailGo(hr);

    hr = DrawText(pDrawItemStruct, rc);
    IfFailGo(hr);

    hr = DrawFocus(pDrawItemStruct, rc);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::OnButtonDown(int ixPos, int iyPos)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::OnButtonDown(int ixPos, int iyPos)
{
    HRESULT           hr = S_OK;
    POINT             pt;
    long              lResult = 0;
    int               iIndex = 0;
    RECT              rc;
    CCheckedListItem *pCheckedListItem = NULL;

    pt.x = ixPos;
    pt.y = iyPos;

    lResult = ::SendMessage(m_hwnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(ixPos, iyPos));
    if (HIWORD(lResult) == 0)
    {
        iIndex = LOWORD(lResult);

        lResult = ::SendMessage(m_hwnd, LB_GETITEMRECT, static_cast<WPARAM>(iIndex), reinterpret_cast<LPARAM>(&rc));
        if (lResult != LB_ERR)
        {
            rc.right = rc.left + LBOXCXCHECKBMP;
            rc.bottom = rc.top + LBOXCYCHECKBMP;

            if (PtInRect(&rc, pt) == TRUE)
            {
                hr = GetItemData(iIndex, reinterpret_cast<void **>(&pCheckedListItem));
                IfFailGo(hr);

                if (pCheckedListItem->m_bSelected == true)
                    pCheckedListItem->m_bSelected = false;
                else
                    pCheckedListItem->m_bSelected = true;

                ::PostMessage(::GetParent(m_hwnd), kCheckBoxChanged, static_cast<WPARAM>(iIndex), 0);
            }
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::ListBoxSubClass(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
LRESULT CALLBACK CCheckList::ListBoxSubClass
(
    HWND   hwnd,
    UINT   iMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT      hr = S_OK;
    CCheckList  *pList = NULL;

    pList = reinterpret_cast<CCheckList *>(::GetWindowLong(hwnd, GWL_USERDATA));
    ASSERT(pList != NULL, "ListBoxSubClass: Cannot recover class");

    switch (iMsg)
    {
    case WM_LBUTTONDOWN:
        hr = pList->OnButtonDown(LOWORD(lParam), HIWORD(lParam));
        IfFailGo(hr);
        break;
    }

Error:
    return ::CallWindowProc(pList->m_oldWinProc, hwnd, iMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desdebug.cpp ===
//=--------------------------------------------------------------------------------------
// dedebug.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// IDesignerDebugging Implementation.
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "desmain.h"

//=--------------------------------------------------------------------------=
//                  IDesignerDebugging Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CSnapInDesigner::BeforeRun(LPVOID FAR* ppvData)
{
    return S_OK;
}

STDMETHODIMP CSnapInDesigner::AfterRun(LPVOID pvData)
{
    return S_OK;
}


STDMETHODIMP CSnapInDesigner::GetStartupInfo(DESIGNERSTARTUPINFO * pStartupInfo)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\datafmt.cpp ===
//=--------------------------------------------------------------------------------------
// datafmt.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- DataFormat-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Manipulating existing IDataFormat's
// Adding, initializing, renaming, deleting and refreshing
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetNewResourceName(BSTR *pbstrResourceFileName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetNewResourceName(BSTR *pbstrResourceFileName)
{
    HRESULT              hr = S_OK;
    OPENFILENAME         ofn;
    TCHAR                szFile[260];

    szFile[0] = 0;

    ::memset(&ofn, 0, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = _T("XML Files\0*.xml\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (TRUE == ::GetOpenFileName(&ofn))
    {
        hr = BSTRFromANSI(szFile, pbstrResourceFileName);
        IfFailGo(hr);
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddResource()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddResource()
{
    HRESULT              hr = S_OK;
    BSTR                 bstrResourceFileName = NULL;
    IDataFormats        *piDataFormats = NULL;
    VARIANT              vtEmpty;
    VARIANT              vtFileName;
    IDataFormat         *piDataFormat = NULL;

    ::VariantInit(&vtEmpty);
    ::VariantInit(&vtFileName);

    hr = GetNewResourceName(&bstrResourceFileName);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piSnapInDesignerDef->get_DataFormats(&piDataFormats);
        IfFailGo(hr);

        if (piDataFormats != NULL)
        {
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            vtFileName.vt = VT_BSTR;
            vtFileName.bstrVal = ::SysAllocString(bstrResourceFileName);
            if (NULL == vtFileName.bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK(hr);
            }

            hr = piDataFormats->Add(vtEmpty, vtEmpty, vtFileName, &piDataFormat);
            IfFailGo(hr);
        }
    }

Error:
    ::VariantClear(&vtFileName);
    ::VariantClear(&vtEmpty);
    FREESTRING(bstrResourceFileName);
    RELEASE(piDataFormat);
    RELEASE(piDataFormats);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddDataFormat(CSelectionHolder *pParent, IDataFormat *piDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddDataFormat(CSelectionHolder *pParent, IDataFormat *piDataFormat)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pDataFormat = NULL;

    ASSERT(NULL != pParent, "OnAddDataFormat: pParent is NULL");
    ASSERT(SEL_XML_RESOURCES == pParent->m_st, "OnAddDataFormat: pParent is not SEL_XML_RESOURCES");
    ASSERT(NULL != piDataFormat, "OnAddDataFormat: piDataFormat is NULL");

    hr = MakeNewDataFormat(piDataFormat, &pDataFormat);
    IfFailGo(hr);

    hr = pDataFormat->RegisterHolder();
    IfFailGo(hr);

    hr = InsertDataFormatInTree(pDataFormat, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pDataFormat);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pDataFormat);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pDataFormat);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameDataFormat(CSelectionHolder *pDataFormat, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameDataFormat(CSelectionHolder *pDataFormat, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrOldName = NULL;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_XML_RESOURCE_NAME == pDataFormat->m_st, "RenameToolbar: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pDataFormat->m_piObject.m_piDataFormat->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = m_pTreeView->GetLabel(pDataFormat, &bstrOldName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pDataFormat, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteDataFormat(CSelectionHolder *pDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteDataFormat(CSelectionHolder *pDataFormat)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    BSTR                 bstrName = NULL;
    VARIANT              vtKey;

    ::VariantInit(&vtKey);

    // Find out who the parent is
    hr = m_pTreeView->GetParent(pDataFormat, &pParent);
    IfFailGo(hr);

    // Remove the ImageList from the appropriate collection
    ASSERT(SEL_XML_RESOURCES == pParent->m_st, "DeleteToolbar: expected another kind of parent");

    hr = pDataFormat->m_piObject.m_piDataFormat->get_Name(&bstrName);
    IfFailGo(hr);

    if (pParent->m_piObject.m_piDataFormats != NULL)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = pParent->m_piObject.m_piDataFormats->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtKey);
    FREESTRING(bstrName);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteDataFormat(CSelectionHolder *pDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteDataFormat(CSelectionHolder *pDataFormat)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IDataFormats        *piDataFormats = NULL;
    long                 lCount = 0;

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pDataFormat, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pDataFormat);
    IfFailGo(hr);

    delete pDataFormat;

    // Select the next selection
    hr = m_piSnapInDesignerDef->get_DataFormats(&piDataFormats);
    IfFailGo(hr);

    if (NULL != piDataFormats)
    {
        hr = piDataFormats->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piDataFormats);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RefreshResource(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RefreshResource(CSelectionHolder *pSelection)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewDataFormat(IDataFormat *piDataFormat, CSelectionHolder **ppDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewDataFormat(IDataFormat *piDataFormat, CSelectionHolder **ppDataFormat)
{
    HRESULT              hr = S_OK;

    *ppDataFormat = New CSelectionHolder(piDataFormat);
    if (*ppDataFormat == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewDataFormat(piDataFormat);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewDataFormat(IDataFormat *piDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewDataFormat(IDataFormat *piDataFormat)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pDataFormatClone = NULL;

    hr = GetResourceString(IDS_DATAFORMAT, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pDataFormatClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piDataFormat->put_Name(bstrName);
    IfFailGo(hr);

    hr = piDataFormat->put_Key(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertDataFormatInTree(CSelectionHolder *pDataFormat, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertDataFormatInTree(CSelectionHolder *pDataFormat, CSelectionHolder *pParent)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pDataFormat->m_piObject.m_piDataFormat->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kDataFmtIcon, pDataFormat);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desmain.h ===
//=--------------------------------------------------------------------------------------
// desmain.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDesigner definition.
//=-------------------------------------------------------------------------------------=

#ifndef _SNAPINDESIGNER_H_

#include "ambients.h"
#include "TreeView.h"
#include "destlib.h"


// UNDONE: REMOVE: When ssulzer puts this in a public header
// We cannot include this directly from vb98\ruby\errvb.h because
// it will pull in other headers with various macros that are
// defined in vb98ctls\include\macros.h and cause a redefinition error.

#ifndef VB_E_IDADONTREPORTME
#define VB_E_IDADONTREPORTME          0x800AEA5FL
#endif


// Message used in our designer at startup
const int CMD_SHOW_MAIN_PROPERTIES      = (WM_USER + 1);      // show props immediately

// Custom message to select views
const int CMD_ADD_EXISTING_VIEW         = (WM_USER + 2);

// Custom message to handle label renames
const int CMD_RENAME_NODE               = (WM_USER + 3);


// Handy definitions for WinProc handling
#define WinProcHandled(bVal)            hr = S_OK; *lResult = (bVal);


////////////////////////////////////////////////////////////////////////////////////
//
// Class MMCViewMenuInfo
//
////////////////////////////////////////////////////////////////////////////////////
class MMCViewMenuInfo
{
public:
    enum MMCViewMenuInfoType { vmitListView = 0, vmitOCXView, vmitURLView, vmitTaskpad };

    MMCViewMenuInfoType m_vmit;
    union
    {
        IListViewDef    *m_piListViewDef;
        IOCXViewDef     *m_piOCXViewDef;
        IURLViewDef     *m_piURLViewDef;
        ITaskpadViewDef *m_piTaskpadViewDef;
    } m_view;

    MMCViewMenuInfo(IListViewDef *piListViewDef) : m_vmit(vmitListView) {
        m_view.m_piListViewDef = piListViewDef;
    }

    MMCViewMenuInfo(IOCXViewDef *piOCXViewDef) : m_vmit(vmitOCXView) {
        m_view.m_piOCXViewDef = piOCXViewDef;
    }

    MMCViewMenuInfo(IURLViewDef *piURLViewDef) : m_vmit(vmitURLView) {
        m_view.m_piURLViewDef = piURLViewDef;
    }

    MMCViewMenuInfo(ITaskpadViewDef *piTaskpadViewDef) : m_vmit(vmitTaskpad) {
        m_view.m_piTaskpadViewDef = piTaskpadViewDef;
    }

    ~MMCViewMenuInfo() { }
};


//=--------------------------------------------------------------------------=
// CSnapInDesigner - The snap-in designer main class. An object of this
// class is created when the designer is added to a VB project.
//=--------------------------------------------------------------------------=

class CSnapInDesigner : public COleControl,
                        public IDispatch,
                        public IActiveDesigner,
                        public IProvideDynamicClassInfo,
                        public ISelectionContainer,
                        public IDesignerDebugging,
                        public IDesignerRegistration,
                        public IObjectModelHost,
                        public CError
{
public:
    CSnapInDesigner(IUnknown *pUnkOuter);
    virtual ~CSnapInDesigner();

    // Static creation function. All controls must have one of these!
    //
    static IUnknown *Create(IUnknown *);
    static HRESULT PreCreateCheck();

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IDispatch methods
    //
    DECLARE_STANDARD_DISPATCH();

    // ISupportErrorInfo methods
    //
    DECLARE_STANDARD_SUPPORTERRORINFO();

    // IActiveDesigner methods
    //
    STDMETHOD(GetRuntimeClassID)(THIS_ CLSID *pclsid);
    STDMETHOD(GetRuntimeMiscStatusFlags)(THIS_ DWORD *pdwMiscFlags);
    STDMETHOD(QueryPersistenceInterface)(THIS_ REFIID riidPersist);
    STDMETHOD(SaveRuntimeState)(THIS_ REFIID riidPersist, REFIID riidObjStgMed, void *pObjStgMed);
    STDMETHOD(GetExtensibilityObject)(THIS_ IDispatch **ppvObjOut);

    // IProvideDynamicClassInfo
    //
    STDMETHOD(GetDynamicClassInfo)(ITypeInfo **ppTypeInfo, DWORD *pdwCookie);
    STDMETHOD(FreezeShape)(void);

    // IProvideClassInfo
    //
    STDMETHOD(GetClassInfo)(ITypeInfo **ppTypeInfo);

    // ISelectionContainer
    //
    STDMETHOD(CountObjects)(DWORD dwFlags, ULONG *pc);
    STDMETHOD(GetObjects)(DWORD dwFlags, ULONG cObjects, IUnknown **apUnkObjects);
    STDMETHOD(SelectObjects)(ULONG cSelect, IUnknown **apUnkSelect, DWORD dwFlags);

    // IDesignerDebugging
    //
    STDMETHOD(BeforeRun)(LPVOID FAR* ppvData);
    STDMETHOD(AfterRun)(LPVOID pvData);
    STDMETHOD(GetStartupInfo)(DESIGNERSTARTUPINFO * pStartupInfo);

    // IDesignerRegistration
    //
    STDMETHOD(GetRegistrationInfo)(BYTE** ppbRegInfo, ULONG* pcbRegInfo);

    // IOleControlSite overide
    // 
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);

    // IPersistStreamInit overide
    //
    STDMETHOD(IsDirty)();

    // IObjectModelHost
    //
    STDMETHOD(Update)(long ObjectCookie, IUnknown *punkObject, DISPID dispid);
    STDMETHOD(Add)(long CollectionCookie, IUnknown *punkNewObject);
    STDMETHOD(Delete)(long ObjectCookie, IUnknown *punkObject);
    STDMETHOD(GetSnapInDesignerDef)(ISnapInDesignerDef **ppiSnapInDesignerDef);
    STDMETHOD(GetRuntime)(BOOL *pfRuntime);

public:

    // Utilities provided by this class for the whole designer

    CAmbients *GetAmbients();
    HRESULT AttachAmbients();
    HRESULT UpdateDesignerName();
    HRESULT ValidateName(BSTR bstrName);

protected:

    // Base Control Overidable - Designer window is to be created
    virtual BOOL    BeforeCreateWindow(DWORD *pdwWindowStyle, DWORD *pdwExWindowStyle, LPSTR pszWindowTitle);
    // Base Control Overidable - Designer window is created
    virtual BOOL    AfterCreateWindow(void);
    // Base Control Overidable - Designer window is about to be destroyed
    void BeforeDestroyWindow();
    // Base Control Overidable - IPersistStreamInit::InitNew was called
    virtual BOOL    InitializeNewState();
    // Base Control Overidable - IViewObject::Draw overidable from base control
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize);
    // Base Control Overidable - Designer's window procedure
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
    // Base Control Overidable - Register control Window Classes
    virtual BOOL    RegisterClassData(void);
    // Base Control Overidable - Internal QI
    virtual HRESULT InternalQueryInterface(REFIID, void **);
    // Base Control Overidable - Called when site calls IOleObject::SetClientSite()
    virtual HRESULT OnSetClientSite();

    // Base Control Overidable - Load binary state
    STDMETHOD(LoadBinaryState)(IStream *pStream);
    // Base Control Overidable - Save binary state
    STDMETHOD(SaveBinaryState)(IStream *pStream);
    // Base Control Overidable - Load text state
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    // Base Control Overidable - Save text state
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault);


////////////////////////////////////////////////////////////////////////////////////
// WinProc and friends, implemented in winproc.cpp
protected:
    HRESULT InitializeToolbar();

    HRESULT OnResize(UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT OnCommand(UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT OnNotify(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lResult);
    HRESULT OnNeedText(LPARAM lParam);
    HRESULT OnDoubleClick(CSelectionHolder *pSelection);
    HRESULT OnPrepareToolbar();
    HRESULT OnContextMenu(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT DoOnContextMenu(int x, int y);
    HRESULT OnInitMenuPopup(HMENU hmenuPopup);
    HRESULT OnKeyDown(NMTVKEYDOWN *pNMTVKeyDown);
    void OnHelp();

    HRESULT OnInitMenuPopupRoot(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupExtensionRoot(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupExtension(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupMyExtensions(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupStaticNode(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupNodeOther(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupNode(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupNodeChildren(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupNodeViews(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupToolsRoot(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupImageLists(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupImageList(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupMenus(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupMenu(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupToolbars(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupToolbar(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupListViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupOCXViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupURLViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupTaskpadViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupView(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupResources(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupResourceName(HMENU hmenuPopup);

    // The following helper functions are used to construct the dynamic view menu
    HRESULT AddViewToViewMenu(HMENU hMenu, int iMenuItem, char *pszMenuItemText, MMCViewMenuInfo *pMMCViewMenuInfo);

    HRESULT FindListViewInCollection(BSTR bstrName, IListViewDefs *piListViewDefs);
    HRESULT PopulateListViews(HMENU hMenu, int *piCurrentMenuItem, IListViewDefs *piListViewDefs, IListViewDefs *piTargetListViewDefs);

    HRESULT FindOCXViewInCollection(BSTR bstrName, IOCXViewDefs *piOCXViewDefs);
    HRESULT PopulateOCXViews(HMENU hMenu, int *piCurrentMenuItem, IOCXViewDefs *piOCXViewDefs, IOCXViewDefs *piTargetOCXViewDefs);

    HRESULT FindURLViewInCollection(BSTR bstrName, IURLViewDefs *piURLViewDefs);
    HRESULT PopulateURLViews(HMENU hMenu, int *piCurrentMenuItem, IURLViewDefs *piURLViewDefs, IURLViewDefs *piTargetURLViewDefs);

    HRESULT FindTaskpadViewInCollection(BSTR bstrName, ITaskpadViewDefs *piTaskpadViewDefs);
    HRESULT PopulateTaskpadViews(HMENU hMenu, int *piCurrentMenuItem, ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDefs *piTargetTaskpadViewDefs);

    HRESULT PopulateNodeViewsMenu(HMENU hmenuPopup);
    HRESULT CleanPopupNodeViews(HMENU hmenuPopup, int iCmd);

    HWND                 m_hwdToolbar;
    RECT                 m_rcToolbar;


////////////////////////////////////////////////////////////////////////////////////
// Initializing and populating the tree, implemented in tvpopul.cpp
protected:
    HRESULT CreateTreeView();
    HRESULT InitializePresentation();

    HRESULT CreateExtensionsTree(CSelectionHolder *pRoot);
    HRESULT PopulateExtensions(CSelectionHolder *pExtensionsParent);
    HRESULT CreateExtendedSnapIn(CSelectionHolder *pRoot, IExtendedSnapIn *piExtendedSnapIn);
    HRESULT PopulateExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT PopulateSnapInExtensions(CSelectionHolder *pRoot, IExtensionDefs *piExtensionDefs);

    HRESULT CreateNodesTree(CSelectionHolder *pRoot);
    HRESULT PopulateNodes(CSelectionHolder *pNodesParent);
    HRESULT PopulateAutoCreateNodes(CSelectionHolder *pAutoCreateNodesParent);
    HRESULT CreateAutoCreateSubTree(CSelectionHolder *pAutoCreateNodesParent);
    HRESULT RemoveAutoCreateSubTree();
    HRESULT DeleteSubTree(CSelectionHolder *pNode);
    HRESULT PopulateStaticNodeTree(CSelectionHolder *pStaticNode);
    HRESULT PopulateOtherNodes(CSelectionHolder *pOtherNodesParent);

    HRESULT CreateToolsTree(CSelectionHolder *pRoot);
    HRESULT InitializeToolsTree(CSelectionHolder *pToolsParent);
    HRESULT PopulateImageLists(CSelectionHolder *pImageListsParent);
    HRESULT PopulateMenus(CSelectionHolder *pMenusParent, IMMCMenus *piMMCMenus);
    HRESULT PopulateToolbars(CSelectionHolder *pToolbarsParent);

    HRESULT CreateViewsTree(CSelectionHolder *pRoot);
    HRESULT InitializeViews(CSelectionHolder *pViewsParent);

    HRESULT CreateDataFormatsTree(CSelectionHolder *pRoot);
    HRESULT PopulateDataFormats(CSelectionHolder *pRoot, IDataFormats *piDataFormats);

    HRESULT PopulateListViews(IViewDefs *piViewDefs, CSelectionHolder *pListViewsParent);
    HRESULT PopulateOCXViews(IViewDefs *piViewDefs, CSelectionHolder *pOCXViewsParent);
    HRESULT PopulateURLViews(IViewDefs *piViewDefs, CSelectionHolder *pURLViewsParent);
    HRESULT PopulateTaskpadViews(IViewDefs *piViewDefs, CSelectionHolder *pTaskpadViewsParent);

    HRESULT RegisterViewCollections(CSelectionHolder *pSelection, IViewDefs *piViewDefs);
    HRESULT PopulateNodeTree(CSelectionHolder *pNodeParent, IScopeItemDef *piScopeItemDef);
    HRESULT GetSnapInName(char **ppszNodeName);

private:
    // Tree nodes we cache throughout the lifetime of the designer
    CSelectionHolder    *m_pRootNode;
    CSelectionHolder    *m_pRootNodes;
    CSelectionHolder    *m_pRootExtensions;
    CSelectionHolder    *m_pRootMyExtensions;
    CSelectionHolder    *m_pStaticNode;
    CSelectionHolder	*m_pAutoCreateRoot;
    CSelectionHolder	*m_pOtherRoot;

    CSelectionHolder    *m_pViewListRoot;
    CSelectionHolder    *m_pViewOCXRoot;
    CSelectionHolder    *m_pViewURLRoot;
    CSelectionHolder    *m_pViewTaskpadRoot;

    CSelectionHolder    *m_pToolImgLstRoot;
    CSelectionHolder    *m_pToolMenuRoot;
    CSelectionHolder    *m_pToolToolbarRoot;


////////////////////////////////////////////////////////////////////////////////////
// Object Model notifications handlers
protected:
    HRESULT OnSnapInChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnMyExtensionsChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnExtendedSnapInChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnScopeItemChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnListViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnOCXViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnURLViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnTaskpadViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnImageListChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnMenuChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnToolbarChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnDataFormatChange(CSelectionHolder *pSelection, DISPID dispid);


////////////////////////////////////////////////////////////////////////////////////
// Command handlers
protected:
    // Command multiplexers, file tvcmd.cpp
    HRESULT AddExistingView(MMCViewMenuInfo *pMMCViewMenuInfo);
    HRESULT DoRename(CSelectionHolder *pSelection, TCHAR *pszNewName);
    HRESULT DoDelete(CSelectionHolder *pSelection);
    HRESULT ShowProperties(CSelectionHolder *pSelection);

    // Manipulating the ISnapInDef, file tvcmd.cpp
    HRESULT RenameSnapIn(CSelectionHolder *pSnapIn, BSTR bstrNewName);
    HRESULT ShowSnapInProperties();
    HRESULT ShowSnapInExtensions();

    //
    // Manipulating IExtendedSnapIn's, implemented in file extend.cpp
    // Extending others
    HRESULT OnAddExtendedSnapIn(CSelectionHolder *pParent, IExtendedSnapIn *piExtendedSnapIn);
    HRESULT RenameExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionNode(SelectionType stExtensionType,
                                CSelectionHolder *pParent);

    HRESULT DoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);

    HRESULT DeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);

    // Extending myself
    HRESULT DoMyExtendsNewMenu(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsNewMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsTaskMenu(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsTaskMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsTopMenu(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsTopMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsViewMenu(CSelectionHolder *pMyExtensions);
    HRESULT OnDoMyExtendsViewMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsPPages(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsPPages(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsToolbar(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsToolbar(CSelectionHolder *pSelection);
    HRESULT DoMyExtendsNameSpace(CSelectionHolder *pMyExtensions);
    HRESULT OnDoMyExtendsNameSpace(CSelectionHolder *pMyExtensions);

    HRESULT DeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn);

    HRESULT FindMyExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension);
    HRESULT FindExtension(CSelectionHolder *pRoot, SelectionType stExtensionType,
                          CSelectionHolder **ppExtension);
    //
    // Manipulating IScopeItemDef's, implemented in file scpitm.cpp
    HRESULT AddNewNode();
    HRESULT OnAddScopeItemDef(CSelectionHolder *pParent, IScopeItemDef *piScopeItemDef);
    HRESULT RenameScopeItem(CSelectionHolder *pScopeItem, BSTR bstrNewName);
    HRESULT DeleteScopeItem(CSelectionHolder *pScopeItem);
    HRESULT CanDeleteScopeItem(CSelectionHolder *pScopeItem);
    HRESULT OnDeleteScopeItem(CSelectionHolder *pScopeItem);
    HRESULT ShowNodeProperties(IScopeItemDef *piScopeItemDef);

    HRESULT MakeNewNode(CSelectionHolder *pParent, IScopeItemDef *piScopeItemDef, CSelectionHolder **ppNode);
    HRESULT InitializeNewAutoCreateNode(IScopeItemDef *piScopeItemDef);
    HRESULT InitializeNewOtherNode(IScopeItemDef *piScopeItemDef);
	HRESULT IsAutoCreateChild(CSelectionHolder *pSelection);
    HRESULT InitializeNewChildNode(IScopeItemDef *piScopeItemDef, IScopeItemDefs *piScopeItemDefs);
    HRESULT InsertNodeInTree(CSelectionHolder *pNode, CSelectionHolder *pParent);

    HRESULT GetScopeItemCollection(CSelectionHolder *pScopeItem, IScopeItemDefs **ppiScopeItemDefs);

    //
    // Manipulating IListViewDefs's, implemented in file listvw.cpp
    HRESULT AddListView();
    HRESULT OnAddListViewDef(CSelectionHolder *pParent, IListViewDef *piListViewDef);
    HRESULT AddExistingListView(IViewDefs *piViewDefs, IListViewDef *piListViewDef);
    HRESULT RenameListView(CSelectionHolder *pListView, BSTR bstrNewName);
    HRESULT DeleteListView(CSelectionHolder *pListView);
    HRESULT OnDeleteListView(CSelectionHolder *pListView);
    HRESULT ShowListViewProperties(IListViewDef *piListViewDef);

    HRESULT MakeNewListView(IListViewDefs *piListViewDefs, IListViewDef *piListViewDef, CSelectionHolder **ppListView);
    HRESULT InitializeNewListView(IListViewDefs *piListViewDefs, CSelectionHolder *pListView);
    HRESULT InsertListViewInTree(CSelectionHolder *pListView, CSelectionHolder *pParent);

    //
    // Manipulating IOCXViewDefs's, implemented in file ocxvw.cpp
    HRESULT AddOCXView();
    HRESULT OnAddOCXViewDef(CSelectionHolder *pParent, IOCXViewDef *piOCXViewDef);
    HRESULT AddExistingOCXView(IViewDefs *piViewDefs, IOCXViewDef *piOCXViewDef);
    HRESULT RenameOCXView(CSelectionHolder *pOCXView, BSTR bstrNewName);
    HRESULT DeleteOCXView(CSelectionHolder *pOCXView);
    HRESULT OnDeleteOCXView(CSelectionHolder *pOCXView);
    HRESULT ShowOCXViewProperties(IOCXViewDef *piOCXViewDef);

    HRESULT MakeNewOCXView(IOCXViewDefs *piOCXViewDefs, IOCXViewDef *piOCXViewDef, CSelectionHolder **ppOCXView);
    HRESULT InitializeNewOCXView(IOCXViewDefs *piOCXViewDefs, CSelectionHolder *pOCXView);
    HRESULT InsertOCXViewInTree(CSelectionHolder *pOCXView, CSelectionHolder *pParent);

    //
    // Manipulating IURLViewDefs's, implemented in file urlvw.cpp
    HRESULT AddURLView();
    HRESULT OnAddURLViewDef(CSelectionHolder *pParent, IURLViewDef *piURLViewDef);
    HRESULT AddExistingURLView(IViewDefs *piViewDefs, IURLViewDef *piURLViewDef);
    HRESULT RenameURLView(CSelectionHolder *pURLView, BSTR bstrNewName);
    HRESULT DeleteURLView(CSelectionHolder *pURLView);
    HRESULT OnDeleteURLView(CSelectionHolder *pURLView);
    HRESULT ShowURLViewProperties(IURLViewDef *piURLViewDef);

    HRESULT MakeNewURLView(IURLViewDefs *piURLViewDefs, IURLViewDef *piURLViewDef, CSelectionHolder **ppURLView);
    HRESULT InitializeNewURLView(IURLViewDefs *piURLViewDefs, CSelectionHolder *pURLView);
    HRESULT InsertURLViewInTree(CSelectionHolder *pURLView, CSelectionHolder *pParent);

    //
    // Manipulating ITaskpadViewDefs's, implemented in file taskpvw.cpp
    HRESULT AddTaskpadView();
    HRESULT OnAddTaskpadViewDef(CSelectionHolder *pParent, ITaskpadViewDef *piTaskpadViewDef);
    HRESULT AddExistingTaskpadView(IViewDefs *piViewDefs, ITaskpadViewDef *piTaskpadViewDef);
    HRESULT RenameTaskpadView(CSelectionHolder *pTaskpadView, BSTR bstrNewName);
    HRESULT DeleteTaskpadView(CSelectionHolder *pTaskpadView);
    HRESULT OnDeleteTaskpadView(CSelectionHolder *pTaskpadView);
    HRESULT ShowTaskpadViewProperties(ITaskpadViewDef *piTaskpadViewDef);

    HRESULT MakeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDef *piTaskpadViewDef, CSelectionHolder **ppTaskpadView);
    HRESULT InitializeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, CSelectionHolder *pTaskpadView);
    HRESULT InsertTaskpadViewInTree(CSelectionHolder *pTaskpadView, CSelectionHolder *pParent);

    //
    // IViewDef's helpers, implemented in file taskpvw.cpp
    HRESULT GetOwningViewCollection(IViewDefs **ppiViewDefs);
    HRESULT GetOwningViewCollection(CSelectionHolder *pView, IViewDefs **ppiViewDefs);
    HRESULT IsSatelliteView(CSelectionHolder *pView);
    HRESULT IsSatelliteCollection(CSelectionHolder *pViewCollection);

    //
    // Manipulating IMMCImageList's, implemented in file imglist.cpp
    HRESULT AddImageList();
    HRESULT OnAddMMCImageList(CSelectionHolder *pParent, IMMCImageList *piMMCImageList);
    HRESULT RenameImageList(CSelectionHolder *pImageList, BSTR bstrNewName);
    HRESULT DeleteImageList(CSelectionHolder *pImageList);
    HRESULT OnDeleteImageList(CSelectionHolder *pImageList);
    HRESULT ShowImageListProperties(IMMCImageList *piMMCImageList);

    HRESULT MakeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList, CSelectionHolder **ppImageList);
    HRESULT InitializeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList);
    HRESULT InsertImageListInTree(CSelectionHolder *pImageList, CSelectionHolder *pParent);

    //
    // Manipulating IMMCMenu's, implemented in file menu.cpp
    HRESULT AddMenu(CSelectionHolder *pSelection);
    HRESULT DemoteMenu(CSelectionHolder *pMenu);
    HRESULT PromoteMenu(CSelectionHolder *pMenu);
    HRESULT MoveMenuUp(CSelectionHolder *pMenu);
    HRESULT MoveMenuDown(CSelectionHolder *pMenu);
    HRESULT OnAddMMCMenu(CSelectionHolder *pParent, IMMCMenu *piMMCMenu);
    HRESULT RenameMenu(CSelectionHolder *pMenu, BSTR bstrNewName);
    HRESULT DeleteMenu(CSelectionHolder *pMenu);
    HRESULT OnDeleteMenu(CSelectionHolder *pMenu);

    HRESULT MakeNewMenu(IMMCMenu *piMMCMenu, CSelectionHolder **ppMenu);
    HRESULT InitializeNewMenu(IMMCMenu *piMMCMenu);
    HRESULT InsertMenuInTree(CSelectionHolder *pMenu, CSelectionHolder *pParent);
    HRESULT DeleteMenuTreeTypeInfo(IMMCMenu *piMMCMenu);
            
    HRESULT AssignMenuDispID(CSelectionHolder *pMenuTarget, CSelectionHolder *pMenuSrc);
    HRESULT SetMenuKey(CSelectionHolder *pMenu);
	HRESULT UnregisterMenuTree(CSelectionHolder *pMenu);
    HRESULT IsTopLevelMenu(CSelectionHolder *pMenu);
    HRESULT CanPromoteMenu(CSelectionHolder *pMenu);
    HRESULT CanDemoteMenu(CSelectionHolder *pMenu);
    HRESULT CanMoveMenuUp(CSelectionHolder *pMenu);
    HRESULT CanMoveMenuDown(CSelectionHolder *pMenu);

    //
    // Manipulating IMMCToolbar's, implemented in file toolbar.cpp
    HRESULT AddToolbar();
    HRESULT OnAddMMCToolbar(CSelectionHolder *pParent, IMMCToolbar *piMMCToolbar);
    HRESULT RenameToolbar(CSelectionHolder *pToolbar, BSTR bstrNewName);
    HRESULT DeleteToolbar(CSelectionHolder *pToolbar);
    HRESULT OnDeleteToolbar(CSelectionHolder *pToolbar);
    HRESULT ShowToolbarProperties(IMMCToolbar *piMMCToolbar);

    HRESULT MakeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar, CSelectionHolder **ppToolbar);
    HRESULT InitializeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar);
    HRESULT InsertToolbarInTree(CSelectionHolder *pToolbar, CSelectionHolder *pParent);

    //
    // Manipulating IDataFormat's, implemented in file datafmt.cpp
    HRESULT AddResource();
    HRESULT OnAddDataFormat(CSelectionHolder *pParent, IDataFormat *piDataFormat);
    HRESULT RenameDataFormat(CSelectionHolder *pDataFormat, BSTR bstrNewName);
    HRESULT DeleteDataFormat(CSelectionHolder *pDataFormat);
    HRESULT OnDeleteDataFormat(CSelectionHolder *pDataFormat);
    HRESULT RefreshResource(CSelectionHolder *pSelection);

    HRESULT GetNewResourceName(BSTR *pbstrResourceFileName);
    HRESULT MakeNewDataFormat(IDataFormat *piDataFormat, CSelectionHolder **ppDataFormat);
    HRESULT InitializeNewDataFormat(IDataFormat *piDataFormat);
    HRESULT InsertDataFormatInTree(CSelectionHolder *pDataFormat, CSelectionHolder *pParent);

    // Dialog Unit converter dialog box (dlgunits.cpp)
    HRESULT ShowDlgUnitConverter();


private:
    int     m_iNextNodeNumber;
    bool    m_bDoingPromoteOrDemote;

////////////////////////////////////////////////////////////////////////////////////
// Selection handling
protected:
    HRESULT OnSelectionChanged(CSelectionHolder *pNewSelection);

private:
    CSelectionHolder    *m_pCurrentSelection;


////////////////////////////////////////////////////////////////////////////////////
// Implementation
private:

    void InitMemberVariables();
    HRESULT InitializeNewDesigner(ISnapInDef *piSnapInDef);

    HRESULT GetHostServices(BOOL fInteractive);
    HRESULT CreateExtensibilityModel();
    HRESULT DestroyExtensibilityModel();
    HRESULT SetObjectModelHost();
    HRESULT AddNodeType(INodeTypes *piNodeTypes, BSTR bstrName, BSTR bstrGUID);
    HRESULT AddNodeTypes(IScopeItemDefs *piScopeItemDefs, INodeTypes *piNodeTypes);
    HRESULT AddListViewNodeTypes(IListViewDefs *piListViewDefs, INodeTypes *piNodeTypes);


    BSTR                      m_bstrName;                  // Name of the designer
    ICodeNavigate2           *m_piCodeNavigate2;           // host service to navigate to code window
    ITrackSelection          *m_piTrackSelection;          // host service to inform VB of selection change
    IProfferTypeLib          *m_piProfferTypeLib;          // host service to add tlb to VB project's references
    IDesignerProgrammability *m_piDesignerProgrammability; // host service used to ensure valid property names
    IHelp                    *m_piHelp;                    // host service to display help topic
    CAmbients                 m_Ambients;                  // ambient dispatch wrapper

    ISnapInDesignerDef       *m_piSnapInDesignerDef;       // top of extensibility object model
    CTreeView                *m_pTreeView;                 // Our tree view
    CSnapInTypeInfo          *m_pSnapInTypeInfo;           // Dynamic type info
    BOOL                      m_bDidLoad;
};



DEFINE_CONTROLOBJECT3(SnapInDesigner,                  // name
                      &CLSID_SnapInDesigner,           // CLSID
                      "SnapIn",                        // ProgID
                      "SnapIn",                        // Registry display name
                      CSnapInDesigner::PreCreateCheck, // pre-create function
                      CSnapInDesigner::Create,         // create function
                      1,                               // major version
                      0,                               // minor version
                      &IID_IDispatch,                  // main interface
                      HELP_FILENAME,                   // help file name
                      NULL,                            // events interface
                      OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT | OLEMISC_INVISIBLEATRUNTIME,
                      0,                               // no IPointerInactive policy by default
                      IDB_TOOLBAR,                     // toolbox bitmap resource ID
                      "SnapInDesignerWndClass",        // Window class name
                      0,                               // no. of property pages
                      NULL,                            // property page GUIDs
                      0,                               // no. of custom verbs
                      NULL,                            // custom verb descriptions
                      TRUE);                           // thread safe


#define _SNAPINDESIGNER_H_
#endif // _SNAPINDESIGNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desreg.cpp ===
//=--------------------------------------------------------------------------------------
// register.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Registration functions.
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "desmain.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
//                  IDesignerRegistration Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRegistrationInfo         [IDesignerRegistration]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      BYTE  **ppbRegInfo [out] buffer containing data to pass to
//                               DllRegistration (CoTaskMemAlloc()ed)
//      ULONG  *pcbRegInfo [out] length of data
//
// Output:
//      HRESULT
//
// Notes:
//
// Populates the RegInfo object from SnapInDesignerDef and serializes it
// to a stream on an HGLOBAL and then copies it to CoTaskMemAlloc()ed buffer.
//
// RegInfo contains:
//      1) A NodeType collection with an item for each extensible node
//         defined by this snap-in. The first item in this collection is
//         always present and represents the snap-in's static node.
//      2) An ExtendedSnapIn collection with an item for each snap-in extended
//         by this snap-in.


STDMETHODIMP CSnapInDesigner::GetRegistrationInfo
(
    BYTE  **ppbRegInfo,
    ULONG  *pcbRegInfo
)
{
    HRESULT             hr = S_OK;
    IRegInfo           *piRegInfo= NULL;
    IPersistStreamInit *piPersistStreamInit = NULL;
    IPersistStream     *piPersistStream = NULL;
    ISnapInDef         *piSnapInDef = NULL;
    IScopeItemDefs     *piScopeItemDefs = NULL;
    IViewDefs          *piViewDefs = NULL;
    IListViewDefs      *piListViewDefs = NULL;
    INodeTypes         *piNodeTypes = NULL;
    IExtensionDefs     *piExtensionDefs = NULL;
    IExtendedSnapIns   *piExtendedSnapIns = NULL;
    HGLOBAL             hglobal = NULL;
    IStream            *piStream = NULL;
    BYTE               *pbBuffer = NULL;
    ULONG               cbBuffer = 0;
    BSTR                bstrName = NULL;
    BSTR                bstrGUID = NULL;
    SnapInTypeConstants Type = siStandAlone;
    VARIANT_BOOL        fStandAlone = VARIANT_FALSE;
    VARIANT_BOOL        fExtensible = VARIANT_FALSE;

    // Get the RegInfo object and InitNew it so we start clean

    IfFailGo(m_piSnapInDesignerDef->get_RegInfo(&piRegInfo));
    IfFailGo(piRegInfo->QueryInterface(IID_IPersistStreamInit,
                                       reinterpret_cast<void **>(&piPersistStreamInit)));
    IfFailGo(piPersistStreamInit->InitNew());

    // Get sub-objects we need
    
    IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));

    // Set the display name

    IfFailGo(piSnapInDef->get_DisplayName(&bstrName));
    IfFailGo(piRegInfo->put_DisplayName(bstrName));
    FREESTRING(bstrName);

    // Set the static node type GUID
    IfFailGo(piSnapInDef->get_NodeTypeGUID(&bstrGUID));
    IfFailGo(piRegInfo->put_StaticNodeTypeGUID(bstrGUID));
    // Don't free GUID here as it may be needed to register the node type

    // Determine whether the snap-in can be created standalone

    IfFailGo(piSnapInDef->get_Type(&Type));
    if (siExtension != Type)
    {
        fStandAlone = VARIANT_TRUE; // either stand-alone or dual-mode
    }
    IfFailGo(piRegInfo->put_StandAlone(fStandAlone));

    // Add an item to the node types collection for each node that is
    // extensible. Check the static node followed by the nodes collections.

    IfFailGo(piRegInfo->get_NodeTypes(&piNodeTypes));

    IfFailGo(piSnapInDef->get_Extensible(&fExtensible));
    if (VARIANT_TRUE == fExtensible)
    {
        IfFailGo(piSnapInDef->get_NodeTypeName(&bstrName));
        IfFailGo(AddNodeType(piNodeTypes, bstrName, bstrGUID));
        FREESTRING(bstrName);
        FREESTRING(bstrGUID);
    }

    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs));
    IfFailGo(AddNodeTypes(piScopeItemDefs, piNodeTypes));
    RELEASE(piScopeItemDefs);

    IfFailGo(m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs));
    IfFailGo(AddNodeTypes(piScopeItemDefs, piNodeTypes));

    IfFailGo(m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(AddListViewNodeTypes(piListViewDefs, piNodeTypes));

    // Borrow the extended snap-ins object from the designer for the
    // serialization
    
    IfFailGo(m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs));
    IfFailGo(piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns));
    IfFailGo(piRegInfo->putref_ExtendedSnapIns(piExtendedSnapIns));

    // Serialize the RegInfo object into a GlobalAlloc()ed buffer

    hr = ::CreateStreamOnHGlobal(NULL, // Allocate buffer
                                 TRUE, // Free buffer on release
                                 &piStream);
    EXCEPTION_CHECK_GO(hr);

    IfFailGo(piRegInfo->QueryInterface(IID_IPersistStream,
                                       reinterpret_cast<void **>(&piPersistStream)));
    IfFailGo(::OleSaveToStream(piPersistStream, piStream));

    // Get the HGLOBAL and copy the contents to a CoTaskMemAlloc()ed buffer
    
    hr = ::GetHGlobalFromStream(piStream, &hglobal);
    EXCEPTION_CHECK_GO(hr);

    cbBuffer = (ULONG)::GlobalSize(hglobal);
    if (0 == cbBuffer)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    pbBuffer = (BYTE *)::GlobalLock(hglobal);
    if (NULL == pbBuffer)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *ppbRegInfo = (BYTE *)::CoTaskMemAlloc(cbBuffer + sizeof(ULONG));
    if (NULL == *ppbRegInfo)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Put the length in the first ULONG followed by the stream contents

    *((ULONG *)(*ppbRegInfo)) = cbBuffer;

    ::memcpy(*ppbRegInfo + sizeof(ULONG), pbBuffer, cbBuffer);
    *pcbRegInfo = cbBuffer + sizeof(ULONG);

Error:
    if (FAILED(hr))
    {
        *ppbRegInfo = NULL;
        *pcbRegInfo = 0;
    }
    QUICK_RELEASE(piRegInfo);
    QUICK_RELEASE(piPersistStreamInit);
    QUICK_RELEASE(piPersistStream);
    QUICK_RELEASE(piSnapInDef);
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piNodeTypes);
    QUICK_RELEASE(piExtensionDefs);
    QUICK_RELEASE(piExtendedSnapIns);
    (void)::GlobalUnlock(hglobal);
    QUICK_RELEASE(piStream);
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);
    RRETURN(hr);
}





HRESULT CSnapInDesigner::AddNodeType
(
    INodeTypes *piNodeTypes,
    BSTR        bstrName,
    BSTR        bstrGUID
)
{
    HRESULT    hr = S_OK;
    INodeType *piNodeType = NULL;
    VARIANT    varUnspecified;
    ::VariantInit(&varUnspecified);

    varUnspecified.vt = VT_ERROR;
    varUnspecified.scode = DISP_E_PARAMNOTFOUND;

    IfFailGo(piNodeTypes->Add(varUnspecified, varUnspecified, &piNodeType));
    IfFailGo(piNodeType->put_Name(bstrName));
    IfFailGo(piNodeType->put_GUID(bstrGUID));

Error:
    QUICK_RELEASE(piNodeType);
    RRETURN(hr);
}



HRESULT CSnapInDesigner::AddNodeTypes
(
    IScopeItemDefs *piScopeItemDefs,
    INodeTypes     *piNodeTypes
)
{
    HRESULT         hr = S_OK;
    IScopeItemDef  *piScopeItemDef = NULL;
    IScopeItemDefs *piChildren = NULL;
    long            cItems = 0;
    VARIANT_BOOL    fExtensible = VARIANT_FALSE;
    BSTR            bstrName = NULL;
    BSTR            bstrGUID = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(piScopeItemDefs->get_Count(&cItems));
    IfFalseGo(0 != cItems, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= cItems)
    {
        IfFailGo(piScopeItemDefs->get_Item(varIndex, &piScopeItemDef));
        IfFailGo(piScopeItemDef->get_Extensible(&fExtensible));
        if (VARIANT_TRUE == fExtensible)
        {
            IfFailGo(piScopeItemDef->get_NodeTypeName(&bstrName));
            IfFailGo(piScopeItemDef->get_NodeTypeGUID(&bstrGUID));
            IfFailGo(AddNodeType(piNodeTypes, bstrName, bstrGUID));
            FREESTRING(bstrName);
            FREESTRING(bstrGUID);
        }

        // NTBUGS 354572 Call this function recursively to process this
        // node's children
        IfFailGo(piScopeItemDef->get_Children(&piChildren));
        IfFailGo(AddNodeTypes(piChildren, piNodeTypes));
        
        RELEASE(piScopeItemDef);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piScopeItemDef);
    QUICK_RELEASE(piChildren);
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);
    RRETURN(hr);
}



HRESULT CSnapInDesigner::AddListViewNodeTypes
(
    IListViewDefs *piListViewDefs,
    INodeTypes    *piNodeTypes
)
{
    HRESULT        hr = S_OK;
    IListViewDef  *piListViewDef = NULL;
    long           cItems = 0;
    VARIANT_BOOL   fExtensible = VARIANT_FALSE;
    BSTR           bstrName = NULL;
    BSTR           bstrGUID = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(piListViewDefs->get_Count(&cItems));
    IfFalseGo(0 != cItems, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= cItems)
    {
        IfFailGo(piListViewDefs->get_Item(varIndex, &piListViewDef));
        IfFailGo(piListViewDef->get_Extensible(&fExtensible));
        if (VARIANT_TRUE == fExtensible)
        {
            IfFailGo(piListViewDef->get_Name(&bstrName));
            IfFailGo(piListViewDef->get_DefaultItemTypeGUID(&bstrGUID));
            IfFailGo(AddNodeType(piNodeTypes, bstrName, bstrGUID));
            FREESTRING(bstrName);
            FREESTRING(bstrGUID);
        }
        RELEASE(piListViewDef);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piListViewDef);
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desmain.cpp ===
//=--------------------------------------------------------------------------------------
// desmain.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "desmain.h"


// for ASSERT and FAIL
//
SZTHISFILE


const int   kMaxBuffer = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PreCreateCheck
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Pre create check used to ensure dev's environment is setup to run
//      the designer
//
HRESULT CSnapInDesigner::PreCreateCheck
(
    void 
)
{
    HRESULT hr = S_OK;
    return hr;
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::Create
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Creates a new CSnapInDesigner and intializes it
//
IUnknown *CSnapInDesigner::Create
(
    IUnknown *pUnkOuter     // [in] Outer unknown for aggregation
)
{
    HRESULT          hr = S_OK;
    CSnapInDesigner *pDesigner = NULL;

    // Create the designer

    pDesigner = New CSnapInDesigner(NULL);
    IfFalseGo(NULL != pDesigner, SID_E_OUTOFMEMORY);

    // We initialize the type info here because during command line builds
    // we will receive CSnapInDesigner::GetDynamicClassInfo() calls before
    // the CSnapInDesigner::AfterCreateWindow() call where we populate it.

    pDesigner->m_pSnapInTypeInfo = New CSnapInTypeInfo();
    IfFalseGo(NULL != pDesigner->m_pSnapInTypeInfo, SID_E_OUTOFMEMORY);

Error:

    if (FAILED(hr))
    {
        if (NULL != pDesigner)
        {
            delete pDesigner;
        }
    }

    // make sure we return the private unknown so that we support aggegation
    // correctly!
    //
    return (S_OK == hr) ? pDesigner->PrivateUnknown() : NULL;
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CSnapInDesigner
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      CSnapInDesigner constructor
//

#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInDesigner::CSnapInDesigner(IUnknown *pUnkOuter) :
    COleControl(pUnkOuter, OBJECT_TYPE_SNAPINDESIGNER, (IDispatch *) this),
    CError(dynamic_cast<CAutomationObject *>(this))
{
    // initialize anything here ...
    //
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CSnapInDesigner::~CSnapInDesigner
//=--------------------------------------------------------------------------=
//
// Notes:
//
CSnapInDesigner::~CSnapInDesigner ()
{
    FREESTRING(m_bstrName);
    RELEASE(m_piCodeNavigate2);
    RELEASE(m_piTrackSelection);
    RELEASE(m_piProfferTypeLib);
    RELEASE(m_piDesignerProgrammability);
    RELEASE(m_piHelp);

    if (NULL != m_hwdToolbar)
        ::DestroyWindow(m_hwdToolbar);

    if (NULL != m_pTreeView)
        delete m_pTreeView;

    if (NULL != m_pSnapInTypeInfo)
        delete m_pSnapInTypeInfo;

    (void)DestroyExtensibilityModel();

    InitMemberVariables();
}       


//=--------------------------------------------------------------------------=
// CSnapInDesigner::InitMemberVariables()
//=--------------------------------------------------------------------------=
//
// Notes:
//
void CSnapInDesigner::InitMemberVariables()
{
    m_bstrName = NULL;
    m_piCodeNavigate2 = NULL;
    m_piTrackSelection = NULL;
    m_piProfferTypeLib = NULL;
    m_piDesignerProgrammability = NULL;
    m_piHelp = NULL;
    m_piSnapInDesignerDef = NULL;
    m_pTreeView = NULL;
    m_bDidLoad = FALSE;

    m_pCurrentSelection = NULL;

    m_pRootNode = NULL;
    m_pRootNodes = NULL;
    m_pRootExtensions = NULL;
    m_pRootMyExtensions = NULL;
    m_pStaticNode = NULL;
	m_pAutoCreateRoot = 0;
	m_pOtherRoot = 0;

    m_pViewListRoot = NULL;
    m_pViewOCXRoot = NULL;
    m_pViewURLRoot = NULL;
    m_pViewTaskpadRoot = NULL;
    m_pToolImgLstRoot = NULL;
    m_pToolMenuRoot = NULL;
    m_pToolToolbarRoot = NULL;

    m_pSnapInTypeInfo = NULL;

    m_iNextNodeNumber = 0;
    m_bDoingPromoteOrDemote = false;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetHostServices
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT_BOOL fvarInteractive - current value of ambient Interactive
//                                   (DISPID_AMBIENT_INTERACTIVE in ad98.h)
//
// Output:
//    HRESULT
//
// Notes:
//    Retrieves all the needed services provided by the designer host:
//    SID_SCodeNavigate
//    SID_STrackSelection
//    SID_DesignerProgrammability,
//    SID_Shelp
//

HRESULT CSnapInDesigner::GetHostServices(BOOL fInteractive)
{
    HRESULT           hr = S_OK;
    IOleClientSite   *piOleClientSite = NULL;
    IServiceProvider *piServiceProvider = NULL;
    ICodeNavigate    *piCodeNavigate = NULL;

    hr = GetClientSite(&piOleClientSite);
    IfFailGo(hr);

    hr = piOleClientSite->QueryInterface(IID_IServiceProvider,
                                         reinterpret_cast<void **>(&piServiceProvider));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_SCodeNavigate,
                                         IID_ICodeNavigate,
                                         reinterpret_cast<void **>(&piCodeNavigate));
    IfFailGo(hr);

    hr = piCodeNavigate->QueryInterface(IID_ICodeNavigate2,
                                        reinterpret_cast<void **>(&m_piCodeNavigate2));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_STrackSelection,
                                         IID_ITrackSelection,
                                         reinterpret_cast<void **>(&m_piTrackSelection));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_SProfferTypeLib,
                                         IID_IProfferTypeLib,
                                         reinterpret_cast<void **>(&m_piProfferTypeLib));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_DesignerProgrammability,
                                         IID_IDesignerProgrammability,
                                         reinterpret_cast<void **>(&m_piDesignerProgrammability));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_SHelp, 
                                         IID_IHelp, 
                                         reinterpret_cast<void **>(&m_piHelp));
    IfFailGo(hr);

    // Need to tell VB about the runtime type library so that it will show up
    // in the object browser and in the code window. We only do this if the
    // user has opened the designer window. If VB is not interactive it will
    // return E_FAIL from ProfferTypeLib().

    if (fInteractive)
    {
        hr = m_piProfferTypeLib->ProfferTypeLib(LIBID_SnapInLib, 1, 0, 0);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(piServiceProvider);
    QUICK_RELEASE(piOleClientSite);
    QUICK_RELEASE(piCodeNavigate);

    EXCEPTION_CHECK(hr);

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetAmbients
//=--------------------------------------------------------------------------=
//
// Notes:
//
CAmbients *CSnapInDesigner::GetAmbients()
{
    return &m_Ambients;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapInDesigner::InternalQueryInterface
//=--------------------------------------------------------------------------=
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
// Handle QI for interfaces we support directly in this method
//

HRESULT CSnapInDesigner::InternalQueryInterface
(
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT     hr = S_OK;
    IUnknown    *pUnk = NULL;

    *ppvObjOut = NULL;

    // TODO: if you want to support any additional interfaces, then you should
    // indicate that here. Never forget to call COleControl's version in the
    // case where you don't support the given interface.
    //
    if (DO_GUIDS_MATCH(riid, IID_IActiveDesigner))
    {
        pUnk = static_cast<IActiveDesigner *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDesignerDebugging))
    {
        pUnk = static_cast<IDesignerDebugging *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDesignerRegistration))
    {
        pUnk = static_cast<IDesignerRegistration *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IProvideClassInfo))
    {
        hr = E_NOINTERFACE;
    }
    else if (DO_GUIDS_MATCH(riid, IID_IProvideDynamicClassInfo))
    {
        pUnk = static_cast<IProvideDynamicClassInfo *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_ISelectionContainer))
    {
        pUnk = static_cast<ISelectionContainer *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IObjectModelHost))
    {
        pUnk = static_cast<IObjectModelHost *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else
    {
        hr = COleControl::InternalQueryInterface(riid, ppvObjOut);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////////
// IActiveDesigner
///////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRuntimeClassID    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Returns the classid of the runtime class
//
STDMETHODIMP CSnapInDesigner::GetRuntimeClassID
(
    CLSID *pclsid       // [out] runime object's CLSID
)
{
    // UNDONE: need to CLSID tricks for standalone, extension dualmode stuff
    *pclsid = CLSID_SnapIn;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRuntimeMiscStatusFlags    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Parameters:
//    DWORD *               - [out] duh.
//
// Output:
//    HRESULT
//
// Notes:
//    Returns the misc status flags for the runtime object.
//
STDMETHODIMP CSnapInDesigner::GetRuntimeMiscStatusFlags
(
    DWORD *pdwMiscFlags     // [out] Returns misc status flags
)
{
    *pdwMiscFlags = OLEMISC_INVISIBLEATRUNTIME | OLEMISC_SETCLIENTSITEFIRST; 

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::QueryPersistenceInterface    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT               - S_OK yep, S_FALSE nope, otherwise error
//
// Notes:
//      Do we support the given interface for persistence for the runmode object?
//
STDMETHODIMP CSnapInDesigner::QueryPersistenceInterface
(
    REFIID riidPersist      // [in] IID of the runtime persist type
)
{
    HRESULT hr = S_FALSE;

    if (DO_GUIDS_MATCH(riidPersist, IID_IPersistStreamInit))
        hr = S_OK;
    else if (DO_GUIDS_MATCH(riidPersist, IID_IPersistStream))
        hr = S_OK; 
    else if (DO_GUIDS_MATCH(riidPersist, IID_IPersistStorage))
        hr = S_FALSE; 
    else if (DO_GUIDS_MATCH(riidPersist, IID_IPersistPropertyBag))
        hr = S_FALSE; 

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SaveRuntimeState    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Given a persistence object and an interface, save out the runtime state
//    using that object.
//
//
STDMETHODIMP CSnapInDesigner::SaveRuntimeState
(
    REFIID riidPersist,         // [in] interface we're saving on
    REFIID riidObjStgMed,       // [in] the interface the object is
    void  *pObjStgMed           // [in] the medium
)
{
    HRESULT         hr = S_OK;
    IPersistStream *piPersistStream = NULL;
    unsigned long   ulTICookie = 0;
    BSTR            bstrProjectName = NULL;

    // Check that we're saving to a stream

    if (IID_IStream != riidObjStgMed)
    {
        EXCEPTION_CHECK_GO(SID_E_UNSUPPORTED_STGMEDIUM);
    }

    if (IID_IPersistStream != riidPersist)
    {
        EXCEPTION_CHECK_GO(SID_E_UNSUPPORTED_STGMEDIUM);
    }

    if (NULL != m_piSnapInDesignerDef)
    {
        // Store the typeinfo cookie. Move it to a ULONG by static cast to
        // catch any size differential during compilation.

        if (NULL != m_pSnapInTypeInfo)
        {
            ulTICookie = static_cast<ULONG>(m_pSnapInTypeInfo->GetCookie());
        }
        IfFailGo(m_piSnapInDesignerDef->put_TypeinfoCookie(static_cast<long>(ulTICookie)));

        // Store the project name for the runtime.

        IfFailGo(AttachAmbients());
        IfFailGo(m_Ambients.GetProjectName(&bstrProjectName));
        IfFailGo(m_piSnapInDesignerDef->put_ProjectName(bstrProjectName));

        // Save the whole shebang to the stream. The SnapInDesigerDef object
        // contains the entire runtime state.

        hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistStream, reinterpret_cast<void **>(&piPersistStream));
        IfFailGo(hr);

        hr = ::OleSaveToStream(piPersistStream, reinterpret_cast<IStream *>(pObjStgMed));
        piPersistStream->Release();

        // Don't do an exception check for OleSaveToStream() because it just
        // QIs and saves so our code will have set the exception info.
    }

Error:
    FREESTRING(bstrProjectName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::::GetExtensibilityObject    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::GetExtensibilityObject
(
    IDispatch **ppvObjOut           // [out] the extensibility object.
)
{
    HRESULT hr = S_OK;

    if (NULL == m_piSnapInDesignerDef)
    {
        *ppvObjOut = NULL;
        hr = E_NOTIMPL;
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppvObjOut));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetDynamicClassInfo    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::GetDynamicClassInfo(ITypeInfo **ppTypeInfo, DWORD *pdwCookie)
{
    HRESULT hr = S_OK;

    if (NULL != ppTypeInfo)
    {
        hr = m_pSnapInTypeInfo->GetTypeInfo(ppTypeInfo);
        IfFailGo(hr);
    }

    if (pdwCookie != NULL)
    {
        m_pSnapInTypeInfo->ResetDirty();
        *pdwCookie = m_pSnapInTypeInfo->GetCookie();
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::FreezeShape    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    TODO: Make sure we don't have to do anything here
//
STDMETHODIMP CSnapInDesigner::FreezeShape(void)
{
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetClassInfo    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    We do dynamic class info so E_NOTIMPL
//
STDMETHODIMP CSnapInDesigner::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    // UNDONE: get rid of this when dynamic typeinfo is in place
/*
    ITypeLib *piTypeLib = NULL;
    HRESULT   hr = S_OK;
    
    IfFalseGo(NULL != ppTypeInfo, S_OK);

    hr = ::LoadRegTypeLib(LIBID_SnapInLib,
                          1,
                          0,
                          LOCALE_SYSTEM_DEFAULT,
                          &piTypeLib);
    IfFailGo(hr);

    hr = piTypeLib->GetTypeInfoOfGuid(CLSID_SnapIn, ppTypeInfo);

Error:
    QUICK_RELEASE(piTypeLib);
    return hr;
*/
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////////
// ISelectionContainer
///////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnSelectionChanged
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Called by CTreeView when the selection changes
//
HRESULT CSnapInDesigner::OnSelectionChanged(CSelectionHolder *pNewSelection)
{
    HRESULT     hr = S_OK;

    m_pCurrentSelection = pNewSelection;

    hr = OnPrepareToolbar();
    IfFailGo(hr);

    if (NULL != m_piTrackSelection)
    {
        hr = m_piTrackSelection->OnSelectChange(static_cast<ISelectionContainer *>(this));
    }

Error:
    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::CountObjects    [ISelectionContainer]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Called by VB to get the number of objects to display in the properties list
//    drop down list or the number of objects selected  
//
HRESULT CSnapInDesigner::CountObjects
(
    DWORD dwFlags,      // [in] Return count of all objects or just selected
    ULONG *pc           // [out] Number of objects
)
{
    HRESULT     hr = S_OK;
    long        lCount = 1;

    *pc = 0;

    // Make sure we have been sited since we need extended dispatch
    //
    if (NULL != m_pControlSite)
    {
        // If VB wants the count of all the objects
        //
        if (GETOBJS_ALL == dwFlags)
        {	
            // get the number of nodes
            //
            hr = m_pTreeView->CountSelectableObjects(&lCount);
            IfFailGo(hr);

            // And add 1 for the designer itself
            //
            *pc = lCount;
        }
        else if (GETOBJS_SELECTED == dwFlags)
            // Otherwise, we only allow one object to be selected at a time
            //
            *pc = 1;
    }

Error:
    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetObjects    [ISelectionContainer]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Returns an array of all the objects or the selected object
//
HRESULT CSnapInDesigner::GetObjects
(
    DWORD dwFlags,              // [in] Return all the objects or the selected
    ULONG cObjects,             // [in] Number to return
    IUnknown **apUnkObjects     // [in,out] Array to return them in
)
{
    HRESULT              hr = S_OK;
    ULONG                i;
    IDispatch           *piDisp = NULL;
    IUnknown            *piUnkUs = NULL;
    long                 lOffset = 1;
    CSelectionHolder    *pParent = NULL;

    // Initialize array to NULL
    //
    for (i = 0; i < cObjects; ++i)
    {
        apUnkObjects[i] = NULL;
    }

    // Pass our extended object if we can, so the user can browse extended properties
    //
    if (NULL != m_pControlSite)
    {
        hr = m_pControlSite->GetExtendedControl(&piDisp);
        if SUCCEEDED(hr)
        {
            hr = piDisp->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnkUs));
            IfFailGo(hr);
        }
        else
        {
            piUnkUs = dynamic_cast<IUnknown *>(dynamic_cast<ISelectionContainer *>(this));
            piUnkUs->AddRef();
        }
    }

    // Let the view collect the selection targets
	if (NULL != m_pTreeView)
	{
        if (GETOBJS_ALL == dwFlags)
        {
            hr = m_pRootNode->GetSelectableObject(&(apUnkObjects[0]));
            IfFailGo(hr);

            hr = m_pTreeView->CollectSelectableObjects(apUnkObjects, &lOffset);
            IfFailGo(hr);
        }
        else if (GETOBJS_SELECTED == dwFlags)
        {
            if (NULL != m_pCurrentSelection)
            {
                if (true == m_pCurrentSelection->IsVirtual())
                {
					if (SEL_NODES_ANY_CHILDREN == m_pCurrentSelection->m_st ||
						SEL_NODES_ANY_VIEWS == m_pCurrentSelection->m_st)
					{
                        hr = m_pTreeView->GetParent(m_pCurrentSelection, &pParent);
                        IfFailGo(hr);

						hr = pParent->GetSelectableObject(&(apUnkObjects[0]));
						IfFailGo(hr);
					}
                    else if (m_pCurrentSelection->m_st >= SEL_EEXTENSIONS_CC_ROOT &&
                             m_pCurrentSelection->m_st <= SEL_EEXTENSIONS_NAMESPACE)
                    {
                        hr = m_pCurrentSelection->GetSelectableObject(&(apUnkObjects[0]));
                        IfFailGo(hr);
                    }
                    else if (m_pCurrentSelection->m_st >= SEL_EXTENSIONS_MYNAME &&
                             m_pCurrentSelection->m_st <= SEL_EXTENSIONS_NAMESPACE)
                    {
                        hr = m_pCurrentSelection->GetSelectableObject(&(apUnkObjects[0]));
                        IfFailGo(hr);
                    }
					else
					{
						hr = m_pRootNode->GetSelectableObject(&(apUnkObjects[0]));
						IfFailGo(hr);
					}
                }
                else
                {
                    hr = m_pCurrentSelection->GetSelectableObject(&(apUnkObjects[0]));
                    IfFailGo(hr);
                }
            }
        }
	}

Error:
    RELEASE(piUnkUs)
    RELEASE(piDisp)

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SelectObjects    [ISelectionContainer]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Called when VB wants the designer's user interface to select a specific 
//    object
//
HRESULT CSnapInDesigner::SelectObjects
(
    ULONG cSelect,              // [in] Number to select
    IUnknown **apUnkSelect,     // [in] Objects to select
    DWORD dwFlags               // 
)
{
    HRESULT             hr = S_OK;
    IUnknown           *piUnkThem = NULL;
    IDispatch          *piDisp = NULL;
    IUnknown           *piUnkUs = NULL;
    BOOL                fSelectRoot = FALSE;
    CSelectionHolder   *pSelection = NULL;

    ASSERT(1 == cSelect, "Can only handle single selection");

	hr = apUnkSelect[0]->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnkThem));	
	IfFailGo(hr);

    // Figure out if the designer itself is the selected object
    //
    hr = m_pControlSite->GetExtendedControl(&piDisp);
    if SUCCEEDED(hr)
    {
        hr = piDisp->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnkUs));
        IfFailGo(hr);
    }
    else
    {
        piUnkUs = dynamic_cast<IUnknown *>(dynamic_cast<ISelectionContainer *>(this));
        piUnkUs->AddRef();
    }

    if (piUnkUs == piUnkThem)
        fSelectRoot = TRUE;

	// Let the view select the object
	//
	if (NULL != m_pTreeView)
	{
        if (TRUE == fSelectRoot)
        {
            hr = m_pTreeView->GetItemParam(TVI_ROOT, &pSelection);
            IfFailGo(hr);

            ::SetActiveWindow(::GetParent(::GetParent(m_pTreeView->TreeViewWindow())));

            return hr;
        }

        // Otherwise, find the node that VB wants to select and select it
        hr = m_pTreeView->FindSelectableObject(piUnkThem, &pSelection);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = m_pTreeView->SelectItem(pSelection);
            IfFailGo(hr);

            m_pCurrentSelection = pSelection;
            hr = OnPrepareToolbar();
            IfFailGo(hr);
        }
	}

Error:
    RELEASE(piUnkUs);
    RELEASE(piDisp);
    RELEASE(piUnkThem);

    return hr;
}


//=--------------------------------------------------------------------------=
//                      IOleControlSite Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnAmbientPropertyChange(DISPID dispid)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::OnAmbientPropertyChange(DISPID dispid)
{
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      IPersistStreamInit Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::IsDirty()
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::IsDirty()
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;

    if (m_fDirty)
    {
        return S_OK;
    }

    if (NULL == m_piSnapInDesignerDef)
    {
        return S_FALSE;
    }
        
    hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistStreamInit, reinterpret_cast<void **>(&piPersistStreamInit));
    IfFailGo(hr);

    hr = piPersistStreamInit->IsDirty();
    piPersistStreamInit->Release();

Error:    
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      COleControl Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnSetClientSite()           [COleControl::OnSetClientSite]
//=--------------------------------------------------------------------------=
//
// Notes:
//
// Called by the framework when the VB calls IOleObject::SetClientSite().
// When the client site is removed as the designer is being shutdown we need
// to release anything that could cause circular ref counts such as
// host interfaces and the object model.

HRESULT CSnapInDesigner::OnSetClientSite()
{
    if (NULL == m_pClientSite) // shutting down
    {
        RELEASE(m_piCodeNavigate2);
        RELEASE(m_piTrackSelection);
        RELEASE(m_piProfferTypeLib);
        RELEASE(m_piDesignerProgrammability);
        RELEASE(m_piHelp);
        (void)DestroyExtensibilityModel();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::BeforeDestroyWindow()
//=--------------------------------------------------------------------------=
//
// Notes:
//
void CSnapInDesigner::BeforeDestroyWindow()
{
    FREESTRING(m_bstrName);
    RELEASE(m_piCodeNavigate2);
    RELEASE(m_piTrackSelection);
    RELEASE(m_piProfferTypeLib);
    RELEASE(m_piDesignerProgrammability);
    RELEASE(m_piHelp);

    if (NULL != m_pSnapInTypeInfo)
    {
        delete m_pSnapInTypeInfo;
        m_pSnapInTypeInfo = NULL;
    }

    if (NULL != m_hwdToolbar)
    {
        ::DestroyWindow(m_hwdToolbar);
        m_hwdToolbar = NULL;
    }

    if (NULL != m_pTreeView)
    {
        delete m_pTreeView;
        m_pTreeView = NULL;
    }

    (void)DestroyExtensibilityModel();

    g_GlobalHelp.Detach();

    RELEASE(m_piSnapInDesignerDef);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::InitializeNewDesigner(ISnapInDef *piSnapInDef)
//=--------------------------------------------------------------------------=
//
// Notes:
//
HRESULT CSnapInDesigner::InitializeNewDesigner
(
    ISnapInDef *piSnapInDef
)
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    TCHAR       szBuffer[kMaxBuffer + 1];
    BSTR        bstrProvider = NULL;
    BSTR        bstrVersion = NULL;
    BSTR        bstrDescription = NULL;

    if (NULL != piSnapInDef)
    {
        hr = piSnapInDef->put_Name(m_bstrName);
        IfFailGo(hr);

        hr = piSnapInDef->put_NodeTypeName(m_bstrName);
        IfFailGo(hr);

        hr = piSnapInDef->put_DisplayName(m_bstrName);
        IfFailGo(hr);

        // Provider
        GetResourceString(IDS_DFLT_PROVIDER, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = BSTRFromANSI(szBuffer, &bstrProvider);
        IfFailGo(hr);

        hr = piSnapInDef->put_Provider(bstrProvider);
        IfFailGo(hr);

        // Version
        GetResourceString(IDS_DFLT_VERSION, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = BSTRFromANSI(szBuffer, &bstrVersion);
        IfFailGo(hr);

        hr = piSnapInDef->put_Version(bstrVersion);
        IfFailGo(hr);

        // Description
        GetResourceString(IDS_DFLT_DESCRIPT, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = BSTRFromANSI(szBuffer, &bstrDescription);
        IfFailGo(hr);

        hr = piSnapInDef->put_Description(bstrDescription);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrDescription);
    FREESTRING(bstrVersion);
    FREESTRING(bstrProvider);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::InitializeNewState()
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::InitializeNewState()
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;
    ISnapInDef         *piSnapInDef = NULL;

    IfFailGo(CreateExtensibilityModel());

    hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistStreamInit, reinterpret_cast<void **>(&piPersistStreamInit));
    IfFailGo(hr);

    hr = piPersistStreamInit->InitNew();
    piPersistStreamInit->Release();

    // Set the host now as following InitNew all objects will have created their
    // sub-objects.

    IfFailGo(SetObjectModelHost());

    hr = UpdateDesignerName();
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = InitializeNewDesigner(piSnapInDef);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    return SUCCEEDED(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::LoadBinaryState(IStream *piStream)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::LoadBinaryState
(
    IStream *piStream
)
{
    HRESULT       hr = S_OK;
    unsigned long lRead = 0;
    unsigned long ulTICookie = 0;

    hr = piStream->Read(&m_iNextNodeNumber, sizeof(m_iNextNodeNumber), &lRead);
    ASSERT(sizeof(m_iNextNodeNumber) == lRead, "SaveBinaryState: Error reading from stream");

    // Destroy existing extensibility object model
    IfFailGo(DestroyExtensibilityModel());

    // Load a new one from the stream
    hr = ::OleLoadFromStream(piStream, IID_ISnapInDesignerDef, reinterpret_cast<void **>(&m_piSnapInDesignerDef));

    // Do an exception check because OleLoadFromStream() will call
    // CoCreateInstance(). If something in the object model returned an error
    // and set the exception info then we will probably just set it again
    // (unless there were arguments).
    EXCEPTION_CHECK_GO(hr);

    // Set the designer as object model host in the extensibility model
    hr = SetObjectModelHost();
    IfFailGo(hr);

    // Set the typeinfo cookie from the saved value. Don't read from long
    // property directly into a DWORD so as to avoid size assumptions.
    // If there is a size problem then the static cast will fail compilation.
    
    IfFailGo(m_piSnapInDesignerDef->get_TypeinfoCookie(reinterpret_cast<long *>(&ulTICookie)));
    if (NULL != m_pSnapInTypeInfo)
    {
        m_pSnapInTypeInfo->SetCookie(static_cast<DWORD>(ulTICookie));
    }

    m_bDidLoad = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SaveBinaryState(IStream *piStream)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::SaveBinaryState
(
    IStream *piStream
)
{
    HRESULT       hr = S_OK;
    unsigned long cbWritten = 0;

    hr = piStream->Write(&m_iNextNodeNumber, sizeof(m_iNextNodeNumber), &cbWritten);
    EXCEPTION_CHECK_GO(hr);
    
    if (sizeof(m_iNextNodeNumber) != cbWritten)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        EXCEPTION_CHECK_GO(hr);
    }

    // The remainder of design time state is the same as the runtime.
    
    IfFailGo(SaveRuntimeState(IID_IPersistStream, IID_IStream, piStream));

Error:    
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::LoadTextState(IPropertyBag *piPropertyBag, IErrorLog *piErrorLog)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::LoadTextState
(
    IPropertyBag *piPropertyBag,
    IErrorLog    *piErrorLog
)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrPropName = NULL;
    VARIANT              vtCounter;
    IPersistPropertyBag *piPersistPropertyBag = NULL;
    unsigned long        ulTICookie = 0;

    ::VariantInit(&vtCounter);

    IfFailGo(CreateExtensibilityModel());

    bstrPropName = ::SysAllocString(L"m_iNextNodeNumber");
    if (NULL == bstrPropName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piPropertyBag->Read(bstrPropName, &vtCounter, NULL);
    IfFailGo(hr);

    IfFailGo(::VariantChangeType(&vtCounter, &vtCounter, 0, VT_I4));

    m_iNextNodeNumber = vtCounter.lVal;

    hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistPropertyBag, reinterpret_cast<void **>(&piPersistPropertyBag));
    IfFailGo(hr);

    hr = piPersistPropertyBag->Load(piPropertyBag, piErrorLog);
    piPersistPropertyBag->Release();
    IfFailGo(hr);

    // Set the designer as object model host in the extensibility model

    hr = SetObjectModelHost();

    // Set the typeinfo cookie from the saved value. Don't read from long
    // property directly into a DWORD so as to avoid size assumptions.
    // If there is a size problem then the static cast will fail compilation.

    IfFailGo(m_piSnapInDesignerDef->get_TypeinfoCookie(reinterpret_cast<long *>(&ulTICookie)));
    if (NULL != m_pSnapInTypeInfo)
    {
        m_pSnapInTypeInfo->SetCookie(static_cast<DWORD>(ulTICookie));
    }

    m_bDidLoad = TRUE;

Error:
    ::VariantClear(&vtCounter);
    FREESTRING(bstrPropName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SaveTextState(IPropertyBag *piPropertyBag, BOOL fWriteDefault)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::SaveTextState
(
    IPropertyBag *piPropertyBag,
    BOOL          fWriteDefault
)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrPropName = NULL;
    VARIANT              vtCounter;
    IPersistPropertyBag *piPersistPropertyBag = NULL;
    unsigned long        ulTICookie = 0;

    ::VariantInit(&vtCounter);

    bstrPropName = ::SysAllocString(L"m_iNextNodeNumber");
    if (NULL == bstrPropName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    vtCounter.vt = VT_I4;
    vtCounter.lVal = m_iNextNodeNumber;
    hr = piPropertyBag->Write(bstrPropName, &vtCounter);
    IfFailGo(hr);

    if (NULL != m_piSnapInDesignerDef)
    {
        // Store the typeinfo cookie.

        if (NULL != m_pSnapInTypeInfo)
        {
            ulTICookie = static_cast<ULONG>(m_pSnapInTypeInfo->GetCookie());
        }
        IfFailGo(m_piSnapInDesignerDef->put_TypeinfoCookie(static_cast<long>(ulTICookie)));

        hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistPropertyBag, reinterpret_cast<void **>(&piPersistPropertyBag));
        IfFailGo(hr);

        hr = piPersistPropertyBag->Save(piPropertyBag,
                                        TRUE, // assume clear dirty
                                        fWriteDefault);
        piPersistPropertyBag->Release();
    }

Error:
    ::VariantClear(&vtCounter);
    FREESTRING(bstrPropName);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      IObjectModelHost Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::Update                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long      ObjectCookie  [in] cookie passed to object's IObjectModel::SetCookie
//    IUnknown *punkObject    [in] IUnknown of the calling object
//    DISPID    dispid        [in] DISPID of the object's property that changed
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility object when one of its properties has changed
// that could affect the UI.
//
//
STDMETHODIMP CSnapInDesigner::Update
(
    long      ObjectCookie,
    IUnknown *punkObject,
    DISPID    dispid
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;

    pSelection = reinterpret_cast<CSelectionHolder *>(ObjectCookie);

    // The cookie may be zero when loading or creating a snap-in because
    // some properties are set before selection holders are created. For
    // example, AfterCreateWindow() will set SnapInDef.IID which will
    // call IObjectModeHost::Update().
    
    IfFalseGo(NULL != pSelection, S_OK);

    // Check whether the selected item is currently in the middle of an update.
    // This can happen in cases where the selected object is not the same as the
    // object model object. For example, A TaskpadViewDef defines a taskpad but
    // the selected object as VB sees it from ISelectionContainer is
    // TaskpadViewDef.Taskpad. In this case, during a rename operation both
    // TaskpadViewDef.Name and TaskpadViewDef.Taskpad.Name will be changed. The
    // 2nd one will result in a rescursive call to this function because of
    // the IObjectModelHost::Update call generated by setting the property. As
    // the DISPID for any object's name is almost always zero, the functions
    // called from here will mistake the second call for another update of the
    // selected object's name.

    IfFalseGo(!pSelection->InUpdate(), S_OK);

    // Now mark the selection as being in an update

    pSelection->SetInUpdate(TRUE);

    // Invoke object specific handlers

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:
        hr = OnSnapInChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_ROOT:
        hr = OnMyExtensionsChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_NAME:
        hr = OnExtendedSnapInChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = OnScopeItemChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = OnListViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = OnOCXViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = OnURLViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = OnTaskpadViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = OnImageListChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = OnMenuChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = OnToolbarChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = OnDataFormatChange(pSelection, dispid);
        IfFailGo(hr);
        break;
    }

    // The object is no longer in a rename operation so mark it as such

    if (NULL != pSelection)
    {
        pSelection->SetInUpdate(FALSE);
    }

Error:

    if (FAILED(hr))
    {
        // The object is no longer in a rename operation so mark it as such.
        // Note that we cannot just do this blindly without checking for failure
        // because at the top of this function we check the flag and exit with
        // S_OK. If we came down here with no change and reset the flag then
        // further updates to the object (e.g. changing the key along with the
        // name), would see an incorrect value of the flag.

        if (NULL != pSelection)
        {
            pSelection->SetInUpdate(FALSE);
        }

        (void)::SDU_DisplayMessage(IDS_RENAME_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_RenameFailed, hr, AppendErrorInfo, NULL);
    }

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::Add                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long      CollectionCookie [in] cookie passed to collection object's
//                                    IObjectModel::SetCookie
//    IUnknown *punkNewObject    [in] IUnknown of the newly added object
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility collection object when an item has been added
// to it.
//
//
STDMETHODIMP CSnapInDesigner::Add
(
    long      CollectionCookie,
    IUnknown *punkNewObject
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;
    IExtendedSnapIn     *piExtendedSnapIn = NULL;
    IScopeItemDef       *piScopeItemDef = NULL;
    IListViewDef        *piListViewDef = NULL;
    IOCXViewDef         *piOCXViewDef = NULL;
    IURLViewDef         *piURLViewDef = NULL;
    ITaskpadViewDef     *piTaskpadViewDef = NULL;
    IMMCImageList       *piMMCImageList = NULL;
    IMMCMenu            *piMMCMenu = NULL;
    IMMCToolbar         *piMMCToolbar = NULL;
    IDataFormat         *piDataFormat = NULL;

    pSelection = reinterpret_cast<CSelectionHolder *>(CollectionCookie);
    if (NULL != pSelection)
    {
        switch (pSelection->m_st)
        {
        case SEL_EXTENSIONS_ROOT:
            // It's got to be an IExtendedSnapIn
            hr = punkNewObject->QueryInterface(IID_IExtendedSnapIn, reinterpret_cast<void **>(&piExtendedSnapIn));
            IfFailGo(hr);

            hr = OnAddExtendedSnapIn(pSelection, piExtendedSnapIn);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
        case SEL_NODES_OTHER:
            // It's got to be an IScopeItemDef
            hr = punkNewObject->QueryInterface(IID_IScopeItemDef, reinterpret_cast<void **>(&piScopeItemDef));
            IfFailGo(hr);

            hr = OnAddScopeItemDef(pSelection, piScopeItemDef);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
            // Could be a IListViewDef
            hr = punkNewObject->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&piListViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddListViewDef(pSelection, piListViewDef);
                IfFailGo(hr);
                break;
            }

            // or a IOCXViewDef
            hr = punkNewObject->QueryInterface(IID_IOCXViewDef, reinterpret_cast<void **>(&piOCXViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddOCXViewDef(pSelection, piOCXViewDef);
                IfFailGo(hr);
                break;
            }

            // or a IURLViewDef
            hr = punkNewObject->QueryInterface(IID_IURLViewDef, reinterpret_cast<void **>(&piURLViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddURLViewDef(pSelection, piURLViewDef);
                IfFailGo(hr);
                break;
            }

            // or a ITaskpadViewDef
            hr = punkNewObject->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&piTaskpadViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddTaskpadViewDef(pSelection, piTaskpadViewDef);
                IfFailGo(hr);
                break;
            }
            ASSERT(0, "Add: Cannot guess type of view");
            break;

        case SEL_VIEWS_LIST_VIEWS:
            // It's got to be an IListViewDef
            hr = punkNewObject->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&piListViewDef));
            IfFailGo(hr);

            hr = OnAddListViewDef(pSelection, piListViewDef);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_OCX:
            // It's got to be an IOCXViewDef
            hr = punkNewObject->QueryInterface(IID_IOCXViewDef, reinterpret_cast<void **>(&piOCXViewDef));
            IfFailGo(hr);

            hr = OnAddOCXViewDef(pSelection, piOCXViewDef);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_URL:
            // It's got to be an IURLViewDef
            hr = punkNewObject->QueryInterface(IID_IURLViewDef, reinterpret_cast<void **>(&piURLViewDef));
            IfFailGo(hr);

            hr = OnAddURLViewDef(pSelection, piURLViewDef);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_TASK_PAD:
            // It's got to be an ITaskpadViewDef
            hr = punkNewObject->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&piTaskpadViewDef));
            IfFailGo(hr);

            hr = OnAddTaskpadViewDef(pSelection, piTaskpadViewDef);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            // It's got to be an IMMCImageList
            hr = punkNewObject->QueryInterface(IID_IMMCImageList, reinterpret_cast<void **>(&piMMCImageList));
            IfFailGo(hr);

            hr = OnAddMMCImageList(pSelection, piMMCImageList);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS:
        case SEL_TOOLS_MENUS_NAME:
            // It's got to be an IMMCMenu
            hr = punkNewObject->QueryInterface(IID_IMMCMenu, reinterpret_cast<void **>(&piMMCMenu));
            IfFailGo(hr);

            hr = OnAddMMCMenu(pSelection, piMMCMenu);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS:
            // It's got to be an ITaskpadViewDef
            hr = punkNewObject->QueryInterface(IID_IMMCToolbar, reinterpret_cast<void **>(&piMMCToolbar));
            IfFailGo(hr);

            hr = OnAddMMCToolbar(pSelection, piMMCToolbar);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCES:
            // It's got to be an IDataFormat
            hr = punkNewObject->QueryInterface(IID_IDataFormat, reinterpret_cast<void **>(&piDataFormat));
            IfFailGo(hr);

            hr = OnAddDataFormat(pSelection, piDataFormat);
            IfFailGo(hr);
        }
    }


Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_ADD_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_AddFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piDataFormat);
    RELEASE(piExtendedSnapIn);
    RELEASE(piMMCToolbar);
    RELEASE(piMMCMenu);
    RELEASE(piMMCImageList);
    RELEASE(piTaskpadViewDef);
    RELEASE(piURLViewDef);
    RELEASE(piOCXViewDef);
    RELEASE(piListViewDef);
    RELEASE(piScopeItemDef);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::Delete                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long      ObjectCookie [in] cookie passed to object's IObjectModel::SetCookie
//    IUnknown *punkObject   [in] IUnknown of the object
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility collection object when an item has been deleted
// from it.
//
//
STDMETHODIMP CSnapInDesigner::Delete
(
    long      ObjectCookie,
    IUnknown *punkObject
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;

    pSelection = reinterpret_cast<CSelectionHolder *>(ObjectCookie);
    if (NULL != pSelection)
    {
        switch (pSelection->m_st)
        {
        case SEL_NODES_ANY_NAME:
            // An IScopeItemDef has been deleted
            hr = OnDeleteScopeItem(pSelection);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            // An IMMCImageList has been deleted
            hr = OnDeleteImageList(pSelection);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS_NAME:
            // An IMMCMenu has been deleted
            hr = OnDeleteMenu(pSelection);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            // An IMMCToolbar has been deleted
            hr = OnDeleteToolbar(pSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
            // An IListViewDef has been deleted
            hr = OnDeleteListView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_URL_NAME:
            // An IURLViewDef has been deleted
            hr = OnDeleteURLView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_OCX_NAME:
            // An IOCXViewDef has been deleted
            hr = OnDeleteOCXView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_TASK_PAD_NAME:
            // An ITaskpadViewDef has been deleted
            hr = OnDeleteTaskpadView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_EEXTENSIONS_NAME:
            // An extended snap-in has been removed
            hr = OnDeleteExtendedSnapIn(pSelection);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCE_NAME:
            // An XML data format has been deleted
            hr = OnDeleteDataFormat(m_pCurrentSelection);
            IfFailGo(hr);
            break;
        }
    }

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_DELETE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_DeleteFailed, hr, AppendErrorInfo, NULL);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnSnapInChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnSnapInChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrName = NULL;
    IDispatch      *piDispExtendedCtl = NULL;
    unsigned int    uiArgErr = (unsigned int)-1;
    static OLECHAR *pwszExtenderNameProperty = OLESTR("Name");
    DISPID          dispidName = 0;

    DISPPARAMS DispParams;
    ::ZeroMemory(&DispParams, sizeof(DispParams));

    EXCEPINFO ExceptionInfo;
    ::ZeroMemory(&ExceptionInfo, sizeof(ExceptionInfo));

    VARIANTARG arg;
    ::VariantInit(&arg);


    if (DISPID_SNAPIN_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piSnapInDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameSnapIn(pSelection, bstrName);
        IfFailGo(hr);

        // Need to set the extended control's name. This will change VB's notion
        // of the snap-in's name and update the project window.

        hr = m_pControlSite->GetExtendedControl(&piDispExtendedCtl);
        IfFailGo(hr);

        if (NULL == piDispExtendedCtl)
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        // Need to do GetIDsOfNames because we can't assume that the extender
        // uses DISPID_VALUE for the name property. (In fact, it doesn't).

        IfFailGo(piDispExtendedCtl->GetIDsOfNames(IID_NULL,
                                                  &pwszExtenderNameProperty,
                                                  1,
                                                  LOCALE_USER_DEFAULT,
                                                  &dispidName));
        arg.vt = VT_BSTR;
        arg.bstrVal = bstrName;

        DispParams.rgdispidNamedArgs = NULL;
        DispParams.rgvarg = &arg;
        DispParams.cArgs = 1;
        DispParams.cNamedArgs = 0;

        IfFailGo(piDispExtendedCtl->Invoke(dispidName,
                                           IID_NULL,
                                           LOCALE_USER_DEFAULT,
                                           DISPATCH_PROPERTYPUT,
                                           &DispParams,
                                           NULL,
                                           &ExceptionInfo,
                                           &uiArgErr));

        // Make sure that the designer's name property is in sync with VB
        hr = UpdateDesignerName();
        IfFailGo(hr);

    }

Error:
    QUICK_RELEASE(piDispExtendedCtl);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnMyExtensionsChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnMyExtensionsChange(CSelectionHolder *pSelection, DISPID dispid)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vbValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_ROOT == pSelection->m_st, "OnMyExtensionsChange: Wrong kind of selection");
    switch (dispid)
    {
    case DISPID_EXTENSIONDEFS_EXTENDS_NEW_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsNewMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsNewMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsNewMenu(pSelection);
            IfFailGo(hr);
        }
        break;
    case DISPID_EXTENSIONDEFS_EXTENDS_TASK_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsTaskMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsTaskMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsTaskMenu(pSelection);
            IfFailGo(hr);
        }
        break;
    case DISPID_EXTENSIONDEFS_EXTENDS_TOP_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsTopMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsTopMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsTopMenu(pSelection);
            IfFailGo(hr);
        }
        break;
    case DISPID_EXTENSIONDEFS_EXTENDS_VIEW_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsViewMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsViewMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsViewMenu(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENSIONDEFS_EXTENDS_PROPERTYPAGES:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsPropertyPages(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsPPages(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsPPages(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENSIONDEFS_EXTENDS_TOOLBAR:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsToolbar(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsToolbar(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsToolbar(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENSIONDEFS_EXTENDS_NAMESPACE:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsNameSpace(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsNameSpace(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsNameSpace(pSelection);
            IfFailGo(hr);
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnExtendedSnapInChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnExtendedSnapInChange(CSelectionHolder *pSelection, DISPID dispid)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vbValue = VARIANT_FALSE;
    BSTR            bstrName = NULL;

    switch (dispid)
    {
    case DISPID_EXTENDEDSNAPIN_NODE_TYPE_NAME:
        hr = RenameExtendedSnapIn(pSelection);
        IfFailGo(hr);
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_NEW_MENU:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionNewMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionNewMenu(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_TASK_MENU:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionTaskMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionTaskMenu(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_PROPERTYPAGES:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionPropertyPages(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionPropertyPages(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_TOOLBAR:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionToolbar(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionToolbar(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_TASKPAD:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionTaskpad(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionTaskpad(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_NAMESPACE:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionNameSpace(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionNameSpace(pSelection);
            IfFailGo(hr);
        }
        break;
    }



Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnScopeItemChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnScopeItemChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_SCOPEITEMDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameScopeItem(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnListViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnListViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_LISTVIEWDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameListView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnOCXViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnOCXViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_OCXVIEWDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piOCXViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameOCXView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnURLViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnURLViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_URLVIEWDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piURLViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameURLView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnTaskpadViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnTaskpadViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT		 hr = S_OK;
	ITaskpad	*piTaskpad = NULL;
    BSTR		 bstrName = NULL;

    if (DISPID_TASKPAD_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

		hr = piTaskpad->get_Name(&bstrName);
		IfFailGo(hr);

        hr = RenameTaskpadView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
	RELEASE(piTaskpad);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnImageListChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnImageListChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_IMAGELIST_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameImageList(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnMenuChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnMenuChange
(
    CSelectionHolder *pMenu,
    DISPID            dispid
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;

    // We only need to concern ourselves with name changes,
    // and then only when the selection holder has been
    // added to the tree.
    if ( (DISPID_MENU_NAME == dispid) && (NULL != pMenu->m_pvData) )
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameMenu(pMenu, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnToolbarChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnToolbarChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_TOOLBAR_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piMMCToolbar->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameToolbar(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDataFormatChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnDataFormatChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_DATAFORMAT_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piDataFormat->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameDataFormat(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetSnapInDesignerDef                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ISnapInDesignerDef **ppiSnapInDesignerDef [out] return designer's
//                                                    ISnapInDesignerDef here
//    
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility object when it needs access to the top of
// the object model.
//
//
STDMETHODIMP CSnapInDesigner::GetSnapInDesignerDef
(
    ISnapInDesignerDef **ppiSnapInDesignerDef
)
{
    HRESULT hr = S_OK;

    if (NULL == m_piSnapInDesignerDef)
    {
        *ppiSnapInDesignerDef = NULL;
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        m_piSnapInDesignerDef->AddRef();
        *ppiSnapInDesignerDef = m_piSnapInDesignerDef;
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRuntime                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BOOL *pfRuntime [out] return flag indiciating whether host is runtime
//                          or designer
//    
// Output:
//      HRESULT
//
// Notes:
//
// Called from any object when it needs to determine if it is running at runtime
// or at design time.
//


STDMETHODIMP CSnapInDesigner::GetRuntime(BOOL *pfRuntime)
{
    HRESULT hr = S_OK;

    if (NULL == pfRuntime)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        *pfRuntime = FALSE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      Private Utility Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::CreateExtensibilityModel
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Creates the extensibility model top level object
//
HRESULT CSnapInDesigner::CreateExtensibilityModel()
{
    HRESULT hr = S_OK;

    // Destroy existing extensibility object model

    IfFailGo(DestroyExtensibilityModel());

    // Create the extensibility object model

    hr = ::CoCreateInstance(CLSID_SnapInDesignerDef,
                            NULL, // aggregate extensibility model
                            CLSCTX_INPROC_SERVER,
                            IID_ISnapInDesignerDef,
                            reinterpret_cast<void **>(&m_piSnapInDesignerDef));
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SetObjectModelHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Sets the designer as the object model host in the extensibility model
//
HRESULT CSnapInDesigner::SetObjectModelHost()
{
    HRESULT hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    if (NULL == m_piSnapInDesignerDef)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piSnapInDesignerDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailRet(hr);

    hr = piObjectModel->SetHost(static_cast<IObjectModelHost *>(this));
    piObjectModel->Release();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::DestroyExtensibilityModel
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Destroys the extensibility model top level object
//
HRESULT CSnapInDesigner::DestroyExtensibilityModel()
{
    HRESULT     hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    // If we have an extensibility model then release it

    if (NULL != m_piSnapInDesignerDef)
    {
        // First remove the host. No need to remove host on subordinate objects
        // as the object itself will do that.

        hr = m_piSnapInDesignerDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailRet(hr);

        hr = piObjectModel->SetHost(NULL);
        piObjectModel->Release();
        IfFailRet(hr);

        m_piSnapInDesignerDef->Release();
        m_piSnapInDesignerDef = NULL;
    }

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::UpdateDesignerName
//=--------------------------------------------------------------------------=
//
// Notes:
//
HRESULT CSnapInDesigner::UpdateDesignerName()
{
    HRESULT hr = S_OK;
    BOOL    fRet = FALSE;

    FREESTRING(m_bstrName);

    fRet = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME,
                              VT_BSTR,
                              &m_bstrName);
    IfFailRet(hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::ValidateName
//=--------------------------------------------------------------------------=
//
// Input:  BSTR bstrNewName [in] name to validate
//
// Output: S_OK - name is valid
//         S_FALSE - name is not valid
//         other - failure occurred
//
// Notes:
//
// Checks that the name is a valid VB identifier and that it is not currently
// in use within the snap-in's typeinfo. Displays message box if either check
// does not pass.
//
HRESULT CSnapInDesigner::ValidateName(BSTR bstrName)
{
    HRESULT hr = S_OK;
    char    szBuffer[1024];

    IfFailGo(m_piDesignerProgrammability->IsValidIdentifier(bstrName));

    if (S_FALSE == hr)
    {
        (void)::SDU_DisplayMessage(IDS_INVALID_IDENTIFIER,
                                   MB_OK | MB_ICONHAND,
                                   HID_mssnapd_InvalidIdentifier, 0,
                                   DontAppendErrorInfo, NULL, bstrName);
        goto Error;
    }
    
    IfFailGo(m_pSnapInTypeInfo->IsNameDefined(bstrName));
    if (S_OK == hr)
    {
        (void)::SDU_DisplayMessage(IDS_IDENTIFIER_IN_USE,
                                   MB_OK | MB_ICONHAND,
                                   HID_mssnapd_IdentifierInUse, 0,
                                   DontAppendErrorInfo, NULL, bstrName);
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Error:
    RRETURN(hr);
}

HRESULT CSnapInDesigner::AttachAmbients()
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarInteractive = VARIANT_FALSE;

    // If we are already attached then just return success

    IfFalseGo(!m_Ambients.Attached(), S_OK);

    // To ensure a good COleControl::m_pDispAmbient we need to fetch a
    // property as that is when the framework initializes it. There is no
    // particular reason for getting this property as opposed to some other.

    IfFalseGo(GetAmbientProperty(DISPID_AMBIENT_INTERACTIVE,
                                 VT_BOOL,
                                 &fvarInteractive), E_FAIL);

    m_Ambients.Attach(m_pDispAmbient);

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\destlib.cpp ===
//=--------------------------------------------------------------------------------------
// destlib.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Designer Dynamic Type Library
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "destlib.h"
#include "snaputil.h"


// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CSnapInTypeInfo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInTypeInfo::CSnapInTypeInfo() : m_pSnapInTypeLib(0),
  m_pcti2CoClass(0), m_guidCoClass(GUID_NULL),
  m_pctiDefaultInterface(0), m_guidDefaultInterface(GUID_NULL),
  m_pctiEventInterface(0), m_guidEventInterface(GUID_NULL),
  m_nextMemID(DISPID_DYNAMIC_BASE),
  m_bDirty(false), m_bInitialized(false), m_dwTICookie(0)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::~CSnapInTypeInfo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInTypeInfo::~CSnapInTypeInfo()
{
    RELEASE(m_pctiDefaultInterface);
    RELEASE(m_pctiEventInterface);
    RELEASE(m_pcti2CoClass);
    RELEASE(m_pSnapInTypeLib);
}


/////////////////////////////////////////////////////////////////////////////
// CSnapInTypeInfo::InitializeTypeInfo()
//
// Create a new coclass for ISnapIn, and make it look like:
//
//    [
//      uuid(9C415910-C8C1-11d1-B447-2A9646000000),
//		helpstring("Snap-In Designer")
//    ]
//    coclass SnapIn {
//		[default] interface _ISnapIn;
//		[default, source] dispinterface DSnapInEvents;
//    };

// interface _ISnapIn : ISnapIn {
// };

HRESULT CSnapInTypeInfo::InitializeTypeInfo(ISnapInDef *piSnapInDef, BSTR bstrSnapIn)
{
    HRESULT             hr = S_OK;
    BSTR                bstrSnapInName = NULL;
    ITypeInfo          *ptiSnapIn = NULL;
    ITypeInfo          *ptiSnapInEvents = NULL;
    ICreateTypeInfo    *pctiCoClass = NULL;
    LPOLESTR            pOleStr = NULL;
    BSTR                bstrIID = NULL;

    if (true == m_bInitialized)
	    goto Error;     // been there, done that

    // Create this type library
    hr = Create(L"SnapInDesigner");
    IfFailGo(hr);

    // Create a blank typeinfo for the new coclass.
    bstrSnapInName = ::SysAllocString(L"SnapIn");
    if (NULL == bstrSnapInName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = CreateCoClassTypeInfo(bstrSnapInName, &pctiCoClass, &m_guidCoClass);
    IfFailGo(hr);

    // Get ISnapIn's interface descriptions
    hr = GetSnapInTypeInfo(&ptiSnapIn, &ptiSnapInEvents);
    IfFailGo(hr);

    // Add the typeinfos for the interface and events
    hr = CreateDefaultInterface(pctiCoClass, ptiSnapIn);
    IfFailGo(hr);

    hr = AddEvents(pctiCoClass, ptiSnapInEvents);
    IfFailGo(hr);

    // Save the IID
    pOleStr = reinterpret_cast<LPOLESTR>(::CoTaskMemAlloc(1024));
    if (NULL == pOleStr)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = StringFromCLSID(m_guidDefaultInterface, &pOleStr);
    IfFailGo(hr);

    bstrIID = ::SysAllocString(pOleStr);
    if (NULL == bstrIID)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piSnapInDef->put_IID(bstrIID);
    IfFailGo(hr);

    // We've got the typeinfo for our final compilable coclass. That
    // should be about it. Store it away as ICreateTypeInfo2.
    hr = pctiCoClass->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&m_pcti2CoClass));
    IfFailGo(hr);

    // It's a good idea to always lay out your new typeinfo
    hr = m_pcti2CoClass->LayOut();
    IfFailGo(hr);

    hr = MakeDirty();
    IfFailGo(hr);

    m_bInitialized = true;

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    if (NULL != pOleStr)
        ::CoTaskMemFree(pOleStr);
    FREESTRING(bstrIID);
    RELEASE(ptiSnapInEvents);
    RELEASE(ptiSnapIn);
    RELEASE(pctiCoClass);
    FREESTRING(bstrSnapInName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameSnapIn(BSTR bstrOldName, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameSnapIn(BSTR bstrOldName, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    ITypeInfo           *pTypeInfo = NULL;
    ICreateTypeInfo2    *piCreateTypeInfo2 = NULL;

    hr = m_piTypeLib->GetTypeInfoOfGuid(m_guidCoClass, &pTypeInfo);
    IfFailGo(hr);

    hr = pTypeInfo->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&piCreateTypeInfo2));
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetName(bstrNewName);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piCreateTypeInfo2);
    RELEASE(pTypeInfo);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CreateDefaultInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::CreateDefaultInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
{
    HRESULT     hr = S_OK;
    BSTR        bstrBaseName = NULL;
    int         nBaseLen = 0;
    BSTR        bstrRealName = NULL;
    ITypeInfo  *ptiInterfaceTypeInfo = NULL;

    hr = ptiTemplate->GetDocumentation(MEMBERID_NIL, &bstrBaseName, NULL, NULL, NULL);
    IfFailGo(hr);

    nBaseLen = ::SysStringLen(bstrBaseName);
    bstrRealName = ::SysAllocStringLen(NULL, nBaseLen + 1);
    if (NULL == bstrRealName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::wcscpy(bstrRealName, L"_");
    ::wcscat(&bstrRealName[1], bstrBaseName);

    hr = CreateInterfaceTypeInfo(bstrRealName, &m_pctiDefaultInterface, &m_guidDefaultInterface);
//    hr = CreateVtblInterfaceTypeInfo(bstrRealName, &m_pctiDefaultInterface, &m_guidDefaultInterface);
    IfFailGo(hr);

    hr = CopyDispInterface(m_pctiDefaultInterface, ptiTemplate);
//    hr = SetBaseInterface(m_pctiDefaultInterface, ptiTemplate);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&ptiInterfaceTypeInfo));
    IfFailGo(hr);

    hr = AddInterface(pctiCoClass, ptiInterfaceTypeInfo);
    IfFailGo(hr);

Error:
    RELEASE(ptiInterfaceTypeInfo);
    FREESTRING(bstrRealName);
    FREESTRING(bstrBaseName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CreateEventsInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::CreateEventsInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
{
    HRESULT     hr = S_OK;
    BSTR        bstrBaseName = NULL;
    int         nBaseLen = 0;
    BSTR        bstrRealName = NULL;
    ITypeInfo  *ptiTargetEvents = NULL;

    hr = ptiTemplate->GetDocumentation(MEMBERID_NIL, &bstrBaseName, NULL, NULL, NULL);
    IfFailGo(hr);

    nBaseLen = ::SysStringLen(bstrBaseName);
    bstrRealName = ::SysAllocStringLen(NULL, nBaseLen + 1);
    if (NULL == bstrRealName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::wcscpy(bstrRealName, L"_");
    ::wcscat(&bstrRealName[1], bstrBaseName);

    hr = CloneSnapInEvents(ptiTemplate, &m_pctiEventInterface, bstrRealName);
    IfFailGo(hr);

    hr = m_pctiEventInterface->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&ptiTargetEvents));
    IfFailGo(hr);

    hr = AddEvents(pctiCoClass, ptiTargetEvents);
    IfFailGo(hr);

Error:
    RELEASE(ptiTargetEvents);
    FREESTRING(bstrRealName);
    FREESTRING(bstrBaseName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CloneSnapInEvents(ITypeInfo *ptiSnapInEvents)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::CloneSnapInEvents(ITypeInfo *ptiSnapInEvents, ICreateTypeInfo **ppiCreateTypeInfo, BSTR bstrName)
{
    HRESULT          hr = S_OK;
    ICreateTypeInfo *piCreateTypeInfo = NULL;
    GUID             guidTypeInfo = GUID_NULL;

    hr = CreateInterfaceTypeInfo(bstrName, ppiCreateTypeInfo, &guidTypeInfo);
    IfFailGo(hr);

    hr = CopyDispInterface(*ppiCreateTypeInfo, ptiSnapInEvents);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::GetSnapInLib()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Get a pointer to ISnapInDesigner's type library
//
HRESULT CSnapInTypeInfo::GetSnapInLib()
{
    HRESULT hr = S_OK;
    USHORT  usMajor = 0;
    USHORT  usMinor = 0;

    if (NULL == m_pSnapInTypeLib)		// Do this only once for each instantiation
    {
        hr = GetLatestTypeLibVersion(LIBID_SnapInLib, &usMajor, &usMinor);
        IfFailGo(hr);

        hr = ::LoadRegTypeLib(LIBID_SnapInLib,
                              usMajor,
                              usMinor,
                              LOCALE_SYSTEM_DEFAULT,
                              &m_pSnapInTypeLib);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::GetSnapInTypeInfo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Get a pointer to the ISnapIn interfaces
//
HRESULT CSnapInTypeInfo::GetSnapInTypeInfo
(
    ITypeInfo **pptiSnapIn,
    ITypeInfo **pptiSnapInEvents
)
{
    HRESULT hr = S_OK;

    ASSERT(NULL != pptiSnapIn, "GetSnapInTypeInfo: pptiSnapIn is NULL");
    ASSERT(NULL != pptiSnapInEvents, "GetSnapInTypeInfo: pptiSnapInEvents is NULL");

    hr = GetSnapInLib();
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(IID_ISnapIn, pptiSnapIn);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(DIID_DSnapInEvents, pptiSnapInEvents);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::MakeDirty()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// If the typeinfo was not dirty then increments the typeinfo cookie and marks
// the typeinfo dirty.
//
HRESULT CSnapInTypeInfo::MakeDirty()
{
    HRESULT hr = S_OK;

    if (!m_bDirty)
    {
        m_dwTICookie++;
        m_bDirty = TRUE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::AddImageList(IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// interface _ISnapIn : ISnapIn {
//  [propget,source] MMCImageList imageList1();
//  };

HRESULT CSnapInTypeInfo::AddImageList
(
    IMMCImageList *piMMCImageList
)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    DISPID              dispid = 0;
    BSTR                bstrName = NULL;
    ITypeInfo          *ptiReturnType = NULL;

    hr = piMMCImageList->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetDISPID(&dispid);
    IfFailGo(hr);

    if (0 == dispid)
    {
        dispid = m_nextMemID;
        ++m_nextMemID;

        hr = piObjectModel->SetDISPID(dispid);
        IfFailGo(hr);
    }
    else
    {
        if (dispid >= m_nextMemID)
            m_nextMemID = dispid + 1;
    }

    // Create a new property with the ImageList's name
    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    // Initialize the return value
    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCImageList, &ptiReturnType);
    IfFailGo(hr);

    hr = AddUserPropertyGet(m_pctiDefaultInterface, bstrName, ptiReturnType, dispid, 0);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piObjectModel);
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameImageList(IMMCImageList *piMMCImageList, BSTR bstrOldName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameImageList
(
    IMMCImageList *piMMCImageList,
    BSTR           bstrOldName
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;
    ITypeInfo  *ptiReturnType = NULL;

    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCImageList, &ptiReturnType);
    IfFailGo(hr);

    hr = RenameUserPropertyGet(m_pctiDefaultInterface, bstrOldName, bstrName, ptiReturnType);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteImageList(IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteImageList
(
    IMMCImageList *piMMCImageList
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;

    ASSERT(NULL != piMMCImageList, "DeleteImageList: piMMCImageList is NULL");

    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::AddToolbar(IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// interface _ISnapIn : ISnapIn {
//  [propget,source] MMCToolbar toolbar1();
//  };

HRESULT CSnapInTypeInfo::AddToolbar
(
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    DISPID              dispid = 0;
    BSTR                bstrName = NULL;
    ITypeInfo          *ptiReturnType = NULL;

    hr = piMMCToolbar->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetDISPID(&dispid);
    IfFailGo(hr);

    if (0 == dispid)
    {
        dispid = m_nextMemID;
        ++m_nextMemID;

        hr = piObjectModel->SetDISPID(dispid);
        IfFailGo(hr);
    }
    else
    {
        if (dispid >= m_nextMemID)
            m_nextMemID = dispid + 1;
    }

    // Create a new property with the Toolbar's name
    hr = piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    // Initialize the return value
    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCToolbar, &ptiReturnType);
    IfFailGo(hr);

    hr = AddUserPropertyGet(m_pctiDefaultInterface, bstrName, ptiReturnType, dispid, 0);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piObjectModel);
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameToolbar(IMMCToolbar *piMMCToolbar, BSTR bstrOldName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameToolbar
(
    IMMCToolbar *piMMCToolbar,
    BSTR         bstrOldName
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;
    ITypeInfo  *ptiReturnType = NULL;

    hr = piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCToolbar, &ptiReturnType);
    IfFailGo(hr);

    hr = RenameUserPropertyGet(m_pctiDefaultInterface, bstrOldName, bstrName, ptiReturnType);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteToolbar(IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteToolbar
(
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;

    ASSERT(NULL != piMMCToolbar, "DeleteImageList: piMMCToolbar is NULL");

    hr = piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::AddMenu(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// interface _ISnapIn : ISnapIn {
//  [propget,source] MMCMenu menu1();
//  };

HRESULT CSnapInTypeInfo::AddMenu
(
    IMMCMenu *piMMCMenu
)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    DISPID              dispid = 0;
    BSTR                bstrName = NULL;
    ITypeInfo          *ptiReturnType = NULL;

    hr = piMMCMenu->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetDISPID(&dispid);
    IfFailGo(hr);

    if (0 == dispid)
    {
        dispid = m_nextMemID;
        ++m_nextMemID;

        hr = piObjectModel->SetDISPID(dispid);
        IfFailGo(hr);
    }
    else
    {
        if (dispid >= m_nextMemID)
            m_nextMemID = dispid + 1;
    }

    // Create a new property with the Menu's name
    hr = piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    // Initialize the return value
    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCMenu, &ptiReturnType);
    IfFailGo(hr);

    hr = AddUserPropertyGet(m_pctiDefaultInterface, bstrName, ptiReturnType, dispid, 0);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piObjectModel);
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameMenu(IMMCMenu *piMMCMenu, BSTR bstrOldName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameMenu
(
    IMMCMenu *piMMCMenu,
    BSTR      bstrOldName
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;
    ITypeInfo  *ptiReturnType = NULL;

    hr = piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCMenu, &ptiReturnType);
    IfFailGo(hr);

    hr = RenameUserPropertyGet(m_pctiDefaultInterface, bstrOldName, bstrName, ptiReturnType);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteMenu(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteMenu
(
    IMMCMenu *piMMCMenu
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    ASSERT(NULL != piMMCMenu, "DeleteMenu: piMMCMenu is NULL");

    hr = piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteMenuNamed(BSTR bstrName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteMenuNamed
(
    BSTR bstrName
)
{
    HRESULT hr = S_OK;

    ASSERT(NULL != bstrName, "DeleteMenuNamed: bstrName is NULL");

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::IsNameDefined(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return S_OK if name is present in the main interface, S_FALSE otherwise
//
HRESULT CSnapInTypeInfo::IsNameDefined(BSTR bstrName)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;

    hr = GetNameIndex(m_pctiDefaultInterface, bstrName, &lIndex);
    IfFailGo(hr);

    if (-1 == lIndex)
        hr = S_FALSE;

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dlgunits.cpp ===
//=--------------------------------------------------------------------------------------
// dlgunits.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dialog Unit Converter Dialog Box
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "desmain.h"
#include "..\..\mssnapr\mssnapr\prpchars.h"

// for ASSERT and FAIL
//
SZTHISFILE



static HRESULT Calc(HWND hwndDlg)
{
    HRESULT hr = S_OK;
    BOOL    fTranslated = FALSE;
    int     xDLUs = 0;
    int     yDLUs = 0;
    UINT    cxChar = 0;
    UINT    cyChar = 0;
    UINT    xPixels = 0;
    UINT    yPixels = 0;
    UINT    xTwips = 0;
    UINT    yTwips = 0;
    UINT    xPoints = 0;
    UINT    yPoints = 0;
    double  xR4Points = 0;
    double  yR4Points = 0;
    HDC     hdc = NULL;

    // Blank out all the calculated fields
    
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_PIXELS_WIDTH, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_PIXELS_HEIGHT, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_TWIPS_WIDTH, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_PIXELS_HEIGHT, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_POINTS_WIDTH, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_POINTS_HEIGHT, ""), HRESULT_FROM_WIN32(::GetLastError()));

    // Get the width and height in dialog units specified by the user

    xDLUs = ::GetDlgItemInt(hwndDlg, IDC_EDIT_WIDTH, &fTranslated, FALSE);
    IfFalseGo(fTranslated, HRESULT_FROM_WIN32(::GetLastError()));

    yDLUs = ::GetDlgItemInt(hwndDlg, IDC_EDIT_HEIGHT, &fTranslated, FALSE);
    IfFalseGo(fTranslated, HRESULT_FROM_WIN32(::GetLastError()));

    // Get the average character height and width in a Win32 property sheet

    IfFailGo(::GetPropSheetCharSizes(&cxChar, &cyChar));

    // Calculate and display the pixel values

    xPixels = (xDLUs * cxChar) / 4;
    yPixels = (yDLUs * cyChar) / 8;

    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_PIXELS_WIDTH, xPixels, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_PIXELS_HEIGHT, yPixels, FALSE), HRESULT_FROM_WIN32(::GetLastError()));

    // Get a screen DC
    hdc = ::GetDC(NULL);
    IfFalseGo(NULL != hdc, HRESULT_FROM_WIN32(::GetLastError()));

    // Calculate and display the points values.
    // A point = 1/72 inch
    // (Pixels per point) = (pixels per logical inch) / 72.
    // Points = pixels / (pixels per point).

    xR4Points  = (float)xPixels / ((float)::GetDeviceCaps(hdc, LOGPIXELSX) / 72.0);
    yR4Points  = (float)yPixels / ((float)::GetDeviceCaps(hdc, LOGPIXELSY) / 72.0);

    xPoints = (UINT)xR4Points;
    yPoints = (UINT)yR4Points;

    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_POINTS_WIDTH, xPoints, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_POINTS_HEIGHT, yPoints, FALSE), HRESULT_FROM_WIN32(::GetLastError()));

    // Calculate and display the twips values. A twip is 1/20 of a point so just
    // multiply by 20.

    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_TWIPS_WIDTH, xPoints * 20, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_TWIPS_HEIGHT, yPoints * 20, FALSE), HRESULT_FROM_WIN32(::GetLastError()));


Error:
    if (NULL != hdc)
    {
        (void)::ReleaseDC(NULL, hdc);
    }
    return hr;
}


static HRESULT CenterDialog(HWND hwndDlg)
{
    HRESULT hr = S_OK;
    int     nScreenWidth = ::GetSystemMetrics(SM_CXSCREEN);
    int     nScreenHeight = ::GetSystemMetrics(SM_CYSCREEN);
    int     nDlgWidth = 0;
    int     nDlgHeight = 0;
    BOOL    fRet = FALSE;

    RECT rectDlg = { 0, 0, 0, 0 };

    IfFalseGo(::GetWindowRect(hwndDlg, &rectDlg), HRESULT_FROM_WIN32(::GetLastError()));

    nDlgWidth = (rectDlg.right - rectDlg.left);
    nDlgHeight = (rectDlg.bottom - rectDlg.top);

    fRet = ::MoveWindow(hwndDlg, 
                        (int)((nScreenWidth - nDlgWidth) / 2), 
                        (int)((nScreenHeight - nDlgHeight) / 2),
                        nDlgWidth,
                        nDlgHeight,
                        FALSE);
    IfFalseGo(fRet, HRESULT_FROM_WIN32(::GetLastError()));

Error:
    RRETURN(hr);
}


static INT_PTR CALLBACK DlgUnitsDlgProc
(
    HWND   hwndDlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL    fProcessed = FALSE;
    HRESULT hr = S_OK;

    switch (msg)
    {
        case WM_INITDIALOG:
            IfFailGo(::CenterDialog(hwndDlg));
            IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_EDIT_HEIGHT, 218, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
            IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_EDIT_WIDTH, 252, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
            IfFalseGo(::PostMessage(hwndDlg, WM_COMMAND,
                                   MAKEWPARAM(ID_BUTTON_CALC, BN_CLICKED),
                                   (LPARAM)::GetDlgItem(hwndDlg, ID_BUTTON_CALC)),
                      HRESULT_FROM_WIN32(::GetLastError()));
            fProcessed = TRUE;
            break;

        case WM_HELP:
            g_GlobalHelp.ShowHelp(HID_mssnapd_DlgUnits);
            fProcessed = TRUE;
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case ID_BUTTON_CALC:
                    IfFailGo(::Calc(hwndDlg));
                    fProcessed = TRUE;
                    break;

                case IDHELP:
                    g_GlobalHelp.ShowHelp(HID_mssnapd_DlgUnits);
                    fProcessed = TRUE;
                    break;

                case IDOK:
                case IDCANCEL:
                    ::EndDialog(hwndDlg, 0);
                    fProcessed = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }

Error:
    if (FAILED(hr))
    {
        ::EndDialog(hwndDlg, static_cast<int>(hr));
    }
    
    return fProcessed;
}



HRESULT CSnapInDesigner::ShowDlgUnitConverter()
{
    HRESULT hr = S_OK;
    int iRc = ::DialogBox(GetResourceHandle(),
                          MAKEINTRESOURCE(IDD_DIALOG_DLGUNITS),
                          m_hwnd,
                          DlgUnitsDlgProc);
    if (-1 == iRc)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        hr = static_cast<HRESULT>(iRc);
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\destlib.h ===
//=--------------------------------------------------------------------------------------
// destlib.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dynamic Type Library encapsulation
//=-------------------------------------------------------------------------------------=

#ifndef _MMCDESIGNER_TYPE_LIB_
#define _MMCDESIGNER_TYPE_LIB_

#include "dtypelib.h"

const DISPID    DISPID_OBJECT_PROPERTY_START = 0x00000500;


class CSnapInTypeInfo : public CDynamicTypeLib
{
public:
    CSnapInTypeInfo();
    virtual ~CSnapInTypeInfo();

    HRESULT InitializeTypeInfo(ISnapInDef *piSnapInDef, BSTR bstrSnapIn);

	inline HRESULT GetTypeInfo(ITypeInfo **ppiTypeInfo)
	{
		return m_pcti2CoClass->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(ppiTypeInfo));
	}

    bool ResetDirty()
    {
        bool    bWasDirty = m_bDirty;
        m_bDirty = false;
        return bWasDirty;
    }

    DWORD GetCookie() { return m_dwTICookie; }
    void SetCookie(DWORD dwCookie) { m_dwTICookie = dwCookie; }

    HRESULT RenameSnapIn(BSTR bstrOldName, BSTR bstrNewName);

    HRESULT AddImageList(IMMCImageList *piMMCImageList);
    HRESULT RenameImageList(IMMCImageList *piMMCImageList, BSTR bstrOldName);
    HRESULT DeleteImageList(IMMCImageList *piMMCImageList);

    HRESULT AddToolbar(IMMCToolbar *piMMCToolbar);
    HRESULT RenameToolbar(IMMCToolbar *piMMCToolbar, BSTR bstrOldName);
    HRESULT DeleteToolbar(IMMCToolbar *piMMCToolbar);

    HRESULT AddMenu(IMMCMenu *piMMCMenu);
    HRESULT RenameMenu(IMMCMenu *piMMCMenu, BSTR bstrOldName);
    HRESULT DeleteMenu(IMMCMenu *piMMCMenu);
    HRESULT DeleteMenuNamed(BSTR bstrName);

    HRESULT IsNameDefined(BSTR bstrName);

protected:
	// Utility functions
	HRESULT GetSnapInLib();
    HRESULT GetSnapInTypeInfo(ITypeInfo **pptiSnapIn, ITypeInfo **pptiSnapInEvents);
    HRESULT CloneSnapInEvents(ITypeInfo *ptiSnapInEvents, ICreateTypeInfo **ppiCreateTypeInfo, BSTR bstrName);
    HRESULT MakeDirty();

    HRESULT CreateDefaultInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate);
    HRESULT CreateEventsInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate);

protected:
	// SnapInDesignerDef's type library, source of our templates
	ITypeLib			*m_pSnapInTypeLib;

	// CoClass information
	ICreateTypeInfo2	*m_pcti2CoClass;
	GUID				 m_guidCoClass;			

	// SnapInDesignerDef' interfaces
    ICreateTypeInfo		*m_pctiDefaultInterface;
    GUID                 m_guidDefaultInterface;
    ICreateTypeInfo		*m_pctiEventInterface;
    GUID                 m_guidEventInterface;

    DISPID               m_nextMemID;
    bool                 m_bDirty;
    bool                 m_bInitialized;
    DWORD                m_dwTICookie;                // host typeinfo cookie

};


#endif  // _MMCDESIGNER_TYPE_LIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dmenu.cpp ===
//=--------------------------------------------------------------------------------------
// menu.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Menu-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddMenu(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddMenu(CSelectionHolder *pSelection)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piMMCMenus = NULL;
    VARIANT    vtEmpty;
    IMMCMenu  *piMMCMenu = NULL;

    ::VariantInit(&vtEmpty);

    if ( (SEL_TOOLS_ROOT == pSelection->m_st) ||
         (SEL_TOOLS_MENUS == pSelection->m_st) )
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pSelection->m_st)
    {
        hr = pSelection->m_piObject.m_piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCMenus));
        IfFailGo(hr);
    }

    if (piMMCMenus != NULL)
    {
        vtEmpty.vt = VT_ERROR;
        vtEmpty.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCMenus->Add(vtEmpty, vtEmpty, &piMMCMenu);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtEmpty);
    RELEASE(piMMCMenus);
    RELEASE(piMMCMenu);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DemoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Make this node a child of the preceeding node.
//  If this node is not a leaf, then the whole tree
//  needs to be indented.
HRESULT CSnapInDesigner::DemoteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pPreviousMenu = NULL;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    BSTR              bstrKey = NULL;
    IMMCMenu         *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    m_bDoingPromoteOrDemote = TRUE;

    // Get the previous node
    hr = m_pTreeView->GetPreviousNode(pMenu, &pPreviousMenu);
    IfFailGo(hr);

    // Get the menu definition tree for the previous node
    piMMCMenu = pMenu->m_piObject.m_piMMCMenu;
    piMMCMenu->AddRef();

    // Get the parent of this node
    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    // Get the menu collection that contains this node
    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Remove this menu from its containing collection
    if (piMMCMenus != NULL)
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Key(&bstrKey);
        IfFailGo(hr);

        varKey.vt = VT_BSTR;
        varKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        // Doing a Remove operation on the collection will generate an
        // OnDeleteMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything.

        hr = piMMCMenus->Remove(varKey);
        IfFailGo(hr);
    }

    // Add this menu node to the preceeding node's collection.
    RELEASE(piMMCMenus);

    hr = pPreviousMenu->m_piObject.m_piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCMenus));
    IfFailGo(hr);

    if (piMMCMenus != NULL)
    {
        // Doing an AddExisting operation on the collection will generate an
        // OnAddMMCMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything. We
        // don't specify an index because in a demotion the new position is
        // following the last child of the new parent which means appending
        // to the end of the collection.

        varIndex.vt = VT_ERROR;
        varIndex.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCMenus->AddExisting(piMMCMenu, varIndex);
        IfFailGo(hr);
    }

    // Now we need to prune the old subtree from its old parent and graft
    // it to its new parent.
    IfFailGo(m_pTreeView->PruneAndGraft(pMenu, pPreviousMenu, kMenuIcon));

    // Set the selection to this menu in its new position

    IfFailGo(m_pTreeView->SelectItem(pMenu));
    IfFailGo(OnSelectionChanged(pMenu));

Error:
    m_bDoingPromoteOrDemote = FALSE;

    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_DEMOTE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_DemoteFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piMMCMenu);
    FREESTRING(bstrKey);
    ::VariantClear(&varKey);
    RELEASE(piMMCMenu);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PromoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Make the currently selected menu a peer of its parent.
//
HRESULT CSnapInDesigner::PromoteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    BSTR              bstrKey = NULL;
    CSelectionHolder *pParentParentMenu = NULL;
    IMMCMenu         *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    m_bDoingPromoteOrDemote = TRUE;

    // Get the root of the menu tree being promoted
    piMMCMenu = pMenu->m_piObject.m_piMMCMenu;
    piMMCMenu->AddRef();

    // Get the parent of this node
    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    // Get the menu collection that contains this node (the parent's child
    // menu collection)
    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Remove this menu from its containing collection
    if (piMMCMenus != NULL)
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Key(&bstrKey);
        IfFailGo(hr);

        varKey.vt = VT_BSTR;
        varKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        // Doing a Remove operation on the collection will generate an
        // OnDeleteMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything.

        hr = piMMCMenus->Remove(varKey);
        IfFailGo(hr);
    }

    RELEASE(piMMCMenus);

    // Get the parent's parent
    
    hr = m_pTreeView->GetParent(pParentMenu, &pParentParentMenu);
    IfFailGo(hr);

    // Get the parent's parent's child menu collection

    if (SEL_TOOLS_MENUS == pParentParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentParentMenu->m_st)
    {
        piMMCMenus = pParentParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Add the node to its parent's parent's child nodes.
    // Ensure that the node has an index that is immediately following its
    // old parent's index. This is so the node will appear in the menu immediately
    // following its parent. That is the user's expectation when promoting a node.
    // For example, given the following menu:
    //
    //  Menus
    //      Menu1
    //          Menu1Child
    //      Menu2
    //
    // If the user promotes Menu1Child they expect the tree to appear as follows:
    //
    //  Menus
    //      Menu1
    //      Menu1Child
    //      Menu2
    //

    if (piMMCMenus != NULL)
    {
        IfFailGo(pParentMenu->m_piObject.m_piMMCMenu->get_Index(&varIndex.lVal));
        varIndex.vt = VT_I4;
        varIndex.lVal++;
        
        // Doing an AddExisting operation on the collection will generate an
        // OnAddMMCMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything.
        hr = piMMCMenus->AddExisting(piMMCMenu, varIndex);
        IfFailGo(hr);
    }

    // Now move the menu node in the treeview to the position immediately
    // following its old parent, (as a peer of its old parent), and re-parent
    // its child menu nodes to the new position.

    IfFailGo(m_pTreeView->MoveNodeAfter(pMenu, pParentParentMenu, pParentMenu,
                                        kMenuIcon));

    // Set the selection to this menu in its new position

    IfFailGo(m_pTreeView->SelectItem(pMenu));
    IfFailGo(OnSelectionChanged(pMenu));

Error:
    m_bDoingPromoteOrDemote = FALSE;

    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_PROMOTE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_PromoteFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piMMCMenu);
    FREESTRING(bstrKey);
    ::VariantClear(&varKey);
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MoveMenuUp(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Swap previous with current
//
HRESULT CSnapInDesigner::MoveMenuUp(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    CSelectionHolder *pPreviousMenu = NULL;
    long              lOldIndex = 0;
    long              lNewIndex = 0;

    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Get the previous node and get the current indices
    hr = m_pTreeView->GetPreviousNode(pMenu, &pPreviousMenu);
    IfFailGo(hr);

    hr = pMenu->m_piObject.m_piMMCMenu->get_Index(&lOldIndex);
    IfFailGo(hr);

    hr = pPreviousMenu->m_piObject.m_piMMCMenu->get_Index(&lNewIndex);
    IfFailGo(hr);

    // Swap them
    hr = piMMCMenus->Swap(lOldIndex, lNewIndex);
    IfFailGo(hr);

    hr = SetMenuKey(pMenu);
    IfFailGo(hr);

    hr = SetMenuKey(pPreviousMenu);
    IfFailGo(hr);

    // Move the previous menu node after the moving menu node and reparent
    // its children

    IfFailGo(m_pTreeView->MoveNodeAfter(pPreviousMenu, pParentMenu, pMenu,
                                        kMenuIcon));

    // Select the moving node
    
    hr = m_pTreeView->SelectItem(pMenu);
    IfFailGo(hr);

    hr = OnSelectionChanged(pMenu);
    IfFailGo(hr);

Error:
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MoveMenuDown(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MoveMenuDown(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    CSelectionHolder *pNextMenu = NULL;
    long              lOldIndex = 0;
    long              lNewIndex = 0;

    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Get the next node and get the current indices
    hr = m_pTreeView->GetNextChildNode(pMenu, &pNextMenu);
    IfFailGo(hr);

    hr = pMenu->m_piObject.m_piMMCMenu->get_Index(&lOldIndex);
    IfFailGo(hr);

    hr = pNextMenu->m_piObject.m_piMMCMenu->get_Index(&lNewIndex);
    IfFailGo(hr);

    // Swap them
    hr = piMMCMenus->Swap(lOldIndex, lNewIndex);
    IfFailGo(hr);

    hr = SetMenuKey(pMenu);
    IfFailGo(hr);

    hr = SetMenuKey(pNextMenu);
    IfFailGo(hr);

    // Move the moving menu node after the next menu node and reparent
    // its children

    IfFailGo(m_pTreeView->MoveNodeAfter(pMenu, pParentMenu, pNextMenu, kMenuIcon));

    hr = m_pTreeView->SelectItem(pMenu);
    IfFailGo(hr);

    hr = OnSelectionChanged(pMenu);
    IfFailGo(hr);

Error:
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddMMCMenu(CSelectionHolder *pParent, IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddMMCMenu(CSelectionHolder *pParent, IMMCMenu *piMMCMenu)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pMenu = NULL;
    long                 lCount = 0;
    long                 lIndex = 0;
    IMMCMenu            *piMMCChildMenu = NULL;

    VARIANT vtIndex;
    ::VariantInit(&vtIndex);

    IfFalseGo(!m_bDoingPromoteOrDemote, S_OK);

    ASSERT(NULL != pParent, "OnAddMMCMenu: pParent is NULL");
    ASSERT(NULL != piMMCMenu, "OnAddMMCMenu: piMMCMenu is NULL");

    hr = MakeNewMenu(piMMCMenu, &pMenu);
    IfFailGo(hr);

    hr = pMenu->RegisterHolder();
    IfFailGo(hr);

    hr = InsertMenuInTree(pMenu, pParent);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->AddMenu(pMenu->m_piObject.m_piMMCMenu);
    IfFailGo(hr);

    // Add the children, if any
    hr = pMenu->m_piChildrenMenus->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = pMenu->m_piChildrenMenus->get_Item(vtIndex, reinterpret_cast<MMCMenu **>(&piMMCChildMenu));
        IfFailGo(hr);

        hr = OnAddMMCMenu(pMenu, piMMCChildMenu);
        IfFailGo(hr);

        RELEASE(piMMCChildMenu);
    }

    // All done. Set the selection
    hr = OnSelectionChanged(pMenu);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pMenu);
    IfFailGo(hr);

    if (false == m_bDoingPromoteOrDemote)
    {
        hr = m_pTreeView->Edit(pMenu);
        IfFailGo(hr);
    }

    m_fDirty = TRUE;

Error:
    ::VariantClear(&vtIndex);
    RELEASE(piMMCChildMenu);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AssignMenuDispID(CSelectionHolder *pMenuTarget, CSelectionHolder *pMenuSrc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  pMenuTarget->DISPID = pMenuSrc->DISPID
//
HRESULT CSnapInDesigner::AssignMenuDispID(CSelectionHolder *pMenuTarget, CSelectionHolder *pMenuSrc)
{
    HRESULT         hr = S_OK;
    IObjectModel   *piObjectModelTarget = NULL;
    DISPID          dispid = 0;
    IObjectModel   *piObjectModelSrc = NULL;

    ASSERT(NULL != pMenuTarget, "AssignMenuDispID: pMenuTarget is NULL");
    ASSERT(NULL != pMenuSrc, "AssignMenuDispID: pMenuSrc is NULL");

    hr = pMenuTarget->m_piObject.m_piMMCMenu->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModelTarget));
    IfFailGo(hr);

    hr = piObjectModelTarget->GetDISPID(&dispid);
    IfFailGo(hr);

    hr = pMenuSrc->m_piObject.m_piMMCMenu->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModelSrc));
    IfFailGo(hr);

    hr = piObjectModelSrc->SetDISPID(dispid);
    IfFailGo(hr);

Error:
    RELEASE(piObjectModelSrc);
    RELEASE(piObjectModelTarget);

    RRETURN(hr);
}




//=--------------------------------------------------------------------------------------
// CSnapInDesigner::SetMenuKey(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::SetMenuKey(CSelectionHolder *pMenu)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;

    VARIANT varKey;
    ::VariantInit(&varKey);

    hr = pMenu->m_piObject.m_piMMCMenu->get_Name(&varKey.bstrVal);
    IfFailGo(hr);
    varKey.vt = VT_BSTR;

    hr = pMenu->m_piObject.m_piMMCMenu->put_Key(varKey.bstrVal);
    IfFailGo(hr);

Error:
    ::VariantClear(&varKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameMenu(CSelectionHolder *pMenu, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameMenu(CSelectionHolder *pMenu, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrOldName = NULL;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_TOOLS_MENUS_NAME == pMenu->m_st, "RenameMenu: wrong argument");

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    // If the new name is already defined, delete the old one,
    // otherwise rename the old one with the new name
    hr = m_pTreeView->GetLabel(pMenu, &bstrOldName);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->RenameMenu(pMenu->m_piObject.m_piMMCMenu, bstrOldName);
    IfFailGo(hr);

    // Update the tree
    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pMenu, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
    {
        CtlFree(pszName);
    }
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParent = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    BSTR              bstrKey = NULL;
    VARIANT           varKey;

    ::VariantInit(&varKey);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParent->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParent->m_st)
    {
        piMMCMenus = pParent->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    if (piMMCMenus != NULL)
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Key(&bstrKey);
        IfFailGo(hr);

        varKey.vt = VT_BSTR;
        varKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piMMCMenus->Remove(varKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&varKey);
    FREESTRING(bstrKey);
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


HRESULT CSnapInDesigner::DeleteMenuTreeTypeInfo(IMMCMenu *piMMCMenu)
{
    HRESULT    hr = S_OK;
    BSTR       bstrName = NULL;
    IMMCMenus *piChildren = NULL;
    IMMCMenu  *piChild = NULL;
    long       cChildren = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(piMMCMenu->get_Name(&bstrName));

    IfFailGo(m_pSnapInTypeInfo->IsNameDefined(bstrName));

    if (S_OK == hr)
    {
        hr = m_pSnapInTypeInfo->DeleteMenu(piMMCMenu);
        IfFailGo(hr);
    }

    IfFailGo(piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piChildren)));
    IfFailGo(piChildren->get_Count(&cChildren));

    varIndex.vt = VT_I4;
    for (varIndex.lVal = 1L; varIndex.lVal <= cChildren; varIndex.lVal++)
    {
        IfFailGo(piChildren->get_Item(varIndex, reinterpret_cast<MMCMenu **>(&piChild)));
        IfFailGo(DeleteMenuTreeTypeInfo(piChild));
        RELEASE(piChild);
    }

Error:
    QUICK_RELEASE(piChild);
    QUICK_RELEASE(piChildren);
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParent = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    long              lCount = 0;

    IfFalseGo(!m_bDoingPromoteOrDemote, S_OK);

    IfFailGo(DeleteMenuTreeTypeInfo(pMenu->m_piObject.m_piMMCMenu));

    // Clear all cookies for this menu tree
    hr = UnregisterMenuTree(pMenu);
	IfFailGo(hr);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pMenu);
    IfFailGo(hr);

    delete pMenu;

    // Select the next selection
    switch (pParent->m_st)
    {
    case SEL_TOOLS_MENUS:
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
        break;
    }

    if (NULL != piMMCMenus)
    {
        hr = piMMCMenus->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::UnregisterMenuTree(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::UnregisterMenuTree
(
    CSelectionHolder *pMenu
)
{
    HRESULT           hr = S_OK;
	long              lCount = 0;
	long              lIndex = 0;
    VARIANT           vtIndex;
    IMMCMenu         *piMMCMenu = NULL;
	IUnknown         *piUnknown = NULL;
	CSelectionHolder *pChildMenu = NULL;

    ::VariantInit(&vtIndex);

	hr = pMenu->UnregisterHolder();
	IfFailGo(hr);

	hr = pMenu->m_piChildrenMenus->get_Count(&lCount);
	IfFailGo(hr);

	for (lIndex = 1; lIndex <= lCount; ++lIndex)
	{
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

		hr = pMenu->m_piChildrenMenus->get_Item(vtIndex, reinterpret_cast<MMCMenu **>(&piMMCMenu));
		IfFailGo(hr);

		hr = piMMCMenu->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
		IfFailGo(hr);

		hr = m_pTreeView->FindInTree(piUnknown, &pChildMenu);
        IfFailGo(hr);

		hr = UnregisterMenuTree(pChildMenu);
        IfFailGo(hr);

		RELEASE(piUnknown);
		RELEASE(piMMCMenu);
	}

Error:
	RELEASE(piUnknown);
	RELEASE(piMMCMenu);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewMenu(IMMCMenu *piMMCMenu, CSelectionHolder **ppMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewMenu
(
    IMMCMenu          *piMMCMenu,
    CSelectionHolder **ppMenu
)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piChildren = NULL;

    hr = piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piChildren));
    IfFailGo(hr);

    *ppMenu = New CSelectionHolder(piMMCMenu, piChildren);
    if (*ppMenu == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewMenu(piMMCMenu);
    IfFailGo(hr);

    hr = SetMenuKey(*ppMenu);
	IfFailGo(hr);

Error:
    RELEASE(piChildren);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewMenu(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewMenu
(
    IMMCMenu *piMMCMenu
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    CSelectionHolder *pMenuClone = NULL;

	hr = piMMCMenu->get_Name(&bstrName);
	IfFailGo(hr);

	if (NULL == bstrName || 0 == ::SysStringLen(bstrName))
	{
		hr = GetResourceString(IDS_MENU, szBuffer, kMaxBuffer);
		IfFailGo(hr);

		do {
			iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
			if (iResult == 0)
			{
				hr = HRESULT_FROM_WIN32(::GetLastError());
				EXCEPTION_CHECK(hr);
			}

			hr = m_pTreeView->FindLabelInTree(szName, &pMenuClone);
			IfFailGo(hr);

			if (S_FALSE == hr)
			{
				break;
			}
		} while (TRUE);

		FREESTRING(bstrName);
		hr = BSTRFromANSI(szName, &bstrName);
		IfFailGo(hr);
	}

	hr = piMMCMenu->put_Name(bstrName);
	IfFailGo(hr);

	hr = piMMCMenu->put_Caption(bstrName);
	IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertMenuInTree(CSelectionHolder *pMenu, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertMenuInTree
(
    CSelectionHolder *pMenu,
    CSelectionHolder *pParent
)
{
    HRESULT      hr = S_OK;
    BSTR         bstrName = NULL;
    TCHAR       *pszName = NULL;

    hr = pMenu->m_piObject.m_piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kMenuIcon, pMenu);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsTopLevelMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::IsTopLevelMenu
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParent->m_st)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanPromoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only promote (make a peer of preceeding node) this menu if:
//
//  1. It is not the first child of the SEL_TOOLS_MENUS node
//
HRESULT CSnapInDesigner::CanPromoteMenu
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParent->m_st)
        hr = S_FALSE;
    else
        hr = S_OK;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanDemoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only demote (make a child of preceeding node) this menu if:
//
//  1. It is not the first child of the parent node
//
HRESULT CSnapInDesigner::CanDemoteMenu
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    CSelectionHolder    *pSelection = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->GetFirstChildNode(pParent, &pSelection);
    IfFailGo(hr);

    if (pSelection != pMenu)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanMoveMenuUp(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only move menu up if:
//
//  1. It is not the first child of the parent node
//
HRESULT CSnapInDesigner::CanMoveMenuUp
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    CSelectionHolder    *pSelection = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->GetFirstChildNode(pParent, &pSelection);
    IfFailGo(hr);

    if (pSelection != pMenu)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanMoveMenuDown(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only move menu down if:
//
//  1. There is another peer after it
//
HRESULT CSnapInDesigner::CanMoveMenuDown
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;

    hr = m_pTreeView->GetNextChildNode(pMenu, &pSelection);
    IfFailGo(hr);

    if (NULL != pSelection)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dll.cpp ===
//=--------------------------------------------------------------------------=
// dll.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//
// Various routines et all that aren't in a file for a particular automation
// object, and don't need to be in the generic ole automation code.
//
#include "pch.h"

#include <initguid.h>              // define all the guids.
#define INITOBJECTS                // define AUTOMATIONOBJECTINFO structs
#include "common.h"

#include "desmain.h"
#include "guids.h"
#include "psmain.h"
#include "psextend.h"
#include "psnode.h"
#include "pslistvw.h"
#include "psurl.h"
#include "psocx.h"
#include "pstaskp.h"
#include "psimglst.h"
#include "pstoolbr.h"


// mssnapr punk. We need to ensure the mssnapd DLL is loaded for the duration
// of the mssnapd.ocx load so that DllGetDocumentation works
//
static LPUNKNOWN g_punkMssnapr = NULL;

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// Our Libid.  This should be the LIBID from the Type library, or NULL if you
// don't have one.
//
const CLSID *g_pLibid = &LIBID_SnapInLib;

//=--------------------------------------------------------------------------=
// Set this up if you want to have a window proc for your parking window. This
// is really only interesting for Sub-classed controls that want, in design
// mode, certain messages that are sent only to the parent window.
//
WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//    a. whether or not this DLL uses satellite DLLs for localization.  if
//       not, then the lcidLocale is ignored, and we just always get resources
//       from the server module file.
//    b. the ambient LocaleID for this in-proc server.  Controls calling
//       GetResourceHandle() will set this up automatically, but anybody
//       else will need to be sure that it's set up properly.
//
const VARIANT_BOOL g_fSatelliteLocalization =  TRUE;
LCID               g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


//=--------------------------------------------------------------------------=
// your license key and where under HKEY_CLASSES_ROOT_LICENSES it's sitting
//
const WCHAR g_wszLicenseKey [] = L"";
const WCHAR g_wszLicenseLocation [] = L"";

//=--------------------------------------------------------------------------=
// TODO: 
//
// Setting this flag to TRUE will cause your control to be created using
// its runtime license key even if it's created as part of a composite
// control (ie: a VB5-built UserControl) in a design environment.  A user
// of the composite control does not need to acquire or purchase your design-time
// license in order to use the composite control.
//
// The current setting of FALSE means that in order for your control to 
// load as part of a composite control (in a design-time environment), 
// the composite control user will need to acquire or purchase your 
// control's design-time license.  This setting is more restrictive 
// in terms of control distribution and licensing when compared to 
// setting this to TRUE. 
//
const BOOL g_fUseRuntimeLicInCompositeCtl = FALSE;


// TODO: Cleanup this mess
static char szInstanceInfo [] = "CLSID\\{B3E55942-FFD8-11d1-9788-44A620524153}\\Instance CLSID";
static char szRuntimeInstCLSID[] = "{9C415910-C8C1-11d1-B447-2A9646000000}";
static const char szMiscStatusRegKey [] = "CLSID\\{B3E55942-FFD8-11d1-9788-44A620524153}\\MiscStatus\\1";
static const char szMiscStatusValue [] = "1024";
static char szPublicSetting [] = "CLSID\\{B3E55942-FFD8-11d1-9788-44A620524153}\\DesignerFeatures";

static DWORD dwPublicFlag = DESIGNERFEATURE_MUSTBEPUBLIC |
                            DESIGNERFEATURE_CANBEPUBLIC |
                            DESIGNERFEATURE_CANCREATE |
                            DESIGNERFEATURE_NOTIFYAFTERRUN |
                            DESIGNERFEATURE_STARTUPINFO |
                            DESIGNERFEATURE_NOTIFYBEFORERUN |
                            DESIGNERFEATURE_REGISTRATION |
                            DESIGNERFEATURE_INPROCONLY;

static char szImplementedCatsKey [] = "Implemented Categories";

//=--------------------------------------------------------------------------=
// This Table describes all the automatible objects in your automation server.
// See AutomationObject.H for a description of what goes in this structure
// and what it's used for.
//
OBJECTINFO g_ObjectInfo[] = {
    CONTROLOBJECT(SnapInDesigner),

	PROPERTYPAGE(SnapInGeneral),
	PROPERTYPAGE(SnapInImageList),
	PROPERTYPAGE(SnapInAvailNodes),

    PROPERTYPAGE(NodeGeneral),
    PROPERTYPAGE(ScopeItemDefColHdrs),

    PROPERTYPAGE(ListViewGeneral),
	PROPERTYPAGE(ListViewImgLists),
	PROPERTYPAGE(ListViewSorting),
	PROPERTYPAGE(ListViewColHdrs),

    PROPERTYPAGE(URLViewGeneral),
	PROPERTYPAGE(OCXViewGeneral),

	PROPERTYPAGE(ImageListImages),

	PROPERTYPAGE(ToolbarGeneral),
	PROPERTYPAGE(ToolbarButtons),

	PROPERTYPAGE(TaskpadViewGeneral),
	PROPERTYPAGE(TaskpadViewBackground),
	PROPERTYPAGE(TaskpadViewTasks),

    EMPTYOBJECT
};

//=--------------------------------------------------------------------------=
// These are all of the CATID's that the control needs to register.
//
const CATID *g_rgCATIDImplemented[] =
{
  &CATID_Designer,
  &CATID_PersistsToPropertyBag,
  &CATID_PersistsToStreamInit,
  &CATID_PersistsToStorage,
};
extern const int g_ctCATIDImplemented = sizeof(g_rgCATIDImplemented) / 
                                        sizeof(CATID *);
const CATID *g_rgCATIDRequired[] = {NULL};
extern const int g_ctCATIDRequired = 0;

const char g_szLibName[] = "SnapInDesigner";


//=--------------------------------------------------------------------------=
// IntializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_ATTACH.  allows the user to do any sort of
// initialization they want to.
//
// Notes:
//
void InitializeLibrary
(
    void
)
{
    HRESULT hr = S_OK;
    int nRet = 0;
    
    //nRet = LoadString(GetResourceHandle(), IDS_WEBCLASSDESIGNER, g_szDesignerName, sizeof(g_szDesignerName));

}

//=--------------------------------------------------------------------------=
// UninitializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_DETACH.  allows the user to clean up anything
// they want.
//
// Notes:
//
void UninitializeLibrary
(
    void
)
{
    // TODO: uninitialization here.  control window class will be unregistered
    // for you, but anything else needs to be cleaned up manually.
    // Please Note that the Window 95 DLL_PROCESS_DETACH isn't quite as stable
    // as NT's, and you might crash doing certain things here ...
}


//=--------------------------------------------------------------------------=
// CheckForLicense
//=--------------------------------------------------------------------------=
// users can implement this if they wish to support Licensing.  otherwise,
// they can just return TRUE all the time.
//
// Parameters:
//    none
//
// Output:
//    BOOL            - TRUE means the license exists, and we can proceed
//                      FALSE means we're not licensed and cannot proceed
//
// Notes:
//    - implementers should use g_wszLicenseKey and g_wszLicenseLocation
//      from the top of this file to define their licensing [the former
//      is necessary, the latter is recommended]
//
BOOL CheckForLicense
(
    void
)
{
    // TODO: decide whether or not your server is licensed in this function.
    // people who don't want to bother with licensing should just return
    // true here always.  g_wszLicenseKey and g_wszLicenseLocation are
    // used by IClassFactory2 to do some of the licensing work.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CheckLicenseKey
//=--------------------------------------------------------------------------=
// when IClassFactory2::CreateInstanceLic is called, a license key is passed
// in, and then passed on to this routine.  users should return a boolean 
// indicating whether it is a valid license key or not
//
// Parameters:
//    LPWSTR          - [in] the key to check
//
// Output:
//    BOOL            - false means it's not valid, true otherwise
//
// Notes:
//
BOOL CheckLicenseKey
(
    LPWSTR pwszKey
)
{
        // Check for the unique license key (key2) or VB4 compatible key (Key1)
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// GetLicenseKey
//=--------------------------------------------------------------------------=
// returns our current license key that should be saved out, and then passed
// back to us in IClassFactory2::CreateInstanceLic
//
// Parameters:
//    none
//
// Output:
//    BSTR                 - key or NULL if Out of memory
//
// Notes:
//
BSTR GetLicenseKey
(
    void
)
{
    // Return our control unique license key
    //
    return SysAllocString(L"");
}

//=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL RegisterData(void)
{
    long    l;
    HKEY    hKey = NULL;

    // We have to register our runtime CLSID, since it's different from the
    //   design-time CLSID.

    l = RegSetValue(HKEY_CLASSES_ROOT,
                    szInstanceInfo,
                    REG_SZ,
                    szRuntimeInstCLSID,
                    sizeof(szRuntimeInstCLSID));
    if (l != ERROR_SUCCESS)
      return FALSE;

    l = RegSetValue(HKEY_CLASSES_ROOT,
                    szMiscStatusRegKey,
                    REG_SZ,
                    szMiscStatusValue,
                    ::lstrlen(szMiscStatusValue));
    if (l != ERROR_SUCCESS)
      return FALSE;
    
    l = ::RegCreateKey(HKEY_CLASSES_ROOT, 
                        szPublicSetting, 
                        &hKey);

    if(l != ERROR_SUCCESS)
        return FALSE;

    l = ::RegSetValueEx(
                    hKey,
                    TEXT("Required"),
                    0,
                    REG_DWORD,
                    (BYTE*) &dwPublicFlag,
                    sizeof(DWORD)
                   );

    ::RegCloseKey(hKey);

    if (l != ERROR_SUCCESS)
      return FALSE;

    // TODO: register any additional data here that you might wish to.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL UnregisterData
(
    void
)
{
    // TODO: any additional registry cleanup that you might wish to do.
    //
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////
// CATID Registration stuff
///////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to suck in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
// extern "C" int __cdecl _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dtoolbar.cpp ===
//=--------------------------------------------------------------------------------------
// toolbar.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Toolbar-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddToolbar()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddToolbar()
{
    HRESULT              hr = S_OK;
    IMMCToolbars        *piMMCToolbars = NULL;
    VARIANT              vtEmpty;
    IMMCToolbar         *piMMCToolbar = NULL;

    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    if (piMMCToolbars != NULL)
    {
        ::VariantInit(&vtEmpty);
        vtEmpty.vt = VT_ERROR;
        vtEmpty.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCToolbars->Add(vtEmpty, vtEmpty, &piMMCToolbar);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCToolbar);
    RELEASE(piMMCToolbars);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddMMCToolbar(CSelectionHolder *pParent, IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddMMCToolbar(CSelectionHolder *pParent, IMMCToolbar *piMMCToolbar)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pToolbar = NULL;

    ASSERT(NULL != pParent, "OnAddMMCToolbar: pParent is NULL");
    ASSERT(SEL_TOOLS_TOOLBARS == pParent->m_st, "OnAddMMCToolbar: pParent is not SEL_TOOLS_TOOLBARS");
    ASSERT(NULL != piMMCToolbar, "OnAddMMCToolbar: piMMCToolbar is NULL");

    hr = MakeNewToolbar(pParent->m_piObject.m_piMMCToolbars, piMMCToolbar, &pToolbar);
    IfFailGo(hr);

    hr = pToolbar->RegisterHolder();
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->AddToolbar(piMMCToolbar);
    IfFailGo(hr);

    hr = InsertToolbarInTree(pToolbar, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pToolbar);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pToolbar);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pToolbar);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameToolbar(CSelectionHolder *pToolbar, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameToolbar(CSelectionHolder *pToolbar, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrOldName = NULL;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_TOOLS_TOOLBARS_NAME == pToolbar->m_st, "RenameToolbar: wrong argument");

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = m_pTreeView->GetLabel(pToolbar, &bstrOldName);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->RenameToolbar(pToolbar->m_piObject.m_piMMCToolbar, bstrOldName);
    IfFailGo(hr);

    hr = pToolbar->m_piObject.m_piMMCToolbar->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pToolbar, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteToolbar(CSelectionHolder *pToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteToolbar(CSelectionHolder *pToolbar)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    BSTR                 bstrName = NULL;
    IMMCToolbars        *piMMCToolbars = NULL;
    VARIANT              vtKey;

    ::VariantInit(&vtKey);

    // Find out who the parent is
    hr = m_pTreeView->GetParent(pToolbar, &pParent);
    IfFailGo(hr);

    // Remove the ImageList from the appropriate collection
    ASSERT(SEL_TOOLS_TOOLBARS == pParent->m_st, "DeleteToolbar: expected another kind of parent");

    hr = pToolbar->m_piObject.m_piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    if (piMMCToolbars != NULL)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piMMCToolbars->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtKey);
    FREESTRING(bstrName);
    RELEASE(piMMCToolbars);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteToolbar(CSelectionHolder *pToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteToolbar(CSelectionHolder *pToolbar)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IMMCToolbars        *piMMCToolbars = NULL;
    long                 lCount = 0;

    // Delete the TypeInfo related property
    hr = m_pSnapInTypeInfo->DeleteToolbar(pToolbar->m_piObject.m_piMMCToolbar);
    IfFailGo(hr);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pToolbar, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pToolbar);
    IfFailGo(hr);

    delete pToolbar;

    // Select the next selection
    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    if (NULL != piMMCToolbars)
    {
        hr = piMMCToolbars->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piMMCToolbars);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowToolbarProperties(IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowToolbarProperties
(
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[2];

    hr = GetResourceString(IDS_TOOLB_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piMMCToolbar->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_MMCToolbarGeneralPP;
    pageClsID[1] = CLSID_MMCToolbarButtonsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar, CSelectionHolder **ppToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewToolbar
(
    IMMCToolbars      *piMMCToolbars,
    IMMCToolbar       *piMMCToolbar,
    CSelectionHolder **ppToolbar
)
{
    HRESULT              hr = S_OK;

    *ppToolbar = New CSelectionHolder(piMMCToolbar);
    if (*ppToolbar == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewToolbar(piMMCToolbars, piMMCToolbar);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewToolbar
(
    IMMCToolbars *piMMCToolbars,
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pMMCToolbarClone = NULL;

    hr = GetResourceString(IDS_TOOLBAR, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pMMCToolbarClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piMMCToolbar->put_Name(bstrName);
    IfFailGo(hr);

    hr = piMMCToolbar->put_Key(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertToolbarInTree(CSelectionHolder *pToolbar, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertToolbarInTree
(
    CSelectionHolder *pToolbar,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pToolbar->m_piObject.m_piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kToolbarIcon, pToolbar);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dtypelib.h ===
//=--------------------------------------------------------------------------------------
// dtypelib.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dynamic Type Library encapsulation
//=-------------------------------------------------------------------------------------=

#ifndef _DYNAMIC_TYPE_LIB_
#define _DYNAMIC_TYPE_LIB_



const USHORT	wctlMajorVerNum		= 1;
const USHORT	wctlMinorVerNum		= 0;


class CDynamicTypeLib : public CtlNewDelete, public CError
{
public:
    CDynamicTypeLib();
    virtual ~CDynamicTypeLib();

public:
    HRESULT Create(BSTR bstrName);
	HRESULT Attach(ITypeInfo *ptiCoClass);

protected:
	// Obtaining information about type libraries
	HRESULT GetClassTypeLibGuid(BSTR bstrClsid, GUID *pguidTypeLib);
	HRESULT GetLatestTypeLibVersion(GUID guidTypeLib, USHORT *pusMajor, USHORT *pusMinor);
	HRESULT GetClassTypeLib(BSTR bstrClsid, GUID *pguidTypeLib, USHORT *pusMajor, USHORT *pusMinor, ITypeLib **ptl);

	// Managing coclasses and their interfaces
	HRESULT CreateCoClassTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo);
	HRESULT CreateInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo);
	HRESULT CreateVtblInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo);

	HRESULT GetDefaultInterface(ITypeInfo *pSrcTypeInfo, ITypeInfo **pptiInterface);
	HRESULT GetSourceInterface(ITypeInfo *pSrcTypeInfo, ITypeInfo **pptiInterface);
	HRESULT SetBaseInterface(ICreateTypeInfo* pctiInterface, ITypeInfo* ptiBaseInterface);

	// Assigning interfaces to coclasses
	HRESULT AddInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiInterface);
	HRESULT AddEvents(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiEvents);

    HRESULT GetNameIndex(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, long *nIndex);

    HRESULT AddUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, ITypeInfo *pReturnType, DISPID dispId, long nIndex);
    HRESULT RenameUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrOldName, BSTR bstrNewName, ITypeInfo *pReturnType);
    HRESULT DeleteUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName);

    // Copying interfaces
    HRESULT GetIDispatchTypeInfo(ITypeInfo **pptiDispatch);
    HRESULT CopyDispInterface(ICreateTypeInfo *pcti, ITypeInfo *ptiTemplate);
    HRESULT CloneInterface(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo);
    HRESULT CopyFunctionDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset, USHORT *puRealOffset);
    HRESULT CopyVarDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset);
    HRESULT FixHrefTypeFuncDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, FUNCDESC *pFuncDesc);
    HRESULT FixHrefTypeVarDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, VARDESC *pVarDesc);
    HRESULT CopyHrefType(ITypeInfo *ptiSource, ITypeInfo *ptiDest, ICreateTypeInfo *pctiDest, HREFTYPE *phreftype);
    HRESULT IsReservedMethod(BSTR bstrMethodName);

protected:
    ICreateTypeLib2     *m_piCreateTypeLib2;
    ITypeLib            *m_piTypeLib;
    GUID                 m_guidTypeLib;
};

#endif  // _DYNAMIC_TYPE_LIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\errors.h ===
//=--------------------------------------------------------------------------=
// errors.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Error Codes Defined by the Designer
//
//=--------------------------------------------------------------------------=


#ifndef _ERRORS_DEFINED_
#define _ERRORS_DEFINED_


// Replacements for framework's macros.h stuff that does not work in header
// files.

#if defined(DEBUG)
extern HRESULT HrDebugTraceReturn(HRESULT hr, char *szFile, int iLine);
#define H_RRETURN(hr) return HrDebugTraceReturn(hr, __FILE__, __LINE__)
#else
#define H_RRETURN(hr) return (hr)
#endif

#define H_IfFailGoto(EXPR, LABEL) \
    { hr = (EXPR); if(FAILEDHR(hr)) goto LABEL; }

#define H_IfFailRet(EXPR) \
    { hr = (EXPR); if(FAILED(hr)) H_RRETURN(hr); }

#define IfFailGo(EXPR) IfFailGoto(EXPR, Error)


#define H_IfFalseRet(EXPR, HR) \
    { if(!(EXPR)) H_RRETURN(HR); }


// Macro to create a return code from an error name in the ID file.
// See below for examples of usage.

#define _MKERR(x)   MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)
#define MKERR(x)    _MKERR(HID_mssnapd_err_##x)


//---------------------------------------------------------------------------
//
// HOW TO ADD A NEW ERROR
//
//
// 1) Add the error to mssnapd.id.  
//    Do *not* use devid to determine the help context id, but rather use
//    the error number itself
// 2) Add a define below for the error, using the MKERR macro
// 3) You may only return Win32 error codes and snap-in defined SID_E_XXXX
//    error codes. Do not use OLE E_XXX error codes directly as the
//    system message table does not have description strings for all of these
//    errors. If any OLE E_XXXX, CO_E_XXX, CTL_E_XXX or other such errors are
//    needed then add them as SID_E errors using the procedure described
//    above. If an error comes from an outside source and you are not sure
//    if error information is available for it then return SIR_E_EXTERNAL
//    and write the error to the event log using CError::WriteEventLog (see
//    error.h).
// 
//---------------------------------------------------------------------------

// Errors defined by the snap-in designer

#define SID_E_EXCEPTION                     MKERR(Exception)
#define SID_E_OUTOFMEMORY                   MKERR(OutOfMemory)
#define SID_E_INVALIDARG                    MKERR(InvalidArg)
#define SID_E_INTERNAL                      MKERR(Internal)


#endif // _ERRORS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\guids.h ===
//=--------------------------------------------------------------------------------------
// guids.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// GUIDS the Snap-In Designer uses
//=-------------------------------------------------------------------------------------=

#ifndef _DESGUIDS_H_
#define _DESGUIDS_H_

// The Snap-In properties
// {37EC7DD0-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_SnapInDefGeneralPP, 0x37ec7dd0, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DE1-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_SnapInDefImageListPP, 0x37ec7de1, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD1-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_SnapInDefExtensionsPP, 0x37ec7dd1, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Node properties
// {37EC7DD2-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ScopeItemDefGeneralPP, 0x37ec7dd2, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DE1-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ScopeItemDefColHdrsPP, 0x37ec7de2, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Views:

// List View
// {37EC7DD3-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefGeneralPP, 0x37ec7dd3, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD4-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefImgLstsPP, 0x37ec7dd4, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD5-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefSortingPP, 0x37ec7dd5, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD6-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefColHdrsPP, 0x37ec7dd6, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// OCX View
// {37EC7DD7-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_OCXViewDefGeneralPP, 0x37ec7dd7, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// URL View
// {37EC7DD8-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_URLViewDefGeneralPP, 0x37ec7dd8, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Taskpad view
// {37EC7DD9-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_TaskpadViewDefGeneralPP, 0x37ec7dd9, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDA-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_TaskpadViewDefBackgroundPP, 0x37ec7dda, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDB-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_TaskpadViewDefTasksPP, 0x37ec7ddb, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Tools:

// ImageLists
// {37EC7DDC-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCImageListImagesPP, 0x37ec7ddc, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Color is stock property page

// Toolbars
// {37EC7DDD-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCToolbarGeneralPP, 0x37ec7ddd, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDE-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCToolbarButtonsPP, 0x37ec7dde, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDF-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCToolbarPicturePP, 0x37ec7ddf, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Menus
// {37EC7DE0-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCMenuGeneralPP, 0x37ec7de0, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);


#endif  // _DESGUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dtypelib.cpp ===
//=--------------------------------------------------------------------------------------
// dtypelib.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dynamic Type Library encapsulation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "dtypelib.h"
#include "snaputil.h"


// for ASSERT and FAIL
//
SZTHISFILE


HRESULT IsReservedMethod(BSTR bstrMethodName);


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CDynamicTypeLib()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CDynamicTypeLib::CDynamicTypeLib() : m_piCreateTypeLib2(0), m_piTypeLib(0), m_guidTypeLib(GUID_NULL)
{
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::~CDynamicTypeLib()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CDynamicTypeLib::~CDynamicTypeLib()
{
    RELEASE(m_piCreateTypeLib2);
    RELEASE(m_piTypeLib);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::Create()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::Create(BSTR bstrName)
{
	HRESULT  hr = S_OK;
    TCHAR    szTempFileName[MAX_PATH] = TEXT("");
    TCHAR    szTempPath[MAX_PATH] = TEXT("");
    WCHAR   *pwszTempFileName = NULL;
    DWORD    cchTempPath = 0;
    UINT     uiRet = 0;

    // get the temp path from the system
    cchTempPath = ::GetTempPath(sizeof(szTempPath), szTempPath);
    if (cchTempPath == 0 || cchTempPath >= sizeof(szTempPath))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    // create the temporary file name
    ::EnterCriticalSection(&g_CriticalSection);
    uiRet = GetTempFileName(szTempPath,      // path - use current directory
                            TEXT("QQ"),      // prefix
                            0,               // system should generate the unique number
                            szTempFileName); // file name returned here
    ::LeaveCriticalSection(&g_CriticalSection);
    if (uiRet == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    // allocate a buffer and convert to UNICODE
    hr = ::WideStrFromANSI(szTempFileName, &pwszTempFileName);
    IfFailGo(hr);

    hr = ::CreateTypeLib2(SYS_WIN32, pwszTempFileName, &m_piCreateTypeLib2);
    IfFailGo(hr);

	hr = ::CoCreateGuid(&m_guidTypeLib);
    IfFailGo(hr);

    hr = m_piCreateTypeLib2->SetGuid(m_guidTypeLib);
    IfFailGo(hr);

    hr = m_piCreateTypeLib2->SetVersion(wctlMajorVerNum, wctlMinorVerNum);
    IfFailGo(hr);

    if (NULL != bstrName)
    {
	    hr = m_piCreateTypeLib2->SetName(bstrName);
        IfFailGo(hr);
    }

	hr = m_piCreateTypeLib2->QueryInterface(IID_ITypeLib, (void **) &m_piTypeLib);
    IfFailGo(hr);

Error:
    if (NULL != pwszTempFileName)
        delete [] pwszTempFileName;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::Attach(ITypeInfo *ptiCoClass)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::Attach
(
	ITypeInfo *ptiCoClass
)
{
	HRESULT hr = S_OK;
	UINT    uiIndex = 0;

	RELEASE(m_piTypeLib);
	RELEASE(m_piCreateTypeLib2);

	hr = ptiCoClass->GetContainingTypeLib(&m_piTypeLib, &uiIndex);
	IfFailGo(hr);

	hr = m_piTypeLib->QueryInterface(IID_ICreateTypeLib2, reinterpret_cast<void **>(&m_piCreateTypeLib2));
	IfFailGo(hr);

Error:
	if (S_OK != hr)
	{
		RELEASE(m_piTypeLib);
		RELEASE(m_piCreateTypeLib2);
	}

    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Obtaining information about type libraries
//
/////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetClassTypeLibGuid(BSTR bstrClsid, GUID *pguidTypeLib)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a CLSID, get the corresponding typelib's GUID. The function
// searches the registry attempting to match a typelib key to the CLSID.
//
HRESULT CDynamicTypeLib::GetClassTypeLibGuid
(
    BSTR  bstrClsid,
    GUID *pguidTypeLib
)
{
    HRESULT     hr = S_OK;
    char       *szClsid = NULL;
    long        lResult = 0;
    char       *lpSubKey = "CLSID";
    HKEY        hClsid = NULL;
    HKEY        hThisClsid = NULL;
    char       *lpTypeLib = "TypeLib";
    HKEY        hTypeLibKey = NULL;
    char       *pszNullValue = "\0\0";
    DWORD       cbType = REG_SZ;
    DWORD       cbSize = 512;
    char        buffer[512];
    BSTR        bstrTypeLibClsid = NULL;

    hr = ANSIFromBSTR(bstrClsid, &szClsid);
    IfFailGo(hr);

    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, lpSubKey, 0, KEY_READ, &hClsid);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    lResult = ::RegOpenKeyEx(hClsid, szClsid, 0, KEY_READ, &hThisClsid);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    lResult = ::RegOpenKeyEx(hThisClsid, lpTypeLib, 0, KEY_READ, &hTypeLibKey);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    lResult = ::RegQueryValueEx(hTypeLibKey, pszNullValue, NULL, &cbType, reinterpret_cast<unsigned char *>(buffer), &cbSize);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    hr = BSTRFromANSI(buffer, &bstrTypeLibClsid);
    IfFailGo(hr);

    hr = ::CLSIDFromString(bstrTypeLibClsid, pguidTypeLib);
    IfFailGo(hr);

Error:
    FREESTRING(bstrTypeLibClsid);
    if (NULL != hTypeLibKey)
        ::RegCloseKey(hTypeLibKey);
    if (NULL != hThisClsid)
        ::RegCloseKey(hThisClsid);
    if (NULL != hClsid)
        ::RegCloseKey(hClsid);
    if (NULL != szClsid)
        CtlFree(szClsid);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetLatestTypeLibVersion(GUID guidTypeLib, int *piMajor, int *piMinor)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a TypeLib's GUID, get the major and minor numbers for the most current
// version.
//
HRESULT CDynamicTypeLib::GetLatestTypeLibVersion
(
    GUID    guidTypeLib,
    USHORT *pusMajor,
    USHORT *pusMinor
)
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    wchar_t     wcBuffer[512];
    char       *szClsid = NULL;
    long        lResult = 0;
    char       *lpSubKey = "TypeLib";
    HKEY        hTypeLibsKey = NULL;
    HKEY        hTypeLibKey = NULL;
    DWORD       dwIndex = 0;
    char        pszKeyName[512];
    DWORD       cbName = 512;
    FILETIME    ftLastWriteTime;
    USHORT      usMajor = 0;
    USHORT      usMinor = 0;

    ASSERT(GUID_NULL != guidTypeLib, "GetLatestTypeLibVersion: guidTypeLib is NULL");
    ASSERT(NULL != pusMajor, "GetLatestTypeLibVersion: pusMajor is NULL");
    ASSERT(NULL != pusMinor, "GetLatestTypeLibVersion: pusMinor is NULL");

    *pusMajor = 0;
    *pusMinor = 0;

    // First covert the GUID to a string representation
    iResult = ::StringFromGUID2(guidTypeLib, wcBuffer, 512);
    if (iResult <= 0)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }

    hr = ANSIFromWideStr(wcBuffer, &szClsid);
    IfFailGo(hr);

    // Open HKEY_CLASSES_ROOT\TypeLib
    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, lpSubKey, 0, KEY_READ, &hTypeLibsKey);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Open HKEY_CLASSES_ROOT\TypeLib\<TypeLibClsid>
    lResult = ::RegOpenKeyEx(hTypeLibsKey, szClsid, 0, KEY_ENUMERATE_SUB_KEYS, &hTypeLibKey);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    while (ERROR_NO_MORE_ITEMS != lResult)
    {
        lResult = ::RegEnumKeyEx(hTypeLibKey, dwIndex, pszKeyName, &cbName, NULL, NULL, NULL, &ftLastWriteTime);

        if (ERROR_NO_MORE_ITEMS != lResult)
        {
            ::sscanf(pszKeyName, "%hu.%hu", &usMajor, &usMinor);
            if (usMajor > *pusMajor)
            {
                *pusMajor = usMajor;
                *pusMinor = usMinor;
            }
            else if (usMinor > *pusMinor)
            {
                *pusMinor = usMinor;
            }
        }
        ++dwIndex;
    }

Error:
    if (NULL != szClsid)
        CtlFree(szClsid);
    if (NULL != hTypeLibKey)
        ::RegCloseKey(hTypeLibKey);
    if (NULL != hTypeLibsKey)
        ::RegCloseKey(hTypeLibsKey);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetClassTypeLib(BSTR bstrClsid, GUID *pguidTypeLib, int *piMajor, int *piMinor, ITypeLib **ptl)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a CLSID, get an ITypeLib pointer to its typelib, plus the typelib's
// GUID, major an minor version numbers.
//
HRESULT CDynamicTypeLib::GetClassTypeLib(BSTR bstrClsid, GUID *pguidTypeLib, USHORT *pusMajor, USHORT *pusMinor, ITypeLib **ptl)
{
    HRESULT hr = S_OK;

    hr = GetClassTypeLibGuid(bstrClsid, pguidTypeLib);
    IfFailGo(hr);

    hr = GetLatestTypeLibVersion(*pguidTypeLib, pusMajor, pusMinor);
    IfFailGo(hr);

    hr = ::LoadRegTypeLib(*pguidTypeLib,
                          *pusMajor,
                          *pusMinor,
                          LOCALE_SYSTEM_DEFAULT,
                          ptl);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Managing coclasses and their interfaces
//
/////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CreateCoClassTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Create a new coclass in the type library
//
HRESULT CDynamicTypeLib::CreateCoClassTypeInfo
(
    BSTR              bstrName,
    ICreateTypeInfo **ppCTInfo,
    GUID             *guidTypeInfo
)
{
    HRESULT		hr = S_OK;

    ASSERT(NULL != bstrName, "CreateCoClassTypeInfo: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "CreateCoClassTypeInfo: bstrName is empty");
    ASSERT(ppCTInfo != NULL, "CreateCoClassTypeInfo: ppCTInfo is NULL");
    ASSERT(guidTypeInfo != NULL, "CreateCoClassTypeInfo: guidTypeInfo is NULL");

    hr = m_piCreateTypeLib2->CreateTypeInfo(bstrName,
                                            TKIND_COCLASS,
                                            ppCTInfo);
    IfFailGo(hr);

    if (GUID_NULL == *guidTypeInfo)
    {
        hr = ::CoCreateGuid(guidTypeInfo);
        IfFailGo(hr);
    }

    hr = (*ppCTInfo)->SetGuid(*guidTypeInfo);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CreateInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Create a new dispatch interface
//
HRESULT CDynamicTypeLib::CreateInterfaceTypeInfo
(
    BSTR              bstrName,
    ICreateTypeInfo **ppCTInfo,
    GUID             *guidTypeInfo
)
{
    HRESULT hr = S_OK;

    ASSERT(NULL != bstrName, "CreateInterfaceTypeInfo: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "CreateInterfaceTypeInfo: bstrName is empty");
    ASSERT(ppCTInfo != NULL, "CreateInterfaceTypeInfo: ppCTInfo is NULL");
    ASSERT(guidTypeInfo != NULL, "CreateInterfaceTypeInfo: guidTypeInfo is NULL");

    hr = m_piCreateTypeLib2->CreateTypeInfo(bstrName,
                                            TKIND_DISPATCH,
                                            ppCTInfo);
    IfFailGo(hr);

    if (GUID_NULL == *guidTypeInfo)
    {
        hr = ::CoCreateGuid(guidTypeInfo);
        IfFailGo(hr);
    }

    hr = (*ppCTInfo)->SetGuid(*guidTypeInfo);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::SetBaseInterface(ICreateTypeInfo *pctiInterface, ITypeInfo *ptiBaseInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the default interface for the class pointed by pSrcTypeInfo.
//
HRESULT CDynamicTypeLib::GetDefaultInterface
(
    ITypeInfo  *pSrcTypeInfo,
    ITypeInfo **pptiInterface
)
{
    HRESULT     hr = S_OK;
    TYPEATTR   *pta = NULL;
    int         i = 0;
    int         iTypeImplFlags = 0;
    HREFTYPE    hreftype;

    ASSERT(NULL != pSrcTypeInfo, "GetDefaultInterface: pSrcTypeInfo is NULL");
    ASSERT(NULL != pptiInterface, "GetDefaultInterface: pptiInterface is NULL");

    hr = pSrcTypeInfo->GetTypeAttr(&pta);
    IfFailGo(hr);

    for (i = 0; i < pta->cImplTypes; i++)
    {
        hr = pSrcTypeInfo->GetImplTypeFlags(i, &iTypeImplFlags);
        IfFailGo(hr);

        if (iTypeImplFlags == IMPLTYPEFLAG_FDEFAULT)
        {
            hr = pSrcTypeInfo->GetRefTypeOfImplType(i, &hreftype);
            IfFailGo(hr);

            hr = pSrcTypeInfo->GetRefTypeInfo(hreftype, pptiInterface);
            IfFailGo(hr);
        }
    }

Error:
    if (NULL != pta)
        pSrcTypeInfo->ReleaseTypeAttr(pta);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetSourceInterface(ITypeInfo *pSrcTypeInfo, ITypeInfo **pptiInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the source (events) interface for the class pointed by pSrcTypeInfo.
//
HRESULT CDynamicTypeLib::GetSourceInterface
(
    ITypeInfo  *pSrcTypeInfo,
    ITypeInfo **pptiInterface
)
{
    HRESULT     hr = S_OK;
    TYPEATTR   *pta = NULL;
    int         i = 0;
    int         iTypeImplFlags = 0;
    HREFTYPE    hreftype;

    ASSERT(NULL != pSrcTypeInfo, "GetSourceInterface: pSrcTypeInfo is NULL");
    ASSERT(NULL != pptiInterface, "GetSourceInterface: pptiInterface is NULL");

    hr = pSrcTypeInfo->GetTypeAttr(&pta);
    IfFailGo(hr);

    for (i = 0; i < pta->cImplTypes; i++)
    {
        hr = pSrcTypeInfo->GetImplTypeFlags(i, &iTypeImplFlags);
        IfFailGo(hr);

        if (iTypeImplFlags == (IMPLTYPEFLAG_FSOURCE | IMPLTYPEFLAG_FDEFAULT))
        {
            hr = pSrcTypeInfo->GetRefTypeOfImplType(i, &hreftype);
            IfFailGo(hr);

            hr = pSrcTypeInfo->GetRefTypeInfo(hreftype, pptiInterface);
            IfFailGo(hr);
        }
    }

Error:
    if (NULL != pta)
        pSrcTypeInfo->ReleaseTypeAttr(pta);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::SetBaseInterface(ICreateTypeInfo *pctiInterface, ITypeInfo *ptiBaseInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::SetBaseInterface
(
	ICreateTypeInfo *pctiInterface,
	ITypeInfo       *ptiBaseInterface
)
{
    HRESULT  hr = S_OK;
    HREFTYPE hreftype = NULL;

    hr = pctiInterface->AddRefTypeInfo(ptiBaseInterface, &hreftype);
    IfFailGo(hr);

    hr = pctiInterface->AddImplType(0, hreftype);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::AddInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add the interface pointed by ptiInterface as the default interface to the
// class pointed by pctiCoClass.
//
HRESULT CDynamicTypeLib::AddInterface
(
    ICreateTypeInfo *pctiCoClass,
    ITypeInfo       *ptiInterface
)
{
    HRESULT     hr = S_OK;
    HREFTYPE    hreftype;

    ASSERT(NULL != pctiCoClass, "AddInterface: pctiCoClass is NULL");
    ASSERT(NULL != ptiInterface, "AddInterface: ptiInterface is NULL");

    hr = pctiCoClass->AddRefTypeInfo(ptiInterface, &hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->AddImplType(0, hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->SetImplTypeFlags(0, IMPLTYPEFLAG_FDEFAULT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::AddEvents(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiEvents)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add the interface pointed by ptiInterface as the default source (events)
// interface to the class pointed by pctiCoClass.
//
HRESULT CDynamicTypeLib::AddEvents
(
    ICreateTypeInfo *pctiCoClass, 
    ITypeInfo       *ptiEvents
)
{
    HRESULT     hr = S_OK;
    HREFTYPE    hreftype;

    ASSERT(NULL != pctiCoClass, "AddEvents: pctiCoClass is NULL");
    ASSERT(NULL != ptiEvents, "AddEvents: ptiEvents is NULL");

    hr = pctiCoClass->AddRefTypeInfo(ptiEvents, &hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->AddImplType(1, hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->SetImplTypeFlags(1, IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::AddUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, ITypeInfo *pReturnType, DISPID dispId, long nIndex)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add a new property with a user-defined return type to an interface of the form:
//
//  HRESULT get_<bstrName>(<pReturnType> ** <bstrName>)
//
HRESULT CDynamicTypeLib::AddUserPropertyGet
(
    ICreateTypeInfo *pctiInterface,
    BSTR             bstrName,
    ITypeInfo       *pReturnType,
    DISPID           dispId,
    long             nIndex
)
{
    HRESULT     hr = S_OK;
    VARIANT     vt;
    PARAMDESCEX pd;
	HREFTYPE	href = NULL;;
    ELEMDESC    ed;
    FUNCDESC    fd;         // new item is a funcdesc
    TYPEDESC    td;

    ASSERT(NULL != pctiInterface, "AddUserPropertyGet: pctiInterface is NULL");
    ASSERT(NULL != bstrName, "AddUserPropertyGet: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "AddUserPropertyGet: bstrName is empty");
    ASSERT(NULL != pReturnType, "AddUserPropertyGet: pReturnType is NULL");

    ::VariantInit(&vt);
    ::memset(&pd, 0, sizeof(PARAMDESCEX));
    ::memset(&ed, 0, sizeof(ELEMDESC));
    ::memset(&fd, 0, sizeof(FUNCDESC));
    ::memset(&td, 0, sizeof(TYPEDESC));

    // Describe the property being returned by this funcion
//    pd.cBytes = 4;
//    pd.varDefaultValue = vt;

	hr = pctiInterface->AddRefTypeInfo(pReturnType, &href);
    IfFailGo(hr);

//    ed.tdesc.hreftype = href;
//    ed.tdesc.vt = VT_USERDEFINED;

//    ed.paramdesc.pparamdescex = &pd;
//    ed.paramdesc.wParamFlags = IDLFLAG_FOUT | IDLFLAG_FRETVAL;

    // Set up the funcdesc
    fd.memid = dispId;                      // Function member ID
    fd.lprgelemdescParam = NULL;            // Parameter information
    fd.funckind = FUNC_DISPATCH;            // Kind of function
    fd.invkind = INVOKE_PROPERTYGET;        // Type of invocation
    fd.callconv = CC_STDCALL;               // Calling convention
	fd.wFuncFlags = FUNCFLAG_FSOURCE;

    // Set up the return value
	td.vt = VT_USERDEFINED;
	td.hreftype = href;
	fd.elemdescFunc.tdesc.lptdesc = &td;
	fd.elemdescFunc.tdesc.vt = VT_PTR;
	fd.elemdescFunc.idldesc.wIDLFlags = IDLFLAG_FOUT | IDLFLAG_FRETVAL;

    // Parameter information
    fd.cParams = 0;                         // Number of parameters
    fd.cParamsOpt = 0;                      // Number of optional parameters

    // Add the function description
    hr = pctiInterface->AddFuncDesc(nIndex, &fd);
    IfFailGo(hr);

    // The &bstrName should really be an array of OLESTR, but since we are setting only
    // one name, we cheat to makes this simpler
    hr =  pctiInterface->SetFuncAndParamNames(nIndex, &bstrName, 1);
    IfFailGo(hr);

    hr = pctiInterface->LayOut();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetNameIndex(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, long *nIndex)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return the memid of the function named bstrName in the typeinfo pointed by pcti.
//
HRESULT CDynamicTypeLib::GetNameIndex(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, long *nIndex)
{
    HRESULT     hr = S_OK;
    ITypeInfo2 *pTypeInfo = NULL;
    TYPEATTR   *pTypeAttr = NULL;
    long        x;
    FUNCDESC   *pFuncDesc = NULL;
    BSTR        bstrFuncName = NULL;
    UINT        cNames = 0;

    ASSERT(NULL != pctiDispinterface, "GetNameIndex: pctiDispinterface is NULL");
    ASSERT(NULL != bstrName, "GetNameIndex: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "GetNameIndex: bstrName is Empty");
    ASSERT(NULL != nIndex, "GetNameIndex: nIndex is NULL");

    *nIndex = -1;

    hr = pctiDispinterface->QueryInterface(IID_ITypeInfo2, (void **) &pTypeInfo);
    IfFailGo(hr);

    hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
    IfFailGo(hr);

    for (x = 0; x < pTypeAttr->cFuncs; x++)
    {
        hr = pTypeInfo->GetFuncDesc(x, &pFuncDesc);
        IfFailGo(hr);

        hr = pTypeInfo->GetNames(pFuncDesc->memid, &bstrFuncName, 1, &cNames);
        IfFailGo(hr);

        if (::_wcsicmp(bstrName, bstrFuncName) == 0)
        {
            *nIndex = x;
            break;
        }

        // Clean up memory after each iteration
        if (NULL != pFuncDesc)
        {
            pTypeInfo->ReleaseFuncDesc(pFuncDesc);
            pFuncDesc = NULL;
        }

        FREESTRING(bstrFuncName);
        bstrFuncName = NULL;
    }

Error:
    FREESTRING(bstrFuncName);
    if (NULL != pFuncDesc)
        pTypeInfo->ReleaseFuncDesc(pFuncDesc);
    if (NULL != pTypeAttr)
        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
    RELEASE(pTypeInfo);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::RenameUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrOldName, BSTR bstrNewName, GUID guidReturnType)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::RenameUserPropertyGet
(
    ICreateTypeInfo *pctiDispinterface,
    BSTR             bstrOldName,
    BSTR             bstrNewName,
    ITypeInfo       *pReturnType
)
{
    HRESULT             hr = S_OK;
    long                lIndex = 0;
    ICreateTypeInfo2   *pCreateTypeInfo2 = NULL;
    FUNCDESC           *pfuncdesc = NULL;           
    ITypeInfo          *pti = NULL;

    ASSERT(NULL != pctiDispinterface, "RenameUserPropertyGet: pctiDispinterface is NULL");
    ASSERT(NULL != bstrOldName, "RenameUserPropertyGet: bstrOldName is NULL");
    ASSERT(::SysStringLen(bstrOldName) > 0, "RenameUserPropertyGet: bstrOldName is Empty");
    ASSERT(NULL != bstrNewName, "RenameUserPropertyGet: bstrNewName is NULL");
    ASSERT(::SysStringLen(bstrNewName) > 0, "RenameUserPropertyGet: bstrNewName is Empty");
    ASSERT(NULL != pReturnType, "RenameUserPropertyGet: pReturnType is NULL");

    hr = GetNameIndex(pctiDispinterface, bstrOldName, &lIndex);
    IfFailGo(hr);

    if (-1 != lIndex)
    {
        hr = pctiDispinterface->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&pti));
        IfFailGo(hr);

        // Get the funcdesc so we can reuse the memid
        hr = pti->GetFuncDesc(lIndex, &pfuncdesc);
        IfFailGo(hr);

        hr = pctiDispinterface->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&pCreateTypeInfo2));
        IfFailGo(hr);

        // Remove the function from the interface
        hr = pCreateTypeInfo2->DeleteFuncDesc(lIndex);
        IfFailGo(hr);

        // Re-add the function to the interface
        hr = AddUserPropertyGet(pctiDispinterface,
                                bstrNewName,
                                pReturnType,
                                pfuncdesc->memid,
                                lIndex);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(pCreateTypeInfo2);
    if (NULL != pti)
    {
        if (NULL != pfuncdesc)
            pti->ReleaseFuncDesc(pfuncdesc);
    }
    QUICK_RELEASE(pti);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::DeleteUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::DeleteUserPropertyGet
(
    ICreateTypeInfo *pctiDispinterface,
    BSTR             bstrName
)
{
    HRESULT             hr = S_OK;
    long                lIndex = 0;
    ICreateTypeInfo2   *pCreateTypeInfo2 = NULL;
    ITypeInfo          *pReturnType = NULL;

    ASSERT(NULL != pctiDispinterface, "DeleteUserPropertyGet: pctiDispinterface is NULL");
    ASSERT(NULL != bstrName, "DeleteUserPropertyGet: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "DeleteUserPropertyGet: bstrName is Empty");

    hr = GetNameIndex(pctiDispinterface, bstrName, &lIndex);
    IfFailGo(hr);

    if (-1 != lIndex)
    {
	    hr = pctiDispinterface->QueryInterface(IID_ICreateTypeInfo2, (void **) &pCreateTypeInfo2);
        IfFailGo(hr);

	    hr = pCreateTypeInfo2->DeleteFuncDesc(lIndex);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(pReturnType);
    QUICK_RELEASE(pCreateTypeInfo2);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetIDispatchTypeInfo(ITypeInfo **pptiDispatch)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::GetIDispatchTypeInfo(ITypeInfo **pptiDispatch)
{
    HRESULT     hr = S_OK;
    ITypeLib   *pTypeLib = NULL;

    hr = ::LoadRegTypeLib(IID_StdOle, STDOLE2_MAJORVERNUM, STDOLE2_MINORVERNUM, STDOLE2_LCID, &pTypeLib);
    IfFailGo(hr);

    hr = pTypeLib->GetTypeInfoOfGuid(IID_IDispatch, pptiDispatch);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(pTypeLib);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyDispInterface(ICreateTypeInfo *pcti, ITypeInfo *ptiTemplate)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CopyDispInterface
(
    ICreateTypeInfo *pcti,
    ITypeInfo       *ptiTemplate
)
{
    HRESULT         hr = S_OK;
    ITypeInfo      *ptiDispatch = NULL;
    HREFTYPE        hreftype;

    ASSERT(NULL != pcti, "CopyDispInterface: pcti is NULL");
    ASSERT(NULL != ptiTemplate, "CopyDispInterface: ptiTemplate is NULL");

    hr = GetIDispatchTypeInfo(&ptiDispatch);
    IfFailGo(hr);

    hr = pcti->AddRefTypeInfo(ptiDispatch, &hreftype);
    IfFailGo(hr);

    hr = pcti->AddImplType(0, hreftype);
    IfFailGo(hr);

    // Make the new interface inherit from our static interface [via cloning]
    hr = CloneInterface(ptiTemplate, pcti);
    IfFailGo(hr);

Error:
	QUICK_RELEASE(ptiDispatch);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CloneInterface(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a dispinterface typeinfo, copy it into a new one
//
// Parameters:
//    ITypeInfo *           - [in]  dude to copy
//    ICreateTypeInfo *     - [in]  guy to copy to.  should be blank
//
// Output:
//    HRESULT
//
// Notes:
//    - yes, this routine should be a little broader and go create the dest
//      typeinfo and guids itself, but this is a little more straightforward
//
HRESULT CDynamicTypeLib::CloneInterface
(
    ITypeInfo       *piTypeInfo,
    ICreateTypeInfo *piCreateTypeInfo
)
{
    HRESULT             hr = S_OK;
    ITypeInfo2         *piTypeInfo2 = NULL;
    ICreateTypeInfo2   *piCreateTypeInfo2 = NULL;
    TYPEATTR           *pTypeAttr = NULL;
    USHORT              x = 0;
    USHORT              offset = 0;

    ASSERT(NULL != piTypeInfo, "CloneInterface: piTypeInfo is NULL");
    ASSERT(NULL != piCreateTypeInfo, "CloneInterface: piCreateTypeInfo is NULL");

    hr = piTypeInfo->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void **>(&piTypeInfo2));
    IfFailGo(hr);

    hr = piCreateTypeInfo->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&piCreateTypeInfo2));
    IfFailGo(hr);

    // get some information about the interface we're going to copy:
    hr = piTypeInfo2->GetTypeAttr(&pTypeAttr);
    IfFailGo(hr);

    offset = 0;

    // iterate through the funcdescs and copy them over
    for (x = 0; x < pTypeAttr->cFuncs; x++)
    {
        hr = CopyFunctionDescription(piTypeInfo2, piCreateTypeInfo2, x, &offset);
        IfFailGo(hr);
    }

    // okay, now copy over the vardescs
    //
    for (x = 0; x < pTypeAttr->cVars; x++)
    {
        hr = CopyVarDescription(piTypeInfo2, piCreateTypeInfo2, x);
        IfFailGo(hr);
    }

Error:
    if (NULL != pTypeAttr)
        piTypeInfo2->ReleaseTypeAttr(pTypeAttr);
    RELEASE(piTypeInfo2);
    RELEASE(piCreateTypeInfo2);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CreateVtblInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CreateVtblInterfaceTypeInfo
(
    BSTR              bstrName,
    ICreateTypeInfo **ppCTInfo,
    GUID             *guidTypeInfo
)
{
	HRESULT		hr = S_OK;

    ASSERT(NULL != bstrName,             "CreateVtblInterfaceTypeInfo: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "CreateVtblInterfaceTypeInfo: bstrName is empty");
    ASSERT(ppCTInfo != NULL,             "CreateVtblInterfaceTypeInfo: ppCTInfo is NULL");
    ASSERT(guidTypeInfo != NULL,         "CreateVtblInterfaceTypeInfo: guidTypeInfo is NULL");

    hr = m_piCreateTypeLib2->CreateTypeInfo(bstrName, TKIND_INTERFACE, ppCTInfo);
    IfFailGo(hr);

    if (GUID_NULL == *guidTypeInfo)
    {
        hr = ::CoCreateGuid(guidTypeInfo);
        IfFailGo(hr);
    }

    hr = (*ppCTInfo)->SetGuid(*guidTypeInfo);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyFunctionDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset, USHORT *puRealOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CopyFunctionDescription
(
    ITypeInfo2       *piTypeInfo2,
    ICreateTypeInfo2 *piCreateTypeInfo2,
    USHORT            uOffset,
    USHORT           *puRealOffset
)
{
    HRESULT     hr = S_OK;
    FUNCDESC   *pFuncDesc = NULL;
    MEMBERID    memid = 0;
    BSTR        rgNames[16] = {NULL};
    UINT        cNames = 0;
    BSTR        bstrDocString = NULL;
    DWORD       ulStringContext = 0;
    USHORT      y;

    ASSERT(NULL != piTypeInfo2, "CopyFunctionDescription: piTypeInfo2 is NULL");
    ASSERT(NULL != piCreateTypeInfo2, "CopyFunctionDescription: piCreateTypeInfo2 is NULL");
    ASSERT(NULL != puRealOffset, "CopyFunctionDescription: puRealOffset is NULL");

    // Get the fundesc
    hr = piTypeInfo2->GetFuncDesc(uOffset, &pFuncDesc);
    IfFailGo(hr);

    memid = pFuncDesc->memid;

    ::memset(rgNames, 0, sizeof(rgNames));
    hr = piTypeInfo2->GetNames(memid, rgNames, 16, &cNames);
    IfFailGo(hr);

    hr = IsReservedMethod(rgNames[0]);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        // copy the fundesc
        hr = FixHrefTypeFuncDesc(piTypeInfo2, piCreateTypeInfo2, pFuncDesc);
        IfFailGo(hr);

        hr = piCreateTypeInfo2->AddFuncDesc(*puRealOffset, pFuncDesc);
        IfFailGo(hr);

        // then copy the names for it.
        hr = piCreateTypeInfo2->SetFuncAndParamNames(*puRealOffset, rgNames, cNames);
        IfFailGo(hr);

        // now copy over the helpstring information
        hr = piTypeInfo2->GetDocumentation2(memid, LOCALE_SYSTEM_DEFAULT, &bstrDocString, &ulStringContext, NULL);
        IfFailGo(hr);

        if (NULL != bstrDocString)
        {
            hr = piCreateTypeInfo2->SetFuncDocString(*puRealOffset, bstrDocString);
            IfFailGo(hr);

            hr = piCreateTypeInfo2->SetFuncHelpStringContext(*puRealOffset, ulStringContext);
            IfFailGo(hr);
        }

        (*puRealOffset)++;
    }

Error:
    if (NULL != pFuncDesc)
        piTypeInfo2->ReleaseFuncDesc(pFuncDesc);

    FREESTRING(bstrDocString);
    for (y = 0; y < sizeof(rgNames) / sizeof(BSTR); y++)
        FREESTRING(rgNames[y]);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyVarDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CopyVarDescription
(
    ITypeInfo2       *piTypeInfo2,
    ICreateTypeInfo2 *piCreateTypeInfo2,
    USHORT            uOffset
)
{
    HRESULT     hr = S_OK;
    VARDESC    *pVarDesc = NULL;
    BSTR        rgNames[16] = {NULL};
    UINT        cNames = 0;
    BSTR        bstrDocString = NULL;
    DWORD       ulStringContext = 0;

    ASSERT(NULL != piTypeInfo2, "CopyVarDescription: piTypeInfo2 is NULL");
    ASSERT(NULL != piCreateTypeInfo2, "CopyVarDescription: piCreateTypeInfo2 is NULL");

    hr = piTypeInfo2->GetVarDesc(uOffset, &pVarDesc);
    IfFailGo(hr);

    hr = FixHrefTypeVarDesc(piTypeInfo2, piCreateTypeInfo2, pVarDesc);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->AddVarDesc(uOffset, pVarDesc);
    IfFailGo(hr);

    // copy the name
    rgNames[0] = NULL;
    hr = piTypeInfo2->GetNames(pVarDesc->memid, rgNames, 1, &cNames);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetVarName(uOffset, rgNames[0]);
    IfFailGo(hr);

    // now copy over the documentation
    hr = piTypeInfo2->GetDocumentation2(pVarDesc->memid, LOCALE_SYSTEM_DEFAULT, &bstrDocString, &ulStringContext, NULL);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetVarDocString(uOffset, bstrDocString);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetVarHelpStringContext(uOffset, ulStringContext);
    IfFailGo(hr);

Error:
    if (NULL != pVarDesc)
        piTypeInfo2->ReleaseVarDesc(pVarDesc);
    FREESTRING(rgNames[0]);
    FREESTRING(bstrDocString);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::FixHrefTypeFuncDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, FUNCDESC *pFuncDesc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// okay, this is pretty ridiculous.  OLE automation apparantly isn't very
// bright and when we're copying over a funcdesc that has an HREFTYPE in it,
// it can't resolve it.  thus, we have to go and set up the HREFTYPE
// ourselves to make things work.
//
// this is just stupid.
//
// Parameters:
//    ITypeInfo *               - [in]  dude we're copying from
//    ICreateTypeInfo *         - [in]  dude we're copying to
//    FUNCDESC *                - [in]  funcdesc we wanna copy.
//
HRESULT CDynamicTypeLib::FixHrefTypeFuncDesc
(
    ITypeInfo       *piTypeInfo,
    ICreateTypeInfo *piCreateTypeInfo,
    FUNCDESC        *pFuncDesc
)
{
    HRESULT     hr = S_OK;
    ITypeInfo  *pti = NULL;
    TYPEDESC   *ptd = NULL;
    short       x = 0;

    ASSERT(NULL != piTypeInfo, "FixHrefTypeFuncDesc: piTypeInfo is NULL");
    ASSERT(NULL != piCreateTypeInfo, "FixHrefTypeFuncDesc: piCreateTypeInfo is NULL");
    ASSERT(NULL != pFuncDesc, "FixHrefTypeFuncDesc: pFuncDesc is NULL");

    // we have to work with ITypeInfo, not ICreateTypeInfo
    hr = piCreateTypeInfo->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&pti));
    IfFailGo(hr);

    // Now look through the funcdesc to see if there a userdefined
    // type anywhere. First, try the return value.
    ptd = &(pFuncDesc->elemdescFunc.tdesc);
    while (VT_PTR == ptd->vt)
        ptd = ptd->lptdesc;

    // If it's a userdefined type, copy over the hreftype
    if (VT_USERDEFINED == ptd->vt)
    {
        hr = CopyHrefType(piTypeInfo, pti, piCreateTypeInfo, &(ptd->hreftype));
        IfFailGo(hr);
    }

    // Now whip through the parameters:
    for (x = 0; x < pFuncDesc->cParams; x++)
    {
        ptd = &(pFuncDesc->lprgelemdescParam[x].tdesc);
        while (VT_PTR == ptd->vt)
            ptd = ptd->lptdesc;

        // If it's a userdefined type, copy over the hreftype
        if (VT_USERDEFINED == ptd->vt)
        {
            hr = CopyHrefType(piTypeInfo, pti, piCreateTypeInfo, &(ptd->hreftype));
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(pti);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::FixHrefTypeVarDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, VARDESC *pVarDesc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// check out the comment for FixHrefTypeFuncDesc.  this sucks.
//
// Parameters:
//    ITypeInfo *               - [in]
//    ICreateTypeInfo *         - [in]
//    VARDESC *                 - [in]
//
HRESULT CDynamicTypeLib::FixHrefTypeVarDesc
(
    ITypeInfo       *piTypeInfo,
    ICreateTypeInfo *piCreateTypeInfo,
    VARDESC         *pVarDesc
)
{
    HRESULT     hr = S_OK;
    ITypeInfo  *pti = NULL;
    TYPEDESC   *ptd = NULL;

    ASSERT(NULL != piTypeInfo, "FixHrefTypeVarDesc: piTypeInfo is NULL");
    ASSERT(NULL != piCreateTypeInfo, "FixHrefTypeVarDesc: piCreateTypeInfo is NULL");
    ASSERT(NULL != pVarDesc, "FixHrefTypeVarDesc: pVarDesc is NULL");

    // We have to work with ITypeInfo, not ICreateTypeInfo
    hr = piCreateTypeInfo->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&pti));
    IfFailGo(hr);

    // Look in the vardesc for VT_USERDEFINED
    ptd = &(pVarDesc->elemdescVar.tdesc);
    while (VT_PTR == ptd->vt)
        ptd = ptd->lptdesc;

    if (VT_USERDEFINED == ptd->vt)
    {
        hr = CopyHrefType(piTypeInfo, pti, piCreateTypeInfo, &(ptd->hreftype));
        IfFailGo(hr);
    }

Error:
    RELEASE(pti);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyHrefType(ITypeInfo *ptiSource, ITypeInfo *ptiDest, ICreateTypeInfo *pctiDest, HREFTYPE *phreftype)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// more of the joy that is ole automation.
//
// Parameters:
//    ITypeInfo *           - [in]     source ti
//    ITypeInfo *           - [in]     dest ti
//    ICreateTypeInfo *     - [in]     dest ti
//    HREFTYPE *            - [in/out] hreftype from old typeinfo
//
HRESULT CDynamicTypeLib::CopyHrefType
(
    ITypeInfo       *ptiSource,
    ITypeInfo       *ptiDest,
    ICreateTypeInfo *pctiDest,
    HREFTYPE        *phreftype
)
{
    HRESULT     hr = S_OK;
    ITypeInfo  *ptiRef = NULL;

    ASSERT(NULL != ptiSource, "CopyHrefType: ptiSource is NULL");
    ASSERT(NULL != ptiDest, "CopyHrefType: ptiDest is NULL");
    ASSERT(NULL != pctiDest, "CopyHrefType: pctiDest is NULL");
    ASSERT(NULL != phreftype, "CopyHrefType: phreftype is NULL");

    hr = ptiSource->GetRefTypeInfo(*phreftype, &ptiRef);
    IfFailGo(hr);

    hr = pctiDest->AddRefTypeInfo(ptiRef, phreftype);
    IfFailGo(hr);

Error:
    RELEASE(ptiRef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::IsReservedMethod(BSTR bstrMethodName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return true if bstrMethodName belongs to either IUnknown's or IDispatch's
// name space.
//
static char	*g_reserved[] = {
	"QueryInterface",
	"AddRef",
	"Release",
	"GetIDsOfNames",
	"GetTypeInfo",
	"GetTypeInfoCount",
	"Invoke",
	"RemoteInvoke",
	NULL
};


HRESULT CDynamicTypeLib::IsReservedMethod
(
    BSTR bstrMethodName
)
{
    HRESULT  hr = S_OK;
    char    *pszMethodName = NULL;
    int      index = 0;

    hr = ANSIFromBSTR(bstrMethodName, &pszMethodName);
    IfFailGo(hr);

    hr = S_FALSE;

    for (index = 0; g_reserved[index] != NULL; ++index)
    {
        if (0 == ::strcmp(g_reserved[index], pszMethodName))
        {
            hr = S_OK;
            break;
        }
    }

Error:
    if (NULL != pszMethodName)
        CtlFree(pszMethodName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\extend.cpp ===
//=--------------------------------------------------------------------------------------
// extend.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Extension-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"
#include "psnode.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddExtendedSnapIn(CSelectionHolder *pParent, IExtendedSnapIn *piExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddExtendedSnapIn(CSelectionHolder *pParent, IExtendedSnapIn *piExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pExtendedSnapIn = NULL;
    BSTR                 bstrName = NULL;
    TCHAR               *pszName = NULL;

    pExtendedSnapIn = New CSelectionHolder(piExtendedSnapIn);
    if (NULL == pExtendedSnapIn)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Use the key as the name here because this function is called during the
    // update notification when the available nodes dialog (psextend.cpp,
    // CSnapInAvailNodesPage::AddSnapIn()) calls
    // SnapInDesignerDef.ExtensionDefs.ExtendedSnapIns.Add. The key will be the
    // node type GUID.

    hr = piExtendedSnapIn->get_Key(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kClosedFolderIcon, pExtendedSnapIn);
    IfFailGo(hr);

    hr = pExtendedSnapIn->RegisterHolder();
    IfFailGo(hr);

    hr = PopulateExtendedSnapIn(pExtendedSnapIn);
    IfFailGo(hr);

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


HRESULT CSnapInDesigner::DeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    IExtendedSnapIns *piExtendedSnapIns = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DeleteExtendedSnapIn: wrong argument");

    // Need to remove the extended snapin from
    // SnapInDesignerDef.ExtensionDefs.ExtendedSnapIns.

    IfFailGo(m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs));

    IfFailGo(piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns));

    IfFailGo(pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_Index(&varIndex.lVal));
    varIndex.vt = VT_I4;

    // The remove call will generate an IObjectModeHost::Delete() call that will
    // be handled in CSnapInDesigner::Delete(). It will in turn call
    // CSnapInDesigner::OnDeleteExtendedSnapIn() (below) which will remove the
    // treeview node.

    IfFailGo(piExtendedSnapIns->Remove(varIndex));

Error:
    QUICK_RELEASE(piExtensionDefs);
    QUICK_RELEASE(piExtendedSnapIns);
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pContextMenus = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DeleteExtendedSnapIn: wrong argument");

    // Need to remove the node and all of its children from the treeview.

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_CC_ROOT,
                           &pContextMenus));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_CC_NEW, pContextMenus));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_CC_TASK, pContextMenus));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_PP_ROOT, pExtendedSnapIn));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_TASKPAD, pExtendedSnapIn));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_TOOLBAR, pExtendedSnapIn));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_NAMESPACE, pExtendedSnapIn));

    IfFailGo(m_pTreeView->DeleteNode(pExtendedSnapIn));

    delete pExtendedSnapIn;

    // Change the selection to <root>\Extensions

    IfFailGo(OnSelectionChanged(m_pRootExtensions));

    IfFailGo(m_pTreeView->SelectItem(m_pRootExtensions));

Error:
    RRETURN(hr);
}



HRESULT CSnapInDesigner::DeleteExtensionNode
(
    SelectionType     stExtensionType,
    CSelectionHolder *pParent
)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pExtension = NULL;

    IfFailGo(FindExtension(pParent, stExtensionType, &pExtension));

    if (NULL != pExtension)
    {
        IfFailGo(m_pTreeView->DeleteNode(pExtension));

        delete pExtension;
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameExtendedSnapIn(CSelectionHolder *pExtendedSnapIn, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Extendend snap-in names are displayed as the node type GUID followed by the
// node type name
//
HRESULT CSnapInDesigner::RenameExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT  hr = S_OK;
    char    *pszDisplayName = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "RenameExtendedSnapIn: wrong argument");

    IfFailGo(::GetExtendedSnapInDisplayName(pExtendedSnapIn->m_piObject.m_piExtendedSnapIn,
                                            &pszDisplayName));

    hr = m_pTreeView->ChangeText(pExtendedSnapIn, pszDisplayName);
    IfFailGo(hr);

Error:
    if (NULL != pszDisplayName)
        CtlFree(pszDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_CC_NEW == pExtendedSnapIn->m_st, "DeleteExtendedSnCtxMnNew: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNewMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pNewMenu = NULL;
    CSelectionHolder *pContextMenus = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionTaskMenu: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_CC_ROOT,
                           &pContextMenus));

    IfFailGo(FindExtension(pContextMenus, SEL_EEXTENSIONS_CC_NEW,
                           &pNewMenu));

    hr = m_pTreeView->DeleteNode(pNewMenu);
    IfFailGo(hr);

    delete pNewMenu;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_CC_TASK == pExtendedSnapIn->m_st, "DeleteExtensionTaskMenu: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pContextMenus = NULL;
    CSelectionHolder *pTaskMenu = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionTaskMenu: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_CC_ROOT,
                           &pContextMenus));

    IfFailGo(FindExtension(pContextMenus, SEL_EEXTENSIONS_CC_TASK,
                           &pTaskMenu));

    hr = m_pTreeView->DeleteNode(pTaskMenu);
    IfFailGo(hr);

    delete pTaskMenu;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_PP_ROOT == pExtendedSnapIn->m_st, "DeleteExtensionPropertyPages: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsPropertyPages(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pPropertyPages = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionPropertyPages: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_PP_ROOT,
                           &pPropertyPages));

    hr = m_pTreeView->DeleteNode(pPropertyPages);
    IfFailGo(hr);

    delete pPropertyPages;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_TASKPAD == pExtendedSnapIn->m_st, "DeleteExtensionTaskpad: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskpad(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTaskpad = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionTaskpad: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_TASKPAD,
                           &pTaskpad));

    hr = m_pTreeView->DeleteNode(pTaskpad);
    IfFailGo(hr);

    delete pTaskpad;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_TOOLBAR == pExtendedSnapIn->m_st, "DeleteExtensionToolbar: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsToolbar(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pToolbar = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionToolbar: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_TOOLBAR,
                           &pToolbar));

    hr = m_pTreeView->DeleteNode(pToolbar);
    IfFailGo(hr);

    delete pToolbar;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAMESPACE == pExtendedSnapIn->m_st, "DeleteExtensionNameSpace: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNameSpace(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pNameSpace = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionNameSpace: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_NAMESPACE,
                           &pNameSpace));

    hr = m_pTreeView->DeleteNode(pNameSpace);
    IfFailGo(hr);

    delete pNameSpace;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Extending myself
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_NEW_MENU == pExtendedSnapIn->m_st, "DeleteMyExtensdsNewMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsNewMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtensdsNewMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_NEW_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_TASK_MENU == pExtendedSnapIn->m_st, "DeleteMyExtensdsTaskMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsTaskMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsTaskMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_TASK_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_TOP_MENU == pExtendedSnapIn->m_st, "DeleteMyExtendsTopMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsTopMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsTopMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_TOP_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_VIEW_MENU == pExtendedSnapIn->m_st, "DeleteMyExtendsViewMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsViewMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsViewMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_VIEW_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_PPAGES == pExtendedSnapIn->m_st, "DeleteMyExtendsPPages: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsPropertyPages(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsPPages: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_PPAGES, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_TOOLBAR == pExtendedSnapIn->m_st, "DeleteMyExtendsToolbar: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsToolbar(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsToolbar: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_TOOLBAR, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_NAMESPACE == pExtendedSnapIn->m_st, "DeleteMyExtendsNameSpace: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsNameSpace(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsNameSpace: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_NAMESPACE, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindMyExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::FindMyExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension)
{
    RRETURN(FindExtension(m_pRootMyExtensions, stExtensionType, ppExtension));
}




//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Extending other Snap-Ins
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


HRESULT CSnapInDesigner::DoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionCtxMenuNew: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNewMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pCtxMenuNew = NULL;
    CSelectionHolder    *pChild = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionNewMenu: pExtendedSnapIn is NULL");

    hr = m_pTreeView->GetFirstChildNode(pExtendedSnapIn, &pChild);
    IfFailGo(hr);

    while (SEL_EEXTENSIONS_CC_ROOT != pChild->m_st)
    {
        hr = m_pTreeView->GetNextChildNode(pChild, &pChild);
        IfFailGo(hr);
    }

    ASSERT(NULL != pChild, "DoExtensionCtxMenuNew: Could not find parent node");
    ASSERT(SEL_EEXTENSIONS_CC_ROOT == pChild->m_st, "DoExtensionCtxMenuNew: Found wrong parent node");

    // Create the tree node for Extensions/<Extended snap-in>/Context Menus/New
    hr = GetResourceString(IDS_EXT_CTX_MENU_NEW, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pCtxMenuNew = New CSelectionHolder(SEL_EEXTENSIONS_CC_NEW, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pCtxMenuNew)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pChild, kClosedFolderIcon, pCtxMenuNew);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionCtxMenuTask: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pCtxMenuTask = NULL;
    CSelectionHolder    *pChild = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionTaskMenu: pExtendedSnapIn is NULL");

    hr = m_pTreeView->GetFirstChildNode(pExtendedSnapIn, &pChild);
    IfFailGo(hr);

    while (SEL_EEXTENSIONS_CC_ROOT != pChild->m_st)
    {
        hr = m_pTreeView->GetNextChildNode(pChild, &pChild);
        IfFailGo(hr);
    }

    ASSERT(NULL != pChild, "DoExtensionCtxMenuTask: Could not find parent node");
    ASSERT(SEL_EEXTENSIONS_CC_ROOT == pChild->m_st, "DoExtensionCtxMenuTask: Found wrong parent node");

    // Create the tree node for Extensions/<Extended snap-in>/Context Menus/New
    hr = GetResourceString(IDS_EXT_CTX_MENU_TASK, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pCtxMenuTask = New CSelectionHolder(SEL_EEXTENSIONS_CC_TASK, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pCtxMenuTask)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pChild, kClosedFolderIcon, pCtxMenuTask);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionPropertyPages: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsPropertyPages(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pPropertyPages = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionPropertyPages: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_PAGES, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pPropertyPages = New CSelectionHolder(SEL_EEXTENSIONS_PP_ROOT, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pPropertyPages)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pPropertyPages);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtension